{type="directory",setuser=false,created=1740881294724,worldPermissions={write=false,read=true,execute=true},contents={var={type="directory",setuser=false,created=1740881290993,worldPermissions={write=false,read=true,execute=true},contents={lib={type="directory",setuser=false,created=1740881294683,worldPermissions={write=false,read=true,execute=true},contents={dpkg={type="directory",setuser=false,created=1740881294691,worldPermissions={write=false,read=true,execute=true},contents={info={type="directory",created=1740881294685,worldPermissions={write=false,read=true,execute=true},contents={["aes.conffiles"]={type="file",created=1740881291113,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291113,size=0},["typescript.md5sums"]={type="file",created=1740881294304,worldPermissions={execute=true,read=true,write=false},data="55e604cccc5b1b075d8940937b8e6259  lib/typescript.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294304,size=53},["usermgr.postinst"]={type="file",created=1740881294436,worldPermissions={execute=true,read=true,write=false},data="if ... == \"configure\" then\n    coroutine.yield(\"syscall\", \"chmod\", \"/usr/bin/login.lua\", nil, {setuser = true})\n    coroutine.yield(\"syscall\", \"chmod\", \"/usr/bin/passwd.lua\", nil, {setuser = true})\n    coroutine.yield(\"syscall\", \"chmod\", \"/usr/bin/su.lua\", nil, {setuser = true})\n    coroutine.yield(\"syscall\", \"chmod\", \"/usr/bin/sudo.lua\", nil, {setuser = true})\n    return true\nelse return true end",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294436,size=400},["startmgr.conffiles"]={type="file",created=1740881294010,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294010,size=0},["yellowbox.postinst"]={type="file",created=1740881294685,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294685,size=0},["githubfs.list"]={type="file",created=1740881292319,worldPermissions={execute=true,read=true,write=false},data="/\n/lib/\n/lib/fuse/\n/lib/fuse/githubfs.lua\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man7/\n/usr/share/man/man7/githubfs.md\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292319,size=129},["spanfs.list"]={type="file",created=1740881293900,worldPermissions={execute=true,read=true,write=false},data="/\n/lib/\n/lib/modules/\n/lib/modules/spanfs.lua\n/sbin/\n/sbin/mkspanfs.lua\n/sbin/spanadd.lua\n/sbin/spaninfo.lua\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man7/\n/usr/share/man/man7/spanfs.md\n/usr/share/man/man8/\n/usr/share/man/man8/mkspanfs.md\n/usr/share/man/man8/spanadd.md\n/usr/share/man/man8/spaninfo.md\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293900,size=310},["yellowbox.conffiles"]={type="file",created=1740881294684,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294684,size=0},["dpkg.conffiles"]={type="file",created=1740881291973,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291973,size=0},["yellowbox.list"]={type="file",created=1740881294684,worldPermissions={execute=true,read=true,write=false},data="/\n/bin/\n/bin/yellowbox.lua\n/etc/\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/yellowbox.service\n/lib/\n/lib/modules/\n/lib/modules/yellowbox.lua\n/lib/yellowbox.lua\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man1/\n/usr/share/man/man1/yellowbox.md\n/usr/share/man/man7/\n/usr/share/man/man7/yellowbox.md\n/var/\n/var/lib/\n/var/lib/yellowbox/\n/var/lib/yellowbox/rom/\n/var/lib/yellowbox/startup.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294684,size=408},["fatfs.conffiles"]={type="file",created=1740881292095,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292095,size=0},["libdeflate.conffiles"]={type="file",created=1740881292672,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292672,size=0},["yahtcc.list"]={type="file",created=1740881294559,worldPermissions={execute=true,read=true,write=false},data="/\n/usr/\n/usr/bin/\n/usr/bin/yahtcc.lua\n/usr/share/\n/usr/share/man/\n/usr/share/man/man6/\n/usr/share/man/man6/yahtcc.md\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294559,size=117},["usermgr.md5sums"]={type="file",created=1740881294435,worldPermissions={execute=true,read=true,write=false},data="b9639d9007a11093ec18491955fa1e73  usr/bin/login.lua\n6889f3f36a1656f227e07725ff744a4f  usr/bin/passwd.lua\n8e3f4a32f644fb9e3bf1cf03bf409ed1  usr/bin/su.lua\na5753c9417f97ba3db5643e832d4081e  etc/motd\n1953929dcde52061f67ee4bc1b58a580  usr/bin/userdel.lua\n30ad13f1feab0ef81ec18681b7169906  usr/bin/useradd.lua\naf38a0fd306e366e0b804ff0b46674a1  usr/libexec/usermgr.lua\nd41d8cd98f00b204e9800998ecf8427e  etc/passwd\naf3c31f5dad89603d41beb445629bdb9  etc/skel/.cashrc\nd41d8cd98f00b204e9800998ecf8427e  etc/shadow\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/usermod.md\n20e62d30ab6ebfe3b09bb0356c20e458  etc/startmgr/system/usermgr.service\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/usermgr.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/userdel.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man5/passwd.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man3/usermgr.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/login.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man5/shadow.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/useradd.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/su.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/passwd.md\n4adde33f29a34744772eeb0c470d34cf  usr/bin/usermod.lua\n82623dc508d076c29b0bb73deb041330  usr/lib/usermgr.lua\n411b0f50d7cf8abf5dfefce9268fbe62  etc/startmgr/system/login.service\n347b4ebeab0ca5ff710065ae20ebe0cc  usr/bin/sudo.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/sudo.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man5/motd.md\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294435,size=1553},["yahtcc.conffiles"]={type="file",created=1740881294559,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294559,size=0},["libsystem.list"]={type="file",created=1740881292780,worldPermissions={execute=true,read=true,write=false},data="/\n/lib/\n/lib/libsystem.a\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292780,size=25},["dpkg.list"]={type="file",created=1740881291973,worldPermissions={execute=true,read=true,write=false},data="/\n/usr/\n/usr/bin/\n/usr/bin/components.lua\n/usr/bin/dpkg-deb.lua\n/usr/bin/dpkg-divert.lua\n/usr/bin/dpkg-query.lua\n/usr/bin/dpkg-trigger.lua\n/usr/bin/dpkg.lua\n/usr/bin/update.lua\n/usr/lib/\n/usr/lib/dpkg/\n/usr/lib/dpkg/control.lua\n/usr/lib/dpkg/deb.lua\n/usr/lib/dpkg/divert.lua\n/usr/lib/dpkg/init.lua\n/usr/lib/dpkg/query.lua\n/usr/lib/dpkg/trigger.lua\n/usr/share/\n/usr/share/man/\n/usr/share/man/man8/\n/usr/share/man/man8/components.md\n/usr/share/man/man8/dpkg.md\n/usr/share/man/man8/update.md\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291973,size=489},["dhcpmgr.md5sums"]={type="file",created=1740881291739,worldPermissions={execute=true,read=true,write=false},data="0c9a08f2a83e9e0e51a66665c6da0624  etc/dhcpmgr.conf\nb7aee3e93a267ee7dba233d02b482dec  usr/libexec/dhcpmgr.lua\n096ab38be9345203bf98238c3a432439  etc/startmgr/system/dhcpmgr.service\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291739,size=179},["baseutils.list"]={type="file",created=1740881291496,worldPermissions={execute=true,read=true,write=false},data="/\n/bin/\n/bin/apropos.lua\n/bin/attach.lua\n/bin/basename.lua\n/bin/cal.lua\n/bin/cash.lua\n/bin/cat.lua\n/bin/cd.lua\n/bin/chmod.lua\n/bin/chown.lua\n/bin/chroot.lua\n/bin/cksum.lua\n/bin/clear.lua\n/bin/cmp.lua\n/bin/comm.lua\n/bin/compress.lua\n/bin/cp.lua\n/bin/curl.lua\n/bin/date.lua\n/bin/df.lua\n/bin/dirname.lua\n/bin/dj.lua\n/bin/du.lua\n/bin/echo.lua\n/bin/eject.lua\n/bin/env.lua\n/bin/expand.lua\n/bin/expr.lua\n/bin/false.lua\n/bin/halt.lua\n/bin/id.lua\n/bin/kill.lua\n/bin/label.lua\n/bin/less.lua\n/bin/link.lua\n/bin/logger.lua\n/bin/ls.lua\n/bin/lsdev.lua\n/bin/lua.lua\n/bin/man.lua\n/bin/mkdir.lua\n/bin/mkfifo.lua\n/bin/mount.lua\n/bin/mv.lua\n/bin/nano.lua\n/bin/nice.lua\n/bin/nm.lua\n/bin/printf.lua\n/bin/ps.lua\n/bin/pwd.lua\n/bin/reboot.lua\n/bin/redstone.lua\n/bin/renice.lua\n/bin/rm.lua\n/bin/rmdir.lua\n/bin/screenfetch.lua\n/bin/sh.lua\n/bin/sleep.lua\n/bin/touch.lua\n/bin/true.lua\n/bin/tty.lua\n/bin/uname.lua\n/bin/uncompress.lua\n/bin/unlink.lua\n/bin/unmount.lua\n/bin/whoami.lua\n/etc/\n/etc/fstab\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/automount.service\n/etc/startmgr/system/startup.service.wants/\n/etc/startmgr/system/startup.service.wants/automount.service\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291496,size=1152},["pgp.list"]={type="file",created=1740881293152,worldPermissions={execute=true,read=true,write=false},data="/\n/usr/\n/usr/bin/\n/usr/bin/pgp.lua\n/usr/lib/\n/usr/lib/pgp.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293152,size=62},["netmgr.md5sums"]={type="file",created=1740881292981,worldPermissions={execute=true,read=true,write=false},data="5f6e8b6f9644d4c54ffdc86d004201a5  etc/startmgr/system/netmgr.service\n1a8951fa370e9218f32bbb88177623df  etc/network.conf\n33e5368d3024cbc43bb5eaa650d114e9  usr/libexec/netmgr.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292981,size=177},["usermgr.list"]={type="file",created=1740881294434,worldPermissions={execute=true,read=true,write=false},data="/\n/etc/\n/etc/motd\n/etc/passwd\n/etc/shadow\n/etc/skel/\n/etc/skel/.cashrc\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/login.service\n/etc/startmgr/system/startup.service.wants/\n/etc/startmgr/system/usermgr.service\n/usr/\n/usr/bin/\n/usr/bin/login.lua\n/usr/bin/passwd.lua\n/usr/bin/su.lua\n/usr/bin/sudo.lua\n/usr/bin/useradd.lua\n/usr/bin/userdel.lua\n/usr/bin/usermod.lua\n/usr/lib/\n/usr/lib/usermgr.lua\n/usr/libexec/\n/usr/libexec/usermgr.lua\n/usr/share/\n/usr/share/man/\n/usr/share/man/man1/\n/usr/share/man/man1/login.md\n/usr/share/man/man1/passwd.md\n/usr/share/man/man1/su.md\n/usr/share/man/man1/sudo.md\n/usr/share/man/man3/\n/usr/share/man/man3/usermgr.md\n/usr/share/man/man5/\n/usr/share/man/man5/motd.md\n/usr/share/man/man5/passwd.md\n/usr/share/man/man5/shadow.md\n/usr/share/man/man8/\n/usr/share/man/man8/useradd.md\n/usr/share/man/man8/userdel.md\n/usr/share/man/man8/usermgr.md\n/usr/share/man/man8/usermod.md\n/etc/startmgr/system/startup.service.wants/login.service\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294434,size=971},["usermgr.conffiles"]={type="file",created=1740881294435,worldPermissions={execute=true,read=true,write=false},data="/etc/passwd\n/etc/shadow\n/etc/motd\n/etc/skel/.cashrc\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294435,size=52},["dpkg.md5sums"]={type="file",created=1740881291973,worldPermissions={execute=true,read=true,write=false},data="ba58b004afcc6edbe9f409f5b0877d33  usr/bin/dpkg-divert.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/update.md\naab6bf7c06734a559f26f40128f89df0  usr/bin/components.lua\nac925bbfc0abed67a409aa32a59e3852  usr/lib/dpkg/init.lua\nd5e27e7174a1fea197a7f2d6a4fe2335  usr/bin/dpkg-query.lua\n8ed0455495f6d0c4456249006281b069  usr/bin/dpkg-deb.lua\nddb74df4a7ad2b15c614ab754ee5f4a9  usr/bin/update.lua\nc1b4ca58881e6ac1f122c2381a87de10  usr/lib/dpkg/control.lua\n76fe1d9953d075f6811758c949da30d2  usr/lib/dpkg/deb.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/components.md\nc5a104541816bf417df68eabccb0c1ce  usr/lib/dpkg/query.lua\n574441cf032742c0a1b4a662b44d5f29  usr/lib/dpkg/trigger.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/dpkg.md\n94f3f1673bbfa8596df3c7bd66bdb444  usr/bin/dpkg.lua\n0b9e4c3020d8d775a34920b3098eb458  usr/lib/dpkg/divert.lua\n637f90e0ca1924d17008cf6073e19887  usr/bin/dpkg-trigger.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291973,size=925},["typescript.list"]={type="file",created=1740881294303,worldPermissions={execute=true,read=true,write=false},data="/\n/lib/\n/lib/typescript.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294303,size=28},["baseutils.triggers"]={type="file",created=1740881291499,worldPermissions={execute=true,read=true,write=false},data="interest /usr/share/man",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291499,size=23},["libcert.conffiles"]={type="file",created=1740881292484,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292484,size=0},["ar.md5sums"]={type="file",created=1740881291265,worldPermissions={execute=true,read=true,write=false},data="4767aeea93f79bff928f7f84b31ba365  lib/ar.lua\n313f5e82958c0d8f26b6167440648acd  bin/ar.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291265,size=90},["tracc.md5sums"]={type="file",created=1740881294227,worldPermissions={execute=true,read=true,write=false},data="68b329da9893e34099c7d8ad5cb9c940  usr/bin/tracc.lua\n5587f874fe4f094b152fcb341807ab81  usr/lib/tracc.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294227,size=104},["pgp.conffiles"]={type="file",created=1740881293153,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293153,size=0},["tar.list"]={type="file",created=1740881294118,worldPermissions={execute=true,read=true,write=false},data="/\n/bin/\n/bin/tar.lua\n/lib/\n/lib/tar.lua\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man1/\n/usr/share/man/man1/tar.md\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294118,size=122},["asn1.list"]={type="file",created=1740881291311,worldPermissions={execute=true,read=true,write=false},data="/\n/usr/\n/usr/lib/\n/usr/lib/asn1.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291311,size=36},["aes.list"]={type="file",created=1740881291112,worldPermissions={execute=true,read=true,write=false},data="/\n/usr/\n/usr/lib/\n/usr/lib/aes.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291112,size=35},["muxzcat.conffiles"]={type="file",created=1740881292923,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292923,size=0},["diskmgr.conffiles"]={type="file",created=1740881291828,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291828,size=0},["encryptfs.conffiles"]={type="file",created=1740881292048,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292048,size=0},["tar.conffiles"]={type="file",created=1740881294118,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294118,size=0},["pxboot.list"]={type="file",created=1740881293680,worldPermissions={execute=true,read=true,write=false},data="/\n/boot/\n/boot/config.lua\n/boot/config.lua.d/\n/boot/config.lua.d/99-craftos.lua\n/boot/pxboot.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293680,size=97},["tar.md5sums"]={type="file",created=1740881294119,worldPermissions={execute=true,read=true,write=false},data="d41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/tar.md\n30746ebcd4553deb0b26ceee80967a53  bin/tar.lua\n8d5cffca8266e5a47fe9522c4388a306  lib/tar.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294119,size=152},["advanced-peripherals.list"]={type="file",created=1740881291058,worldPermissions={execute=true,read=true,write=false},data="/\n/lib/\n/lib/modules/\n/lib/modules/advanced-peripherals.lua\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man7/\n/usr/share/man/man7/advanced-peripherals.md\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291058,size=159},["tracc.list"]={type="file",created=1740881294227,worldPermissions={execute=true,read=true,write=false},data="/\n/usr/\n/usr/bin/\n/usr/bin/tracc.lua\n/usr/lib/\n/usr/lib/tracc.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294227,size=66},["encryptfs.list"]={type="file",created=1740881292047,worldPermissions={execute=true,read=true,write=false},data="/\n/etc/\n/etc/initrd/\n/etc/initrd/initrd.conf.template/\n/etc/initrd/initrd.conf.template/encryptfs.conf\n/etc/initrd/scripts/\n/etc/initrd/scripts/encryptfs.lua\n/lib/\n/lib/modules/\n/lib/modules/encryptfs.lua\n/sbin/\n/sbin/mkencryptfs.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292047,size=234},["startmgr.md5sums"]={type="file",created=1740881294010,worldPermissions={execute=true,read=true,write=false},data="d41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/startctl.md\n2f681b48d8fd9ea8060c31a931c7f6c1  sbin/init.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/startmgr.md\nd2439cbe3dccf4c8e86575b5ef2d19b3  lib/startmgr.lua\n1f6093323d818261b3fc4d0db3966e66  etc/startmgr/system/startup.service\n02794145e8ba948a089985bb283f3dcc  sbin/startctl.lua\n99a9872f41e5aae13ed404f4b1fb6a0b  sbin/shutdown.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/shutdown.md\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294010,size=468},["sha2.md5sums"]={type="file",created=1740881293799,worldPermissions={execute=true,read=true,write=false},data="0b23c04f92d6d68601b90ebc0acdba3d  usr/bin/md5sum.lua\n89854efcea24687d4f30272d0225950a  usr/bin/sha224sum.lua\n5b6687a44f299b26cb8e8d97b0469fd4  usr/bin/sha512sum.lua\n124dbf6c8623dbc523f29b8c2a7a366c  usr/lib/sha2.lua\n3d3f60e38d1e37fea659736e340ddeb9  usr/bin/b2sum.lua\n368538cdc6f626d57abd0198700058d3  usr/bin/shasum.lua\n88b53fee64630fb7bbfa178142d1c92d  usr/bin/sha384sum.lua\n44304a9aa632161afa6524d6bc03e42a  usr/bin/sha256sum.lua\nf1245ba271f47d6318e39fac55a96258  usr/bin/sha1sum.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293799,size=487},["startmgr.list"]={type="file",created=1740881294010,worldPermissions={execute=true,read=true,write=false},data="/\n/etc/\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/startup.service\n/lib/\n/lib/startmgr.lua\n/sbin/\n/sbin/init.lua\n/sbin/shutdown.lua\n/sbin/startctl.lua\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man1/\n/usr/share/man/man1/shutdown.md\n/usr/share/man/man1/startctl.md\n/usr/share/man/man1/startmgr.md\n/usr/share/man/man3/\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294010,size=338},["initrd-utils.list"]={type="file",created=1740881292391,worldPermissions={execute=true,read=true,write=false},data="/\n/etc/\n/etc/initrd/\n/etc/initrd/hooks.d/\n/etc/initrd/hooks.d/00-modules.lua\n/etc/initrd/hooks.d/01-files.lua\n/etc/initrd/hooks.d/05-shell.lua\n/etc/initrd/hooks.d/10-init.lua\n/etc/initrd/initrd.conf\n/usr/\n/usr/bin/\n/usr/bin/mktablefs.lua\n/usr/bin/update-initrd.lua\n/usr/share/\n/usr/share/man/\n/usr/share/man/man8/\n/usr/share/man/man8/update-initrd.md\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292391,size=351},["dhcpmgr.list"]={type="file",created=1740881291739,worldPermissions={execute=true,read=true,write=false},data="/\n/etc/\n/etc/dhcpmgr.conf\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/dhcpmgr.service\n/usr/\n/usr/libexec/\n/usr/libexec/dhcpmgr.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291739,size=145},["pgp.md5sums"]={type="file",created=1740881293153,worldPermissions={execute=true,read=true,write=false},data="68b329da9893e34099c7d8ad5cb9c940  usr/bin/pgp.lua\na8414b662f1c7de41512ca33250a4dbd  usr/lib/pgp.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293153,size=100},["spanfs.md5sums"]={type="file",created=1740881293901,worldPermissions={execute=true,read=true,write=false},data="7c5d3c8cf149d4e6a14f4f43ccf95e1b  usr/share/man/man8/spanadd.md\n1e86a7b4870ab26673ba335f84cb43a2  usr/share/man/man8/spaninfo.md\n1500428c94799e469bf39de9cfe1d6b7  sbin/spaninfo.lua\n842808b46a8b1f43ccc3960ca1eea0ab  usr/share/man/man8/mkspanfs.md\n12ae0eecfc9726d37b739bbfabd91fa4  sbin/spanadd.lua\n0d26312bc80245eb751c67282895fe12  lib/modules/spanfs.lua\n125e008924e81e287b896ca534c39a9c  sbin/mkspanfs.lua\nda4cc0b9de4f274cde762fdcf4960a78  usr/share/man/man7/spanfs.md\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293901,size=469},["netmgr.conffiles"]={type="file",created=1740881292981,worldPermissions={execute=true,read=true,write=false},data="/etc/network.conf\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292981,size=18},["advanced-peripherals.md5sums"]={type="file",created=1740881291059,worldPermissions={execute=true,read=true,write=false},data="c226450f974f6b8ce22ce93782ceb850  lib/modules/advanced-peripherals.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man7/advanced-peripherals.md\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291059,size=148},["pdb.conffiles"]={type="file",created=1740881293099,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293099,size=0},["pxboot.md5sums"]={type="file",created=1740881293681,worldPermissions={execute=true,read=true,write=false},data="68b329da9893e34099c7d8ad5cb9c940  boot/config.lua\n59333490fc59f5e7b3f71cbe20a24ca5  boot/pxboot.lua\nbdb340a10570edcffedc694989ec8ffc  boot/config.lua.d/99-craftos.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293681,size=167},["fuse.conffiles"]={type="file",created=1740881292257,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292257,size=0},["ar.conffiles"]={type="file",created=1740881291264,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291264,size=0},["fuse.md5sums"]={type="file",created=1740881292258,worldPermissions={execute=true,read=true,write=false},data="09dc6c64b9805a78c159c544f2ac9560  usr/share/man/man7/fuse.md\n4f70313f4c99be264d2232cec45c8ad5  lib/modules/fuse.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292258,size=116},["asn1.conffiles"]={type="file",created=1740881291312,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291312,size=0},["baseutils.conffiles"]={type="file",created=1740881291497,worldPermissions={execute=true,read=true,write=false},data="/etc/fstab\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291497,size=11},["netutils.list"]={type="file",created=1740881293040,worldPermissions={execute=true,read=true,write=false},data="/\n/usr/\n/usr/bin/\n/usr/bin/arp.lua\n/usr/bin/dhclient.lua\n/usr/bin/ifconfig.lua\n/usr/bin/nc.lua\n/usr/bin/ping.lua\n/usr/bin/route.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293040,size=132},["yellowbox.md5sums"]={type="file",created=1740881294685,worldPermissions={execute=true,read=true,write=false},data="55bd44bbb67383a3b7bcfa88743d0658  bin/yellowbox.lua\n1d494b3289e328798db15f4e2a8ddfdd  lib/modules/yellowbox.lua\n7853969f1eb90ad06f2cf6bd8e793bd0  usr/share/man/man7/yellowbox.md\n953d8809284e3a96dbc22832fafe0d91  usr/share/man/man1/yellowbox.md\n68b329da9893e34099c7d8ad5cb9c940  lib/yellowbox.lua\n68b329da9893e34099c7d8ad5cb9c940  var/lib/yellowbox/startup.lua\nb51f91cd5db06fd5bf8c98b842ce1e44  etc/startmgr/system/yellowbox.service\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294685,size=432},["libcraftos.md5sums"]={type="file",created=1740881292593,worldPermissions={execute=true,read=true,write=false},data="2ae28cfcf7043e98dfa59e3899d6a837  usr/share/man/man1/craftos.md\n2491e895910d32c9f82fcb6541fd3e34  bin/craftos.lua\n191ca4cf0fc3b7d0362f3caecf2ef411  lib/libcc.a\nf3d31d93421629073eb2226ad016116d  lib/libcraftos.a\n96654d5385d7f6f6cd4df591b4187f0a  usr/share/man/man1/shell.md\n254d1461a35ee297995f9da936cd60e5  bin/shell.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292593,size=321},["spanfs.conffiles"]={type="file",created=1740881293900,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293900,size=0},["sha2.list"]={type="file",created=1740881293799,worldPermissions={execute=true,read=true,write=false},data="/\n/usr/\n/usr/bin/\n/usr/bin/b2sum.lua\n/usr/bin/md5sum.lua\n/usr/bin/sha1sum.lua\n/usr/bin/sha224sum.lua\n/usr/bin/sha256sum.lua\n/usr/bin/sha384sum.lua\n/usr/bin/sha512sum.lua\n/usr/bin/shasum.lua\n/usr/lib/\n/usr/lib/sha2.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293799,size=218},["pxboot.conffiles"]={type="file",created=1740881293681,worldPermissions={execute=true,read=true,write=false},data="/boot/config.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293681,size=17},["tracc.conffiles"]={type="file",created=1740881294227,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294227,size=0},["ccryptolib.list"]={type="file",created=1740881291599,worldPermissions={execute=true,read=true,write=false},data="/\n/usr/\n/usr/lib/\n/usr/lib/libccryptolib.a\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291599,size=43},["sha2.conffiles"]={type="file",created=1740881293799,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293799,size=0},["diff.md5sums"]={type="file",created=1740881291784,worldPermissions={execute=true,read=true,write=false},data="c861d0c4f89d14b794beb174269bcede  lib/diff.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291784,size=47},["githubfs.md5sums"]={type="file",created=1740881292320,worldPermissions={execute=true,read=true,write=false},data="b17c71098acb992c51ae34386d563dd4  lib/fuse/githubfs.lua\nb39be2e408528ee49dadcc4608f8814f  usr/share/man/man7/githubfs.md\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292320,size=121},["apt.list"]={type="file",created=1740881291209,worldPermissions={execute=true,read=true,write=false},data="/\n/etc/\n/etc/apt/\n/etc/apt/sources.list\n/etc/apt/trusted.gpg.d/\n/etc/apt/trusted.gpg.d/phoenix.gpg\n/usr/\n/usr/bin/\n/usr/bin/add-apt-repository.lua\n/usr/bin/apt-cache.lua\n/usr/bin/apt-config.lua\n/usr/bin/apt-get.lua\n/usr/bin/apt-key.lua\n/usr/bin/apt-mark.lua\n/usr/bin/apt.lua\n/usr/lib/\n/usr/lib/apt/\n/usr/lib/apt/cache.lua\n/usr/lib/apt/config.lua\n/usr/lib/apt/get.lua\n/usr/lib/apt/init.lua\n/usr/lib/apt/methods/\n/usr/lib/apt/methods/file.lua\n/usr/lib/apt/methods/ftp.lua\n/usr/lib/apt/methods/http.lua\n/usr/lib/apt/planners/\n/usr/lib/apt/planners/80-default.lua\n/usr/lib/apt/repo.lua\n/usr/lib/apt/solvers/\n/usr/lib/apt/solvers/80-default.lua\n/usr/bin/apt-add-repository.lua\n/usr/lib/apt/methods/https.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291209,size=703},["diskmgr.list"]={type="file",created=1740881291828,worldPermissions={execute=true,read=true,write=false},data="/\n/etc/\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/diskmgr.service\n/etc/startmgr/system/startup.service.wants/\n/usr/\n/usr/libexec/\n/usr/libexec/diskmgr.lua\n/etc/startmgr/system/startup.service.wants/diskmgr.service\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291828,size=230},["apt.md5sums"]={type="file",created=1740881291209,worldPermissions={execute=true,read=true,write=false},data="386ff5fdbfb4c5d0f5cc42246b3cfcf7  usr/bin/apt-config.lua\nb1d1ac605949bf87f052c404eea10b4f  usr/lib/apt/repo.lua\n0c4d226fa1543eb731e6acfdbf93e9e7  etc/apt/sources.list\n03302bdbb0e5e99891c49a55af5e8003  usr/bin/apt-get.lua\n5cc722c6bca5bdb7481563a4f1a2b814  usr/lib/apt/get.lua\n7ba3e2e2e1464c6a16769ecc454a06d5  usr/lib/apt/methods/file.lua\n573aa13d881550f84056399196919f8f  usr/bin/apt-cache.lua\n763f83f348b69b2b661aaa31158db4bf  usr/bin/add-apt-repository.lua\n4ccfd57d521b3857570f7009e1a46402  usr/lib/apt/solvers/80-default.lua\n791ca0fb0664879bfd1a59f66a076fc8  usr/lib/apt/methods/http.lua\n60cfe56b8d78b9e75853e6fc788f81dc  etc/apt/trusted.gpg.d/phoenix.gpg\n68b329da9893e34099c7d8ad5cb9c940  usr/bin/apt-key.lua\n68b329da9893e34099c7d8ad5cb9c940  usr/bin/apt-mark.lua\n4f165d8af19433b864b41486eb348fbf  usr/lib/apt/methods/ftp.lua\n68b329da9893e34099c7d8ad5cb9c940  usr/bin/apt.lua\nb4ba488bd66be283f54342e8c25b2cba  usr/lib/apt/planners/80-default.lua\n7ad6480011fb4abce823d2d7f4db5273  usr/lib/apt/config.lua\nf2f388a7a3a77cd7121bbb84c1a5919b  usr/lib/apt/cache.lua\n68b329da9893e34099c7d8ad5cb9c940  usr/lib/apt/init.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291209,size=1118},["phoenix-docs.conffiles"]={type="file",created=1740881293548,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293548,size=0},["ccryptolib.md5sums"]={type="file",created=1740881291600,worldPermissions={execute=true,read=true,write=false},data="98f9289f49c33b9ec13eb53f071efcb9  usr/lib/libccryptolib.a\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291600,size=58},["deflateans.list"]={type="file",created=1740881291690,worldPermissions={execute=true,read=true,write=false},data="/\n/usr/\n/usr/lib/\n/usr/lib/deflateans.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291690,size=42},["advanced-peripherals.conffiles"]={type="file",created=1740881291058,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291058,size=0},["fatfs.list"]={type="file",created=1740881292095,worldPermissions={execute=true,read=true,write=false},data="/\n/lib/\n/lib/modules/\n/lib/modules/fatfs.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292095,size=45},["ftp.list"]={type="file",created=1740881292186,worldPermissions={execute=true,read=true,write=false},data="/\n/etc/\n/etc/ftpmgr.conf\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/ftpmgr.service\n/lib/\n/lib/fuse/\n/lib/fuse/ftp.lua\n/usr/\n/usr/lib/\n/usr/lib/ftp.lua\n/usr/libexec/\n/usr/libexec/ftpmgr.lua\n/usr/share/\n/usr/share/man/\n/usr/share/man/man3/\n/usr/share/man/man3/ftp.md\n/usr/share/man/man5/\n/usr/share/man/man5/ftpmgr.conf.md\n/usr/share/man/man8/\n/usr/share/man/man8/ftpmgr.md\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292186,size=387},["pdb.md5sums"]={type="file",created=1740881293099,worldPermissions={execute=true,read=true,write=false},data="368f6c8d8ba6bed09da33b3cb20eebdb  usr/bin/pdb.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293099,size=50},["compressfs.md5sums"]={type="file",created=1740881291643,worldPermissions={execute=true,read=true,write=false},data="93f785ad5cb4c073d9e441b333484734  etc/initrd/initrd.conf.template/compressfs.conf\n3316177fb4bc33f803c1620b18ef08c3  lib/modules/compressfs.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291643,size=143},["pdb.list"]={type="file",created=1740881293098,worldPermissions={execute=true,read=true,write=false},data="/\n/usr/\n/usr/bin/\n/usr/bin/pdb.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293098,size=35},["ftp.md5sums"]={type="file",created=1740881292187,worldPermissions={execute=true,read=true,write=false},data="d41d8cd98f00b204e9800998ecf8427e  usr/share/man/man3/ftp.md\ne4a01ba4833d4d6283e94b8b4d803541  etc/ftpmgr.conf\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/ftpmgr.md\nfb8f26e52240525783a09925f60edd02  usr/libexec/ftpmgr.lua\n1630d6d240408784b2e1b316ed4cd942  lib/fuse/ftp.lua\n7a760cd3b26ac36fa0e8934aabb0fb93  usr/lib/ftp.lua\n0d311fd801635be99833577c8317072a  usr/share/man/man5/ftpmgr.conf.md\ndaf955dbbcdcad648af2ad9d52a11cb8  etc/startmgr/system/ftpmgr.service\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292187,size=468},["netutils.md5sums"]={type="file",created=1740881293041,worldPermissions={execute=true,read=true,write=false},data="e8fe3e8b26edb804f8bef0b17e9e6afb  usr/bin/dhclient.lua\nf7aabeec00376eb5e12643392fb5abae  usr/bin/arp.lua\n158a50065b8d605ce928a75ed7b83d98  usr/bin/route.lua\n68b329da9893e34099c7d8ad5cb9c940  usr/bin/nc.lua\n41c9783bf056efa1345e0e058ed4d63a  usr/bin/ifconfig.lua\n5881edfd5fc61aaea57986174d5e1a8c  usr/bin/ping.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293041,size=312},["githubfs.conffiles"]={type="file",created=1740881292319,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292319,size=0},["asn1.md5sums"]={type="file",created=1740881291312,worldPermissions={execute=true,read=true,write=false},data="6e4ca60e383e8f822d5cdd2de92f8c4c  usr/lib/asn1.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291312,size=51},["ar.list"]={type="file",created=1740881291264,worldPermissions={execute=true,read=true,write=false},data="/\n/bin/\n/bin/ar.lua\n/lib/\n/lib/ar.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291264,size=38},["netutils.conffiles"]={type="file",created=1740881293040,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293040,size=0},["netmgr.list"]={type="file",created=1740881292981,worldPermissions={execute=true,read=true,write=false},data="/\n/etc/\n/etc/network.conf\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/netmgr.service\n/usr/\n/usr/libexec/\n/usr/libexec/netmgr.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292981,size=143},["initrd-utils.conffiles"]={type="file",created=1740881292391,worldPermissions={execute=true,read=true,write=false},data="/etc/initrd/initrd.conf\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292391,size=24},["baseutils.postinst"]={type="file",created=1740881291498,worldPermissions={execute=true,read=true,write=false},data="if ... == \"triggered\" then return coroutine.yield(\"syscall\", \"exec\", \"/bin/man.lua\", \"-u\") end",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291498,size=94},["muxzcat.list"]={type="file",created=1740881292923,worldPermissions={execute=true,read=true,write=false},data="/\n/usr/\n/usr/bin/\n/usr/bin/unxz.lua\n/usr/lib/\n/usr/lib/muxzcat.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292923,size=67},["libcert.md5sums"]={type="file",created=1740881292485,worldPermissions={execute=true,read=true,write=false},data="e30c9cf5840dcb7f39a3fa1005e6c2fb  usr/lib/cert/init.lua\n68b329da9893e34099c7d8ad5cb9c940  usr/bin/certutil.lua\n4282e0924abe538d0497d7865d4a47b5  usr/lib/cert/csr.lua\n68b329da9893e34099c7d8ad5cb9c940  usr/bin/signtool.lua\nc89b832429682ebfdb35a38ba71edbc1  usr/lib/cert/signature.lua\n0122e4c6755d2c424f3f0241c4acca1b  usr/lib/cert/crypto.lua\n14651374e4fa509ff82e99289044b41b  usr/lib/cert/chain.lua\n8e090b05517380e0b2c63f35f0ece1a8  usr/lib/cert/util.lua\n2aa2766decd687bc085b5d7792d8cb5b  usr/lib/cert/container.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292485,size=514},["diff.conffiles"]={type="file",created=1740881291784,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291784,size=0},["libcraftos.conffiles"]={type="file",created=1740881292593,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292593,size=0},["libsystem.conffiles"]={type="file",created=1740881292780,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292780,size=0},["luz.md5sums"]={type="file",created=1740881292855,worldPermissions={execute=true,read=true,write=false},data="bf692665ff81a957298f784d7bf73531  lib/luz/token_encode_map.lua\n16f1b23c5035e2dc69e08a69501bfd72  lib/luz/lz77.lua\n2f4c8200e228ef34efece3e66286d41c  lib/modules/luz.lua\na9979c022975187f0dc8945a0d4cc1c6  lib/luz/compress.lua\ncba820ecaa45e4b4d38d4cb511259021  lib/luz/init.lua\n802f60c677e8859a1e515169219c5f8f  bin/luz.lua\ncfaab46b772f6efe1fe86af611a8ba7f  lib/luz/maketree.lua\n12b1258d8ec144f602549a2e0f79a809  lib/luz/minify.lua\nc6f4c9d10659f0a6438e22e0a787d573  lib/luz/decompress.lua\n9654f6e61a1f848f18834d44b4a622c2  lib/luz/lex.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292855,size=535},["ftp.conffiles"]={type="file",created=1740881292186,worldPermissions={execute=true,read=true,write=false},data="/etc/ftpmgr.conf\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292186,size=17},["compressfs.conffiles"]={type="file",created=1740881291643,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291643,size=0},["luz.list"]={type="file",created=1740881292855,worldPermissions={execute=true,read=true,write=false},data="/\n/bin/\n/bin/luz.lua\n/lib/\n/lib/luz/\n/lib/luz/compress.lua\n/lib/luz/decompress.lua\n/lib/luz/init.lua\n/lib/luz/lex.lua\n/lib/luz/lz77.lua\n/lib/luz/maketree.lua\n/lib/luz/minify.lua\n/lib/luz/token_encode_map.lua\n/lib/modules/\n/lib/modules/luz.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292855,size=243},["phoenix-docs.list"]={type="file",created=1740881293548,worldPermissions={execute=true,read=true,write=false},data="/\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man1/\n/usr/share/man/man1/logger.md\n/usr/share/man/man2/\n/usr/share/man/man2/_template.md\n/usr/share/man/man2/acquiresemaphore.md\n/usr/share/man/man2/alarm.md\n/usr/share/man/man2/arplist.md\n/usr/share/man/man2/arpset.md\n/usr/share/man/man2/attach.md\n/usr/share/man/man2/callmodule.md\n/usr/share/man/man2/cancel.md\n/usr/share/man/man2/cchost.md\n/usr/share/man/man2/checkuri.md\n/usr/share/man/man2/chmod.md\n/usr/share/man/man2/chown.md\n/usr/share/man/man2/chroot.md\n/usr/share/man/man2/combine.md\n/usr/share/man/man2/connect.md\n/usr/share/man/man2/detach.md\n/usr/share/man/man2/devalias.md\n/usr/share/man/man2/devcall.md\n/usr/share/man/man2/devchildren.md\n/usr/share/man/man2/devfind.md\n/usr/share/man/man2/devinfo.md\n/usr/share/man/man2/devlisten.md\n/usr/share/man/man2/devlock.md\n/usr/share/man/man2/devlookup.md\n/usr/share/man/man2/devmethods.md\n/usr/share/man/man2/devproperties.md\n/usr/share/man/man2/devunlock.md\n/usr/share/man/man2/ipconfig.md\n/usr/share/man/man2/kernargs.md\n/usr/share/man/man2/kill.md\n/usr/share/man/man2/link.md\n/usr/share/man/man2/list.md\n/usr/share/man/man2/listen.md\n/usr/share/man/man2/listmodules.md\n/usr/share/man/man2/loadCraftOSAPI.md\n/usr/share/man/man2/loadmodule.md\n/usr/share/man/man2/lockmutex.md\n/usr/share/man/man2/mkdir.md\n/usr/share/man/man2/mkfifo.md\n/usr/share/man/man2/mount.md\n/usr/share/man/man2/mountlist.md\n/usr/share/man/man2/netcontrol.md\n/usr/share/man/man2/netevent.md\n/usr/share/man/man2/open.md\n/usr/share/man/man2/queueEvent.md\n/usr/share/man/man2/releasesemaphore.md\n/usr/share/man/man2/remove.md\n/usr/share/man/man2/rename.md\n/usr/share/man/man2/routeadd.md\n/usr/share/man/man2/routedel.md\n/usr/share/man/man2/routelist.md\n/usr/share/man/man2/sendEvent.md\n/usr/share/man/man2/signal.md\n/usr/share/man/man2/stat.md\n/usr/share/man/man2/timeacquiresemaphore.md\n/usr/share/man/man2/timelockmutex.md\n/usr/share/man/man2/timer.md\n/usr/share/man/man2/trylockmutex.md\n/usr/share/man/man2/unlisten.md\n/usr/share/man/man2/unloadmodule.md\n/usr/share/man/man2/unlockmutex.md\n/usr/share/man/man2/unmount.md\n/usr/share/man/man2/uptime.md\n/usr/share/man/man2/version.md\n/usr/share/man/man3/\n/usr/share/man/man3/system.expect.md\n/usr/share/man/man3/system.filesystem.md\n/usr/share/man/man3/system.framebuffer.md\n/usr/share/man/man3/system.graphics.md\n/usr/share/man/man3/system.hardware.md\n/usr/share/man/man3/system.ipc.md\n/usr/share/man/man3/system.keys.md\n/usr/share/man/man3/system.log.md\n/usr/share/man/man3/system.network.md\n/usr/share/man/man3/system.pretty.md\n/usr/share/man/man3/system.process.md\n/usr/share/man/man3/system.serialization.md\n/usr/share/man/man3/system.sync.md\n/usr/share/man/man3/system.terminal.md\n/usr/share/man/man3/system.util.md\n/usr/share/man/man9/\n/usr/share/man/man9/kernel.md\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293548,size=2803},["libsystem.md5sums"]={type="file",created=1740881292781,worldPermissions={execute=true,read=true,write=false},data="2ed3bd2a1ee17107a1a1ef7eaa21c319  lib/libsystem.a\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292781,size=50},["libdeflate.md5sums"]={type="file",created=1740881292672,worldPermissions={execute=true,read=true,write=false},data="61a11f1b095de6ecf98a981e4e84be8c  usr/bin/gzip.lua\n9ab27810840ddae0b90ef4d0bc39d960  usr/lib/LibDeflate.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292672,size=108},["aes.md5sums"]={type="file",created=1740881291113,worldPermissions={execute=true,read=true,write=false},data="728e4a1a718c49f7f582635aaaa85000  usr/lib/aes.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291113,size=50},["libdeflate.list"]={type="file",created=1740881292672,worldPermissions={execute=true,read=true,write=false},data="/\n/usr/\n/usr/bin/\n/usr/bin/gzip.lua\n/usr/lib/\n/usr/lib/LibDeflate.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292672,size=70},["yahtcc.md5sums"]={type="file",created=1740881294559,worldPermissions={execute=true,read=true,write=false},data="32f4ff232b0ae7535cc9bdbd16d6649e  usr/share/man/man6/yahtcc.md\nd8e5bc545009c73a7a15ed2cfd9da260  usr/bin/yahtcc.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294559,size=116},["diskmgr.md5sums"]={type="file",created=1740881291828,worldPermissions={execute=true,read=true,write=false},data="bef0900b5d48f903c15177c062b52e35  usr/libexec/diskmgr.lua\n52dfeac33b5887d026695dff5dc9dbac  etc/startmgr/system/diskmgr.service\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291828,size=128},["deflateans.conffiles"]={type="file",created=1740881291690,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291690,size=0},["ccryptolib.conffiles"]={type="file",created=1740881291600,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291600,size=0},["fuse.list"]={type="file",created=1740881292257,worldPermissions={execute=true,read=true,write=false},data="/\n/lib/\n/lib/modules/\n/lib/modules/fuse.lua\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man7/\n/usr/share/man/man7/fuse.md\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292257,size=127},["libcraftos.list"]={type="file",created=1740881292592,worldPermissions={execute=true,read=true,write=false},data="/\n/bin/\n/bin/craftos.lua\n/bin/shell.lua\n/lib/\n/lib/libcc.a\n/lib/libcraftos.a\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man1/\n/usr/share/man/man1/craftos.md\n/usr/share/man/man1/shell.md\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292592,size=192},["initrd-utils.md5sums"]={type="file",created=1740881292391,worldPermissions={execute=true,read=true,write=false},data="9db39ca3f02b2edaf85d3592a5286fa2  etc/initrd/hooks.d/05-shell.lua\n0fddcca5345e03354ce487ac30956628  etc/initrd/initrd.conf\nd8b1a2233c15c3046f0487033043371f  etc/initrd/hooks.d/01-files.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/update-initrd.md\na56442d2083dfaae3061210edf9250ba  usr/bin/update-initrd.lua\n8032576522e153987a0fd69fc99d689b  etc/initrd/hooks.d/10-init.lua\n9e3969cffb4e6f97ccde4da9c8e8a72e  usr/bin/mktablefs.lua\nc737755eb7c50bccabd06de16ac53c0b  etc/initrd/hooks.d/00-modules.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292391,size=508},["libcert.list"]={type="file",created=1740881292484,worldPermissions={execute=true,read=true,write=false},data="/\n/usr/\n/usr/bin/\n/usr/bin/certutil.lua\n/usr/bin/signtool.lua\n/usr/lib/\n/usr/lib/cert/\n/usr/lib/cert/chain.lua\n/usr/lib/cert/container.lua\n/usr/lib/cert/crypto.lua\n/usr/lib/cert/csr.lua\n/usr/lib/cert/init.lua\n/usr/lib/cert/signature.lua\n/usr/lib/cert/util.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292484,size=260},["typescript.conffiles"]={type="file",created=1740881294303,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294303,size=0},["encryptfs.md5sums"]={type="file",created=1740881292048,worldPermissions={execute=true,read=true,write=false},data="ab6d506d9382b92aa9190c744ff4e892  lib/modules/encryptfs.lua\n672733d614dcf0b631ae1caad162cd6c  etc/initrd/scripts/encryptfs.lua\nb06c84afb1362e6fd83a5adfbccdd98b  sbin/mkencryptfs.lua\n3756973d1f50c546354db12fbd084c1b  etc/initrd/initrd.conf.template/encryptfs.conf\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292048,size=263},["deflateans.md5sums"]={type="file",created=1740881291691,worldPermissions={execute=true,read=true,write=false},data="048e66916139912611cc33796299e6d0  usr/lib/deflateans.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291691,size=57},["compressfs.list"]={type="file",created=1740881291643,worldPermissions={execute=true,read=true,write=false},data="/\n/etc/\n/etc/initrd/\n/etc/initrd/initrd.conf.template/\n/etc/initrd/initrd.conf.template/compressfs.conf\n/lib/\n/lib/modules/\n/lib/modules/compressfs.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291643,size=152},["dhcpmgr.conffiles"]={type="file",created=1740881291739,worldPermissions={execute=true,read=true,write=false},data="/etc/dhcpmgr.conf\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291739,size=18},["luz.conffiles"]={type="file",created=1740881292855,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292855,size=0},["phoenix-docs.md5sums"]={type="file",created=1740881293548,worldPermissions={execute=true,read=true,write=false},data="1e3f6c4fe095b7dfcc595a0493101f29  usr/share/man/man2/kernargs.md\nee2402f90c4ad6d76fbb8d79514463ec  usr/share/man/man2/timelockmutex.md\n28291760a2e4b96be1171acc644c5d6e  usr/share/man/man3/system.hardware.md\n5e4ac8f69342bd5e07b28d77bc4aebca  usr/share/man/man2/releasesemaphore.md\n5cab43ff97f5780078c29e9f75cad7b5  usr/share/man/man2/_template.md\n911e57faab1316f11d584a94eca7eefd  usr/share/man/man9/kernel.md\ncb5483b392e5196c755d8f4fb3bb6d5d  usr/share/man/man2/loadCraftOSAPI.md\nd181c9ee13a5868c6b636b035eef1f27  usr/share/man/man2/open.md\n06124b31ba7e667b1618f4f0f993456a  usr/share/man/man2/devunlock.md\ndd26ad844296daa48ce9824f78112145  usr/share/man/man2/unlockmutex.md\n6fc3507c68de16d6909370c3e2b0eeb6  usr/share/man/man2/signal.md\n300a370b5355fc236a4e3bcd5ce6e771  usr/share/man/man2/listen.md\n2e226e3b72e730965dd894189fa98b45  usr/share/man/man2/devcall.md\n8e7e90089d0ba1d260e65c8fef1d6882  usr/share/man/man2/devmethods.md\nf92254ae8278c8f48402cd0a6e3ab2c3  usr/share/man/man2/devlock.md\n005eb4b4db66b177c3a09068c7d5e5c8  usr/share/man/man2/trylockmutex.md\n05b2b6ce596d1911ecc622e0d91c03d4  usr/share/man/man2/cchost.md\na04eafd5194d4bf030b1f98a92b71e64  usr/share/man/man2/queueEvent.md\ndafda555c67469ef269165d080d4f537  usr/share/man/man2/kill.md\n1bef5a63b0fe7719b02a57aa85b65f41  usr/share/man/man2/loadmodule.md\nda74496fbe0ae2de16e985af5eaf7367  usr/share/man/man2/listmodules.md\n37c295514dbf251035461e407ec667b3  usr/share/man/man3/system.expect.md\nb48e433d717c524cc10da33c4c23472b  usr/share/man/man2/remove.md\n9de4abbd2b0da2b14c5da9dbf81bc23c  usr/share/man/man2/arpset.md\n3aecf75563c43ac627904e5557db6d93  usr/share/man/man2/acquiresemaphore.md\n998c1f99fc18bb138afb96f8a290829b  usr/share/man/man2/stat.md\n0d28ca0a43641a8e25ea4f57ba9c53a3  usr/share/man/man2/routedel.md\n05279006f5323ad189eaa20c795a8fe4  usr/share/man/man2/connect.md\n696a2040bc36af8af6ad66fe78433ae7  usr/share/man/man3/system.process.md\nea033221bc9037a8519781148c3e36b9  usr/share/man/man2/arplist.md\n338b606dbe6b417f1e6eee5d61042d13  usr/share/man/man2/rename.md\nd0e27457aa68149eb780fe1b63977a9a  usr/share/man/man2/chmod.md\n468f1c781f256e30f3f7fdeeac94b6bf  usr/share/man/man2/mountlist.md\nca0bfb454428824d3b9adbb2ad49175f  usr/share/man/man2/unloadmodule.md\n7ac41cc3c74aa8163d90e4614d492e75  usr/share/man/man3/system.util.md\nc3d0d69b999f47463b8e679e2d04651d  usr/share/man/man1/logger.md\nd0996ceaa773d903957e6e9619641906  usr/share/man/man2/devproperties.md\n005fc8770f15afd6e1c2422202eeb837  usr/share/man/man2/devchildren.md\nd69b17d40fc99325335341dc5c80fd36  usr/share/man/man2/detach.md\n2cc2c7a42459d2e32c6bc49a9d2d4021  usr/share/man/man2/chown.md\ne6e6e85c1c165f256ac8529611f99129  usr/share/man/man2/netcontrol.md\ne63ea2179e036d83f3d5f37aec41a229  usr/share/man/man2/attach.md\nf3afcb4b2f99ed91a29178f38323f345  usr/share/man/man2/devlookup.md\n9acb7f91203c9ea3969f7830ad4bd6a5  usr/share/man/man3/system.serialization.md\n49d3e4050d1082830f48ad6967eae91f  usr/share/man/man3/system.pretty.md\n2501ef2ed4f1fbdf54649e4920f1b584  usr/share/man/man3/system.log.md\nbafeb327ddff1f91ee06ec03d87f06b3  usr/share/man/man3/system.ipc.md\nfaa2cb304a8d49cf6d1ef8a3e03f8e4d  usr/share/man/man3/system.network.md\n9d542afcd7482e1c80531b8b987c2d8a  usr/share/man/man3/system.keys.md\n969be2cabd57377208f2fcc306f4e390  usr/share/man/man3/system.graphics.md\n567d15c62ba1bef2a7d1455df96abb3d  usr/share/man/man2/devinfo.md\nf9b544105798e40052a32bc6e997de7c  usr/share/man/man2/uptime.md\ne15a8b674e3b2317a49f49c68dffbf37  usr/share/man/man2/unlisten.md\nf4ab4a41e3fa302d47096ea8534aed80  usr/share/man/man2/mount.md\nab2514f962bed9c4833e34cda902fed7  usr/share/man/man3/system.framebuffer.md\n90939a50982f279ff8bc78b7feb98d84  usr/share/man/man2/list.md\nfa70b112de755bca55aeed95aefceae6  usr/share/man/man3/system.filesystem.md\n153307238fe3c50cd989e29fcf673cc8  usr/share/man/man2/checkuri.md\n5f19cc0f6ab4148ba9335d6e814d8356  usr/share/man/man2/callmodule.md\n3f9fd39c8c546bd480bc96cde4ce451f  usr/share/man/man2/devfind.md\n927b9673495ee1ab6372804aaffb0602  usr/share/man/man2/link.md\na594570023aefc380e2ffeb3cce0c052  usr/share/man/man2/combine.md\n78d09c5fb0699148ad0f03f55e1aa0dd  usr/share/man/man2/netevent.md\n791883f15b0b6d761feeee712293d767  usr/share/man/man3/system.sync.md\nfe185470ef69904cd06ff581fea471fb  usr/share/man/man2/cancel.md\ne9fcc0a2c89dd521a771880001556e07  usr/share/man/man2/chroot.md\n278ed6f961df2429b512436974dbbde6  usr/share/man/man2/lockmutex.md\n0389a13f78cfe99d7bc6e7d1972b27f8  usr/share/man/man2/devalias.md\n4346c291bae58e8d989ebe3101ee7338  usr/share/man/man2/timer.md\n3392e744c6cf94bf74a63cd1ee0f8472  usr/share/man/man2/routeadd.md\n0df54115cb3ece67b17c2d74a9c7c42a  usr/share/man/man2/ipconfig.md\n2efd87231f058c6ff1d2954ac15f3a26  usr/share/man/man2/mkdir.md\n132985fdf367e06d1c55fdb223876ce0  usr/share/man/man2/sendEvent.md\n9d644b65cd00553301c202322b78ecf3  usr/share/man/man2/version.md\na9af46d4ab2b6d36714d9177510e26ca  usr/share/man/man3/system.terminal.md\n97d3a6b6fa05ad9d5abad1d52032952d  usr/share/man/man2/alarm.md\n2e0a0cdc9d2ade4fbe183999475535ac  usr/share/man/man2/routelist.md\n3af4e3ce46827777ebc9a72faadc8656  usr/share/man/man2/timeacquiresemaphore.md\nd18a93b14fed71208f5f8aa3acd3626c  usr/share/man/man2/mkfifo.md\n1580cca776cbe49c5a7e738522f88bd1  usr/share/man/man2/unmount.md\ne741c0b7f30cf6ac9b7ee24923645449  usr/share/man/man2/devlisten.md\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293548,size=5356},["baseutils.md5sums"]={type="file",created=1740881291497,worldPermissions={execute=true,read=true,write=false},data="ad5fba84720b513d6f26372dd5b5ab28  bin/comm.lua\n987d142e32bf4435302ea980d722f662  bin/chroot.lua\nd0b417ad3ed2f618495a08ac7ccdfbc7  bin/unlink.lua\na405b344188c49650c4271f25a7ab484  bin/pwd.lua\ne5590661b9ac5ad7431baf87f9f6ebd8  bin/ls.lua\n19a7ed0f8311b94f930979801ee228e3  bin/kill.lua\n0f10a6f7c075b3a617909ead335f4d98  bin/uname.lua\n822d221ba295280690311191dc59116c  bin/mv.lua\n28cd84b2857ade19e4b5999e32e5a977  bin/ps.lua\ne73afa8bb012520a303ca3848e7f1a76  bin/unmount.lua\n157c726b4783bd2673d2cba23237a907  bin/man.lua\n2102f2892490510c6e9e544cdf3b7d0a  bin/lua.lua\ne37948d8fe2173d8aed103b254c62d1f  bin/tty.lua\nb01fc398510a4f29b9f20688da4c8416  bin/date.lua\n9cef8a2758c30e387122857d87f120a3  bin/nice.lua\n7e38b7acf96e039b14919857ca2dfff0  bin/echo.lua\n4cf589c746eec22552853c5e16159c41  bin/cp.lua\nef8b2b3d019a3599cbed101638862f4a  bin/uncompress.lua\n30eeb5f52a96f9451aa7675a1781c54c  bin/cash.lua\ned2b6fdd6beca77514505804a2a73769  bin/lsdev.lua\n0162e4fb0aa8420b1f0e1535d0db3b91  bin/rm.lua\nb6f9425e648bbe725388f999543121fe  bin/link.lua\n51f8cdc2583e09f579c03b6ef5062e73  bin/attach.lua\n1e17ad07b4de339a36733bb6b64df2ef  etc/fstab\n6cf0176b6703a4c406cea8c00bab5f99  bin/sleep.lua\na47b79d65900867e04baeb6e74b981aa  bin/basename.lua\ndb653efad0b708300165886068c5120f  bin/less.lua\n386461ecb77eda2da55fc1f7f1930dec  bin/printf.lua\nf440e472d544d26738a6525dfa90b75d  bin/env.lua\nda5ce367b0a4c3af6d41af201ef276d4  bin/du.lua\nc2a7b0aebf221a4b99d35e5960f2fb95  bin/cksum.lua\nd1bc55425d94166e624eefd0c3db0461  bin/mount.lua\nf979bb61d1ec11feadbf75599f242e8a  bin/eject.lua\naf6fa5fb651bfc8b592147b8d24edb63  bin/compress.lua\ne1fd3abb99d7ba394544afdd8bc3219f  bin/apropos.lua\ne03ef0f14153ee028a78157730d8720d  bin/cmp.lua\n41390f5b9ef52688391812ce84611224  bin/nm.lua\naec4174943d2ec4e79d75872f627417c  bin/logger.lua\na200214f00028170ec84b4bac4ab2d65  bin/mkdir.lua\na143fa05fa09243d41711837a71a42f9  bin/df.lua\n7bc6b5e904c9e9a3b895d107a7fd7494  bin/touch.lua\n92ce61ebeec4cf62b1d20c5818f4a06a  bin/whoami.lua\nbac687f4efd22b8d455f1c76a78a3e9a  bin/chmod.lua\ndd5fbf031731db755455e1f38629c4d1  bin/chown.lua\n69c9945d22bca607f5fc6fd9e9c0d8d6  etc/startmgr/system/automount.service\n35f1f8cc65e3946559a835134046bf21  bin/dirname.lua\nd7b659299185af45cce85813753429bd  bin/renice.lua\nef798e1b9b0a0fc28f350411eb197935  bin/reboot.lua\n47df5ee3376c8d52c08065546dd944df  bin/cd.lua\n469245890049f26bfb8b637caa23f4f7  bin/mkfifo.lua\nc1821d21f33e68c32514f1a1b47e332b  bin/rmdir.lua\n22dc5bb80fb08df6b1eb3f56a23f4a7a  bin/expr.lua\n5e2f6f33e2ae0953eff784bc9d151adb  bin/true.lua\n94acf0509749ce1c89dfc0fdef87999e  bin/id.lua\n1c3eb4de206e2d9e1c901daa830b358e  bin/redstone.lua\n517599d164412eaf63b10648690a16aa  bin/cat.lua\nc5d8cb7436d8ad18d06d999ac0465340  bin/nano.lua\n35a3925e059a2329500a5653892ebde5  bin/sh.lua\n714914be6658567665f655a1022cc8ce  bin/dj.lua\n37b20313032486367bc1355219ad3df0  bin/label.lua\n3f3c71d1bccbde885221c4b14d9ea111  bin/cal.lua\n71c3a28801bfa5038fbae9aa13bbf34f  bin/halt.lua\nd58ed7910c0ba7ba878abc6b05f6048e  bin/screenfetch.lua\n6f1593ad1511d26efa3b5c696a7df2b2  bin/clear.lua\n987e5f6bb8457528c7ddb9027544b038  bin/expand.lua\na0acb3bbd7647ffc42881b5b1f652101  bin/false.lua\nbbdb66d558c4bfa0ac8c80912e68031f  bin/curl.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291497,size=3207},["apt.conffiles"]={type="file",created=1740881291209,worldPermissions={execute=true,read=true,write=false},data="/etc/apt/sources.list\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291209,size=22},["diff.list"]={type="file",created=1740881291784,worldPermissions={execute=true,read=true,write=false},data="/\n/bin/\n/lib/\n/lib/diff.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291784,size=28},["muxzcat.md5sums"]={type="file",created=1740881292924,worldPermissions={execute=true,read=true,write=false},data="dded8eb9f482a41f6db65e6a30f501b8  usr/bin/unxz.lua\n3856053135fee8c5ecc4821c31861023  usr/lib/muxzcat.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292924,size=105},["fatfs.md5sums"]={type="file",created=1740881292095,worldPermissions={execute=true,read=true,write=false},data="68b329da9893e34099c7d8ad5cb9c940  lib/modules/fatfs.lua\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292095,size=56}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294685,size=0},triggers={type="directory",setuser=false,created=1740881294719,worldPermissions={write=false,read=true,execute=true},contents={File={type="file",created=1740881291497,worldPermissions={execute=true,read=true,write=false},data="/usr/share/man baseutils\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291497,size=25},Unincorp={type="file",created=1740881294719,worldPermissions={execute=true,read=true,write=false},data="",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294718,size=0}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294719,size=0},["status-old"]={type="file",created=1740881294720,worldPermissions={execute=true,read=true,write=false},data="Package: asn1\nStatus: install ok installed\nSection: libraries\nVersion: 1.0-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nHomepage: https://github.com/kunkku/lua-asn1\nDescription: ASN.1 serialization library\n Handles serializing and deserializing tables inASN.1 DER format.\n\nPackage: usermgr\nDepends: libsystem\nStatus: install ok installed\nSection: admin\nVersion: 0.1.2-1\nEssential: yes\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: standard\nDescription: user account manager\n Manager service to handle user accounts, includinglogin, passwords, creation, and deletion.\n\nPackage: tracc\nDepends: libsystem\nStatus: install ok installed\nSection: sound\nVersion: 1.0-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: module tracker library and frontend\n tracc is a module tracker for ComputerCraft. It supports playing XM and S3Mmodules natively, as well as limited support for IT.\n\nPackage: pdb\nDepends: libsystem (>= 0.1.6)\nStatus: install ok installed\nSection: devel\nVersion: 0.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: Phoenix debugger program\n Implements a GDB-like debugger for Phoenixprograms.\n\nPackage: compressfs\nDepends: libsystem, libdeflate\nStatus: install ok installed\nSection: kernel\nVersion: 1.0-1\nArchitecture: phoenix\nRecommends: deflateans, luz\nPriority: optional\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Compressed file system driver\n Implements a file system that compresses diskcontents automatically. Supports DEFLATE (throughlibdeflate), DEFLATE-ANS (through deflateans), andLuz (through luz) on supported Lua files.\n\nPackage: libdeflate\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nStatus: install ok installed\nVersion: 1.0.2-3\nSection: libraries\nDescription: DEFLATE/zlib compression library\n Provides compression and decompression for DEFLATEformatted archives, including zlib and gzip files.\n\nPackage: typescript\nStatus: install ok installed\nSection: libraries\nVersion: 1.28.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nHomepage: https://typescript-to-lua.github.io\nDescription: TypeScriptToLua library features bundle\n Provides important polyfills to allow TypeScript code to run on Lua platforms.To use, set \"luaLibImport\" to \"require\" in tsconfig.json, and either set\"luaLibName\" to \"typescript\" (requires @jackmacwindows/typescript-to-lua), orreplace `require(\"lualib-bundle\")` with `require(\"typescript\")` in generatedfiles.\n\nPackage: tar\nDepends: libsystem\nStatus: install ok installed\nSection: utils\nVersion: 1.0.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: important\nDescription: TAR archive format library and program\n Allows creating and extracting TAR archives.\n\nPackage: sha2\nDepends: libsystem\nStatus: install ok installed\nSection: libraries\nVersion: 12-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: SHA-1, SHA-2, SHA-3, BLAKE2 and BLAKE3 functions written in pure Lua and optimized for speed.\n This module contains functions to calculate SHA digest:   MD5, SHA-1,   SHA-224, SHA-256, SHA-512/224, SHA-512/256, SHA-384, SHA-512,   SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, SHAKE256,   HMAC,   BLAKE2b, BLAKE2s, BLAKE2bp, BLAKE2sp, BLAKE2Xb, BLAKE2Xs,   BLAKE3, BLAKE3_KDFWritten in pure Lua.Compatible with:   Lua 5.1, Lua 5.2, Lua 5.3, Lua 5.4, Fengari, LuaJIT 2.0/2.1 (any CPU endianness).Main feature of this module: it was heavily optimized for speed.For every Lua version the module contains particular implementation branch to get benefits from version-specific features.   - branch for Lua 5.1 (emulating bitwise operators using look-up table)   - branch for Lua 5.2 (using bit32/bit library), suitable for both Lua 5.2 with native \"bit32\" and Lua 5.1 with external library \"bit\"   - branch for Lua 5.3/5.4 (using native 64-bit bitwise operators)   - branch for Lua 5.3/5.4 (using native 32-bit bitwise operators) for Lua built with LUA_INT_TYPE=LUA_INT_INT   - branch for LuaJIT without FFI library (useful in a sandboxed environment)   - branch for LuaJIT x86 without FFI library (LuaJIT x86 has oddity because of lack of CPU registers)   - branch for LuaJIT 2.0 with FFI library (bit.* functions work only with Lua numbers)   - branch for LuaJIT 2.1 with FFI library (bit.* functions can work with \"int64_t\" arguments)\n\nPackage: diskmgr\nDepends: libsystem\nStatus: install ok installed\nSection: utils\nVersion: 1.0.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: standard\nDescription: disk auto mounting manager\n Manager service to handle automatically mountingattached disks.\n\nPackage: muxzcat\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nStatus: install ok installed\nVersion: 1.0-1\nSection: libraries\nDescription: LZMA/XZ decompression library\n Provides functions for decompressing LZMA and XZformat compressed files.\n\nPackage: spanfs\nDepends: libsystem\nStatus: install ok installed\nSection: kernel\nVersion: 0.1.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: Spanning filesystem kernel module & utilities\n spanfs provides a RAID-like spanning filesystemthat allows concatenating multiple disk drivesinto a single large virtual disk. One disk storesan index file containing the filesystem structure,and the file data is spread across the rest of thedisks.\n\nPackage: fatfs\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nStatus: install ok installed\nVersion: 1.0-1\nSection: kernel\nDescription: FAT filesystem driver\n Implements the FAT filesystem for Phoenix. Basedon FatFs driver in C.\n\nPackage: yahtcc\nDepends: libsystem\nSection: games\nVersion: 1.0-3\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nStatus: install ok installed\nDescription: Yahtzee game for Phoenix\n Yahtzee game for Phoenix\n\nPackage: ar\nDepends: libsystem\nStatus: install ok installed\nSection: utils\nVersion: 1.1.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: standard\nDescription: ar archive format library and program\n Allows creating and extracting ar/.a archives.\n\nPackage: phoenix-docs\nArchitecture: all\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nStatus: install ok installed\nVersion: 0.0.4-1\nSection: doc\nDescription: Documentation files for Phoenix\n Contains manual files for Phoenix syscalls andkernel API functions, libsystem modules, andbaseutils programs. These are separated from themain packages to save space.\n\nPackage: diff\nDepends: libsystem\nStatus: install ok installed\nSection: utils\nVersion: 1.0-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: important\nDescription: File comparison library and utility\n Provides a library for comparing files, as well asprograms for comparing and patching using the lib.\n\nPackage: githubfs\nDepends: libsystem, fuse\nStatus: install ok installed\nSection: utils\nVersion: 1.0-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: GitHub filesystem provider\n Provides a filesystem for mounting GitHubrepositories on the local system.\n\nPackage: pxboot\nStatus: install ok installed\nSection: admin\nVersion: 0.1.3-1\nEssential: yes\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: required\nDescription: Multipurpose bootloader for ComputerCraft\n A bootloader for ComputerCraft operating systemswith built-in UnBIOS functionality, a configurableselection menu, and more. Designed for Phoenix,but supports other OSes as well, including CraftOS.\n\nPackage: fuse\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nStatus: install ok installed\nVersion: 0.1-1\nSection: kernel\nDescription: Filesystem in userspace module\n fuse implements filesystems in userspace, allowingfilesystems to be implemented without using kernelmodules.\n\nPackage: dhcpmgr\nDepends: libsystem\nStatus: install ok installed\nSection: net\nVersion: 0.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: DHCP server manager for Phoenix\n Implements a Dynamic Host Configuration Protocolserver, which allocates and assigns IP addressesto computers on a network.\n\nPackage: dpkg\nDepends: ar, diff, libdeflate, libsystem, muxzcat, sha2, tar\nStatus: install ok installed\nSection: admin\nVersion: 0.2.6-2\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: required\nDescription: Debian Package Manager for Phoenix\n A port of the Debian Package Manager to thePhoenix operating system, written in Lua.\n\nPackage: netutils\nDepends: libsystem\nStatus: install ok installed\nSection: net\nVersion: 0.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: Network configuration utilities\n Provides a set of programs to configure the systemnetworking layer.\n\nPackage: deflateans\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nStatus: install ok installed\nVersion: 1.0-1\nSection: libraries\nDescription: Compression algorithm utilizing ANS\n A variant of DEFLATE that uses asymmetrical numeral systemsinstead of Huffman coding, increasing decompression speed with similarcompression ratios.\n\nPackage: ccryptolib\nDepends: libsystem\nStatus: install ok installed\nSection: libraries\nVersion: 1.2.2-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: cryptography library for Phoenix\n An integrated collection of cryptographicprimitives written in Lua using the ComputerCraft/Phoenix system API.\n\nPackage: baseutils\nDepends: libsystem\nStatus: install ok installed\nSection: utils\nVersion: 0.2.2-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: important\nDescription: base utility set for Phoenix\n Contains a standard set of POSIX utilities for Phoenix.\n\nPackage: luz\nDepends: libdeflate\nStatus: install ok installed\nSection: libraries\nVersion: 0.1.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: Lua compression algorithm\n Efficient compressor for Lua scripts. Includes ashared library, a command-line utility to compressand decompress Lua files, and a kernel module toallow direct execution of Luz files.\n\nPackage: apt\nDepends: libsystem (>= 0.1.6), dpkg (>= 0.2.6), sha2, pgp, libdeflate\nStatus: install ok installed\nSection: admin\nVersion: 0.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: standard\nDescription: Advanced Package Tool for Phoenix\n A port of the Debian Advanced Package Tool to thePhoenix operating system, written in Lua.\n\nPackage: libsystem\nStatus: install ok installed\nSection: libraries\nVersion: 0.1.6-1\nEssential: yes\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: required\nDescription: System libraries for Phoenix\n Provides convenient wrapper functions for usingPhoenix syscalls, as well as various usefulcomponents for programs.\n\nPackage: netmgr\nDepends: libsystem\nStatus: install ok installed\nSection: net\nVersion: 0.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: Network manager service\n Background manager that automatically configuresnetworking on all available modems.\n\nPackage: advanced-peripherals\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nStatus: install ok installed\nVersion: 1.0-1\nSection: kernel\nDescription: Advanced Peripherals drivers\n Provides drivers for Advanced Peripherals devices.\n\nPackage: aes\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nStatus: install ok installed\nVersion: 1.0-1\nSection: libraries\nDescription: AES encryption library\n Provides functions to encrypt and decrypt datausing the AES algorithm. Supports 128, 192, 256bit keys, and ECB or CBC cipher modes.\n\nPackage: ftp\nDepends: libsystem, sha2\nStatus: install ok installed\nSection: net\nVersion: 0.1-1\nArchitecture: phoenix\nRecommends: fuse, usermgr, startmgr\nPriority: optional\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: RFC 959-compliant FTP client & server\n Implements the FTP protocol on top of Phoenixsockets. Includes an object-oriented library formanaging clients and servers, as well as a smallserver manager for FTP access, and a FUSEfilesystem for mounting FTP shares locally.\n\nPackage: encryptfs\nDepends: libsystem, ccryptolib (>= 1.2.0)\nStatus: install ok installed\nSection: kernel\nVersion: 1.0-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: Encrypted file system driver\n Implements a file system that encrypts diskcontents automatically.\n\nPackage: libcert\nDepends: libsystem, ccryptolib, sha2, aes\nStatus: install ok installed\nSection: libraries\nVersion: 1.0-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: Certificate and security library\n Handles the storage and use of cryptographicresources on the system, including certificates,passwords, API keys, and encryption keys. Alsoprovides functions for validating certificateroots, verifying signatures, and encryption ofdata using certificates.\n\nPackage: libcraftos\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nStatus: install ok installed\nVersion: 0.2.3-1\nSection: libraries\nDescription: CraftOS compatibility library\n Provides CraftOS shim functions to allow runningCraftOS programs on Phoenix.\n\nPackage: startmgr\nDepends: libsystem\nStatus: install ok installed\nSection: admin\nVersion: 0.1.2-1\nEssential: yes\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: standard\nDescription: Phoenix service manager and init system\n Provides automatic service management facilitiesfor Phoenix systems.\n\nPackage: initrd-utils\nDepends: libsystem\nStatus: install ok installed\nSection: admin\nVersion: 0.1.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: initrd management tools\n Contains a collection of utility programs to createand manage initial ramdisk (initrd) files.\n\nPackage: pgp\nDepends: libsystem, ccryptolib, sha2, aes\nStatus: install ok installed\nSection: utils\nVersion: 0.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: standard\nDescription: OpenPGP implementation for Phoenix\n Implements the OpenPGP (RFC 4880/9580  ) standardcryptography scheme in Phoenix, including GPGextensions.\n\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294720,size=15359},status={type="file",created=1740881294720,worldPermissions={execute=true,read=true,write=false},data="Package: dpkg\nDepends: ar, diff, libdeflate, libsystem, muxzcat, sha2, tar\nStatus: install ok installed\nSection: admin\nVersion: 0.2.6-2\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: required\nDescription: Debian Package Manager for Phoenix\n A port of the Debian Package Manager to thePhoenix operating system, written in Lua.\n\nPackage: diff\nDepends: libsystem\nStatus: install ok installed\nSection: utils\nVersion: 1.0-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: important\nDescription: File comparison library and utility\n Provides a library for comparing files, as well asprograms for comparing and patching using the lib.\n\nPackage: tracc\nDepends: libsystem\nStatus: install ok installed\nSection: sound\nVersion: 1.0-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: module tracker library and frontend\n tracc is a module tracker for ComputerCraft. It supports playing XM and S3Mmodules natively, as well as limited support for IT.\n\nPackage: fuse\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nStatus: install ok installed\nVersion: 0.1-1\nSection: kernel\nDescription: Filesystem in userspace module\n fuse implements filesystems in userspace, allowingfilesystems to be implemented without using kernelmodules.\n\nPackage: compressfs\nDepends: libsystem, libdeflate\nStatus: install ok installed\nSection: kernel\nVersion: 1.0-1\nArchitecture: phoenix\nRecommends: deflateans, luz\nPriority: optional\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Compressed file system driver\n Implements a file system that compresses diskcontents automatically. Supports DEFLATE (throughlibdeflate), DEFLATE-ANS (through deflateans), andLuz (through luz) on supported Lua files.\n\nPackage: libdeflate\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nStatus: install ok installed\nVersion: 1.0.2-3\nSection: libraries\nDescription: DEFLATE/zlib compression library\n Provides compression and decompression for DEFLATEformatted archives, including zlib and gzip files.\n\nPackage: ar\nDepends: libsystem\nStatus: install ok installed\nSection: utils\nVersion: 1.1.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: standard\nDescription: ar archive format library and program\n Allows creating and extracting ar/.a archives.\n\nPackage: tar\nDepends: libsystem\nStatus: install ok installed\nSection: utils\nVersion: 1.0.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: important\nDescription: TAR archive format library and program\n Allows creating and extracting TAR archives.\n\nPackage: sha2\nDepends: libsystem\nStatus: install ok installed\nSection: libraries\nVersion: 12-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: SHA-1, SHA-2, SHA-3, BLAKE2 and BLAKE3 functions written in pure Lua and optimized for speed.\n This module contains functions to calculate SHA digest:   MD5, SHA-1,   SHA-224, SHA-256, SHA-512/224, SHA-512/256, SHA-384, SHA-512,   SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, SHAKE256,   HMAC,   BLAKE2b, BLAKE2s, BLAKE2bp, BLAKE2sp, BLAKE2Xb, BLAKE2Xs,   BLAKE3, BLAKE3_KDFWritten in pure Lua.Compatible with:   Lua 5.1, Lua 5.2, Lua 5.3, Lua 5.4, Fengari, LuaJIT 2.0/2.1 (any CPU endianness).Main feature of this module: it was heavily optimized for speed.For every Lua version the module contains particular implementation branch to get benefits from version-specific features.   - branch for Lua 5.1 (emulating bitwise operators using look-up table)   - branch for Lua 5.2 (using bit32/bit library), suitable for both Lua 5.2 with native \"bit32\" and Lua 5.1 with external library \"bit\"   - branch for Lua 5.3/5.4 (using native 64-bit bitwise operators)   - branch for Lua 5.3/5.4 (using native 32-bit bitwise operators) for Lua built with LUA_INT_TYPE=LUA_INT_INT   - branch for LuaJIT without FFI library (useful in a sandboxed environment)   - branch for LuaJIT x86 without FFI library (LuaJIT x86 has oddity because of lack of CPU registers)   - branch for LuaJIT 2.0 with FFI library (bit.* functions work only with Lua numbers)   - branch for LuaJIT 2.1 with FFI library (bit.* functions can work with \"int64_t\" arguments)\n\nPackage: diskmgr\nDepends: libsystem\nStatus: install ok installed\nSection: utils\nVersion: 1.0.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: standard\nDescription: disk auto mounting manager\n Manager service to handle automatically mountingattached disks.\n\nPackage: muxzcat\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nStatus: install ok installed\nVersion: 1.0-1\nSection: libraries\nDescription: LZMA/XZ decompression library\n Provides functions for decompressing LZMA and XZformat compressed files.\n\nPackage: spanfs\nDepends: libsystem\nStatus: install ok installed\nSection: kernel\nVersion: 0.1.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: Spanning filesystem kernel module & utilities\n spanfs provides a RAID-like spanning filesystemthat allows concatenating multiple disk drivesinto a single large virtual disk. One disk storesan index file containing the filesystem structure,and the file data is spread across the rest of thedisks.\n\nPackage: fatfs\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nStatus: install ok installed\nVersion: 1.0-1\nSection: kernel\nDescription: FAT filesystem driver\n Implements the FAT filesystem for Phoenix. Basedon FatFs driver in C.\n\nPackage: yellowbox\nDepends: libsystem, libcraftos\nSection: otherosfs\nVersion: 0.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nStatus: install ok installed\nDescription: CraftOS emulator in the kernel\n    Kernel module that implements a ComputerCraft   emulator in the Phoenix kernel. Allows runningCraftOS programs on a proper CraftOS machine,without using shims or compatibility libraries.\n\nPackage: pgp\nDepends: libsystem, ccryptolib, sha2, aes\nStatus: install ok installed\nSection: utils\nVersion: 0.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: standard\nDescription: OpenPGP implementation for Phoenix\n Implements the OpenPGP (RFC 4880/9580  ) standardcryptography scheme in Phoenix, including GPGextensions.\n\nPackage: ccryptolib\nDepends: libsystem\nStatus: install ok installed\nSection: libraries\nVersion: 1.2.2-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: cryptography library for Phoenix\n An integrated collection of cryptographicprimitives written in Lua using the ComputerCraft/Phoenix system API.\n\nPackage: phoenix-docs\nArchitecture: all\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nStatus: install ok installed\nVersion: 0.0.4-1\nSection: doc\nDescription: Documentation files for Phoenix\n Contains manual files for Phoenix syscalls andkernel API functions, libsystem modules, andbaseutils programs. These are separated from themain packages to save space.\n\nPackage: startmgr\nDepends: libsystem\nStatus: install ok installed\nSection: admin\nVersion: 0.1.2-1\nEssential: yes\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: standard\nDescription: Phoenix service manager and init system\n Provides automatic service management facilitiesfor Phoenix systems.\n\nPackage: libcraftos\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nStatus: install ok installed\nVersion: 0.2.3-1\nSection: libraries\nDescription: CraftOS compatibility library\n Provides CraftOS shim functions to allow runningCraftOS programs on Phoenix.\n\nPackage: pxboot\nStatus: install ok installed\nSection: admin\nVersion: 0.1.3-1\nEssential: yes\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: required\nDescription: Multipurpose bootloader for ComputerCraft\n A bootloader for ComputerCraft operating systemswith built-in UnBIOS functionality, a configurableselection menu, and more. Designed for Phoenix,but supports other OSes as well, including CraftOS.\n\nPackage: libcert\nDepends: libsystem, ccryptolib, sha2, aes\nStatus: install ok installed\nSection: libraries\nVersion: 1.0-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: Certificate and security library\n Handles the storage and use of cryptographicresources on the system, including certificates,passwords, API keys, and encryption keys. Alsoprovides functions for validating certificateroots, verifying signatures, and encryption ofdata using certificates.\n\nPackage: dhcpmgr\nDepends: libsystem\nStatus: install ok installed\nSection: net\nVersion: 0.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: DHCP server manager for Phoenix\n Implements a Dynamic Host Configuration Protocolserver, which allocates and assigns IP addressesto computers on a network.\n\nPackage: usermgr\nDepends: libsystem\nStatus: install ok installed\nSection: admin\nVersion: 0.1.2-1\nEssential: yes\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: standard\nDescription: user account manager\n Manager service to handle user accounts, includinglogin, passwords, creation, and deletion.\n\nPackage: netutils\nDepends: libsystem\nStatus: install ok installed\nSection: net\nVersion: 0.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: Network configuration utilities\n Provides a set of programs to configure the systemnetworking layer.\n\nPackage: deflateans\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nStatus: install ok installed\nVersion: 1.0-1\nSection: libraries\nDescription: Compression algorithm utilizing ANS\n A variant of DEFLATE that uses asymmetrical numeral systemsinstead of Huffman coding, increasing decompression speed with similarcompression ratios.\n\nPackage: asn1\nStatus: install ok installed\nSection: libraries\nVersion: 1.0-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nHomepage: https://github.com/kunkku/lua-asn1\nDescription: ASN.1 serialization library\n Handles serializing and deserializing tables inASN.1 DER format.\n\nPackage: baseutils\nDepends: libsystem\nStatus: install ok installed\nSection: utils\nVersion: 0.2.2-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: important\nDescription: base utility set for Phoenix\n Contains a standard set of POSIX utilities for Phoenix.\n\nPackage: githubfs\nDepends: libsystem, fuse\nStatus: install ok installed\nSection: utils\nVersion: 1.0-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: GitHub filesystem provider\n Provides a filesystem for mounting GitHubrepositories on the local system.\n\nPackage: apt\nDepends: libsystem (>= 0.1.6), dpkg (>= 0.2.6), sha2, pgp, libdeflate\nStatus: install ok installed\nSection: admin\nVersion: 0.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: standard\nDescription: Advanced Package Tool for Phoenix\n A port of the Debian Advanced Package Tool to thePhoenix operating system, written in Lua.\n\nPackage: libsystem\nStatus: install ok installed\nSection: libraries\nVersion: 0.1.6-1\nEssential: yes\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: required\nDescription: System libraries for Phoenix\n Provides convenient wrapper functions for usingPhoenix syscalls, as well as various usefulcomponents for programs.\n\nPackage: netmgr\nDepends: libsystem\nStatus: install ok installed\nSection: net\nVersion: 0.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: Network manager service\n Background manager that automatically configuresnetworking on all available modems.\n\nPackage: advanced-peripherals\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nStatus: install ok installed\nVersion: 1.0-1\nSection: kernel\nDescription: Advanced Peripherals drivers\n Provides drivers for Advanced Peripherals devices.\n\nPackage: aes\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nStatus: install ok installed\nVersion: 1.0-1\nSection: libraries\nDescription: AES encryption library\n Provides functions to encrypt and decrypt datausing the AES algorithm. Supports 128, 192, 256bit keys, and ECB or CBC cipher modes.\n\nPackage: ftp\nDepends: libsystem, sha2\nStatus: install ok installed\nSection: net\nVersion: 0.1-1\nArchitecture: phoenix\nRecommends: fuse, usermgr, startmgr\nPriority: optional\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: RFC 959-compliant FTP client & server\n Implements the FTP protocol on top of Phoenixsockets. Includes an object-oriented library formanaging clients and servers, as well as a smallserver manager for FTP access, and a FUSEfilesystem for mounting FTP shares locally.\n\nPackage: encryptfs\nDepends: libsystem, ccryptolib (>= 1.2.0)\nStatus: install ok installed\nSection: kernel\nVersion: 1.0-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: Encrypted file system driver\n Implements a file system that encrypts diskcontents automatically.\n\nPackage: luz\nDepends: libdeflate\nStatus: install ok installed\nSection: libraries\nVersion: 0.1.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: Lua compression algorithm\n Efficient compressor for Lua scripts. Includes ashared library, a command-line utility to compressand decompress Lua files, and a kernel module toallow direct execution of Luz files.\n\nPackage: pdb\nDepends: libsystem (>= 0.1.6)\nStatus: install ok installed\nSection: devel\nVersion: 0.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: Phoenix debugger program\n Implements a GDB-like debugger for Phoenixprograms.\n\nPackage: yahtcc\nDepends: libsystem\nStatus: install ok installed\nSection: games\nVersion: 1.0-3\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: Yahtzee game for Phoenix\n Yahtzee game for Phoenix\n\nPackage: initrd-utils\nDepends: libsystem\nStatus: install ok installed\nSection: admin\nVersion: 0.1.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nDescription: initrd management tools\n Contains a collection of utility programs to createand manage initial ramdisk (initrd) files.\n\nPackage: typescript\nStatus: install ok installed\nSection: libraries\nVersion: 1.28.1-1\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nHomepage: https://typescript-to-lua.github.io\nDescription: TypeScriptToLua library features bundle\n Provides important polyfills to allow TypeScript code to run on Lua platforms.To use, set \"luaLibImport\" to \"require\" in tsconfig.json, and either set\"luaLibName\" to \"typescript\" (requires @jackmacwindows/typescript-to-lua), orreplace `require(\"lualib-bundle\")` with `require(\"typescript\")` in generatedfiles.\n\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294720,size=15808}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294691,size=0},yellowbox={type="directory",created=1740881294691,worldPermissions={write=false,read=true,execute=true},contents={rom={type="directory",created=1740881294683,worldPermissions={write=false,read=true,execute=true},contents={},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294683,size=0},["startup.lua"]={type="file",created=1740881294691,worldPermissions={execute=false,read=true,write=false},data="\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881294684,size=1}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294691,size=0}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294683,size=0},log={type="directory",created=1740881290993,worldPermissions={execute=true,read=true,write=false},setuser=false,contents={["default.log"]={type="file",created=1740881294720,worldPermissions={execute=true,read=true,write=false},data="[Mar 01 21:08:11] kernel[0] [Info]: Starting Phoenix version 0.0.7 PRERELEASE NONFREE Sat Mar  1 21:02:32 2025 PREEMPT\n[Mar 01 21:08:11] kernel[0] [Info]: Initialized system logger\n[Mar 01 21:08:11] kernel[0] [Info]: System started at 1740881291003 on computer 0\n[Mar 01 21:08:11] kernel[0] [Info]: Computer host is ComputerCraft 1.112.0 (CraftOS-PC v2.8.3)\n[Mar 01 21:08:11] kernel[0] [Debug]: Key table sizes: 211 46\n[Mar 01 21:08:11] kernel[0] [Info]: Loading kernel modules from /lib/modules\n[Mar 01 21:08:11] kernel[0] [Info]: Loading kernel module spanfs from /lib/modules/spanfs.lua\n[Mar 01 21:08:11] kernel[0] (spanfs) [Info]: spanfs is now loaded\n[Mar 01 21:08:11] kernel[0] (Hardware) [Info]: Registered device with type computer on device / using driver root\n[Mar 01 21:08:11] kernel[0] (Hardware) [Info]: Added new device at /redstone\n[Mar 01 21:08:11] kernel[0] (Hardware) [Info]: Added new device at /redstone/top\n[Mar 01 21:08:11] kernel[0] (Hardware) [Info]: Registered device with type redstone on device /redstone/top using driver root_redstone\n[Mar 01 21:08:11] kernel[0] (Hardware) [Info]: Added new device at /redstone/bottom\n[Mar 01 21:08:11] kernel[0] (Hardware) [Info]: Registered device with type redstone on device /redstone/bottom using driver root_redstone\n[Mar 01 21:08:11] kernel[0] (Hardware) [Info]: Added new device at /redstone/left\n[Mar 01 21:08:11] kernel[0] (Hardware) [Info]: Registered device with type redstone on device /redstone/left using driver root_redstone\n[Mar 01 21:08:11] kernel[0] (Hardware) [Info]: Added new device at /redstone/right\n[Mar 01 21:08:11] kernel[0] (Hardware) [Info]: Registered device with type redstone on device /redstone/right using driver root_redstone\n[Mar 01 21:08:11] kernel[0] (Hardware) [Info]: Added new device at /redstone/front\n[Mar 01 21:08:11] kernel[0] (Hardware) [Info]: Registered device with type redstone on device /redstone/front using driver root_redstone\n[Mar 01 21:08:11] kernel[0] (Hardware) [Info]: Added new device at /redstone/back\n[Mar 01 21:08:11] kernel[0] (Hardware) [Info]: Registered device with type redstone on device /redstone/back using driver root_redstone\n[Mar 01 21:08:11] kernel[0] (Hardware) [Info]: Added new device at /lo\n[Mar 01 21:08:11] kernel[0] (Hardware) [Info]: Registered device with type modem on device /lo using driver loopback_modem\n[Mar 01 21:08:11] kernel[0] [Info]: Configured IP for loopback device\n[Mar 01 21:08:11] kernel[0] [Info]: Starting init from /mkramfs_stage2.lua\n[Mar 01 21:08:11] kernel[0] [Debug]: Reaping process 2 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:11] kernel[0] [Debug]: Reaping process 3 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:11] kernel[0] [Debug]: Creating link /usr/bin/apt-add-repository.lua.dpkg-new  =>  /usr/bin/add-apt-repository.lua\n[Mar 01 21:08:11] kernel[0] [Debug]: Creating link /usr/lib/apt/methods/https.lua.dpkg-new  =>  /usr/lib/apt/methods/http.lua\n[Mar 01 21:08:11] kernel[0] [Debug]: Reaping process 4 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:11] kernel[0] [Debug]: Reaping process 5 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:11] kernel[0] [Debug]: Reaping process 6 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:11] kernel[0] [Debug]: Creating link /etc/startmgr/system/startup.service.wants/automount.service.dpkg-new  =>  /etc/startmgr/system/automount.service\n[Mar 01 21:08:11] kernel[0] [Debug]: Reaping process 8 (/var/lib/dpkg/info/baseutils.postinst)\n[Mar 01 21:08:11] kernel[0] [Debug]: Reaping process 7 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:11] kernel[0] [Debug]: Reaping process 9 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:11] kernel[0] [Debug]: Reaping process 10 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:11] kernel[0] [Debug]: Reaping process 11 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:11] kernel[0] [Debug]: Reaping process 12 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:11] kernel[0] [Debug]: Reaping process 13 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:11] kernel[0] [Debug]: Creating link /etc/startmgr/system/startup.service.wants/diskmgr.service.dpkg-new  =>  /etc/startmgr/system/diskmgr.service\n[Mar 01 21:08:11] kernel[0] [Debug]: Reaping process 14 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:11] kernel[0] [Debug]: Reaping process 16 (/bin/man.lua)\n[Mar 01 21:08:11] kernel[0] [Debug]: Reaping process 15 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:12] kernel[0] [Debug]: Reaping process 17 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:12] kernel[0] [Debug]: Reaping process 18 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:12] kernel[0] [Debug]: Reaping process 20 (/bin/man.lua)\n[Mar 01 21:08:12] kernel[0] [Debug]: Reaping process 19 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:12] kernel[0] [Debug]: Reaping process 22 (/bin/man.lua)\n[Mar 01 21:08:12] kernel[0] [Debug]: Reaping process 21 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:12] kernel[0] [Debug]: Reaping process 24 (/bin/man.lua)\n[Mar 01 21:08:12] kernel[0] [Debug]: Reaping process 23 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:12] kernel[0] [Debug]: Reaping process 26 (/bin/man.lua)\n[Mar 01 21:08:12] kernel[0] [Debug]: Reaping process 25 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:12] kernel[0] [Debug]: Reaping process 27 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:12] kernel[0] [Debug]: Reaping process 29 (/bin/man.lua)\n[Mar 01 21:08:12] kernel[0] [Debug]: Reaping process 28 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:12] kernel[0] [Debug]: Reaping process 30 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:12] kernel[0] [Debug]: Reaping process 31 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:12] kernel[0] [Debug]: Reaping process 32 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:12] kernel[0] [Debug]: Reaping process 33 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:12] kernel[0] [Debug]: Reaping process 34 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:13] kernel[0] [Debug]: Reaping process 35 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:13] kernel[0] [Debug]: Reaping process 36 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:13] kernel[0] [Debug]: Reaping process 37 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:13] kernel[0] [Debug]: Reaping process 39 (/bin/man.lua)\n[Mar 01 21:08:13] kernel[0] [Debug]: Reaping process 38 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:13] kernel[0] [Debug]: Reaping process 40 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:13] kernel[0] [Debug]: Reaping process 41 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:13] kernel[0] [Debug]: Reaping process 43 (/bin/man.lua)\n[Mar 01 21:08:13] kernel[0] [Debug]: Reaping process 42 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:14] kernel[0] [Debug]: Reaping process 45 (/bin/man.lua)\n[Mar 01 21:08:14] kernel[0] [Debug]: Reaping process 44 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:14] kernel[0] [Debug]: Reaping process 47 (/bin/man.lua)\n[Mar 01 21:08:14] kernel[0] [Debug]: Reaping process 46 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:14] kernel[0] [Debug]: Reaping process 48 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:14] kernel[0] [Debug]: Reaping process 49 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:14] kernel[0] [Debug]: Creating link /etc/startmgr/system/startup.service.wants/login.service.dpkg-new  =>  /etc/startmgr/system/login.service\n[Mar 01 21:08:14] kernel[0] [Debug]: Reaping process 51 (/var/lib/dpkg/info/usermgr.postinst)\n[Mar 01 21:08:14] kernel[0] [Debug]: Reaping process 52 (/bin/man.lua)\n[Mar 01 21:08:14] kernel[0] [Debug]: Reaping process 50 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:14] kernel[0] [Debug]: Reaping process 54 (/bin/man.lua)\n[Mar 01 21:08:14] kernel[0] [Debug]: Reaping process 53 (/usr/bin/dpkg.lua)\n[Mar 01 21:08:14] kernel[0] [Debug]: Reaping process 56 (/var/lib/dpkg/info/yellowbox.postinst)\n[Mar 01 21:08:14] kernel[0] [Debug]: Reaping process 57 (/bin/man.lua)\n[Mar 01 21:08:14] kernel[0] [Debug]: Reaping process 55 (/usr/bin/dpkg.lua)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294720,size=7479}},permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881290993,size=0}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881290993,size=0},home={type="directory",created=1740881294724,worldPermissions={write=false,read=true,execute=true},contents={phoenix={type="directory",setuser=false,created=1740881294724,worldPermissions={write=false,read=true,execute=true},contents={[".cashrc"]={type="file",created=1740881294724,worldPermissions={execute=true,read=true,write=false},data="PS1=\"\\033[1;32m\\u@\\h\\033[39m:\\033[34m\\W\\033[0m\\$ \"",setuser=false,permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294724,size=50}},permissions={root={write=true,read=true,execute=true},phoenix={execute=true,read=true,write=true}},owner="phoenix",modified=1740881294724,size=0}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294724,size=0},bin={type="directory",created=1740881294686,worldPermissions={write=false,read=true,execute=true},contents={["attach.lua"]={type="file",created=1740881291500,worldPermissions={execute=true,read=true,write=false},data="local a={...}if type(a[1])~=\"string\"or type(a[2])~=\"string\"then print(\"Usage: attach <side> <type> [options...]\")else if tonumber(a[3])~=nil then a[3]=tonumber(a[3])end;local b,c,d=coroutine.yield(\"syscall\",\"attach\",a[1],a[2],a[3])if not b then io.stderr:write(\"Could not attach peripheral\"..(c and\": \"..c or\"\")..\"\\n\")elseif not c then io.stderr:write(\"Could not attach peripheral\"..(d and\": \"..d or\"\")..\"\\n\")end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291460,size=417},["nice.lua"]={type="file",created=1740881291521,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.process\"local b=require\"system.util\"local c=assert(b.argparse({n=\"number\"},...))if not c[1]then error(\"Usage: nice [-n <increment>] <program> [args...]\")end;local d=a.fork(function()a.nice(c.n or 10)a.execp(table.unpack(c))end,c[1])local e,f;repeat e,f=coroutine.yield()until e==\"process_complete\"and f.id==d;return f.value\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291483,size=347},["reboot.lua"]={type="file",created=1740881291523,worldPermissions={execute=true,read=true,write=false},data="return coroutine.yield(\"syscall\",\"devcall\",\"/\",\"reboot\")\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291485,size=57},["cd.lua"]={type="file",created=1740881291502,worldPermissions={execute=true,read=true,write=false},data="return coroutine.yield(\"syscall\",\"chdir\",...)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291463,size=46},["man.lua"]={type="file",created=1740881291517,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=assert(b.argparse({k=false,apropos=\"@k\",P=true,pager=\"@P\",M=true,manpath=\"@M\",S=true,s=\"@S\",sections=\"@S\",r=true,prompt=\"@r\",u=false,update=\"@u\"},...))local d=c.M or os.getenv(\"MANPATH\")or\"/usr/share/man\"local e=c.S or os.getenv(\"MANSECT\")or\"1 8 3 2 5 4 9 6 7\"local f={[\"and\"]=true,[\"break\"]=true,[\"do\"]=true,[\"else\"]=true,[\"elseif\"]=true,[\"end\"]=true,[\"for\"]=true,[\"function\"]=true,[\"if\"]=true,[\"in\"]=true,[\"local\"]=true,[\"not\"]=true,[\"or\"]=true,[\"repeat\"]=true,[\"return\"]=true,[\"then\"]=true,[\"until\"]=true,[\"while\"]=true}local g={[\"false\"]=true,[\"nil\"]=true,[\"true\"]=true}if c.u then for h in d:gmatch\"[^:]+\"do local i=assert(io.open(a.combine(h,\".mandb\"),\"w\"))for j,k in ipairs(a.list(h))do if k:match\"^man\"then for j,l in ipairs(a.list(a.combine(h,k)))do local m=l:match(\"^[^%.]+\")..\"(\"..k:sub(4)..\"): \"local n=io.open(a.combine(h,k,l),\"r\")if n then for o in n:lines()do local p=o:match(\"<summary>(.-)</summary>\")if p then m=m..p;break end end;n:close()end;i:write(m..\"\\n\")end end end;i:close()end;return true elseif c.k then for j,q in ipairs(c)do for h in d:gmatch\"[^:]+\"do local i=io.open(a.combine(h,\".mandb\"),\"r\")if i then for o in i:lines()do if o:match(q)then print(o)end end;i:close()end end end;return true end;if#c>1 and c[1]:match(\"^%d\")then e=table.remove(c,1)end;for j,q in ipairs(c)do for h in d:gmatch\"[^:]+\"do local r=nil;for s in e:gmatch\"[0-9a-z]+\"do if a.exists(a.combine(h,\"man\"..s,q..\".md\"))then r=a.combine(h,\"man\"..s,q..\".md\")break elseif a.exists(a.combine(h,\"man\"..s,q))then r=a.combine(h,\"man\"..s,q)break end end;if r then local m=\"\"local t=true;local u=false;for o in io.lines(r)do if u then if o==\"```\"then u=false;t=true;m=m..\"\\x1b[0m\\n\"else if u==\"lua\"then o=o:gsub(\"%f[%d](%d+)%f[%D]\",\"\\x1b[94m%1\\x1b[37m\"):gsub(\"%-%-.*$\",\"\\x1b[32m%0\\x1b[37m\"):gsub(\"%f[\\\\'\\\"]['\\\"].*%f[\\\\'\\\"]['\\\"]\",\"\\x1b[31m%0\\x1b[37m\")for v in pairs(f)do o=o:gsub(\"%f[0-9A-Za-z_]\"..v..\"%f[^0-9A-Za-z_]\",\"\\x1b[93m%0\\x1b[37m\")end;for v in pairs(g)do o=o:gsub(\"%f[0-9A-Za-z_]\"..v..\"%f[^0-9A-Za-z_]\",\"\\x1b[34m%0\\x1b[37m\")end end;m=m..o..\"\\n\"end else if o:match\"^#\"then if not t then m=m..\"\\n\"end;m=m..\"\\x1b[92m\"..o:match\"^#+%s*(.*)$\"..\"\\x1b[0m\\n\"t=true elseif o:match\"^%s*[%-%*]%s+\"then if not t then m=m..\"\\n\"end;m=m..o:match\"^(%s*)\"..\" \\7 \"..o:match\"^%s*[%-%*]%s+(.*)$\"..\"\\n\"t=true elseif o:match\"^%d+%.%s\"then if not t then m=m..\"\\n\"end;m=m..o..\"\\n\"t=true elseif o:match\"^>%s\"then if not t then m=m..\"\\n\"end;m=m..\"\\x1b[47m\\x1b[30m\\x95\\x1b[49m\\x1b[37m \"..o:match\"^>%s+(.*)$\"..\"\\x1b[0m\\n\"t=true elseif o:match\"^%-%-%-\"then if not t then m=m..\"\\n\"end;m=m..\"\\x8C\\x8C\\x8C\\x8C\\x8C\\x8C\\x8C\\x8C\\x8C\\x8C\\n\"t=true elseif o:match\"<summary>.*</summary>\"then elseif o:match\"^```\"then if o==\"```lua\"then u=\"lua\"else u=true end;if not t then m=m..\"\\n\"end;m=m..\"\\x1b[37m\"else o=o:gsub(\"%f[\\\\%*]%*%*(%S.-)%f[\\\\%*]%*%*\",\"\\x1b[94m%1\\x1b[0m\"):gsub(\"%f[\\\\%*]%*(%S.-)%f[\\\\%*]%*\",\"\\x1b[92m%1\\x1b[0m\"):gsub(\"%f[\\\\`]`(.-)%f[\\\\`]`\",\"\\x1b[37m%1\\x1b[0m\"):gsub(\"\\\\x(%x%x)\",function(w)return string.char(tonumber(w,16))end):gsub(\"\\\\e\",\"\\x1b\")m=m..o..\" \"t=false end;if not t then if o:match\"^%s*$\"then m=m..\"\\n\\n\"t=true elseif o:match\"%s%s$\"then m=m..\"\\n\"t=true end end end end;io.popen(c.P or\"/bin/less -P '\"..(c.r or\"Manual page \"..q)..\"'\",\"w\"):write(m..\"\\n\"):close()break end end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291480,size=3328},["expand.lua"]={type="file",created=1740881291511,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.util\"local b=assert(a.argparse({t=true},...))b.t=b.t or\"8\"if#b==0 then b[1]=\"-\"end;local c={}if b.t:match(\"^%d+$\")then local d=tonumber(b.t)setmetatable(c,{__index=function(e,f)return math.ceil((f+1)/d)*d-f end})elseif b.t:match(\"^[%d, ]+$\")then local g=1;for h in b.t:gmatch\"%d+\"do local d=tonumber(h)assert(d>g,\"expand: invalid tab stop format\")for i=g,d-1 do c[i]=d-i end;g=d end;setmetatable(c,{__index=function(e,f)return 1 end})else error(\"expand: invalid tab stop format\")end;for e,j in ipairs(b)do for k in io.lines(j~=\"-\"and j or nil)do print(k:gsub(\"()\\t\",function(f)return(\" \"):rep(c[f])end))end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291472,size=634},["id.lua"]={type="file",created=1740881291513,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.hardware\"if...then local b=assert(a.wrap(...),\"No such device\")local c=b.state;if c and c.id then print(\"This drive has disk #\"..c.id)else error(\"No disk in drive\")end else print(\"This is computer #\"..a.info(\"/\").metadata.id)end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291475,size=252},["rm.lua"]={type="file",created=1740881291524,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=assert(b.argparse({f=false,i=false,R=\"@r\",r=false,[\"no-preserve-root\"]=false},...))local d=true;for e,f in ipairs(c)do local g=a.stat(f)if not c[\"no-preserve-root\"]and a.combine(f)==\"/\"then io.stderr:write(\"rm: refusing to remove root directory\")elseif not g then if not c.f then io.stderr:write(\"rm: \"..f..\": No such file or directory\\n\")end;d=false elseif g.type==\"directory\"then if c.r then a.remove(f)else io.stderr:write(\"rm: -r not specified, skipping directory \"..f..\"\\n\")d=false end else a.remove(f)end end;return d\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291487,size=594},["unlink.lua"]={type="file",created=1740881291529,worldPermissions={execute=true,read=true,write=false},data="return coroutine.yield(\"syscall\",\"remove\",...)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291492,size=47},["touch.lua"]={type="file",created=1740881291526,worldPermissions={execute=true,read=true,write=false},data="for a,b in ipairs{...}do if b:sub(1,1)~=\"-\"then assert(io.open(b,\"a\")):close()end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291489,size=86},["lsdev.lua"]={type="file",created=1740881291516,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.hardware\"local b=require\"system.util\"local c=assert(b.argparse({v=false},...))local function d(e,f)for g,h in ipairs(a.children(e))do local i=a.info(e..\"/\"..h)if c.v then print((\"%sDevice %s (%s): %s\"):format((\" \"):rep(f),h,i.uuid,i.displayName or\"\"))io.write((\" \"):rep(f)..\"Types: \")local j=true;for k,l in pairs(i.types)do io.write((j and\"\"or\", \")..k..\" (\"..l..\")\")j=false end;print()else print((\"%sDevice %s: %s\"):format((\" \"):rep(f),h,i.displayName or\"\"))end;d(e..\"/\"..h,f+2)end end;local i=a.info(\"/\")if c.v then print((\"Device / (%s): %s\"):format(i.uuid,i.displayName or\"\"))io.write(\"Types: \")local j=true;for k,l in pairs(i.types)do io.write((j and\"\"or\", \")..k..\" (\"..l..\")\")j=false end;print()else print((\"Device /: %s\"):format(i.displayName or\"\"))end;d(\"/\",2)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291479,size=792},["nano.lua"]={type="file",created=1740881291520,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.framebuffer\"local c=require\"system.keys\"local d=require\"system.terminal\"local e=require\"system.util\"local f=\"0.1\"local g=assert(e.argparse({},...))local h={[c.leftBracket]='{',[c.rightBracket]='}',[c.minus]='_',[c.nine]='(',[c.zero]=')',[c.semicolon]=':',[c.up]='\\24',[c.down]='\\25',[c.left]='\\27',[c.right]='\\26'}local i,j;local k=assert(d.openterm())local l=d.termctl()d.termctl{raw=true}local m,n=k.getSize()local o=g[1]local p={}local q=1;local r,s=1,1;local t=b.window(k,1,2,m,n-4)local u=false;local v,w;local x=false;local y,z=\"\",1;local A;local B=true;local C={}local function D(E,F,G)if#E<F then return(G and\"\"or(' '):rep(math.ceil((F-#E)/2)))..E..(' '):rep(math.floor((F-#E)/(G and 1 or 2)))elseif#E==F then return E elseif G then return E:sub(1,F)else return\"...\"..E:sub(-F+3)end end;local function H(I)local J=\"\"if I.key==c.delete and I.shift then J=\"Sh-\"end;if I.ctrl then J=J..\"^\"elseif I.alt then J=J..\"M-\"end;if h[I.key]then J=J..h[I.key]else J=J..c.getCharacter(I.key):upper()end;return J end;local function K()if v then k.setTextColor(d.colors.black)k.setBackgroundColor(d.colors.white)if x then k.setCursorPos(1,n-2)k.clearLine()k.write(v)local F=m-#v-1;if#y>F then if z<F-1 then k.write(y:sub(1,F-1)..\">\")k.setCursorPos(#v+z,n-2)else local L=math.floor((z-F+1)/(F-8)+1)*(F-8)+2;k.write(\"<\"..y:sub(L,L+F-3))if#y>L+m-1 then k.write(\">\")else k.write(y:sub(L+F-3,L+F-2))end;k.setCursorPos(#v+z-L+2,n-2)end else k.write(y)k.setCursorPos(#v+z,n-2)end else k.setCursorPos(math.floor((m-#v)/2)+1,n-2)k.write(v)end;k.setTextColor(d.colors.white)k.setBackgroundColor(d.colors.black)end end;local M;local function N()k.setBackgroundColor(d.colors.black)k.clear()k.setCursorBlink(false)k.setCursorPos(1,1)k.setBackgroundColor(d.colors.white)k.setTextColor(d.colors.black)if m>=#f+#o+26 then k.write(\"  Phoenix nano \"..f..D(o,m-#f-26)..(u and\" Modified  \"or(' '):rep(11)))elseif m>=#o+13 then k.write(\"  \"..D(o,m-13)..(u and\" Modified  \"or(' '):rep(11)))elseif m>=#o+4 and not u then k.write(\"  \"..D(o,m-4)..\"  \")else k.write(D(o,u and m-9 or m)..(u and\" Modified\"or\"\"))end;K()local O,P=k.getCursorPos()k.setCursorPos(1,n-1)local Q=math.floor(m/20)+2;local R=math.floor(m/Q)for S=1,Q do if not i[1][S]then break end;local I=H(i[1][S])local E=D(I..\" \"..i[1][S].description,S==Q and m-R*(S-1)or R,true)k.blit(E,('f'):rep(#I)..('0'):rep(#E-#I),('0'):rep(#I)..('f'):rep(#E-#I))end;k.setCursorPos(1,n)for S=1,Q do if not i[2][S]then break end;local I=H(i[2][S])local E=D(I..\" \"..i[2][S].description,S==Q and m-R*(S-1)or R,true)k.blit(E,('f'):rep(#I)..('0'):rep(#E-#I),('0'):rep(#I)..('f'):rep(#E-#I))end;M()if v and x then k.setCursorPos(O,P)end end;M=function()t.setBackgroundColor(d.colors.black)t.setTextColor(d.colors.white)t.clear()t.setCursorBlink(false)local T,U;for S=1,n-4 do t.setCursorPos(1,S)if p[q+S-1]==nil then break end;if S+q-1==s and#p[q+S-1]>m then if r<m-1 then t.write(p[q+S-1]:sub(1,m-1))t.blit(\">\",\"f\",\"0\")t.setBackgroundColor(d.colors.black)t.setTextColor(d.colors.white)else local L=math.floor((r-m+1)/(m-8)+1)*(m-8)+2;t.blit(\"<\",\"f\",\"0\")t.setBackgroundColor(d.colors.black)t.setTextColor(d.colors.white)t.write(p[q+S-1]:sub(L,L+m-3))if#p[q+S-1]>L+m-1 then t.blit(\">\",\"f\",\"0\")t.setBackgroundColor(d.colors.black)t.setTextColor(d.colors.white)else t.write(p[q+S-1]:sub(L+m-3,L+m-2))end;T,U=r-L+2,s-q+1 end elseif#p[q+S-1]>m then t.write(p[q+S-1]:sub(1,m-1))t.blit(\">\",\"f\",\"0\")t.setBackgroundColor(d.colors.black)t.setTextColor(d.colors.white)else t.write(p[q+S-1])end end;if T==nil then T,U=r,s-q+1 end;t.setCursorPos(T,U)t.setCursorBlink(true)end;local function V(W)v=W;x=false;w=20;N()end;local function X(W,Y,Z)v=W;w=nil;x=true;i=Y or i;y=\"\"z=1;A=Z;N()end;local function _(a0)local a1=1;local a2={\"File Name to Write: \",\"File Name to Write [DOS Format]: \",\"File Name to Write [Mac Format]: \"}X(\"File Name to Write: \",{{{key=c.g,ctrl=true,description=\"Help\"},{key=c.d,alt=true,description=\"DOS Format\",action=function()if a1==2 then a1=1 else a1=2 end;v=a2[a1]K()end},{key=c.a,alt=true,description=\"Append\"},{key=c.b,alt=true,description=\"Backup File\"}},{{key=c.c,ctrl=true,description=\"Cancel\",action=function()i=j;V\"[ Cancelled ]\"end},{key=c.m,alt=true,description=\"Mac Format\",action=function()if a1==3 then a1=1 else a1=3 end;v=a2[a1]K()end},{key=c.p,alt=true,description=\"Prepend\"},{key=c.t,ctrl=true,description=\"Browse\"}}},function(a3)local a4,a5=a.open(a3,\"w\")if not a4 then V(\"[ Could not write file: \"..a5 ..\" ]\")return end;local a6=({\"\\n\",\"\\r\\n\",\"\\r\"})[a1]for a7,a8 in ipairs(p)do a4.write(a8 ..a6)end;a4.close()u=false;if a0 then B=false else V(\"[ Wrote \"..#p..\" lines ]\")end end)if g[1]then y=o;z=#o+1;K()end end;j={{{key=c.g,ctrl=true,description=\"Get Help\"},{key=c.o,ctrl=true,description=\"Write Out\",action=_},{key=c.w,ctrl=true,description=\"Where Is\"},{key=c.k,ctrl=true,description=\"Cut Text\",action=function()if s==#p then V(\"[ Nothing was cut ]\")else C[#C+1]=table.remove(p,s)r=math.min(r,#p[s]+1)if not u then u=true;N()else M()end end end},{key=c.j,ctrl=true,description=\"Justify\"},{key=c.c,ctrl=true,description=\"Cur Pos\",action=function()local a9=0;for U=1,s-1 do a9=a9+#p[U]end;local aa=a9;for U=s,#p do aa=aa+#p[U]end;V((\"[ line %d/%d, col %d/%d, char %d/%d ]\"):format(s,#p,r,#p[s],a9+r-1,aa))end},{key=c.u,alt=true,description=\"Undo\"},{key=c.a,alt=true,description=\"Mark Text\"},{key=c.rightBracket,alt=true,description=\"To Bracket\"},{key=c.q,alt=true,description=\"Previous\"},{key=c.b,ctrl=true,description=\"Back\"},{key=c.left,ctrl=true,description=\"Prev Word\"},{key=c.a,ctrl=true,description=\"Home\"},{key=c.p,ctrl=true,description=\"Prev Line\"},{key=c.up,alt=true,description=\"Scroll Up\"},{key=c.up,ctrl=true,description=\"Prev Block\"},{key=c.nine,shift=true,alt=true,description=\"Beg of Par\"},{key=c.y,ctrl=true,description=\"Prev Page\"},{key=c.backslash,alt=true,description=\"First Line\"},{key=c.left,alt=true,description=\"Prev File\"},{key=c.i,ctrl=true,description=\"Tab\"},{key=c.h,ctrl=true,description=\"Backspace\"},{key=c.delete,shift=true,ctrl=true,description=\"Chop Left\"},{key=c.t,alt=true,description=\"CutTillEnd\"},{key=c.d,alt=true,description=\"Word Count\"},{key=c.l,ctrl=true,description=\"Refresh\"},{key=c.rightBracket,shift=true,alt=true,description=\"Indent\"},{key=c.three,alt=true,description=\"Comment Lines\"},{key=c.semicolon,shift=true,alt=true,description=\"Record\"},{key=c.delete,alt=true,description=\"Zap Text\"},{key=c.f,alt=true,description=\"Formatter\"}},{{key=c.x,ctrl=true,description=\"Exit\"},{key=c.r,ctrl=true,description=\"Read File\"},{key=c.backslash,ctrl=true,description=\"Replace\"},{key=c.u,ctrl=true,description=\"Paste Text\",action=function()if#C==0 then V(\"[ Nothing was pasted ]\")else for S=#C,1,-1 do table.insert(p,s,C[S])end;C={}if not u then u=true;N()else M()end end end},{key=c.t,ctrl=true,description=\"To Spell\"},{key=c.minus,shift=true,ctrl=true,description=\"Go To Line\",action=function()X(\"Enter line number, column number: \",{{{key=c.g,ctrl=true,description=\"Help\"},{key=c.w,ctrl=true,description=\"Begin of Paragr.\"},{key=c.y,ctrl=true,description=\"First Line\"},{key=c.t,ctrl=true,description=\"Go To Text\"}},{{key=c.c,ctrl=true,description=\"Cancel\",action=function()i=j;V\"[ Cancelled ]\"end},{key=c.o,ctrl=true,description=\"End of Paragraph\"},{key=c.v,ctrl=true,description=\"Last Line\"}}},function(W)local ab=tonumber(W)if ab and ab<=#p then s=ab;if s<q then q=s elseif s-n+5>q then q=s-n+5 end else V\"[ Invalid line or column number ]\"end end)end},{key=c.e,alt=true,description=\"Redo\"},{key=c.six,alt=true,description=\"Copy Text\"},{key=c.q,ctrl=true,description=\"Where Was\"},{key=c.w,alt=true,description=\"Next\"},{key=c.f,ctrl=true,description=\"Forward\"},{key=c.right,ctrl=true,description=\"Next Word\"},{key=c.e,ctrl=true,description=\"End\"},{key=c.n,ctrl=true,description=\"Next Line\"},{key=c.down,alt=true,description=\"Scroll Down\"},{key=c.down,ctrl=true,description=\"Next Block\"},{key=c.zero,shift=true,alt=true,description=\"End of Par\"},{key=c.v,ctrl=true,description=\"Next Page\"},{key=c.slash,alt=true,description=\"Last Line\"},{key=c.right,alt=true,description=\"Next File\"},{key=c.m,ctrl=true,description=\"Enter\"},{key=c.d,ctrl=true,description=\"Delete\"},{key=c.delete,ctrl=true,description=\"Chop Right\"},{key=c.j,alt=true,description=\"FullJstify\"},{key=c.v,alt=true,description=\"Verbatim\"},{key=c.z,ctrl=true,description=\"Suspend\"},{key=c.leftBracket,shift=true,alt=true,description=\"Unindent\"},{key=c.rightBracket,ctrl=true,description=\"Complete\"},{key=c.semicolon,alt=true,description=\"Run Macro\"},{key=c.b,alt=true,description=\"To Linter\"},{key=c.s,ctrl=true,description=\"Save\"}}}i=j;if o then if a.stat(o)then for ac in io.lines(o)do table.insert(p,ac)end;V(\"[ Read \"..#p..\" lines ]\")else V\"[ New File ]\"end else o=\"New Buffer\"V\"[ Welcome to nano. For basic help, type Ctrl+G. ]\"end;N()while B do local ad,ae=coroutine.yield()if v and x then if ad==\"key\"then if ae.keycode==c.left and z>1 then z=z-1;K()elseif ae.keycode==c.right and z<=#y then z=z+1;K()elseif ae.keycode==c.backspace and z>1 then y=y:sub(1,z-2)..y:sub(z)z=z-1;K()elseif ae.keycode==c.delete then y=y:sub(1,z-1)..y:sub(z+1)K()elseif ae.keycode==c.enter then v,x=nil;i=j;A(y)N()else local af;for a7,a8 in ipairs(i[1])do if ae.keycode==a8.key and ae.ctrlHeld==(a8.ctrl or false)and ae.altHeld==(a8.alt or false)and ae.shiftHeld==(a8.shift or false)then if a8.action then a8.action()end;af=true;break end end;if not af then for a7,a8 in ipairs(i[2])do if ae.keycode==a8.key and ae.ctrlHeld==(a8.ctrl or false)and ae.altHeld==(a8.alt or false)and ae.shiftHeld==(a8.shift or false)then if a8.action then a8.action()end;af=true;break end end end end elseif ad==\"char\"then y=y:sub(1,z-1)..ae.character..y:sub(z)z=z+1;K()end else if ad==\"key\"then if ae.keycode==c.up and s>1 then s=s-1;if s<q then q=s end;if not p[s]then r=1 elseif r>#p[s]+1 then r=#p[s]+1 end;M()elseif ae.keycode==c.down and s<=#p then s=s+1;if s-n+5>q then q=s-n+5 end;if not p[s]then r=1 elseif r>#p[s]+1 then r=#p[s]+1 end;M()elseif ae.keycode==c.right and p[s]then if#p[s]<r then s=s+1;r=1 else r=r+1 end;M()elseif ae.keycode==c.left and(r>1 or s>1)then if r==1 then s=s-1;r=#p[s]+1 else r=r-1 end;M()elseif ae.keycode==c.backspace then if r==1 then if s~=1 then r=#p[s-1]+1;p[s-1]=p[s-1]..(table.remove(p,s)or\"\")s=s-1;if s<q then q=s end end else p[s]=p[s]:sub(1,r-2)..p[s]:sub(r)r=r-1 end;if not u then u=true;N()else M()end elseif ae.keycode==c.delete and p[s]then if r==#p[s]+1 then p[s]=p[s]..(table.remove(p,s+1)or\"\")else p[s]=p[s]:sub(1,r-1)..p[s]:sub(r+1)end;if not u then u=true;N()else M()end elseif ae.keycode==c.enter then local ag=(p[s]or\"\"):sub(r)p[s]=(p[s]or\"\"):sub(1,r-1)table.insert(p,s+1,ag)r=1;s=s+1;if s-n+5>q then q=s-n+5 end;if not u then u=true;N()else M()end elseif ae.keycode==c.x and ae.ctrlHeld then local ah=true;if u then k.setCursorPos(1,n-2)k.setBackgroundColor(d.colors.white)k.setTextColor(d.colors.black)k.clearLine()k.write(\"Save modified buffer?\")k.setBackgroundColor(d.colors.black)k.setTextColor(d.colors.white)k.setCursorPos(1,n-1)k.clearLine()k.blit(\" Y Yes\",\"ff0000\",\"00ffff\")k.setCursorPos(1,n)k.clearLine()k.blit(\" N No       ^C Cancel\",\"ff0000000000ff0000000\",\"00ffffffffff00fffffff\")k.setCursorBlink(false)while true do ad,ae=coroutine.yield()if ad==\"key\"and ae.keycode==c.c and ae.ctrlHeld then ah=false;break elseif ad==\"char\"then if ae.character==\"y\"then _(true)ah=false;break elseif ae.character==\"n\"then break end end end end;if ah then break end;if not x then V\"[ Cancelled ]\"end else local af;for a7,a8 in ipairs(i[1])do if ae.keycode==a8.key and ae.ctrlHeld==(a8.ctrl or false)and ae.altHeld==(a8.alt or false)and ae.shiftHeld==(a8.shift or false)then if a8.action then a8.action()end;af=true;break end end;if not af then for a7,a8 in ipairs(i[2])do if ae.keycode==a8.key and ae.ctrlHeld==(a8.ctrl or false)and ae.altHeld==(a8.alt or false)and ae.shiftHeld==(a8.shift or false)then if a8.action then a8.action()end;af=true;break end end end end elseif ad==\"char\"then if p[s]then p[s]=p[s]:sub(1,r-1)..ae.character..p[s]:sub(r)else p[s]=ae.character end;r=r+1;if not u then u=true;N()else M()end end end;if w then w=w-1;if w==0 then v,w=nil;N()end end end;k.setBackgroundColor(d.colors.black)k.setTextColor(d.colors.white)k.clear()k.setCursorPos(1,1)k.close()d.termctl(l)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291483,size=12311},["cash.lua"]={type="file",created=1740881291501,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=require\"system.serialization\"local d=require\"system.terminal\"local e=require\"system.util\"local f=assert(e.argparse({c=false,i=false,s=false},...))local g,h;if f.c then h=table.remove(f,1)end;if not f.s then g=table.remove(f,1)end;if not f.c and not f.s and e.syscall.istty()then f.i=true end;local i={}local j=os.time()local k=true;local l=0;local m;local n;local o=b.getenv()if table.maxn==nil then table.maxn=function(p)local q=1;while p[q]~=nil do q=q+1 end;return q-1 end end;local function r(s)return string.match(s,'^()%s*$')and''or string.match(s,'^%s*(.*%S)')end;o.HOME=o.HOME or\"/\"o.SHELL=b.getname()o.PATH=o.PATH or\"/bin:/sbin:/usr/bin\"o.USER=b.getuser()o.EDITOR=o.EDITOR or\"nano\"o.OLDPWD=b.getcwd()o.PWD=o.OLDPWD;o.SHLVL=o.SHLVL and o.SHLVL+1 or 1;o.TERM=o.TERM or\"craftos\"o.COLORTERM=o.COLORTERM or\"16color\"local t={PS1=\"\\\\s-\\\\v\\\\$ \",PS2=\"> \",IFS=\"\\n\",CASH=o.SHELL,CASH_VERSION=\"0.4.1\",RANDOM=function()return math.random(0,32767)end,SECONDS=function()return math.floor((os.time()-j)/1000)end,HOSTNAME=\"localhost\",TERMINATE_QUIT=\"no\",[\"*\"]=table.concat(f,\" \"),[\"@\"]=function()return table.concat(f,\" \")end,[\"#\"]=#f,[\"?\"]=0,[\"0\"]=o.SHELL,_=o.SHELL,[\"$\"]=b.getpid()}local u={}local v={}local w={}local x,y={},0;local z,A={},0;local B,C={},0;local D=nil;local E={}local F={}local G;local H,I;local J=false;local K=false;local L=false;local M={}local N={}local O={}local function P(...)io.write(...)io.write(\"\\n\")end;local Q;Q={[\":\"]=function()return 0 end,[\".\"]=function(R)local S=io.open(R,\"r\")if not S then return 1 end;t.LINENUM=1;for T in S:lines()do i.run(T)t.LINENUM=t.LINENUM+1 end;t.LINENUM=nil;S:close()end,echo=function(...)P(...)return 0 end,builtin=function(U,...)return Q[U](...)end,cd=function(V)V=V or\"/\"if not V:match\"^/\"then V=a.combine(o.PWD,V)end;local W,X=b.chdir(V)if not W then io.stderr:write(\"cash: cd: \"..V..\": \"..X..\"\\n\")return 1 end;o.OLDPWD=o.PWD;o.PWD=V end,command=function(...)L=true;i.run(...)L=false;return t[\"?\"]end,complete=function()end,eval=function(...)i.run(...)return t[\"?\"]end,exec=function(...)m=table.concat({...},' ')i.exit()end,exit=function(...)return i.exit(...)end,export=function(...)local t={...}if#t==0 or t[1]==\"-p\"then for Y,Z in pairs(o)do if type(Z)==\"string\"or type(Z)==\"number\"then P(\"export \"..Y..\"=\"..Z)end end else for Y,Z in ipairs(t)do local _,a0=string.match(Z,\"(.+)=(.+)\")if not(_==nil or a0==nil)and(o[_]==nil or type(o[_])==\"string\"or type(o[_])==\"number\")then o[_]=a0 end end end end,history=function(...)if({...})[1]==\"-c\"then G.close()G=a.open(\".cash_history\",\"w\")F={}return end;local a1={}for Y,Z in ipairs(F)do P(\" \"..Y..string.rep(\" \",math.floor(math.log10(#F))-math.floor(math.log10(Y))+2)..Z)end end,jobs=function(...)local a2={...}for Y,Z in pairs(N)do if Z.cmd~=\"jobs\"then if#a2==0 then P(\"[\"..Y..\"]+  \"..(Z.paused and\"Paused\"or\"Running\")..\"  \"..Z.cmd)else for a3,a4 in ipairs(a2)do if Y==a4 then P(\"[\"..Y..\"]+  \"..(Z.paused and\"Paused\"or\"Running\")..\"  \"..Z.cmd)end end end end end end,pushd=function(a5)if a5 then if not a5:match\"^/\"then a5=a.combine(o.PWD,a5)end;local W,X=b.chdir(a5)if not W then io.stderr:write(\"cash: pushd: \"..a5 ..\": \"..X..\"\\n\")return 1 end end;table.insert(M,o.PWD)if a5 then o.OLDPWD=o.PWD;o.PWD=a5 end;io.write((o.PWD==\"\"and\"/\"or o.PWD)..\" \")for q=#M,1,-1 do io.write((M[q]==\"\"and\"/\"or M[q])..\" \")end;P()end,popd=function()if#M==0 then io.stderr:write(\"cash: popd: directory stack empty\\n\")return-1 end;local W,X=b.chdir(M[#M])if not W then io.stderr:write(\"cash: popd: \"..M[#M]..\": \"..X..\"\\n\")return 1 end;o.PWD=table.remove(M,#M)io.write((o.PWD==\"\"and\"/\"or o.PWD)..\" \")for q=#M,1,-1 do io.write((M[q]==\"\"and\"/\"or M[q])..\" \")end;P()end,dirs=function()io.write((o.PWD==\"\"and\"/\"or o.PWD)..\" \")for q=#M,1,-1 do io.write((M[q]==\"\"and\"/\"or M[q])..\" \")end;P()end,pwd=function()P(o.PWD)end,read=function(a6)t[a6]=io.read()end,set=function(...)local a7={...}if#a7==0 then for Y,Z in pairs(t)do P(Y..\"=\"..Z)end else for Y,Z in ipairs(a7)do if Z:match\"^%-\"then for a8 in Z:sub(2):gmatch\".\"do u[a8]=true end elseif string.find(Z,\"=\")then local _,a0=string.match(Z,\"(.+)=(.+)\")t[_]=a0 end end end end,alias=function(...)local t={...}if#t==0 or t[1]==\"-p\"then for Y,Z in pairs(v)do P(\"alias \"..Y..\"=\"..Z)end else for Y,Z in ipairs(t)do local _,a0=string.match(Z,\"(.+)=(.+)\")v[_]=a0 end end end,sleep=function(a9)e.sleep(tonumber(a9)or 0)end,test=function(...)local f={...}if#f<1 then io.stderr:write(\"cash: test: unary operator expected\\n\")return-1 end;local function aa(Z)return Z end;if f[1]==\"!\"then table.remove(f,1)aa=function(Z)return not Z end end;if string.sub(f[1],1,1)==\"-\"then if f[2]==nil then return aa(true)elseif f[1]==\"-d\"then return aa((a.stat(f[2])or{}).type==\"directory\")elseif f[1]==\"-e\"then return aa(a.stat(f[2])~=nil)elseif f[1]==\"-f\"then return aa((a.stat(f[2])or{}).type==\"file\")elseif f[1]==\"-n\"then return aa(#f[2]>0)elseif f[1]==\"-s\"then return aa(a.stat(f[2])>0)elseif f[1]==\"-u\"then return aa((a.stat(f[2])or{}).permissions.setuid)elseif f[1]==\"-w\"then local ab=a.stat(f[2])if not ab then return aa(false)end;return aa((ab.permissions[b.getuser()]or ab.worldPermissions).write)elseif f[1]==\"-x\"then local ab=a.stat(f[2])if not ab then return aa(false)end;return aa((ab.permissions[b.getuser()]or ab.worldPermissions).execute)elseif f[1]==\"-z\"then return aa(#f[2]==0)else return aa(false)end elseif f[3]and string.sub(f[2],1,1)==\"-\"then if f[2]==\"-eq\"then return aa(tonumber(f[1])==tonumber(f[3]))elseif f[2]==\"-ne\"then return aa(tonumber(f[1])~=tonumber(f[3]))elseif f[2]==\"-lt\"then return aa(tonumber(f[1])<tonumber(f[3]))elseif f[2]==\"-gt\"then return aa(tonumber(f[1])>tonumber(f[3]))elseif f[2]==\"-le\"then return aa(tonumber(f[1])<=tonumber(f[3]))elseif f[2]==\"-ge\"then return aa(tonumber(f[1])>=tonumber(f[3]))else return aa(false)end elseif f[2]==\"=\"then return aa(f[1]==f[3])elseif f[2]==\"!=\"then return aa(f[1]~=f[3])else io.stderr:write(\"cash: test: unary operator expected\\n\")return 2 end end,time=function(...)if not...then io.stderr:write(\"cash: time: missing program path\\n\")return false end;local ac=os.time()local Z={vars={},[0]=...,select(2,...)}local R,ad=i.resolveProgram(Z[0])R=R or Z[0]if not(ad and string.find(Z[0],\"/\")==nil)then Z[0]=R end;local ae=I(Z)if not ae then ae={cputime=0,systime=0}end;P(table.concat({...},\" \"),(\"%.2f user %.2f sys %.3f total\"):format(ae.cputime,ae.systime,(os.time()-ac)/1000))return t[\"?\"]end,[\"true\"]=function()return 0 end,[\"false\"]=function()return 1 end,unalias=function(...)for Y,Z in ipairs({...})do v[Z]=nil end end,unset=function(...)for Y,Z in ipairs({...})do if Z:match\"^%-\"then for a8 in Z:sub(2):gmatch\".\"do u[a8]=nil end else t[Z]=nil end end end,wait=function(af)if af then while N[tonumber(af)]~=nil do sleep(0.1)end else while table.maxn(N)~=0 do sleep(0.1)end end end,cat=function(...)for Y,Z in ipairs({...})do local S=a.open(Z,\"r\")if S~=nil then P(S.readAll())S.close()end end end,which=function(U)if not U then return 1 end;local U,Z=i.resolveProgram(U)if not Z and U then P(U)end end,[\"if\"]=function(...)i.run(...)table.insert(x,{cond=t[\"?\"]==0,inv=false})end,[\"then\"]=function(...)if y>=table.maxn(x)then io.stderr:write(\"cash: syntax error near unexpected token `then'\\n\")return-1 end;y=y+1;i.run(...)return t[\"?\"]end,[\"else\"]=function(...)if y<1 or x[y].inv then io.stderr:write(\"cash: syntax error near unexpected token `else'\\n\")return-1 end;x[y].inv=true;x[y].cond=not x[y].cond;i.run(...)return t[\"?\"]end,fi=function()if y<1 then io.stderr:write(\"cash: syntax error near unexpected token `fi'\\n\")return-1 end;table.remove(x,y)y=y-1 end,[\"while\"]=function(...)table.insert(z,{cond={...},lines={}})end,[\"do\"]=function(...)if table.maxn(z)==0 then io.stderr:write(\"cash: syntax error near unexpected token `do'\\n\")return-1 end;A=A+1 end,done=function()if A<1 then io.stderr:write(\"cash: syntax error near unexpected token `done'\\n\")return-1 end;A=A-1;if A==0 then local ag=table.remove(z,A+1)if type(ag.cond)==\"function\"then ag.cond()else i.run(table.unpack(ag.cond))end;local ah=t[\"?\"]K=false;while ah==0 and not K do for Y,Z in ipairs(ag.lines)do if type(Z)==\"function\"then Z()else i.run(Z)end end;if type(ag.cond)==\"function\"then ag.cond()else i.run(table.unpack(ag.cond))end;ah=t[\"?\"]end end end,[\"break\"]=function()K=true end,[\"for\"]=function(...)local f={...}if f[2]~=\"in\"then io.stderr:write(\"cash: missing `in' in for loop\\n\")return-1 end;local q=2;table.insert(z,{cond=function()q=q+1;t[\"?\"]=f[q]~=nil and 0 or 1 end,lines={function()t[f[1]]=f[q]end}})end,[\"function\"]=function(U,ai)if D~=nil then io.stderr:write(\"cash: syntax error near unexpected token `function'\\n\")return-1 end;if ai~=\"{\"then io.stderr:write(\"cash: syntax error near token `\"..U..\"'\\n\")return-1 end;D=U;E[D]={}end,[\"}\"]=function()if D==nil then io.stderr:write(\"cash: syntax error near unexpected token `}'\\n\")return-1 end;D=nil end,[\"return\"]=function(a6)if J==false then io.stderr:write(\"cash: syntax error near unexpected token `return'\\n\")return-1 end;J=false;return a6 end,bg=function(p)if n then N[n].isfg=false;N[n].paused=false;if CCKernel2 then kernel.signal(signal.SIGCONT,N[n].pid)end;n=nil;return 0 elseif tonumber(p)and N[tonumber(p)]then local aj=tonumber(p)N[aj].isfg=false;N[aj].paused=false;if CCKernel2 then kernel.signal(signal.SIGCONT,N[aj].pid)end;return 0 else io.stderr:write(\"cash: bg: current: no such job\\n\")return 1 end end,fg=function(p)if n then N[n].isfg=true;N[n].paused=false;if CCKernel2 then kernel.signal(signal.SIGCONT,N[n].pid)end;n=nil;return 0 elseif tonumber(p)and N[tonumber(p)]then local aj=tonumber(p)N[aj].isfg=true;N[aj].paused=false;if CCKernel2 then kernel.signal(signal.SIGCONT,N[aj].pid)end;return 0 else io.stderr:write(\"cash: fg: current: no such job\\n\")return 1 end end}Q[\"[\"]=Q.test;function i.exit(ak)k=false;l=ak or 0 end;function i.resolveProgram(U)if Q[U]~=nil then return U end;if v[U]~=nil then U=v[U]end;for R in string.gmatch(o.PATH,\"[^:]+\")do local ai=a.combine(R,U)local ab=a.stat(ai)if ab and ab.type==\"file\"and(ab.permissions[b.getuser()]or ab.worldPermissions).execute then return ai else ai=a.combine(R,U..\".lua\")ab=a.stat(ai)if ab and ab.type==\"file\"and(ab.permissions[b.getuser()]or ab.worldPermissions).execute then return ai end end end;if(a.stat(U)or{}).type==\"file\"then return U,string.find(U,\"/\")==nil end;if(a.stat(U..\".lua\")or{}).type==\"file\"then return U..\".lua\",string.find(U,\"/\")==nil end;return nil end;local function al(a6)if string.sub(a6,1,1)~=\"$\"then return nil end;if string.sub(a6,2,2)==\"{\"then local am=string.sub(string.match(a6,\"%b{}\"),2,-2)local ak=o[am]or t[am]if type(ak)==\"function\"then return ak(),#am+2 else return ak or\"\",#am+2 end elseif string.sub(a6,2,3)==\"((\"then local an=string.gsub(string.sub(string.match(string.sub(a6,3),\"%b()\"),2,-2),\"%$\",\"\")local ao=loadstring(\"return \"..an)local ap=setmetatable({},{__index=_ENV})for Y,Z in pairs(t)do ap[Y]=Z end;setfenv(ao,ap)return tostring(ao()),#an+4 elseif tonumber(string.sub(a6,2,2))then local am=tonumber(string.match(string.sub(a6,2,2),\"[0-9]+\"))if am==0 then return t[\"0\"],1 else return f[am]or\"\",math.floor(math.log10(am))+1 end else local am=\"\"for a8 in string.gmatch(string.sub(a6,2),\".\")do if a8==\" \"then return\"\",#am end;am=am..a8;if o[am]or t[am]then local ak=o[am]or t[am]if type(ak)==\"function\"then return ak(),#am else return ak or\"\",#am end end end;return\"\",#a6-1 end end;local function aq(ar)local as=false;local at=false;local au=1;local ak={\"\"}local av,aw;for a8 in string.gmatch(ar,\".\")do if av=='&'and a8~='&'and aw~='&'and not at and not as then au=au+1;ak[au]=\"\"end;local ax=false;if a8=='\"'or a8=='\\''and not as then at=not at elseif a8=='\\\\'and not at and not as then ax=true;as=true end;if a8==';'and not at and not as then au=au+1;ak[au]=\"\"elseif not(a8==' 'and ak[au]==\"\")then ak[au]=ak[au]..a8 end;if not ax then as=false end;aw=av;av=a8 end;return ak end;local function ay(ar,az)local aA=false;local as=false;local aB=\"\"local q=1;local function aC(Z)if type(Z)==\"boolean\"then return Z and\"true\"or\"false\"elseif Z==nil then return\"nil\"elseif type(Z)==\"table\"then return c.lua.encode(Z)elseif type(Z)==\"string\"then return Z else return tostring(Z)end end;if az then aB=ar else while q<=#ar do local a8=string.sub(ar,q,q)if a8=='$'and not as and not aA then local s,aa=al(string.sub(ar,q))s=aC(s)aB=aB..s;q=q+aa else if a8=='\\''and not as then aA=not aA end;as=a8=='\\\\'and not as;aB=aB..a8 end;q=q+1 end end;local ak={{[0]=\"\"}}q=0;local au=1;local at=false;as=false;local av,aD;for a8 in string.gmatch(aB,\".\")do if aD then if a8==';'then au=au+1;q=0;ak[au]={[0]=\"\"}elseif av=='&'and a8=='&'then ak[au][aD]=string.sub(ak[au][aD],1,-2)au=au+1;q=0;ak[au]={[0]=\"\",last=0}elseif av=='|'and a8=='|'then ak[au][aD]=string.sub(ak[au][aD],1,-2)au=au+1;q=0;ak[au]={[0]=\"\",last=1}elseif av=='2'and a8=='>'then ak[au].stderr=\"\"aD=\"stderr\"elseif a8=='>'then ak[au].stdout=\"\"aD=\"stdout\"elseif a8=='<'then ak[au].stdin=\"\"aD=\"stdin\"elseif a8~=' 'or ak[au][aD]~=\"\"then ak[au][aD]=ak[au][aD]..a8 end elseif not as then if(a8=='\"'or a8=='\\'')and not as then at=not at elseif not at then if a8==' 'then if#ak[au][q]>0 then q=q+1;ak[au][q]=\"\"end elseif a8==';'then if ak[au][q]==\"\"then ak[au][q]=nil end;au=au+1;q=0;ak[au]={[0]=\"\"}elseif av=='&'and a8=='&'then ak[au][q]=string.sub(ak[au][q],1,-2)if ak[au][q]==\"\"then ak[au][q]=nil end;au=au+1;q=0;ak[au]={[0]=\"\",last=0}elseif av=='|'and a8=='|'then ak[au][q]=string.sub(ak[au][q],1,-2)if ak[au][q]==\"\"then ak[au][q]=nil end;au=au+1;q=0;ak[au]={[0]=\"\",last=1}elseif av=='2'and a8=='>'then if ak[au][q]==\"\"then ak[au][q]=nil end;ak[au].stderr=\"\"aD=\"stderr\"elseif a8=='>'then if ak[au][q]==\"\"then ak[au][q]=nil end;ak[au].stdout=\"\"aD=\"stdout\"elseif a8=='<'then if ak[au][q]==\"\"then ak[au][q]=nil end;ak[au].stdin=\"\"aD=\"stdin\"elseif a8~='\\\\'then ak[au][q]=ak[au][q]..a8 end else ak[au][q]=ak[au][q]..a8 end else ak[au][q]=ak[au][q]..a8 end;as=a8=='\\\\'and not at and not as;av=a8 end;if av=='&'then ak.async=true end;for Y,Z in ipairs(ak)do if Z[0]~=\"\"then local R,ad=i.resolveProgram(Z[0])R=R or Z[0]if not(ad and string.find(Z[0],\"/\")==nil)then Z[0]=R end;Z.vars={}while Z[0]and string.find(Z[0],\"=\")do local a3=string.sub(Z[0],1,string.find(Z[0],\"=\")-1)Z.vars[a3]=string.sub(Z[0],string.find(Z[0],\"=\")+1)Z.vars[a3]=tonumber(Z.vars[a3])or Z.vars[a3]Z[0]=nil;for q=1,table.maxn(Z)do Z[q-1]=Z[q]Z[q]=nil end end end end;return ak end;local aE=31+28+31+30+31+30;local function aF(aG)if aG<=31 then return\"Jan \"..aG elseif aG>31 and aG<=31+28 then return\"Feb \"..aG-31 elseif aG>31+28 and aG<=31+28+31 then return\"Mar \"..aG-31-28 elseif aG>31+28+31 and aG<=31+28+31+30 then return\"Apr \"..aG-31-28-31 elseif aG>31+28+31+30 and aG<=31+28+31+30+31 then return\"May \"..aG-31-28-31-30 elseif aG>31+28+31+30+31 and aG<=aE then return\"Jun \"..aG-31-28-31-30-31 elseif aG>aE and aG<=aE+31 then return\"Jul \"..aG-aE elseif aG>aE+31 and aG<=aE+31+31 then return\"Aug \"..aG-aE-31 elseif aG>aE+31+31 and aG<=aE+31+31+30 then return\"Sep \"..aG-aE-31-31 elseif aG>aE+31+31+30 and aG<=aE+31+31+30+31 then return\"Oct \"..aG-aE-31-31-30 elseif aG>aE+31+31+30+31 and aG<=aE+31+31+30+31+30 then return\"Nov \"..aG-aE-31-31-30-31 else return\"Dec \"..aG-aE-31-31-30-31-30 end end;local function aH()local ak=(y>0 or A>0 or C>0)and t.PS2 or t.PS1 or\"\\\\$ \"for Y,Z in pairs({[\"\\\\d\"]=aF(0),[\"\\\\e\"]=string.char(0x1b),[\"\\\\h\"]=string.sub(\"localhost\",1,string.find(\"localhost\",\"%.\")),[\"\\\\H\"]=\"localhost\",[\"\\\\n\"]=\"\\n\",[\"\\\\s\"]=string.gsub(t[\"0\"]:match(\"[^/]+$\"),\".lua\",\"\"),[\"\\\\t\"]=\"00:00\",[\"\\\\T\"]=\"00:00\",[\"\\\\u\"]=o.USER,[\"\\\\v\"]=t.CASH_VERSION,[\"\\\\V\"]=t.CASH_VERSION,[\"\\\\w\"]=o.PWD,[\"\\\\W\"]=o.PWD:match(\"[^/]+$\")==\".\"and\"/\"or o.PWD:match(\"[^/]+$\"),[\"\\\\%#\"]=t.LINENUM,[\"\\\\%$\"]=o.USER==\"root\"and\"#\"or\"$\",[\"\\\\([0-7][0-7][0-7])\"]=function(aa)return string.char(tonumber(aa,8))end,[\"\\\\\\\\\"]=\"\\\\\",[\"\\\\%[.+\\\\%]\"]=\"\"})do ak=string.gsub(ak,Y,Z)end;return ak end;function I(aI)local R=aI[0]if R==nil then return end;if#aI==0 and string.find(R,\"=\")~=nil then local Y=string.sub(R,1,string.find(R,\"=\")-1)t[Y]=string.sub(R,string.find(R,\"=\")+1)t[Y]=tonumber(t[Y])or t[Y]return end;local aJ={}for Y,Z in pairs(aI.vars)do aJ[Y]=_ENV[Y]_ENV[Y]=Z end;if y>0 and not x[y].cond and R~=\"else\"and R~=\"elif\"and R~=\"fi\"then return end;if u.x then P(\"- \"..table.concat(aI,\" \",0))end;local ae;if Q[R]~=nil then local aK,aL=io.input(),io.output()if aI.stdin then io.input(aI.stdin)end;if aI.stdout then io.output(aI.stdout)end;t[\"?\"]=Q[R](table.unpack(aI))if aI.stdin then io.input():close()io.input(aK)end;if aI.stdout then io.output():close()io.output(aL)end;if t[\"?\"]==nil or t[\"?\"]==true then t[\"?\"]=0 elseif t[\"?\"]==false then t[\"?\"]=1 end elseif E[R]~=nil and not L then local aM=f;f=aI;J=true;for Y,Z in ipairs(E[R])do i.run(Z)if not J then break end end;f=aM else local ab=a.stat(R)if not ab then io.stderr:write(\"cash: \"..R..\": No such file or directory\\n\")t[\"?\"]=-1;return elseif not(ab.permissions[b.getuser()]or ab.worldPermissions).execute then io.stderr:write(\"cash: \"..R..\": Permission denied\\n\")t[\"?\"]=-1;return end;if aI.stdin then aI.stdin=a.open(aI.stdin,\"rb\")end;if aI.stdout then aI.stdout=a.open(aI.stdout,\"wb\")end;if aI.stderr then aI.stderr=a.open(aI.stderr,\"wb\")end;local aN=t._;t._=R;if m then if aI.stdin then e.syscall.stdin(aI.stdin)end;if aI.stdout then e.syscall.stdout(aI.stdout)end;if aI.stderr then e.syscall.stderr(aI.stderr)end;b.exec(R,table.unpack(aI))return end;local aO=b.fork(function()if aI.stdin then e.syscall.stdin(aI.stdin)elseif aI.async then e.syscall.stdin(nil)end;if aI.stdout then e.syscall.stdout(aI.stdout)end;if aI.stderr then e.syscall.stderr(aI.stderr)end;b.exec(R,table.unpack(aI))end)while true do local U,aP=coroutine.yield()if U==\"process_complete\"and aP.pid==aO then t[\"?\"]=aP.return_value;break end;ae=b.getpinfo(aO)end;if aI.stdin then aI.stdin.close()end;if aI.stdout then aI.stdout.close()end;if aI.stderr then aI.stderr.close()end;if t[\"?\"]==nil or t[\"?\"]==true then t[\"?\"]=0 elseif t[\"?\"]==false then t[\"?\"]=1 end;t._=aN end;for Y,Z in pairs(aI.vars)do _ENV[Y]=aJ[Y]end;return ae end;function H(aI,aQ)if aI.async and not aQ then local aO=b.fork(function()return H(aI,true)end,\"cash\")local aR=#N+1;N[aR]={cmd=aI[1][0]..\" \"..table.concat(aI[1],\" \"),pid=aO,isfg=false,start=true}P(\"[\"..aR..\"] \"..(aO or\"\"))else for aS,aT in ipairs(aI)do if aT[0]then if r(aT[0])~=\"\"and(aT.last==0 and t[\"?\"]==0)or aT.last==1 and t[\"?\"]~=0 or aT.last==nil then I(aT)end else for Y,Z in pairs(aT.vars)do t[Y]=tonumber(Z)or Z end end end end;return t[\"?\"]==0 end;local aU=function(aI)local aO=b.fork(function()return H(aI,true)end,\"cash\")local aR=#N+1;N[aR]={cmd=aI[1][0]and aI[1][0]..\" \"..table.concat(aI[1],\" \")or\"cash\",pid=aO,isfg=not aI.async,start=true}if aI.async then P(\"[\"..aR..\"] \"..(aO or\"\"))end end;function i.run(...)local aV=table.concat({...},\" \")if aV==\"\"or string.sub(aV,1,1)==\"#\"then return end;if D~=nil then if string.find(aV,\"}\")then D=nil else table.insert(E[D],aV)end;return true elseif A>0 then local aI=aq(aV)for Y,T in ipairs(aI)do T=string.sub(T,#string.match(T,\"^ *\")+1)if T==\"do\"or T==\"done\"or string.find(T,\"^do \")or string.find(T,\"^done \")then H(ay(T))end;if A>0 then table.insert(z[1].lines,T)end end;return true end;local a1=aq(aV)for Y,Z in ipairs(a1)do H(ay(Z,string.sub(Z,1,6)==\"while \"))end;return t[\"?\"]==0 end;function i.runAsync(...)local aV=table.concat({...},\" \")if aV==\"\"or string.sub(aV,1,1)==\"#\"then return end;if D~=nil then if string.find(aV,\"}\")then D=nil else table.insert(E[D],aV)end;return true elseif A>0 then local aI=aq(aV)for Y,T in ipairs(aI)do T=string.sub(T,#string.match(T,\"^ *\")+1)if T==\"do\"or T==\"done\"or string.find(T,\"^do \")or string.find(T,\"^done \")then H(ay(T))end;if A>0 then table.insert(z[1].lines,T)end end;return true end;local a1=aq(aV)for Y,Z in ipairs(a1)do aU(ay(Z,string.sub(Z,1,6)==\"while \"))end;return t[\"?\"]==0 end;if a.stat(\"/etc/cashrc\")then local S,X=io.open(\"/etc/cashrc\",\"r\")if not S then io.stderr:write(\"Could not open /etc/cashrc:\",X)else for T in S:lines()do i.run(T)end;S:close()end end;if a.stat(a.combine(o.HOME,\".cashrc\"))then local S,X=io.open(a.combine(o.HOME,\".cashrc\"),\"r\")if not S then io.stderr:write(\"Could not open .cashrc:\",X)else for T in S:lines()do i.run(T)end;S:close()end end;if a.stat(a.combine(o.HOME,\".cash_history\"))then local S,X=io.open(a.combine(o.HOME,\".cash_history\"),\"r\")if not S then io.stderr:write(\"Could not open .cashhistory:\",X)else for T in S:lines()do table.insert(F,1,T)end;S:close()end;G=a.open(a.combine(o.HOME,\".cash_history\"),\"a\")else G=a.open(a.combine(o.HOME,\".cash_history\"),\"w\")end;if h then t[\"0\"]=g;t.LINENUM=1;i.run(h)t.LINENUM=nil;return l end;if g then if g==\"-\"then t.LINENUM=1;for T in io.lines()do i.run(T)t.LINENUM=t.LINENUM+1;if not k then break end end;t.LINENUM=nil;return l else local S=io.open(g,\"r\")if not S then S=io.open(i.resolveProgram(g),\"r\")if not S then return 1 end end;t[\"0\"]=g;t.LINENUM=1;for T in S:lines()do i.run(T)t.LINENUM=t.LINENUM+1;if not k then break end end;S:close()t.LINENUM=nil;return l end end;while k do if f.i then local aW=aH()io.stdout:write(aW)end;local aX=d.readline2(F,function(aY)if aY:find\" \"then local R=aY:match\"%S*$\"local aZ=a.find(R..\"*\")for q,Z in ipairs(aZ)do if a.isDir(Z)then aZ[q]=Z:gsub(\"^\"..R:gsub(\"[%^%$%(%)%[%]%%%.%*%+%-%?]\",\"%%%1\"),\"\")..\"/\"else aZ[q]=Z:gsub(\"^\"..R:gsub(\"[%^%$%(%)%[%]%%%.%*%+%-%?]\",\"%%%1\"),\"\")..\" \"end end;table.sort(aZ)return aZ else local a_={}for Y in pairs(Q)do if Y:sub(1,#aY)==aY then a_[#a_+1]=Y:sub(#aY+1)..\" \"end end;for Y in pairs(E)do if Y:sub(1,#aY)==aY then a_[#a_+1]=Y:sub(#aY+1)..\" \"end end;for R in o.PATH:gmatch\"[^:]+\"do R=a.combine(R,aY)local aZ=a.find(R..\"*\")for aS,Z in ipairs(aZ)do a_[#a_+1]=Z:gsub(\"^\"..R:gsub(\"[%^%$%(%)%[%]%%%.%*%+%-%?]\",\"%%%1\"),\"\"):gsub(\"%.lua$\",\"\")..\" \"end end;table.sort(a_)return a_ end end)if f.i then if G and aX~=\"\"and aX~=F[1]then table.insert(F,1,aX)G.writeLine(aX)G.flush()end end;i.run(aX)end;if m then i.run(m)return t[\"?\"]end;G.close()return l\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291462,size=21937},["mkdir.lua"]={type="file",created=1740881291518,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.util\"local b=require\"system.filesystem\"local c=assert(a.argparse({p=false,m=true},...))local d=c.m;local e=d and tonumber(d,8)local function f(g)local h=b.stat(g)if e then b.chmod(g,h.owner,bit32.band(bit32.rshift(e,6),7))b.chmod(g,nil,bit32.band(e,7))else for i in d:gmatch\"[^,]+\"do local j,k=i:match\"^([^%+%-=]*)([%+%-=][rwxs]+)$\"if not j then error(\"mkdir: invalid mode: \"..i)end;if j==\"\"then j=nil end;b.chmod(g,j,k)end end end;for l,m in ipairs(c)do if not c.p and not b.isDir(b.dirname(m))then error(\"mkdir: \"..b.dirname(m)..\": Not a directory\")end;b.mkdir(m)if d then f(m)end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291481,size=610},["link.lua"]={type="file",created=1740881291515,worldPermissions={execute=true,read=true,write=false},data="return coroutine.yield(\"syscall\",\"link\",...)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291478,size=45},["chmod.lua"]={type="file",created=1740881291503,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b={...}local c=false;if b[1]==\"-R\"then c=true;table.remove(b,1)end;local d=table.remove(b,1)local e=tonumber(d,8)local function f(g)local h=a.stat(g,true)if e then a.chmod(g,h.owner,bit32.band(bit32.rshift(e,6),7))a.chmod(g,nil,bit32.band(e,7))else for i in d:gmatch\"[^,]+\"do local j,k=i:match\"^([^%+%-=]*)([%+%-=][rwxs]+)$\"if not j then error(\"chmod: invalid mode: \"..i)end;if j==\"\"then j=nil end;a.chmod(g,j,k)end end;if c and h.type==\"directory\"then for l,m in ipairs(a.list(g))do f(a.combine(g,m))end end end;for l,g in ipairs(b)do f(g)end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291463,size=584},["cp.lua"]={type="file",created=1740881291506,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.util\"local b=require\"system.filesystem\"local c=assert(a.argparse({P=false,f=false,i=false,p=false,R=false,H=false,L=false,n=false},...))if#c<2 then error(\"cp: missing operand\")end;local function d(e,f)local g=b.stat(e)if not g then error(\"cp: \"..e..\": No such file or directory\")end;local h=b.stat(f)if g.type==\"directory\"then local i=false;if not c.R then io.stderr:write(\"cp: -R not specified, omitting directory '\"..e..\"'\\n\")return false end;if h then if h.type~=\"directory\"then io.stderr:write(\"cp: omitting existing \"..h.type..\" '\"..f..\"'\\n\")return false end else b.mkdir(f)i=true end;local j=b.list(e)local k=true;for l,m in ipairs(j)do k=d(b.combine(e,m),b.combine(f,m))and k end;if i then b.chmod(f,nil,g.worldPermissions)for n,m in pairs(g.permissions)do b.chmod(f,n,m)end;if g.owner then b.chown(f,g.owner)end end;return k else if h then if c.i then io.stderr:write(\"overwrite \"..h.type..\" \"..f..\"? \")local o=io.read()if o:lower()~=\"y\"then return false end elseif c.n then return false end end;local p,q=b.open(e,\"rb\")if not p then error(\"cp: \"..e..\": \"..q,2)end;local r,q=b.open(f,\"wb\")if not r then if c.f and h then b.remove(f)r,q=b.open(f,\"wb\")end;if not r then p.close()error(q,2)end end;repeat local s=p.read(512)if s then r.write(s)end until not s;r.close()p.close()if c.p then b.chmod(f,nil,g.worldPermissions)for n,m in pairs(g.permissions)do b.chmod(f,n,m)end;if g.owner then b.chown(f,g.owner)end end;return true end end;local t=table.remove(c)if#c==1 and not b.isDir(t)then return d(c[1],t)else if not b.isDir(t)then error(\"cp: target is not a directory\")end;local k=true;for l,m in ipairs(c)do k=d(m,b.combine(t,b.basename(m)))and k end;return k end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291467,size=1696},["sh.lua"]={type="file",created=1740881291526,worldPermissions={execute=true,read=true,write=false},data="return coroutine.yield(\"syscall\",\"exec\",\"/bin/cash\",...)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291488,size=57},["false.lua"]={type="file",created=1740881291512,worldPermissions={execute=true,read=true,write=false},data="return false\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291473,size=13},["chroot.lua"]={type="file",created=1740881291504,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=require\"system.util\"local d=assert(c.argparse({userspec=true,[\"skip-chdir\"]=false},...))if b.getuser()~=\"root\"then error(\"This program requires root.\")end;local e=table.remove(d,1)if not e then error(\"Usage: chroot [options] <path> [program] [args...]\")end;if#d==0 then d[1],d[2]=b.getenv().SHELL or\"/bin/sh\",\"-i\"end;a.chroot(e)if not d[\"skip-chdir\"]then b.chdir(\"/\")end;if d.userspec then b.setuser(d.userspec)end;return b.execp(table.unpack(d))\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291464,size=520},["env.lua"]={type="file",created=1740881291510,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.process\"local b={...}local c=a.getenv()while#b>0 do if b[1]==\"-i\"then for d in pairs(c)do c[d]=nil end;table.remove(b,1)elseif b[1]:find(\"=\")then local d,e=table.remove(b,1):match\"^([^=]+)=(.*)$\"c[d]=e else break end end;if#b==0 then for d,e in pairs(c)do print(d..\"=\"..e)end else return a.execp(table.unpack(b))end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291472,size=339},["sleep.lua"]={type="file",created=1740881291526,worldPermissions={execute=true,read=true,write=false},data="require\"system.util\".sleep(tonumber(...))\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291489,size=42},["mkfifo.lua"]={type="file",created=1740881291518,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=assert(b.argparse({m=true},...))local function d(e)local f=a.stat(e,true)local g=tonumber(c.m,8)if g then a.chmod(e,f.owner,bit32.band(bit32.rshift(g,6),7))a.chmod(e,nil,bit32.band(g,7))else for h in c.m:gmatch\"[^,]+\"do local i,j=h:match\"^([^%+%-=]*)([%+%-=][rwxs]+)$\"if not i then error(\"chmod: invalid mode: \"..h)end;if i==\"\"then i=nil end;a.chmod(e,i,j)end end end;for k,l in ipairs(c)do a.mkfifo(l)if c.m then d(l)end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291481,size=496},["kill.lua"]={type="file",created=1740881291513,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.ipc\"local b={}local c=a.signal.SIGTERM;local d;for e,f in ipairs{...}do if d then c,d=a.signal[\"SIG\"..f]or c,nil elseif f:sub(1,1)==\"-\"then f=f:sub(2)if f==\"s\"then d=true elseif f==\"l\"then b.l=true elseif a.signal[\"SIG\"..f]then c=a.signal[\"SIG\"..f]elseif tonumber(f)then c=tonumber(f)else error(\"unknown argument \"..f)end else b[#b+1]=assert(tonumber(f),\"invalid PID \"..f)end end;if b.l then if b[1]then for g,f in pairs(a.signal)do if f==b[1]then print(g:sub(4))return end end;print(\"UNKNOWN\")return false else for g,f in pairs(a.signal)do io.write(g:sub(4)..\" \")end;print()end else for e,f in ipairs(b)do a.kill(f,c)end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291476,size=649},["screenfetch.lua"]={type="file",created=1740881291525,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.hardware\"local c=require\"system.process\"local d=require\"system.terminal\"local e=require\"system.util\"local f={\"\\x1b[30;40m                \\x1b[0m\",\"\\x1b[30;40m  \\x1b[33;106m\\x88\\x1b[96;43m\\x8F\\x1b[96;40m\\x90 \\x1b[30;106m\\x9F\\x1b[96;40m\\x90   \\x1b[30;106m\\x9F\\x1b[96;43m\\x8F\\x1b[33;106m\\x84\\x1b[30;40m  \\x1b[0m\",\"\\x1b[96;40m \\x9A\\x1b[33;106m\\x89\\x84\\x1b[33;41m\\x82\\x1b[33;40m\\x94\\x1b[30;106m\\x95 \\x1b[96;40m\\x90 \\x1b[30;43m\\x97\\x1b[33;41m\\x81\\x1b[33;106m\\x88\\x86\\x1b[30;106m\\x9A\\x1b[30;40m \\x1b[0m\",\"\\x1b[30;106m\\x9F\\x1b[96;43m\\x9B\\x8C\\x1b[96;41m\\x95 \\x1b[33;40m\\x95\\x1b[30;106m\\x95 \\x96\\x1b[30;40m \\x1b[30;43m\\x95\\x1b[96;41m \\x1b[31;106m\\x95\\x1b[96;43m\\x8C\\x1b[33;106m\\x98\\x1b[96;40m\\x90\\x1b[0m\",\"\\x1b[30;106m\\x95\\x1b[33;106m\\x8C\\x84\\x1b[96;41m\\x95 \\x1b[30;43m\\x8A\\x1b[30;106m\\x95\\x1b[96;100m\\x8F\\x8F\\x1b[96;40m\\x95\\x1b[30;43m\\x85\\x1b[96;41m \\x1b[31;106m\\x95\\x1b[33;106m\\x88\\x8C\\x1b[96;40m\\x95\\x1b[0m\",\"\\x1b[96;40m\\x8A\\x1b[96;43m\\x9C\\x8E\\x1b[31;106m\\x82\\x1b[33;41m \\x82\\x1b[90;106m\\x95\\x1b[33;106m\\x90\\x1b[96;43m\\x9F\\x1b[96;100m\\x95\\x1b[33;41m\\x81 \\x1b[31;106m\\x81\\x1b[96;43m\\x8D\\x1b[33;106m\\x93\\x1b[96;40m\\x85\\x1b[0m\",\"\\x1b[30;40m \\x1b[96;43m\\x9E\\x1b[33;106m\\x8C\\x1b[96;43m\\x9B\\x1b[31;106m\\x82\\x1b[96;41m\\x90\\x1b[90;106m\\x95\\x1b[33;106m\\x85\\x8A\\x1b[96;100m\\x95\\x1b[31;106m\\x9F\\x81\\x1b[33;106m\\x98\\x8C\\x92\\x1b[30;40m \\x1b[0m\",\"\\x1b[96;40m \\x82\\x1b[33;106m\\x86\\x99\\x99\\x1b[96;100m\\x95\\x1b[33;106m\\x8A\\x88\\x81\\x85\\x1b[90;106m\\x95\\x1b[96;43m\\x99\\x99\\x1b[33;106m\\x89\\x1b[106;40m\\x81 \\x1b[0m\",\"\\x1b[33;40m  \\x82\\x8B\\x1b[90;106m \\x96 \\x1b[33;106m\\x95\\x1b[96;43m\\x95\\x1b[96;106m \\x1b[96;100m\\x96\\x1b[96;106m \\x1b[33;40m\\x87\\x81  \\x1b[0m\",\"\\x1b[96;40m     \\x83\\x8B\\x8F\\x8F\\x87\\x83     \\x1b[0m\",\"\\x1b[30;40m                \\x1b[0m\"}local function g(h)local i=math.floor(h/3600)local j=math.floor(h/60)%60;local k=h%60;local l=k..\"s\"if j>0 or i>0 then l=j..\"m \"..l end;if i>0 then l=i..\"h \"..l end;return l end;local function m(h)if h>=1073741824 then return(\"%.3g GiB\"):format(h/1073741824)elseif h>=1048576 then return(\"%.3g MiB\"):format(h/1048576)elseif h>=1024 then return(\"%.3g kiB\"):format(h/1024)else return(\"%.3g B\"):format(h)end end;local n={\"\\x1b[96m\"..c.getuser()..\"\\x1b[0m@\\x1b[96m\"..(b.call(\"/\",\"getLabel\")or\"Computer \"..b.info(\"/\").id)}n[#n+1]=(\"-\"):rep(#n[1]-14)local function o(p,q)n[#n+1]=\"\\x1b[96m\"..p..\"\\x1b[0m: \"..q end;o(\"OS\",\"Phoenix \"..e.syscall.version())o(\"Uptime\",g(e.syscall.uptime()))o(\"Runtime\",e.syscall.cchost():match(\"%b()\"):sub(2,-2))o(\"Lua\",_VERSION)o(\"CC Version\",e.syscall.cchost():match(\"ComputerCraft [%d%.]+\"))o(\"Resolution\",table.concat({d.termsize()},\"x\"))local r=a.stat(\"/\")o(\"Disk Space\",m(r.freeSpace)..\" / \"..m(r.capacity))if collectgarbage then o(\"Memory\",m(collectgarbage(\"count\")*1024))end;n[#n+1]=\"\"n[#n+1]=\"\\x1b[40m   \\x1b[41m   \\x1b[42m   \\x1b[43m   \\x1b[44m   \\x1b[45m   \\x1b[46m   \\x1b[47m   \\x1b[0m\"n[#n+1]=\"\\x1b[100m   \\x1b[101m   \\x1b[102m   \\x1b[103m   \\x1b[104m   \\x1b[105m   \\x1b[106m   \\x1b[107m   \\x1b[0m\"n[#n+1]=\"\"local s=d.termsize()-18;for t=1,math.max(#f,#n)do local k=n[t]or\"\"local u,v=0,false;for w,x in k:gmatch\"(.)()\"do if v then if w=='m'then v=false end elseif w=='\\x1b'then v=true else u=u+1;if u==s then k=k:sub(1,x)v=true;break end end end;if v then io.write((f[t]or\"                \")..\"  \"..k)else print((f[t]or\"                \")..\"  \"..k)end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291488,size=3370},["shell.lua"]={type="file",created=1740881292594,worldPermissions={execute=true,read=true,write=false},data="for a,b in pairs(require\"craftos\")do if a~=\"shell\"and a~=\"multishell\"then _G[a]=b end end;if not fs.isDir(\"/rom\")then if select(2,coroutine.yield(\"syscall\",\"getuser\"))~=\"root\"then error(\"The CraftOS ROM must be mounted to /rom. Please mount it as root.\")end;fs.makeDir(\"/rom\")end;if not fs.isDir(\"/rom/programs\")then if select(2,coroutine.yield(\"syscall\",\"getuser\"))~=\"root\"then error(\"The CraftOS ROM must be mounted to /rom. Please mount it as root.\")end;coroutine.yield(\"syscall\",\"mount\",\"craftos\",\"/rom\",\"/rom\",{})end;local c=coroutine.resume;function coroutine.resume(d,...)local e=table.pack(c(d,...))while e[1]and e[2]==\"syscall\"do e=table.pack(c(d,coroutine.yield(table.unpack(e,2,e.n))))end;return table.unpack(e,1,e.n)end;coroutine.yield(\"syscall\",\"chdir\",\"/\")return coroutine.yield(\"syscall\",\"exec\",\"/rom/programs/shell.lua\",...)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292581,size=841},["ls.lua"]={type="file",created=1740881291516,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=assert(b.argparse({A=false,C=false,F=false,H=false,L=false,R=false,S=false,a=false,c=false,d=false,f=false,g=false,h=false,i=false,k=false,l=false,m=false,n=false,o=false,p=false,q=false,r=false,s=false,t=false,u=false,x=false,[\"1\"]=false},...))if not c[1]then c[1]=\".\"end;if c.f then c.a,c.r,c.S,c.t=true,false,false,false end;if c.a then c.A=true end;if c.g or c.n or c.o then c.l=true end;local d={file='-',directory='d',fifo='p',link='l'}local function e(f,g,h)if c.p and g.type==\"directory\"then f=f..\"/\"elseif c.F then if g.type==\"directory\"then f=f..\"/\"elseif g.type==\"fifo\"then f=f..\"|\"elseif g.type==\"link\"then f=f..\"@\"elseif g.worldPermissions.execute then f=f..\"*\"end end;if c.q then f=f:gsub(\"[\\0-\\31\\127-\\255]\",\"?\")end;if c.s then io.stdout:write(math.ceil(g.size/(c.k and 1024 or 512))..\" \")end;if c.l then local i=g.worldPermissions;local j=g.permissions[g.owner]or g.worldPermissions;local k=(i.read and'r'or'-')..(i.write and'w'or'-')..(i.execute and'x'or'-')local l=(\"%s%s%s%s%s%s\"):format(d[g.type],j.read and'r'or'-',j.write and'w'or'-',j.execute and(g.setuser and's'or'x')or'-',k,k)local m=os.time()-g.modified>15552000000 and os.date(\"%b %e  %Y\",g.modified/1000)or os.date(\"%b %e %H:%M\",g.modified/1000)if c.h then local n,o;if g.size>=1000000000 then n,o=g.size/1000000000,\"G\"elseif g.size>=1000000 then n,o=g.size/1000000,\"M\"elseif g.size>=1000 then n,o=g.size/1000,\"k\"else n=g.size end;if o then print((\"%s %u %s %s\\t%4.3g%s %s %s%s\"):format(l,0,c.g and\"\"or g.owner,\"\",n,o,m,f,g.type==\"link\"and\" -> \"..g.link or\"\"))else print((\"%s %u %s %s\\t%5.3g %s %s%s\"):format(l,0,c.g and\"\"or g.owner,\"\",n,m,f,g.type==\"link\"and\" -> \"..g.link or\"\"))end else print((\"%s %u %s %s\\t%\"..h..\"u %s %s%s\"):format(l,0,c.g and\"\"or g.owner,\"\",math.ceil(g.size/(c.k and 1024 or 512)),m,f,g.type==\"link\"and\" -> \"..g.link or\"\"))end elseif c.m then io.stdout:write(f..\", \")elseif c.C then elseif c.x then else print(f)end end;for p,q in ipairs(c)do if#c>1 then print(q..\":\")end;local g,r=a.stat(q,true)local s;if g then if g.type==\"directory\"then s=a.list(q)else q,s=a.dirname(q),{a.basename(q)}end;local t={}if c.a then s[#s+1]=\".\"s[#s+1]=\"..\"end;for p,u in ipairs(s)do if c.A or not u:match\"^%.\"then local v=a.stat(a.combine(q,u),true)if v then t[#t+1]={name=u,stat=v}end end end;local w;if c.r then w=function(x,y)return x>=y end else w=function(x,y)return x<y end end;if c.S then table.sort(t,function(x,y)if x.stat.size==y.stat.size then return w(x.name,y.name)else return not w(x.stat.size,y.stat.size)end end)elseif c.t then table.sort(t,function(x,y)if x.stat.modified==y.stat.modified then return w(x.name,y.name)else return not w(x.stat.modified,y.stat.modified)end end)elseif not c.f then table.sort(t,function(x,y)return w(x.name,y.name)end)end;if c.l or c.s then local n=0;for p,z in ipairs(t)do n=n+math.ceil(z.stat.size/(c.k and 1024 or 512))end;print(\"total \"..n)end;local A=0;for p,z in ipairs(t)do A=math.max(A,math.ceil(math.log(z.stat.size/(c.k and 1024 or 512),10)))end;for p,z in ipairs(t)do e(z.name,z.stat,A)end;if c.m then print()end else io.stderr:write(\"ls: cannot access '\"..q..\"': \"..(r or\"\")..\"\\n\")end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291479,size=3202},["df.lua"]={type="file",created=1740881291508,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=assert(b.argparse({k=false,P=false,t=false,h=false},...))local d=a.mountlist()local e={}if#c==0 then for f,g in ipairs(d)do e[f],g.stat=g,a.stat(g.path)end else for f,g in ipairs(c)do local h,i=a.stat(g)if h then for j,k in ipairs(d)do if k.path==h.mountpoint then e[f],k.stat=k,h;break end end else io.stderr:write(\"df: could not stat \"..g..\": \"..(i or\"\")..\"\\n\")end end end;local function l(m)if m==math.huge then return\"inf\"elseif m~=m then return\"nan\"else return tostring(m)end end;if c.P then local n=c.k and 1024 or 512;print(\"Filesystem \"..n..\"-blocks Used Available Capacity Mounted on\")for j,g in ipairs(e)do print((\"%s %s %s %s %s%% %s\"):format(g.source,l(math.ceil(g.stat.capacity/n)),l(math.ceil((g.stat.capacity-g.stat.freeSpace)/n)),l(math.ceil(g.stat.freeSpace/n)),l(math.floor((g.stat.capacity-g.stat.freeSpace)/g.stat.capacity*100)),g.path))end elseif c.h then local function o(m)if m==math.huge then return\"inf\"elseif m~=m then return\"nan\"elseif m>=1000000000000 then return(\"%.3gT\"):format(m/1000000000000)elseif m>=1000000000 then return(\"%.3gG\"):format(m/1000000000)elseif m>=1000000 then return(\"%.3gM\"):format(m/1000000)elseif m>=1000 then return(\"%.3gK\"):format(m/1000)else return(\"%.3g \"):format(m)end end;print(\"Filesystem\\tSize\\tUsed\\tAvail\\tUse%\\tMounted on\")for j,g in ipairs(e)do print((\"%s\\t%s\\t%s\\t%s\\t%s%%\\t%s\"):format(g.source..(#g.source<8 and\"\\t\"or\"\"),o(g.stat.capacity),o(g.stat.capacity-g.stat.freeSpace),o(g.stat.freeSpace),l(math.floor((g.stat.capacity-g.stat.freeSpace)/g.stat.capacity*100)),g.path))end else local n=c.k and 1024 or 512;print(\"Filesystem\\tSize\\tUsed\\tAvail\\tUse%\\tMounted on\")for j,g in ipairs(e)do print((\"%s\\t%s\\t%s\\t%s\\t%s%%\\t%s\"):format(g.source..(#g.source<8 and\"\\t\"or\"\"),l(math.ceil(g.stat.capacity/n)),l(math.ceil((g.stat.capacity-g.stat.freeSpace)/n)),l(math.ceil(g.stat.freeSpace/n)),l(math.floor((g.stat.capacity-g.stat.freeSpace)/g.stat.capacity*100)),g.path))end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291469,size=2006},["luz.lua"]={type="file",created=1740881292856,worldPermissions={execute=true,read=true,write=false},data="local a=require\"luz.lex\"local b=require\"luz.minify\"local c=require\"luz.compress\"local d=require\"luz.decompress\"local function e()print[[Usage: luz [options] <input> [output]\nOptions:\n  -c       Force compression\n  -d       Force decompression\n  -l <num> Compression level (0-9)\n  -m       Minify before compression (experimental)\n  -r       Run compressed file\n  --help   Show this help\n]]end;local f,g,h={}local i,j;local k=false;local l;for m,n in ipairs{...}do if l then if l==1 then j=tonumber(n)end;l=nil elseif n:sub(1,2)==\"--\"then if n==\"--help\"then return e()end elseif n:sub(1,1)==\"-\"then for o in n:sub(2):gmatch(\".\")do if o==\"c\"then i=1 elseif o==\"d\"then i=2 elseif o==\"l\"then l=1 elseif o==\"r\"then i=3 elseif o==\"m\"then k=true end end elseif not g then g=n elseif not h then h=n else f[#f+1]=n end end;if not g then return e()end;if i==3 then table.insert(f,1,h)h=nil end;if shell then g,h=shell.resolve(g),h and shell.resolve(h)end;local p=assert(io.open(g,\"rb\"))local q=p:read(\"*a\")p:close()if not i then i=q:sub(1,5)==\"\\27LuzQ\"and 2 or 1 end;local r=pcall(load,\"\")if i==3 then local s=d(q)return assert((r and load or loadstring)(s,\"@\"..g,\"t\",_ENV))((table.unpack or unpack)(f))elseif i==2 then h=h or g..\".lua\"local s=d(q)p=assert(io.open(h,\"w\"))p:write(s)p:close()else h=h or g..\".luz\"assert((r and load or loadstring)(q))local t=a(q,1,2)if k then t=b(t)end;local u=c(t,j)p=assert(io.open(h,\"wb\"))p:write(u)p:close()print(g..\": \"..#q..\" => \"..#u)end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292848,size=1467},["less.lua"]={type="file",created=1740881291514,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.keys\"local c=require\"system.process\"local d=require\"system.terminal\"local e=require\"system.util\"local f=assert(e.argparse({[\"chop-long-lines\"]=false,S=\"@chop-long-lines\",[\"prompt\"]=true,P=\"@prompt\",help=false,version=false},...))local g=f[1]local h=not f[\"chop-long-lines\"]local i=f.prompt;if g==nil and not d.istty()then g=\"-\"end;if g==nil then error(\"Missing filename (\\\"less --help\\\" for help)\")end;local j;local k=assert(d.openterm())local l,m,n={},{},{}local o,p=1,1;local q,r=k.getSize()r=r-1;local function s()l={}if g==\"-\"then if not j then j={}repeat local t=io.stdin:read()j[#j+1]=t until not t end;for u,v in ipairs(j)do l[u]=v end else local w=a.open(g,\"r\")if w==nil then error(\"Could not open file \"..g)end;local t=w.readLine()while t do table.insert(l,({string.gsub(t,\"\\t\",\"    \")})[1])t=w.readLine()end;w.close()end;for u,v in ipairs(l)do local x,y,z=\"\",\"\",\"\"local A=1;local B,C=\"0\",\"f\"for D,E,F in v:gmatch\"()%f[\\x1b]\\x1b%[(%d+)m()\"do x=x..v:sub(A,D-1)y=y..B:rep(D-A)z=z..C:rep(D-A)E=tonumber(E)if E==0 then B,C=\"0\",\"f\"elseif E>=30 and E<=37 then B=(\"%x\"):format(15-(E-30))elseif E==39 then B='0'elseif E>=40 and E<=47 then C=(\"%x\"):format(15-(E-40))elseif E==49 then C='f'elseif E>=90 and E<=97 then B=(\"%x\"):format(15-(E-90)-8)elseif E>=100 and E<=107 then C=(\"%x\"):format(15-(E-100)-8)end;A=F end;x=x..v:sub(A)y=y..B:rep(#v-A+1)z=z..C:rep(#v-A+1)l[u],m[u],n[u]=x,y,z end;if h and p==1 then local u=1;while u<=#l do while#l[u]>q do local G=q-(l[u]:sub(1,q):reverse():find(\" \")or 1)+1;table.insert(l,u+1,string.sub(l[u],G+1)or\"\")table.insert(m,u+1,string.sub(m[u],G+1)or\"\")table.insert(n,u+1,string.sub(n[u],G+1)or\"\")l[u],m[u],n[u]=l[u]:sub(1,G),m[u]:sub(1,G),n[u]:sub(1,G)end;u=u+1 end end end;local function H()k.clear()k.setCursorPos(1,1)k.setCursorBlink(false)for u=o,o+r-1 do if l[u]~=nil then k.blit(l[u]:sub(p),m[u]:sub(p),n[u]:sub(p))end;k.setCursorPos(1,u-o+2)end;k.setCursorPos(1,r+1)if i then k.blit(i,string.rep(\"f\",#i),string.rep(\"0\",#i))elseif o>=#l-r then k.blit(\"(END)\",\"fffff\",\"00000\")else k.write(\":\")end;k.setCursorBlink(true)end;local function I(J,m,n)k.setCursorPos(1,r+1)k.clearLine()k.blit(J,m or string.rep(\"0\",#J),n or string.rep(\"f\",#J))local K=\"\"local L=1;while true do k.setCursorPos(#J+1,r+1)k.write(K..string.rep(\" \",q-#K-#J-2))k.setCursorPos(#J+L,r+1)k.setCursorBlink(true)local M,N=coroutine.yield()if M==\"key\"then if N.keycode==b.backspace then if K==\"\"then return nil elseif L>1 then K=string.sub(K,1,L-2)..string.sub(K,L)L=L-1 end elseif N.keycode==b.left and L>1 then L=L-1 elseif N.keycode==b.right and L<#K+1 then L=L+1 elseif N.keycode==b.enter then return K end elseif M==\"char\"then K=string.sub(K,1,L-1)..N.character..string.sub(K,L)L=L+1 end end end;local function O()local P,n,Q=k.getPaletteColor(d.colors.black)k.setPaletteColor(d.colors.black,k.getPaletteColor(d.colors.lightGray))e.sleep(0.1)k.setPaletteColor(d.colors.black,k.getPaletteColor(d.colors.gray))e.sleep(0.05)k.setPaletteColor(d.colors.black,P,n,Q)e.sleep(0.05)end;s()local R=nil;while true do H()local M,N=coroutine.yield()local S=i;i=nil;if M==\"key\"then if N.keycode==b.left and p>q/2 then p=p-q/2 elseif N.keycode==b.right then p=p+q/2 elseif N.keycode==b.up then if o>1 then o=o-1 else O()end elseif N.keycode==b.down or N.keycode==b.enter then if o<#l-r then o=o+1 else O()end elseif N.keycode==b.space then if o<#l-r then o=o+(o<#l-2*r+1 and r or#l-r-o)else O()end end elseif M==\"char\"then if N.character==\"q\"then break elseif N.character==\"f\"then if o<#l-r then o=o+(o<#l-2*r+1 and r or#l-r-o)else O()end elseif N.character==\"b\"then if o>1 then o=o-(o>r+1 and r or o-1)else O()end elseif N.character==\"d\"then if o<#l-r then o=o+(o<#l-1.5*r+1 and r/2 or#l-r-o)else O()end elseif N.character==\"u\"then if o>1 then o=o-(o>r/2+1 and r/2 or o-1)else O()end elseif N.character==\"g\"or N.character==\"<\"then o=1 elseif N.character==\"G\"or N.character==\">\"then o=#l-r elseif N.character==\"e\"or N.character==\"j\"then if o<#l-r then o=o+1 else O()end elseif N.character==\"y\"or N.character==\"k\"then if o>1 then o=o-1 else O()end elseif N.character==\"K\"or N.character==\"Y\"then o=o-1 elseif N.character==\"J\"then o=o+1 elseif N.character==\"/\"then local T=I(\"/\")if T==\"\"then T=R end;if T~=nil then R=T;local U=false;for u=o+1,#l do if string.match(l[u],T)then o=u;U=true;break end end;if o>#l-r then o=#l-r end;if not U then i=\"Pattern not found\"end end elseif N.character==\"?\"then local T=I(\"?\")if T==\"\"then T=R end;if T~=nil then R=T;local U=false;for u=o-1,1,-1 do if string.match(l[u],T)then o=u;U=true;break end end;if o>#l-r then o=#l-r end;if not U then i=\"Pattern not found\"end end elseif N.character==\"n\"then local U=false;for u=o+1,#l do if string.match(l[u],R)then o=u;U=true;break end end;if o>#l-r then o=#l-r end;if not U then i=\"Pattern not found\"end elseif N.character==\"N\"then local U=false;for u=o-1,1,-1 do if string.match(l[u],R)then o=u;U=true;break end end;if o>#l-r then o=#l-r end;if not U then i=\"Pattern not found\"end elseif N.character==\"v\"then local V=c.start(EDITOR or\"/bin/vi\",g)repeat local M,N=coroutine.yield()until M==\"process_complete\"and N.id==V;s()elseif N.character==\"!\"then local W=I(\"!\")if W then local V=c.start(string.gsub(W,\"%%\",g))repeat local M,N=coroutine.yield()until M==\"process_complete\"and N.id==V end end elseif M==\"term_resize\"then q,r=k.getSize()r=r-1;s()elseif M==\"mouse_scroll\"then if N.direction==1 and o<#l-r then o=o+1 elseif N.direction==-1 and o>1 then o=o-1 end else i=S end end;k.clear()k.setCursorPos(1,1)k.close()\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291477,size=5547},["compress.lua"]={type="file",created=1740881291506,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=string.char;local type=type;local d=string.sub;local e=math.floor;local f={}for g=0,255 do local h=c(g)f[h]=g end;local function i(j,k,l,m)if l>=256 then l,m=0,m+1;if m>=256 then k={}m=1 end end;k[j]=m*256+l;l=l+1;return k,l,m end;local function n(o,p)if type(o)~=\"string\"then return nil,\"string expected, got \"..type(o)end;local q=#o;local k={}local l,m=1,1;local r=\"\"local s,t,u,v=9,\"\\x1F\\x9D\\x90\",0,0;for g=1,q do local w=d(o,g,g)local x=r..w;if not(f[x]or k[x])then local y=f[r]or k[r]if not y then return nil,\"algorithm error, could not fetch word\"end;u=u+y*2^v;v=v+s;while v>=8 do t=t..c(u%256)u=e(u/256)v=v-8 end;if m<p then k,l,m=i(x,k,l,m)if l==1 and m==2^(s-8)then if v>0 then t=t..c(u%256)end;u=0;v=0;s=s+1 end end;r=w else r=x end end;u=u+(f[r]or k[r])*2^v;v=v+s;while v>=8 do t=t..c(u%256)u=e(u/256)v=v-8 end;if v>0 then t=t..c(u)end;return t end;local z=assert(b.argparse({b=\"number\",c=false,f=false,k=false,v=false},...))local A;if z[1]==\"-\"or z[1]==nil then A=io.read(\"*a\")else local B=assert(io.open(z[1],\"rb\"))A=B:read(\"*a\")B:close()end;local C=n(A,z.b and 2^(z.b-8)or 256)if z.v then io.stderr:write((\"%s: %.3g%%\\n\"):format(z[1],#C/#A*100))end;if z.c then io.write(C)return end;if not z.f and#C>#A then return 2 end;if not z.f and a.exists(z[1]..\".Z\")then io.write(\"replace file \"..z[1]..\".Z? (y/N) \")local D=io.read()if D~=\"Y\"and D~=\"y\"then return 1 end end;local B=assert(io.open(z[1]..\".Z\",\"wb\"))B:write(C)B:close()if not z.k then os.remove(z[1])end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291467,size=1542},["cat.lua"]={type="file",created=1740881291502,worldPermissions={execute=true,read=true,write=false},data="local a={...}if a[1]==\"-u\"then table.remove(a,1)end;if#a==0 then a[1]=\"-\"end;for b,c in ipairs(a)do if c==\"-\"then io.stdout:write(io.stdin:read(\"*a\"))else local d,e=io.open(c,\"rb\")if not d then error(\"cat: \"..c..\": \"..e)end;io.stdout:write(d:read(\"*a\"))d:close()end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291462,size=270},["redstone.lua"]={type="file",created=1740881291523,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.hardware\"local b=require\"system.util\"local c={...}if c[1]==\"probe\"then local d=false;print(\"Redstone inputs:\")local e={}for f,g in ipairs(a.children(\"/redstone\"))do local h=a.wrap(\"/redstone/\"..g)local i=h.bundledInput;if i and i>0 then d=true end;local j=h.input;if j then e[#e+1]=g..\" (\"..j..\")\"end end;if#e>0 then print(table.concat(e,\", \"))else print(\"None.\")end;if d then print()print(\"Bundled inputs:\")local k={[0]=\"white\",\"orange\",\"magenta\",\"lightBlue\",\"yellow\",\"lime\",\"pink\",\"gray\",\"lightGray\",\"cyan\",\"purple\",\"blue\",\"brown\",\"green\",\"red\",\"black\"}for f,g in ipairs(a.children(\"/redstone\"))do local h=a.wrap(\"/redstone/\"..g)local i=h.bundledInput;if i and i>0 then io.write(g..\": \")local e={}for l=0,15 do if bit32.btest(i,2^l)then e[#e+1]=k[l]end end;print(table.concat(e,\", \"))end end end elseif c[1]==\"set\"then if#c<3 then error(\"Usage: redstone set <side> [color] <value>\")end;local h=assert(a.wrap(\"/redstone/\"..c[2]),\"Not a side\")if#c>=4 then if not h.bundledOutput then error(\"Bundled output is not available\")end;local k={white=0,orange=1,magenta=2,lightBlue=3,yellow=4,lime=5,pink=6,gray=7,grey=7,lightGray=8,lightGrey=8,cyan=9,purple=10,blue=11,brown=12,green=13,red=14,black=15}local m=2^assert(k[c[3]],\"Invalid color\")if c[4]:lower()==\"true\"then h.bundledOutput=bit32.bor(h.bundledOutput,m)else h.bundledOutput=bit32.band(h.bundledOutput,bit32.bnot(m))end else local n;if c[3]:lower()==\"true\"then n=15 else n=tonumber(c[3])or 0 end;h.output=n end elseif c[1]==\"pulse\"then if#c<4 then error(\"Usage: redstone pulse <side> <count> <period>\")end;local h=assert(a.wrap(\"/redstone/\"..c[2]),\"Not a side\")local o=tonumber(c[3])or 1;local p=tonumber(c[4])or 0.5;for f=1,o do h.output=true;b.sleep(p/2)h.output=false;b.sleep(p/2)end else print(\"Usage: redstone <probe|set|pulse> ...\")end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291486,size=1820},["eject.lua"]={type="file",created=1740881291510,worldPermissions={execute=true,read=true,write=false},data="if not...then error(\"Usage: eject <drive>\")end;return assert(coroutine.yield(\"syscall\",\"devcall\",...,\"eject\"))\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291471,size=111},["apropos.lua"]={type="file",created=1740881291499,worldPermissions={execute=true,read=true,write=false},data="return coroutine.yield(\"syscall\",\"exec\",\"/bin/man\",\"-k\",...)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291459,size=61},["logger.lua"]={type="file",created=1740881291515,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.log\"local b=require\"system.process\"local c=require\"system.util\"local d={[0]=\"Debug\",\"Info\",\"Notice\",\"Warning\",\"Error\",\"Critical\",\"Panic\"}local e={[0]='\\27[90m','\\27[97m','\\27[36m','\\27[93m','\\27[31m','\\27[95m','\\27[96m'}local f={...}local g=table.remove(f,1)if g==\"log\"then f=assert(c.argparse({c=true,l=true,m=true,n=true},table.unpack(f)))a.log({name=f.n,level=f.l,category=f.c,module=f.m},table.unpack(f))elseif g==\"create\"then f=assert(c.argparse({F=true,s=false},table.unpack(f)))if not f[1]then error(\"Usage: logger create [-F <file>] [-s] <log>\")end;a.create(f[1],f.s,f.F)elseif g==\"delete\"then f=assert(c.argparse({p=true},table.unpack(f)))if not f[1]then error(\"Usage: logger delete [-p] <log>\")end;a.remove(f[1])if f.p then os.remove(\"/var/log/\"..f[1]..\".log\")end elseif g==\"view\"then if not f[1]then error(\"Usage: logger view <log>\")end;b.run(\"/bin/less\",\"/var/log/\"..f[1]..\".log\")elseif g==\"follow\"then f=assert(c.argparse({f=true},table.unpack(f)))if not f[1]then error(\"Usage: logger follow [-f <filter>] <log>\")end;a.open(f[1],f.f)print(\"Listening for messages...\")while true do local h,i=coroutine.yield()if h==\"syslog\"then if i.traceback then i.message=i.message:gsub(\"\\t\",\"  \"):gsub(\"([^\\n]+):(%d+):\",\"\\27[96m%1\\27[37m:\\27[95m%2\\27[37m:\"):gsub(\"'([^']+)'\\n\",\"\\27[93m'%1'\\27[37m\\n\")end;local j=b.getpinfo(i.process)print((\"%s[%s]%s %s[%d%s]%s [%s]: %s\\27[0m\"):format(e[i.level],os.date(\"%b %d %X\",i.time/1000),i.category and\" <\"..i.category..\">\"or\"\",j and j.name or\"(unknown)\",i.process,i.thread and\":\"..i.thread or\"\",i.module and\" (\"..i.module..\")\"or\"\",d[i.level],i.message))end end else error(\"Usage: logger <log|create|delete|view|follow> ...\")end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291478,size=1691},["yellowbox.lua"]={type="file",created=1740881294686,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.keys\"local c=require\"system.ipc\"local d=require\"system.process\"local e=require\"system.terminal\"local f=require\"system.util\"local function g(h,i)return h[b.getName(i)]end;local function j(k)local h=f.syscall.loadCraftOSAPI(\"keys\")local l=f.syscall.callmodule(\"yellowbox\",\"getTTY\",k)local m=assert(e.openterm())do local n=l.textBuffer;for o=1,l.size.height do m.setCursorPos(1,o)m.blit(n[o][1],n[o][2],n[o][3])end;for p=0,15 do m.setPaletteColor(p,table.unpack(n.palette[p]))end;m.setCursorPos(n.cursor.x,n.cursor.y)m.setCursorBlink(n.cursorBlink)end;while true do local q,r=coroutine.yield()if q==\"tty_redraw\"and r.id==l.id then local n=l.textBuffer;for o=1,l.size.height do m.setCursorPos(1,o)m.blit(n[o][1],n[o][2],n[o][3])end;for p=0,15 do m.setPaletteColor(p,table.unpack(n.palette[p]))end;m.setCursorPos(n.cursor.x,n.cursor.y)m.setCursorBlink(n.cursorBlink)elseif q==\"key\"then c.sendEvent(k,\"key\",{g(h,r.keycode),r.isRepeat})elseif q==\"key_up\"then c.sendEvent(k,\"key_up\",{g(h,r.keycode)})elseif q==\"char\"then c.sendEvent(k,\"char\",{r.character})elseif q==\"paste\"then c.sendEvent(k,\"paste\",{r.text})elseif q==\"mouse_click\"or q==\"mouse_up\"or q==\"mouse_drag\"then c.sendEvent(k,q,{r.button,r.x,r.y})elseif q==\"mouse_scroll\"then c.sendEvent(k,q,{r.direction,r.x,r.y})end end;m.close()end;local s=...if s==\"status\"then print(\"Running boxes:\")local t=d.getplist()for u,v in ipairs(t)do local w=d.getpinfo(v)if w.name==\"[yellowbox]\"then print(\"- PID \"..v..\", running as \"..w.user)end end elseif s==\"start\"then if d.getuser()~=\"root\"then error(\"Starting a box requires root privileges.\")end;local x=f.argparse({p=true,peripherals=\"@p\",b=true,bios=\"@b\",r=true,root=\"@r\",u=true,user=\"@u\",i=false,interactive=\"@i\",http=false,[\"no-http\"]=false},select(2,...))local y={root=\"/var/lib/yellowbox\",user=select(2,d.getuser()),bios=\"/var/lib/yellowbox/bios.lua\",peripherals={}}if x.b then y.bios=x.b end;if x.r then y.root=x.r end;if x.u then y.user=x.u end;if x.http then y.http=true end;if x[\"no-http\"]then y.http=false end;if x.p then for w in x.p:gmatch\"[^,;]+\"do local z,A=w:match\"^([^=]+)=(.+)$\"if not z then error(\"bad argument 'p' (invalid format)\")end;y.peripherals[z]=A end end;local B=assert(io.open(y.bios,\"r\"))y.bios=B:read(\"*a\")B:close()if not a.exists(a.combine(y.root,\"rom/startup.lua\"))then a.mkdir(a.combine(y.root,\"rom\"))a.mount(\"craftos\",\"rom\",a.combine(y.root,\"rom\"),{ro=true})end;local C=f.syscall.callmodule(\"yellowbox\",\"create\",y)print(\"* Started box at PID \"..C)if x.i then j(C)end elseif s==\"stop\"then if d.getuser()~=\"root\"then error(\"Stopping a box requires root privileges.\")end;f.syscall.callmodule(\"yellowbox\",\"stop\",assert(tonumber(select(2,...))))elseif s==\"shutdown\"or s==\"reboot\"then f.syscall.callmodule(\"yellowbox\",s,assert(tonumber(select(2,...))))elseif s==\"view\"then return j(assert(tonumber(select(2,...)),\"argument must be a number\"))elseif s==\"get-bios\"then else error(\"Usage: yellowbox <status|start|stop|shutdown|reboot|view|get-bios> [...]\")end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294669,size=3032},["label.lua"]={type="file",created=1740881291514,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.hardware\"local b={...}if b[1]==\"set\"and not b[3]then b[3],b[2]=b[2],nil end;local c;if b[2]then c=assert(a.wrap(b[2]),\"No such device '\"..b[2]..\"'\")else c=a.wrap(\"/\")end;if not c.getLabel then error(\"Device does not support labels\")end;if b[1]==\"get\"then local d=c.label;if d then print((b[2]or\"Computer\")..\" is labeled '\"..d..\"'\")else print(\"No \"..(b[2]or\"computer\")..\" label\")end elseif b[1]==\"set\"then c.label=b[3]print(\"Set \"..(b[2]or\"computer\")..\" label to '\"..b[3]..\"'\")elseif b[1]==\"clear\"then c.label=nil;print(\"Cleared \"..(b[2]or\"computer\")..\" label\")else error(\"Usage: label <get|set|clear> [drive] [label]\")end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291477,size=645},["whoami.lua"]={type="file",created=1740881291530,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.process\"local b=a.getuser()print(b)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291493,size=59},["uname.lua"]={type="file",created=1740881291528,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.util\"local b=assert(a.argparse({a=false,m=false,n=false,r=false,s=false,v=false},...))if next(b)==nil then b.s=true end;if b.a then b.m,b.n,b.r,b.s,b.v=true,true,true,true,true end;local c={}if b.s then c[#c+1]=\"Phoenix\"end;if b.n then c[#c+1]=a.syscall.devinfo(\"/\").name end;if b.r then c[#c+1]=a.syscall.version()end;if b.v then c[#c+1]=a.syscall.version(true)end;if b.m then c[#c+1]=a.syscall.cchost()end;print(table.concat(c,\" \"))\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291491,size=458},["printf.lua"]={type="file",created=1740881291522,worldPermissions={execute=true,read=true,write=false},data="local a={...}if#a<1 then error(\"printf: missing format\")end;local b=table.remove(a,1)local c={}for d in b:gmatch\"%%[%-%+ #0]?%d*%.?%d*[jzt]?[diuoxXfFeEgGaAcsq]\"do local e=d:sub(-1,-1)local f=#c+1;local g=assert(a[f],\"printf: missing argument for \"..d)if e==\"q\"or e==\"s\"then c[f]=g else c[f]=assert(tonumber(g),\"printf: argument \"..g..\" not a number\")end end;print(b:format(table.unpack(c)))\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291484,size=391},["chown.lua"]={type="file",created=1740881291503,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.util\"local b=require\"system.filesystem\"local c=assert(a.argparse({h=false,H=false,L=false,P=false,R=false},...))if#c<2 then error(\"usage: chown [-h] [-R [-H|-L|-P]] <owner> <file...>\")end;local function d(e,f)b.chown(e,f)if b.stat(e,true).type==\"directory\"then for g,h in ipairs(b.list(e))do d(b.combine(e,h),f)end end end;local f=c[1]:gsub(\":.*\",\"\")for i=2,#c do if c.R then d(c[i],f)else b.chown(c[i],f)end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291464,size=436},["dj.lua"]={type="file",created=1740881291509,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.hardware\"local b={...}local c=b[2]and a.wrap(b[2])or a.find(\"drive\")if not c then if b[2]then error(\"Could not find drive named \"..b[2])else error(\"Could not find any attached drives\")end end;if b[1]==\"play\"then local d=c.state;if not d then error(\"No disc in drive\")elseif not d.audio then error(\"Disc in drive is not a record\")end;c.play()print(\"Playing '\"..d.audio..\"'\")elseif b[1]==\"stop\"then c.stop()else error(\"Usage: dj <play|stop> [drive]\")end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291470,size=475},["uncompress.lua"]={type="file",created=1740881291528,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=string.char;local type=type;local d=string.sub;local e=table.concat;local f=math.floor;local g=string.byte;local h={}for i=0,255 do local j=c(i)h[i]=j end;local function k(l,m,n,o)if n>=256 then n,o=0,o+1;if o>=256 then m={}o=1 end end;m[o*256+n]=l;n=n+1;return m,n,o end;local function p(q)if type(q)~=\"string\"then return nil,\"string expected, got \"..type(q)end;if#q<1 then return nil,\"invalid input - not a compressed string\"end;local r=#q;if r<3 then return nil,\"invalid input - not a compressed string\"end;if d(q,1,2)~=\"\\x1F\\x9D\"then return nil,\"invalid input - not a compressed string\"end;local s,t,u,v=9,0,0,4;local function w()while u<s do if v>r then return nil end;t=t+g(q,v)*2^u;v=v+1;u=u+8 end;local x=t%2^s;t=f(t/2^s)u=u-s;return x end;local m={}local n,o=1,1;local y={}local z=1;local A=w()y[z]=h[A]or m[A]z=z+1;while true do local B=w()if not B then break end;local C=h[A]or m[A]if not C then return nil,\"could not find last from dict. Invalid input?\"end;local D=h[B]or m[B]if D then y[z]=D;z=z+1;m,n,o=k(C..d(D,1,1),m,n,o)else local E=C..d(C,1,1)y[z]=E;z=z+1;m,n,o=k(E,m,n,o)end;if n==256 and o==2^(s-8)-1 then local F=u%8;if F~=0 then t=f(t/2^F)u=u-F end;s=s+1 end;A=B end;return e(y)end;local G=assert(b.argparse({c=false,f=false,k=false,v=false},...))local H;if G[1]==\"-\"or G[1]==nil then H=io.read(\"*a\")else local I=assert(io.open(G[1],\"rb\"))H=I:read(\"*a\")I:close()end;local J=assert(p(H))if G.v then io.stderr:write((\"%s: %.3g%%\\n\"):format(G[1],#J/#H*100))end;if G.c then io.write(J)return end;local K=G[1]:gsub(\"%.Z$\",\"\")if not G.f and a.exists(K)then io.write(\"replace file \"..K..\"? (y/N) \")local L=io.read()if L~=\"Y\"and L~=\"y\"then return 1 end end;local I=assert(io.open(K,\"wb\"))I:write(J)I:close()if not G.k then os.remove(G[1])end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291491,size=1826},["mv.lua"]={type="file",created=1740881291520,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=assert(b.argparse({i=false,f=false},...))if#c<2 then error(\"mv: missing operand\")end;local d=table.remove(c)local e=a.stat(d)if#c==1 and(not e or e.type~=\"directory\")then if e and not c.f and(not a.effectivePermissions(e).write and b.syscall.istty()or c.i)then io.stderr:write(\"mv: overwrite \"..e.type..\" \"..d..\"? \")local f=io.read()if f:lower()~=\"y\"then return false end end;a.move(c[1],d)return end;if not e or e.type~=\"directory\"then error(\"mv: \"..d..\": not a directory\")end;for g,h in ipairs(c)do local i=a.combine(d,a.basename(h))e=a.stat(i)if e and not c.f and(not a.effectivePermissions(e).write and b.syscall.istty()or c.i)then io.stderr:write(\"mv: overwrite \"..e.type..\" \"..i..\"? \")local f=io.read()if f:lower()~=\"y\"then return false end end;a.move(h,i)end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291482,size=836},["cksum.lua"]={type="file",created=1740881291504,worldPermissions={execute=true,read=true,write=false},data="local a={...}local b={[0]=0x00000000,0x04c11db7,0x09823b6e,0x0d4326d9,0x130476dc,0x17c56b6b,0x1a864db2,0x1e475005,0x2608edb8,0x22c9f00f,0x2f8ad6d6,0x2b4bcb61,0x350c9b64,0x31cd86d3,0x3c8ea00a,0x384fbdbd,0x4c11db70,0x48d0c6c7,0x4593e01e,0x4152fda9,0x5f15adac,0x5bd4b01b,0x569796c2,0x52568b75,0x6a1936c8,0x6ed82b7f,0x639b0da6,0x675a1011,0x791d4014,0x7ddc5da3,0x709f7b7a,0x745e66cd,0x9823b6e0,0x9ce2ab57,0x91a18d8e,0x95609039,0x8b27c03c,0x8fe6dd8b,0x82a5fb52,0x8664e6e5,0xbe2b5b58,0xbaea46ef,0xb7a96036,0xb3687d81,0xad2f2d84,0xa9ee3033,0xa4ad16ea,0xa06c0b5d,0xd4326d90,0xd0f37027,0xddb056fe,0xd9714b49,0xc7361b4c,0xc3f706fb,0xceb42022,0xca753d95,0xf23a8028,0xf6fb9d9f,0xfbb8bb46,0xff79a6f1,0xe13ef6f4,0xe5ffeb43,0xe8bccd9a,0xec7dd02d,0x34867077,0x30476dc0,0x3d044b19,0x39c556ae,0x278206ab,0x23431b1c,0x2e003dc5,0x2ac12072,0x128e9dcf,0x164f8078,0x1b0ca6a1,0x1fcdbb16,0x018aeb13,0x054bf6a4,0x0808d07d,0x0cc9cdca,0x7897ab07,0x7c56b6b0,0x71159069,0x75d48dde,0x6b93dddb,0x6f52c06c,0x6211e6b5,0x66d0fb02,0x5e9f46bf,0x5a5e5b08,0x571d7dd1,0x53dc6066,0x4d9b3063,0x495a2dd4,0x44190b0d,0x40d816ba,0xaca5c697,0xa864db20,0xa527fdf9,0xa1e6e04e,0xbfa1b04b,0xbb60adfc,0xb6238b25,0xb2e29692,0x8aad2b2f,0x8e6c3698,0x832f1041,0x87ee0df6,0x99a95df3,0x9d684044,0x902b669d,0x94ea7b2a,0xe0b41de7,0xe4750050,0xe9362689,0xedf73b3e,0xf3b06b3b,0xf771768c,0xfa325055,0xfef34de2,0xc6bcf05f,0xc27dede8,0xcf3ecb31,0xcbffd686,0xd5b88683,0xd1799b34,0xdc3abded,0xd8fba05a,0x690ce0ee,0x6dcdfd59,0x608edb80,0x644fc637,0x7a089632,0x7ec98b85,0x738aad5c,0x774bb0eb,0x4f040d56,0x4bc510e1,0x46863638,0x42472b8f,0x5c007b8a,0x58c1663d,0x558240e4,0x51435d53,0x251d3b9e,0x21dc2629,0x2c9f00f0,0x285e1d47,0x36194d42,0x32d850f5,0x3f9b762c,0x3b5a6b9b,0x0315d626,0x07d4cb91,0x0a97ed48,0x0e56f0ff,0x1011a0fa,0x14d0bd4d,0x19939b94,0x1d528623,0xf12f560e,0xf5ee4bb9,0xf8ad6d60,0xfc6c70d7,0xe22b20d2,0xe6ea3d65,0xeba91bbc,0xef68060b,0xd727bbb6,0xd3e6a601,0xdea580d8,0xda649d6f,0xc423cd6a,0xc0e2d0dd,0xcda1f604,0xc960ebb3,0xbd3e8d7e,0xb9ff90c9,0xb4bcb610,0xb07daba7,0xae3afba2,0xaafbe615,0xa7b8c0cc,0xa379dd7b,0x9b3660c6,0x9ff77d71,0x92b45ba8,0x9675461f,0x8832161a,0x8cf30bad,0x81b02d74,0x857130c3,0x5d8a9099,0x594b8d2e,0x5408abf7,0x50c9b640,0x4e8ee645,0x4a4ffbf2,0x470cdd2b,0x43cdc09c,0x7b827d21,0x7f436096,0x7200464f,0x76c15bf8,0x68860bfd,0x6c47164a,0x61043093,0x65c52d24,0x119b4be9,0x155a565e,0x18197087,0x1cd86d30,0x029f3d35,0x065e2082,0x0b1d065b,0x0fdc1bec,0x3793a651,0x3352bbe6,0x3e119d3f,0x3ad08088,0x2497d08d,0x2056cd3a,0x2d15ebe3,0x29d4f654,0xc5a92679,0xc1683bce,0xcc2b1d17,0xc8ea00a0,0xd6ad50a5,0xd26c4d12,0xdf2f6bcb,0xdbee767c,0xe3a1cbc1,0xe760d676,0xea23f0af,0xeee2ed18,0xf0a5bd1d,0xf464a0aa,0xf9278673,0xfde69bc4,0x89b8fd09,0x8d79e0be,0x803ac667,0x84fbdbd0,0x9abc8bd5,0x9e7d9662,0x933eb0bb,0x97ffad0c,0xafb010b1,0xab710d06,0xa6322bdf,0xa2f33668,0xbcb4666d,0xb8757bda,0xb5365d03,0xb1f740b4}local function c(d)d=d..((\"%x\"):format(#d):reverse()..\"0\"):gsub(\"%x%x\",function(e)return string.char(tonumber(e:sub(1,1),16)+tonumber(e:sub(2,2),16)*16)end)local f=0;for g=1,#d do f=bit32.bxor(bit32.lshift(f,8),b[bit32.bxor(bit32.rshift(f,24),d:byte(g))])end;return bit32.bnot(f)end;if#a==0 then a[1]=\"-\"end;local h=0;for i,j in ipairs(a)do local d;if j==\"-\"then d=io.read(\"*a\")else local k,h=io.open(j,\"rb\")if k then d=k:read(\"*a\")k:close()else io.stderr:write(\"Could not open \"..j..\": \"..h..\"\\n\")h=h+1 end end;print((\"%u %d %s\"):format(c(d),#d,j))end;return h\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291465,size=3404},["basename.lua"]={type="file",created=1740881291501,worldPermissions={execute=true,read=true,write=false},data="local a=assert(...,\"basename: missing path\")if a==\"\"then print\".\"elseif a:match\"^/+$\"then print\"/\"else local b=a:gsub(\"/+$\",\"\"):match\"[^/]+$\"local c=select(2,...)if c and b~=c then b=b:gsub(c..\"$\",\"\")end;print(b)end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291461,size=216},["tty.lua"]={type="file",created=1740881291527,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.process\"local b=a.getpinfo(a.getpid())if b.stdout then print(\"tty\"..b.stdout)end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291490,size=104},["true.lua"]={type="file",created=1740881291527,worldPermissions={execute=true,read=true,write=false},data="return true\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291490,size=12},["ar.lua"]={type="file",created=1740881291265,worldPermissions={execute=true,read=true,write=false},data="local a=require\"ar\"local function b(c,d,e)return string.len(c)<d and string.sub(c,1,d)..string.rep(e or\" \",d-string.len(c))or c end;local function f(g,c,e)local h=\"\"for i=1,string.len(c)do h=h..(bit32.band(g,bit32.lshift(1,string.len(c)-i))==0 and e or string.sub(c,i,i))end;return h end;local j={...}if#j<2 then error(\"Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]\")end;if j[1]==\"--version\"then print(\"Phoenix ar (baseutils) 1.0 (compatible with GNU/BSD ar)\\nCopyright (c) 2019-2022 JackMacWindows.\")return 2 end;local k=nil;local l=false;local m=false;if string.find(j[1],\"d\")then k=0 end;if string.find(j[1],\"p\")then k=1 end;if string.find(j[1],\"q\")then k=2 end;if string.find(j[1],\"r\")then k=3 end;if string.find(j[1],\"t\")then k=4 end;if string.find(j[1],\"x\")then k=5 end;if string.find(j[1],\"c\")then a.verbosity=-1 end;if string.find(j[1],\"v\")then a.verbosity=1 end;if string.find(j[1],\"u\")then l=true end;if string.find(j[1],\"T\")then m=true end;if string.find(j[1],\"f\")then m=true end;local n=a.load(j[2])local o={...}table.remove(o,1)table.remove(o,1)if n==nil then if a.verbosity>-1 then print(\"ar: Creating archive \"..j[2])end;n={}end;if k==0 then for p,q in pairs(n)do for r,s in pairs(o)do if q.name==s then n[p]=nil;break end end end;a.save(n,j[2])elseif k==1 then if#j>2 then for p,q in pairs(n)do for r,s in pairs(o)do if q.name==s then print(q.data)break end end end else for p,q in pairs(n)do print(q.data)end end elseif k==2 then for p,q in pairs(o)do local t=a.read(q)t.name=string.sub(t.name,1,m and 15 or nil)table.insert(n,t)end;a.save(n,j[2])elseif k==3 then for p,q in pairs(o)do local t=a.read(q)t.name=string.sub(t.name,1,m and 15 or nil)local u=false;for r,s in pairs(n)do if s.name==t.name then u=true;for v,w in pairs(t)do s[v]=t[v]end;break end end;if not u then table.insert(n,t)end end;a.save(n,j[2])elseif k==4 then if a.verbosity>0 then local x={}local y={0,0,0,0,0}for p,q in pairs(n)do local z=os.date(\"%c\",q.timestamp or 0)local A={f(q.mode,\"rwxrwxrwx\",\"-\"),q.owner..\"/\"..q.group,string.len(q.data),z,q.name}for r,s in pairs(A)do if string.len(s)+3>y[r]then y[r]=string.len(s)+3 end end;table.insert(x,A)end;for p,q in pairs(x)do for r,s in pairs(q)do io.write(b(s,y[r]))end;print(\"\")end else for p,q in pairs(n)do print(q.name)end end elseif k==5 then local B=#o>0 and table.remove(o,1)or\".\"local t;if#o>0 then t={}for p,q in pairs(n)do for r,s in pairs(o)do if q.name==s then table.insert(t,q)break end end end else t=n end;a.extract(t,B)else error(\"Unknown mode\")end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291262,size=2516},["ps.lua"]={type="file",created=1740881291522,worldPermissions={execute=true,read=true,write=false},data="local a=setmetatable({},{__index=function(self,b)return function(...)local c=table.pack(coroutine.yield(\"syscall\",b,...))if c[1]then return table.unpack(c,2,c.n)else error(c[2],2)end end end,__newindex=function()end})local d=a.getplist()print(\"PID\\tTTY\\tTIME\\t\\tCMD\")for e,f in ipairs(d)do local g=a.getpinfo(f)if g then print(f,g.stdout and\"tty\"..g.stdout or\"?\",(\"%02d:%02d:%02d.%03d\"):format(math.floor(g.cputime/3600),math.floor(g.cputime/60),math.floor(g.cputime),math.floor(g.cputime*1000)%1000),g.name)end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291484,size=516},["tar.lua"]={type="file",created=1740881294119,worldPermissions={execute=true,read=true,write=false},data="local a=require\"tar\"local b=require\"system.filesystem\"local c=require\"system.process\"local function d(e,f,g)return string.len(e)<f and string.sub(e,1,f)..string.rep(g or\" \",f-string.len(e))or e end;local function h(e,f,g)return string.len(e)<f and string.rep(g or\" \",f-string.len(e))..string.sub(e,1,f)or e end;local function i(j)return 0x38+(j.worldPermissions.read and 4 or 0)+(j.worldPermissions.write and 2 or 0)+(j.worldPermissions.execute and 1 or 0)+(j.permissions[j.owner].read and 256 or 0)+(j.permissions[j.owner].write and 128 or 0)+(j.permissions[j.owner].execute and 64 or 0)end;local function k(l,e,g)local m=\"\"for n=1,string.len(e)do m=m..(bit32.band(l,bit32.lshift(1,string.len(e)-n))==0 and g or string.sub(e,n,n))end;return m end;local o=[=[Usage: tar [OPTION...] [FILE]...\nPhoenix 'tar' saves many files together into a single tape or disk archive, and\ncan restore individual files from the archive.\n\nExamples:\n  tar -cf archive.tar foo bar  # Create archive.tar from files foo and bar.\n  tar -tvf archive.tar         # List all files in archive.tar verbosely.\n  tar -xf archive.tar          # Extract all files from archive.tar.\n\n Local file name selection:\n\n      --add-file=FILE        add given FILE to the archive (useful if its name\n                             starts with a dash)\n  -C, --directory=DIR        change to directory DIR\n      --no-null              disable the effect of the previous --null option\n      --no-recursion         avoid descending automatically in directories\n      --null                 -T reads null-terminated names; implies\n                             --verbatim-files-from\n      --recursion            recurse into directories (default)\n  -T, --files-from=FILE      get names to extract or create from FILE\n\n Main operation mode:\n\n  -A, --catenate, --concatenate   append tar files to an archive\n  -c, --create               create a new archive\n  -d, --diff, --compare      find differences between archive and file system\n      --delete               delete from the archive (not on mag tapes!)\n  -r, --append               append files to the end of an archive\n  -t, --list                 list the contents of an archive\n  -u, --update               only append files newer than copy in archive\n  -x, --extract, --get       extract files from an archive\n\n Overwrite control:\n\n  -k, --keep-old-files       don't replace existing files when extracting,\n                             treat them as errors\n      --overwrite            overwrite existing files when extracting\n      --remove-files         remove files after adding them to the archive\n  -W, --verify               attempt to verify the archive after writing it\n\n Device selection and switching:\n\n  -f, --file=ARCHIVE         use archive file or device ARCHIVE\n\n Device blocking:\n\n  -i, --ignore-zeros         ignore zeroed blocks in archive (means EOF)\n\n Compression options:\n\n  -z, --gzip, --gunzip, --ungzip   filter the archive through gzip\n\n Local file selection:\n\n  -N, --newer=DATE-OR-FILE, --after-date=DATE-OR-FILE\n                             only store files newer than DATE-OR-FILE\n\n Informative output:\n\n  -v, --verbose              verbosely list files processed\n\n Other options:\n\n  -?, --help                 give this help list\n      --usage                give a short usage message\n      --version              print program version]=]local p={...}local q=nil;local r={}local s=nil;local t=nil;local u=true;local v=false;local w=false;local x=nil;local y=false;local z=false;local A=nil;local B=0;local C=false;local D=false;for E,F in ipairs(p)do if t then if t==0 then q=F elseif t==1 then x=F elseif t==2 then A=F elseif t==3 then B=tonumber(F)elseif t==4 then local G=b.open(F,\"r\")local H=G.readLine()while H~=nil do if C then table.insert(r,H)else table.insert(p,H)end;H=G.readLine()end;G.close()end;t=nil elseif E==1 or string.sub(F,1,1)==\"-\"and string.sub(F,2,2)~=\"-\"then if string.find(F,\"A\")then s=0 end;if string.find(F,\"d\")then s=2 end;if string.find(F,\"c\")then s=1 end;if string.find(F,\"r\")then s=3 end;if string.find(F,\"t\")then s=4 end;if string.find(F,\"u\")then s=5 end;if string.find(F,\"x\")then s=6 end;if string.find(F,\"f\")then t=0 end;if string.find(F,\"k\")then u=false end;if string.find(F,\"U\")then v=true end;if string.find(F,\"W\")then w=true end;if string.find(F,\"O\")then x=0 end;if string.find(F,\"p\")then y=true end;if string.find(F,\"i\")then a.ignore_zero=true end;if string.find(F,\"z\")then z=true end;if string.find(F,\"C\")then t=1 end;if string.find(F,\"K\")then t=2 end;if string.find(F,\"N\")then t=3 end;if string.find(F,\"T\")then t=4 end;if string.find(F,\"v\")then a.verbosity=1 end;if string.find(F,\"?\")then print(o)return 2 end elseif string.sub(F,1,2)==\"--\"then if F==\"--catenate\"then s=0 elseif F==\"--concatenate\"then s=0 elseif F==\"--create\"then s=1 elseif F==\"--diff\"then s=2 elseif F==\"--compare\"then s=2 elseif F==\"--delete\"then s=7 elseif F==\"--append\"then s=3 elseif F==\"--list\"then s=4 elseif F==\"--update\"then s=5 elseif F==\"--extract\"then s=6 elseif F==\"--get\"then s=6 elseif F==\"--help\"or F==\"--usage\"then print(o)return 2 elseif F==\"--version\"then print(\"Phoenix tar v1.0\")return 2 elseif F==\"--keep-old-files\"then u=false elseif F==\"--overwrite\"then u=true elseif F==\"--remove-files\"then v=true elseif F==\"--unlink-first\"then v=true elseif F==\"--verify\"then w=true elseif F==\"--to-stdout\"then x=0 elseif F==\"--preserve-permissions\"then y=true elseif F==\"--same-permissions\"then y=true elseif F==\"--preserve\"then y=true elseif string.find(F,\"--file=\")then q=string.sub(F,8)elseif F==\"--ignore-zeros\"then a.ignore_zero=true elseif F==\"--gzip\"or F==\"--gunzip\"or F==\"--ungzip\"then z=true elseif string.find(F,\"--add-file=\")then table.insert(r,string.sub(F,12))elseif string.find(F,\"--directory=\")then x=string.sub(F,13)elseif string.find(F,\"--starting-file=\")then A=string.sub(F,17)elseif F==\"--no-null\"then C=false elseif F==\"--null\"then C=true elseif string.find(F,\"--newer=\")then B=tonumber(string.sub(F,9))elseif string.find(F,\"--after-date=\")then B=tonumber(string.sub(F,14))elseif string.find(F,\"--files-from=\")then local G=b.open(string.sub(F,14),\"r\")local H=G.readLine()while H~=nil do if C then table.insert(r,H)else table.insert(p,H)end;H=G.readLine()end;G.close()elseif F==\"--verbose\"then a.verbosity=1 elseif F==\"--no-recursion\"then D=true end else table.insert(r,F)end end;if z and LibDeflate==nil then LibDeflate=require\"LibDeflate\"if LibDeflate==nil then error(\"Compression is only supported when LibDeflate.lua is available in the PATH.\")end end;local I=c.getcwd()if type(x)==\"string\"then c.chdir(x)end;local function J(e)c.chdir(I)error(e)end;local function K(L)if z then local M=\"\"local G=b.open(q,\"rb\")local g=G.read()while g~=nil do M=M..string.char(g)g=G.read()if string.len(M)%10240==0 then os.queueEvent(\"nosleep\")os.pullEvent()end end;G.close()return a.load(LibDeflate:DecompressGzip(M),L,true)else return a.load(q,L)end end;local function N(O)if not z and q then a.save(O,q)else local m=a.save(O,nil)if z then m=LibDeflate:CompressGzip(m)end;if x==0 then io.write(m)elseif m then local G=b.open(q,\"wb\")for g in string.gmatch(m,\".\")do G.write(string.byte(g))end;G.close()end end end;if s==0 then if z==true then J(\"Compressed files cannot be concatenated\")end;if q==nil then J(\"You must specify an arhive with -f <first.tar>.\")end;local P=b.open(q,\"ab\")for E,F in pairs(r)do local Q=b.open(F,\"rb\")local g=Q.read()while g do P.write(g)g=Q.read()end;Q.close()end;P.close()elseif s==1 then if q==nil and x~=0 then J(\"You must specify an archive with -f <output.tar> or -O.\")end;local O={}for E,F in pairs(r)do local R=split(F,\"/\")local S=O;local T=nil;for E,F in pairs(R)do if E==#R then break end;T=T and b.combine(T,F)or F;if S[F]==nil then S[F]={}end;S=S[F]end;if string.sub(F,1,1)==\"/\"then S[R[#R]]=(D and a.read or a.pack)(\"/\",string.sub(F,2))else S[R[#R]]=(D and a.read or a.pack)(c.getcwd(),F)end;if v then b.remove(F)end end;N(O)elseif s==2 then J(\"Not implemented\")elseif s==3 then if q==nil and x~=0 then J(\"You must specify an archive with -f <output.tar> or -O.\")end;local O=K(true)for E,F in pairs(r)do if string.sub(F,1,1)==\"/\"then table.insert(O,(D and a.read or a.pack)(\"/\",string.sub(F,2)))else table.insert(O,(D and a.read or a.pack)(c.getcwd(),F))end;if v then b.remove(F)end end;N(O)elseif s==4 then if q==nil then J(\"You must specify an archive with -f <file.tar>.\")end;local O=K(true)if a.verbosity>0 then local U={}local V={0,0,0,0,0}for E,F in pairs(O)do local S=os.date(\"%F %R\",F.timestamp or 0)local W={k(F.mode+(F.type==5 and 0x200 or 0),\"drwxrwxrwx\",\"-\"),(F.ownerName or F.owner or 0)..\"/\"..(F.groupName or F.group or 0),string.len(F.data or\"\"),S,F.name..(F.link and F.link~=\"\"and\" -> \"..F.link or\"\")}for X,Y in pairs(W)do if string.len(Y)+1>V[X]then V[X]=string.len(Y)+1 end end;table.insert(U,W)end;for E,F in pairs(U)do for X,Y in pairs(F)do io.write((X==3 and h or d)(Y,V[X])..(X==3 and\" \"or\"\"))end;print(\"\")end else for E,F in pairs(O)do print(F.name)end end elseif s==5 then if q==nil and x~=0 then J(\"You must specify an archive with -f <output.tar> or -O.\")end;local O=K()for E,F in pairs(r)do local R=split(F,\"/\")local S=O;local T=nil;for E,F in pairs(R)do if E==#R then break end;T=T and b.combine(T,F)or F;local j=b.stat(T)if S[F]==nil then S[F]={[\"//\"]={name=T,mode=i(j),owner=0,group=0,timestamp=j.modified,type=5,link=\"\",ownerName=j.owner,groupName=\"\",deviceNumber=nil,data=nil}}end;S=S[F]end;if string.sub(F,1,1)==\"/\"then S[R[#R]]=(D and a.read or a.pack)(\"/\",string.sub(F,2))else S[R[#R]]=(D and a.read or a.pack)(c.getcwd(),F)end;if v then b.remove(F)end end;N(O)elseif s==6 then if q==nil then J(\"You must specify an archive with -f <file.tar>.\")end;local O=K()a.extract(O,c.getcwd())elseif s==7 then if q==nil then J(\"You must specify an archive with -f <file.tar>.\")end;local O=K(true)for E,F in pairs(r)do for X,Y in pairs(O)do if Y.name==F then O[X]=nil;break end end end;N(O)else J(\"You must specify one of -Acdrtux, see --help for details.\")end;c.chdir(I)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294110,size=10000},["expr.lua"]={type="file",created=1740881291511,worldPermissions={execute=true,read=true,write=false},data="print(assert(load(table.concat({...},\" \"):gsub(\"&\",\" and \"):gsub(\"|\",\" or \"),\"=expr\",\"t\",{}))())\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291473,size=97},["curl.lua"]={type="file",created=1740881291507,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.network\"local b=require\"system.serialization\"local c=require\"system.util\"local function d(e)return e:gsub(\"[^A-Za-z0-9%-_%.~]\",function(f)return(\"%%%02X\"):format(f:byte())end)end;local g={[100]=\"Continue\",[101]=\"Switching Protocols\",[102]=\"Processing\",[200]=\"OK\",[201]=\"Created\",[202]=\"Accepted\",[203]=\"Non-authoritative Information\",[204]=\"No Content\",[205]=\"Reset Content\",[206]=\"Partial Content\",[207]=\"Multi-Status\",[208]=\"Already Reported\",[226]=\"IM Used\",[300]=\"Multiple Choices\",[301]=\"Moved Permanently\",[302]=\"Found\",[303]=\"See Other\",[304]=\"Not Modified\",[305]=\"Use Proxy\",[307]=\"Temporary Redirect\",[308]=\"Permanent Redirect\",[400]=\"Bad Request\",[401]=\"Unauthorized\",[402]=\"Payment Required\",[403]=\"Forbidden\",[404]=\"Not Found\",[405]=\"Method Not Allowed\",[406]=\"Not Acceptable\",[407]=\"Proxy Authentication Required\",[408]=\"Request Timeout\",[409]=\"Conflict\",[410]=\"Gone\",[411]=\"Length Required\",[412]=\"Precondition Failed\",[413]=\"Payload Too Large\",[414]=\"Request-URI Too Long\",[415]=\"Unsupported Media Type\",[416]=\"Requested Range Not Satisfiable\",[417]=\"Expectation Failed\",[418]=\"I'm a teapot\",[421]=\"Misdirected Request\",[422]=\"Unprocessable Entity\",[423]=\"Locked\",[424]=\"Failed Dependency\",[426]=\"Upgrade Required\",[428]=\"Precondition Required\",[429]=\"Too Many Requests\",[431]=\"Request Header Fields Too Large\",[444]=\"Connection Closed Without Response\",[451]=\"Unavailable For Legal Reasons\",[499]=\"Client Closed Request\",[500]=\"Internal Server Error\",[501]=\"Not Implemented\",[502]=\"Bad Gateway\",[503]=\"Service Unavailable\",[504]=\"Gateway Timeout\",[505]=\"HTTP Version Not Supported\",[506]=\"Variant Also Negotiates\",[507]=\"Insufficient Storage\",[508]=\"Loop Detected\",[510]=\"Not Extended\",[511]=\"Network Authentication Required\",[599]=\"Network Connect Timeout Error\"}local h=assert(c.argparse({[\"\"]={stopProcessingOnPositionalArgument=true},A=true,[\"user-agent\"]=\"@A\",b=true,cookie=\"@b\",c=true,[\"cookie-jar\"]=\"@c\",d=\"multiple\",data=\"@d\",[\"data-ascii\"]=\"@d\",D=true,[\"dump-header\"]=\"@D\",e=true,referer=\"@e\",G=false,get=\"@G\",H=\"multiple\",header=\"@H\",I=false,head=\"@I\",i=false,include=\"@i\",J=false,[\"remote-header-name\"]=\"@J\",L=false,location=\"@L\",o=true,output=\"@o\",O=false,[\"remote-name\"]=\"@O\",r=true,range=\"@r\",R=false,run=\"@R\",s=false,silent=\"@s\",S=false,[\"show-error\"]=\"@S\",T=true,[\"upload-file\"]=\"@T\",u=true,user=\"@u\",v=false,verbose=\"@v\",X=true,request=\"@X\",[\"#\"]=false,[\"progress-bar\"]=\"@#\",basic=false,[\"data-binary\"]=\"multiple\",[\"data-raw\"]=\"multiple\",[\"data-urlencode\"]=\"multiple\",digest=false,[\"disallow-username-in-url\"]=false,[\"doh-url\"]=true,json=true,[\"location-trusted\"]=false,[\"oauth2-bearer\"]=true,[\"output-dir\"]=true,post301=false,post302=false,post303=false,retry=\"number\",[\"retry-delay\"]=\"number\",h=false,help=\"@h\"},...))if h.h then print[[\nUsage: curl [options...] URL\nOptions:\n  -o, --output <path>     Path to write to\n  -H, --header <header>   Add a header to the request\n      --run               Run the file as a Lua script\n  -h, --help              Show this help\n]]return end;local i=h[1]if not i then error(\"curl: Missing URL.\")end;local j={}if h.H then for k,l in ipairs(h.H)do local m,n=l:match(\"^([^:]+):%s*(.+)$\")if not m then error(\"curl: Malformed header \"..l)end;j[m]=n end end;if h.A then j[\"User-Agent\"]=h.A end;if h.b then end;if h.c then end;if h.e then j[\"Referer\"]=h.e end;if h.u then if not h.u:find\":\"then io.stdout:write(\"Password: \")terminal.termctl({echo=false})h.u=h.u..\":\"..io.stdin:read()terminal.termctl({echo=true})print()end;if h.basic then j[\"Authorization\"]=\"Basic \"..b.base64.encode(h.u)elseif h.digest then elseif h[\"oauth2-bearer\"]then j[\"Authorization\"]=\"Bearer \"..h[\"oauth2-bearer\"]else i=i:gsub(\"^(https?://)\",\"%1\"..h.u)end end;local o;if h.d then for k,l in ipairs(h.d)do if o then o=o..\"&\"else o=\"\"end;if l:sub(1,1)==\"@\"then local p=l:sub(2):gsub(\"[\\r\\n]\",\"\")local q,r=io.open(p,\"r\")if not q then error(\"curl: Could not open \"..p..\": \"..r)end;o=o..q:read(\"*a\")q:close()else o=o..l end end end;if h[\"data-raw\"]then for k,l in ipairs(h[\"data-raw\"])do if o then o=o..\"&\"else o=\"\"end;o=o..l end end;if h[\"data-binary\"]then for k,l in ipairs(h[\"data-binary\"])do if o then o=o..\"&\"else o=\"\"end;if l:sub(1,1)==\"@\"then local p=l:sub(2):gsub(\"[\\r\\n]\",\"\")local q,r=io.open(p,\"rb\")if not q then error(\"curl: Could not open \"..p..\": \"..r)end;o=o..q:read(\"*a\")q:close()else o=o..l end end end;if h[\"data-urlencode\"]then for k,l in ipairs(h[\"data-urlencode\"])do if o then o=o..\"&\"else o=\"\"end;local s,t=l:match\"^([^=]+)=(.+)$\"local u,p=l:match\"^([^@]*)@(.*)$\"if s then o=o..s..\"=\"..d(t)elseif u then if u~=\"\"then o=o..u..\"=\"end;local q,r=io.open(p,\"r\")if not q then error(\"curl: Could not open \"..p..\": \"..r)end;o=o..d(q:read(\"*a\"))q:close()else o=o..l end end end;if h.json then if o then o=o..\"&\"else o=\"\"end;if h.json:sub(1,1)==\"@\"then local p=h.json:sub(2):gsub(\"[\\r\\n]\",\"\")local q,r=io.open(p,\"rb\")if not q then error(\"curl: Could not open \"..p..\": \"..r)end;o=o..q:read(\"*a\")q:close()else o=o..h.json end;j[\"Content-Type\"]=\"application/json\"j[\"Accept\"]=\"application/json\"end;local v;if h.X then v=h.X:upper()elseif h.G then v=\"GET\"if o then i=i..\"?\"..o end elseif h.I then v=\"HEAD\"elseif h.T then v=\"PUT\"local q,r=io.open(h.T,\"rb\")if not q then error(\"curl: Could not open \"..h.T..\": \"..r)end;o=q:read(\"*a\")q:close()elseif o then v=\"POST\"else v=\"GET\"end;if h.v then io.stderr:write(\"* Opening connection to \"..i:match(\"^https?://([^/]+)\")..\"\\n\")io.stderr:write(\"> GET \"..i:match(\"^https?://[^/]+(/[^#]+)\")..\" HTTP/1.1\\n\")for m,l in pairs(j)do io.stderr:write(\"> \"..m..\": \"..l..\"\\n\")end;io.stderr:write(\"> \\n\")end;local w;for k=0,h.retry or 0 do w=a.connect{url=i,method=v,headers=j,redirect=h.L}w:write(o)local x=false;while true do local y,z=coroutine.yield()if y==\"handle_status_change\"and z.id==w.id then if z.status==\"open\"then x=true;break elseif z.status==\"error\"then io.stderr:write(select(2,w:status()))w=nil;break end end end;if x then break end end;if not w then return false end;local A=w:responseCode()local B=w:responseHeaders()if h.o then io.output(h.o)elseif h.O then local s=i:gsub(\"%?.*$\",\"\"):gsub(\"#.*$\",\"\"):match(\"([^/]+)/*$\")if h.J then s=B[\"Content-Disposition\"]or s end;if h[\"output-dir\"]then s=h[\"output-dir\"]..\"/\"..s end;io.output(s)end;if h.v or h.i then local C=function(D)return io.write(D)end;if h.v then C=function(D)return io.stderr:write(\"< \"..D)end end;C(\"HTTP/1.1 \"..A..\" \"..(g[A]or\"Unknown\"))for m,l in pairs(B)do C(m..\": \"..l)end;C(\"\")end;if h.D then local q,r=io.open(h.D,\"w\")if q then for m,l in pairs(B)do q:write(m..\": \"..l..\"\\n\")end;q:close()else io.stderr:write(\"curl: Could not open header dump file: \"..r..\"\\n\")end end;if h.R then if math.floor(A/100)~=2 then error(\"curl: Got HTTP response \"..A..\", not running data.\")end;local s=i:gsub(\"%?.*$\",\"\"):gsub(\"#.*$\",\"\"):match(\"([^/]+)/*$\")if h.J then s=B[\"Content-Disposition\"]or s end;local E,r=load(function()return w:read(\"*L\")end,\"=\"..s)if not E then error(\"curl: Could not load file: \"..r)end;return E(table.unpack(h,2,h.n))end;io.write(w:read(\"*a\"))w:close()io.output():close()\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291468,size=7062},["comm.lua"]={type="file",created=1740881291505,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.util\"local b=assert(a.argparse({[\"1\"]=false,[\"2\"]=false,[\"3\"]=false},...))if#b<2 then error(\"Usage: comm [-123] <file1> <file2>\")end;local c=b[1]==\"-\"and io.input()or assert(io.open(b[1],\"r\"))local d=b[2]==\"-\"and io.input()or assert(io.open(b[2],\"r\"))local e,f=c,d;local g=e:read(\"*l\")while g do local h=f:read(\"*l\")if not h then break end;if g<h then if e==c then if not b[\"1\"]then print(g)end elseif not b[\"2\"]then print((b[\"1\"]and\"\"or\"\\t\")..g)end;e,f=f,e;g=h elseif g==h then if not b[\"3\"]then print((b[\"1\"]and\"\"or\"\\t\")..(b[\"2\"]and\"\"or\"\\t\")..g)end;g=e:read(\"*l\")if not g then e,g=f,h;break end else if f==c then if not b[\"1\"]then print(h)end elseif not b[\"2\"]then print((b[\"1\"]and\"\"or\"\\t\")..h)end end end;while g do if e==c then if not b[\"1\"]then print(g)end elseif not b[\"2\"]then print((b[\"1\"]and\"\"or\"\\t\")..g)end;g=e:read(\"*l\")end;c:close()if c~=d then d:close()end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291466,size=893},["craftos.lua"]={type="file",created=1740881292593,worldPermissions={execute=true,read=true,write=false},data="for a,b in pairs(require\"craftos\")do _G[a]=b end;return coroutine.yield(\"syscall\",\"exec\",...)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292580,size=94},["du.lua"]={type="file",created=1740881291509,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=assert(b.argparse({a=false,s=false,k=false,h=false,x=false,H=false,L=false},...))if#c==0 then c[1]=\".\"end;local d=0;local function e(f)if c.h then if f>=1000000000000 then return(\"%.3gT\"):format(f/1000000000000)elseif f>=1000000000 then return(\"%.3gG\"):format(f/1000000000)elseif f>=1000000 then return(\"%.3gM\"):format(f/1000000)elseif f>=1000 then return(\"%.3gK\"):format(f/1000)else return(\"%.3g \"):format(f)end elseif c.k then return math.ceil(f/1024)else return math.ceil(f/512)end end;local function g(h,i,j)local k,l=a.stat(h,not(j and c.H or c.L))if k then if i==true then i=k.mountpoint end;if i and i~=k.mountpoint then return 0 end;if k.type==\"directory\"then local m=0;for n,o in ipairs(a.list(h))do m=m+g(a.combine(h,o),i)end;if not c.s then print(e(m),h)end;return m else if c.a and not c.s then print(e(k.size),h)end;return k.size end else io.stderr:write(\"du: could not stat \"..h..\": \"..(l or\"\")..\"\\n\")d=1;return 0 end end;for n,o in ipairs(c)do local m=g(o,c.x,true)if c.s then print(e(m),o)end end;return d\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291470,size=1092},["cmp.lua"]={type="file",created=1740881291505,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.util\"local b=assert(a.argparse({l=false,s=false},...))if#b<2 then error(\"usage: cmp [-ls] <file1> <file2>\")end;local c,d;if b[1]==\"-\"then c=io.stdin else c=io.open(b[1],\"rb\")end;if b[2]==\"-\"then d=io.stdin else d=io.open(b[2],\"rb\")end;local function e(f)if c~=io.stdin then c:close()end;if d~=io.stdin then d:close()end;return f end;if c==d then return e(0)end;local g,h=1,0;for i=1,math.huge do local j=c:read(1)local k=d:read(1)if j~=k then h=1;if not j then if not b.s then io.stderr:write(\"cmp: EOF on \"..b[1]..\"\\n\")end elseif not k then if not b.s then io.stderr:write(\"cmp: EOF on \"..b[2]..\"\\n\")end elseif not b.s then if b.l then io.write(i..\" \"..j..\" \"..k..\"\\n\")else io.write((\"%s %s differ: char %d, line %d\\n\"):format(b[1],b[2],i,g))end end;if not b.l then return e(1)end end;if j==\"\\n\"then g=g+1 end;if not j or not k then break end end;return e(h)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291466,size=883},["date.lua"]={type="file",created=1740881291507,worldPermissions={execute=true,read=true,write=false},data="local a=false;local b=\"%c\"for c,d in ipairs{...}do if d==\"-u\"then a=true elseif d:sub(1,1)==\"+\"then b=d:sub(2)end end;if a then b=\"!\"..b end;print(os.date(b))\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291468,size=159},["rmdir.lua"]={type="file",created=1740881291525,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=false;local function c(d)if not a.isDir(d)or#a.list(d)>0 then error(\"rmdir: \"..d..\": directory not empty\")end;a.remove(d)if b and d:find\"/\"then return c(a.dirname(d))end end;for e,f in ipairs{...}do if f==\"-p\"then b=true else c(f)end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291487,size=280},["renice.lua"]={type="file",created=1740881291524,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.process\"local b=require\"system.util\"local c=assert(b.argparse({n=\"number\"},...))if not c[1]or not c.n then error(\"Usage: renice -n <increment> <PID...>\")end;for d,e in ipairs(c)do e=tonumber(e)or error(\"renice: argument \"..e..\" is not a PID\")a.nice(c.n,e)end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291486,size=282},["cal.lua"]={type="file",created=1740881291501,worldPermissions={execute=true,read=true,write=false},data="local a={...}local b={\"january\",\"february\",\"march\",\"april\",\"may\",\"june\",\"july\",\"august\",\"september\",\"october\",\"november\",\"december\"}local c={31,28,31,30,31,30,31,31,30,31,30,31}local function d(e)if#e<3 then return end;local f=\"^\"..e:lower()for g,h in ipairs(b)do if h:match(f)then return g end end end;local i=os.date(\"*t\")local j,k;if a[2]then j,k=assert(tonumber(a[1])or d(a[1]),\"cal: \"..a[1]..\" is neither a month number (1..12) nor a name\"),assert(tonumber(a[2]),\"cal: year `\"..a[2]..\"' not in range 1..9999\")elseif a[1]then k=assert(tonumber(a[1]),\"cal: year `\"..a[1]..\"' not in range 1..9999\")else j,k=i.month,i.year end;if k<1 or k>9999 then error(\"cal: year `\"..k..\"' not in range 1..9999\")end;if j and(j<1 or j>12)then error(\"cal: \"..j..\" is neither a month number (1..12) nor a name\")end;if j then local l=b[j]:gsub(\"^.\",string.upper)..\" \"..k;l=(\" \"):rep(math.floor((20-#l)/2))..l;print(l)print(\"Su Mo Tu We Th Fr Sa\")local m=os.date(\"*t\",os.time({year=k,month=j,day=1})).wday;io.stdout:write((\"   \"):rep(m-1))local n=c[j]if j==2 and(k%4==0 and k%100~=0 or k%400==0)then n=29 end;for g=1,n do if i.year==k and i.month==j and i.day==g then io.stdout:write((\"\\x1b[7m%2d\\x1b[7m \"):format(g))else io.stdout:write((\"%2d \"):format(g))end;m=m+1;if m>7 then print()m=1 end end;if m>1 then print()end else print((\"                              %4d\"):format(k))local function o(p)local l=b[p]:gsub(\"^.\",string.upper)l=(\" \"):rep(math.floor((20-#l)/2))..l..(\" \"):rep(math.ceil((20-#l)/2))coroutine.yield(l)coroutine.yield(\"Su Mo Tu We Th Fr Sa\")local m=os.date(\"*t\",os.time({year=k,month=p,day=1})).wday;local q=(\"   \"):rep(m-1)local n=c[p]if p==2 and(k%4==0 and k%100~=0 or k%400==0)then n=29 end;for g=1,n do if i.year==k and i.month==p and i.day==g then q=q..(\"\\x1b[7m%2d\\x1b[7m \"):format(g)else q=q..(\"%2d \"):format(g)end;m=m+1;if m>7 then coroutine.yield(q:sub(1,-2))q,m=\"\",1 end end;if m>1 then coroutine.yield(q:sub(1,-2)..(\" \"):rep(20-#q+1))end end;for g=0,3 do local r,s,t=coroutine.create(function()o(g*3+1)end),coroutine.create(function()o(g*3+2)end),coroutine.create(function()o(g*3+3)end)while coroutine.status(r)==\"suspended\"or coroutine.status(s)==\"suspended\"or coroutine.status(t)==\"suspended\"do local q=\"\"local u,v=coroutine.resume(r)if u and v then q=v..\"  \"end;u,v=coroutine.resume(s)if u and v then q=q..v..\"  \"end;u,v=coroutine.resume(t)if u and v then q=q..v end;print(q)end end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291461,size=2404},["pwd.lua"]={type="file",created=1740881291522,worldPermissions={execute=true,read=true,write=false},data="print(select(2,coroutine.yield(\"syscall\",\"getcwd\")))\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291485,size=53},["dirname.lua"]={type="file",created=1740881291508,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"print(a.dirname(...))\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291469,size=56},["unmount.lua"]={type="file",created=1740881291529,worldPermissions={execute=true,read=true,write=false},data="return coroutine.yield(\"syscall\",\"unmount\",assert(...,\"Usage: unmount <path>\"))\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291492,size=80},["echo.lua"]={type="file",created=1740881291509,worldPermissions={execute=true,read=true,write=false},data="print(...)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291471,size=11},["nm.lua"]={type="file",created=1740881291521,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=require\"system.util\"local d=assert(c.argparse({A=false,e=false,f=false,g=false,o=false,P=false,t=true,u=false,v=false,x=false},...))if d.t then assert(d.t:match\"^[dox]$\",\"nm: invalid option '\"..d.t..\"' for argument -t\")end;if#d==0 then error(\"nm: missing file operand\")end;if d.o then d.t=\"o\"end;d.t=d.t or(d.P and\"d\"or\"x\")local e={d=\"%s%s %s %d %d\",o=\"%s%s %s %o %o\",x=\"%s%s %s %x %x\"}for f,g in ipairs(d)do local h={}local require=require;local j={}local k=setmetatable({require=function(l)local m=require(l)local n={name=l,lib=m,used={}}h[#h+1]=n;return setmetatable({},{__index=function(f,o)n.used[o]=true;return m[o]end,__newindex=function(f,o,p)n.used[o]=true;m[o]=p end})end,__scrapelocals=function()if not d.g and not d.e then for i=1,math.huge do local q,r=debug.getlocal(2,i)if not q then break end;local s=type(r)if s==\"function\"then j[#j+1]={lib=g,type=\"t\",name=q,value=tonumber(tostring(r):match(\": (%x+)\"),16),size=#string.dump(r)}elseif s==\"string\"then j[#j+1]={lib=g,type=\"d\",name=q,value=i,size=#r}elseif s==\"number\"then j[#j+1]={lib=g,type=\"d\",name=q,value=i,size=8}elseif s==\"boolean\"then j[#j+1]={lib=g,type=\"d\",name=q,value=i,size=1}elseif s==\"nil\"then j[#j+1]={lib=g,type=\"d\",name=q,value=i,size=0}else j[#j+1]={lib=g,type=\"d\",name=q,value=tonumber(tostring(r):match(\": (%x+)\"),16),size=#r or 8}end end end end},{__index=_G})local t,u=a.open(g,\"r\")if t then local v=t.readAll()t.close()local w;repeat local x=v:find(\"%f[A-Za-z0-9_]return%f[^A-Za-z0-9_]\",w and w+1)if x then w=x end until not x;if w and v:find(\"%f[A-Za-z0-9_]end%f[^A-Za-z0-9_]\",w)then w=nil end;if w then v=v:sub(1,w-1)..\" __scrapelocals() \"..v:sub(w)else v=v..\" __scrapelocals()\"end;local y,u=load(v,\"@\"..g,nil,k)if y then local z=b.getcwd()b.chdir(a.dirname(g))local A,B=pcall(y,a.basename(g):gsub(\"%.lua$\",\"\"),g)b.chdir(z)if A then local C=type(B)if not d.u then if C==\"function\"then j[#j+1]={lib=g,type=\"T\",name=\"\",value=tonumber(tostring(B):match(\": (%x+)\"),16),size=#string.dump(B)}elseif C==\"table\"then local i=1;for q,r in pairs(B)do local s=type(r)if s==\"function\"then j[#j+1]={lib=g,type=\"T\",name=q,value=tonumber(tostring(r):match(\": (%x+)\"),16),size=#string.dump(r)}elseif s==\"string\"then j[#j+1]={lib=g,type=\"D\",name=q,value=i,size=#r}elseif s==\"number\"then j[#j+1]={lib=g,type=\"D\",name=q,value=i,size=8}elseif s==\"boolean\"then j[#j+1]={lib=g,type=\"D\",name=q,value=i,size=1}elseif s==\"nil\"then j[#j+1]={lib=g,type=\"D\",name=q,value=i,size=0}else j[#j+1]={lib=g,type=\"D\",name=q,value=tonumber(tostring(r):match(\": (%x+)\"),16),size=#r or 8}end;i=i+1 end end end else io.stderr:write(\"nm: could not require \"..g..\": \"..B..\"\\n\")end;if not d.u then for q,r in pairs(k)do if q~=\"require\"and q~=\"__scrapelocals\"and q~=\"_ENV\"and q~=\"_G\"then local s=type(r)if s==\"function\"then j[#j+1]={lib=g,type=\"A\",name=q,value=tonumber(tostring(r):match(\": (%x+)\"),16),size=#string.dump(r)}elseif s==\"string\"then j[#j+1]={lib=g,type=\"A\",name=q,value=i,size=#r}elseif s==\"number\"then j[#j+1]={lib=g,type=\"A\",name=q,value=i,size=8}elseif s==\"boolean\"then j[#j+1]={lib=g,type=\"A\",name=q,value=i,size=1}elseif s==\"nil\"then j[#j+1]={lib=g,type=\"A\",name=q,value=i,size=0}else j[#j+1]={lib=g,type=\"A\",name=q,value=tonumber(tostring(r):match(\": (%x+)\"),16),size=#r or 8}end end end end;if not d.g and not d.e then for f,m in ipairs(h)do for q in pairs(m.used)do j[#j+1]={lib=m.name,type=\"U\",name=q}end end end;if d.v then table.sort(j,function(D,E)return(D.value or-1)<(E.value or-1)end)else table.sort(j,function(D,E)return D.name<E.name end)end;if#d>1 then print(g..\":\")end;for f,F in ipairs(j)do if d.P then print(e[d.t]:format(d.A and F.lib..\": \"or\"\",F.name,F.type,F.value or 0,F.size or 0))else if d.A then io.write(F.name..\":\")end;if F.value then io.write((\"%016x \"):format(F.value))else io.write(\"         \")end;print(F.type..\" \"..F.name)end end else io.stderr:write(\"nm: could not load \"..g..\": \"..u..\"\\n\")end else io.stderr:write(\"nm: could not load \"..g..\": \"..u..\"\\n\")end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291483,size=4032},["mount.lua"]={type="file",created=1740881291519,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.util\"if select(\"#\",...)==0 then for c,d in ipairs(a.mountlist())do local e={}for f,g in pairs(d.options)do if g==true then e[#e+1]=f elseif type(g)==\"string\"then e[#e+1]=g elseif type(g)==\"number\"then e[#e+1]=tostring(g)end end;print((\"%s on %s type %s (%s)\"):format(d.source,d.path,d.type,table.concat(e,\",\")))end;return end;local h={}local i=a.open(\"/etc/fstab\",\"r\")if i then for j in i.readLine do local k,l,type,e,c,m=j:gsub(\"#.*\",\"\"):match(\"(%S+)%s+(%S+)%s+(%S+)%s+(%S+)%s+(%S+)%s+(%S+)\")if k then k=k:gsub(\"\\\\([0-3][0-7][0-7])\",function(n)return string.char(tonumber(n,8))end):gsub(\"\\\\x(%x%x)\",function(n)return string.char(tonumber(n,16))end)l=l:gsub(\"\\\\([0-3][0-7][0-7])\",function(n)return string.char(tonumber(n,8))end):gsub(\"\\\\x(%x%x)\",function(n)return string.char(tonumber(n,16))end)local o={}for p in e:gmatch\"[^,]+\"do local f,d=p:match\"([^=]+)=?(.*)\"if f==\"defaults\"then o.rw=true;o.suid=true;o.dev=true;o.exec=true;o.auto=true;o.owner=true;o.async=true else if not f then f,d=p,true end;o[f]=d end end;h[k]={src=k,dest=l,type=type,options=o,check=tonumber(m)}h[#h+1]=h[k]end end end;local q=assert(b.argparse({t=true,o=true,a=false},...))if q.a then local r=true;for c,d in ipairs(h)do if d.options.auto and not d.options.noauto then local s,t=pcall(a.mount,d.type,d.src,d.dest,d.options)if not s and not d.options.nofail then io.stderr:write(\"mount: could not mount \"..d.src..\": \"..t..\"\\n\")r=false end end end;return r end;if q[1]and not q[2]and h[q[1]]then q[2]=h[q[1]].dest end;if#q<2 then error(\"Usage: mount [-t type] [-o options] device [mountpoint]\\n       mount -a\")end;local type=q.t or h[q[1]]and h[q[1]].type or\"craftos\"local o=h[q[1]]and h[q[1]].options or{rw=true,suid=true,dev=true,exec=true,auto=true,owner=true,async=true}if q.o then for p in q.o:gmatch\"[^,]+\"do local f,d=p:match\"([^=]+)=(.*)\"if not f then f,d=p,true end;o[f]=d end end;return a.mount(type,q[1],q[2],o)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291482,size=1959},["clear.lua"]={type="file",created=1740881291505,worldPermissions={execute=true,read=true,write=false},data="io.write(\"\\x1b[0m\\x1b[2J\\x1b[H\")\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291465,size=33},["lua.lua"]={type="file",created=1740881291517,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.pretty\"local b=require\"system.terminal\"local c=require\"system.util\"local d=assert(c.argparse({h=false,help=false,e=true,l=true,i=false,v=false},...))for e,f in ipairs(d)do if f==\"--\"then table.remove(d,e)break end end;if d.h then print[=[\nusage: lua [options] [script [args]].\nAvailable options are:\n  -e stat  execute string 'stat'\n  -l name  require library 'name'\n  -i       enter interactive mode after executing 'script'\n  -v       show version information\n  --       stop handling options\n  -        execute stdin and stop handling options\n]=]return 0 elseif d.v then print(_VERSION,\"Copyright (C) 2021 JackMacWindows\")return 0 end;if d.l then _ENV[d.l]=require(d.l)end;if d.e then assert(load(d.e,\"=(command line)\",\"t\"))()end;if d[1]then local g;if d[1]==\"-\"then g=assert(load(function()return io.stdin:read(\"*L\")end,\"=stdin\"))else g=assert(load(d[1],\"@\"..d[1]))end;g(table.unpack(d,2,#d))if not d.i then return 0 end end;exit=setmetatable({},{__tostring=function()return\"Press Ctrl+D or Ctrl+C to exit\"end})quit=exit;print(_VERSION,\"Copyright (C) 2021 JackMacWindows\")local h={}while true do local i=\"\"local g,j;repeat if i==\"\"then io.stdout:write(\"> \")else io.stdout:write(\">> \")end;local k=b.readline2(h)if not k then print()return 0 end;i=i..k..\"\\n\"g,j=load(\"return \"..i,\"=stdin\")if not g then g,j=load(i,\"=stdin\")end until g or not j:match(\"<eof>\")if g then local l=table.pack(pcall(g))if l[1]then for e=2,l.n do a.print(a.pretty(l[e],{function_source=true,function_args=true}))end else io.stderr:write(l[2]..\"\\n\")end else io.stderr:write(j..\"\\n\")end;table.insert(h,1,i:sub(1,-2))end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291480,size=1619},["halt.lua"]={type="file",created=1740881291512,worldPermissions={execute=true,read=true,write=false},data="coroutine.yield(\"syscall\",\"devcall\",\"/\",\"shutdown\")\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291474,size=52}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294686,size=0},root={type="directory",created=1740881294723,worldPermissions={write=false,read=true,execute=true},contents={},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294723,size=0},sbin={type="directory",created=1740881294013,worldPermissions={write=false,read=true,execute=true},contents={["mkspanfs.lua"]={type="file",created=1740881293902,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.hardware\"local c=require\"system.process\"local d={...}if#d<3 then error(\"Usage: mkspanfs <name> <index drive> <data drives...>\")end;if c.getuser()~=\"root\"then error(\"This program must be run as root.\")end;local e=table.remove(d,1)local f=\"The following disks will be erased and replaced with a new span filesystem:\\n\"for g,h in ipairs(d)do local i=b.info(h)if not i then error(\"Device '\"..h..\"' does not exist.\")end;if not i.types.drive then error(\"Device '\"..h..\"' is not a compatible disk drive.\")end;f=f..\"  Drive '\"..(i.alias or i.displayName or b.path(h))..\"' (\"..i.uuid..\")\\n\"end;print(f)io.write(\"Continue? (y/N) \")local j=io.read()if j:upper()~=\"Y\"then return false end;local k=('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'):gsub('[xy]',function(l)local h=l=='x'and math.random(0,0xf)or math.random(8,0xb)return('%x'):format(h)end)local m=\"/tmp/.mkspanfs-\"..math.random(0,99999)a.mkdir(m)local n,o=0,0;for p,h in ipairs(d)do a.mount(\"drivefs\",h,m,{})for g,q in ipairs(a.list(m))do a.remove(m..\"/\"..q)end;local r=assert(io.open(m..\"/.spanfs\",\"w\"))r:write(e..\"\\n\"..k..\"\\n\"..p-1 ..\"\\n\")r:close()if p==1 then r=assert(io.open(m..\"/index\",\"wb\"))r:write((\"<III8I8BBs2s2Bs2BI\"):pack(38+#e,0,os.time()*1000,os.time()*1000,5,5,e,\"root\",1,\"root\",7,0))r:close()local s=a.stat(m)print(\"Index disk \"..h..\" has \"..s.freeSpace..\" bytes free\")else local s=a.stat(m)print(\"Data disk \"..h..\" has \"..s.freeSpace..\" bytes free\")n=n+s.freeSpace;o=o+s.capacity end;a.unmount(m)end;a.remove(m)print(\"Finished creating span filesystem '\"..e..\"' (\"..k..\") across \"..#d..\" disks.\")print(\"Total disk capacity: \"..o)print(\"Usable space: \"..n)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293882,size=1673},["startctl.lua"]={type="file",created=1740881294013,worldPermissions={execute=true,read=true,write=false},data="local a=require\"startmgr\"local b=require\"system.util\"local c=assert(b.argparse({user=false},...))local d;if not c.user then d=\"root\"end;if not a[c[1]]then error(\"Invalid operation\")end;if c[1]==\"list\"then local e,f=a.list(d)for g,h in pairs(f)do print(g..\": \"..(h.running and\"running\"or\"stopped\"))end else print(a[c[1]](c[2],d))end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293996,size=332},["mkencryptfs.lua"]={type="file",created=1740881292050,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=require\"system.terminal\"local d=require\"system.util\"local e=require\"ccryptolib.aead\"local f=require\"ccryptolib.random\"local g=require\"ccryptolib.sha256\"local h=assert(d.argparse({p=true,password=\"@p\",t=true,type=\"@t\",d=true,[\"mount-dir\"]=\"@d\",i=\"number\",iter=\"@i\",o=true,options=\"@o\",c=false,convert=\"@c\",e=false,erase=\"@e\"},...))if#h<1 then error(\"Usage: mkencryptfs [-c|-e] [-p <password>] [-t type] [-d mount-dir] [-i iter] [-o options] <filesystem>\")end;if h.c and h.e then error(\"-c and -e are mutually exclusive\")end;if not h.p then c.termctl{echo=false}c.write(\"Enter encryption password: \")h.p=c.readline()c.write(\"\\nConfirm password: \")if h.p~=c.readline()then c.termctl{echo=true}error(\"\\nPasswords do not match.\")end;c.termctl{echo=true}print()end;h.d=h.d or\"/tmp/.mkencryptfs\"f.initWithTiming()a.mkdir(h.d)local i={rw=true,suid=true,dev=true,exec=true,auto=true,owner=true,async=true}if h.o then for j in h.o:gmatch\"[^,]+\"do local k,l=j:match\"([^=]+)=?(.*)\"if not k then k,l=j,true end;i[k]=l end end;print(\"Creating encryptfs filesystem on \"..h[1]..\" (type \"..(h.t or\"craftos\")..\")\")a.mount(h.t or\"craftos\",h[1],h.d,i)if h.e then for m,l in ipairs(a.list(h.d))do a.remove(a.combine(h.d,l))end end;local n=f.random(28)local o=f.random(32)local p=g.digest(h.p..\" encryptfs salt file \\x12\\x34\\x56\\x78\\x9A\\xBC\\xDE\\xF0\"):gsub(\".\",function(q)return(\"%02x\"):format(q:byte())end)local r=assert(a.open(a.combine(h.d,p),\"wb\"))r.write(\"Efs\\x00\")r.write(n)r.write(o)r.close()local s=g.pbkdf2(h.p,n,h.i or 5000)local t=f.random(12)local u=b.getuser()local v=os.time()*1000;local w,x=e.encrypt(s,t,([[{\n    type = \"directory\",\n    owner = \"%s\",\n    permissions = {[\"%s\"] = {read = true, write = true, execute = true}},\n    worldPermissions = {read = true, write = false, execute = true},\n    created = %d,\n    modified = %d,\n    contents = {}\n}]]):format(u,u,v,v),t)o=o:gsub(\".\",function(q)return(\"%02x\"):format(q:byte())end)r=assert(a.open(a.combine(h.d,o),\"wb\"))r.write(\"Efs\\x01\")r.write(t)r.write(x)r.write(w)r.close()if h.c then print(\"Converting drive...\")a.mkdir(h.d..\"_convert\")i.encryptfs_password=h.p;i.encryptfs_basefs=h.t;i.encryptfs_iter=h.i;a.mount(\"encryptfs\",h[1],h.d..\"_convert\",i)local function y(z)local A=a.stat(a.combine(h.d,z))if A.type==\"file\"then print(z)a.move(a.combine(h.d,z),a.combine(h.d..\"_convert\",z))elseif A.type==\"directory\"then a.mkdir(a.combine(h.d..\"_convert\",z))for m,l in ipairs(a.list(a.combine(h.d,z)))do y(a.combine(z,l))end;a.remove(a.combine(h.d,z))elseif A.type==\"link\"then a.link(a.combine(h.d..\"_convert\",z),A.link)elseif A.type==\"fifo\"then a.mkfifo(a.combine(h.d..\"_convert\",z))end end;local B=\"^\"..(\"%x\"):rep(64)..\"$\"for m,l in ipairs(a.list(h.d))do if not l:match(B)then y(l)end end;a.unmount(h.d..\"_convert\")a.remove(h.d..\"_convert\")end;a.unmount(h.d)print(\"Filesystem created successfully.\")\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292047,size=2915},["spaninfo.lua"]={type="file",created=1740881293903,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.util\"local b=...if not b then error(\"Usage: spaninfo <mountpoint>\\n\")end;local function c(d)if d>=1000000000 then return(\"%.3g GB\"):format(d/1000000000)elseif d>=1000000 then return(\"%.3g MB\"):format(d/1000000)elseif d>=1000 then return(\"%.3g kB\"):format(d/1000)else return d..\" bytes\"end end;local e=a.syscall.callmodule(\"spanfs\",\"info\",b)local f=a.syscall.stat(b)print(\"Span '\"..e.name..\"' (\"..e.uuid..\")\")print(\"Capacity: \"..c(f.capacity))print(\"Free space: \"..c(f.freeSpace))print(\"Disks:\")for g,h in pairs(e.disks)do print(\"  Disk \"..g..\" (\"..h.device:match(\"^%x+\")..\"): \"..h.space..\" bytes free\")end;print(\"Free index space: \"..e.freeindex)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293884,size=670},["spanadd.lua"]={type="file",created=1740881293903,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.hardware\"local c=require\"system.process\"local d=require\"system.util\"local e={...}if#e<2 then error(\"Usage: spanadd <span mount> <drives...>\")end;if c.getuser()~=\"root\"then error(\"This program must be run as root.\")end;local f=table.remove(e,1)local g=d.syscall.callmodule(\"spanfs\",\"info\",f)local h=\"The following disks will be erased and added to the span filesystem '\"..(g.name or g.uuid)..\"':\\n\"for i,j in ipairs(e)do local k=b.info(j)if not k then error(\"Device '\"..j..\"' does not exist.\")end;if not k.types.drive then error(\"Device '\"..j..\"' is not a compatible disk drive.\")end;h=h..\"  Drive '\"..(k.alias or k.displayName or b.path(j))..\"' (\"..k.uuid..\")\\n\"end;print(h)io.write(\"Continue? (y/N) \")local l=io.read()if l:upper()~=\"Y\"then return false end;local m=\"/tmp/.mkspanfs-\"..math.random(0,99999)a.mkdir(m)local n,o=g.freeSpace,g.capacity;for i,j in ipairs(e)do a.mount(\"drivefs\",j,m,{})for i,p in ipairs(a.list(m))do a.remove(m..\"/\"..p)end;local q=assert(io.open(m..\"/.spanfs\",\"w\"))q:write(g.name..\"\\n\"..g.uuid..\"\\n\"..#g.disks+1 ..\"\\n\")q:close()local r=a.stat(m)print(\"Data disk \"..j..\" has \"..r.freeSpace..\" bytes free\")n=n+r.freeSpace;o=o+r.capacity;g.disks[#g.disks+1]={device=j,space=r.freeSpace}a.unmount(m)end;a.remove(m)print(\"Finished adding \"..#e..\" disks to the span filesystem '\"..g.name..\"' (\"..g.uuid..\").\")print(\"New total disk capacity: \"..o)print(\"Usable space: \"..n)print(\"You must remount the filesystem or restart the computer for changes to take effect.\")\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293883,size=1543},["shutdown.lua"]={type="file",created=1740881294013,worldPermissions={execute=true,read=true,write=false},data="local a=require\"startmgr\"local b=require\"system.log\"local c=require\"system.process\"local d=require\"system.util\"local e=assert(d.argparse({P=false,poweroff=\"@P\",H=\"@P\",halt=\"@P\",h=\"@P\",r=false,reboot=\"@r\",c=false,show=false,help=false},...))if e.help then print[[\nUsage: shutdown [OPTIONS] [TIME]\nOptions:\n  --help          Show this help\n  -H, --halt      Equivalent to -P\n  -P, --poweroff  Power off the machine\n  -r, --reboot    Reboot the machine\n  -h              Equivalent to -P\n  -c              Cancel a pending shutdown\n  --show          Show pending shutdown\n]]end;local f={31,28,31,30,31,30,31,31,30,31,30,31}local function g(h)return h%4==0 and(h%100~=0 or h%400==0)end;if e.c then return a.remove(\"shutdown-timer\",\"root\")elseif e.show then local i=a.status(\"shutdown-timer\",\"root\")if i then else print(\"No scheduled shutdown.\")end else local j=e[1]or\"+1\"if j==\"+0\"or j==\"now\"then if e.r and not e.P then assert(a.reboot())else assert(a.shutdown())end else local k;if j:match\"^%+%d+$\"then k=tonumber(j:match\"^%+(%d+)$\")*60 elseif j:match\"^%d+:%d+$\"then local l,m=j:match\"^(%d+):(%d+)$\"l,m=tonumber(l),tonumber(m)if l<0 or l>23 or m<0 or m>59 then error(\"shutdown: Invalid argument\")end;local n=os.date(\"!*t\")if l<n.hour or l==n.hour and m<n.min then n.day=n.day+1;n.wday=(n.wday+1)%7;n.yday=(n.yday+1)%(g(n.year)and 366 or 365)if n.day>f[n.month]or n.month==2 and g(n.year)and n.day>29 then n.day=1;n.month=n.month+1;if n.month>12 then n.month=1;n.year=n.year+1 end end end;n.hour,n.min,n.sec=l,m,0;k=os.time(n)-os.time()else error(\"shutdown: Invalid argument\")end;assert(a.add([[\nname = \"shutdown-timer\"\nunit.description = \"Shutdown Timer\"\nfunction trigger()\n    startmgr.]]..(e.r and not e.P and\"reboot\"or\"shutdown\")..[[()\nend\ntimer.loadTime = ]]..k,\"root\"))b.notice(\"System is going down in \"..k/60 ..\" minutes.\")end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293995,size=1836},["init.lua"]={type="file",created=1740881294012,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.expect\"local b=require\"system.filesystem\"local c=require\"system.ipc\"local d=require\"system.log\"local e=require\"system.process\"local f=require\"system.sync\"local g=require\"system.util\"startmgr={}local h,i;local j={}local k=e.getuser()if k==\"root\"then assert(e.getpid()==1,\"startmgr must be run as init.\")h={\"/etc/startmgr/system\",j}c.register(\"ServiceManager\")i=d.create(\"startmgr\",true,\"/var/log/startmgr.log\")else assert(not c.lookup(\"ServiceManager.\"..k),\"startmgr is already running for this user.\")h={\"/home/\"..k..\"/.local/etc/startmgr\",\"/etc/startmgr/user\",j}c.register(\"ServiceManager.\"..k)i=d.create(\"startmgr.\"..k,true,\"/home/\"..k..\"/.local/var/log/startmgr.log\")end;local l={}local m,n;local o={[0]='\\27[90m','\\27[97m','\\27[36m','\\27[93m','\\27[31m','\\27[95m','\\27[96m'}local function p(q,r,...)if k==\"root\"then local s=o[r or 1]if q==\"OK\"then s=\"\\27[92m\"end;local t=...print((q and\"[\"..s..(\" \"):rep(math.floor((6-#q)/2))..q..(\" \"):rep(math.ceil((6-#q)/2))..\"\\27[0m]\"or\"        \")..\"  \"..t)end;i.log({level=r},...)end;local function u(v)if type(v)==\"table\"then local w={}for x,t in pairs(v)do w[u(x)]=u(t)end;return w else return v end end;local function y(z,A)if next(z)==nil then return true end;local B=f.barrier.new(#z+1)local C,D=true,\"\"for x,t in pairs(z)do e.newthread(function()local E,F=A(x)if t and not E then C=false;if F then D=D..F..\"\\n\"end end;B:wait()end)end;B:wait()return C,D:gsub(\"\\n+$\",\"\")end;function startmgr.start(G)local H=l[G]if not H then return false,\"No such service\"end;if H.runtime.running then return false,\"Service is already running\"end;if H.runtime.pending then return true end;local I={}for J,t in ipairs(H.unit.wants or{})do I[t]=false end;for J,t in ipairs(H.unit.upholds or{})do I[t]=false end;for J,t in ipairs(H.unit.requires or{})do if not l[t]then return false,\"Required service \"..t..\" does not exist\"end;I[t]=true end;for J,t in ipairs(H.unit.bindsTo or{})do if not l[t]then return false,\"Required service \"..t..\" does not exist\"end;I[t]=true end;for J,t in ipairs(H.unit.requisites or{})do if not l[t]or not l[t].runtime.running then return false,\"Requisite service \"..t..\" is not running\"end end;for J,t in ipairs(H.unit.conflicts or{})do if l[t]and l[t].runtime.running then return false,\"Conflicting service \"..t..\" is running\"end end;local K,L,M={},{[G]=true},{}local N,O={},{}for J,t in ipairs(H.unit.before or{})do N[t]=true end;for J,t in ipairs(H.unit.after or{})do O[t]=true end;for x,t in pairs(I)do if O[x]then K[x]=t end;if N[x]then M[x]=t end;if l[x]then for J,P in ipairs(l[x].unit.before or{})do if P==x then K[x]=t;break end end;for J,P in ipairs(l[x].unit.after or{})do if P==x then M[x]=t;break end end end;if K[x]and M[x]then return false,\"Service is misconfigured: Dependency \"..x..\" is ordered both before and after service\"end;if not K[x]and not M[x]then L[x]=t end end;if H.runtime.pending then return true end;H.runtime.pending=true;local E,F=y(K,startmgr.start)if not E then H.runtime.pending=false;return false,F end;E,F=y(L,function(Q)if Q==G then local E,R=false,\"Missing service start function\"if H.start then p(nil,nil,\"Starting \"..(H.unit and H.unit.description or Q)..\"...\")E,R=pcall(H.start)H.runtime.running=E and R;H.runtime.pending=false;p(E and R and\"OK\"or\"ERROR\",E and R and d.levels.notice or d.levels.error,\"Started \"..(H.unit and H.unit.description or Q)..\".\")end;if not E and type(R)==\"string\"then p(\"ERROR\",d.levels.error,\"Service \"..Q..\" threw an error:\",R)end;if not E or not R then return false,E and\"Failed to start service\"or R end;return true else return startmgr.start(Q)end end)if not E then return false,F end;return y(M,startmgr.start)end;function startmgr.stop(G)local H=l[G]if not H then return false,\"No such service\"end;if not H.runtime.running then return false,\"Service is already stopped\"end;local S={[G]=true}for J,t in ipairs(H.unit.bindsTo or{})do S[t]=false end;for J,t in ipairs(H.unit.parts or{})do S[t]=false end;return y(S,function(Q)if Q==G then p(nil,nil,\"Stopping \"..(H.unit and H.unit.description or Q)..\"...\")H.runtime.pending=true;if H.stop then local E,R=pcall(H.stop,false)H.runtime.running=not(E and R)if H.runtime.running then if not E and type(R)==\"string\"then p(\"ERROR\",d.levels.error,\"Service \"..Q..\" threw an error:\",R)end;return false,E and\"Failed to start service\"or R end end;for J,t in pairs(H.service.pid)do c.kill(t,c.signal.SIGHUP)end;return true else return startmgr.stop(Q)end end)end;function startmgr.kill(G)local H=l[G]if not H then return false,\"No such service\"end;if not H.runtime.running then return false,\"Service is already stopped\"end;local S={[G]=true}for J,t in ipairs(H.unit.bindsTo or{})do S[t]=false end;for J,t in ipairs(H.unit.parts or{})do S[t]=false end;return y(S,function(Q)if Q==G then p(nil,nil,\"Killing \"..(H.unit and H.unit.description or Q)..\"...\")H.runtime.pending=true;if H.stop then pcall(H.stop,true)H.runtime.running=false end;for J,t in pairs(H.service.pid)do c.kill(t,c.signal.SIGKILL)end;return true else return startmgr.stop(Q)end end)end;function startmgr.restart(G)local E,F=startmgr.stop(G)if not E then return E,F end;return startmgr.start(G)end;local function T(U,V,W,X,Y,Z)local _=setmetatable(u(U[V])or{name=V,path=W~=j and b.combine(W,X)or nil,runtime={},unit={},install={},service={pid={}},timer={}},{__index=_ENV})local A,F;if W==j then A,F=load(X,\"=service:\"..V,\"t\",_)else A,F=loadfile(b.combine(W,X),\"t\",_)end;if A then local E;E,F=pcall(A)if E then if _.service and type(_.unit.partOf)==\"table\"then for J,t in ipairs(_.unit.partOf)do Y[t]=Y[t]or{}Y[t][#Y[t]+1]=V end end;U[V]=_;_.runtime.didDelete=nil else Z[#Z+1]=\"\\x1b[31mError\\x1b[0m: Could not load \"..V..\": \"..F end else Z[#Z+1]=\"\\x1b[31mError\\x1b[0m: Could not load \"..V..\": \"..F end end;function startmgr.reload(G)if G then local H=l[G]if not H then return false,\"No such service\"end;if not H.runtime.running then return false,\"Service is not running\"end;if H.reload then return pcall(H.reload)else return true,\"Service has no reload function\"end else local U={}local Z={}for x,t in pairs(l)do if t.runtime.running then U[x]=t;t.runtime.didDelete=true end end;local Y={}for J,W in ipairs(h)do local E,z;if W==j then E,z=true,j else E,z=pcall(b.list,W)end;if E then for J,X in ipairs(z)do local V=W==j and select(2,X:match\"name%s*=%s*([\\\"'])([^\\\"']+)%1\")or X:match(\"^%w+\")if X:match\"%.wants$\"and b.isDir(b.combine(W,X))then if not U[V]then U[V]={unit={requires={}}}end;if not U[V].unit.requires then U[V].unit.requires={}end;local a0=U[V].unit.requires;for J,a1 in ipairs(b.list(b.combine(W,X)))do local Q=a1:match(\"^%w+\")T(U,Q,b.combine(W,X),a1,Y,Z)a0[#a0+1]=Q end else T(U,V,W,X,Y,Z)end end end end;for x,t in pairs(Y)do if U[x]and U[x].service then U[x].unit.parts=t end end;for x,t in pairs(U)do if t.runtime.didDelete then Z[#Z+1]=\"\\x1b[93mWarning\\x1b[0m: The service \"..x..\"was deleted on disk, but it is still running. The service will be deleted upon being stopped.\"end end;l=U;return true,Z end end;function startmgr.add(a2)local J,X=a2:match\"name%s*=%s*([\\\"'])([^\\\"']+)%1\"if not X then return false,\"Could not get name from service\"end;if l[X]then return false,\"Service with this name already exists\"end;j[#j+1]=a2;startmgr.reload()return true,X end;function startmgr.remove(G)for a3,t in ipairs(j)do local J,X=t:match\"name%s*=%s*([\\\"'])([^\\\"']+)%1\"if X==G then table.remove(j,a3)return true end end;return false end;function startmgr.list()local w={}for x,t in pairs(l)do w[x]={running=t.runtime.running}end;return true,w end;function startmgr.status(G)end;function startmgr.install(G)local H=l[G]if not H or not H.path or not H.install.wantedBy then return false end;local a4=l[H.install.wantedBy]if not a4 or not a4.path then return false end;b.mkdir(a4.path..\".wants\")if not b.exists(a4.path..\".wants/\"..b.basename(H.path))then b.link(a4.path..\".wants/\"..b.basename(H.path),H.path)end;return true end;function startmgr.uninstall(G)local H=l[G]if not H or not H.path or not H.install.wantedBy then return false end;local a4=l[H.install.wantedBy]if not a4 or not a4.path then return false end;b.remove(a4.path..\".wants/\"..b.basename(H.path))return true end;local function a5()p(nil,nil,\"Stopping all services...\")local a6=0;repeat local E=true;for x,t in pairs(l)do if t.runtime.running then E=(a6>=5 and startmgr.kill or startmgr.stop)(x)and E end end;a6=a6+1;if a6>10 then p(\"ERROR\",d.levels.error,\"Could not stop all services successfully, killing all processes.\")elseif a6==5 then p(nil,nil,\"Killing all remaining services...\")end;g.sleep(0.25)until E or a6>10 end;function startmgr.shutdown()if k~=\"root\"then return false,\"Operation invalid for this instance\"end;a5()g.syscall.devcall(\"/\",\"shutdown\")end;function startmgr.reboot()if k~=\"root\"then return false,\"Operation invalid for this instance\"end;a5()g.syscall.devcall(\"/\",\"reboot\")end;print(\"Welcome to \\27[96mPhoenix\\27[0m!\\n\")startmgr.reload()if not l.startup then p(\"WARN\",d.levels.warning,\"No startup service available. Installing default shell service.\")local a7={}l.startup={name=\"startup\",runtime={},unit={description=\"Shell prompt\"},install={},service={pid=a7,restart=k==\"root\"and\"always\"or\"no\"},timer={},start=function()a7[1]=e.start(\"/bin/sh\")return true end}end;assert(startmgr.start(\"startup\"))while true do local a8,a9=coroutine.yield()if a8==\"timer\"and a9.id==n then n=g.timer(m)elseif a8==\"process_complete\"then for x,t in pairs(l)do for a3,a7 in pairs(t.service and t.service.pid or{})do if a7==a9.id then t.service.pid[a3]=nil;local aa=a9.error or a9.value==false;p(nil,nil,\"Process \"..a7 ..\" (of service \"..x..\") exited \"..(aa and\"with an error: \"or\"successfully with return value: \")..(a9.error or tostring(a9.value)))if a9.error then p(\"ERROR\",d.levels.error,a9.error)end;if next(t.service.pid)==nil then if t.runtime.running and not t.runtime.pending and t.service.restart and t.service.restart~=\"no\"then if t.service.restart==\"always\"or t.service.restart==\"on-success\"and not aa or t.service.restart==\"on-failure\"and a9.value==false or t.service.restart==\"on-abnormal\"and aa or t.service.restart==\"on-abort\"and a9.error then startmgr.start(x)end else t.runtime.running=false;t.runtime.pending=false;if aa then if t.failure then pcall(t.failure)end elseif t.success then pcall(t.success)end;p(\"OK\",d.levels.notice,\"Stopped \"..(t.unit and t.unit.description or x)..\".\")end end end end end elseif a8==\"remote_event\"and a9.type==\"startmgr.request\"then if type(a9.data)==\"table\"and type(a9.data.func)==\"string\"then local ab=e.getpinfo(a9.sender)if ab.user==k then e.newthread(function()local A=startmgr[a9.data.func]if A then c.sendEvent(a9.sender,\"startmgr.response\",{func=a9.data.func,ok=true,result={A(a9.data.param)}})else c.sendEvent(a9.sender,\"startmgr.response\",{func=a9.data.func,ok=false,error=\"Unknown function\"})end end)else c.sendEvent(a9.sender,\"startmgr.response\",{func=a9.data.func,ok=false,error=\"Permission denied\"})end else c.sendEvent(a9.sender,\"startmgr.response\",{func=a9.data.func,ok=false,error=\"Invalid request\"})end end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293994,size=11007}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294013,size=0},boot={type="directory",setuser=false,created=1740881294723,worldPermissions={write=false,read=true,execute=true},contents={["kernel.lua"]={type="file",created=1740881290993,worldPermissions={execute=true,read=true,write=false},data="PHOENIX_VERSION=\"0.0.7\"PHOENIX_BUILD=\"PRERELEASE NONFREE Sat Mar  1 21:02:32 2025\"systemStartTime=os.epoch\"utc\"args={init=\"/sbin/init.lua\",root=\"/root\",rootfstype=\"craftos\",preemptive=true,quantum=20000,splitkernpath=\"/boot/kernel.lua.d\",loglevel=1,console=\"tty1\",traceback=true}syscalls={}processes={[0]={name=\"kernel\",id=0,user=\"root\",dir=\"/\",root=\"/\",env=_G,vars={},dependents={}}}KERNEL=processes[0]modules={}eventHooks={}shutdownHooks={}debugHooks=setmetatable({},{__mode=\"k\"})kSyscallYield={}kSyscallComplete={}process={}filesystem={}terminal={}syslog={}hardware={}if discord then discord(\"Phoenix\",\"Booting Phoenix \"..PHOENIX_VERSION)end;do local a=fs.open(\"/rom/modules/main/cc/expect.lua\",\"r\")expect=(loadstring or load)(a.readAll(),\"@/rom/modules/main/cc/expect.lua\")()a.close()setmetatable(expect,{__call=function(self,...)return self.expect(...)end})if not expect.range then function expect.range(b,c,d)expect(1,b,\"number\")expect(2,c,\"number\",\"nil\")expect(3,d,\"number\",\"nil\")if d and c and d<c then error(\"bad argument #3 (min must be less than or equal to max)\",2)end;if b~=b or b<(c or-math.huge)or b>(d or math.huge)then error((\"number outside of range (expected %s to be within %s and %s)\"):format(b,c or-math.huge,d or math.huge),3)end;return b end end end;do local a=fs.open(\"/rom/apis/textutils.lua\",\"r\")local e=setmetatable({dofile=function(g)if g==\"rom/modules/main/cc/expect.lua\"then return expect elseif g==\"rom/modules/main/cc/require.lua\"then return{make=function()return function(h)if h==\"cc.expect\"then return expect else return{}end end end}end end},{__index=_G})local i;if loadstring and setfenv then i=loadstring(a.readAll(),\"@/rom/apis/textutils.lua\")setfenv(i,e)else i=load(a.readAll(),\"@/rom/apis/textutils.lua\",\"t\",e)end;a.close()i()serialize,unserialize=e.serialize,e.unserialize end;do local a=fs.open(\"/rom/apis/keys.lua\",\"r\")local e=setmetatable({dofile=function()return expect end},{__index=_G})if _VERSION<\"Lua 5.2\"then e._ENV=e end;local i;if loadstring and setfenv then i=loadstring(a.readAll(),\"@/rom/apis/keys.lua\")setfenv(i,e)else i=load(a.readAll(),\"@/rom/apis/keys.lua\",\"t\",e)end;a.close()i()keys={}for j,k in pairs(e)do keys[j]=k end end;if not pcall(load,\"return\",\"=test\",\"t\",{})then local l,m,expect,setfenv=load,loadstring,expect,setfenv;function load(n,o,p,e)expect(1,n,\"string\",\"function\")expect(2,o,\"string\",\"nil\")expect(3,p,\"string\",\"nil\")expect(4,e,\"table\",\"nil\")if type(n)==\"string\"then if n:sub(1,4)==\"\\27Lua\"then if p==nil or p:find\"b\"then local i,q=m(n,o)if i and e then setfenv(i,e)end;return i,q else return nil,\"attempt to load a binary chunk (mode is '\"..(p or\"bt\")..\"')\"end else if p==nil or p:find\"t\"then local i,q=m(n,o)if i and e then setfenv(i,e)end;return i,q else return nil,\"attempt to load a text chunk (mode is '\"..(p or\"bt\")..\"')\"end end else local i,q=l(n,o)if i then setfenv(i,e)end;return i,q end end end;loadstring=nil;if bit then if not bit32 then local bit=bit;bit32={bnot=bit.bnot,lshift=bit.blshift,rshift=bit.blogic_rshift,arshift=bit.brshift}function bit32.band(r,s,...)expect(1,r,\"number\")expect(2,s,\"number\",\"nil\")if not s then return r end;return bit32.band(bit.band(r,s),...)end;function bit32.bor(r,s,...)expect(1,r,\"number\")expect(2,s,\"number\",\"nil\")if not s then return r end;return bit32.bor(bit.bor(r,s),...)end;function bit32.bxor(r,s,...)expect(1,r,\"number\")expect(2,s,\"number\",\"nil\")if not s then return r end;return bit32.bxor(bit.bxor(r,s),...)end;function bit32.btest(...)return bit32.band(...)~=0 end;function bit32.extract(t,u,v)expect(1,t,\"number\")expect(2,u,\"number\")expect(3,v,\"number\",\"nil\")(expect.range or function()end)(u,0,31)(expect.range or function()end)(u+v-1,0,31)v=v or 1;local w=0;for x=u+v-1,u,-1 do w=w*2+bit.band(t,2^x)/2^x end;return w end;function bit32.replace(t,k,u,v)expect(1,t,\"number\")expect(2,k,\"number\")expect(3,u,\"number\")expect(4,v,\"number\",\"nil\")(expect.range or function()end)(u,0,31)(expect.range or function()end)(u+v-1,0,31)v=v or 1;local y=2^v-1;return bit.bor(bit.band(t,bit.bnot(bit.blshift(y,u))),bit.blshift(bit.band(k,y),u))end;function bit32.lrotate(r,z)return bit.bor(bit.blshift(r,z),bit.blogic_rshift(r,32-z))end;function bit32.rrotate(r,z)return bit.bor(bit.blogic_rshift(r,z),bit.blshift(r,32-z))end end;bit=nil end;if _VERSION==\"Lua 5.1\"and load(\"::a:: goto a\")then _VERSION=\"Lua 5.2\"if load(\"return 1 >> 2 & 3\")then _VERSION=\"Lua 5.3\"if load(\"local <const> a = 2\")then _VERSION=\"Lua 5.4\"end end end;if _VERSION==\"Lua 5.1\"then if not table.pack then table.pack=function(...)local A={...}A.n=select(\"#\",...)return A end end;if not table.unpack then table.unpack,unpack=unpack,nil end;local B,k=xpcall(function(C)return C end,function()end,true)if not k then local D=xpcall;xpcall=function(f,E,...)if select(\"#\",...)>0 then local args=table.pack(...)return D(function()return f(table.unpack(args,1,args.n))end,E)else return D(f,E)end end end end;if tonumber(_HOST:match\"ComputerCraft 1.(%d+)\")<95 then local F=fs.combine;function fs.combine(G,...)if...~=nil then return F(G,fs.combine(...))else return G end end end;if not string.pack then local expect=expect.expect;local H={BIG_ENDIAN=1,LITTLE_ENDIAN=2}local I={b=1,B=1,h=1,H=1,l=1,L=1,j=1,J=1,T=1}local J={b=1,B=1,x=1,h=2,H=2,f=4,j=4,J=4,l=8,L=8,T=8,d=8,n=8}local function K(t)if t%1>=0.5 then return math.ceil(t)else return math.floor(t)end end;local function L(f)if f==0 then return 0 elseif f==-0 then return 0x80000000 elseif f==math.huge then return 0x7F800000 elseif f==-math.huge then return 0xFF800000 end;local C,M=math.frexp(f)if M>127 or M<-126 then error(\"number out of range\",3)end;M,C=M+126,K((math.abs(C)-0.5)*0x1000000)if C>0x7FFFFF then M=M+1 end;return bit32.bor(f<0 and 0x80000000 or 0,bit32.lshift(bit32.band(M,0xFF),23),bit32.band(C,0x7FFFFF))end;local function N(f)if f==0 then return 0,0 elseif f==-0 then return 0x80000000,0 elseif f==math.huge then return 0x7FF00000,0 elseif f==-math.huge then return 0xFFF00000,0 end;local C,M=math.frexp(f)if M>1023 or M<-1022 then error(\"number out of range\",3)end;M,C=M+1022,K((math.abs(C)-0.5)*0x20000000000000)if C>0xFFFFFFFFFFFFF then M=M+1 end;return bit32.bor(f<0 and 0x80000000 or 0,bit32.lshift(bit32.band(M,0x7FF),20),bit32.band(C/0x100000000,0xFFFFF)),bit32.band(C,0xFFFFFFFF)end;local function O(P)if P==0 then return 0 elseif P==0x80000000 then return-0 elseif P==0x7F800000 then return math.huge elseif P==0xFF800000 then return-math.huge end;local C,M=bit32.band(P,0x7FFFFF),bit32.band(bit32.rshift(P,23),0xFF)M,C=M-126,C/0x1000000+0.5;local t=math.ldexp(C,M)return bit32.btest(P,0x80000000)and-t or t end;local function Q(R,S)if R==0 and S==0 then return 0 elseif R==0x80000000 and S==0 then return-0 elseif R==0x7FF00000 and S==0 then return math.huge elseif R==0xFFF00000 and S==0 then return-math.huge end;local C,M=bit32.band(R,0xFFFFF)*0x100000000+bit32.band(S,0xFFFFFFFF),bit32.band(bit32.rshift(R,20),0x7FF)M,C=M-1022,C/0x20000000000000+0.5;local t=math.ldexp(C,M)return bit32.btest(R,0x80000000)and-t or t end;local function T(b,U,V,W,X,Y,Z)local _=0;if W%math.min(U,X)~=0 and X>1 then local x=0;while W%math.min(U,X)~=0 and x<X do V[W]=0;W=W+1;_=_+1;x=x+1 end end;if Y==H.BIG_ENDIAN then local a0=0;if U>8 then for x=0,U-9 do V[W+x]=Z and b>=2^(U*8-1)~=0 and 0xFF or 0;a0=a0+1;_=_+1 end end;for x=a0,U-1 do V[W+x]=bit32.band(bit32.rshift(b,(U-x-1)*8),0xFF)_=_+1 end else for x=0,math.min(U,8)-1 do V[W+x]=b/2^(x*8)%256;_=_+1 end;for x=8,U-1 do V[W+x]=Z and b>=2^(U*8-1)~=0 and 0xFF or 0;_=_+1 end end;return _ end;local function a1(a2,W,U,Y,X,Z)local a3,a4=0,0;if W%math.min(U,X)~=0 and X>1 then for x=0,X-1 do if W%math.min(U,X)==0 then break end;W=W+1;a4=a4+1 end end;for x=0,U-1 do a3=a3+a2:byte(W+x)*2^((Y==H.BIG_ENDIAN and U-x-1 or x)*8)a4=a4+1 end;if Z and a3>=2^(U*8-1)then a3=a3-2^(U*8)end;return a3,a4 end;local function a5(a6,X)local a7=J[a6]or 0;if X>1 and a7%X~=0 then a7=a7+X-a7%X end;return a7 end;function string.pack(...)local a8=expect(1,...,\"string\")local Y=H.LITTLE_ENDIAN;local X=1;local a9=1;local aa=2;local V={}local x=1;while x<=#a8 do local ab=a8:sub(x,x)x=x+1;if ab=='='or ab=='<'then Y=H.LITTLE_ENDIAN elseif ab=='>'then Y=H.BIG_ENDIAN elseif ab=='!'then local U=-1;while x<=#a8 and a8:sub(x,x):match(\"%d\")do if U>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;U=math.max(U,0)*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 or U==0 then error(string.format(\"integral size (%d) out of limits [1,16]\",U),2)elseif U==-1 then X=4 else X=U end elseif I[ab]then local b=expect(aa,select(aa,...),\"number\")aa=aa+1;if b>=math.pow(2,a5(ab,0)*8-(ab:match(\"%l\")and 1 or 0))or b<(ab:match(\"%l\")and-math.pow(2,a5(ab,0)*8-1)or 0)then error(string.format(\"bad argument #%d to 'pack' (integer overflow)\",aa-1),2)end;a9=a9+T(b,a5(ab,0),V,a9,X,Y,false)elseif ab:lower()=='i'then local Z=ab=='i'local U=-1;while x<=#a8 and a8:sub(x,x):match(\"%d\")do if U>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;U=math.max(U,0)*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 or U==0 then error(string.format(\"integral size (%d) out of limits [1,16]\",U),2)elseif X>1 and(U~=1 and U~=2 and U~=4 and U~=8 and U~=16)then error(\"bad argument #1 to 'pack' (format asks for alignment not power of 2)\",2)elseif U==-1 then U=4 end;local b=expect(aa,select(aa,...),\"number\")aa=aa+1;if b>=math.pow(2,U*8-(ab:match(\"%l\")and 1 or 0))or b<(ab:match(\"%l\")and-math.pow(2,U*8-1)or 0)then error(string.format(\"bad argument #%d to 'pack' (integer overflow)\",aa-1),2)end;a9=a9+T(b,U,V,a9,X,Y,Z)elseif ab=='f'then local f=expect(aa,select(aa,...),\"number\")aa=aa+1;local P=L(f)if a9%math.min(4,X)~=0 and X>1 then for ac=0,X-1 do if a9%math.min(4,X)==0 then break end;V[a9]=0;a9=a9+1 end end;for ac=0,3 do V[a9+(Y==H.BIG_ENDIAN and 3-ac or ac)]=bit32.band(bit32.rshift(P,ac*8),0xFF)end;a9=a9+4 elseif ab=='d'or ab=='n'then local f=expect(aa,select(aa,...),\"number\")aa=aa+1;local R,S=N(f)if a9%math.min(8,X)~=0 and X>1 then for ac=0,X-1 do if a9%math.min(8,X)==0 then break end;V[a9]=0;a9=a9+1 end end;for ac=0,3 do V[a9+(Y==H.BIG_ENDIAN and 7-ac or ac)]=bit32.band(bit32.rshift(S,ac*8),0xFF)end;for ac=4,7 do V[a9+(Y==H.BIG_ENDIAN and 7-ac or ac)]=bit32.band(bit32.rshift(R,(ac-4)*8),0xFF)end;a9=a9+8 elseif ab=='c'then local U=0;if x>#a8 or not a8:sub(x,x):match(\"%d\")then error(\"missing size for format option 'c'\",2)end;while x<=#a8 and a8:sub(x,x):match(\"%d\")do if U>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if a9+U<a9 or a9+U>0xFFFFFFFF then error(\"bad argument #1 to 'pack' (format result too large)\",2)end;local a2=expect(aa,select(aa,...),\"string\")aa=aa+1;if#a2>U then error(string.format(\"bad argument #%d to 'pack' (string longer than given size)\",aa-1),2)end;if U>0 then for ac=0,U-1 do V[a9+ac]=a2:byte(ac+1)or 0 end;a9=a9+U end elseif ab=='z'then local a2=expect(aa,select(aa,...),\"string\")aa=aa+1;for ad in a2:gmatch\".\"do if ad=='\\0'then error(string.format(\"bad argument #%d to 'pack' (string contains zeros)\",aa-1),2)end end;for ac=0,#a2-1 do V[a9+ac]=a2:byte(ac+1)end;V[a9+#a2]=0;a9=a9+#a2+1 elseif ab=='s'then local U=0;while x<=#a8 and a8:sub(x,x):match(\"%d\")do if U>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 then error(string.format(\"integral size (%d) out of limits [1,16]\",U),2)elseif U==0 then U=4 end;local a2=expect(aa,select(aa,...),\"string\")aa=aa+1;if#a2>=math.pow(2,U*8)then error(string.format(\"bad argument #%d to 'pack' (string length does not fit in given size)\",aa-1),2)end;T(#a2,U,V,a9,1,Y,false)for ac=U,#a2+U-1 do V[a9+ac]=a2:byte(ac-U+1)or 0 end;a9=a9+#a2+U elseif ab=='x'then V[a9]=0;a9=a9+1 elseif ab=='X'then if x>=#a8 then error(\"invalid next option for option 'X'\",2)end;local U=0;local ab=a8:sub(x,x)x=x+1;if ab:lower()=='i'then while x<=#a8 and a8:sub(x,x):match(\"%d\")do if U>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 or U==0 then error(string.format(\"integral size (%d) out of limits [1,16]\",U),2)end else U=a5(ab,0)end;if U<1 then error(\"invalid next option for option 'X'\",2)end;if a9%math.min(U,X)~=0 and X>1 then for ac=1,X do if a9%math.min(U,X)==0 then break end;V[a9]=0;a9=a9+1 end end elseif ab~=' 'then error(string.format(\"invalid format option '%s'\",ab),2)end end;return string.char(table.unpack(V))end;function string.packsize(a8)local a9=0;local X=1;local x=1;while x<=#a8 do local ab=a8:sub(x,x)x=x+1;if ab=='!'then local U=0;while x<=#a8 and a8:sub(x,x):match(\"%d\")do if U>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 then error(string.format(\"integral size (%d) out of limits [1,16]\",U),2)elseif U==0 then X=4 else X=U end elseif I[ab]then local U=a5(ab,0)if a9%math.min(U,X)~=0 and X>1 then for ac=1,X do if a9%math.min(U,X)==0 then break end;a9=a9+1 end end;a9=a9+U elseif ab:lower()=='i'then local U=0;while x<=#a8 and a8:sub(x,x):match(\"%d\")do if U>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 then error(string.format(\"integral size (%d) out of limits [1,16]\",U))elseif X>1 and(U~=1 and U~=2 and U~=4 and U~=8 and U~=16)then error(\"bad argument #1 to 'pack' (format asks for alignment not power of 2)\",2)elseif U==0 then U=4 end;if a9%math.min(U,X)~=0 and X>1 then for ac=1,X do if a9%math.min(U,X)==0 then break end;a9=a9+1 end end;a9=a9+U elseif ab=='f'then if a9%math.min(4,X)~=0 and X>1 then for ac=1,X do if a9%math.min(4,X)==0 then break end;a9=a9+1 end end;a9=a9+4 elseif ab=='d'or ab=='n'then if a9%math.min(8,X)~=0 and X>1 then for ac=1,X do if a9%math.min(8,X)==0 then break end;a9=a9+1 end end;a9=a9+8 elseif ab=='c'then local U=0;if x>#a8 or not a8:sub(x,x):match(\"%d\")then error(\"missing size for format option 'c'\",2)end;while x<=#a8 and a8:sub(x,x):match(\"%d\")do if U>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if a9+U<a9 or a9+U>0x7FFFFFFF then error(\"bad argument #1 to 'packsize' (format result too large)\",2)end;a9=a9+U elseif ab=='x'then a9=a9+1 elseif ab=='X'then if x>=#a8 then error(\"invalid next option for option 'X'\",2)end;local U=0;local ab=a8:sub(x,x)x=x+1;if ab:lower()=='i'then while x<=#a8 and a8:sub(x,x):match(\"%d\")do if U>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 or U==0 then error(string.format(\"integral size (%d) out of limits [1,16]\",U),2)end else U=a5(ab,0)end;if U<1 then error(\"invalid next option for option 'X'\",2)end;if a9%math.min(U,X)~=0 and X>1 then for ac=1,X do if a9%math.min(U,X)==0 then break end;a9=a9+1 end end elseif ab=='s'or ab=='z'then error(\"bad argument #1 to 'packsize' (variable-length format)\",2)elseif ab~=' 'and ab~='<'and ab~='>'and ab~='='then error(string.format(\"invalid format option '%s'\",ab),2)end end;return a9 end;function string.unpack(a8,a2,a9)expect(1,a8,\"string\")expect(2,a2,\"string\")expect(3,a9,\"number\",\"nil\")if a9 then if a9<0 then a9=#a2+a9 elseif a9==0 then error(\"bad argument #3 to 'unpack' (initial position out of string)\",2)end;if a9>#a2 or a9<0 then error(\"bad argument #3 to 'unpack' (initial position out of string)\",2)end else a9=1 end;local Y=H.LITTLE_ENDIAN;local X=1;local a7={}local x=1;while x<=#a8 do local ab=a8:sub(x,x)x=x+1;if ab=='<'or ab=='='then Y=H.LITTLE_ENDIAN elseif ab=='>'then Y=H.BIG_ENDIAN elseif ab=='!'then local U=0;while x<=#a8 and a8:sub(x,x):match(\"%d\")do if U>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 then error(string.format(\"integral size (%d) out of limits [1,16]\",U))elseif U==0 then X=4 else X=U end elseif I[ab]then if a9+a5(ab,0)>#a2+1 then error(\"data string too short\",2)end;local w,ae=a1(a2,a9,a5(ab,0),Y,X,ab:match(\"%l\")~=nil)a7[#a7+1]=w;a9=a9+ae elseif ab:lower()=='i'then local Z=ab=='i'local U=0;while x<=#a8 and a8:sub(x,x):match(\"%d\")do if U>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 then error(string.format(\"integral size (%d) out of limits [1,16]\",U),2)elseif U>8 then error(string.format(\"%d-byte integer does not fit into Lua Integer\",U),2)elseif U==0 then U=4 end;if a9+U>#a2+1 then error(\"data string too short\",2)end;local w,ae=a1(a2,a9,U,Y,X,Z)a7[#a7+1]=w;a9=a9+ae elseif ab=='f'then if a9%math.min(4,X)~=0 and X>1 then for ac=1,X do if a9%math.min(4,X)==0 then break end;a9=a9+1 end end;if a9+4>#a2+1 then error(\"data string too short\",2)end;local w=a1(a2,a9,4,Y,X,false)a7[#a7+1]=O(w)a9=a9+4 elseif ab=='d'or ab=='n'then if a9%math.min(8,X)~=0 and X>1 then for ac=1,X do if a9%math.min(8,X)==0 then break end;a9=a9+1 end end;if a9+8>#a2+1 then error(\"data string too short\",2)end;local R,S=0,0;for ac=0,3 do R=bit32.bor(R,bit32.lshift(a2:byte(a9+ac),(Y==H.BIG_ENDIAN and 3-ac or ac)*8))end;for ac=0,3 do S=bit32.bor(S,bit32.lshift(a2:byte(a9+ac+4),(Y==H.BIG_ENDIAN and 3-ac or ac)*8))end;if Y==H.LITTLE_ENDIAN then R,S=S,R end;a7[#a7+1]=Q(R,S)a9=a9+8 elseif ab=='c'then local U=0;if x>#a8 or not a8:sub(x,x):match(\"%d\")then error(\"missing size for format option 'c'\",2)end;while x<=#a8 and a8:sub(x,x):match(\"%d\")do if U>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\")end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if a9+U>#a2+1 then error(\"data string too short\",2)end;a7[#a7+1]=a2:sub(a9,a9+U-1)a9=a9+U elseif ab=='z'then local U=0;while a2:byte(a9+U)~=0 do U=U+1;if a9+U>#a2 then error(\"unfinished string for format 'z'\",2)end end;a7[#a7+1]=a2:sub(a9,a9+U-1)a9=a9+U+1 elseif ab=='s'then local U=0;while x<=#a8 and a8:sub(x,x):match(\"%d\")do if U>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 then error(string.format(\"integral size (%d) out of limits [1,16]\",U),2)elseif U==0 then U=4 end;if a9+U>#a2+1 then error(\"data string too short\",2)end;local b,af=a1(a2,a9,U,Y,X,false)a9=a9+af;if a9+b>#a2+1 then error(\"data string too short\",2)end;a7[#a7+1]=a2:sub(a9,a9+b-1)a9=a9+b elseif ab=='x'then a9=a9+1 elseif ab=='X'then if x>=#a8 then error(\"invalid next option for option 'X'\",2)end;local U=0;local ab=a8:sub(x,x)x=x+1;if ab:lower()=='i'then while x<=#a8 and a8:sub(x,x):match(\"%d\")do if U>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 or U==0 then error(string.format(\"integral size (%d) out of limits [1,16]\",U),2)elseif U==-1 then U=4 end else U=a5(ab,0)end;if U<1 then error(\"invalid next option for option 'X'\",2)end;if a9%math.min(U,X)~=0 and X>1 then for ac=1,X do if a9%math.min(U,X)==0 then break end;a9=a9+1 end end elseif ab~=' 'then error(string.format(\"invalid format option '%s'\",ab),2)end end;a7[#a7+1]=a9;return table.unpack(a7)end end;function panic(ag)term.setBackgroundColor(32768)term.setTextColor(16384)term.setCursorBlink(false)local r,s=term.getCursorPos()r=1;local ah,ai=term.getSize()ag=\"panic: \"..(ag or\"unknown\")for aj in ag:gmatch\"%S+\"do if r+#aj>=ah then r,s=1,s+1;if s>ai then term.scroll(1)s=s-1 end end;term.setCursorPos(r,s)if r==1 then term.clearLine()end;term.write(aj..\" \")r=r+#aj+1 end;r,s=1,s+1;if s>ai then term.scroll(1)s=s-1 end;if debug then local ak=debug.traceback(nil,2)for al in ak:gmatch\"[^\\n]+\"do term.setCursorPos(1,s)term.write(al)s=s+1;if s>ai then term.scroll(1)s=s-1 end end end;term.setCursorPos(1,s)term.setTextColor(2)term.write(\"panic: We are hanging here...\")mainThread=nil;if _HEADLESS then os.shutdown(1)end;while true do coroutine.yield()end end;function do_syscall(am,...)local w=table.pack(coroutine.yield(\"syscall\",am,...))if w[1]then return table.unpack(w,2,w.n)else error(w[2],3)end end;function deepcopy(an)if type(an)==\"table\"then local a7=setmetatable({},deepcopy(getmetatable(an)))for j,k in pairs(an)do a7[deepcopy(j)]=deepcopy(k)end;return a7 else return an end end;function split(a2,ao)local A={}for ap in a2:gmatch(\"[^\"..(ao or\"%s\")..\"]+\")do A[#A+1]=ap end;return A end;local aq=pcall(os.epoch,\"nano\")and function()return os.epoch\"nano\"/1000000 end or(ccemux and function()return ccemux.nanoTime()/1000000 end or function()return os.epoch\"utc\"end)local ar;function getCurrentThread()return ar end;local as={n=0}function executeThread(process,at,au,av,aw)local args;if at.paused then return false,aw end;if at.status==\"starting\"then args=at.args elseif at.status==\"syscall\"then args=table.pack(table.unpack(at.syscall_return,3,at.syscall_return.n))elseif at.status==\"preempt\"then args=as elseif at.status==\"suspended\"then args={au[1],{}}for j,k in pairs(au[2])do args[2][j]=k end elseif at.status==\"paused\"then return false,aw end;if at.status~=\"dead\"and(not at.filter or at.filter(process,at,au))then local ax=av;av=false;at.filter=nil;local ay;if at.yielding then ay={n=at.syscall_return.n,true,\"syscall\",at.yielding,table.unpack(at.syscall_return,4,at.syscall_return.n)}at.yielding=nil else ar=at;local az=globalMetatables;globalMetatables=process.globalMetatables;updateGlobalMetatables()local aA=aq()ay=table.pack(coroutine.resume(at.coro,table.unpack(args,1,args.n)))process.cputime=process.cputime+(aq()-aA)/1000;globalMetatables=az;updateGlobalMetatables()ar=nil end;if ay[2]==\"secure_syscall\"then ay[2]=\"syscall\"elseif ay[2]==\"secure_event\"then ay[2]=nil end;if ay[2]==\"syscall\"then at.status=\"syscall\"local aB=aw;aw=false;if ay[3]and syscalls[ay[3]]then local aA=aq()at.syscall_return=table.pack(coroutine.resume(at.syscall,ay[3],process,at,table.unpack(ay,4,ay.n)))process.systime=process.systime+(aq()-aA)/1000;if at.syscall_return[2]==kSyscallComplete then if not at.syscall_return[3]and type(at.syscall_return[4])==\"string\"then syslog.log({level=\"debug\",category=\"Syscall Failure\",process=0,module=ay[3]},at.syscall_return[4])at.syscall_return[4]=at.syscall_return[4]:gsub(\"kernel:%d+: \",\"\")end;if at.syscall_return[4]==kSyscallYield then at.yielding=at.syscall_return[5]aw=aB end else at.yielding=ay[3]end else at.syscall_return={false,\"No such syscall\",n=2}end elseif ay[2]==\"preempt\"then at.status=\"preempt\"aw=false elseif coroutine.status(at.coro)==\"dead\"then at.status=\"dead\"at.return_value=ay[2]if ay[1]then process.lastReturnValue={pid=process.id,thread=at.id,value=ay[2],n=ay.n-1,table.unpack(ay,2,ay.n)}else process.lastReturnValue={pid=process.id,thread=at.id,error=ay[2],traceback=debug.traceback(at.coro)}end;if not ay[1]then at.did_error=true;syslog.log({level=_G.args.traceback and\"error\"or\"debug\",process=process.id,thread=at.id,category=\"Application Error\",traceback=true},debug.traceback(at.coro,ay[2]))if ay[2]and process.stderr and process.stderr.isTTY then terminal.write(process.stderr,ay[2]..\"\\n\")end end;process.threads[at.id]=nil;av=ax else at.status=\"suspended\"aw=aw and#process.eventQueue==0 end end;return av,aw end;mainThread=coroutine.running()function userModeCallback(process,aC,...)local aD=syscalls.newthread(process,nil,aC,...)local at=process.threads[aD]at.name=\"<user mode callback>\"while at.status~=\"dead\"do if coroutine.running()==mainThread then error(\"userModeCallback not called from a yieldable context\",2)end;coroutine.yield()end;return not at.did_error,at.return_value end;function make_ENV(e)if type(e)~=\"table\"or _VERSION~=\"Lua 5.1\"then return e end;repeat local aE=getmetatable(e)if aE and aE.__env then e=aE.__env end until not aE or not aE.__env;local A=setmetatable({},{__index=function(self,aF)if self==e then e=getmetatable(self).__env end;if aF==\"_ENV\"then return e else return e[aF]end end,__newindex=function(self,aF,aG)if self==e then e=getmetatable(self).__env end;if aF==\"_ENV\"then e=aG else e[aF]=aG end end,__pairs=function(self)if self==e then e=getmetatable(self).__env end;return next,e end,__len=function(self)if self==e then e=getmetatable(self).__env end;return#e end,__env=e})return A end;for B,k in ipairs({...})do local aH,aI=k:match(\"^([^=]+)=(.+)$\")if aH and aI then if type(args[aH])==\"boolean\"then args[aH]=aI:lower()==\"true\"or aI==\"1\"elseif type(args[aH])==\"number\"then args[aH]=tonumber(aI)else args[aH]=aI end elseif aH==\"silent\"then args.loglevel=5 elseif aH==\"quiet\"then args.loglevel=3 end end;if _HEADLESS then args.headless=true end;local function aJ(aK)local w;if _CC_VERSION then w=aK<=_CC_VERSION elseif not _HOST then w=aK<=os.version():gsub(\"CraftOS \",\"\")elseif _HOST:match(\"ComputerCraft 1%.1%d+\")~=aK:match(\"1%.1%d+\")then aK=aK:gsub(\"(1%.)([02-9])\",\"%10%2\")local aL=_HOST:gsub(\"(ComputerCraft 1%.)([02-9])\",\"%10%2\")w=aK<=aL:match(\"ComputerCraft ([0-9%.]+)\")else w=aK<=_HOST:match(\"ComputerCraft ([0-9%.]+)\")end;return w end;if not aJ\"1.87.0\"then panic(\"Phoenix requires ComputerCraft 1.87.0 or later. Please upgrade your version of ComputerCraft.\")end;if jit and args.preemptive then panic(\"Phoenix does not support preemption when running under LuaJIT. Please set preemptive to false in the kernel arguments.\")end;if not debug and args.preemptive then panic(\"Phoenix does not support preemption without the debug API. Please set preemptive to false in the kernel arguments.\")end;if args.preemptive then PHOENIX_BUILD=PHOENIX_BUILD..\" PREEMPT\"end;if not getfenv then if not debug then panic(\"Phoenix requires the debug API when running under Lua 5.2 and later.\")end;function getfenv(i)local x=1;while true do local o,aG=debug.getupvalue(i,x)if o==\"_ENV\"then return aG elseif not o then break end;x=x+1 end end;function setfenv(i,e)local x=1;while true do local o=debug.getupvalue(i,x)if o==\"_ENV\"then debug.upvaluejoin(i,x,function()return e end,1)break elseif not o then break end;x=x+1 end;return i end end;globalMetatables={[\"nil\"]={},[\"boolean\"]={},[\"number\"]={},[\"string\"]={__index=string},[\"function\"]={},[\"thread\"]={__index=coroutine,__call=coroutine.resume},[\"userdata\"]={}}local aM,aN=debug.getmetatable,debug.setmetatable;function updateGlobalMetatables()aN(nil,globalMetatables[\"nil\"])aN(false,globalMetatables[\"boolean\"])aN(0,globalMetatables[\"number\"])aN(\"\",globalMetatables[\"string\"])aN(assert,globalMetatables[\"function\"])aN(coroutine.running(),globalMetatables[\"thread\"])if debug.upvalueid then aN(debug.upvalueid(executeThread,1),globalMetatables[\"userdata\"])end end;local type=type;function debug.getmetatable(aG)if type(aG)==\"table\"then return aM(aG)else return globalMetatables[type(aG)]end end;function debug.setmetatable(aG,an)expect(2,an,\"table\")if type(aG)==\"table\"then return aN(aG,an)else globalMetatables[type(aG)]=an end end;do local aO;local aP,aQ,aR,aS,aT,aU,aV,aW,aX=getfenv,setfenv,debug.getfenv,debug.getlocal,debug.getupvalue,debug.setfenv,debug.setlocal,debug.setupvalue,debug.upvaluejoin;local error,aY,aZ,select,setmetatable,type,tonumber=error,debug.getinfo,coroutine.running,select,setmetatable,type,tonumber;local a_;local function keys(A,k,...)if k then A[k]=true end;if select(\"#\",...)>0 then return keys(A,...)else return A end end;local function b0(k,...)if select(\"#\",...)>0 then return a_[k or\"\"]or k,b0(...)else return a_[k or\"\"]or k end end;local function b1(t)t=bit32.band(tonumber(t),0xFFFFFFFF)if bit32.btest(t,0x80000000)then t=t-0x100000000 end;return t end;function debug.getinfo(at,aC,b2)if type(at)~=\"thread\"then b2,aC,at=aC,at,aZ()end;local a7;if tonumber(aC)then a7=aY(at,aC+1,b2)else a7=aY(at,aC,b2)end;if a7 and a7.func then a7.func=a_[a7.func]or a7.func end;return a7 end;function debug.getlocal(at,b3,b4)if b4==nil then b4,b3,at=b3,at,aZ()end;local j,k;if type(b3)==\"function\"then local b5=aY(2,\"f\")if aO[b3]and not(b5 and aO[b3][b5.func])then return nil end;j,k=b0(aS(b3,b4))elseif tonumber(b3)then local info=aY(at,b3+1,\"f\")local b5=aY(2,\"f\")if info and aO[info.func]and not(b5 and aO[info.func][b5.func])then return nil end;j,k=b0(aS(at,b3+1,b4))else j,k=b0(aS(at,b3,b4))end;return j,k end;function debug.getupvalue(aC,b6)if type(aC)==\"function\"then local b5=aY(2,\"f\")if aO[aC]and not(b5 and aO[aC][b5.func])then return nil end end;local j,k=b0(aT(aC,b6))return j,k end;function debug.setlocal(at,b3,b4,aI)if b4==nil then b4,b3,at=b3,at,aZ()end;if tonumber(b3)then local info=aY(at,b3+1,\"f\")local b5=aY(2,\"f\")if info and aO[info.func]and not(b5 and aO[info.func][b5.func])then error(\"attempt to set local of protected function\",2)end;aV(at,b3+1,b4,aI)else aV(at,b3,b4,aI)end end;function debug.setupvalue(aC,b6,aI)if type(aC)==\"function\"then local b5=aY(2,\"f\")if aO[aC]and not(b5 and aO[aC][b5.func])then error(\"attempt to set upvalue of protected function\",2)end end;aW(aC,b6,aI)end;function _G.getfenv(f)local k;if f==nil then k=aP(2)elseif tonumber(f)and b1(f)>0 then local info=aY(f+1,\"f\")local b5=aY(2,\"f\")if info and aO[info.func]and not(b5 and aO[info.func][b5.func])then return nil end;k=aP(f+1)elseif type(f)==\"function\"then local b5=aY(2,\"f\")if aO[f]and not(b5 and aO[f][b5.func])then return nil end;k=aP(f)else k=aP(f)end;return k end;function _G.setfenv(f,an)if tonumber(f)and b1(f)>0 then local info=aY(f+1,\"f\")local b5=aY(2,\"f\")if info and aO[info.func]and not(b5 and aO[info.func][b5.func])then error(\"attempt to set environment of protected function\",2)end;aQ(f+1,an)elseif type(f)==\"function\"then local b5=aY(2,\"f\")if aO[f]and not(b5 and aO[f][b5.func])then error(\"attempt to set environment of protected function\",2)end end;aQ(f,an)end;if aR then function debug.getfenv(b7)if type(b7)==\"function\"then local b5=aY(2,\"f\")if aO[b7]and not(b5 and aO[b7][b5.func])then return nil end end;local k=aR(b7)return k end;function debug.setfenv(b7,an)if type(b7)==\"function\"then local b5=aY(2,\"f\")if aO[b7]and not(b5 and aO[b7][b5.func])then error(\"attempt to set environment of protected function\",2)end end;aU(b7,an)end end;if aX then function debug.upvaluejoin(b8,b9,ba,bb)if type(b8)==\"function\"and type(ba)==\"function\"then local b5=aY(2,\"f\")if aO[b8]and not(b5 and aO[b8][b5.func])then error(\"attempt to get upvalue of protected function\",2)end;if aO[ba]and not(b5 and aO[ba][b5.func])then error(\"attempt to set upvalue of protected function\",2)end end;aX(b8,b9,ba,bb)end end;function debug.protect(aC)if type(aC)~=\"function\"then error(\"bad argument #1 (expected function, got \"..type(aC)..\")\",2)end;if aO[aC]then error(\"attempt to protect a protected function\",2)end;aO[aC]=keys(setmetatable({},{__mode=\"k\"}))end;a_={[aS]=debug.getlocal,[aV]=debug.setlocal,[aT]=debug.getupvalue,[aW]=debug.setupvalue,[aY]=debug.getinfo,[b0]=function()end}if debug.upvaluejoin then a_[aX]=debug.upvaluejoin end;if debug.getfenv then a_[aR]=debug.getfenv end;if debug.setfenv then a_[aU]=debug.setfenv end;if _G.getfenv then a_[aP]=_G.getfenv end;if _G.setfenv then a_[aQ]=_G.setfenv end;aO=keys(setmetatable({},{__mode=\"k\"}),getfenv,setfenv,debug.getfenv,debug.setfenv,debug.getlocal,debug.setlocal,debug.getupvalue,debug.setupvalue,debug.upvaluejoin,debug.getinfo,b0,debug.protect)for j,k in pairs(aO)do aO[j]={}end end;mounts={}fifos={}fsevents={}filesystems={craftos={meta={meta={type=\"directory\",owner=\"root\",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}},metapath=\"/meta.ltn\",lastDispatch=0},tmpfs={},drivefs={},tablefs={},bind={}}local function bc(process,g)local G=fs.combine(process.root,g:sub(1,1)==\"/\"and\"\"or process.dir,g)if\"/\"..G..\"/\"~=process.root and G:find(process.root:sub(2),1,true)~=1 then error(g..\": No such file or directory\",4)end;return G end;local function bd(process,g,be)local bf=split(bc(process,g),\"/\\\\\")if#bf==0 then if be then return mounts[\"\"],g,\"\"end;return mounts[\"\"][1],g,\"\"end;local bg;for j in pairs(mounts)do local bh=true;for x,ab in ipairs(split(j,\"/\\\\\"))do if bf[x]~=ab then bh=false;break end end;if bh and(not bg or#j>#bg)then bg=j end end;if not bg then panic(\"Could not find mount for path \"..g..\". Where is root?\")end;local bi=split(bg,\"/\\\\\")local G=#bf>=#bi+1 and fs.combine(table.unpack(bf,#bi+1,#bf))or\"\"local mounts=mounts[bg]if be then return mounts,G,bg end;local bj=mounts[1]if#mounts>1 then for B,k in ipairs(mounts)do local bh,w=pcall(k.stat,k,process,G,true)if bh and w then bj=k;break end end end;return bj,G,bg end;function filesystem.readhandle(process,bk,bl)if bk==\"\"then local bm=false;local function bn()if bm then return nil end;bm=true;return\"\"end;local bo={readLine=bn,readAll=bn,read=bn,close=function()end}if bl then function bo.seek()bm=false end;function bo.read(t)if not t then return nil end;return bn()end end;return bo end;local a9=1;local bp=false;local A={readLine=function(bq)if bp then error(\"attempt to use a closed file\",2)end;if a9>#bk then return nil end;local br;br,a9=bk:match(\"([^\\n]*\"..(bq and\"\\n?)\"or\")\\n?\")..\"()\",a9)return br end,readAll=function()if bp then error(\"attempt to use a closed file\",2)end;if a9>#bk then return nil end;local br=bk:sub(a9)a9=#br+1;return br end,read=function(t)if bp then error(\"attempt to use a closed file\",2)end;if t~=nil and type(t)~=\"number\"then error(\"bad argument #1 (expected number, got \"..type(t)..\")\",2)end;t=t or 1;if a9>#bk then return nil end;local br=bk:sub(a9,a9+t-1)a9=a9+t;return br end,close=function()if bp then error(\"attempt to use a closed file\",2)end;bp=true end}if bl then A.read=function(t)if bp then error(\"attempt to use a closed file\",2)end;if t~=nil and type(t)~=\"number\"then error(\"bad argument #1 (expected number, got \"..type(t)..\")\",2)end;if a9>#bk then return nil end;if t then local br=bk:sub(a9,a9+t-1)a9=a9+t;return br else local br=bk:byte(a9)a9=a9+1;return br end end;A.seek=function(bs,W)if bs~=nil and type(bs)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(bs)..\")\",2)end;if W~=nil and type(W)~=\"number\"then error(\"bad argument #2 (expected number, got \"..type(W)..\")\",2)end;bs=bs or\"cur\"W=W or 0;if bp then error(\"attempt to use closed file\",2)end;if bs==\"set\"then a9=W+1 elseif bs==\"cur\"then a9=a9+W elseif bs==\"end\"then a9=math.max(#bk-W,1)else error(\"Invalid whence\",2)end;return a9-1 end else bk=bk:gsub(\"[\\x80-\\xFF]+\",function(bt)local bu=\"\"if not pcall(function()for B,bv in utf8.codes(bt)do bu=bu..(bv<256 and string.char(bv)or\"?\")end end)then return bt end;return bu end)end;for B,k in pairs(A)do setfenv(k,process.env)debug.protect(k)end;return setmetatable(A,{__name=\"file\"})end;function filesystem.writehandle(process,bw,bl)setfenv(bw,process.env)local function bx(A)for B,k in pairs(A)do setfenv(k,process.env)debug.protect(k)end;return setmetatable(A,{__name=\"file\"})end;local bp=false;if bl then local a9=1;local by=\"\"local bz=\"\"return bx{write=function(br)if bp then error(\"attempt to use a closed file\",2)end;if type(br)==\"number\"then by,a9=by:sub(1,a9-1)..string.char(br)..by:sub(a9+1),a9+1;if bz then bz=bz..string.char(br)end elseif type(br)==\"string\"then by,a9=by:sub(1,a9-1)..br..by:sub(a9+#br),a9+#br;if bz then bz=bz..br end else error(\"bad argument #1 (expected string or number, got \"..type(br)..\")\",2)end end,writeLine=function(br)if bp then error(\"attempt to use a closed file\",2)end;if type(br)==\"number\"then by,a9=by:sub(1,a9-1)..string.char(br)..\"\\n\"..by:sub(a9+2),a9+2;if bz then bz=bz..string.char(br)..\"\\n\"end elseif type(br)==\"string\"then by,a9=by:sub(1,a9-1)..br..\"\\n\"..by:sub(a9+#br+1),a9+#br+1;if bz then bz=bz..br..\"\\n\"end else error(\"bad argument #1 (expected string or number, got \"..type(br)..\")\",2)end end,seek=function(bs,W)if bs~=nil and type(bs)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(bs)..\")\",2)end;if W~=nil and type(W)~=\"number\"then error(\"bad argument #2 (expected number, got \"..type(W)..\")\",2)end;bs=bs or\"cur\"W=W or 0;if bp then error(\"attempt to use closed file\",2)end;local bA=a9;if bs==\"set\"then a9=W+1 elseif bs==\"cur\"then a9=a9+W elseif bs==\"end\"then a9=math.max(#by-W,1)else error(\"Invalid whence\",2)end;if bA~=a9 then bz=nil end;return a9-1 end,flush=function()if bp then error(\"attempt to use a closed file\",2)end;if bz then bw(bz,false)else bw(by,true)end;bz=\"\"end,close=function()if bp then error(\"attempt to use a closed file\",2)end;bp=true;if bz then bw(bz,false)else bw(by,true)end;bz=\"\"end}else local by=\"\"return bx{write=function(br)if bp then error(\"attempt to use a closed file\",2)end;by=by..tostring(br)end,writeLine=function(br)if bp then error(\"attempt to use a closed file\",2)end;by=by..tostring(br)..\"\\n\"end,flush=function()if bp then error(\"attempt to use a closed file\",2)end;bw(by,false)by=\"\"end,close=function()if bp then error(\"attempt to use a closed file\",2)end;bw(by,false)by=\"\"bp=true end}end end;function filesystem.fifohandle(process,bB,p)local bp=false;local function bx(A)for B,k in pairs(A)do setfenv(k,process.env)debug.protect(k)end;return setmetatable(A,{__name=\"file\"})end;if p==\"r\"then return bx{readLine=function(bq)if bp then error(\"attempt to use a closed file\",2)end;if#bB.data==0 then return nil end;local br;br,bB.data=bB.data:match(\"([^\\n]*\"..(bq and\"\\n?)\"or\")\\n?\")..\"(.*)\")return br end,readAll=function()if bp then error(\"attempt to use a closed file\",2)end;if#bB.data==0 then return nil end;local br=bB.data;bB.data=\"\"return br end,read=function(t)if bp then error(\"attempt to use a closed file\",2)end;if t~=nil and type(t)~=\"number\"then error(\"bad argument #1 (expected number, got \"..type(t)..\")\",2)end;t=t or 1;if#bB.data==0 then return nil end;local br=bB.data:sub(1,t)bB.data=bB.data:sub(t+1)return br end,close=function()if bp then error(\"attempt to use a closed file\",2)end;bp=true end}elseif p==\"w\"or p==\"a\"then local by=bB.data;return bx{write=function(br)if bp then error(\"attempt to use a closed file\",2)end;by=by..tostring(br)end,writeLine=function(br)if bp then error(\"attempt to use a closed file\",2)end;by=by..tostring(br)..\"\\n\"end,flush=function()if bp then error(\"attempt to use a closed file\",2)end;bB.data=by end,close=function()if bp then error(\"attempt to use a closed file\",2)end;bB.data=by;bp=true end}elseif p==\"rb\"then return bx{readLine=function(bq)if bp then error(\"attempt to use a closed file\",2)end;if#bB.data==0 then return nil end;local br;br,bB.data=bB.data:match(\"([^\\n]*\"..(bq and\"\\n?)\"or\")\\n?\")..\"(.*)\")return br end,readAll=function()if bp then error(\"attempt to use a closed file\",2)end;if#bB.data==0 then return nil end;local br=bB.data;bB.data=\"\"return br end,read=function(t)if bp then error(\"attempt to use a closed file\",2)end;if t~=nil and type(t)~=\"number\"then error(\"bad argument #1 (expected number, got \"..type(t)..\")\",2)end;if#bB.data==0 then return nil end;if t then local br=bB.data:sub(1,t)bB.data=bB.data:sub(t+1)return br else local br=bB.data:byte()bB.data=bB.data:sub(2)return br end end,seek=function(bs,W)if bs~=nil and type(bs)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(bs)..\")\",2)end;if W~=nil and type(W)~=\"number\"then error(\"bad argument #2 (expected number, got \"..type(W)..\")\",2)end;if bp then error(\"attempt to use closed file\",2)end;return 0 end,close=function()if bp then error(\"attempt to use a closed file\",2)end;bp=true end}elseif p==\"wb\"or p==\"ab\"then local by=bB.data;return bx{write=function(br)if bp then error(\"attempt to use a closed file\",2)end;if type(br)==\"number\"then by=by..string.char(br)elseif type(br)==\"string\"then by=by..br else error(\"bad argument #1 (expected string or number, got \"..type(br)..\")\",2)end end,writeLine=function(br)if bp then error(\"attempt to use a closed file\",2)end;if type(br)==\"number\"then by=by..string.char(br)..\"\\n\"elseif type(br)==\"string\"then by=by..br..\"\\n\"else error(\"bad argument #1 (expected string or number, got \"..type(br)..\")\",2)end end,seek=function(bs,W)if bs~=nil and type(bs)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(bs)..\")\",2)end;if W~=nil and type(W)~=\"number\"then error(\"bad argument #2 (expected number, got \"..type(W)..\")\",2)end;if bp then error(\"attempt to use closed file\",2)end;return#bB.data+#by end,flush=function()if bp then error(\"attempt to use a closed file\",2)end;bB.data=by end,close=function()if bp then error(\"attempt to use a closed file\",2)end;bB.data=by;bp=true end}else return nil,\"Invalid mode\"end end;filesystem.openfifo=filesystem.fifohandle;do local a=fs.open(\"/meta.ltn\",\"r\")if a then filesystems.craftos.meta=unserialize(a.readAll())or filesystems.craftos.meta;filesystems.craftos.lastDispatch=os.epoch\"utc\"a.close()end end;shutdownHooks[#shutdownHooks+1]=function()syslog.log(\"Syncing filesystem\")local a=fs.open(filesystems.craftos.metapath,\"w\")if a then a.write(serialize(filesystems.craftos.meta,{compact=true}))a.close()end end;if args.fsmeta then local a=fs.open(args.fsmeta,\"r\")if a then local bC=unserialize(a.readAll())a.close()if bC then local function bD(bE,bF)for j,k in pairs(bE)do if bF[j]and type(bF[j])==\"table\"and type(k)==\"table\"then bD(k,bF[j])else bF[j]=k end end end;bD(bC,filesystems.craftos.meta)end end end;function filesystems.craftos:getmeta(bG,g,bH)local bI={}local A=self.meta;local bi=split(g,\"/\\\\\")for x,G in ipairs(bi)do if G==\"..\"then A=table.remove(bI)if not A then return nil end elseif not G:match\"^%.*$\"then if not A then return nil elseif A.meta.type~=\"directory\"then error(\"Not a directory\",2)elseif A.meta.permissions[bG]then if not A.meta.permissions[bG].execute then error(\"Permission denied\",2)end elseif not A.meta.worldPermissions.execute then error(\"Permission denied\",2)end;bI[#bI+1]=A;A=A.contents[G]if A and A.meta.type==\"link\"and not bH then local bJ=filesystem.combine(A.meta.link,table.unpack(bi,x+1))if fs.combine(bJ)==fs.combine(g)then error(\"Loop in link\",2)end;error{link=true,path=bJ,orig=g}end end end;return A and A.meta end;function filesystems.craftos:setmeta(bG,g,bC,bH)local bI={}local A=self.meta;local o;local bi=split(g,\"/\\\\\")for x,G in ipairs(bi)do if G==\"..\"then A=table.remove(bI)if not A then error(\"Not a directory\",2)end elseif not G:match\"^%.*$\"then if A.meta.type~=\"directory\"then error(\"Not a directory\",2)elseif A.meta.permissions[bG]then if not A.meta.permissions[bG].execute then error(\"Permission denied\",2)end elseif not A.meta.worldPermissions.execute then error(\"Permission denied\",2)end;if not A.contents[G]then A.contents[G]={meta={type=\"directory\",owner=A.meta.owner or\"root\",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}}end;bI[#bI+1]=A;A=A.contents[G]o=G;if A and A.meta.type==\"link\"and not bH then local bJ=filesystem.combine(A.meta.link,table.unpack(bi,x+1))if fs.combine(bJ)==fs.combine(g)then error(\"Loop in link\",2)end;error{link=true,path=bJ,orig=g}end end end;if bC~=nil then A.meta={type=bC.type,owner=bC.owner,permissions=deepcopy(bC.permissions),worldPermissions=deepcopy(bC.worldPermissions),setuser=bC.setuser,link=bC.link}if bC.type~=\"directory\"then A.contents=nil end else bI[#bI].contents[o]=nil end;if os.epoch\"utc\"-self.lastDispatch>1000 then local a=assert(fs.open(self.metapath,\"w\"))a.write(serialize(self.meta,{compact=true}))a.close()self.lastDispatch=os.epoch\"utc\"end end;function filesystems.craftos:new(process,g,bK)expect.field(bK,\"ro\",\"boolean\",\"nil\")if process.user~=\"root\"then error(\"Could not mount \"..g..\": Permission denied\",3)elseif not fs.isDir(g)then error(\"Could not mount \"..g..\": No such directory\",3)end;return setmetatable({path=g,readOnly=bK.ro},{__index=self})end;function filesystems.craftos:open(process,g,p)local bh,bL=pcall(self.stat,self,process,g)if not bh then if type(bL)==\"table\"then error(bL)end;return nil,bL elseif not bL then if p:sub(1,1)==\"w\"or p:sub(1,1)==\"a\"then if self.readOnly then return nil,\"Read-only filesystem\"end;local bM,bN=pcall(self.stat,self,process,fs.getDir(g))if not bM or not bN then if type(bN)==\"table\"then error(bN)end;local bO,q=pcall(self.mkdir,self,process,fs.getDir(g))if not bO then if type(q)==\"table\"then error(q)end;return nil,q:gsub(\"kernel:%d: \",\"\")end;bN=self:stat(process,fs.getDir(g))if not bN then return nil,\"Could not stat \"..fs.getDir(g)end end;if process.user~=\"root\"then local bP=bN.permissions[process.user]or bN.worldPermissions;if not bP.write then return nil,\"Permission denied\"end end;local bC={type=\"file\",owner=process.user,permissions=deepcopy(bN.permissions),worldPermissions=deepcopy(bN.worldPermissions),setuser=false}if bN.owner then local A=bC.permissions[bN.owner]bC.permissions[bN.owner]=nil;bC.permissions[process.user]=A end;self:setmeta(process.user,fs.combine(self.path,g),bC)local a,q=fs.open(fs.combine(self.path,g),p)if not a then return a,q end;return setmetatable(a,{__name=\"file\"})else return nil,\"File not found\"end elseif bL.type==\"directory\"then return nil,\"Is a directory\"end;local bP=bL.permissions[process.user]or bL.worldPermissions;if process.user~=\"root\"and(p:sub(1,1)==\"r\"and not bP.read or(p:sub(1,1)==\"w\"or p:sub(1,1)==\"a\")and not bP.write)then return nil,\"Permission denied\"end;if bL.type==\"fifo\"then local bC=self:getmeta(process.user,fs.combine(self.path,g))local bQ=fifos[bC]if not bQ then bQ={data=\"\"}fifos[bC]=bQ end;return filesystem.fifohandle(process,bQ,p)end;local a,q=fs.open(fs.combine(self.path,g),p)if not a then return nil,q end;return setmetatable(a,{__name=\"file\"})end;function filesystems.craftos:list(process,g)local bL=self:stat(process,g)if not bL or bL.type~=\"directory\"then error(g..\": Not a directory\",2)end;if process.user~=\"root\"then local bP=bL.permissions[process.user]or bL.worldPermissions;if not bP.read then error(g..\": Permission denied\",2)end end;return fs.list(fs.combine(self.path,g))end;function filesystems.craftos:stat(process,g,bH)local G=fs.combine(self.path,g)if G:find(self.path:gsub(\"^/\",\"\"):gsub(\"/$\",\"\"),1,false)~=1 then return nil end;local bh,bR=pcall(fs.attributes,G)if not bh or not bR then return nil end;bR.type=bR.isDir and\"directory\"or\"file\"bR.special={}bR.isDir=nil;if not bR.modified then bR.modified=bR.modification end;bR.modification=nil;bR.capacity=fs.getCapacity(G)or 0;bR.freeSpace=fs.getFreeSpace(G)local bS=bR.isReadOnly;bR.isReadOnly=nil;local bC=self:getmeta(process.user,fs.combine(self.path,g),bH)if bC then bR.owner=bC.owner;bR.permissions=deepcopy(bC.permissions)bR.worldPermissions=deepcopy(bC.worldPermissions)bR.type=bC.type or bR.type;bR.setuser=bC.setuser;bR.link=bC.link else bR.owner=\"root\"bR.permissions={root={read=true,write=true,execute=true}}bR.worldPermissions={read=true,write=false,execute=true}bR.setuser=false end;if bS then bR.worldPermissions.write=false;for B,k in pairs(bR.permissions)do k.write=false end end;return bR end;function filesystems.craftos:remove(process,g)if self.readOnly then error(g..\": Read-only filesystem\",2)end;local bL=self:stat(process,g,true)if not bL then return end;local function bT(G)local bt=self:stat(process,G,true)local bP=bt.permissions[process.user]or bt.worldPermissions;if process.user~=\"root\"and not bP.write then error(G..\": Permission denied\",3)end;if bt.type==\"directory\"then if process.user~=\"root\"and not bP.read then error(G..\": Permission denied\",3)end;for B,k in ipairs(fs.list(fs.combine(self.path,G)))do bT(fs.combine(G,k))end end end;bT(g)fs.delete(fs.combine(self.path,g))self:setmeta(process.user,fs.combine(self.path,g),nil,true)end;function filesystems.craftos:rename(process,bU,bV)if self.readOnly then error(\"Read-only filesystem\",2)end;local bW=self:stat(process,bU,true)local bX=self:stat(process,bV,true)if not bW then error(bU..\": No such file or directory\",2)elseif bX then error(bV..\": \"..bX.type:gsub(\"%w\",string.upper,1)..\" already exists\",2)end;bX=self:stat(process,fs.getDir(bV))if not bX then self:mkdir(process,fs.getDir(bV))bX=self:stat(process,fs.getDir(bV))end;if process.user~=\"root\"then local bP=bX.permissions[process.user]or bX.worldPermissions;if not bP.write then error(bV..\": Permission denied\",2)end end;fs.move(fs.combine(self.path,bU),fs.combine(self.path,bV))self:setmeta(process.user,fs.combine(self.path,bV),self:getmeta(process.user,fs.combine(self.path,bU),true),true)self:setmeta(process.user,fs.combine(self.path,bU),nil,true)end;function filesystems.craftos:mkdir(process,g)if self.readOnly then error(g..\": Read-only filesystem\",2)end;local bL=self:stat(process,g)if bL then if bL.type==\"directory\"then return else error(g..\": File already exists\",2)end end;local bi=split(g,\"/\\\\\")local x=#bi;repeat x=x-1;bL=self:stat(process,table.concat(bi,\"/\",1,x))if bL then if bL.type==\"directory\"then break else error(g..\": File already exists\",2)end end until bL or x<=0;if not bL then if g:match\"^/\"then bL=assert(self:stat(process,\"/\"))else bL=assert(filesystem.stat(process,process.dir))end end;if process.user~=\"root\"then local bP=bL.permissions[process.user]or bL.worldPermissions;if not bP.write then error(g..\": Permission denied\",2)end end;local bC={type=\"directory\",owner=process.user,permissions=deepcopy(bL.permissions),worldPermissions=deepcopy(bL.worldPermissions)}if bL.owner then local A=bC.permissions[bL.owner]bC.permissions[bL.owner]=nil;bC.permissions[process.user]=A end;x=x+1;while x<=#bi do self:setmeta(process.user,fs.combine(self.path,table.concat(bi,\"/\",1,x)),deepcopy(bC))x=x+1 end;fs.makeDir(fs.combine(self.path,g))end;function filesystems.craftos:link(process,g,bY)local bL=self:stat(process,g,true)if bL then error(g..\": File exists\",2)end;self:setmeta(process.user,fs.combine(self.path,g),nil,true)assert(self:open(process,g,\"w\")).close()local bC=self:getmeta(process.user,fs.combine(self.path,g),true)bC.type,bC.link=\"link\",bY;self:setmeta(process.user,fs.combine(self.path,g),bC,true)end;function filesystems.craftos:mkfifo(process,g)local bL=self:stat(process,g)if bL then error(g..\": File exists\",2)end;assert(self:open(process,g,\"w\")).close()local bC=self:getmeta(process.user,fs.combine(self.path,g),true)bC.type=\"fifo\"self:setmeta(process.user,fs.combine(self.path,g),bC,true)end;function filesystems.craftos:chmod(process,g,bG,p)if self.readOnly then error(g..\": Read-only filesystem\",2)end;local bL=self:stat(process,g,true)if not bL then error(g..\": No such file or directory\",2)end;if not bL.owner or process.user~=\"root\"and process.user~=bL.owner then error(g..\": Permission denied\",2)end;local bP;if bG==nil then bP=bL.worldPermissions else bP=bL.permissions[bG]if not bP then bP=deepcopy(bL.worldPermissions)bL.permissions[bG]=bP end end;if type(p)==\"string\"then if p:match\"^[%+%-=][rwxs]+$\"then local C=p:sub(1,1)local A={}for ab in p:gmatch(\"[rwxs]\")do if ab==\"r\"then A.read=true elseif ab==\"w\"then A.write=true elseif ab==\"s\"then A.setuser=true else A.execute=true end end;if C==\"+\"then if A.read then bP.read=true end;if A.write then bP.write=true end;if A.execute then bP.execute=true end;if A.setuser then bL.setuser=true end elseif C==\"-\"then if A.read then bP.read=false end;if A.write then bP.write=false end;if A.execute then bP.execute=false end;if A.setuser then bL.setuser=false end else bP.read=A.read or false;bP.write=A.write or false;bP.execute=A.execute or false;bL.setuser=A.setuser or false end else bP.read=p:sub(1,1)~=\"-\"bP.write=p:sub(2,2)~=\"-\"bP.execute=p:sub(3,3)~=\"-\"bL.setuser=p:sub(3,3)==\"s\"end elseif type(p)==\"number\"then bL.setuser=bit32.btest(p,8)bP.read=bit32.btest(p,4)bP.write=bit32.btest(p,2)bP.execute=bit32.btest(p,1)else if p.read~=nil then bP.read=p.read end;if p.write~=nil then bP.write=p.write end;if p.execute~=nil then bP.execute=p.execute end;if p.setuser~=nil then bL.setuser=p.setuser end end;self:setmeta(process.user,fs.combine(self.path,g),deepcopy(bL),true)end;function filesystems.craftos:chown(process,g,bZ)if self.readOnly then error(g..\": Read-only filesystem\",2)end;local bL=self:stat(process,g,true)if not bL then error(g..\": No such file or directory\",2)end;if not bL.owner or process.user~=\"root\"and process.user~=bL.owner then error(g..\": Permission denied\",2)end;bL.owner=bZ;bL.setuser=false;self:setmeta(process.user,fs.combine(self.path,g),deepcopy(bL),true)end;function filesystems.craftos:info()return\"craftos\",self.path,{ro=self.readOnly}end;function filesystems.tmpfs:getpath(bG,g,bH)local A=self;local bi=split(g,\"/\\\\\")for x,G in ipairs(bi)do if not A then return nil elseif A.type~=\"directory\"then error(\"Not a directory\",2)elseif A.permissions[bG]then if not A.permissions[bG].execute then error(\"Permission denied\",2)end elseif not A.worldPermissions.execute then error(\"Permission denied\",2)end;A=A.contents[G]if A and A.type==\"link\"and not(bH and x==#bi)then error{link=true,path=filesystem.combine(A.link,table.unpack(bi,x+1)),orig=g}end end;return A end;function filesystems.tmpfs:setpath(bG,g,bk,bH)local A=self;local M=split(g,\"/\\\\\")local b_=M[#M]M[#M]=nil;for x,G in ipairs(M)do if A.type~=\"directory\"then error(\"Not a directory\",2)elseif A.permissions[bG]then if not A.permissions[bG].execute then error(\"Permission denied\",2)end elseif not A.worldPermissions.execute then error(\"Permission denied\",2)end;if not A.contents[G]then A.contents[G]={type=\"directory\",owner=A.owner,permissions=deepcopy(A.permissions),worldPermissions=deepcopy(A.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\",contents={}}end;A=A.contents[G]if A and A.type==\"link\"then error{link=true,path=filesystem.combine(A.link,table.unpack(M,x+1)),orig=g}end end;if A.type~=\"directory\"then error(\"Not a directory\",2)elseif bG~=\"root\"then if A.permissions[bG]then if not A.permissions[bG].execute then error(\"Permission denied\",2)end elseif not A.worldPermissions.execute then error(\"Permission denied\",2)end end;if not bH and A.contents[b_]and A.contents[b_].type==\"link\"then error{link=true,path=A.contents[b_].link,orig=g}end;A.contents[b_]=bk end;function filesystems.tmpfs:new(process,bE,bK)return setmetatable({type=\"directory\",owner=process.user,permissions={[process.user]={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\",contents={}},{__index=self})end;function filesystems.tmpfs:_open_internal(process,g,p)local c0=os.epoch;local bk=self:getpath(process.user,g)if not bk then return nil,\"No such file\"end;if p==\"r\"or p==\"rb\"then return filesystem.readhandle(process,bk.data,p==\"rb\")elseif p==\"w\"or p==\"wb\"then bk.data=\"\"bk.modified=c0\"utc\"return filesystem.writehandle(process,function(by,c1)if c1 then bk.data=by else bk.data=bk.data..by end;bk.modified=c0\"utc\"if self.__flush then self:__flush()end end,p==\"wb\")elseif p==\"a\"or p==\"ab\"then local c2=bk.data;return filesystem.writehandle(process,function(by,c1)if c1 then bk.data=c2 ..by else bk.data=bk.data..by end;bk.modified=c0\"utc\"if self.__flush then self:__flush()end end,p==\"ab\")else return nil,\"Invalid mode\"end end;function filesystems.tmpfs:open(process,g,p)if self.readOnly and(p:sub(1,1)==\"w\"or p:sub(1,1)==\"a\")then return nil,\"Read-only filesystem\"end;local bh,bL=pcall(self.stat,self,process,g)if not bh then if type(bL)==\"table\"then error(bL)end;return nil,bL elseif not bL then if p:sub(1,1)==\"w\"or p:sub(1,1)==\"a\"then local bM,bN=pcall(self.stat,self,process,fs.getDir(g))if not bM or not bN then if type(bN)==\"table\"then error(bN)end;local bO,q=pcall(self.mkdir,self,process,fs.getDir(g))if not bO then if type(q)==\"table\"then error(q)end;return nil,q:gsub(\"kernel:%d: \",\"\")end;bN=self:stat(process,fs.getDir(g))end;if process.user~=\"root\"then local bP=bN.permissions[process.user]or bN.worldPermissions;if not bP.write then return nil,\"Permission denied\"end end;local bC={type=\"file\",owner=process.user,permissions=deepcopy(bN.permissions),worldPermissions=deepcopy(bN.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\",data=\"\"}local A=bC.permissions[bN.owner]bC.permissions[bN.owner]=nil;bC.permissions[process.user]=A;self:setpath(process.user,g,bC)return self:_open_internal(process,g,p)else return nil,\"File not found\"end elseif bL.type==\"directory\"then return nil,\"Is a directory\"end;if process.user~=\"root\"then local bP=bL.permissions[process.user]or bL.worldPermissions;if p:sub(1,1)==\"r\"and not bP.read or(p:sub(1,1)==\"w\"or p:sub(1,1)==\"a\")and not bP.write then return nil,\"Permission denied\"end end;if bL.type==\"fifo\"then local bC=self:getpath(process.user,g)local bQ=fifos[bC]if not bQ then bQ={data=\"\"}fifos[bC]=bQ end;return filesystem.fifohandle(process,bQ,p)end;return self:_open_internal(process,g,p)end;function filesystems.tmpfs:list(process,g)local bk=self:getpath(process.user,g)if not bk or bk.type~=\"directory\"then error(g..\": Not a directory\",2)end;if process.user~=\"root\"then local bP=bk.permissions[process.user]or bk.worldPermissions;if not bP.read then error(g..\": Permission denied\",2)end end;local a7={}for j in pairs(bk.contents)do a7[#a7+1]=j end;table.sort(a7)return a7 end;function filesystems.tmpfs:stat(process,g,bH)local bk=self:getpath(process.user,g,bH)if not bk then return nil end;return{size=bk.type==\"file\"and#bk.data or(bk.type==\"directory\"and#bk.contents or 0),type=bk.type,created=bk.created,modified=bk.modified,owner=bk.owner,permissions=deepcopy(bk.permissions),worldPermissions=deepcopy(bk.worldPermissions),setuser=bk.setuser,capacity=math.huge,freeSpace=math.huge,link=rawget(bk,\"link\"),special={}}end;function filesystems.tmpfs:remove(process,g)if self.readOnly then error(\"Read-only filesystem\",2)end;local c3=self:getpath(process.user,fs.getDir(g))local o=fs.getName(g)if not c3 or c3.type~=\"directory\"or not c3.contents[o]then return end;if process.user~=\"root\"and not(c3.permissions[process.user]or c3.worldPermissions).write then error(g..\": Permission denied\",2)end;local bk=c3.contents[o]if process.user~=\"root\"and not(bk.permissions[process.user]or bk.worldPermissions).write then error(g..\": Permission denied\",2)end;local function bT(bt)local bP=bt.permissions[process.user]or bt.worldPermissions;if process.user~=\"root\"and not bP.write then error(g..\": Permission denied\",3)end;if bt.type==\"directory\"then if process.user~=\"root\"and not bP.read then error(g..\": Permission denied\",3)end;for B,k in pairs(bt.contents)do bT(k)end end end;bT(bk)c3.contents[o]=nil;c3.modified=os.epoch\"utc\"end;function filesystems.tmpfs:rename(process,bU,bV)if self.readOnly then error(\"Read-only filesystem\",2)end;local c4=self:getpath(process.user,fs.getDir(bU))local c5=fs.getName(bU)if not c4 or c4.type~=\"directory\"or not c4.contents[c5]then error(bU..\": No such file or directory\",2)end;if process.user~=\"root\"and not(c4.permissions[process.user]or c4.worldPermissions).write then error(bU..\": Permission denied\",2)end;local c6=c4.contents[c5]if process.user~=\"root\"and not(c6.permissions[process.user]or c6.worldPermissions).write then error(bU..\": Permission denied\",2)end;local c7=self:getpath(process.user,fs.getDir(bV))local c8=fs.getName(bV)if not c7 or c7.type~=\"directory\"then error(bV..\": No such file or directory\",2)end;if process.user~=\"root\"and not(c7.permissions[process.user]or c7.worldPermissions).write then error(bV..\": Permission denied\",2)end;local c9=c7.contents[c8]if c9 then error(bV..\": File already exists\",2)end;c7.contents[c8],c4.contents[c5]=c6,nil;local ca=os.epoch\"utc\"c4.modified,c7.modified=ca,ca end;function filesystems.tmpfs:mkdir(process,g)if self.readOnly then error(\"Read-only filesystem\",2)end;local A=self;for B,G in ipairs(split(g,\"/\\\\\"))do local bP=A.permissions[process.user]or A.worldPermissions;if A.type~=\"directory\"then error(g..\": File exists\",2)elseif process.user~=\"root\"and not bP.execute then error(g..\": Permission denied\",2)end;if not A.contents[G]then if process.user~=\"root\"and not bP.write then error(g..\": Permission denied\",2)end;A.contents[G]={type=\"directory\",owner=A.owner,permissions=deepcopy(A.permissions),worldPermissions=deepcopy(A.worldPermissions),created=os.epoch\"utc\",modified=os.epoch\"utc\",contents={}}A.modified=os.epoch\"utc\"end;A=A.contents[G]end end;function filesystems.tmpfs:link(process,g,bY)if self.readOnly then error(\"Read-only filesystem\",2)end;local bL=self:stat(process,g)if bL then error(g..\": File exists\",2)end;local bM,bN=pcall(self.stat,self,process,fs.getDir(g))if not bM or not bN then if type(bN)==\"table\"then error(bN)end;local bO,q=pcall(self.mkdir,self,process,fs.getDir(g))if not bO then if type(q)==\"table\"then error(q)end;return nil,type(q)==\"string\"and q:gsub(\"kernel:%d: \",\"\")or q end;bN=self:stat(process,fs.getDir(g))end;self:setpath(process.user,g,{type=\"link\",owner=process.user,permissions=deepcopy(bN.permissions),worldPermissions=deepcopy(bN.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\",path=bY},true)end;function filesystems.tmpfs:mkfifo(process,g)if self.readOnly then error(\"Read-only filesystem\",2)end;local bL=self:stat(process,g)if bL then error(g..\": File exists\",2)end;local bM,bN=pcall(self.stat,self,process,fs.getDir(g))if not bM or not bN then if type(bN)==\"table\"then error(bN)end;local bO,q=pcall(self.mkdir,self,process,fs.getDir(g))if not bO then if type(q)==\"table\"then error(q)end;return nil,type(q)==\"string\"and q:gsub(\"kernel:%d: \",\"\")or q end;bN=self:stat(process,fs.getDir(g))end;self:setpath(process.user,g,{type=\"fifo\",owner=process.user,permissions=deepcopy(bN.permissions),worldPermissions=deepcopy(bN.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\"},true)end;function filesystems.tmpfs:chmod(process,g,bG,p)if self.readOnly then error(\"Read-only filesystem\",2)end;local bL=self:getpath(process.user,g,true)if not bL then error(g..\": No such file or directory\",2)end;if not bL.owner or process.user~=\"root\"and process.user~=bL.owner then error(g..\": Permission denied\",2)end;local bP;if bG==nil then bP=bL.worldPermissions else bP=bL.permissions[bG]if not bP then bP=deepcopy(bL.worldPermissions)bL.permissions[bG]=bP end end;if type(p)==\"string\"then if p:match\"^[%+%-=][rwxs]+$\"then local C=p:sub(1,1)local A={}for ab in p:gmatch(\"[rwxs]\")do if ab==\"r\"then A.read=true elseif ab==\"w\"then A.write=true elseif ab==\"s\"then A.setuser=true else A.execute=true end end;if C==\"+\"then if A.read then bP.read=true end;if A.write then bP.write=true end;if A.execute then bP.execute=true end;if A.setuser then bL.setuser=true end elseif C==\"-\"then if A.read then bP.read=false end;if A.write then bP.write=false end;if A.execute then bP.execute=false end;if A.setuser then bL.setuser=false end else bP.read=A.read or false;bP.write=A.write or false;bP.execute=A.execute or false;bL.setuser=A.setuser or false end else bP.read=p:sub(1,1)~=\"-\"bP.write=p:sub(2,2)~=\"-\"bP.execute=p:sub(3,3)~=\"-\"bL.setuser=p:sub(3,3)==\"s\"end elseif type(p)==\"number\"then bL.setuser=bit32.btest(p,8)bP.read=bit32.btest(p,4)bP.write=bit32.btest(p,2)bP.execute=bit32.btest(p,1)else if p.read~=nil then bP.read=p.read end;if p.write~=nil then bP.write=p.write end;if p.execute~=nil then bP.execute=p.execute end;if p.setuser~=nil then bL.setuser=p.setuser end end end;function filesystems.tmpfs:chown(process,g,bZ)if self.readOnly then error(\"Read-only filesystem\",2)end;local bL=self:getpath(process.user,g,true)if not bL then error(g..\": No such file or directory\",2)end;if not bL.owner or process.user~=\"root\"and process.user~=bL.owner then error(g..\": Permission denied\",2)end;bL.owner=bZ;bL.setuser=false end;function filesystems.tmpfs:info()return\"tmpfs\",\"memory\",{ro=self.readOnly}end;setmetatable(filesystems.drivefs,{__index=filesystems.craftos})function filesystems.drivefs:stat(process,g)local w,q=filesystems.craftos.stat(self,process,g)if g==\"\"and w==nil then return{size=0,type=\"directory\",created=0,modified=0,owner=self.owner,capacity=0,freeSpace=0,permissions={[self.owner]={read=false,write=true,execute=false}},worldPermissions={read=false,write=false,execute=false},setuser=false}end;return w,q end;function filesystems.drivefs:new(process,bE,bK)local cb=hardware.get(bE)if not cb then error(\"Could not find drive at \"..bE)end;local g=hardware.call(process,cb,\"getMountPath\")local fs=filesystems.craftos:new(process,g,bK)fs.drive=cb.uuid;fs.owner=process.user;fs.meta={meta={type=\"directory\",owner=\"root\",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}}fs.metapath=fs.combine(g,\".meta.ltn\")local a=fs.open(fs.metapath,\"r\")if a then fs.meta=unserialize(a.readAll())or fs.meta;a.close()end;return setmetatable(fs,{__index=self})end;function filesystems.drivefs:info()return\"drivefs\",self.drive,{ro=self.readOnly}end;setmetatable(filesystems.tablefs,{__index=filesystems.tmpfs})function filesystems.tablefs:new(process,bE,bK)local A;local a,q;if process~=KERNEL and mounts[\"\"]then a,q=filesystem.open(process,bE,\"r\")else a,q=fs.open(bE,\"r\")end;if a then local bk=a.readAll()or\"\"a.close()local bh,w=pcall(unserialize,bk)if not bh then error(\"Could not mount \"..bE..\": \"..w,3)elseif type(w)~=\"table\"or w.type~=\"directory\"or type(w.contents)~=\"table\"then error(\"Could not mount \"..bE..\": Invalid table file\",3)end;A=w else if not(bK.rw and not bK.ro)then error(\"Could not mount \"..bE..\": \"..q,3)end;A={type=\"directory\",owner=process.user,permissions={[process.user]={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\",contents={}}end;A.src=bE;A.readOnly=bK.ro;if bK.rw and not bK.ro then function A:__flush()local f,bt=self.__flush,self.src;self.__flush,self.src=nil;local bh,w=pcall(serialize,self)self.__flush,self.src=f,bt;if not bh then error(w)end;local a,q=filesystem.open(process,bE,\"w\")if not a then syslog.log({level=4},\"Could not save mount to \"..bE..\": \"..q)return end;a.write(w)a.close()end end;return setmetatable(A,{__index=self})end;function filesystems.tablefs:info()return\"tablefs\",self.src,{rw=self.__flush~=nil,ro=self.readOnly}end;function filesystems.bind:new(process,g,bK)local bL,q=filesystem.stat(process,g)if not bL then error(\"Could not bind \"..g..\": \"..q,3)elseif bL.type~=\"directory\"then error(\"Could not bind \"..g..\": Not a directory\",3)end;return setmetatable({path=g},{__index=self})end;function filesystems.bind:open(process,g,p)return filesystem.open(process,fs.combine(self.path,g),p)end;function filesystems.bind:list(process,g)return filesystem.list(process,fs.combine(self.path,g))end;function filesystems.bind:stat(process,g,bH)return filesystem.stat(process,fs.combine(self.path,g),bH)end;function filesystems.bind:remove(process,g)return filesystem.remove(process,fs.combine(self.path,g))end;function filesystems.bind:rename(process,bU,bV)return filesystem.rename(process,fs.combine(self.path,bU),fs.combine(self.path,bV))end;function filesystems.bind:mkdir(process,g)return filesystem.mkdir(process,fs.combine(self.path,g))end;function filesystems.bind:link(process,g,bY)return filesystem.link(process,fs.combine(self.path,g),bY)end;function filesystems.bind:mkfifo(process,g)return filesystem.mkfifo(process,fs.combine(self.path,g))end;function filesystems.bind:chmod(process,g,bG,p)return filesystem.chmod(process,fs.combine(self.path,g),bG,p)end;function filesystems.bind:chown(process,g,bZ)return filesystem.chown(process,fs.combine(self.path,g),bZ)end;function filesystems.bind:info()return\"bind\",self.path,{}end;local function cc(process,g,cd,ce)local cf=bc(process,g)if ce then if cf==\"\"then cf=nil else cf=fs.getDir(cf)end end;if cf and fsevents[cf]then for B,k in pairs(fsevents[cf])do local cg=cf;if cg:find(k.root,1,true)==1 then cg=cg:sub(#k.root+1)end;k.eventQueue[#k.eventQueue+1]={\"fsevent\",{path=cg,event=cd,name=ce and fs.getName(cf)or nil,process=process.id}}wakeup(k)end end end;function filesystem.open(process,g,p)expect(0,process,\"table\")expect(1,g,\"string\")expect(2,p,\"string\")if not p:match\"^[rwa]b?$\"then error(\"Invalid mode\",0)end;for B=1,1000 do local bh,bj,G=pcall(bd,process,g)if not bh then return nil,bj end;local w=table.pack(pcall(bj.open,bj,process,G,p))if w[1]then if w[2]and p~=\"r\"and p~=\"rb\"then cc(process,g,\"open\",false)cc(process,g,\"open_child\",true)end;return table.unpack(w,2,w.n)elseif type(w[2])~=\"table\"or type(w[2].path)~=\"string\"then error(w[2],2)end;g=w[2].path end;error(\"Too many levels of symbolic links\",2)end;local function ch(process,g,ci)local a7={}local mounts,G=bd(process,g,true)for B,bj in ipairs(mounts)do local bh,w=pcall(bj.list,bj,process,G)if not bh then if type(w)~=\"table\"or type(w.path)~=\"string\"then if#mounts==1 and ci then error(w,2)else w={}end else w=ch(process,w.path,false)end end;for B,k in ipairs(w)do a7[#a7+1]=k end end;return a7 end;function filesystem.list(process,g)expect(0,process,\"table\")expect(1,g,\"string\")local a7=ch(process,g,true)table.sort(a7)return a7 end;function filesystem.stat(process,g,bH)expect(0,process,\"table\")expect(1,g,\"string\")for B=1,1000 do local bh,bj,G,cj=pcall(bd,process,g)if not bh then return nil,bj end;local ck,w,q=pcall(bj.stat,bj,process,G,bH)if ck then if w then w.mountpoint=\"/\"..cj end;return w,q elseif type(w)~=\"table\"or type(w.path)~=\"string\"then error(w,2)end;g=w.path end;error(\"Too many levels of symbolic links\",2)end;function filesystem.remove(process,g)expect(0,process,\"table\")expect(1,g,\"string\")for B=1,1000 do local bj,G=bd(process,g)local bh,w=pcall(bj.remove,bj,process,G)if bh then cc(process,g,\"remove\",false)cc(process,g,\"remove_child\",true)return elseif type(w)~=\"table\"or type(w.path)~=\"string\"then error(w,2)end;g=w.path end;error(\"Too many levels of symbolic links\",2)end;function filesystem.rename(process,bU,bV)expect(0,process,\"table\")expect(1,bU,\"string\")expect(2,bV,\"string\")for B=1,1000 do local cl,cm=bd(process,bU)local cn,co=bd(process,bV)if cl~=cn then error(\"Attempt to rename file across two filesystems\",0)end;local bh,w=pcall(cl.rename,cl,process,cm,co)if bh then cc(process,bU,\"rename_from\",false)cc(process,bU,\"rename_from_child\",true)cc(process,bV,\"rename_to\",false)cc(process,bV,\"rename_to_child\",true)return elseif type(w)~=\"table\"or type(w.path)~=\"string\"then error(w,2)end;if w.orig==bU then bU=w.path else bV=w.path end end;error(\"Too many levels of symbolic links\",2)end;function filesystem.mkdir(process,g)expect(0,process,\"table\")expect(1,g,\"string\")for B=1,1000 do local bj,G=bd(process,g)local bh,w=pcall(bj.mkdir,bj,process,G)if bh then cc(process,g,\"mkdir\",false)cc(process,g,\"mkdir_child\",true)return elseif type(w)~=\"table\"or type(w.path)~=\"string\"then error(w,2)end;g=w.path end;error(\"Too many levels of symbolic links\",2)end;function filesystem.link(process,g,bY)expect(0,process,\"table\")expect(1,g,\"string\")expect(2,bY,\"string\")if fs.combine(g)==fs.combine(bY)then error(\"Cannot link file to itself\",2)end;syslog.debug(\"Creating link\",g,\" => \",bY)for B=1,1000 do local bj,G=bd(process,g)if not bj.link then error(\"Filesystem does not support links\",2)end;local bh,w=pcall(bj.link,bj,process,G,bY)if bh then cc(process,g,\"link\",false)cc(process,g,\"link_child\",true)return elseif type(w)~=\"table\"or type(w.path)~=\"string\"then error(w,2)end;g=w.path end;error(\"Too many levels of symbolic links\",2)end;function filesystem.mkfifo(process,g)expect(0,process,\"table\")expect(1,g,\"string\")for B=1,1000 do local bj,G=bd(process,g)if not bj.mkfifo then error(\"Filesystem does not support FIFOs\",2)end;local bh,w=pcall(bj.mkfifo,bj,process,G)if bh then cc(process,g,\"mkfifo\",false)cc(process,g,\"mkfifo_child\",true)return elseif type(w)~=\"table\"or type(w.path)~=\"string\"then error(w,2)end;g=w.path end;error(\"Too many levels of symbolic links\",2)end;function filesystem.chmod(process,g,bG,p)expect(0,process,\"table\")expect(1,g,\"string\")expect(2,bG,\"string\",\"nil\")expect(3,p,\"number\",\"string\",\"table\")if type(p)==\"string\"and not p:match\"^[%+%-=][rwxs]+$\"and not p:match\"^[r%-][w%-][xs%-]$\"then error(\"bad argument #3 (invalid mode)\",2)elseif type(p)==\"table\"then expect.field(p,\"read\",\"boolean\",\"nil\")expect.field(p,\"write\",\"boolean\",\"nil\")expect.field(p,\"execute\",\"boolean\",\"nil\")end;for B=1,1000 do local bj,G=bd(process,g)local bh,w=pcall(bj.chmod,bj,process,G,bG,p)if bh then return elseif type(w)~=\"table\"or type(w.path)~=\"string\"then error(w,2)end;g=w.path end;error(\"Too many levels of symbolic links\",2)end;function filesystem.chown(process,g,bG)expect(0,process,\"table\")expect(1,g,\"string\")expect(2,bG,\"string\")for B=1,1000 do local bj,G=bd(process,g)local bh,w=pcall(bj.chown,bj,process,G,bG)if bh then return elseif type(w)~=\"table\"or type(w.path)~=\"string\"then error(w,2)end;g=w.path end;error(\"Too many levels of symbolic links\",2)end;function filesystem.chroot(process,g)expect(0,process,\"table\")expect(1,g,\"string\")if process.user~=\"root\"then error(\"Could not change root: Permission denied\",2)end;local cp=filesystem.combine(process.root,g)..\"/\"if cp:find(process.root,1,true)~=1 then error(\"Could not change root: No such file or directory\",2)end;local bt=filesystem.stat(process,\"/\"..g)if not bt then error(g..\": No such directory\",2)end;if bt.type~=\"directory\"then error(g..\": Not a directory\",2)end;process.root=cp end;function filesystem.mount(process,type,bE,bF,bK)expect(0,process,\"table\")expect(1,type,\"string\")expect(2,bE,\"string\")expect(3,bF,\"string\")expect(4,bK,\"table\",\"nil\")if not filesystems[type]then error(\"No such filesystem '\"..type..\"'\",2)end;local G=bc(process,bF)if G==\"\"then if process.user~=\"root\"then error(\"Could not mount to \"..bF..\": Permission denied\",2)end;if mounts[G]and not(bK and bK.overlay)then error(\"Could not mount to \"..bF..\": Mount already exists (use overlay to mount over)\")end;if not mounts[G]and(bK and bK.overlay)then error(\"Could not mount to \"..bF..\": No base mount exists for overlay\")end else local bL=filesystem.stat(process,bF)if not bL then error(\"Could not mount to \"..bF..\": No such directory\",2)end;if bL.type~=\"directory\"then error(\"Could not mount to \"..bF..\": Not a directory\",2)end;if process.user~=\"root\"and not(bL.permissions[process.user]or bL.worldPermissions).write then error(\"Could not mount to \"..bF..\": Permission denied\",2)end;if mounts[G]and not(bK and bK.overlay)then error(\"Could not mount to \"..bF..\": Mount already exists (use overlay to mount over)\")end;if not mounts[G]and(bK and bK.overlay)then error(\"Could not mount to \"..bF..\": No base mount exists for overlay\")end end;local bj=filesystems[type]:new(process,bE,bK or{})if bK and bK.overlay then mounts[G][#mounts[G]+1]=bj else mounts[G]={bj}end end;function filesystem.unmount(process,g)expect(0,process,\"table\")expect(1,g,\"string\")g=bc(process,g)if not mounts[g]then error(g..\": No such mount\",2)end;local b_=#mounts[g]local bL=mounts[g][b_]:stat(process,\"\")if not bL then error(\"Internal error in unmount: could not get stat for root! Please report this to the maintainer of the target filesystem.\",2)elseif process.user~=\"root\"and not(bL.permissions[process.user]or bL.worldPermissions).write then error(g..\": Permission denied\",2)end;if mounts[g][b_].unmount then mounts[g][b_]:unmount(process)end;mounts[g][b_]=nil;if b_==1 then mounts[g]=nil end end;function filesystem.mountlist(process)expect(0,process,\"table\")local a7={}for j,k in pairs(mounts)do if\"/\"..j..\"/\"==process.root or j:find(process.root:sub(2),1,true)==1 then for B,bj in ipairs(k)do local type,g,bK=bj:info()a7[#a7+1]={path=\"/\"..j,type=type,source=g,options=bK}end end end;return a7 end;function filesystem.combine(cq,...)expect(1,cq,\"string\")local a2=fs.combine(cq,...)if cq:match\"^/\"then a2=\"/\"..a2 end;return a2 end;function syscalls.open(process,at,...)return filesystem.open(process,...)end;function syscalls.list(process,at,...)return filesystem.list(process,...)end;function syscalls.stat(process,at,...)return filesystem.stat(process,...)end;function syscalls.remove(process,at,...)return filesystem.remove(process,...)end;function syscalls.rename(process,at,...)return filesystem.rename(process,...)end;function syscalls.mkdir(process,at,...)return filesystem.mkdir(process,...)end;function syscalls.link(process,at,...)return filesystem.link(process,...)end;function syscalls.mkfifo(process,at,...)return filesystem.mkfifo(process,...)end;function syscalls.chmod(process,at,...)return filesystem.chmod(process,...)end;function syscalls.chown(process,at,...)return filesystem.chown(process,...)end;function syscalls.chroot(process,at,...)return filesystem.chroot(process,...)end;function syscalls.mount(process,at,...)return filesystem.mount(process,...)end;function syscalls.unmount(process,at,...)return filesystem.unmount(process,...)end;function syscalls.mountlist(process,at,...)return filesystem.mountlist(process,...)end;function syscalls.combine(process,at,...)return filesystem.combine(...)end;function syscalls.loadCraftOSAPI(process,at,cr)expect(1,cr,\"string\")local e;e=setmetatable({dofile=function(g)local a,q=fs.open(g,\"rb\")if not a then error(\"Could not open module: \"..q,0)end;local i,q=load(a.readAll(),\"@\"..g,nil,e)a.close()if not i then error(\"Could not load module: \"..q,0)end;return i()end,require=function(o)return e.dofile(\"rom/modules/main/\"..o:gsub(\"%.\",\"/\")..\".lua\")end},{__index=process.env})e._ENV=e;if cr:sub(1,3)==\"cc.\"then local g=fs.combine(\"rom/modules/main\",cr:gsub(\"%.\",\"/\")..\".lua\")if not g:match\"^/?rom/modules/main/\"then error(\"Invalid module path\",0)end;return e.dofile(g)else if not cr:match\"^[a-z]+$\"then error(\"Invalid API name\",0)end;local g=fs.combine(\"rom/apis\",cr..\".lua\")local a,q=fs.open(g,\"rb\")if not a then error(\"Could not open module: \"..q,0)end;local i,q=load(a.readAll(),\"@\"..g,nil,e)a.close()if not i then error(\"Could not load module: \"..q,0)end;i()local A={}for j,k in pairs(e)do if j~=\"dofile\"and j~=\"require\"and j~=\"_ENV\"then A[j]=k end end;return A end end;function syscalls.fsevent(process,at,g,cs)expect(1,g,\"string\")expect(2,cs,\"boolean\",\"nil\")if cs==nil then cs=true end;g=bc(process,g)syslog.debug(\"Registering fsevents for\",g)fsevents[g]=fsevents[g]or setmetatable({},{__mode=\"v\"})fsevents[g][#fsevents[g]+1]=cs and process or nil end;xpcall(function()if args.initrd then if args.initrd:match\"^_G%..\"then local ci=_G[args.initrd:match\"^_G%.(.+)\"]if type(ci)~=\"table\"then error(\"Requested root filesystem in global '\"..args.initrd..\"' is not a table\")end;ci.src=args.initrd;mounts[\"\"]={setmetatable(ci,{__index=filesystems.tablefs})}else mounts[\"\"]={filesystems.tablefs:new(KERNEL,args.initrd,{})}end else local bK={}if args.rootflags then for C in args.rootflags:gmatch\"[^,]+\"do local j,k=C:match(\"^([^=]+)=(.*)$\")if j and k then if k==\"true\"then bK[j]=true elseif k==\"false\"then bK[j]=false else bK[j]=tonumber(k)or k end else bK[C]=true end end end;mounts[\"\"]={filesystems[args.rootfstype]:new(KERNEL,args.root,bK)}end end,panic)local do_syscall=do_syscall;local expect=expect;local function ct(cu,cv,cw,cx)local cy={bit32.extract(cv,0,16),bit32.extract(cv,16,16),bit32.extract(cu,0,16),bit32.extract(cu,16,16)}local ad={bit32.extract(cx,0,16),bit32.extract(cx,16,16),bit32.extract(cw,0,16),bit32.extract(cw,16,16)}local bz={{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0}}for cz=1,4 do for cA=1,4 do local t=cy[cA]*ad[cz]+bz[cz][cA]bz[cz][cA+1],bz[cz][cA]=bit32.rshift(t,16),bit32.band(t,0xFFFF)end end;local cB={0,0,0,0,0,0,0,0}for cC=1,8 do for cD=1,4 do cB[cC]=cB[cC]+(bz[cD][cC-cD+1]or 0)end;cB[cC+1],cB[cC]=bit32.rshift(cB[cC],16),bit32.band(cB[cC],0xFFFF)end;return cB[3]+cB[4]*0x10000,cB[1]+cB[2]*0x10000 end;local function cE(ad,cu,cv)return cu+math.floor((cv+ad)/0x100000000),bit32.band(cv+ad,0xFFFFFFFF)end;function makeRandom()local cF,cG=0,0;local function next(cH)cF,cG=cE(0xB,ct(cF,cG,0x5,0xDEECE66D))cF=bit32.band(cF,0xFFFF)return math.floor(cF/2^(16-cH))+math.floor(cG/2^(48-cH))end;local function cI(c,d)expect(1,c,\"number\",\"nil\")expect(2,d,\"number\",\"nil\")if c then expect.range(c,0,0x7FFFFFFF)if not d then c,d=0,c else expect.range(d,0,0x7FFFFFFF)end;local cJ=d-c+1;local cK;if math.log(cJ,2)%1==0 then cK=math.floor(cJ*next(31)/0x80000000)else local cH;repeat cH=next(31)cK=cH%cJ until cH-cK+cJ-1>=0 end;return cK+c else return(next(26)*0x8000000+next(27))/0x20000000000000 end end;local function cL(cM)expect(1,cM,\"number\")cF,cG=bit32.band(bit32.bxor(0x5,math.floor(cM/0x100000000)),0xFFFF),bit32.bxor(0xDEECE66D,math.floor(cM))end;cL(os.epoch\"utc\"*tonumber(tostring(next):match(\"%x+\")or\"1\",16))return cI,cL end;do math.random,math.randomseed=makeRandom()end;function createLuaLib(process)local cN={}for B,k in ipairs{\"assert\",\"error\",\"getmetatable\",\"ipairs\",\"next\",\"pairs\",\"pcall\",\"rawequal\",\"rawget\",\"rawset\",\"select\",\"setmetatable\",\"tonumber\",\"tostring\",\"type\",\"_VERSION\",\"xpcall\",\"collectgarbage\"}do cN[k]=_G[k]end;function cN.dofile(g)if g~=nil and type(g)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(g)..\")\",2)end;local i,q=loadfile(g or io.stdin:read(\"*a\"))if not i then error(q,2)end;return i()end;do local load,getfenv,setfenv,make_ENV=load,getfenv,setfenv,make_ENV;if _VERSION==\"Lua 5.1\"then function cN.load(n,o,p,e)return load(n,o,p,make_ENV(e or process.env))end;function cN.getfenv(f)local k;if f==nil then k=getfenv(2)elseif tonumber(f)and tonumber(f)>0 then k=getfenv(f+1)elseif type(f)==\"function\"then k=getfenv(f)else k=getfenv(f)end;local aE=getmetatable(f)if aE and aE.__env then return aE.__env else return k end end;function cN.setfenv(f,M)return setfenv(f,make_ENV(M))end else cN.load,cN.getfenv,cN.setfenv=function(n,o,p,e)return load(n,o,p,e or process.env)end,getfenv,setfenv end end;function cN.loadfile(g,p,e)if e==nil and type(p)==\"table\"then e,p=p,nil end;if type(g)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(g)..\")\",2)end;if p~=nil and type(p)~=\"string\"then error(\"bad argument #2 (expected string, got \"..type(p)..\")\",2)end;if e~=nil and type(e)~=\"table\"then error(\"bad argument #3 (expected table, got \"..type(e)..\")\",2)end;local a,q=do_syscall(\"open\",g,\"rb\")if not a then error(q,2)end;local bk=a.readAll()a.close()return load(bk,\"@\"..g,p,e)end;function cN.print(...)local args=table.pack(...)if args.n==0 then args={\"\",n=1}end;args[args.n]=tostring(args[args.n])..\"\\n\"return do_syscall(\"write\",table.unpack(args,1,args.n))end;cN.coroutine=deepcopy(coroutine)cN.string=deepcopy(string)cN.table=deepcopy(table)cN.math=deepcopy(math)cN.bit32=deepcopy(bit32)cN.utf8=deepcopy(utf8)cN.math.random,cN.math.randomseed=makeRandom()local cO=\"\"local cP=setmetatable({close=function()end,lines=function(self,...)local args=table.pack(...)return function()return self:read(table.unpack(args,1,args.n))end end,read=function(self,a8,...)local bt,M;a8=a8 or\"*l\"if type(a8)==\"number\"then while#cO<a8 do cO=cO..do_syscall(\"read\",a8)end elseif type(a8)==\"string\"then a8=a8:gsub(\"^%*\",\"\")if a8==\"n\"then while not cO:find(\"%d\")do local bu=do_syscall(\"readline\")if bu==nil then break end;cO=cO..bu..\"\\n\"end elseif a8==\"a\"then while true do local bu=do_syscall(\"readline\")if bu==nil then break end;cO=cO..bu..\"\\n\"end elseif a8==\"l\"or a8==\"L\"then local bu=do_syscall(\"readline\")if bu==nil then return nil end;cO=cO..bu..\"\\n\"else error(\"bad argument (invalid format '\"..a8 ..\"')\",2)end else error(\"bad argument (expected string or number, got \"..type(a8),2)end;if type(a8)==\"number\"then bt,M=cO:sub(1,a8),a8+1 elseif a8==\"n\"then bt,M=cO:match(\"(%d)()\")elseif a8==\"a\"then bt,M=cO,#cO+1 elseif a8==\"l\"then bt,M=cO:match(\"(.*)\\n()\")else bt,M=cO:match(\"(.*\\n)()\")end;if not bt then return nil end;cO=cO:sub(M)if select(\"#\",...)>0 then return bt,self:read(...)else return bt end end,seek=function()return nil,\"Cannot seek default file\"end,setvbuf=function()end},{__name=\"FILE*\"})local cQ=setmetatable({close=function()end,flush=function()end,seek=function()return nil,\"Cannot seek default file\"end,setvbuf=function()end,write=function(self,...)do_syscall(\"write\",...)return self end},{__name=\"FILE*\"})local cR=setmetatable({close=function()end,flush=function()end,seek=function()return nil,\"Cannot seek default file\"end,setvbuf=function()end,write=function(self,...)do_syscall(\"writeerr\",...)return self end},{__name=\"FILE*\"})local cS,cT=cP,cQ;local cU={close=function(self)self._file.close()self._closed=true end,lines=function(self,...)local args=table.pack(...)return function()return self:read(table.unpack(args,1,args.n))end end,read=function(self,a8,...)local k;if a8==nil then a8=\"l\"end;if type(a8)==\"number\"then k=self._file.read(a8)elseif type(a8)==\"string\"then a8=a8:gsub(\"^%*\",\"\")if a8==\"a\"then k=self._file.readAll()elseif a8==\"l\"then k=self._file.readLine(false)elseif a8==\"L\"then k=self._file.readLine(true)elseif a8==\"n\"then local bt,ab=\"\"repeat ab=self._file.read(1)until ab:match(\"%d\")while ab:match(\"%d\")do bt,ab=bt..ab,self._file.read(1)end;k=tonumber(bt)else error(\"bad argument (invalid format '\"..a8 ..\"')\",2)end else error(\"bad argument (expected string or number, got \"..type(a8)..\")\",2)end;if select(\"#\",...)>0 then return k,self:read(...)else return k end end,seek=function(self,bs,W)if self._file.seek then return self._file.seek(bs,W)else return nil,\"Cannot seek text file\"end end,setvbuf=function()end}local cV={close=function(self)self._file.close()self._closed=true end,flush=function(self)self._file:flush()end,seek=function(self,bs,W)if self._file.seek then return self._file.seek(bs,W)else return nil,\"Cannot seek text file\"end end,setvbuf=function()end,write=function(self,...)self._file.write(...)return self end}cN.io={close=function(a)if a==nil then cT:close()elseif type(a)==\"table\"and getmetatable(a)and getmetatable(a).__name==\"FILE*\"then a:close()else error(\"bad argument #1 (expected FILE*, got \"..type(a)..\")\",2)end end,flush=function()return cT:flush()end,input=function(a)if a==nil then return cS elseif type(a)==\"string\"then local ai,q=io.open(a,\"r\")if not ai then error(q,2)end;cS=ai elseif type(a)==\"table\"and getmetatable(a)and getmetatable(a).__name==\"FILE*\"then cS=a else error(\"bad argument #1 (expected string or FILE*, got \"..type(a)..\")\",2)end end,lines=function(cW,...)if cW==nil then return cS:lines(...)end;if type(cW)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(cW)..\")\",2)end;local ai,q=io.open(cW,\"r\")if not ai then error(q,2)end;local i=ai:lines(...)return function(...)local a7=table.pack(i(...))if a7.n==0 or a7[1]==nil then ai:close()end;return table.unpack(a7,1,a7.n)end end,open=function(cW,p)if type(cW)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(cW)..\")\",2)end;if p==nil then p=\"r\"end;if type(p)~=\"string\"then error(\"bad argument #2 (expected string, got \"..type(p)..\")\",2)end;local a,q=do_syscall(\"open\",cW,p)if not a then return nil,q elseif p:find(\"r\")then return setmetatable({_file=a},{__index=cU,__name=\"FILE*\"})else return setmetatable({_file=a},{__index=cV,__name=\"FILE*\"})end end,output=function(a)if a==nil then return cT elseif type(a)==\"string\"then local ai,q=io.open(a,\"w\")if not ai then error(q,2)end;cT=ai elseif type(a)==\"table\"and getmetatable(a)and getmetatable(a).__name==\"FILE*\"then cT=a else error(\"bad argument #1 (expected string or FILE*, got \"..type(a)..\")\",2)end end,popen=function(g,p)expect(1,g,\"string\")p=expect(2,p,\"string\",\"nil\")or\"r\"if p~=\"r\"and p~=\"w\"and p~=\"rw\"then error(\"bad argument #2 (invalid mode)\",2)end;if p==\"rw\"then local cX,cY=\"\",\"\"local cZ;local c_={read=function(t)if cX==\"\"then return nil elseif t then local bt=cX:sub(1,t)cX=cX:sub(t+1)return bt else local bt,M=cX:match\"([^\\n]*)\\n*()\"cX=cX:sub(M)return bt end end}local d0={write=function(bt)cX=cX..bt end,flush=function()end,close=function()local info=do_syscall(\"getpinfo\",cZ)if not info then return end;repeat local au,d1=coroutine.yield()until au==\"process_complete\"and d1.pid==cZ end}local d2={read=function(t)if cY==\"\"then return nil elseif t then local bt=cY:sub(1,t)cY=cY:sub(t+1)return bt else local bt,M=cY:match\"([^\\n]*)\\n*()\"cY=cY:sub(M)return bt end end,readLine=function()local bt,M=cY:match\"([^\\n]*)\\n*()\"cY=cY:sub(M)return bt end,readAll=function()local bt=cY;cY=\"\"return bt end,close=function()local info=do_syscall(\"getpinfo\",cZ)if not info then return end;repeat local au,d1=coroutine.yield()until au==\"process_complete\"and d1.pid==cZ end}local d3={write=function(bt)cY=cY..bt end}cZ=do_syscall(\"fork\",function()do_syscall(\"stdin\",c_)do_syscall(\"stdout\",d3)do_syscall(\"exec\",\"/bin/sh\",\"-c\",g)end)return setmetatable({_file=d2},{__index=cU,__name=\"FILE*\"}),setmetatable({_file=d0},{__index=cV,__name=\"FILE*\"})else local d4=\"\"local bp=false;local cZ;local d5={read=function(t)if d4==\"\"then if bp then return nil else return\"\"end elseif t then local bt=d4:sub(1,t)d4=d4:sub(t+1)return bt else local bt,M=d4:match\"([^\\n]*\\n?)()\"d4=d4:sub(M)return bt end end,readLine=function()local bt,M=d4:match\"([^\\n]*\\n?)()\"d4=d4:sub(M)return bt end,readAll=function()local bt=d4;d4=\"\"return bt end,close=function()bp=true;local info=do_syscall(\"getpinfo\",cZ)if not info then return end;repeat local au,d1=coroutine.yield()until au==\"process_complete\"and d1.pid==cZ end}local d6={write=function(bt)d4=d4 ..bt end,flush=function()end,close=function()bp=true;local info=do_syscall(\"getpinfo\",cZ)if not info then return end;repeat local au,d1=coroutine.yield()until au==\"process_complete\"and d1.pid==cZ end}cZ=do_syscall(\"fork\",function()do_syscall(p==\"r\"and\"stdout\"or\"stdin\",p==\"r\"and d6 or d5)do_syscall(\"exec\",\"/bin/sh\",\"-c\",g)end)return p==\"r\"and setmetatable({_file=d5},{__index=cU,__name=\"FILE*\"})or setmetatable({_file=d6},{__index=cV,__name=\"FILE*\"})end end,read=function(...)return cS:read(...)end,tmpfile=function()return io.open(os.tmpname(),\"a\")end,type=function(bB)if type(bB)==\"table\"and getmetatable(bB)and getmetatable(bB).__name==\"FILE*\"then if bB._closed then return\"closed file\"else return\"file\"end else return nil end end,write=function(...)return cT:write(...)end,stdin=cP,stdout=cQ,stderr=cR}local d7=os;cN.os={clock=function()return do_syscall(\"clock\")end,date=function(a8,ca)if type(a8)==\"string\"and a8:sub(1,1)==\"?\"then local br=d7.date(\"!\"..a8:sub(2),ca or d7.epoch\"ingame\"/1000)if type(br)==\"table\"then br.year=br.year-1970 end;return br else return d7.date(a8,ca)end end,difftime=function(cy,ad)return cy-ad end,execute=function(g)do_syscall(\"exec\",\"/bin/sh\",\"-c\",g)end,exit=function(bv)do_syscall(\"exit\",bv)end,getenv=function(o)expect(1,o,\"string\")local e=do_syscall(\"getenv\")if not e then return nil end;return e[o]end,remove=function(g)expect(1,g,\"string\")local bh,q=do_syscall(\"remove\",g)if not bh then bh=nil end;return bh,q end,rename=function(bU,bV)expect(1,bU,\"string\")expect(2,bV,\"string\")local bh,q=do_syscall(\"rename\",bU,bV)if not bh then bh=nil end;return bh,q end,setlocale=function(d8)if d8 then error(\"setlocale is not supported\",2)else return\"C\"end end,time=function(A)if A==\"ingame\"then return d7.epoch\"ingame\"/1000 elseif A==\"nano\"then return ccemux and ccemux.nanoTime()or d7.epoch\"nano\"end;expect(1,A,\"table\",\"nil\")if A then return d7.time(A)else return d7.epoch\"utc\"/1000 end end,tmpname=function()local o=\"/tmp/lua_\"for x=1,6 do local t=math.random(1,64)o=o..(\"qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890._\"):sub(t,t)end;return o end}cN.debug=deepcopy(debug)local d9,da,db,aY,getCurrentThread,dc,dd,next,xpcall,wakeup=coroutine.resume,coroutine.yield,debug.sethook,debug.getinfo,getCurrentThread,table.pack,table.unpack,next,xpcall,wakeup;local de=debugHooks;function cN.coroutine.resume(df,...)expect(1,df,\"thread\")local at=getCurrentThread()if process.debugging then for aD,dg in next,process.breakpoints do if dg.type==\"resume\"and(dg.thread==nil or dg.thread==at.id)then local bh=true;if dg.filter then for j,k in next,dg.filter do if info[j]~=k then bh=false;break end end end;if bh then dg.process.eventQueue[#dg.process.eventQueue+1]={\"debug_break\",{process=process.id,thread=at.id,breakpoint=aD}}wakeup(dg.process)at.paused=true;da(\"preempt\")end end end end;local dh=#at.coroStack+1;at.coroStack[dh]=df;local a7=dc(d9(df,...))while a7.n>=2 and a7[1]==true and(a7[2]==\"preempt\"or a7[2]==\"secure_syscall\"or a7[2]==\"secure_event\")do a7=dc(d9(df,da(dd(a7,2,a7.n))))end;if process.debugging and not a7[1]then local info=aY(df,1)for aD,dg in next,process.breakpoints do if dg.type==\"error\"and(dg.thread==nil or dg.thread==at.id)then local bh=true;if dg.filter then for j,k in next,dg.filter do if info[j]~=k then bh=false;break end end end;if bh then dg.process.eventQueue[#dg.process.eventQueue+1]={\"debug_break\",{process=process.id,thread=at.id,breakpoint=aD}}wakeup(dg.process)at.paused=true;da(\"preempt\")end end end end;at.coroStack[dh]=nil;return dd(a7,1,a7.n)end;function cN.coroutine.yield(cy,ad,...)if process.debugging then local at=getCurrentThread()local info=aY(2)for aD,dg in next,process.breakpoints do if dg.type==\"syscall\"and not(dg.filter and dg.filter.name and dg.filter.name~=ad)and(dg.thread==nil or dg.thread==at.id)then dg.process.eventQueue[#dg.process.eventQueue+1]={\"debug_break\",{process=process.id,thread=at.id,breakpoint=aD}}wakeup(dg.process)at.paused=true;da(\"preempt\")elseif dg.type==\"yield\"and(dg.thread==nil or dg.thread==at.id)then local bh=true;if dg.filter then for j,k in next,dg.filter do if info[j]~=k then bh=false;break end end end;if bh then dg.process.eventQueue[#dg.process.eventQueue+1]={\"debug_break\",{process=process.id,thread=at.id,breakpoint=aD}}wakeup(dg.process)at.paused=true;da(\"preempt\")end end end end;return da(cy,ad,...)end;function cN.debug.gethook(df)expect(1,df,\"thread\",\"nil\")df=df or coroutine.running()local ai=de[df]if not ai then return nil end;return ai.func,ai.mask,ai.count end;function cN.debug.sethook(df,aC,y,di)if type(df)~=\"thread\"then df,aC,y,di=coroutine.running(),df,aC,y end;expect(1,df,\"thread\")expect(2,aC,\"function\",\"nil\")if aC then expect(3,y,\"string\")expect(4,di,\"number\",\"nil\")de[df]={func=aC,mask=y,count=di}if not process.debugging then db(df,process.hookf,y,process.quantum)end else de[df]=nil;if not process.debugging then db(df,process.hookf,\"\",process.quantum)end end end;function cN.pcall(f,...)return xpcall(f,function(q)if process.debugging then local at=getCurrentThread()local info=aY(2)for aD,dg in next,process.breakpoints do if dg.type==\"error\"and(dg.thread==nil or dg.thread==at.id)then local bh=true;if dg.filter then for j,k in next,dg.filter do if info[j]~=k then bh=false;break end end end;if bh then dg.process.eventQueue[#dg.process.eventQueue+1]={\"debug_break\",{process=process.id,thread=at.id,breakpoint=aD,error=q}}wakeup(dg.process)at.paused=true;da(\"preempt\")end end end end;return q end,...)end;function cN.xpcall(f,dj,...)return xpcall(f,function(q)if process.debugging then local at=getCurrentThread()local info=aY(2)for aD,dg in next,process.breakpoints do if dg.type==\"error\"and(dg.thread==nil or dg.thread==at.id)then local bh=true;if dg.filter then for j,k in next,dg.filter do if info[j]~=k then bh=false;break end end end;if bh then dg.process.eventQueue[#dg.process.eventQueue+1]={\"debug_break\",{process=process.id,thread=at.id,breakpoint=aD,error=q}}wakeup(dg.process)at.paused=true;da(\"preempt\")end end end end;return dj(q)end,...)end;createRequire(process,cN)for j,k in pairs(cN)do if type(k)==\"function\"then pcall(setfenv,k,cN)pcall(debug.protect,k)elseif type(k)==\"table\"and j~=\"debug\"then for B,ah in pairs(k)do if type(ah)==\"function\"then pcall(setfenv,ah,cN)pcall(debug.protect,ah)end end end end;return cN end;function loadfile(g,p,e)if e==nil and type(p)==\"table\"then e,p=p,nil end;if type(g)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(g)..\")\",2)end;if p~=nil and type(p)~=\"string\"then error(\"bad argument #2 (expected string, got \"..type(p)..\")\",2)end;if e~=nil and type(e)~=\"table\"then error(\"bad argument #3 (expected table, got \"..type(e)..\")\",2)end;local a,q=filesystem.open(KERNEL,g,\"rb\")if not a then error(q,2)end;local bk=a.readAll()a.close()return load(bk,\"@\"..g,p,e)end;function dofile(g)if g~=nil and type(g)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(g)..\")\",2)end;local i,q=loadfile(g or io.stdin:read(\"*a\"))if not i then error(q,2)end;return i()end;function print(...)for x=1,select(\"#\",...)do local k=tostring(select(x,...))terminal.write(TTY[1],k)end end;function terminal.makeTTY(term,v,dk)local a7={isTTY=true,flags={cbreak=false,delay=true,echo=true,keypad=false,nlcr=true,raw=false},cursor={x=1,y=1},cursorBlink=true,colors={fg='0',bg='f',bold=false},size={width=v,height=dk},dirtyLines={},palette={},dirtyPalette={},buffer=\"\",preBuffer=\"\",isLocked=false,isGraphics=false,textBuffer={},graphicsBuffer={},frontmostProcess=nil,processList={},eof=false,term=term}for s=1,dk do a7[s]={(' '):rep(v),('0'):rep(v),('f'):rep(v)}a7.dirtyLines[s]=true end;for x=0,15 do a7.palette[x]={_G.term.nativePaletteColor(2^x)}a7.dirtyPalette[x]=true end;return a7 end;do local dl,dm=term.getSize()TTY={terminal.makeTTY(term,dl,dm),terminal.makeTTY(term,dl,dm),terminal.makeTTY(term,dl,dm),terminal.makeTTY(term,dl,dm),terminal.makeTTY(term,dl,dm),terminal.makeTTY(term,dl,dm),terminal.makeTTY(term,dl,dm),terminal.makeTTY(term,dl,dm)}end;currentTTY=TTY[1]terminal.userTTYs={}do local t=args.console:match\"^tty(%d+)$\"if t then KERNEL.stdout,KERNEL.stderr,KERNEL.stdin=TTY[tonumber(t)],TTY[tonumber(t)],TTY[tonumber(t)]end end;keysHeld={ctrl=false,alt=false,shift=false}eventHooks.term_resize=eventHooks.term_resize or{}eventHooks.char=eventHooks.char or{}eventHooks.paste=eventHooks.paste or{}eventHooks.key=eventHooks.key or{}eventHooks.key_up=eventHooks.key_up or{}eventHooks.term_resize[#eventHooks.term_resize+1]=function()local ah,ai=term.getSize()for x=1,8 do terminal.resize(TTY[x],ah,ai)end end;eventHooks.char[#eventHooks.char+1]=function(au)if not currentTTY.isLocked then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer..au[2]else currentTTY.preBuffer=currentTTY.preBuffer..au[2]end;if currentTTY.flags.echo then terminal.write(currentTTY,au[2])terminal.redraw(currentTTY)end end end;eventHooks.paste[#eventHooks.paste+1]=function(au)if not currentTTY.isLocked then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer..au[2]else currentTTY.preBuffer=currentTTY.preBuffer..au[2]end;if currentTTY.flags.echo then terminal.write(currentTTY,au[2])terminal.redraw(currentTTY)end end end;eventHooks.key[#eventHooks.key+1]=function(au)if not currentTTY.isLocked then if au[2]==keys.enter then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer..\"\\n\"else currentTTY.buffer=currentTTY.buffer..currentTTY.preBuffer..\"\\n\"currentTTY.preBuffer=\"\"end;if currentTTY.flags.echo then terminal.write(currentTTY,\"\\n\")terminal.redraw(currentTTY)end elseif au[2]==keys.backspace then if currentTTY.flags.cbreak then elseif#currentTTY.preBuffer>0 then currentTTY.preBuffer=currentTTY.preBuffer:sub(1,-2)if currentTTY.flags.echo then terminal.write(currentTTY,\"\\b \\b\")terminal.redraw(currentTTY)end end end end;if au[2]==keys.leftCtrl or au[2]==keys.rightCtrl then keysHeld.ctrl=true elseif au[2]==keys.leftAlt or au[2]==keys.rightAlt then keysHeld.alt=true elseif au[2]==keys.leftShift or au[2]==keys.rightShift then keysHeld.shift=true end;if not currentTTY.flags.raw and currentTTY.frontmostProcess and keysHeld.ctrl and not keysHeld.alt and not keysHeld.shift then if au[2]==keys.c then killProcess(currentTTY.frontmostProcess.id,2)terminal.write(currentTTY,\"^C\")elseif au[2]==keys.backslash then killProcess(currentTTY.frontmostProcess.id,3)terminal.write(currentTTY,\"^\\\\\")elseif au[2]==keys.z then killProcess(currentTTY.frontmostProcess.id,19)terminal.write(currentTTY,\"^Z\")elseif au[2]==keys.d then currentTTY.eof=true;terminal.write(currentTTY,\"^D\")elseif au[2]==keys.l and currentTTY.cursor.y>1 then local s=currentTTY.cursor.y-1;terminal.write(currentTTY,\"\\x1b[\"..s..\"T\\x1b[1;\"..currentTTY.cursor.x..\"H\")end end;if keysHeld.ctrl and not keysHeld.alt and keysHeld.shift then local dn=true;if au[2]==keys.f1 then currentTTY=TTY[1]elseif au[2]==keys.f2 then currentTTY=TTY[2]elseif au[2]==keys.f3 then currentTTY=TTY[3]elseif au[2]==keys.f4 then currentTTY=TTY[4]elseif au[2]==keys.f5 then currentTTY=TTY[5]elseif au[2]==keys.f6 then currentTTY=TTY[6]elseif au[2]==keys.f7 then currentTTY=TTY[7]elseif au[2]==keys.f8 then currentTTY=TTY[8]elseif au[2]==keys.left then for x=1,8 do if currentTTY==TTY[x]then currentTTY=TTY[(x+7)%8]break end end elseif au[2]==keys.right then for x=1,8 do if currentTTY==TTY[x]then currentTTY=TTY[(x+1)%8]break end end else dn=false end;if dn then terminal.redraw(currentTTY,true)end end end;eventHooks.key_up[#eventHooks.key_up+1]=function(au)if au[2]==keys.leftCtrl or au[2]==keys.rightCtrl then keysHeld.ctrl=false elseif au[2]==keys.leftAlt or au[2]==keys.rightAlt then keysHeld.alt=false elseif au[2]==keys.leftShift or au[2]==keys.rightShift then keysHeld.shift=false end end;function terminal.redraw(dp,c1)if _HEADLESS and dp==TTY[1]and not dp.isLocked then return end;if dp.process then dp.process.eventQueue[#dp.process.eventQueue+1]={\"tty_redraw\",{id=dp.id}}return elseif currentTTY~=dp and not dp.isMonitor then return end;local term=dp.term;local d4=dp;if dp.isLocked then if dp.isGraphics then term.setGraphicsMode(2)if term.setFrozen then term.setFrozen(true)end;if c1 then term.clear()term.drawPixels(0,0,dp.graphicsBuffer)for x=0,255 do term.setPaletteColor(x,dp.graphicsBuffer.palette[x][1],dp.graphicsBuffer.palette[x][2],dp.graphicsBuffer.palette[x][3])end else if dp.graphicsBuffer.frozen then if term.setFrozen then term.setFrozen(false)end;return end;for B,k in ipairs(dp.graphicsBuffer.dirtyRects)do if k.color then term.setPixel(k.x,k.y,k.color,k.width,k.height)else term.drawPixels(k.x,k.y,k)end end;for x in pairs(dp.graphicsBuffer.dirtyPalette)do term.setPaletteColor(x,dp.graphicsBuffer.palette[x][1],dp.graphicsBuffer.palette[x][2],dp.graphicsBuffer.palette[x][3])end end;if term.setFrozen then term.setFrozen(false)end;d4.dirtyRects,d4.dirtyPalette={},{}return end;if term.setGraphicsMode then term.setGraphicsMode(false)end;d4=dp.textBuffer elseif dp.isGraphics then term.setGraphicsMode(false)dp.isGraphics=false end;term.setCursorBlink(false)if c1 then term.clear()for s=1,dp.size.height do term.setCursorPos(1,s)term.blit(d4[s][1],d4[s][2],d4[s][3])end;for x=0,15 do term.setPaletteColor(2^x,d4.palette[x][1],d4.palette[x][2],d4.palette[x][3])end else for s in pairs(d4.dirtyLines)do if not d4[s]then error(debug.traceback(s))end;term.setCursorPos(1,s)if#d4[s][1]~=#d4[s][2]or#d4[s][2]~=#d4[s][3]then syslog.log({level=\"critical\"},\"Bug in text writer! Inequal lengths: \"..#d4[s][1]..\", \"..#d4[s][2]..\", \"..#d4[s][3])error(\"Invalid lengths\")end;term.blit(d4[s][1],d4[s][2],d4[s][3])end;for x in pairs(d4.dirtyPalette)do term.setPaletteColor(2^x,d4.palette[x][1],d4.palette[x][2],d4.palette[x][3])end end;term.setCursorPos(d4.cursor.x,d4.cursor.y)term.setCursorBlink(d4.cursorBlink)term.setTextColor(2^tonumber(d4.colors.fg,16))d4.dirtyLines,d4.dirtyPalette={},{}end;function terminal.resize(dp,v,dk)if v>dp.size.width then for s=1,dp.size.height do dp[s][1]=dp[s][1]..(' '):rep(v-dp.size.width)dp[s][2]=dp[s][2]..dp.colors.fg:rep(v-dp.size.width)dp[s][3]=dp[s][3]..dp.colors.bg:rep(v-dp.size.width)dp.dirtyLines[s]=true end;if dp.isLocked then if dp.isGraphics then for s=1,dp.size.height*9 do dp.graphicsBuffer[s]=dp.graphicsBuffer[s]..('\\15'):rep((v-dp.size.width)*6)end;dp.graphicsBuffer.dirtyRects[#dp.graphicsBuffer.dirtyRects+1]={x=dp.size.width*6+1,y=1,width=(v-dp.size.width)*6,height=dp.size.height*9}else for s=1,dp.size.height do dp.textBuffer[s][1]=dp.textBuffer[s][1]..(' '):rep(v-dp.size.width)dp.textBuffer[s][2]=dp.textBuffer[s][2]..dp.textBuffer.colors.fg:rep(v-dp.size.width)dp.textBuffer[s][3]=dp.textBuffer[s][3]..dp.textBuffer.colors.bg:rep(v-dp.size.width)dp.textBuffer.dirtyLines[s]=true end end end elseif v<dp.size.width then for s=1,dp.size.height do dp[s][1]=dp[s][1]:sub(1,v)dp[s][2]=dp[s][2]:sub(1,v)dp[s][3]=dp[s][3]:sub(1,v)dp.dirtyLines[s]=true end;if dp.isLocked then if dp.isGraphics then for s=1,dp.size.height*9 do dp.graphicsBuffer[s]=dp.graphicsBuffer[s]:sub(1,v*6)end else for s=1,dp.size.height do dp.textBuffer[s][1]=dp.textBuffer[s][1]:sub(1,v)dp.textBuffer[s][2]=dp.textBuffer[s][2]:sub(1,v)dp.textBuffer[s][3]=dp.textBuffer[s][3]:sub(1,v)end end end end;dp.size.width=v;if dk>dp.size.height then for s=dp.size.height+1,dk do dp[s]={(' '):rep(v),dp.colors.fg:rep(v),dp.colors.bg:rep(v)}dp.dirtyLines[s]=true end;if dp.isLocked then if dp.isGraphics then for s=dp.size.height*9+1,dk*9 do dp.graphicsBuffer[s]=('\\15'):rep(v*6)end;dp.graphicsBuffer.dirtyRects[#dp.graphicsBuffer.dirtyRects+1]={x=1,y=dp.size.height*9+1,width=dp.size.width*6,height=(dk-dp.size.height)*9}else for s=dp.size.height+1,dk do dp.textBuffer[s]={(' '):rep(v),dp.textBuffer.colors.fg:rep(v),dp.textBuffer.colors.bg:rep(v)}dp.textBuffer.dirtyLines[s]=true end end end elseif dk<dp.size.height then for s=dk+1,dp.size.height do dp[s]=nil;dp.dirtyLines[s]=nil end;if dp.isLocked then if dp.isGraphics then for s=dk*9+1,dp.size.height*9 do dp.graphicsBuffer[s]=nil end else for s=dk+1,dp.size.height do dp.textBuffer[s]=nil;dp.textBuffer.dirtyLines[s]=nil end end end end;dp.size.height=dk end;local function dq(dp)local dr=dp.cursor;local s=dr.y+1;dr.y=s;local U=dp.size;local dk=U.height;if s>dk then local ds=dp.dirtyLines;for x=1,dk-1 do dp[x]=dp[x+1]ds[x]=true end;local v=U.width;local dt=dp.colors;dp[dk]={(' '):rep(v),dt.fg:rep(v),dt.bg:rep(v)}ds[dk]=true;dr.y=dk end end;local du={['@']=function(dp,ay)local G=ay[1]or 1;if G==0 then G=1 end;local dv,dw=G%dp.size.width,math.floor(G/dp.size.width)local t={dp[dp.cursor.y][1]:sub(dp.size.width-dv+1),dp[dp.cursor.y][2]:sub(dp.size.width-dv+1),dp[dp.cursor.y][3]:sub(dp.size.width-dv+1)}dp[dp.cursor.y][1]=dp[dp.cursor.y][1]:sub(1,dp.cursor.x-1)..(\" \"):rep(G)..dp[dp.cursor.y+dw][1]:sub(dp.cursor.x,dp.size.width-dv)dp[dp.cursor.y][2]=dp[dp.cursor.y][2]:sub(1,dp.cursor.x-1)..dp.colors.fg:rep(G)..dp[dp.cursor.y+dw][2]:sub(dp.cursor.x,dp.size.width-dv)dp[dp.cursor.y][3]=dp[dp.cursor.y][3]:sub(1,dp.cursor.x-1)..dp.colors.bg:rep(G)..dp[dp.cursor.y+dw][3]:sub(dp.cursor.x,dp.size.width-dv)dp.dirtyLines[dp.cursor.y]=true;for s=dp.cursor.y+dw+1,dp.size.height do local dx={dp[s-dw][1]:sub(dp.size.width-G+1),dp[s-dw][2]:sub(dp.size.width-G+1),dp[s-dw][3]:sub(dp.size.width-G+1)}dp[s][1]=t[1]..dp[s-dw][1]:sub(1,dp.size.width-dv)dp[s][2]=t[2]..dp[s-dw][2]:sub(1,dp.size.width-dv)dp[s][3]=t[3]..dp[s-dw][3]:sub(1,dp.size.width-dv)dp.dirtyLines[s]=true;t=dx end;for s=dp.cursor.y+1,dp.cursor.y+dw do dp[s][1]=(\" \"):rep(dp.size.width)dp[s][2]=dp.colors.fg:rep(dp.size.width)dp[s][3]=dp.colors.bg:rep(dp.size.width)dp.dirtyLines[s]=true end end,A=function(dp,ay)local G=ay[1]or 1;if G==0 then G=1 end;dp.cursor.y=math.max(dp.cursor.y-G,1)end,B=function(dp,ay)local G=ay[1]or 1;if G==0 then G=1 end;dp.cursor.y=math.min(dp.cursor.y+G,dp.size.height)end,C=function(dp,ay)local G=ay[1]or 1;if G==0 then G=1 end;dp.cursor.y=dp.cursor.y+math.floor((dp.cursor.x-1+G)/dp.size.width)dp.cursor.x=(dp.cursor.x-1+G)%dp.size.width+1 end,D=function(dp,ay)local G=ay[1]or 1;if G==0 then G=1 end;dp.cursor.y=dp.cursor.y+math.floor((dp.cursor.x-1-G)/dp.size.width)dp.cursor.x=(dp.cursor.x-1-G)%dp.size.width+1 end,E=function(dp,ay)local G=ay[1]or 1;if G==0 then G=1 end;dp.cursor.y=math.min(dp.cursor.y+G,dp.size.height)dp.cursor.x=1 end,F=function(dp,ay)local G=ay[1]or 1;if G==0 then G=1 end;dp.cursor.y=math.max(dp.cursor.y-G,1)dp.cursor.x=1 end,G=function(dp,ay)local G=ay[1]or 1;if G==0 then G=1 end;dp.cursor.x=math.min(G,dp.size.width)end,H=function(dp,ay)local bu,ab=ay[1]or 1,ay[2]or 1;if bu==0 then bu=1 end;if ab==0 then ab=1 end;dp.cursor.x,dp.cursor.y=math.min(ab,dp.size.width),math.min(bu,dp.size.height)end,I=function(dp,ay)end,J=function(dp,ay)local t=ay[1]or 0;if t==0 then dp[dp.cursor.y][1]=dp[dp.cursor.y][1]:sub(1,dp.cursor.x-1)..(\" \"):rep(dp.size.width-dp.cursor.x)dp[dp.cursor.y][2]=dp[dp.cursor.y][2]:sub(1,dp.cursor.x-1)..dp.colors.fg:rep(dp.size.width-dp.cursor.x)dp[dp.cursor.y][3]=dp[dp.cursor.y][3]:sub(1,dp.cursor.x-1)..dp.colors.bg:rep(dp.size.width-dp.cursor.x)dp.dirtyLines[dp.cursor.y]=true;for s=dp.cursor.y+1,dp.size.height do dp[s][1]=(\" \"):rep(dp.size.width)dp[s][2]=dp.colors.fg:rep(dp.size.width)dp[s][3]=dp.colors.bg:rep(dp.size.width)dp.dirtyLines[s]=true end elseif t==1 then dp[dp.cursor.y][1]=(\" \"):rep(dp.cursor.x)..dp[dp.cursor.y][1]:sub(dp.cursor.x)dp[dp.cursor.y][2]=dp.colors.fg:rep(dp.cursor.x)..dp[dp.cursor.y][2]:sub(dp.cursor.x)dp[dp.cursor.y][3]=dp.colors.bg:rep(dp.cursor.x)..dp[dp.cursor.y][3]:sub(dp.cursor.x)dp.dirtyLines[dp.cursor.y]=true;for s=dp.cursor.y-1,1,-1 do dp[s][1]=(\" \"):rep(dp.size.width)dp[s][2]=dp.colors.fg:rep(dp.size.width)dp[s][3]=dp.colors.bg:rep(dp.size.width)dp.dirtyLines[s]=true end elseif t==2 then for s=1,dp.size.height do dp[s][1]=(\" \"):rep(dp.size.width)dp[s][2]=dp.colors.fg:rep(dp.size.width)dp[s][3]=dp.colors.bg:rep(dp.size.width)dp.dirtyLines[s]=true end end end,K=function(dp,ay)local t=ay[1]or 0;if t==0 then dp[dp.cursor.y][1]=dp[dp.cursor.y][1]:sub(1,dp.cursor.x-1)..(\" \"):rep(dp.size.width-dp.cursor.x)dp[dp.cursor.y][2]=dp[dp.cursor.y][2]:sub(1,dp.cursor.x-1)..dp.colors.fg:rep(dp.size.width-dp.cursor.x)dp[dp.cursor.y][3]=dp[dp.cursor.y][3]:sub(1,dp.cursor.x-1)..dp.colors.bg:rep(dp.size.width-dp.cursor.x)dp.dirtyLines[dp.cursor.y]=true elseif t==1 then dp[dp.cursor.y][1]=(\" \"):rep(dp.cursor.x)..dp[dp.cursor.y][1]:sub(dp.cursor.x)dp[dp.cursor.y][2]=dp.colors.fg:rep(dp.cursor.x)..dp[dp.cursor.y][2]:sub(dp.cursor.x)dp[dp.cursor.y][3]=dp.colors.bg:rep(dp.cursor.x)..dp[dp.cursor.y][3]:sub(dp.cursor.x)dp.dirtyLines[dp.cursor.y]=true elseif t==2 then dp[dp.cursor.y][1]=(\" \"):rep(dp.size.width)dp[dp.cursor.y][2]=dp.colors.fg:rep(dp.size.width)dp[dp.cursor.y][3]=dp.colors.bg:rep(dp.size.width)dp.dirtyLines[dp.cursor.y]=true end end,L=function(dp,ay)end,M=function(dp,ay)end,N=function(dp,ay)end,O=function(dp,ay)end,P=function(dp,ay)local G=ay[1]or 1;if G==0 then G=1 end;local dv,dw=G%dp.size.width,math.floor(G/dp.size.width)local t={(\" \"):rep(dv),dp.colors.fg:rep(dv),dp.colors.bg:rep(dv)}for s=dp.size.height-dw,dp.cursor.y+1,-1 do local dx={dp[s+dw][1]:sub(1,dv),dp[s+dw][2]:sub(1,dv),dp[s+dw][3]:sub(1,dv)}dp[s][1]=dp[s+dw][1]:sub(dv+1)..t[1]dp[s][2]=dp[s+dw][2]:sub(dv+1)..t[2]dp[s][3]=dp[s+dw][3]:sub(dv+1)..t[3]dp.dirtyLines[s]=true;t=dx end;for s=dp.size.height-dw+1,dp.size.height do dp[s][1]=(\" \"):rep(dp.size.width)dp[s][2]=dp.colors.fg:rep(dp.size.width)dp[s][3]=dp.colors.bg:rep(dp.size.width)dp.dirtyLines[s]=true end;dp[dp.cursor.y][1]=dp[dp.cursor.y][1]:sub(1,dp.cursor.x-1)..dp[dp.cursor.y+dw][1]:sub(dp.cursor.x+dv,dp.size.width)..t[1]dp[dp.cursor.y][2]=dp[dp.cursor.y][2]:sub(1,dp.cursor.x-1)..dp[dp.cursor.y+dw][2]:sub(dp.cursor.x+dv,dp.size.width)..t[2]dp[dp.cursor.y][3]=dp[dp.cursor.y][3]:sub(1,dp.cursor.x-1)..dp[dp.cursor.y+dw][3]:sub(dp.cursor.x+dv,dp.size.width)..t[3]dp.dirtyLines[dp.cursor.y]=true end,Q=function(dp,ay)end,R=function(dp,ay)end,S=function(dp,ay)local t=ay[1]or 0;if t==0 then t=1 end;for B=1,t do table.insert(dp,1,{(' '):rep(dp.size.width),dp.colors.fg:rep(dp.size.width),dp.colors.bg:rep(dp.size.width)})dp[dp.size.height+1]=nil end;for s=1,dp.size.height do dp.dirtyLines[s]=true end end,T=function(dp,ay)local t=ay[1]or 0;if t==0 then t=1 end;for B=1,t do table.remove(dp,1)dp[dp.size.height]={(' '):rep(dp.size.width),dp.colors.fg:rep(dp.size.width),dp.colors.bg:rep(dp.size.width)}end;for s=1,dp.size.height do dp.dirtyLines[s]=true end end,U=function(dp,ay)end,V=function(dp,ay)end,W=function(dp,ay)end,X=function(dp,ay)end,Y=function(dp,ay)end,Z=function(dp,ay)end,['[']=function(dp,ay)end,['\\\\']=function(dp,ay)end,[']']=function(dp,ay)end,['^']=function(dp,ay)end,['_']=function(dp,ay)end,['`']=function(dp,ay)end,a=function(dp,ay)end,b=function(dp,ay)end,c=function(dp,ay)end,d=function(dp,ay)end,e=function(dp,ay)end,f=function(dp,ay)end,g=function(dp,ay)end,h=function(dp,ay)if ay[1]==25 then dp.cursorBlink=true end end,i=function(dp,ay)end,j=function(dp,ay)end,k=function(dp,ay)end,l=function(dp,ay)if ay[1]==25 then dp.cursorBlink=false end end,m=function(dp,ay)local t,C=ay[1]or 0,ay[2]if t==0 then dp.colors.fg,dp.colors.bg,dp.colors.bold='0','f',false elseif t==1 then dp.colors.bold=true elseif t==7 or t==27 then dp.colors.fg,dp.colors.bg=dp.colors.bg,dp.colors.fg elseif t==22 then dp.colors.bold=false elseif t>=30 and t<=37 then dp.colors.fg=(\"%x\"):format(15-(t-30)-(dp.colors.bold and 8 or 0))elseif t==39 then dp.colors.fg='0'elseif t>=40 and t<=47 then dp.colors.bg=(\"%x\"):format(15-(t-40)-(dp.colors.bold and 8 or 0))elseif t==49 then dp.colors.bg='f'elseif t>=90 and t<=97 then dp.colors.fg=(\"%x\"):format(15-(t-90)-8)elseif t>=100 and t<=107 then dp.colors.bg=(\"%x\"):format(15-(t-100)-8)end;if C~=nil then if C==0 then dp.colors.fg,dp.colors.bg='0','f'elseif C==1 then dp.colors.bold=true elseif C==7 or C==27 then dp.colors.fg,dp.colors.bg=dp.colors.bg,dp.colors.fg elseif C==22 then dp.colors.bold=false elseif C>=30 and C<=37 then dp.colors.fg=(\"%x\"):format(15-(C-30)-(dp.colors.bold and 8 or 0))elseif C==39 then dp.colors.fg='0'elseif C>=40 and C<=47 then dp.colors.bg=(\"%x\"):format(15-(C-40)-(dp.colors.bold and 8 or 0))elseif C==49 then dp.colors.bg='f'elseif C>=90 and C<=97 then dp.colors.fg=(\"%x\"):format(15-(C-90)-8)elseif C>=100 and C<=107 then dp.colors.bg=(\"%x\"):format(15-(C-100)-8)end end end,n=function(dp,ay)end,o=function(dp,ay)end}for x=0x70,0x7F do du[string.char(x)]=function(dp,ay)end end;function terminal.write(dp,dy)if _HEADLESS and dp==TTY[1]then return term.write(dy)end;local aA,U=1,0;local function dz(r)if U==0 then aA,U=r,0;return end;while dp.cursor.x+U>dp.size.width do dp[dp.cursor.y][1]=dp[dp.cursor.y][1]:sub(1,dp.cursor.x-1)..dy:sub(aA,aA+dp.size.width-dp.cursor.x)dp[dp.cursor.y][2]=dp[dp.cursor.y][2]:sub(1,dp.cursor.x-1)..dp.colors.fg:rep(dp.size.width-dp.cursor.x+1)dp[dp.cursor.y][3]=dp[dp.cursor.y][3]:sub(1,dp.cursor.x-1)..dp.colors.bg:rep(dp.size.width-dp.cursor.x+1)dp.dirtyLines[dp.cursor.y]=true;aA=aA+dp.size.width-dp.cursor.x+1;U=U-(dp.size.width-dp.cursor.x+1)dp.cursor.x=1;dq(dp)end;dp[dp.cursor.y][1]=dp[dp.cursor.y][1]:sub(1,dp.cursor.x-1)..dy:sub(aA,aA+U-1)..dp[dp.cursor.y][1]:sub(dp.cursor.x+U)dp[dp.cursor.y][2]=dp[dp.cursor.y][2]:sub(1,dp.cursor.x-1)..dp.colors.fg:rep(U)..dp[dp.cursor.y][2]:sub(dp.cursor.x+U)dp[dp.cursor.y][3]=dp[dp.cursor.y][3]:sub(1,dp.cursor.x-1)..dp.colors.bg:rep(U)..dp[dp.cursor.y][3]:sub(dp.cursor.x+U)dp.dirtyLines[dp.cursor.y]=true;dp.cursor.x=dp.cursor.x+U;aA,U=r,0 end;local dA=0;local ay,dB;for r,ab,t in dy:gmatch\"()(.)()\"do if dA==0 then if ab=='\\a'then dz(t)local dC=hardware.find(\"speaker\")if dC then hardware.call(dC,\"playNote\",\"pling\")end elseif ab=='\\b'then dz(t)if dp.cursor.x==1 then if dp.cursor.y>1 then dp.cursor.x,dp.cursor.y=dp.size.width,dp.cursor.y-1 end else dp.cursor.x=dp.cursor.x-1 end elseif ab=='\\t'then dz(t)dp.cursor.x=math.floor((dp.cursor.x-1)/8)*8+9;if dp.cursor.x>dp.size.width then dp.cursor.x=1;dq(dp)end elseif ab=='\\n'then dz(t)dq(dp)if dp.flags.nlcr then dp.cursor.x=1 end elseif ab=='\\f'then dz(t)dq(dp)elseif ab=='\\r'then dz(t)dp.cursor.x=1 elseif ab=='\\27'then dA=1 else U=U+1 end elseif dA==1 then if false then elseif ab=='['then dA=2;ay,dB={},0 elseif ab==']'then if dy:byte(t)==0x50 then dA=4;ay={}else dA=3;ay,dB={},0 end else dz(t)dA=0 end elseif dA==2 then if ab>='@'and ab<='\\127'then dz(t)ay[#ay+1]=dB;du[ab](dp,ay)dA=0 elseif ab>='0'and ab<='?'then if ab<='9'then dB=dB*10+tonumber(ab)elseif ab==';'then ay[#ay+1],dB=dB,0 end else dz(t)dA=0 end elseif dA==3 then if ab=='\\\\'and dy:byte(r-1)=='\\27'then dz(t)dA=0 end elseif dA==4 then if#ay==0 then ay[1]=tonumber(ab,16)or 0 elseif#ay==1 and not dB then dB=(tonumber(ab,16)or 0)*16 elseif#ay==1 then ay[2],dB=dB+(tonumber(ab,16)or 0),nil elseif#ay==2 and not dB then dB=(tonumber(ab,16)or 0)*16 elseif#ay==2 then ay[3],dB=dB+(tonumber(ab,16)or 0),nil elseif#ay==3 and not dB then dB=(tonumber(ab,16)or 0)*16 elseif#ay==3 then dz(t)ay[4],dB=dB+(tonumber(ab,16)or 0),nil;dp.palette[ay[1]]={ay[2]/255,ay[3]/255,ay[4]/255}dp.dirtyPalette[ay[1]]=true;dA=0 end end end;dz()end;function syscalls.write(process,at,...)if not process.stdout then return end;local function dD(A)if process.stdout.isTTY then terminal.write(process.stdout,A)else process.stdout.write(A)end end;local args=table.pack(...)for x=1,args.n do if x>1 then dD(\"\\t\")end;dD(tostring(args[x]))end;if process.stdout.isTTY then terminal.redraw(process.stdout)end end;function syscalls.writeerr(process,at,...)if not process.stderr then return end;local function dD(A)if process.stderr.isTTY then terminal.write(process.stderr,A)else process.stderr.write(A)end end;local args=table.pack(...)for x=1,args.n do if x>1 then dD(\"\\t\")end;dD(tostring(args[x]))end;if process.stderr.isTTY then terminal.redraw(process.stderr)end end;function syscalls.read(process,at,t)expect(1,t,\"number\")if process.stdin then if process.stdin.eof then process.stdin.eof=false;return nil end;while#process.stdin.buffer<t do if process.stdin.eof then process.stdin.eof=false;return nil end;if process.stdin.isTTY and not process.stdin.flags.delay then return nil end;if process.stdin.read then local bt=process.stdin.read(t-#process.stdin.buffer)if not bt then return nil end;process.stdin.buffer=process.stdin.buffer..bt else return kSyscallYield,\"read\",t end end;local bt=process.stdin.buffer:sub(1,t-1)process.stdin.buffer=process.stdin.buffer:sub(t)return bt else return nil end end;function syscalls.readline(process,at)if process.stdin then if process.stdin.eof then process.stdin.eof=false;return nil end;while not process.stdin.buffer:find(\"\\n\")do if process.stdin.eof then process.stdin.eof=false;return nil end;if process.stdin.isTTY and not process.stdin.flags.delay then return nil end;if process.stdin.read then local bt=process.stdin.read()if not bt then return nil end;process.stdin.buffer=process.stdin.buffer..bt else return kSyscallYield,\"readline\"end end;local t=process.stdin.buffer:find(\"\\n\")local bt=process.stdin.buffer:sub(1,t-1)process.stdin.buffer=process.stdin.buffer:sub(t+1)return bt else return nil end end;function syscalls.termctl(process,at,dE)expect(1,dE,\"table\",\"nil\")if not process.stdout or not process.stdout.isTTY then return nil end;if dE then expect.field(dE,\"cbreak\",\"boolean\",\"nil\")expect.field(dE,\"delay\",\"boolean\",\"nil\")expect.field(dE,\"echo\",\"boolean\",\"nil\")expect.field(dE,\"keypad\",\"boolean\",\"nil\")expect.field(dE,\"nlcr\",\"boolean\",\"nil\")expect.field(dE,\"raw\",\"boolean\",\"nil\")for j,k in pairs(dE)do if process.stdout.flags[j]~=nil then process.stdout.flags[j]=k end end end;local A=deepcopy(process.stdout.flags)A.hasgfx=term.getGraphicsMode~=nil;return A end;function terminal.openterm(dp,process)if dp.isLocked then if not dp.isGraphics and dp.frontmostProcess==process then return dp.screenHandle end;return nil,\"Terminal already in use\"end;local U=dp.size;local d4={cursor={x=1,y=1},cursorBlink=false,colors={fg='0',bg='f'},palette={},dirtyLines={},dirtyPalette={}}dp.textBuffer=d4;dp.isLocked=true;dp.isGraphics=false;for s=1,U.height do d4[s]={(' '):rep(U.width),('0'):rep(U.width),('f'):rep(U.width)}d4.dirtyLines[s]=true end;for x=0,15 do d4.palette[x]={term.nativePaletteColor(2^x)}d4.dirtyPalette[x]=true end;dp.processList[#dp.processList+1]=dp.frontmostProcess;dp.frontmostProcess=process;local dF=setmetatable({},{__name=\"Terminal\"})local dG=terminal.redraw;local expect=expect;dp.screenHandle=dF;function dF.close()if not dF then error(\"terminal is already closed\",2)end;dF=nil;dp.isLocked=false;dp.frontmostProcess=table.remove(dp.processList)dp.screenHandle=nil;dG(dp,true)end;function dF.write(dy)if not dF then error(\"terminal is already closed\",2)end;dy=tostring(dy)expect(1,dy,\"string\")if d4.cursor.y<1 or d4.cursor.y>U.height then return elseif d4.cursor.x>U.width or d4.cursor.x+#dy<1 then d4.cursor.x=d4.cursor.x+#dy;return elseif d4.cursor.x<1 then dy=dy:sub(-d4.cursor.x+2)d4.cursor.x=1 end;local dH=#dy;if d4.cursor.x+#dy>U.width then dy=dy:sub(1,U.width-d4.cursor.x+1)end;d4[d4.cursor.y][1]=d4[d4.cursor.y][1]:sub(1,d4.cursor.x-1)..dy..d4[d4.cursor.y][1]:sub(d4.cursor.x+#dy)d4[d4.cursor.y][2]=d4[d4.cursor.y][2]:sub(1,d4.cursor.x-1)..d4.colors.fg:rep(#dy)..d4[d4.cursor.y][2]:sub(d4.cursor.x+#dy)d4[d4.cursor.y][3]=d4[d4.cursor.y][3]:sub(1,d4.cursor.x-1)..d4.colors.bg:rep(#dy)..d4[d4.cursor.y][3]:sub(d4.cursor.x+#dy)d4.cursor.x=d4.cursor.x+dH;d4.dirtyLines[d4.cursor.y]=true end;function dF.blit(dy,dI,dJ)if not dF then error(\"terminal is already closed\",2)end;dy=tostring(dy)expect(1,dy,\"string\")expect(2,dI,\"string\")expect(3,dJ,\"string\")if#dy~=#dI or#dI~=#dJ then error(\"Arguments must be the same length\",2)end;if d4.cursor.y<1 or d4.cursor.y>U.height then return elseif d4.cursor.x>U.width or d4.cursor.x<1-#dy then d4.cursor.x=d4.cursor.x+#dy;dG(dp)return elseif d4.cursor.x<1 then dy,dI,dJ=dy:sub(-d4.cursor.x+2),dI:sub(-d4.cursor.x+2),dJ:sub(-d4.cursor.x+2)d4.cursor.x=1 end;local dH=#dy;if d4.cursor.x+#dy>U.width then dy,dI,dJ=dy:sub(1,U.width-d4.cursor.x+1),dI:sub(1,U.width-d4.cursor.x+1),dJ:sub(1,U.width-d4.cursor.x+1)end;d4[d4.cursor.y][1]=d4[d4.cursor.y][1]:sub(1,d4.cursor.x-1)..dy..d4[d4.cursor.y][1]:sub(d4.cursor.x+#dy)d4[d4.cursor.y][2]=d4[d4.cursor.y][2]:sub(1,d4.cursor.x-1)..dI..d4[d4.cursor.y][2]:sub(d4.cursor.x+#dI)d4[d4.cursor.y][3]=d4[d4.cursor.y][3]:sub(1,d4.cursor.x-1)..dJ..d4[d4.cursor.y][3]:sub(d4.cursor.x+#dJ)d4.cursor.x=d4.cursor.x+dH;d4.dirtyLines[d4.cursor.y]=true end;function dF.clear()if not dF then error(\"terminal is already closed\",2)end;for s=1,U.height do d4[s]={(' '):rep(U.width),d4.colors.fg:rep(U.width),d4.colors.bg:rep(U.width)}d4.dirtyLines[s]=true end end;function dF.clearLine()if not dF then error(\"terminal is already closed\",2)end;if d4.cursor.y>=1 and d4.cursor.y<=U.height then d4[d4.cursor.y]={(' '):rep(U.width),d4.colors.fg:rep(U.width),d4.colors.bg:rep(U.width)}d4.dirtyLines[d4.cursor.y]=true end end;function dF.getCursorPos()if not dF then error(\"terminal is already closed\",2)end;return d4.cursor.x,d4.cursor.y end;function dF.setCursorPos(dK,dL)if not dF then error(\"terminal is already closed\",2)end;expect(1,dK,\"number\")expect(2,dL,\"number\")if dK==d4.cursor.x and dL==d4.cursor.y then return end;d4.cursor.x,d4.cursor.y=math.floor(dK),math.floor(dL)end;function dF.getCursorBlink()if not dF then error(\"terminal is already closed\",2)end;return d4.cursorBlink end;function dF.setCursorBlink(ad)if not dF then error(\"terminal is already closed\",2)end;expect(1,ad,\"boolean\")d4.cursorBlink=ad end;function dF.isColor()if not dF then error(\"terminal is already closed\",2)end;return true end;function dF.getSize()if not dF then error(\"terminal is already closed\",2)end;return U.width,U.height end;function dF.scroll(dM)if not dF then error(\"terminal is already closed\",2)end;expect(1,dM,\"number\")if math.abs(dM)>=U.width then for s=1,U.height do d4[s]={(' '):rep(U.width),d4.colors.fg:rep(U.width),d4.colors.bg:rep(U.width)}end elseif dM>0 then for x=dM+1,U.height do d4[x]=d4[x-dM]end;for x=U.height-dM+1,U.height do d4[x]={(' '):rep(U.width),d4.colors.fg:rep(U.width),d4.colors.bg:rep(U.width)}end elseif dM<0 then for x=1,U.height+dM do d4[x-dM]=d4[x]end;for x=1,-dM do d4[x]={(' '):rep(U.width),d4.colors.fg:rep(U.width),d4.colors.bg:rep(U.width)}end else return end;for x=1,U.height do d4.dirtyLines[x]=true end end;function dF.getTextColor()if not dF then error(\"terminal is already closed\",2)end;return tonumber(d4.colors.fg,16)end;function dF.setTextColor(dN)if not dF then error(\"terminal is already closed\",2)end;expect(1,dN,\"number\")expect.range(dN,0,15)d4.colors.fg=(\"%x\"):format(dN)end;function dF.getBackgroundColor()if not dF then error(\"terminal is already closed\",2)end;return tonumber(d4.colors.bg,16)end;function dF.setBackgroundColor(dN)if not dF then error(\"terminal is already closed\",2)end;expect(1,dN,\"number\")expect.range(dN,0,15)d4.colors.bg=(\"%x\"):format(dN)end;function dF.getPaletteColor(dN)if not dF then error(\"terminal is already closed\",2)end;expect(1,dN,\"number\")expect.range(dN,0,15)return table.unpack(d4.palette[math.floor(dN)])end;function dF.setPaletteColor(dN,bu,dO,ad)if not dF then error(\"terminal is already closed\",2)end;expect(1,dN,\"number\")expect(2,bu,\"number\")if dO==nil and ad==nil then bu,dO,ad=bit32.band(bit32.rshift(bu,16),0xFF)/255,bit32.band(bit32.rshift(bu,8),0xFF)/255,bit32.band(bu,0xFF)/255 end;expect(3,dO,\"number\")expect(4,ad,\"number\")expect.range(dN,0,15)if bu<0 or bu>1 then error(\"bad argument #2 (value out of range)\",2)end;if dO<0 or dO>1 then error(\"bad argument #3 (value out of range)\",2)end;if ad<0 or ad>1 then error(\"bad argument #4 (value out of range)\",2)end;d4.palette[math.floor(dN)]={bu,dO,ad}d4.dirtyPalette[math.floor(dN)]=true end;function dF.getLine(s)if not dF then error(\"terminal is already closed\",2)end;expect(1,s,\"number\")local P=d4[s]if P then return table.unpack(P,1,3)end end;local dP=term.nativePaletteColor;function dF.nativePaletteColor(dN)expect(1,dN,\"number\")expect.range(dN,0,15)return dP(2^dN)end;for B,k in pairs(dF)do setfenv(k,process.env)debug.protect(k)end;dF.isColour=dF.isColor;dF.getTextColour=dF.getTextColor;dF.setTextColour=dF.setTextColor;dF.getBackgroundColour=dF.getBackgroundColor;dF.setBackgroundColour=dF.setBackgroundColor;dF.getPaletteColour=dF.getPaletteColor;dF.setPaletteColour=dF.setPaletteColor;dF.nativePaletteColour=dF.nativePaletteColor;process.dependents[#process.dependents+1]={gc=function()if dF then return dF.close()end end}dG(dp,true)return dF end;function syscalls.openterm(process,at)if not process.stdout or not process.stdout.isTTY then return nil,\"No valid TTY attached\"end;if process~=process.stdout.frontmostProcess then syscalls.kill(KERNEL,nil,process.id,22)if process.paused then return kSyscallYield,\"openterm\"end end;return terminal.openterm(process.stdout,process)end;function terminal.opengfx(dp,process)if not term.drawPixels then return nil,\"Graphics mode not supported\"end;if dp.isLocked then if dp.isGraphics and dp.frontmostProcess==process then return dp.screenHandle end;return nil,\"Terminal already in use\"end;local U=dp.size;local d4={palette={},dirtyRects={},dirtyPalette={},frozen=false}dp.graphicsBuffer=d4;dp.isLocked=true;dp.isGraphics=true;for s=1,U.height*9 do d4[s]=('\\15'):rep(U.width*6)end;for x=0,15 do d4.palette[x]={term.nativePaletteColor(2^x)}d4.dirtyPalette[x]=true end;for x=16,255 do d4.palette[x]={0,0,0}d4.dirtyPalette[x]=true end;dp.processList[#dp.processList+1]=dp.frontmostProcess;dp.frontmostProcess=process;local dF=setmetatable({},{__name=\"GFXTerminal\"})local dG=terminal.redraw;local expect=expect;dp.screenHandle=dF;function dF.close()if not dF then error(\"terminal is already closed\",2)end;dF=nil;dp.isLocked=false;dp.frontmostProcess=table.remove(dp.processList)dp.screenHandle=nil;dG(dp,true)end;function dF.getSize()return U.width*6,U.height*9 end;function dF.clear()if not dF then error(\"terminal is already closed\",2)end;for s=1,U.height*9 do d4[s]=('\\15'):rep(U.width*6)end;dG(dp,true)end;function dF.getPixel(r,s)if not dF then error(\"terminal is already closed\",2)end;expect(1,r,\"number\")expect(2,s,\"number\")expect.range(r,0,U.width*6-1)expect.range(s,0,U.height*9-1)r,s=math.floor(r),math.floor(s)return d4[s+1]:byte(r+1)end;function dF.setPixel(r,s,dN)if not dF then error(\"terminal is already closed\",2)end;expect(1,r,\"number\")expect(2,s,\"number\")expect(3,dN,\"number\")expect.range(r,0,U.width*6-1)expect.range(s,0,U.height*9-1)expect.range(dN,0,255)r,s=math.floor(r),math.floor(s)d4[s+1]=d4[s+1]:sub(1,r)..string.char(dN)..d4[s+1]:sub(r+2)d4.dirtyRects[#d4.dirtyRects+1]={x=r,y=s,color=dN}end;function dF.getPixels(r,s,v,dk,dQ)if not dF then error(\"terminal is already closed\",2)end;expect(1,r,\"number\")expect(2,s,\"number\")expect(3,v,\"number\")expect(4,dk,\"number\")expect(5,dQ,\"boolean\",\"nil\")expect.range(v,0)expect.range(dk,0)r,s=math.floor(r),math.floor(s)local A={}for dR=1,dk do if dQ then A[dR]=d4[s+dR]:sub(r+1,r+v)else A[dR]={d4[s+dR]:sub(r+1,r+v):byte(1,-1)}end end;return A end;function dF.drawPixels(r,s,bk,v,dk)if not dF then error(\"terminal is already closed\",2)end;expect(1,r,\"number\")expect(2,s,\"number\")expect(3,bk,\"table\",\"number\")local dS=type(bk)==\"number\"expect(4,v,\"number\",not dS and\"nil\"or nil)expect(5,dk,\"number\",not dS and\"nil\"or nil)expect.range(r,0,U.width*6-1)expect.range(s,0,U.height*9-1)if v then expect.range(v,0)end;if dk then expect.range(dk,0)end;if dS then expect.range(bk,0,255)end;if v==0 or dk==0 then return end;r,s=math.floor(r),math.floor(s)if v and r+v>=U.width*6 then v=U.width*6-r end;dk=dk or#bk;local dT={x=r,y=s,width=v,height=dk}for dR=1,dk do if s+dR>U.height*9 then break end;if dS then local bt=string.char(bk):rep(v)d4[s+dR]=d4[s+dR]:sub(1,r)..bt..d4[s+dR]:sub(r+v+1)dT[dR]=bt elseif bk[dR]~=nil then if type(bk[dR])~=\"table\"and type(bk[dR])~=\"string\"then error(\"bad argument #3 to 'drawPixels' (invalid row \"..dR..\")\",2)end;local v=v or#bk[dR]if r+v>=U.width*6 then v=U.width*6-r end;local bt;if type(bk[dR])==\"string\"then bt=bk[dR]if#bt<v then bt=bt..('\\15'):rep(v-#bt)elseif#bt>v then bt=bt:sub(1,v)end else bt=\"\"for dU=1,v do bt=bt..string.char(bk[dR][dU]or d4[s+dR]:byte(r+dU))end end;d4[s+dR]=d4[s+dR]:sub(1,r)..bt..d4[s+dR]:sub(r+v+1)dT[dR]=bt end end;d4.dirtyRects[#d4.dirtyRects+1]=dT end;function dF.getFrozen()if not dF then error(\"terminal is already closed\",2)end;return d4.frozen end;function dF.setFrozen(f)if not dF then error(\"terminal is already closed\",2)end;expect(1,f,\"boolean\")d4.frozen=f end;function dF.getPaletteColor(dN)if not dF then error(\"terminal is already closed\",2)end;expect(1,dN,\"number\")expect.range(dN,0,255)return table.unpack(d4.palette[dN])end;function dF.setPaletteColor(dN,bu,dO,ad)if not dF then error(\"terminal is already closed\",2)end;expect(1,dN,\"number\")expect(2,bu,\"number\")if dO==nil and ad==nil then bu,dO,ad=bit32.band(bit32.rshift(bu,16),0xFF)/255,bit32.band(bit32.rshift(bu,8),0xFF)/255,bit32.band(bu,0xFF)/255 end;expect(3,dO,\"number\")expect(4,ad,\"number\")expect.range(bu,0,1)expect.range(dO,0,1)expect.range(ad,0,1)expect.range(dN,0,255)d4.palette[dN]={bu,dO,ad}d4.dirtyPalette[dN]=true end;local dP=term.nativePaletteColor;function dF.nativePaletteColor(dN)expect(1,dN,\"number\")expect.range(dN,0,15)return dP(2^dN)end;for B,k in pairs(dF)do setfenv(k,process.env)debug.protect(k)end;dF.getPaletteColour=dF.getPaletteColor;dF.setPaletteColour=dF.setPaletteColor;dF.nativePaletteColour=dF.nativePaletteColor;process.dependents[#process.dependents+1]={gc=function()if dF then return dF.close()end end}dG(dp,true)return dF end;function syscalls.opengfx(process,at)if not process.stdout or not process.stdout.isTTY then return nil,\"No valid TTY attached\"end;if process~=process.stdout.frontmostProcess then syscalls.kill(KERNEL,nil,process.id,22)if process.paused then return kSyscallYield,\"openterm\"end end;return terminal.opengfx(process.stdout,process)end;function syscalls.mktty(process,at,v,dk)expect(1,v,\"number\")expect(2,dk,\"number\")expect.range(v,1)expect.range(dk,1)local dp=terminal.makeTTY(term,v,dk)dp.id=math.random(0,0x7FFFFFFF)dp.process=process;local aE={__index=dp,__metatable={__name=\"TTY\"}}local a7=setmetatable({},aE)local do_syscall=do_syscall;function a7.sendEvent(cd,d1)return do_syscall(\"__ttyevent\",a7,cd,d1)end;function a7.write(dy)return do_syscall(\"__ttyevent\",a7,\"paste\",tostring(dy))end;debug.protect(a7.sendEvent)debug.protect(a7.write)aE.__newindex=function()error(\"cannot modify TTY\",2)end;terminal.userTTYs[a7]=dp;process.dependents[#process.dependents+1]={gc=function()terminal.userTTYs[a7]=nil end}return a7 end;function syscalls.__ttyevent(process,at,dV,cd,d1)expect(1,dV,\"table\")expect(2,cd,\"string\")expect(3,d1,\"table\")local dp=terminal.userTTYs[dV]if not dp then error(\"Invalid TTY\")end;if dp.process~=process then error(\"Invalid TTY\")end;if not dp.frontmostProcess then return end;if cd==\"key\"then expect.field(d1,\"keycode\",\"number\")expect.field(d1,\"isRepeat\",\"boolean\")dp.frontmostProcess.eventQueue[#dp.frontmostProcess.eventQueue+1]={\"key\",{keycode=d1.keycode,isRepeat=d1.isRepeat,ctrlHeld=keysHeld.ctrl,altHeld=keysHeld.alt,shiftHeld=keysHeld.shift}}if not dp.isLocked then if d1.keycode==10 then if dp.flags.cbreak then dp.buffer=dp.buffer..\"\\n\"else dp.buffer=dp.buffer..dp.preBuffer..\"\\n\"dp.preBuffer=\"\"end;if dp.flags.echo then terminal.write(dp,\"\\n\")terminal.redraw(dp)end elseif d1.keycode==8 then if dp.flags.cbreak then elseif#dp.preBuffer>0 then dp.preBuffer=dp.preBuffer:sub(1,-2)if dp.flags.echo then terminal.write(dp,\"\\b \\b\")terminal.redraw(dp)end end end end elseif cd==\"key_up\"then expect.field(d1,\"keycode\",\"number\")dp.frontmostProcess.eventQueue[#dp.frontmostProcess.eventQueue+1]={\"key_up\",{keycode=d1.keycode,ctrlHeld=keysHeld.ctrl,altHeld=keysHeld.alt,shiftHeld=keysHeld.shift}}elseif cd==\"char\"then expect.field(d1,\"character\",\"string\")dp.frontmostProcess.eventQueue[#dp.frontmostProcess.eventQueue+1]={\"char\",{character=d1.character}}if not dp.isLocked then if dp.flags.cbreak then dp.buffer=dp.buffer..d1.character else dp.preBuffer=dp.preBuffer..d1.character end;if dp.flags.echo then terminal.write(dp,d1.character)terminal.redraw(dp)end end elseif cd==\"paste\"then expect.field(d1,\"text\",\"string\")dp.frontmostProcess.eventQueue[#dp.frontmostProcess.eventQueue+1]={\"paste\",{text=d1.text}}if not dp.isLocked then if dp.flags.cbreak then dp.buffer=dp.buffer..d1.text else dp.preBuffer=dp.preBuffer..d1.text end;if dp.flags.echo then terminal.write(dp,d1.text)terminal.redraw(dp)end end elseif cd==\"mouse_click\"or cd==\"mouse_up\"or cd==\"mouse_drag\"then expect.field(d1,\"x\",\"number\")expect.field(d1,\"y\",\"number\")expect.field(d1,\"button\",\"number\")dp.frontmostProcess.eventQueue[#dp.frontmostProcess.eventQueue+1]={cd,{x=d1.x,y=d1.y,button=d1.button,buttonMask=0}}elseif cd==\"mouse_scroll\"then expect.field(d1,\"x\",\"number\")expect.field(d1,\"y\",\"number\")expect.field(d1,\"direction\",\"number\")dp.frontmostProcess.eventQueue[#dp.frontmostProcess.eventQueue+1]={cd,{x=d1.x,y=d1.y,button=d1.direction}}else error(\"Invalid event\")end;wakeup(dp.frontmostProcess)end;function syscalls.capture(process,at)local bo=process.stdin;if not bo or not bo.isTTY then return end;bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process end;function syscalls.release(process,at)local bo=process.stdin;if not bo or not bo.isTTY then return end;if bo.frontmostProcess==process then bo.frontmostProcess=table.remove(bo.processList)else local dW=nil;for x=#bo.processList,1,-1 do if bo.processList[x]==process then if dW then table.remove(bo.processList,dW)break else dW=x end end end end end;function syscalls.stdin(process,at,bo)expect(1,bo,\"number\",\"table\",\"string\",\"nil\")if process.stdin and process.stdin.isTTY and process.stdin.frontmostProcess==process then process.stdin.preBuffer=\"\"end;if type(bo)==\"number\"then bo=TTY[bo]if bo and process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process;if discord and process.stdin==currentTTY then discord(\"Phoenix\",\"Executing \"..process.name)end end;process.stdin=bo elseif type(bo)==\"string\"then local dX=hardware.get(bo)if not dX then error(\"bad argument #1 (no such device)\",2)end;if not dX.internalState.tty then error(\"bad argument #1 (no TTY available on device)\",2)end;bo=dX.internalState.tty;if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process end;process.stdin=bo elseif bo==nil then if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)end;process.stdin=nil else if bo.isTTY then bo=terminal.userTTYs[bo]if not bo then error(\"bad argument #1 (invalid TTY)\",2)end;if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process;bo.preBuffer=\"\"end else expect.field(bo,\"read\",\"function\")local bn=bo.read;bo={buffer=\"\",read=function(...)local bh,w=userModeCallback(process,bn,...)if bh then return w else error(w,2)end end}end;process.stdin=bo end end;function syscalls.stdout(process,at,bo)expect(1,bo,\"number\",\"table\",\"string\",\"nil\")if process.stdout and process.stdout.isTTY and process.stdout.frontmostProcess==process then if discord and process.stdout==currentTTY then discord(\"Phoenix\",\"Executing \"..process.stdout.frontmostProcess.name)end end;if type(bo)==\"number\"then bo=TTY[bo]if bo and process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process;if discord and process.stdout==currentTTY then discord(\"Phoenix\",\"Executing \"..process.name)end end;process.stdout=bo elseif type(bo)==\"string\"then local dX=hardware.get(bo)if not dX then error(\"bad argument #1 (no such device)\",2)end;if not dX.internalState.tty then error(\"bad argument #1 (no TTY available on device)\",2)end;bo=dX.internalState.tty;if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process;if discord and process.stdout==currentTTY then discord(\"Phoenix\",\"Executing \"..process.name)end end;process.stdout=bo elseif bo==nil then if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)if discord and process.stdout==currentTTY then discord(\"Phoenix\",\"Executing \"..process.name)end end;process.stdout=nil else if bo.isTTY then bo=terminal.userTTYs[bo]if not bo then error(\"bad argument #1 (invalid TTY)\",2)end;if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process;if discord and process.stdout==currentTTY then discord(\"Phoenix\",\"Executing \"..process.name)end end else expect.field(bo,\"write\",\"function\")local dD=bo.write;bo={write=function(...)local bh,w=userModeCallback(process,dD,...)if bh then return w else error(w,2)end end}end;process.stdout=bo end end;function syscalls.stderr(process,at,bo)expect(1,bo,\"number\",\"table\",\"string\",\"nil\")if process.stderr and process.stderr.isTTY and process.stderr.frontmostProcess==process then end;if type(bo)==\"number\"then bo=TTY[bo]if bo and process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process;if discord and process.stderr==currentTTY then discord(\"Phoenix\",\"Executing \"..process.name)end end;process.stderr=bo elseif type(bo)==\"string\"then local dX=hardware.get(bo)if not dX then error(\"bad argument #1 (no such device)\",2)end;if not dX.internalState.tty then error(\"bad argument #1 (no TTY available on device)\",2)end;bo=dX.internalState.tty;if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process end;process.stderr=bo elseif bo==nil then if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)end;process.stderr=nil else if bo.isTTY then bo=terminal.userTTYs[bo]if not bo then error(\"bad argument #1 (invalid TTY)\",2)end;if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process end else expect.field(bo,\"write\",\"function\")local dD=bo.write;bo={write=function(...)local bh,w=userModeCallback(process,dD,...)if bh then return w else error(w,2)end end}end;process.stderr=bo end end;function syscalls.istty(process,at)return process.stdin and process.stdin.isTTY,process.stdout and process.stdout.isTTY end;function syscalls.termsize(process,at)if not process.stdout or not process.stdout.isTTY then return nil,nil end;return process.stdout.size.width,process.stdout.size.height end;syslogs={default={stream={},tty=KERNEL.stdout,tty_level=args.loglevel,colorize=true}}local dY={[0]=\"Debug\",\"Info\",\"Notice\",\"Warning\",\"Error\",\"Critical\",\"Panic\"}local dZ={}for x=0,#dY do dZ[dY[x]:lower()]=x end;local d_={[0]='\\27[90m','\\27[97m','\\27[36m','\\27[93m','\\27[31m','\\27[95m','\\27[96m'}local function e0(A,ao,x,ac)if x>=ac then return tostring(A[x])else return tostring(A[x])..ao..e0(A,ao,x+1,ac)end end;function syscalls.syslog(process,at,bK,...)local args=table.pack(...)if type(bK)==\"table\"then expect.field(bK,\"name\",\"string\",\"nil\")expect.field(bK,\"category\",\"string\",\"nil\")expect.field(bK,\"level\",\"number\",\"string\",\"nil\")expect.field(bK,\"time\",\"number\",\"nil\")expect.field(bK,\"process\",\"number\",\"nil\")expect.field(bK,\"thread\",\"number\",\"nil\")expect.field(bK,\"module\",\"string\",\"nil\")expect.field(bK,\"traceback\",\"boolean\",\"nil\")if type(bK.level)==\"string\"then bK.level=dZ[bK.level:lower()]if not bK.level then error(\"bad field 'level' (invalid name)\",0)end elseif bK.level and(bK.level<0 or bK.level>#dY)then error(\"bad field 'level' (level out of range)\",0)end;bK.name=bK.name or\"default\"bK.process=bK.process or process.id;bK.thread=bK.thread or at and at.id;bK.level=bK.level or 1;bK.time=bK.time or os.epoch\"utc\"else local t=args.n;table.insert(args,1,bK)args.n=t+1;bK={process=process.id,thread=at and at.id,level=1,name=\"default\",time=os.epoch\"utc\"}end;local e1=syslogs[bK.name]if e1==nil then error(\"No such log named \"..bK.name,0)end;local ag;for x=1,args.n do ag=(x==1 and\"\"or ag..\" \")..serialize(args[x])end;if e1.file then e1.file.write((\"[%s]%s %s[%d%s]%s [%s]: %s\\n\"):format(os.date(\"%b %d %X\",bK.time/1000),bK.category and\" <\"..bK.category..\">\"or\"\",processes[bK.process]and processes[bK.process].name or\"(unknown)\",bK.process,bK.thread and\":\"..bK.thread or\"\",bK.module and\" (\"..bK.module..\")\"or\"\",dY[bK.level],e0(args,\" \",1,args.n)))e1.file.flush()end;if e1.stream then bK.message=ag;for B,k in pairs(e1.stream)do local bh=true;if k.filter then local o,e2,aG=\"\"local x=1;local e3,e4=false,false;while x<#k.filter do if e2==nil then o,x=k.filter:match(\"(%a+)%s*()\",x)if bK[o]==nil then bh=false;break end;e2=\"\"elseif aG==nil then local b7=k.filter:sub(x,x+1)if b7==\"==\"or b7==\"!=\"or b7==\"=%\"or b7==\"!%\"or b7==\"<=\"or b7==\">=\"then e2=b7 elseif b7==\"~=\"then e2=\"!=\"elseif b7==\"~%\"then e2=\"!%\"elseif k.filter:sub(x,x)=='<'or k.filter:sub(x,x)=='>'then e2=k.filter:sub(x,x)else bh=false;break end;aG=\"\"else local ab=k.filter:sub(x,x)if e3 then if ab==e3 and not e4 then e3,e4=false,false else aG=aG..ab;if not e4 and ab=='\\\\'then e4=true else e4=false end end elseif ab=='\"'or ab==\"'\"then e3=ab elseif ab=='|'or ab==';'then if e2==\"==\"and bK[o]==aG or e2==\"!=\"and bK[o]~=aG or e2==\"=%\"and bK[o]:match(aG)or e2==\"!%\"and not bK[o]:match(aG)or e2==\"<\"and(tonumber(bK[o])or 0)<(tonumber(aG)or 0)or e2==\"<=\"and(tonumber(bK[o])or 0)<=(tonumber(aG)or 0)or e2==\">=\"and(tonumber(bK[o])or 0)>=(tonumber(aG)or 0)or e2==\">\"and(tonumber(bK[o])or 0)>(tonumber(aG)or 0)then if ab=='|'then x=k.filter:match(\"[^;]*;+()\",x)if x==nil then break end;x=x-1 end;o,e2,aG=\"\"e3,e4=false,false else bh=ab=='|'aG=\"\"if not bh then break end end elseif not(ab==' 'and aG==\"\")then aG=aG..ab end;x=x+1 end end;if e3 then bh=false;break end end;if bh then local process=processes[k.pid]if process then process.eventQueue[#process.eventQueue+1]={\"syslog\",deepcopy(bK)}end end end end;if e1.tty and e1.tty_level<=bK.level then if e1.tty.isTTY then local a2=e0(args,\" \",1,args.n)if e1.colorize and bK.traceback then a2=a2:gsub(\"\\t\",\"  \"):gsub(\"([^\\n]+):(%d+):\",\"\\27[96m%1\\27[37m:\\27[95m%2\\27[37m:\"):gsub(\"'([^']+)'\\n\",\"\\27[93m'%1'\\27[37m\\n\")end;terminal.write(e1.tty,(\"%s[%s]%s %s[%d%s]%s [%s]: %s%s\\n\"):format(e1.colorize and d_[bK.level]or\"\",os.date(\"%b %d %X\",bK.time/1000),bK.category and\" <\"..bK.category..\">\"or\"\",processes[bK.process]and processes[bK.process].name or\"(unknown)\",bK.process,bK.thread and\":\"..bK.thread or\"\",bK.module and\" (\"..bK.module..\")\"or\"\",dY[bK.level],a2,e1.colorize and\"\\27[0m\"or\"\"))terminal.redraw(e1.tty)else end end end;function syscalls.mklog(process,at,o,e5,g)expect(1,o,\"string\")expect(2,e5,\"boolean\",\"nil\")expect(3,g,\"string\",\"nil\")if syslogs[o]then return end;syslogs[o]={}if g then local q;syslogs[o].file,q=filesystem.open(process,g,\"a\")if syslogs[o].file==nil then syslogs[o]=nil;return error(\"Could not open log file: \"..q,0)end end;if e5 then syslogs[o].stream={}end end;function syscalls.rmlog(process,at,o)expect(1,o,\"string\")if o==\"default\"then error(\"Cannot delete default log\",0)end;if not syslogs[o]then error(\"Log does not exist\",0)end;if syslogs[o].stream then for B,k in pairs(syslogs[o].stream)do processes[k.pid].eventQueue[#processes[k.pid].eventQueue+1]={\"syslog_close\",{id=k.id}}processes[k.pid].dependents[k.id]=nil;wakeup(processes[k.pid])end end;syslogs[o]=nil end;function syscalls.openlog(process,at,o,e6)expect(1,o,\"string\")expect(2,e6,\"string\",\"nil\")if not syslogs[o]then error(\"Log does not exist\",0)end;if not syslogs[o].stream then error(\"Log does not have streaming enabled\",0)end;local aD=#process.dependents+1;local cZ=process.id;process.dependents[aD]={type=\"log\",name=o,filter=e6,gc=function()for x,k in pairs(syslogs[o].stream)do if k.id==aD and k.pid==cZ then syslogs[o].stream[x]=nil end end end}syslogs[o].stream[#syslogs[o].stream+1]={pid=cZ,id=aD,filter=e6}return aD end;function syscalls.closelog(process,at,o)expect(1,o,\"string\",\"number\")if type(o)==\"string\"then if not syslogs[o]then error(\"Log does not exist\",0)end;if not syslogs[o].stream then error(\"Log does not have streaming enabled\",0)end;for x,k in pairs(syslogs[o].stream)do if k.pid==process.id then process.dependents[k.id]=nil;syslogs[o].stream[x]=nil end end else if not process.dependents[o]then error(\"Log connection does not exist\",0)end;local e1=syslogs[process.dependents[o].name].stream;for x,k in pairs(e1)do if k.pid==process.id and k.id==o then process.dependents[k.id]=nil;e1[x]=nil;break end end end end;function syscalls.logtty(process,at,o,dp,b3)if process.user~=\"root\"then error(\"Permission denied\",0)end;expect(1,o,\"string\")expect(2,dp,\"table\",\"number\",\"nil\")expect(3,b3,\"number\",\"nil\")if not syslogs[o]then error(\"Log does not exist\",0)end;syslogs[o].tty=type(dp)==\"table\"and dp or TTY[dp]syslogs[o].tty_level=b3;return true end;function syslog.log(bK,...)return pcall(syscalls.syslog,KERNEL,nil,bK,...)end;function syslog.debug(...)return pcall(syscalls.syslog,KERNEL,nil,{level=\"debug\",process=0},...)end;local e7=panic;function panic(ag)xpcall(function()TTY[1].isLocked=false;syslog.log({level=\"panic\"},\"Kernel panic:\",ag)if debug then local ak=debug.traceback(nil,2)syslog.log({level=\"panic\",traceback=true},ak)end;syslog.log({level=\"panic\"},\"We are hanging here...\")terminal.redraw(TTY[1],true)term.setCursorBlink(false)mainThread=nil;if _HEADLESS then os.shutdown(1)end;while true do coroutine.yield()end end,function(C)e7(ag..\"; and an error occurred while logging the error: \"..C)end)end;xpcall(function()local q;syslogs.default.file,q=filesystem.open(KERNEL,\"/var/log/default.log\",\"a\")shutdownHooks[#shutdownHooks+1]=function()if syslogs.default.file then syslogs.default.file.close()end end;syslog.log(\"Starting Phoenix version\",PHOENIX_VERSION,PHOENIX_BUILD)syslog.log(\"Initialized system logger\")syslog.log(\"System started at \"..systemStartTime..\" on computer \"..os.computerID()..(os.computerLabel()and\"('\"..os.computerLabel()..\"')\"or\"\"))syslog.log(\"Computer host is \".._HOST)if syslogs.default.file==nil then syslog.log({level=\"notice\"},\"An error occurred while opening the log file at /var/log/default.log:\",q,\". System logs will not be saved to disk.\")end end,panic)local function e8(bt)return string.match(bt,'^()%s*$')and''or string.match(bt,'^%s*(.*%S)')end;local expect,do_syscall=expect,do_syscall;local function e9(bk)local a9=1;local function bn(ab)if a9>#bk then return nil end;ab=ab or 1;local bt=bk:sub(a9,a9+ab-1)a9=a9+ab;return bt end;if bn(8)~=\"!<arch>\\n\"then error(\"Not an ar archive\",2)end;local a7={}local ea=nil;local eb={}while true do local bk={}local ec=bn()while ec==\"\\n\"do ec=bn()end;if ec==nil then break end;local o=bn(15)if o==nil then break end;o=ec..o;if string.find(o,\"/\")and string.find(o,\"/\")>1 then o=string.sub(o,1,string.find(o,\"/\")-1)else o=e8(o)end;bk.timestamp=tonumber(e8(bn(12)))bk.owner=tonumber(e8(bn(6)))bk.group=tonumber(e8(bn(6)))bk.mode=tonumber(e8(bn(8)),8)local U=tonumber(e8(bn(10)))if bn(2)~=\"`\\n\"then error(\"Invalid header for file \"..o,2)end;if string.match(o,\"^#1/%d+$\")then o=bn(tonumber(string.match(o,\"#1/(%d+)\")))elseif string.match(o,\"^/%d+$\")then if ea then local t=tonumber(string.match(o,\"/(%d+)\"))o=ea:match(\"[^/]*\",t+1)else table.insert(eb,o)end end;bk.name=o;bk.data=bn(U)if o==\"//\"then ea=bk.data elseif o~=\"/\"and o~=\"/SYM64/\"then table.insert(a7,bk)end end;if ea then for j,k in pairs(eb)do local t=tonumber(string.match(k,\"/(%d+)\"))for P,ah in pairs(a7)do if ah.name==k then ah.name=ea:match(\"[^/]*\",t+1)break end end end end;local ed={}for B,k in ipairs(a7)do ed[k.name]=k end;return ed end;function createRequire(process,cN)local ee,ef={},{}cN.package={}local eg=processes[process.parent]and processes[process.parent].env;if eg then cN.package.path=eg.package and eg.package.path;cN.package.libpath=eg.package and eg.package.libpath end;cN.package.path=cN.package.path or\"/lib/?.lua;/lib/?/init.lua;/usr/lib/?.lua;/usr/lib/?/init.lua;./?.lua;./?/init.lua\"if type(process.vars.PACKAGE_PATH)==\"string\"then cN.package.path=process.vars.PACKAGE_PATH..';'..cN.package.path end;cN.package.libpath=cN.package.libpath or\"/lib/lib?.a;/usr/lib/lib?.a\"if type(process.vars.PACKAGE_LIBPATH)==\"string\"then cN.package.libpath=process.vars.PACKAGE_LIBPATH..';'..cN.package.libpath end;cN.package.config=\"/\\n;\\n?\\n!\\n-\"cN.package.loaded=ee;cN.package.preload=ef;cN.package.forceload=false;for j,k in pairs(cN)do if type(k)==\"table\"then ee[j]=k end end;local eh=setmetatable({},{__newindex=function()end,__metatable=false})local ei={}local function ej(o,g)local a,q=do_syscall(\"open\",g,\"rb\")if not a then error(g..\": \"..q,3)end;local bk=a.readAll()a.close()local i,q=load(bk,\"@\"..g,nil,_ENV)if not i then error(g..\": \"..q,3)end;local ce=g:match(\"^(.*)/[^/]*$\")or\"/\"ei[#ei+1]=function(ek)local g,q=package.searchpath(ek,ce..\"/?.lua;\"..ce..\"/?/init.lua\")if not g then return nil,q end;return ej,g end;local bh,w=pcall(i,o)ei[#ei]=nil;if bh then return w else error(g..\": \"..w,3)end end;local function el(o,g)local em;if g:find\"%z\"then g,em=g:match\"^([^%z]*)%z(.*)$\"elseif o:find\"%-\"then em=o:match(\"^([^%-]*)%-(.*)$\")else em=\"init\"end;local a,q=do_syscall(\"open\",g,\"rb\")if not a then error(g..\": \"..q,3)end;local bk=a.readAll()a.close()local ce=e9(bk)local function en(o)local G=o..\".lua\"if not ce[G]then error(g..\":\"..G..\": File not found\",0)end;local bk=ce[G].data;local i,q=load(bk,\"@\"..g..\":\"..G,nil,_ENV)if not i then error(g..\":\"..G..\": \"..q,3)end;local bh,w=pcall(i,o)if bh then return w else error(g..\":\"..G..\": \"..w)end end;ei[#ei+1]=function(ek)return en,ek end;local w=en(em)ei[#ei]=nil;return w end;ei[1]=function(o)local ce=do_syscall(\"getname\"):match(\"^(.*)/[^/]*$\")or\"/\"local g,q=package.searchpath(o,ce..\"/?.lua;\"..ce..\"/?/init.lua\")if not g then return nil,q end;return ej,g end;function cN.package.searchpath(o,g,ao,eo)expect(1,o,\"string\")expect(2,g,\"string\")expect(3,ao,\"string\",\"nil\")expect(4,eo,\"string\",\"nil\")ao=(ao or\".\"):gsub(\"([%^%$%(%)%%%.%[%]%*%+%-%?])\",\"%%%1\")eo=(eo or\"/\"):gsub(\"([%^%$%(%)%%%.%[%]%*%+%-%?])\",\"%%%1\")local ep=\"\"for G in g:gmatch\"[^;]+\"do local cg=G:gsub(\"%?\",o:gsub(ao,eo),nil)local a,q=do_syscall(\"open\",cg,\"r\")if a then a.close()return cg else ep=ep..\"\\t\"..cg..\": \"..q..\"\\n\"end end;return nil,ep end;cN.package.searchers={function(o)local G=ef[o]if G then return G else return nil,\"\\tpackage.preload['\"..o..\"']: No such field\\n\"end end,function(o)local g,q=package.searchpath(o,package.path)if not g then return nil,q end;return ej,g,g end,function(o)local g,q=package.searchpath(o:match(\"^[^%-]*\"),package.libpath)if not g then return nil,q end;local t=o:match(\"%-(.+)$\")if t then return el,g,g..\":\"..t else return el,g,g..\":init\"end end,function(o)if not o:find\"%.\"then return nil end;local g,q=package.searchpath(o:match(\"^[^%.]*\"),package.libpath)if not g then return nil,q end;local t=o:match(\"^[^%.]*%.(.*)$\")return el,g..\"\\0\"..t,g..\":\"..t end,function(o)if#ei>0 then return ei[#ei](o)end;return nil,\"no local loaders found\"end}setfenv(ej,cN)debug.protect(ej)setfenv(el,cN)debug.protect(el)setfenv(ei[1],cN)debug.protect(ei[1])for B,k in pairs(cN.package.searchers)do setfenv(k,cN)debug.protect(k)end;function cN.require(o)expect(1,o,\"string\")local q=\"module '\"..o..\"' not found:\\n\"local eq,er,es;for B,k in ipairs(package.searchers)do eq,er,es=k(o)if eq then break end;q=q..(er or\"\")end;if not eq then error(q,2)end;if es then if ee[es]then if ee[es]==eh then error(\"loop detected loading '\"..o..\"'\",3)elseif not package.forceload then return ee[es]end end;ee[es]=eh else if ee[o]then if ee[o]==eh then error(\"loop detected loading '\"..o..\"'\",3)elseif not package.forceload then return ee[o]end end end;ee[o]=eh;local bh,w=pcall(eq,o,er)if bh then if w~=nil then ee[o]=w elseif ee[o]==eh then ee[o]=true end;if es then if w~=nil then ee[es]=w elseif ee[es]==eh then ee[es]=true end end;return ee[o]else ee[o]=nil;if es then ee[es]=nil end;error(q..\"\\t\"..w..\"\\n\",2)end end;return cN end;do local ee,ef={},{}package={}package.path=\"/lib/?.lua;/lib/?/init.lua;/usr/lib/?.lua;/usr/lib/?/init.lua\"package.libpath=\"/lib/lib?.a;/usr/lib/lib?.a\"package.config=\"/\\n;\\n?\\n!\\n-\"package.loaded=ee;package.preload=ef;package.forceload=false;for j,k in pairs(_G)do if type(k)==\"table\"then ee[j]=k end end;local eh=setmetatable({},{__newindex=function()end,__metatable=false})local ei={}local function ej(o,g)local bL,q=filesystem.stat(KERNEL,g)if not bL then error(g..\": \"..q,3)end;if bL.owner~=\"root\"or bL.worldPermissions.write then error(g..\": Insecure file permissions\",3)end;for j,k in pairs(bL.permissions)do if j~=\"root\"and k.write then error(g..\": Insecure file permissions\",3)end end;local a,q=filesystem.open(KERNEL,g,\"rb\")if not a then error(g..\": \"..q,3)end;local bk=a.readAll()a.close()local i,q=load(bk,\"@\"..g,nil,_G)if not i then error(g..\": \"..q,3)end;local ce=g:match(\"^(.*)/[^/]*$\")or\"/\"ei[#ei+1]=function(ek)local g,q=package.searchpath(ek,ce..\"/?.lua;\"..ce..\"/?/init.lua\")if not g then return nil,q end;return ej,g end;local bh,w=pcall(i,o)ei[#ei]=nil;if bh then return w else error(g..\": \"..w,3)end end;local function el(o,g)local em;if g:find\"%z\"then g,em=g:match\"^([^%z]*)%z(.*)$\"elseif o:find\"%-\"then em=o:match(\"^([^%-]*)%-(.*)$\")else em=\"init\"end;local bL,q=filesystem.stat(KERNEL,g)if not bL then error(g..\": \"..q,3)end;if bL.owner~=\"root\"or bL.worldPermissions.write then error(g..\": Insecure file permissions\",3)end;for j,k in pairs(bL.permissions)do if j~=\"root\"and k.write then error(g..\": Insecure file permissions\",3)end end;local a,q=filesystem.open(KERNEL,g,\"rb\")if not a then error(g..\": \"..q,3)end;local bk=a.readAll()a.close()local ce=e9(bk)local function en(o)local G=o..\".lua\"if not ce[G]then error(g..\":\"..G..\": File not found\",0)end;local bk=ce[G].data;local i,q=load(bk,\"@\"..g..\":\"..G,nil,_ENV)if not i then error(g..\":\"..G..\": \"..q,3)end;local bh,w=pcall(i,o)if bh then return w else error(g..\":\"..G..\": \"..w)end end;ei[#ei+1]=function(ek)return en,ek end;local w=en(em)ei[#ei]=nil;return w end;function package.searchpath(o,g,ao,eo)expect(1,o,\"string\")expect(2,g,\"string\")expect(3,ao,\"string\",\"nil\")expect(4,eo,\"string\",\"nil\")ao=(ao or\".\"):gsub(\"([%^%$%(%)%%%.%[%]%*%+%-%?])\",\"%%%1\")eo=(eo or\"/\"):gsub(\"([%^%$%(%)%%%.%[%]%*%+%-%?])\",\"%%%1\")local ep=\"\"for G in g:gmatch\"[^;]+\"do local cg=G:gsub(\"%?\",o:gsub(ao,eo),nil)local a,q=filesystem.open(KERNEL,cg,\"r\")if a then a.close()return cg else ep=ep..\"\\t\"..cg..\": \"..q..\"\\n\"end end;return nil,ep end;package.searchers={function(o)local G=ef[o]if G then return G else return nil,\"\\tpackage.preload['\"..o..\"']: No such field\\n\"end end,function(o)local g,q=package.searchpath(o,package.path)if not g then return nil,q end;return ej,g,g end,function(o)local g,q=package.searchpath(o:match(\"^[^%-]*\"),package.libpath)if not g then return nil,q end;local t=o:match(\"%-(.+)$\")if t then return el,g,g..\":\"..t else return el,g,g..\":init\"end end,function(o)if not o:find\"%.\"then return nil end;local g,q=package.searchpath(o:match(\"^[^%.]*\"),package.libpath)if not g then return nil,q end;local t=o:match(\"^[^%.]*%.(.*)$\")return el,g..\"\\0\"..t,g..\":\"..t end,function(o)if#ei>0 then return ei[#ei](o)end;return nil,\"\\tno local loaders found\"end}function require(o)expect(1,o,\"string\")local q=\"module '\"..o..\"' not found:\\n\"local eq,er,es;for B,k in ipairs(package.searchers)do eq,er,es=k(o)if eq then break end;q=q..(er or\"\")end;if not eq then error(q,2)end;if es then if ee[es]then if ee[es]==eh then error(\"loop detected loading '\"..o..\"'\",3)elseif not package.forceload then return ee[es]end end;ee[es]=eh else if ee[o]then if ee[o]==eh then error(\"loop detected loading '\"..o..\"'\",3)elseif not package.forceload then return ee[o]end end end;ee[o]=eh;local bh,w=pcall(eq,o,er)if bh then if w~=nil then ee[o]=w elseif ee[o]==eh then ee[o]=true end;if es then if w~=nil then ee[es]=w elseif ee[es]==eh then ee[es]=true end end;return ee[o]else ee[o]=nil;if es then ee[es]=nil end;error(q..\"\\t\"..w..\"\\n\",2)end end end;timerMap={}alarmMap={}local et={}function syscalls.kill(process,at,cZ,eu)expect(1,cZ,\"number\")expect(2,eu,\"number\")local ev=processes[cZ]if not ev then error(\"No such process\",2)end;if process.user~=\"root\"and process.user~=ev.user then error(\"Permission denied\",2)end;if eu==9 then reap_process(ev)if processes[ev.parent]then syscalls.queueEvent(processes[ev.parent],nil,\"process_complete\",{id=cZ,result=9})end;processes[cZ]=nil elseif ev.signalHandlers[eu]then userModeCallback(ev,ev.signalHandlers[eu],eu)else syscalls.queueEvent(ev,nil,\"signal\",{signal=eu})end end;function killProcess(cZ,eu)expect(1,cZ,\"number\")expect(2,eu,\"number\")local ev=processes[cZ]if not ev then return end;if eu==9 then reap_process(ev)if processes[ev.parent]then syscalls.queueEvent(processes[ev.parent],nil,\"process_complete\",{id=cZ,result=9})end;processes[cZ]=nil elseif ev.signalHandlers[eu]then local aD=syscalls.newthread(ev,nil,ev.signalHandlers[eu],eu)ev.threads[aD].name=\"<signal handler:\"..eu..\">\"else syscalls.queueEvent(ev,nil,\"signal\",{signal=eu})end end;function syscalls.signal(process,at,eu,ew)expect(1,eu,\"number\")expect(2,ew,\"function\",\"nil\")process.signalHandlers[eu]=ew end;function syscalls.queueEvent(process,at,o,ay)expect(1,o,\"string\")expect(2,ay,\"table\")process.eventQueue[#process.eventQueue+1]={o,ay}end;function syscalls.sendEvent(process,at,cZ,o,ay)expect(1,cZ,\"number\")expect(2,o,\"string\")local ev=processes[cZ]if not ev then return false end;ev.eventQueue[#ev.eventQueue+1]={\"remote_event\",{type=o,sender=process.id,data=ay}}wakeup(ev)return true end;function syscalls.peekEvent(process,at)local au=process.eventQueue[#process.eventQueue]if not au then return nil end;local args={}for j,k in pairs(au[2])do args[j]=k end;return au[1],args end;function syscalls.register(process,at,o)expect(1,o,\"string\")if et[o]then return false end;et[o]=process.id;process.dependents[#process.dependents+1]={gc=function()et[o]=nil end}return true end;function syscalls.lookup(process,at,o)expect(1,o,\"string\")return et[o]end;function syscalls.timer(process,at,ex)expect(1,ex,\"number\")local ey=os.startTimer(ex)timerMap[ey]=process;return bit32.band(ey,0x7FFFFFFF)end;function syscalls.alarm(process,at,ex)expect(1,ex,\"number\")local ey=os.setAlarm(ex)alarmMap[ey]=process;return bit32.bor(ey,0x80000000)end;function syscalls.cancel(process,at,ey)expect(1,ey,\"number\")if bit32.btest(ey,0x80000000)then ey=bit32.band(ey,0x7FFFFFFF)if alarmMap[ey]~=process then error(\"No such alarm\")end;os.cancelAlarm(ey)alarmMap[ey]=nil else if timerMap[ey]~=process then error(\"No such timer\")end;os.cancelTimer(ey)timerMap[ey]=nil end end;eventHooks.terminate=eventHooks.terminate or{}eventHooks.terminate[#eventHooks.terminate+1]=function()if currentTTY.frontmostProcess then syscalls.kill(KERNEL,nil,currentTTY.frontmostProcess.id,2)terminal.write(currentTTY,\"^T\")end end;eventParameterMap={alarm={\"id\"},char={\"character\"},key={\"keycode\",\"isRepeat\"},key_up={\"keycode\"},mouse_click={\"button\",\"x\",\"y\"},mouse_drag={\"button\",\"x\",\"y\"},mouse_up={\"button\",\"x\",\"y\"},mouse_scroll={\"direction\",\"x\",\"y\"},paste={\"text\"},redstone={},term_resize={},timer={\"id\"},turtle_inventory={}}do local ez=0;for B,k in pairs(keys)do if type(k)==\"number\"then ez=math.max(ez,k)end end;local bv;local eA,eB=pcall(string.dump,function()end)if eA then local eC=(function(r)if r<8 then return r end;local M=0;while r>=128 do r,M=bit32.rshift(r+0xf,4),M+4 end;while r>=16 do r,M=bit32.rshift(r+1,1),M+1 end;return bit32.bor((M+1)*8,r-8)end)(ez)syslog.debug(\"Key table sizes:\",ez,eC)if _VERSION==\"Lua 5.1\"then bv=eB:sub(1,12)..(\"I\"..eB:byte(9)..\"IIBBBBIIIIIIII\"):pack(0,0,0,0,0,0,1,2,eC*0x800000+10,0x0100001E,0,0,0,0,0)elseif _VERSION==\"Lua 5.2\"then bv=eB:sub(1,18)..(\"IIBBBIIIIIIIIII\"):pack(0,0,0,0,1,2,eC*0x800000+11,0x0100001F,0,0,0,0,0,0,0)elseif _VERSION==\"Lua 5.3\"then bv=eB:sub(1,17+(\"jn\"):packsize())..(\"BBIIBBBIIIIIIIII\"):pack(0,0,0,0,0,0,1,2,eC*0x800000+11,0x01000026,0,0,0,0,0,0)elseif _VERSION==\"Lua 5.4\"then bv=eB:sub(1,15+(\"jn\"):packsize())..(\"BBBBBBBBIIIBBBBBBB\"):pack(0,0x80,0x80,0x80,0,0,1,0x83,0x00000013,ez*0x80+82,0x00008048,0x80,0x80,0x80,0x80,0x80,0x80,0x80)end;if bv then local i,q=load(bv,nil,\"b\")if i then keymap=i()else syslog.debug(\"Could not load key table code:\",q)end end end;if not keymap then keymap=load(\"return {\"..(\"nil,\"):rep(ez)..\"}\")()end;for x=0x61,0x7A do keymap[keys[string.char(x)]]=x end;for x=0x81,0x99 do if keys[\"f\"..bit32.band(x,31)]then keymap[keys[\"f\"..bit32.band(x,31)]]=x end end;for x=0xA0,0xA9 do keymap[keys[\"numPad\"..bit32.band(x,15)]]=x end;keymap[keys.backspace]=0x08;keymap[keys.tab]=0x09;keymap[keys.enter or keys[\"return\"]]=0x0A;keymap[keys.space]=0x20;keymap[keys.apostrophe]=0x27;keymap[keys.comma]=0x2C;keymap[keys.minus]=0x2D;keymap[keys.period]=0x2E;keymap[keys.slash]=0x2F;keymap[keys.zero]=0x30;keymap[keys.one]=0x31;keymap[keys.two]=0x32;keymap[keys.three]=0x33;keymap[keys.four]=0x34;keymap[keys.five]=0x35;keymap[keys.six]=0x36;keymap[keys.seven]=0x37;keymap[keys.eight]=0x38;keymap[keys.nine]=0x39;keymap[keys.semicolon or keys.semiColon]=0x3B;keymap[keys.equals]=0x3D;keymap[keys.leftBracket]=0x5B;keymap[keys.backslash]=0x5C;keymap[keys.rightBracket]=0x5D;keymap[keys.grave]=0x60;keymap[keys.delete]=0x7F;keymap[keys.insert]=0x80;if keys.convert then keymap[keys.convert]=0x9A end;if keys.noconvert then keymap[keys.noconvert]=0x9B end;if keys.kana then keymap[keys.kana]=0x9C end;if keys.kanji then keymap[keys.kanji]=0x9D end;if keys.yen then keymap[keys.yen]=0x9E end;keymap[keys.numPadDecimal]=0x9F;keymap[keys.numPadAdd]=0xAA;keymap[keys.numPadSubtract]=0xAB;if keys.numPadMultiply then keymap[keys.numPadMultiply]=0xAC end;keymap[keys.numPadDivide]=0xAD;keymap[keys.numPadEqual or keys.numPadEquals]=0xAE;keymap[keys.numPadEnter]=0xAF;keymap[keys.leftCtrl]=0xB0;keymap[keys.rightCtrl]=0xB1;keymap[keys.leftAlt]=0xB2;keymap[keys.rightAlt]=0xB3;keymap[keys.leftShift]=0xB4;keymap[keys.rightShift]=0xB5;if keys.leftSuper then keymap[keys.leftSuper]=0xB6 end;if keys.rightSuper then keymap[keys.rightSuper]=0xB7 end;keymap[keys.capsLock]=0xB8;keymap[keys.numLock]=0xB9;keymap[keys.scrollLock or keys.scollLock]=0xBA;if keys.printScreen then keymap[keys.printScreen]=0xBB end;keymap[keys.pause]=0xBC;if keys.menu then keymap[keys.menu]=0xBD end;if keys.stop then keymap[keys.stop]=0xBE end;if keys.ax then keymap[keys.ax]=0xBF end;keymap[keys.up]=0xC0;keymap[keys.down]=0xC1;keymap[keys.left]=0xC2;keymap[keys.right]=0xC3;keymap[keys.pageUp]=0xC4;keymap[keys.pageDown]=0xC5;keymap[keys.home]=0xC6;keymap[keys[\"end\"]]=0xC7;if keys.circumflex or keys.cimcumflex then keymap[keys.circumflex or keys.cimcumflex]=0xC8 end;if keys.at then keymap[keys.at]=0xC9 end;if keys.colon then keymap[keys.colon]=0xCA end;if keys.underscore then keymap[keys.underscore]=0xCB end end;local eD={id=0,name=\"\",coro=coroutine.create(function()end),coroStack={},status=\"starting\",args={\"a\",n=1},filter=function(process,at,cd)end,paused=false}local eE={id=1,name=\"init\",user=\"root\",dependents={{gc=function()end}},parent=0,dir=\"/\",stdin=TTY[1],stdout={},stderr=TTY[1],cputime=0.2,systime=0.1,debugging=false,allowDebug=true,debugger=nil,breakpoints={},hookf=function()end,env={},syscallyield=nil,eventQueue={},signalHandlers={},paused=false,nice=0,threads={[0]=eD},globalMetatables={}}local eF=1;local function eG(process)local e=createLuaLib(process)if _VERSION<\"Lua 5.2\"then e=make_ENV(e)end;e._G=e;return e end;local eH,eI,debugHooks=coroutine.yield,coroutine.running,debugHooks;local function eJ(cd,al)if cd==\"count\"then eH(\"preempt\")end;local ai=debugHooks[eI()]if ai then if cd==\"count\"and not ai.count then return end;return ai.func(cd,al)end end;local eK={load}function addProcessLoader(eq)table.insert(eK,1,eq)end;function removeProcessLoader(eq)for x,k in ipairs(eK)do if k==eq then table.remove(eK,x)return end end end;function reap_process(process)syslog.debug(\"Reaping process \"..process.id..\" (\"..process.name..\")\")for B,k in ipairs(process.dependents)do k:gc()end;if process.stdin and process.stdin.isTTY then if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)process.stdin.preBuffer=\"\"if discord and process.stdout==currentTTY and process.stdout.frontmostProcess then discord(\"Phoenix\",\"Executing \"..process.stdout.frontmostProcess.name)end else for x,k in ipairs(process.stdin.processList)do if k==process then table.remove(process.stdin.processList,x)break end end end end;if process.stdout and process.stdout.isTTY then if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)else for x,k in ipairs(process.stdout.processList)do if k==process then table.remove(process.stdout.processList,x)break end end end end;if process.stderr and process.stderr.isTTY then if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)else for x,k in ipairs(process.stderr.processList)do if k==process then table.remove(process.stderr.processList,x)break end end end end end;function syscalls.getpid(process,at)return process.id end;function syscalls.getppid(process,at)return process.parent end;function syscalls.clock(process,at)return process.cputime end;function syscalls.getenv(process,at)return process.vars end;function syscalls.getfenv(process,at)return process.env end;function syscalls.getname(process,at)return process.name end;function syscalls.getcwd(process,at)return process.dir end;function syscalls.chdir(process,at,ce)expect(1,ce,\"string\")local bL=filesystem.stat(process,ce)if not bL or bL.type~=\"directory\"then return false,\"No such file or directory\"elseif not(bL.permissions[process.user]or bL.worldPermissions).execute then return false,\"Permission denied\"end;process.dir=ce:gsub(\"^([^/])\",\"/\"..process.dir..\"/%1\")return true end;function syscalls.getuser(process,at)return process.user,process.realuser end;function syscalls.setuser(process,at,bG)expect(1,bG,\"string\")if process.user~=\"root\"then error(\"Permission denied\")end;process.user=bG;process.realuser=nil end;local function eL(cN)return{[\"nil\"]={},[\"boolean\"]={__unm=function()end},[\"number\"]={},[\"string\"]={__index=cN.string},[\"function\"]={},[\"thread\"]={__index=cN.coroutine,__call=cN.coroutine.resume},[\"userdata\"]={}}end;function syscalls.fork(process,at,aC,o,...)expect(1,aC,\"function\")expect(2,o,\"string\",\"nil\")local aD=eF;eF=eF+1;processes[aD]={id=aD,name=o or process.name,user=process.user,dependents={},parent=process.id,dir=process.dir,env=nil,root=process.root,stdin=process.stdin,stdout=process.stdout,stderr=process.stderr,vars=deepcopy(process.vars),cputime=0,systime=0,debugging=false,allowDebug=true,breakpoints={},hookf=eJ,quantum=args.quantum,syscallyield=nil,eventQueue={},globalMetatables=nil,signalHandlers={[1]=function()return coroutine.yield(\"syscall\",\"exit\",1)end,[2]=function()return coroutine.yield(\"syscall\",\"exit\",1)end,[3]=function()coroutine.yield(\"syscall\",\"syslog\",{level=\"error\",category=\"Application Error\",traceback=true},debug.traceback(\"Quit\"))return coroutine.yield(\"syscall\",\"exit\",1)end,[6]=function(q)coroutine.yield(\"syscall\",\"syslog\",{level=\"error\",category=\"Application Error\",traceback=true},debug.traceback(q or\"Aborted\"))return coroutine.yield(\"syscall\",\"exit\",1)end,[13]=function()return coroutine.yield(\"syscall\",\"exit\",1)end,[15]=function()return coroutine.yield(\"syscall\",\"exit\",1)end,[19]=function()return coroutine.yield(\"syscall\",\"suspend\")end,[21]=function()return coroutine.yield(\"syscall\",\"suspend\")end,[22]=function()return coroutine.yield(\"syscall\",\"suspend\")end},paused=false,nice=0,threads={[0]={id=0,name=\"<main thread>\",coro=coroutine.create(aC),syscall=coroutine.create(function(...)local args=table.pack(...)while true do args=table.pack(coroutine.yield(kSyscallComplete,xpcall(syscalls[args[1]],debug.traceback,table.unpack(args,2,args.n))))end end),status=\"starting\",args=table.pack(...),filter=nil,coroStack=nil,paused=false}}}processes[aD].threads[0].coroStack={processes[aD].threads[0].coro}processes[aD].env=eG(processes[aD])processes[aD].globalMetatables=eL(processes[aD].env)setfenv(aC,processes[aD].env)if process.stdin and process.stdin.isTTY and not process.stdin.isLocked then process.stdin.processList[#process.stdin.processList+1]=process.stdin.frontmostProcess;process.stdin.frontmostProcess=processes[aD]process.stdin.preBuffer=\"\"if discord and process.stdout==currentTTY then discord(\"Phoenix\",\"Executing \"..process.name)end end;if process.stdout and process.stdout.isTTY and not process.stdout.isLocked and process.stdout.frontmostProcess~=processes[aD]then process.stdout.processList[#process.stdout.processList+1]=process.stdout.frontmostProcess;process.stdout.frontmostProcess=processes[aD]end;if process.stderr and process.stderr.isTTY and not process.stderr.isLocked and process.stderr.frontmostProcess~=processes[aD]then process.stderr.processList[#process.stderr.processList+1]=process.stderr.frontmostProcess;process.stderr.frontmostProcess=processes[aD]end;if args.preemptive then debug.sethook(processes[aD].threads[0].coro,eJ,\"\",processes[aD].quantum)end;return aD end;function syscalls.exec(process,at,g,...)expect(1,g,\"string\")local a,q=filesystem.open(process,g,\"r\")if not a then g=g..\".lua\"a,q=filesystem.open(process,g,\"r\")if not a then error(\"Could not open file: \"..q,0)end end;local eM=a.readAll()a.close()if eM:find(\"[%z\\1-\\31]\")then a,q=filesystem.open(process,g,\"rb\")if not a then error(\"Could not open file: \"..q,0)end;eM=a.readAll()a.close()end;local bL=assert(filesystem.stat(process,g))if not(bL.permissions[bL.owner]or bL.worldPermissions).execute then error(\"Could not execute file: Permission denied\",0)end;if bL.setuser then process.realuser,process.user=process.user,bL.owner end;if eM:sub(1,2)==\"#!\"then local eN=eM:sub(3,eM:find(\"\\n\")-1)local args,x={},0;for bt in eN:gmatch\"%S+\"do args[x]=bt;x=x+1 end;args[x],x=g,x+1;for B,k in ipairs{...}do args[x]=k;x=x+1 end;if args[0]==g then error(\"Recursive path detected while resolving shebang\",0)end;syscalls.exec(process,at,args[0],table.unpack(args,1,x))process.name=\"/\"..fs.combine(g:sub(1,1)==\"/\"and\"\"or process.dir,g)else local aC,q;for B,eq in ipairs(eK)do aC,q=eq(eM,\"@\"..g,\"bt\",process.env)if aC then break end end;if not aC then error(\"Could not execute file: \"..q,0)end;process.name=\"/\"..fs.combine(g:sub(1,1)==\"/\"and\"\"or process.dir,g)process.threads={[0]={id=0,name=\"<main thread>\",coro=coroutine.create(aC),syscall=coroutine.create(function(...)local args=table.pack(...)while true do args=table.pack(coroutine.yield(kSyscallComplete,xpcall(syscalls[args[1]],debug.traceback,table.unpack(args,2,args.n))))end end),status=\"starting\",args=table.pack(...),filter=nil}}process.threads[0].coroStack={process.threads[0].coro}if args.preemptive then debug.sethook(process.threads[0].coro,process.hookf,process.debugging and\"crl\"or\"\",process.quantum)end end;if discord and process.stdin and process.stdin.isTTY and process.stdin.frontmostProcess==process then discord(\"Phoenix\",\"Executing \"..process.name)end end;function syscalls.newthread(process,at,aC,...)expect(1,aC,\"function\")local aD=#process.threads+1;process.threads[aD]={id=aD,name=\"<thread:\"..aD..\">\",coro=coroutine.create(aC),syscall=coroutine.create(function(...)local args=table.pack(...)while true do args=table.pack(coroutine.yield(kSyscallComplete,xpcall(syscalls[args[1]],debug.traceback,table.unpack(args,2,args.n))))end end),status=\"starting\",args=table.pack(...),filter=nil,coroStack=nil,paused=false}setfenv(aC,process.env)process.threads[aD].coroStack={process.threads[aD].coro}if args.preemptive then debug.sethook(process.threads[aD].coro,process.hookf,process.debugging and\"crl\"or\"\",process.quantum)end;return aD end;function syscalls.exit(process,at,bv)process.lastReturnValue={pid=process.id,thread=at.id,value=bv,n=1,bv}for B,at in pairs(process.threads)do at.status=\"dead\"at.return_value=bv end end;function syscalls.atexit(process,at,i)expect(1,i,\"function\")process.dependents[#process.dependents+1]={gc=function()local aD=syscalls.newthread(process,nil,i)local x=0;while process.threads[aD]and process.threads[aD].coro:status()==\"suspended\"and x<100 do executeThread(process,process.threads[aD],{n=0},false,false)x=x+1 end end}end;function syscalls.getplist(process,at)local eO={}for j in pairs(processes)do eO[#eO+1]=j end;table.sort(eO)return eO end;function syscalls.getpinfo(process,at,cZ)expect(1,cZ,\"number\")local G=processes[cZ]if not G then return nil,\"No such process\"end;local eP,eQ,eR;for x,k in ipairs(TTY)do if G.stdin==k then eP=x end;if G.stdout==k then eQ=x end;if G.stderr==k then eR=x end end;local eS={}if G.threads then for x,k in pairs(G.threads)do eS[x]={id=k.id,name=k.name,status=k.status,paused=k.pause or false}end end;return{id=G.id,name=G.name,user=G.user,realuser=G.realuser,parent=G.parent,dir=G.dir,stdin=eP,stdout=eQ,stderr=eR,cputime=G.cputime or 0,systime=G.systime or 0,threads=eS,allowDebug=G.allowDebug,debugging=G.debugging}end;function syscalls.suspend(process,at)process.paused=true end;function syscalls.nice(process,at,b3,cZ)expect(1,b3,\"number\")expect.range(b3,-20,20)expect(2,cZ,\"number\",\"nil\")if b3<0 and process.user~=\"root\"then error(\"Permission denied\",0)end;local ev=cZ and assert(processes[cZ],\"Invalid process ID\")or process;if ev.user~=process.user and process.user~=\"root\"then error(\"Permission denied\",0)end;ev.nice=b3;ev.quantum=args.quantum*10^(b3/-10)if args.preemptive then for B,A in pairs(ev.threads)do debug.sethook(A.coro,eJ,\"\",ev.quantum)end end end;local function eT(process)local eU,next,eV,getCurrentThread,wakeup=string.find,next,debug.getinfo,getCurrentThread,wakeup;local function eW(cd,al)if cd==\"count\"then eH(\"preempt\")end;local info=eV(2)local at=getCurrentThread()for aD,dg in next,process.breakpoints do if dg.type==cd or dg.type==\"call\"and cd==\"tail call\"then local bh=dg.thread==nil or dg.thread==at.id;if dg.filter then for j,k in next,dg.filter do if info[j]~=k then bh=false;break end end end;if bh then dg.process.eventQueue[#dg.process.eventQueue+1]={\"debug_break\",{process=process.id,thread=at.id,breakpoint=aD}}wakeup(dg.process)at.paused=true;eH(\"preempt\")break end end end;while at.pendingExec do local w=table.pack(pcall(at.pendingExec))w.ok=table.remove(w,1)w.n=w.n-1;if not w.ok then w.error=w[1]end;w.process=process.id;w.thread=at.id;local eX=at.pendingExecProcess.eventQueue;eX[#eX+1]={\"debug_exec_result\",w}wakeup(at.pendingExecProcess)at.pendingExec,at.pendingExecProcess=nil;at.paused=true;eH(\"preempt\")end;local ai=debugHooks[eI()]if ai then if cd==\"count\"and not ai.count or(cd==\"call\"or cd==\"tail call\")and not eU(ai.mask,\"c\")or cd==\"return\"and not eU(ai.mask,\"r\")or cd==\"line\"and not eU(ai.mask,\"l\")then return end;return ai.func(cd,al)end end;setfenv(eW,process.env)debug.protect(eW)process.hookf=eW;for B,k in pairs(process.threads)do for B,ah in ipairs(k.coroStack)do debug.sethook(ah,eW,\"clr\",process.quantum)end end end;local function eY(process)for B,k in pairs(process.threads)do k.paused=false;for B,ah in ipairs(k.coroStack)do local ai=debugHooks[ah]debug.sethook(ah,eJ,ai and ai.mask or\"\",process.quantum)end end;process.hookf=eJ end;function syscalls.debug_enable(process,at,cZ,cs)expect(1,cZ,\"number\",\"nil\")expect(2,cs,\"boolean\")local G;if cZ==process.id or cZ==nil then G=process;process.allowDebug=cs else G=processes[cZ]if not G then error(\"No such process\")end;if not G.allowDebug or G.user~=process.user and process.user~=\"root\"then error(\"Permission denied\")end end;if G.debugging~=cs then if cs then eT(G)else eY(G)end end;G.debugging=cs;if cs and G~=process then G.debugger=process end end;function syscalls.debug_break(process,at,cZ,eZ)if cZ==nil then if not process.debugger or not processes[process.debugger.id]then return end;process.debugger.eventQueue[#process.debugger.eventQueue+1]={\"debug_break\",{process=process.id,thread=at.id}}wakeup(process.debugger)at.paused=true;return end;expect(1,cZ,\"number\")expect(2,eZ,\"number\",\"nil\")local G=processes[cZ]if not G then error(\"No such process\")end;if G.user~=process.user and process.user~=\"root\"then error(\"Permission denied\")end;if not G.debugging then error(\"Process does not have debugging enabled\")end;if eZ then local A=G.threads[eZ]if not A then error(\"No such thread\")end;if not A.paused then process.eventQueue[#process.eventQueue+1]={\"debug_break\",{process=G.id,thread=A.id}}end;A.paused=true else for B,A in pairs(G.threads)do if not A.paused then process.eventQueue[#process.eventQueue+1]={\"debug_break\",{process=G.id,thread=A.id}}end;A.paused=true end end end;function syscalls.debug_(process,at,cZ)expect(1,cZ,\"number\")local G=processes[cZ]if not G then error(\"No such process\")end;if G.user~=process.user and process.user~=\"root\"then error(\"Permission denied\")end;if not G.debugging then error(\"Process does not have debugging enabled\")end end;function syscalls.debug_continue(process,at,cZ,eZ)expect(1,cZ,\"number\")expect(2,eZ,\"number\",\"nil\")local G=processes[cZ]if not G then error(\"No such process\")end;if G.user~=process.user and process.user~=\"root\"then error(\"Permission denied\")end;if not G.debugging then error(\"Process does not have debugging enabled\")end;if eZ then local A=G.threads[eZ]if not A then error(\"No such thread\")end;A.paused=false else for B,A in pairs(G.threads)do A.paused=false end end end;local e_={call=true,[\"return\"]=true,line=true,error=true,resume=true,yield=true}function syscalls.debug_setbreakpoint(process,at,cZ,eZ,f0,e6)expect(1,cZ,\"number\")expect(2,eZ,\"number\",\"nil\")expect(3,f0,\"string\",\"number\")expect(4,e6,\"table\",\"nil\")if type(f0)~=\"number\"and not e_[f0]then error(\"bad argument #3 (invalid option '\"..f0 ..\"')\")end;local G=processes[cZ]if not G then error(\"No such process\")end;if G.user~=process.user and process.user~=\"root\"then error(\"Permission denied\")end;if not G.debugging then error(\"Process does not have debugging enabled\")end;local aD=#G.breakpoints+1;G.breakpoints[aD]={process=process,thread=eZ,type=f0,filter=e6}return aD end;function syscalls.debug_unsetbreakpoint(process,at,cZ,f1)expect(1,cZ,\"number\")expect(2,f1,\"number\")local G=processes[cZ]if not G then error(\"No such process\")end;if G.user~=process.user and process.user~=\"root\"then error(\"Permission denied\")end;if not G.debugging then error(\"Process does not have debugging enabled\")end;G.breakpoints[f1]=nil end;function syscalls.debug_listbreakpoints(process,at,cZ)expect(1,cZ,\"number\")local G=processes[cZ]if not G then error(\"No such process\")end;if G.user~=process.user and process.user~=\"root\"then error(\"Permission denied\")end;if not G.debugging then error(\"Process does not have debugging enabled\")end;local a7={}for aD,dg in pairs(G.breakpoints)do a7[aD]={type=dg.type,thread=dg.thread}if dg.filter then for j,k in pairs(dg.filter)do a7[aD][j]=k end end end;return a7 end;function syscalls.debug_getinfo(process,at,cZ,eZ,b3,b2)expect(1,cZ,\"number\")expect(2,eZ,\"number\")expect(3,b3,\"number\")expect(4,b2,\"string\",\"nil\")local G=processes[cZ]if not G then error(\"No such process\")end;if G.user~=process.user and process.user~=\"root\"then error(\"Permission denied\")end;if not G.debugging then error(\"Process does not have debugging enabled\")end;local A=G.threads[eZ]if not A then error(\"No such thread\")end;return debug.getinfo(A.coroStack[#A.coroStack],b3,b2)end;function syscalls.debug_getlocal(process,at,cZ,eZ,b3,t)expect(1,cZ,\"number\")expect(2,eZ,\"number\")expect(3,b3,\"number\")expect(4,t,\"number\")local G=processes[cZ]if not G then error(\"No such process\")end;if G.user~=process.user and process.user~=\"root\"then error(\"Permission denied\")end;if not G.debugging then error(\"Process does not have debugging enabled\")end;local A=G.threads[eZ]if not A then error(\"No such thread\")end;return debug.getlocal(A.coroStack[#A.coroStack],b3,t)end;function syscalls.debug_getupvalue(process,at,cZ,eZ,b3,t)expect(1,cZ,\"number\")expect(2,eZ,\"number\")expect(3,b3,\"number\")expect(4,t,\"number\")local G=processes[cZ]if not G then error(\"No such process\")end;if G.user~=process.user and process.user~=\"root\"then error(\"Permission denied\")end;if not G.debugging then error(\"Process does not have debugging enabled\")end;local A=G.threads[eZ]if not A then error(\"No such thread\")end;local info=debug.getinfo(A.coroStack[#A.coroStack],b3,\"f\")if not info then error(\"bad argument #3 (level out of range)\")end;return debug.getupvalue(info.func,t)end;function syscalls.debug_exec(process,at,cZ,eZ,i)expect(1,cZ,\"number\")expect(2,eZ,\"number\")expect(3,i,\"function\")local G=processes[cZ]if not G then error(\"No such process\")end;if G.user~=process.user and process.user~=\"root\"then error(\"Permission denied\")end;if not G.debugging then error(\"Process does not have debugging enabled\")end;local A=G.threads[eZ]if not A then error(\"No such thread\")end;if not A.paused then error(\"Thread is not paused\")end;setfenv(i,G.env)A.pendingExec=i;A.pendingExecProcess=process;A.paused=false end;local function f2(a2)a2=a2 ..\"\\x80\"..(\"\\0\"):rep(-(#a2+9)%64)..(\">I8\"):pack(#a2)local f3,f4,f5,f6,f7,ah=0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476,0xC3D2E1F0,{}for f8=1,#a2,64 do local f9=f8;for x=0,15 do ah[x]=a2:byte(f9)*0x1000000+a2:byte(f9+1)*0x10000+a2:byte(f9+2)*0x100+a2:byte(f9+3)f9=f9+4 end;for x=16,79 do ah[x]=bit32.lrotate(bit32.bxor(ah[x-3],ah[x-8],ah[x-14],ah[x-16]),1)end;local cy,ad,ab,br,M=f3,f4,f5,f6,f7;for x=0,79 do local f,j;if x<=19 then f,j=bit32.bxor(br,bit32.band(ad,bit32.bxor(ab,br))),0x5A827999 elseif x<=39 then f,j=bit32.bxor(ad,ab,br),0x6ED9EBA1 elseif x<=59 then f,j=bit32.bor(bit32.band(ad,bit32.bor(ab,br)),bit32.band(ab,br)),0x8F1BBCDC else f,j=bit32.bxor(ad,ab,br),0xCA62C1D6 end;local fa=bit32.band(bit32.lrotate(cy,5)+f+M+j+ah[x],0xFFFFFFFF)M,br,ab,ad,cy=br,ab,bit32.lrotate(ad,30),cy,fa end;f3=bit32.band(f3+cy,0xFFFFFFFF)f4=bit32.band(f4+ad,0xFFFFFFFF)f5=bit32.band(f5+ab,0xFFFFFFFF)f6=bit32.band(f6+br,0xFFFFFFFF)f7=bit32.band(f7+M,0xFFFFFFFF)end;return{f3,f4,f5,f6,f7}end;local function fb(fc,o)local fd=f2(fc:gsub(\"%X\",\"\"):gsub(\"%x%x\",function(bt)return string.char(tonumber(bt,16))end)..o)local cy,ad,ab,br=fd[1],bit32.bor(bit32.band(fd[2],0xFFFF0FFF),0x5000),bit32.bor(bit32.band(fd[3],0x3FFFFFFF),0x80000000),fd[4]return(\"%08x-%04x-%04x-%04x-%04x%08x\"):format(cy,bit32.rshift(ad,16),bit32.band(ad,0xFFFF),bit32.rshift(ab,16),bit32.band(ab,0xFFFF),br)end;local fe=\"a6f53b7d-50f3-4e51-adef-8728c83e3f3a\"deviceTreeRoot={id=tostring(os.getComputerID()),uuid=fb(fe,tostring(os.getComputerID())),parent=nil,displayName=os.getComputerLabel()or\"\",drivers={},metadata={},internalState={},children={},listeners=setmetatable({},{__mode=\"k\"})}local ff={[deviceTreeRoot.uuid]=deviceTreeRoot}local fg={}function hardware.get(g)expect(1,g,\"string\")if g:find(\"^%x+%-%x+%-%x+%-%x+%-%x+$\")then return ff[g]elseif g==\"\"or g:find(\"/\")then local dX=deviceTreeRoot;for o in g:gmatch\"[^/]+\"do dX=dX.children[o]if dX==nil then break end end;return dX else local fh={}local function fi(dX)if dX.id==g or dX.alias==g then fh[#fh+1]=dX end;for B,k in pairs(dX.children)do fi(k)end end;fi(deviceTreeRoot)return table.unpack(fh)end end;function hardware.find(type)expect(1,type,\"string\")local dW={}local function fj(dX)for B,k in ipairs(dX.drivers)do if k.type==type then dW[#dW+1]=dX;break end end;for B,k in pairs(dX.children)do fj(k)end end;fj(deviceTreeRoot)return table.unpack(dW)end;function hardware.path(dX)expect(1,dX,\"table\")expect.field(dX,\"uuid\",\"string\")if not ff[dX.uuid]then error(\"bad argument #1 (invalid node)\",2)end;local g=dX.id;dX=dX.parent;while dX do g=dX.id..\"/\"..g;dX=dX.parent end;g=g:gsub(\"^[^/]+\",\"\")return g==\"\"and\"/\"or g end;function hardware.add(c3,o)expect(1,c3,\"table\")expect(2,o,\"string\")expect.field(c3,\"uuid\",\"string\")if not ff[c3.uuid]then return nil,\"Invalid parent node\"end;if c3.children[o]then return nil,\"Node already exists\"end;local dX={id=o,uuid=fb(c3.uuid,o),parent=c3,displayName=\"\",drivers={},metadata={},internalState={},children={},listeners=setmetatable({},{__mode=\"k\"})}c3.children[o]=dX;ff[dX.uuid]=dX;syslog.log({module=\"Hardware\"},\"Added new device at \"..hardware.path(dX))for B,k in ipairs(fg)do if(not k.parent or k.parent==c3)and(not k.pattern or o:match(k.pattern))then k.callback(dX)end end;return dX end;function hardware.remove(dX)expect(1,dX,\"table\")expect.field(dX,\"uuid\",\"string\")if not ff[dX.uuid]then return false,\"Invalid node\"end;if dX==deviceTreeRoot or not dX.parent then return false,\"Cannot remove root node\"end;for x=#dX.drivers,1,-1 do hardware.deregister(dX,dX.drivers[x])end;for B,k in pairs(dX.children)do hardware.remove(k)end;syslog.log({module=\"Hardware\"},\"Device at \"..hardware.path(dX)..\" has been removed\")dX.parent.children[dX.id]=nil;ff[dX.uuid]=nil;dX.parent=nil;return true end;function hardware.register(dX,fk)expect(1,dX,\"table\")expect(2,fk,\"table\")expect.field(dX,\"uuid\",\"string\")expect.field(fk,\"name\",\"string\")expect.field(fk,\"type\",\"string\")expect.field(fk,\"properties\",\"table\")expect.field(fk,\"methods\",\"table\")expect.field(fk,\"init\",\"function\",\"nil\")expect.field(fk,\"deinit\",\"function\",\"nil\")for j in pairs(fk.methods)do if type(j)~=\"string\"then error(\"bad method name '\"..tostring(j)..\"' (not a string)\",2)end;expect.field(fk.methods,j,\"function\")end;for B,k in ipairs(fk.properties)do if type(k)~=\"string\"then error(\"bad property name '\"..tostring(k)..\"' (not a string)\",2)end;if not fk.methods[\"get\"..k:sub(1,1):upper()..k:sub(2)]then error(\"bad property '\"..k..\"' (no getter present)\",2)end end;if not ff[dX.uuid]then error(\"bad argument #1 (invalid node)\",2)end;for B,k in ipairs(dX.drivers)do if k==fk then return false end end;dX.drivers[#dX.drivers+1]=fk;syslog.log({module=\"Hardware\"},\"Registered device with type \"..fk.type..\" on device \"..hardware.path(dX)..\" using driver \"..fk.name)if fk.init then fk.init(dX)end;return true end;function hardware.register_callback(fk)return function(dX)return hardware.register(dX,fk)end end;function hardware.deregister(dX,fk)expect(1,dX,\"table\")expect(2,fk,\"table\")expect.field(dX,\"uuid\",\"string\")if not ff[dX.uuid]then error(\"bad argument #1 (invalid node)\",2)end;for x,k in ipairs(dX.drivers)do if k==fk then if fk.deinit then fk.deinit(dX)end;table.remove(dX.drivers,x)syslog.log({module=\"Hardware\"},\"Driver \"..fk.name..\" has been deregistered from device \"..hardware.path(dX))return true end end;return false end;function hardware.listen(fl,c3,fm)expect(1,fl,\"function\")expect(2,c3,\"table\",\"nil\")expect(3,fm,\"string\",\"nil\")if c3 then expect.field(c3,\"uuid\",\"string\")end;if fm and not pcall(string.match,\"\",fm)then error(\"bad argument #3 (invalid pattern)\",2)end;fg[#fg+1]={callback=fl,parent=c3,pattern=fm}end;function hardware.unlisten(fl)expect(1,fl,\"function\")local x=1;while x<#fg do if fg[x].callback==fl then table.remove(fg,x)else x=x+1 end end end;function hardware.broadcast(dX,cd,d1)expect(1,dX,\"table\")expect(2,cd,\"string\")expect(3,d1,\"table\")expect.field(dX,\"uuid\",\"string\")if not ff[dX.uuid]then error(\"bad argument #1 (invalid node)\",2)end;for k in pairs(dX.listeners)do k.eventQueue[#k.eventQueue+1]={cd,d1}wakeup(k)end end;function hardware.call(process,dX,fn,...)for B,fk in ipairs(dX.drivers)do if fk.methods[fn]then return fk.methods[fn](dX,process,...)end end;error(\"No such method\",2)end;function syscalls.devlookup(process,at,o)expect(1,o,\"string\")local fo={hardware.get(o)}for j,k in ipairs(fo)do fo[j]=hardware.path(k)end;return table.unpack(fo)end;function syscalls.devfind(process,at,type)expect(1,type,\"string\")local fo={hardware.find(type)}for j,k in ipairs(fo)do fo[j]=hardware.path(k)end;return table.unpack(fo)end;function syscalls.devinfo(process,at,fp)expect(1,fp,\"string\")local dX=hardware.get(fp)if not dX then return nil end;local fq={}for B,k in ipairs(dX.drivers)do fq[k.type]=k.name end;return{id=dX.id,uuid=dX.uuid,alias=dX.alias,parent=dX.parent and hardware.path(dX.parent)or\"/\",displayName=dX.displayName,types=fq,metadata=deepcopy(dX.metadata)}end;function syscalls.devalias(process,at,fp,fr)expect(1,fp,\"string\")expect(2,fr,\"string\",\"nil\")local dX=hardware.get(fp)if not dX then error(\"No such device\",2)end;dX.alias=fr end;function syscalls.devmethods(process,at,fp)expect(1,fp,\"string\")local dX=hardware.get(fp)if not dX then error(\"No such device\",2)end;local ft={}for B,k in ipairs(dX.drivers)do for j in pairs(k.methods)do ft[#ft+1]=j end end;return ft end;function syscalls.devproperties(process,at,fp)expect(1,fp,\"string\")local dX=hardware.get(fp)if not dX then error(\"No such device\",2)end;local fu={}for B,k in ipairs(dX.drivers)do for B,j in pairs(k.properties)do fu[#fu+1]=j end end;return fu end;function syscalls.devchildren(process,at,fp)expect(1,fp,\"string\")local dX=hardware.get(fp)if not dX then error(\"No such device\",2)end;local fv={}for j in pairs(dX.children)do fv[#fv+1]=j end;return fv end;function syscalls.devcall(process,at,fp,fn,...)expect(1,fp,\"string\")expect(2,fn,\"string\")local dX=hardware.get(fp)if not dX then error(\"No such device\",2)end;if dX.process and dX.process~=process.id then error(\"Device is locked\",2)end;return hardware.call(process,dX,fn,...)end;function syscalls.devlisten(process,at,fp,dA)expect(1,fp,\"string\")expect(2,dA,\"boolean\",\"nil\")if dA==nil then dA=true end;local dX=hardware.get(fp)if not dX then error(\"No such device\",2)end;if dA then for B,k in ipairs(dX.listeners)do if k==process then return end end;dX.listeners[process]=true;process.dependents[#process.dependents+1]={type=\"hardware listen\",node=dX,gc=function()dX.listeners[process]=nil end}else dX.listeners[process]=nil;for x,k in ipairs(process.dependents)do if k.type==\"hardware listen\"and k.node==dX then table.remove(process.dependents,x)break end end end end;function syscalls.devlock(process,at,fp,fw)expect(1,fp,\"string\")expect(2,fw,\"boolean\",\"nil\")if fw==nil then fw=true end;local dX=hardware.get(fp)if not dX then error(\"No such device\",2)end;if dX.process==nil then dX.process=process.id;process.dependents[#process.dependents+1]={type=\"hardware lock\",node=dX,gc=function()dX.process=nil end}return true elseif dX.process==process.id then return true elseif fw then at.filter=function(process,at)return dX.process==nil or dX.process==process.id end;return kSyscallYield,\"devlock\",fp,true else return false end end;function syscalls.devunlock(process,at,fp)expect(1,fp,\"string\")local dX=hardware.get(fp)if not dX then error(\"No such device\",2)end;if dX.process and dX.process~=process.id then error(\"Device is locked\",2)end;dX.process=nil;for x,k in ipairs(process.dependents)do if k.type==\"hardware lock\"and k.node==dX then table.remove(process.dependents,x)break end end end;function syscalls.version(process,at,fx)if fx then return PHOENIX_BUILD else return PHOENIX_VERSION end end;function syscalls.cchost(process,at)return _HOST end;function syscalls.uptime(process,at)return(os.epoch\"utc\"-systemStartTime)/1000 end;function syscalls.attach(process,at,fy,_type,...)if process.user~=\"root\"then error(\"Permission denied\")end;expect(1,fy,\"string\",\"number\")expect(2,_type,\"string\")local bh,q;if periphemu then bh=periphemu.create(fy,_type,...)elseif ccemux then if type(fy)==\"number\"then fy=_type..\"_\"..fy end;if _type==\"drive\"then _type=\"disk_drive\"elseif _type==\"modem\"then _type=\"wireless_modem\"end;if _type==\"computer\"then local aD=tonumber(fy:match(\"%d+\"))if aD then bh,q=pcall(ccemux.openEmu,aD)else bh,q=false,\"Invalid side\"end else bh,q=pcall(ccemux.attach,fy,_type,...)end else bh,q=false,\"Operation not supported\"end;return bh,q end;function syscalls.detach(process,at,fy)if process.user~=\"root\"then error(\"Permission denied\")end;expect(1,fy,\"string\",\"number\")local bh,q;if periphemu then bh=periphemu.remove(fy)elseif ccemux then if type(fy)==\"number\"then fy=_type..\"_\"..fy end;bh,q=pcall(ccemux.detach,fy)else bh,q=false,\"Operation not supported\"end;return bh,q end;function syscalls.kernargs(process,at)return deepcopy(args)end;local fz=0;function syscalls.lockmutex(process,at,fA)expect(1,fA,\"table\")while fA.owner~=nil and fA.owner~=at.id or fA.pid~=nil and fA.pid~=process.id do coroutine.yield()end;if fA.owner then if type(fA.recursive)==\"number\"then fA.recursive=fA.recursive+1;return else error(\"cannot recursively lock mutex\",0)end end;fA.owner=at.id;fA.pid=process.id;if fA.recursive then fA.recursive=1 end end;function syscalls.__timeout_check(process,at,info)if info.timeout then return false end;return syscalls[info.call](process,at,info.object,0)end;function syscalls.timelockmutex(process,at,fA,ex)expect(1,fA,\"table\")expect(2,ex,\"number\")if fA.owner then if fA.owner~=at.id then local fB=os.startTimer(ex)local info={object=fA,timeout=false,call=\"timelockmutex\"}at.filter=function(process,at,au)if au[1]==\"timer\"and au[2].id==fB then info.timeout=true;return true end;return fA.owner==nil or fA.owner==at.id end;return kSyscallYield,\"__timeout_check\",info elseif type(fA.recursive)==\"number\"then fA.recursive=fA.recursive+1 else error(\"cannot recursively lock mutex\",0)end else fA.owner=at.id;if fA.recursive then fA.recursive=1 end end;return true end;function syscalls.unlockmutex(process,at,fA)expect(1,fA,\"table\")if fA.owner==at.id and fA.pid==process.id then if type(fA.recursive)==\"number\"then fA.recursive=fA.recursive-1;if fA.recursive<=0 then fA.owner=nil end else fA.owner,fA.pid=nil end elseif fA.owner==nil then error(\"mutex already unlocked\",0)else error(\"mutex not locked by current thread\")end end;function syscalls.trylockmutex(process,at,fA)expect(1,fA,\"table\")if fA.owner then if fA.owner~=at.id or fA.pid~=process.id then return false elseif type(fA.recursive)==\"number\"then fA.recursive=fA.recursive+1;return true else error(\"cannot recursively lock mutex\",0)end else fA.owner=at.id;fA.pid=process.id;if fA.recursive then fA.recursive=1 end;return true end end;function syscalls.acquiresemaphore(process,at,fC)expect(1,fC,\"table\")expect.field(fC,\"count\",\"number\")while fC.count<=0 do coroutine.yield()end;fC.count=fC.count-1 end;function syscalls.timeacquiresemaphore(process,at,fC,ex)expect(1,fC,\"table\")expect.field(fC,\"count\",\"number\")expect(2,ex,\"number\")if fC.count<=0 then local fB=os.startTimer(ex)local info={object=fC,timeout=false,call=\"timeacquiresemaphore\"}at.filter=function(process,at,au)if au[1]==\"timer\"and au[2].id==fB then info.timeout=true;return true end;return type(fC.count)~=\"number\"or fC.count>0 end;return kSyscallYield,\"__timeout_check\",info end;fC.count=fC.count-1;return true end;function syscalls.releasesemaphore(process,at,fC)expect(1,fC,\"table\")expect.field(fC,\"count\",\"number\")fC.count=fC.count+1 end;local fD={name=\"root\",type=\"computer\",properties={\"label\",\"id\"},methods={getLabel=function()end,setLabel=function(fE)end,getId=function()end,shutdown=function()end,reboot=function()end},init=function(dX)end,deinit=function(dX)end}local fF={top=true,bottom=true,left=true,right=true,front=true,back=true}local fG={}function getNodeById(o)if fF[o]then if deviceTreeRoot.children[o]then return deviceTreeRoot.children[o]end else for j in pairs(fF)do if peripheral.getType(j)==\"modem\"and not peripheral.call(j,\"isWireless\")and deviceTreeRoot.children[j]and deviceTreeRoot.children[j].children[o]then return deviceTreeRoot.children[j].children[o]end end end end;local function fH(self)self.internalState.peripheral=self.internalState.peripheral or{}if not self.internalState.peripheral.call then self.internalState.peripheral.call=peripheral.call end;if self.internalState.peripheral.call==peripheral.call or not self.parent then self.internalState.peripheral.getMethods=peripheral.getMethods else self.internalState.peripheral.getMethods=function(aD)return peripheral.call(self.parent.id,\"getMethodsRemote\",aD)end end end;local function fI(process,aE)aE.__metatable={}for B,k in pairs(aE)do setfenv(k,process.env)debug.protect(k)end;return setmetatable({},aE)end;local function fJ(fk,type)return function(dX)local fq,i;if dX.parent==deviceTreeRoot then fq,i={peripheral.getType(dX.id)},peripheral.call else fq,i={peripheral.call(dX.parent.id,\"getTypeRemote\",dX.id)},function(...)return peripheral.call(dX.parent.id,\"callRemote\",...)end end;for B,k in ipairs(fq)do if k==type then dX.internalState.peripheral={call=i}return hardware.register(dX,fk)end end end end;local function fK(type)return hardware.listen(fJ(fG[\"peripheral_\"..type],type),deviceTreeRoot)end;local function fL(fn)return function(self)return self.internalState.peripheral.call(self.id,fn)end end;local function fM(fn)return function(self,process)if process.user~=\"root\"then error(\"Permission denied\",0)end;return self.internalState.peripheral.call(self.id,fn)end end;local function fN(fn)return function(...)local fq={...}return function(self,process,aI)expect(1,aI,table.unpack(fq))return self.internalState.peripheral.call(self.id,fn,aI)end end end;local function fO(fn)return function(...)local fq={...}return function(self,process,aI)expect(1,aI,table.unpack(fq))if process.user~=\"root\"then error(\"Permission denied\",0)end;return self.internalState.peripheral.call(self.id,fn,aI)end end end;local function fP()syslog.log(\"Sending SIGTERM to all processes\")local fQ=false;for cZ,process in pairs(processes)do if cZ~=0 then killProcess(cZ,15)local fR,au=false,nil;local av=true;for eZ,at in pairs(process.threads)do if not fR and at.status==\"suspended\"then au=table.remove(process.eventQueue,1)fR=true end;if au or at.status~=\"suspended\"then av=executeThread(process,at,au or{n=0},av,true)else av=false end end;if av then process.isDead=true;if process.parent~=0 and processes[process.parent]then processes[process.parent].eventQueue[#processes[process.parent].eventQueue+1]={\"process_complete\",process.lastReturnValue}wakeup(processes[process.parent])end;reap_process(process)processes[cZ]=nil else fQ=true end end end;terminal.redraw(currentTTY)if fQ then syslog.log(\"Sending SIGKILL to all processes\")for cZ in pairs(processes)do if cZ~=0 then killProcess(cZ,9)end end end end;fG.root={name=\"root\",type=\"computer\",properties={\"isOn\",\"label\"},methods={}}function fG.root.methods:getIsOn(process)return true end;function fG.root.methods:getLabel(process)return os.getComputerLabel()end;function fG.root.methods:setLabel(process,fE)expect(1,fE,\"string\",\"nil\")os.setComputerLabel(fE)end;function fG.root.methods:turnOn(process)end;function fG.root.methods:shutdown(process,a7)if process.user~=\"root\"then error(\"Permission denied\",2)end;syslog.log(\"System is shutting down.\")function postkill()hardware.deregister(deviceTreeRoot,fG.root)syslog.log(\"Halting system\")for B,k in ipairs(shutdownHooks)do k()end;os.shutdown(a7)mainThread=nil;while true do coroutine.yield()end end;fP()end;function fG.root.methods:reboot(process)if process.user~=\"root\"then error(\"Permission denied\",2)end;syslog.log(\"System is restarting.\")function postkill()hardware.deregister(deviceTreeRoot,fG.root)syslog.log(\"Rebooting system\")for B,k in ipairs(shutdownHooks)do k()end;os.reboot()mainThread=nil;while true do coroutine.yield()end end;fP()end;function fG.root:init()local fS=hardware.add(self,\"redstone\")for B,k in ipairs{\"top\",\"bottom\",\"left\",\"right\",\"front\",\"back\"}do local br=hardware.add(fS,k)br.internalState.redstone={side=k}hardware.register(br,fG.root_redstone)end;hardware.register(hardware.add(deviceTreeRoot,\"lo\"),fG.loopback_modem)registerLoopback()for k in pairs(fF)do if peripheral.isPresent(k)then hardware.add(self,k)end end;self.displayName=os.getComputerLabel()self.metadata.id=os.getComputerID()end;function fG.root:deinit()for k in pairs(fF)do if peripheral.isPresent(k)and self.children[k]then hardware.remove(self.children[k])end end;hardware.remove(hardware.get(\"/lo\"))hardware.remove(hardware.get(\"/redstone\"))end;eventHooks.peripheral=eventHooks.peripheral or{}eventHooks.peripheral[#eventHooks.peripheral+1]=function(au)if fF[au[2]]then local dX,q=hardware.add(deviceTreeRoot,au[2])if dX then hardware.broadcast(deviceTreeRoot,\"device_added\",{device=hardware.path(dX)})else syslog.log({level=\"error\",module=\"Hardware\"},\"Could not create new device: \"..q)end else for j in pairs(fF)do if peripheral.getType(j)==\"modem\"and not peripheral.call(j,\"isWireless\")and peripheral.call(j,\"isPresentRemote\",au[2])then if not deviceTreeRoot.children[j]then hardware.add(deviceTreeRoot,j)end;local dX,q=hardware.add(deviceTreeRoot.children[j],au[2])if dX then hardware.broadcast(deviceTreeRoot.children[j],\"device_added\",{device=hardware.path(dX)})else syslog.log({level=\"error\",module=\"Hardware\"},\"Could not create new device: \"..q)end;break end end end end;eventHooks.peripheral_detach=eventHooks.peripheral_detach or{}eventHooks.peripheral_detach[#eventHooks.peripheral_detach+1]=function(au)local dX=getNodeById(au[2])if not dX then syslog.log({level=\"notice\",module=\"Hardware\"},\"Received \"..au[1]..\" event for device ID \"..au[2]..\", but no device node was found; ignoring\")return end;local g,c3=hardware.path(dX),dX.parent;hardware.remove(dX)hardware.broadcast(c3,\"device_removed\",{device=g})end;rootDriver=fG.root;fG.root_redstone={name=\"root_redstone\",type=\"redstone\",properties={\"input\",\"output\",\"bundledInput\",\"bundledOutput\"},methods={}}local function fT(t)if t==0 then return nil else return t end end;function fG.root_redstone.methods:getInput()return fT(redstone.getAnalogInput(self.internalState.redstone.side))end;function fG.root_redstone.methods:getOutput()return fT(redstone.getAnalogOutput(self.internalState.redstone.side))end;function fG.root_redstone.methods:setOutput(process,t)t=expect(1,t,\"number\",\"boolean\",\"nil\")or 0;if t==false then t=0 elseif t==true then t=15 end;expect.range(t,0,15)redstone.setAnalogOutput(self.internalState.redstone.side,t)end;function fG.root_redstone.methods:getBundledInput()return redstone.getBundledInput(self.internalState.redstone.side)end;function fG.root_redstone.methods:getBundledOutput()return redstone.getBundledOutput(self.internalState.redstone.side)end;function fG.root_redstone.methods:setBundledOutput(process,t)expect(1,t,\"number\")expect.range(t,0,65535)redstone.setBundledOutput(self.internalState.redstone.side,t)end;function fG.root_redstone:init()if not self.internalState.redstone or not self.internalState.redstone.side then error(\"No assigned side on redstone device!\",2)end;self.displayName=\"Redstone I/O on side \"..self.internalState.redstone.side end;fG.peripheral_command={name=\"peripheral_command\",type=\"command\",properties={\"command\"},methods={}}fG.peripheral_command.methods.getCommand=fM\"getCommand\"fG.peripheral_command.methods.setCommand=fO\"setCommand\"(\"string\")fG.peripheral_command.methods.run=fM\"runCommand\"function fG.peripheral_command:init()fH(self)self.displayName=\"Command block at \"..self.id end;fK\"command\"fG.peripheral_computer={name=\"peripheral_computer\",type=\"computer\",properties={\"isOn\",\"label\"},methods={}}fG.peripheral_computer.methods.getIsOn=fL\"isOn\"fG.peripheral_computer.methods.getLabel=fL\"getLabel\"fG.peripheral_computer.methods.turnOn=fM\"turnOn\"fG.peripheral_computer.methods.shutdown=fM\"shutdown\"fG.peripheral_computer.methods.reboot=fM\"reboot\"function fG.peripheral_command:init()fH(self)local fE=self.internalState.peripheral.call(self.id,\"getLabel\")self.metadata.id=self.internalState.peripheral.call(self.id,\"getID\")self.displayName=(fE or\"Computer \"..self.metadata.id)..\" at \"..self.id end;fK\"computer\"hardware.listen(fJ(fG[\"peripheral_computer\"],\"turtle\"),deviceTreeRoot)fG.peripheral_drive={name=\"peripheral_drive\",type=\"drive\",properties={\"state\",\"label\"},methods={}}function fG.peripheral_drive.methods:getState(process)if not self.internalState.peripheral.call(self.id,\"isDiskPresent\")then return nil end;return{audio=self.internalState.peripheral.call(self.id,\"getAudioTitle\")or nil,label=self.internalState.peripheral.call(self.id,\"getDiskLabel\"),id=self.internalState.peripheral.call(self.id,\"getDiskID\")}end;fG.peripheral_drive.methods.getLabel=fL\"getDiskLabel\"fG.peripheral_drive.methods.setLabel=fN\"setDiskLabel\"(\"string\",\"nil\")fG.peripheral_drive.methods.getMountPath=fL\"getMountPath\"function fG.peripheral_drive.methods:play(process)if not self.internalState.peripheral.call(self.id,\"hasAudio\")then error(\"Inserted disk is not an audio disc\",2)end;return self.internalState.peripheral.call(self.id,\"playAudio\")end;fG.peripheral_drive.methods.stop=fL\"stopAudio\"fG.peripheral_drive.methods.eject=fL\"ejectDisk\"fG.peripheral_drive.methods.insert=fO\"insertDisk\"(\"string\")function fG.peripheral_drive:init()fH(self)self.displayName=(self.internalState.peripheral.call(self.id,\"getDiskLabel\")or\"No disk\")..\" on drive \"..self.id end;fK\"drive\"eventHooks.disk=eventHooks.disk or{}eventHooks.disk[#eventHooks.disk+1]=function(au)local dX=getNodeById(au[2])if not dX then syslog.log({level=\"notice\",module=\"Hardware\"},\"Received \"..au[1]..\" event for device ID \"..au[2]..\", but no device node was found; ignoring\")return end;hardware.broadcast(dX,\"disk\",{device=hardware.path(dX)})end;eventHooks.disk_eject=eventHooks.disk_eject or{}eventHooks.disk_eject[#eventHooks.disk_eject+1]=function(au)local dX=getNodeById(au[2])if not dX then syslog.log({level=\"notice\",module=\"Hardware\"},\"Received \"..au[1]..\" event for device ID \"..au[2]..\", but no device node was found; ignoring\")return end;hardware.broadcast(dX,\"disk_eject\",{device=hardware.path(dX)})end;fG.peripheral_energy_storage={name=\"peripheral_energy_storage\",type=\"energy_storage\",properties={\"energy\"},methods={}}fG.peripheral_energy_storage.methods.getEnergy=fL\"getEnergy\"function fG.peripheral_energy_storage:init()fH(self)self.displayName=\"Energy storage block at \"..self.id;self.metadata.capacity=self.internalState.peripheral.call(self.id,\"getEnergyCapacity\")end;fK\"energy_storage\"fG.peripheral_fluid_storage={name=\"peripheral_fluid_storage\",type=\"fluid_storage\",properties={\"tanks\"},methods={}}fG.peripheral_fluid_storage.methods.getTanks=fL\"tanks\"function fG.peripheral_fluid_storage.methods:push(process,bV,fU,o)expect(1,bV,\"string\")expect(2,fU,\"number\",\"nil\")expect(3,o,\"string\",\"nil\")local ev;local fV={hardware.get(bV)}if#fV==1 then ev=fV[1]else for B,k in ipairs(fV)do if k.parent==self.parent then ev=k;break end end end;if not ev then error(\"No such device\",0)elseif ev.parent~=self.parent then error(\"Devices must be on the same network\",0)end;local bh=false;for B,k in ipairs(ev.drivers)do if k==fG.peripheral_fluid_storage then bh=true;break end end;if not bh then error(\"Target device is not a fluid storage block\",0)end;return self.internalState.peripheral.call(self.id,\"pushFluid\",ev.id,fU,o)end;function fG.peripheral_fluid_storage.methods:pull(process,bU,fU,o)expect(1,bU,\"string\")expect(2,fU,\"number\",\"nil\")expect(3,o,\"string\",\"nil\")local ev;local fV={hardware.get(bU)}if#fV==1 then ev=fV[1]else for B,k in ipairs(fV)do if k.parent==self.parent then ev=k;break end end end;if not ev then error(\"No such device\",0)elseif ev.parent~=self.parent then error(\"Devices must be on the same network\",0)end;local bh=false;for B,k in ipairs(ev.drivers)do if k==fG.peripheral_fluid_storage then bh=true;break end end;if not bh then error(\"Target device is not a fluid storage block\",0)end;return self.internalState.peripheral.call(self.id,\"pullFluid\",ev.id,fU,o)end;function fG.peripheral_fluid_storage:init()fH(self)self.displayName=\"Fluid storage block at \"..self.id end;fK\"fluid_storage\"fG.peripheral_inventory={name=\"peripheral_inventory\",type=\"inventory\",properties={\"items\"},methods={}}fG.peripheral_inventory.methods.getItems=fL\"list\"fG.peripheral_inventory.methods.detail=fN\"getItemDetail\"(\"number\")fG.peripheral_inventory.methods.limit=fN\"getItemLimit\"(\"number\")function fG.peripheral_inventory.methods:push(process,bV,fW,fU,fX)expect(1,bV,\"string\")expect(2,fW,\"number\")expect(3,fU,\"number\",\"nil\")expect(4,fX,\"number\",\"nil\")local ev;local fV={hardware.get(bV)}if#fV==1 then ev=fV[1]else for B,k in ipairs(fV)do if k.parent==self.parent then ev=k;break end end end;if not ev then error(\"No such device\",0)elseif ev.parent~=self.parent then error(\"Devices must be on the same network\",0)end;local bh=false;for B,k in ipairs(ev.drivers)do if k==fG.peripheral_inventory then bh=true;break end end;if not bh then error(\"Target device is not an inventory block\",0)end;return self.internalState.peripheral.call(self.id,\"pushItems\",ev.id,fW,fU,fX)end;function fG.peripheral_inventory.methods:pull(process,bU,fW,fU,fX)expect(1,bU,\"string\")expect(2,fW,\"number\")expect(3,fU,\"number\",\"nil\")expect(4,fX,\"number\",\"nil\")local ev;local fV={hardware.get(bU)}if#fV==1 then ev=fV[1]else for B,k in ipairs(fV)do if k.parent==self.parent then ev=k;break end end end;if not ev then error(\"No such device\",0)elseif ev.parent~=self.parent then error(\"Devices must be on the same network\",0)end;local bh=false;for B,k in ipairs(ev.drivers)do if k==fG.peripheral_inventory then bh=true;break end end;if not bh then error(\"Target device is not an inventory block\",0)end;return self.internalState.peripheral.call(self.id,\"pullItems\",ev.id,fW,fU,fX)end;function fG.peripheral_inventory:init()fH(self)self.displayName=\"Inventory at \"..self.id;self.metadata.size=self.internalState.peripheral.call(self.id,\"size\")end;fK\"inventory\"fG.peripheral_monitor={name=\"peripheral_monitor\",type=\"monitor\",properties={\"scale\",\"size\"},methods={}}fG.peripheral_monitor.methods.getScale=fL\"getTextScale\"fG.peripheral_monitor.methods.setScale=fN\"setTextScale\"(\"number\")function fG.peripheral_monitor.methods:getSize()local ah,ai=self.internalState.peripheral.call(self.id,\"getSize\")return{width=ah,height=ai}end;function fG.peripheral_monitor.methods:write(process,...)for x,k in ipairs{...}do if x>1 then terminal.write(self.internalState.tty,\"\\t\")end;terminal.write(self.internalState.tty,k)end;terminal.redraw(self.internalState.tty)end;function fG.peripheral_monitor.methods:termctl(process,dE)expect(1,dE,\"table\",\"nil\")if dE then expect.field(dE,\"cbreak\",\"boolean\",\"nil\")expect.field(dE,\"delay\",\"boolean\",\"nil\")expect.field(dE,\"echo\",\"boolean\",\"nil\")expect.field(dE,\"keypad\",\"boolean\",\"nil\")expect.field(dE,\"nlcr\",\"boolean\",\"nil\")expect.field(dE,\"raw\",\"boolean\",\"nil\")for j,k in pairs(dE)do if self.internalState.tty.flags[j]~=nil then self.internalState.tty.flags[j]=k end end end;local A=deepcopy(self.internalState.tty.flags)A.hasgfx=term.getGraphicsMode~=nil;return A end;function fG.peripheral_monitor.methods:openterm(process)return terminal.openterm(self.internalState.tty,process)end;function fG.peripheral_monitor.methods:opengfx(process)return terminal.opengfx(self.internalState.tty,process)end;function fG.peripheral_monitor:init()fH(self)local ah,ai=self.internalState.peripheral.call(self.id,\"getSize\")local fY=self.internalState.peripheral.call(self.id,\"getTextScale\")self.displayName=ah*fY..\"x\"..ai*fY..\" monitor at \"..self.id;local term={}for B,k in ipairs(self.internalState.peripheral.getMethods(self.id))do term[k]=function(...)return self.internalState.peripheral.call(self.id,k,...)end end;self.internalState.tty=terminal.makeTTY(term,ah,ai)self.internalState.tty.isMonitor=true;terminal.redraw(self.internalState.tty,true)end;function fG.peripheral_monitor:deinit()local dp=self.internalState.tty;if dp.frontmostProcess then local k=dp.frontmostProcess;if k.stdin==dp then k.stdin=nil end;if k.stdout==dp then k.stdout=nil end;if k.stderr==dp then k.stderr=nil end end;for B,k in ipairs(dp.processList)do if k.stdin==dp then k.stdin=nil end;if k.stdout==dp then k.stdout=nil end;if k.stderr==dp then k.stderr=nil end end end;fK\"monitor\"eventHooks.monitor_resize=eventHooks.monitor_resize or{}eventHooks.monitor_resize[#eventHooks.monitor_resize+1]=function(au)local dX=getNodeById(au[2])if not dX then syslog.log({level=\"notice\",module=\"Hardware\"},\"Received \"..au[1]..\" event for device ID \"..au[2]..\", but no device node was found; ignoring\")return end;local U=fG.peripheral_monitor.methods.getSize(dX)terminal.resize(dX.internalState.tty,U.width,U.height)hardware.broadcast(dX,\"monitor_resize\",{device=hardware.path(dX),width=U.width,height=U.height})end;fG.peripheral_printer={name=\"peripheral_printer\",type=\"printer\",properties={\"inkLevel\",\"paperLevel\"},methods={}}fG.peripheral_printer.methods.getInkLevel=fL\"getInkLevel\"fG.peripheral_printer.methods.getPaperLevel=fL\"getPaperLevel\"function fG.peripheral_printer.methods:page(process)if self.internalState.printer.open then self.internalState.peripheral.call(self.id,\"endPage\")self.internalState.printer.open=false end;if not self.internalState.peripheral.call(self.id,\"newPage\")then return nil end;self.internalState.printer.open=true;local fZ,r,s;local function dD(...)if not self.internalState.printer.open then error(\"attempt to use closed page\",2)end;return self.internalState.peripheral.call(self.id,\"write\",...)end;local function f_()if not self.internalState.printer.open then return true end;if not self.internalState.peripheral.call(self.id,\"endPage\")then return false end;self.internalState.printer.open=false end;setfenv(dD,process.env)setfenv(f_,process.env)debug.protect(dD)debug.protect(f_)return fI(process,{__index=function(B,aF)if not self.internalState.printer.open then error(\"attempt to use closed page\",2)end;if aF==\"size\"then local v,dk=self.internalState.peripheral.call(self.id,\"getPageSize\")return fI(process,{__index=function(B,aF)if aF==\"width\"then return v elseif aF==\"height\"then return dk end end,__newindex=function()error(\"Cannot modify read-only table\",2)end})elseif aF==\"cursor\"then r,s=self.internalState.peripheral.call(self.id,\"getCursorPos\")return fI(process,{__index=function(B,aF)if aF==\"x\"then return r elseif aF==\"y\"then return s end end,__newindex=function(B,aF,aG)if aF==\"x\"then r=aG;self.internalState.peripheral.call(self.id,\"setCursorPos\",r,s)elseif aF==\"y\"then s=aG;self.internalState.peripheral.call(self.id,\"setCursorPos\",r,s)else error(\"Cannot modify member '\"..aF..\"'\",2)end end})elseif aF==\"title\"then return fZ elseif aF==\"isOpen\"then return self.internalState.printer.open elseif aF==\"write\"then return dD elseif aF==\"close\"then return f_ end end,__newindex=function(B,aF,aG)if not self.internalState.printer.open then error(\"attempt to use closed page\",2)end;if aF==\"cursor\"then if type(aG)~=\"table\"then error(\"bad value for 'cursor' (expected table, got \"..type(aG)..\")\",2)end;expect.field(aG,\"x\",\"number\")expect.field(aG,\"y\",\"number\")r,s=aG.x,aG.y;self.internalState.peripheral.call(self.id,\"setCursorPos\",r,s)elseif aF==\"title\"then if type(aG)~=\"string\"and aG~=nil then error(\"bad value for 'title' (expected string, got \"..type(aG)..\")\",2)end;fZ=aG;self.internalState.peripheral.call(self.id,\"setPageTitle\",fZ)else error(\"Cannot modify member '\"..aF..\"'\",2)end end})end;function fG.peripheral_printer:init()fH(self)self.displayName=\"Speaker at \"..self.id;self.internalState.printer={open=false}end;fK\"printer\"local g0={name=\"peripheral_redstone_relay_side\",type=\"redstone\",properties={\"input\",\"output\",\"bundledInput\",\"bundledOutput\"},methods={}}function g0.methods:getInput()return fT(self.internalState.peripheral.call(self.id,\"getAnalogInput\",self.internalState.redstone.side))end;function g0.methods:getOutput()return fT(self.internalState.peripheral.call(self.id,\"getAnalogOutput\",self.internalState.redstone.side))end;function g0.methods:setOutput(process,t)t=expect(1,t,\"number\",\"boolean\",\"nil\")or 0;if t==false then t=0 elseif t==true then t=15 end;expect.range(t,0,15)self.internalState.peripheral.call(self.id,\"setAnalogOutput\",self.internalState.redstone.side,t)end;function g0.methods:getBundledInput()return self.internalState.peripheral.call(self.id,\"getBundledInput\",self.internalState.redstone.side)end;function g0.methods:getBundledOutput()return self.internalState.peripheral.call(self.id,\"getBundledOutput\",self.internalState.redstone.side)end;function g0.methods:setBundledOutput(process,t)expect(1,t,\"number\")expect.range(t,0,65535)return self.internalState.peripheral.call(self.id,\"setBundledOnput\",self.internalState.redstone.side,t)end;function g0:init()if not self.internalState.redstone or not self.internalState.redstone.side then error(\"No assigned side on redstone device!\",2)end;self.displayName=\"Redstone Relay '\"..self.id..\"' on side \"..self.internalState.redstone.side end;fG.peripheral_redstone_relay={name=\"peripheral_redstone_relay\",type=\"redstone_relay\",properties={},methods={}}function fG.peripheral_redstone_relay:init()for B,k in ipairs{\"top\",\"bottom\",\"left\",\"right\",\"front\",\"back\"}do local br=hardware.add(self,k)br.internalState.redstone={side=k}hardware.register(br,g0)end end;fK\"redstone_relay\"fG.peripheral_speaker={name=\"peripheral_speaker\",type=\"speaker\",properties={},methods={}}function fG.peripheral_speaker.methods:playNote(process,g1,g2,g3)expect(1,g1,\"string\")expect(2,g2,\"number\",\"nil\")expect(3,g3,\"number\",\"nil\")if g2 then expect.range(g2,0,3)end;if g3 then expect.range(g3,0,24)end;return self.internalState.peripheral.call(self.id,\"playNote\",g1,g2,g3)end;function fG.peripheral_speaker.methods:playSound(process,o,g2,g4)expect(1,o,\"string\")expect(2,g2,\"number\",\"nil\")expect(3,g4,\"number\",\"nil\")if g2 then expect.range(g2,0,3)end;if g4 then expect.range(g4,0.5,2.0)end;return self.internalState.peripheral.call(self.id,\"playNote\",o,g2,g4)end;function fG.peripheral_speaker.methods:playAudio(g5,g2)expect(1,g5,\"table\")expect(2,g2,\"number\",\"nil\")if g2 then expect.range(g2,0,3)end;return self.internalState.peripheral.call(self.id,\"playAudio\",g5,g2)end;fG.peripheral_speaker.methods.stop=fL\"stop\"function fG.peripheral_speaker:init()fH(self)self.displayName=\"Speaker at \"..self.id end;fK\"speaker\"eventHooks.speaker_audio_empty=eventHooks.speaker_audio_empty or{}eventHooks.speaker_audio_empty[#eventHooks.speaker_audio_empty+1]=function(au)local dX=getNodeById(au[2])if not dX then syslog.log({level=\"notice\",module=\"Hardware\"},\"Received \"..au[1]..\" event for device ID \"..au[2]..\", but no device node was found; ignoring\")return end;hardware.broadcast(dX,\"speaker_audio_empty\",{device=hardware.path(dX)})end;local g6={fG.peripheral_command,fG.peripheral_computer,fG.peripheral_drive,fG.peripheral_energy_storage,fG.peripheral_fluid_storage,fG.peripheral_inventory,fG.peripheral_monitor,fG.peripheral_printer,fG.peripheral_speaker}function registerDriver(fk)local g7=fk.init;fk.init=function(dX)fH(dX)if g7 then return g7(dX)end end;fk.__callback=fJ(fk,fk.type)hardware.listen(fk.__callback,deviceTreeRoot)g6[#g6+1]=fk;for B,dX in ipairs{hardware.find(\"modem\")}do if not dX.metadata.wireless then hardware.listen(fk.__callback,dX)dX.internalState.modem.callbacks[#dX.internalState.modem.callbacks+1]=f end end end;function deregisterDriver(fk)if not fk.__callback then return end;hardware.unlisten(fk.__callback)for B,k in ipairs{hardware.find(fk.type)}do hardware.deregister(k,fk)end;for x,k in ipairs(fF)do if k==fk then table.remove(fF,x)break end end;for B,dX in ipairs{hardware.find(\"modem\")}do if not dX.metadata.wireless then hardware.unlisten(fk.__callback)for x,k in ipairs(dX.internalState.modem.callbacks)do if k==fk.__callback then table.remove(dX.internalState.modem.callbacks,x)break end end end end end;fG.peripheral_modem={name=\"peripheral_modem\",type=\"modem\",properties={\"remainingChannels\"},methods={}}function fG.peripheral_modem.methods:getRemainingChannels()local b=128;for B in pairs(self.internalState.modem)do b=b-1 end;return b end;function fG.peripheral_modem.methods:open(process,g8)if not self.internalState.modem[g8]then self.internalState.peripheral.call(self.id,\"open\",g8)self.internalState.modem[g8]={}end;self.internalState.modem[g8][process]=true end;function fG.peripheral_modem.methods:isOpen(process,g8)return self.internalState.modem[g8]and self.internalState.modem[g8][process]end;function fG.peripheral_modem.methods:close(process,g8)self.internalState.modem[g8][process]=nil;if not next(self.internalState.modem[g8])then self.internalState.peripheral.call(self.id,\"close\",g8)self.internalState.modem[g8]=nil end end;function fG.peripheral_modem.methods:closeAll(process)for g8=0,65535 do self.internalState.modem[g8][process]=nil;if not next(self.internalState.modem[g8])then self.internalState.peripheral.call(self.id,\"close\",g8)self.internalState.modem[g8]=nil end end end;function fG.peripheral_modem.methods:transmit(process,g8,g9,ga)expect(1,g8,\"number\")g9=expect(2,g9,\"number\",\"nil\")or g8;return self.internalState.peripheral.call(self.id,\"transmit\",g8,g9,ga)end;function fG.peripheral_modem:init()fH(self)self.metadata.wireless=self.internalState.peripheral.call(self.id,\"isWireless\")self.displayName=(self.metadata.wireless and\"Wireless\"or\"Wired\")..\" modem at \"..self.id;self.internalState.modem={}self.internalState.modem.channels={}self.internalState.peripheral.call(self.id,\"closeAll\")if not self.metadata.wireless then self.internalState.modem.callbacks={}for B,k in ipairs(g6)do local f=fJ(k,k.type)hardware.listen(f,self)self.internalState.modem.callbacks[#self.internalState.modem.callbacks+1]=f end;local f=fJ(fG[\"peripheral_computer\"],\"turtle\")hardware.listen(f,self)self.internalState.modem.callbacks[#self.internalState.modem.callbacks+1]=f;for B,o in ipairs(self.internalState.peripheral.call(self.id,\"getNamesRemote\"))do hardware.add(self,o)end end end;function fG.peripheral_modem:deinit()if not self.metadata.wireless then for B,k in ipairs(self.internalState.modem.callbacks)do hardware.unlisten(k)end end end;fK\"modem\"eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(au)local dX=getNodeById(au[2])or hardware.get(au[2])if not dX then syslog.log({level=\"notice\",module=\"Hardware\"},\"Received \"..au[1]..\" event for device ID \"..au[2]..\", but no device node was found; ignoring\")return end;local a7=false;for k in pairs(dX.listeners)do if(dX.internalState.modem[au[3]]or{})[k]then k.eventQueue[#k.eventQueue+1],a7={\"modem_message\",{device=hardware.path(dX),channel=au[3],replyChannel=au[4],message=au[5],distance=au[6]}},true;wakeup(k)end end;return a7 end;fG.loopback_modem={name=\"loopback_modem\",type=\"modem\",properties={\"remainingChannels\"},methods={}}function fG.loopback_modem.methods:getRemainingChannels()local b=128;for B in pairs(self.internalState.modem)do b=b-1 end;return b end;function fG.loopback_modem.methods:open(process,g8)if not self.internalState.modem[g8]then self.internalState.modem[g8]={}end;self.internalState.modem[g8][process]=true end;function fG.loopback_modem.methods:isOpen(process,g8)return self.internalState.modem[g8]and self.internalState.modem[g8][process]end;function fG.loopback_modem.methods:close(process,g8)self.internalState.modem[g8][process]=nil;if not next(self.internalState.modem[g8])then self.internalState.modem[g8]=nil end end;function fG.loopback_modem.methods:closeAll(process)for g8=0,65535 do self.internalState.modem[g8][process]=nil;if not next(self.internalState.modem[g8])then self.internalState.modem[g8]=nil end end end;function fG.loopback_modem.methods:transmit(process,g8,g9,ga)expect(1,g8,\"number\")g9=expect(2,g9,\"number\",\"nil\")or g8;os.queueEvent(\"modem_message\",self.uuid,g8,g9,ga,0)end;function fG.loopback_modem:init()self.metadata.wireless=true;self.displayName=\"Loopback modem\"self.internalState.modem={}self.internalState.modem.channels={}end;local function gb(gc)local info={scheme=\"\"}for ab in gc:gmatch\".\"do if info.fragment then if ab:match\"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/?]\"then info.fragment=info.fragment..ab else error(\"Invalid URI\",3)end elseif info.query then if ab==\"#\"then info.fragment=\"\"elseif ab:match\"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/?]\"then info.query=info.query..ab else error(\"Invalid URI\",3)end elseif info.path then if ab==\"/\"and info.path==\"/\"and not info.host then info.path,info.host=nil,\"\"elseif ab==\"?\"then info.query=\"\"elseif ab==\"#\"then info.fragment=\"\"elseif ab:match\"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/]\"then info.path=info.path..ab else error(\"Invalid URI\",3)end elseif info.port then if tonumber(ab)then info.port=info.port..ab elseif ab==\"/\"then info.path=\"/\"else error(\"Invalid URI\",3)end elseif info.host then if ab==\"@\"and not info.user then info.user,info.host=info.host,\"\"elseif ab==\":\"then info.port=\"\"elseif ab==\"/\"then info.path=\"/\"elseif ab:match\"[%w%-%._~%%/!%$&'%(%)%*%+,;=]\"then info.host=info.host..ab else error(\"Invalid URI\",3)end else if ab==\":\"then info.path=\"\"elseif ab:match(info.scheme==\"\"and\"[%a%+%-%.]\"or\"[%w%+%-%.]\")then info.scheme=info.scheme..ab else error(\"Invalid URI\",3)end end end;if info.port then info.port=tonumber(info.port)end;return info end;local function gd(ge)if ge:match\"^%d+$\"then return tonumber(ge)elseif ge:match\"^%d+%.%d+$\"then return tonumber(ge:match\"^%d+\")*0x1000000+tonumber(ge:match\"^%d+%.(%d+)\")elseif ge:match\"^%d+%.%d+%.%d+$\"then return tonumber(ge:match\"^(%d+)\")*0x1000000+tonumber(ge:match\"^%d+%.(%d+)\")*0x10000+tonumber(ge:match\"^%d+%.%d+%.(%d+)\")elseif ge:match\"^%d+%.%d+%.%d+%.%d+$\"then return tonumber(ge:match\"^(%d+)\")*0x1000000+tonumber(ge:match\"^%d+%.(%d+)\")*0x10000+tonumber(ge:match\"^%d+%.%d+%.(%d+)\")*0x100+tonumber(ge:match\"^%d+%.%d+%.%d+%.(%d+)\")else error(\"Invalid IP address\",2)end end;local function gf(b)if not b then return nil end;return(\"%d.%d.%d.%d\"):format(bit32.band(bit32.rshift(b,24),0xFF),bit32.band(bit32.rshift(b,16),0xFF),bit32.band(bit32.rshift(b,8),0xFF),bit32.band(b,0xFF))end;local function gg(gh)local bt=\"\"for x=1,gh do bt=bt..string.char(math.random(0,255))end;return bt end;local function gi(b)return bit32.bnot(2^(32-b)-1)end;local function gj(y)local t=0;while bit32.btest(y,0x80000000)do y,t=bit32.lshift(y,1),t+1 end;return t end;local function gk(dX)if not dX then error(\"No such device\")end;for B,k in pairs(dX.drivers)do if k.type==\"modem\"then return dX end end;error(\"Not a modem\")end;local gl=0;local gm={}local gn={maxn=0,[0]={}}local go={}local gp={send={},recv={}}local gq={}local gr={}local gs=setmetatable({},{__mode=\"k\"})local gt={arp={},socket={}}local gu={}function gp.send.link(info,gv,ag)expect(2,gv,\"number\",\"nil\")expect.field(info,\"device\",\"table\")local bB={PhoenixNetworking=true,type=\"link\",source=os.computerID(),destination=gv,payload=ag}if gv==os.computerID()then os.queueEvent(\"modem_message\",info.device.id,info.outPort or 0,info.inPort or 0,bB,0)else hardware.call(info.process or KERNEL,info.device,\"transmit\",info.outPort or 0,info.inPort or 0,bB)end end;function gp.send.arp_request(info,ge)expect.field(info,\"device\",\"table\")expect(2,ge,\"string\")hardware.call(info.process or KERNEL,info.device,\"transmit\",0,0,{PhoenixNetworking=true,type=\"arp\",reply=false,source=os.computerID(),sourceIP=gm[info.device.uuid]and gf(gm[info.device.uuid].ip),destinationIP=ge})end;function gp.send.arp_reply(info,gv,gw)expect.field(info,\"device\",\"table\")expect(2,gv,\"number\")expect(3,gw,\"string\",\"nil\")hardware.call(info.process or KERNEL,info.device,\"transmit\",0,0,{PhoenixNetworking=true,type=\"arp\",reply=true,source=os.computerID(),sourceIP=gf(gm[info.device.uuid].ip),destination=gv,destinationIP=gw})end;function gp.send.internet(info,gv,ag,gx)expect(2,gv,\"number\")local ep={PhoenixNetworking=true,type=\"internet\",hopsLeft=gx or 15,payload=ag,destination=gf(gv)}local aD=gg(32)ep.messageID=aD;local k;for x=gn.maxn,0,-1 do if gn[x]then for B,gy in ipairs(gn[x])do if bit32.band(gy.source,gy.sourceNetmask)==bit32.band(gv,gy.sourceNetmask)and(not k or gj(gy.sourceNetmask)>gj(k.sourceNetmask))then k=gy end end end end;if not k then return gp.recv.control({},{PhoenixNetworking=true,messageType=\"unreachable\",error=\"No route to host\",payload=ep})end;if k.action==\"unicast\"and gm[k.device.uuid]and gm[k.device.uuid].up then info.device=k.device;ep.source=gf(gm[k.device.uuid].ip)if go[k.device.uuid]and go[k.device.uuid][k.destination]then return gp.send.link(info,go[k.device.uuid][k.destination],ep)end;local gz=false;local fB;local function gA(B,ge,bF)if not gz and gd(ge)==k.destination then gz=true;gp.send.link(info,bF,ep)end;if gz then for x,f in ipairs(gt.arp)do if f==gA then table.remove(gt.arp,x)break end end end end;local function gB(au)if au[2]==fB then if not gz then gp.recv.control({},{PhoenixNetworking=true,messageType=\"unreachable\",error=\"No route to host\",payload=ep})end;gz=true;for x,ah in ipairs(eventHooks.timer)do if ah==gB then table.remove(eventHooks.timer,x)break end end;for x,f in ipairs(gt.arp)do if f==gA then table.remove(gt.arp,x)break end end end end;gt.arp[#gt.arp+1]=gA;gp.send.arp_request(info,gf(k.destination))eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=gB;fB=os.startTimer(2)return elseif k.action==\"broadcast\"and gm[k.device.uuid]and gm[k.device.uuid].up then info.device=k.device;ep.source=gf(gm[k.device.uuid].ip)return gp.send.link(info,nil,ep)elseif k.action==\"local\"and gm[k.device.uuid]and gm[k.device.uuid].up then info.device=k.device;ep.source=gf(gm[k.device.uuid].ip)if go[k.device.uuid]and go[k.device.uuid][gv]then return gp.send.link(info,go[k.device.uuid][gv],ep)end;local gz=false;local fB;local function gA(B,ge,bF)if not gz and gd(ge)==gv then gz=true;gp.send.link(info,bF,ep)end;if gz then for x,f in ipairs(gt.arp)do if f==gA then table.remove(gt.arp,x)break end end end end;local function gB(au)if au[2]==fB then if not gz then gp.recv.control({},{PhoenixNetworking=true,messageType=\"unreachable\",error=\"No route to host\",payload=ep})end;gz=true;for x,ah in ipairs(eventHooks.timer)do if ah==gB then table.remove(eventHooks.timer,x)break end end end end;gt.arp[#gt.arp+1]=gA;gp.send.arp_request(info,gf(gv))eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=gB;fB=os.startTimer(2)return elseif k.action==\"unreachable\"then return gp.recv.control({},{PhoenixNetworking=true,messageType=\"unreachable\",error=\"Destination unreachable\",payload=ep})elseif k.action==\"prohibit\"then return gp.recv.control({},{PhoenixNetworking=true,messageType=\"unreachable\",error=\"Prohibited\",payload=ep})elseif k.action==\"blackhole\"then return end end;function gp.send.control(info,gv,type,q,gC,gx)expect(3,type,\"string\")expect(4,q,\"string\",\"nil\")return gp.send.internet(info,gv,{PhoenixNetworking=true,type=\"control\",messageType=type,error=q,payload=gC},gx)end;gp.send.socket={}function gp.send.socket.connect(info,ge,gD,gE)for x=1,16384 do local G=math.random(49152,65535)if not gq[G]or not gq[G][gD]then gE.localPort=G;break end end;if not gE.localPort then error(\"Too many open sockets\")end;gE.id=gl;gl=gl+1;gE.ip=ge;gE.port=gD;gE.sendSeq=math.floor(math.random()*0x10000000000)gE.sendSeqNext=gE.sendSeq+2;gE.sendSeqMax=gE.sendSeq+256;info.outPort=gD;info.inPort=gE.localPort;gs[gE]=function(G)if G.type==\"control\"and G.payload.destination==gf(ge)then gE.status=\"error\"gE.error=G.error;return true end;return false end;gp.send.internet(info,ge,{PhoenixNetworking=true,type=\"socket\",sequence=gE.sendSeqNext-1,windowSize=256,synchronize=true})local bh,q=pcall(hardware.call,info.process or KERNEL,info.device,\"open\",gE.localPort)if not bh then gp.send.internet(info,ge,{PhoenixNetworking=true,type=\"socket\",sequence=gE.sendSeqNext,windowSize=0,reset=true})gE.status=\"error\"gE.error=q;return false end;gE.status=\"syn-sent\"gE.nextUpdate=os.epoch\"utc\"+5000;gE.process=info.process;gE.retryCount=0;gq[gE.localPort]=gq[gE.localPort]or{}gq[gE.localPort][gD]=gE;gr[gE.id]=gE end;function gp.send.socket.data(info,ag,gE)info.outPort=gE.port;info.inPort=gE.localPort;ag.PhoenixNetworking=true;ag.type=\"socket\"if not ag.sequence then ag.sequence=gE.sendSeqNext;gE.sendSeqNext=gE.sendSeqNext+1 end;ag.acknowledgement=ag.acknowledgement or gE.recvSeq-1;gE.nextAck=nil;if not ag.final then ag.windowSize=256 end;return gp.send.internet(info,gE.ip,ag)end;function gp.send.socket.ack(info,b,gE)return gp.send.socket.data(info,{acknowledgement=b},gE)end;function gp.send.socket.reset(info,ge,gD,gF,gG,gH)info.outPort=gD;info.inPort=gH or gD;return gp.send.internet(info,ge,{PhoenixNetworking=true,type=\"socket\",sequence=gF,acknowledgement=gG,reset=true})end;local function gI(gE,p,...)p=p or\"*l\"if type(p)~=\"string\"and type(p)~=\"number\"then error(\"bad argument (expected string or number, got \"..type(p)..\")\",2)end;if gE.buffer==\"\"then return nil end;p=p:gsub(\"^%*\",\"\")if p==\"a\"then local a2=gE.buffer;gE.buffer=\"\"return a2 elseif p==\"l\"then local a2,a9=gE.buffer:match\"^([^\\n]*)\\n?()\"if a2 then gE.buffer=gE.buffer:sub(a9)if select(\"#\",...)>0 then return a2,gI(gE,...)else return a2 end else return nil end elseif p==\"L\"then local a2,a9=gE.buffer:match\"^([^\\n]*\\n?)()\"if a2 then gE.buffer=gE.buffer:sub(a9)if select(\"#\",...)>0 then return a2,gI(gE,...)else return a2 end else return nil end elseif p==\"n\"then local a2,a9=gE.buffer:match\"(%d+)()\"if a2 then gE.buffer=gE.buffer:sub(a9)if select(\"#\",...)>0 then return tonumber(a2),gI(gE,...)else return tonumber(a2)end else return nil end elseif type(p)==\"number\"then local a2=gE.buffer:sub(1,p)gE.buffer=gE.buffer:sub(p+1)if select(\"#\",...)>0 then return a2,gI(gE,...)else return a2 end else error(\"bad argument (invalid mode '\"..p..\"')\",2)end end;local function gJ(gE,bk,...)bk=tostring(bk)gE.outQueue[gE.sendSeqNext]=bk;gp.send.socket.data({},{payload=bk},gE)if select(\"#\",...)>0 then return gJ(gE,...)end end;function syscalls.__socketcall(process,at,aD,fn,...)local gE=gr[aD]if not gE then error(\"No such socket\")end;local gK=process;while process~=gE.process do if process==nil then error(\"No such socket\")end;process=processes[process.parent or-1]end;if fn==\"close\"then gE.sendSeqMax=gE.sendSeqNext;gp.send.socket.data({},{final=true},gE)gE.status=\"fin-wait\"elseif fn==\"read\"then return gI(gE,...)elseif fn==\"write\"then return gJ(gE,...)elseif fn==\"transfer\"then gE.process=gK else error(\"No such method\")end end;local do_syscall=do_syscall;local function gL(gE)local bB=setmetatable({id=gE.id},{__name=\"socket\"})function bB:localIP()return gE.localIP end;function bB:status()if gE.status==\"listening\"or gE.status==\"syn-sent\"or gE.status==\"syn-received\"then return\"connecting\"elseif gE.status==\"connected\"or gE.buffer~=\"\"then return\"open\"elseif gE.status==\"error\"then return\"error\",gE.error else return\"closed\"end end;function bB:read(p,...)if gE.status~=\"connected\"and gE.status~=\"close-wait\"and gE.status~=\"closed\"then error(\"attempt to read from a \"..gE.status..\" handle\",2)end;return do_syscall(\"__socketcall\",gE.id,\"read\",p,...)end;function bB:write(bk,...)if gE.status~=\"connected\"then error(\"attempt to write to a \"..gE.status..\" handle\",2)end;return do_syscall(\"__socketcall\",gE.id,\"write\",bk,...)end;function bB:close()if gE.status==\"closing\"or gE.status==\"fin-wait\"or gE.status==\"closed\"then return end;if not(gE.status==\"listening\"or gE.status==\"syn-sent\"or gE.status==\"syn-received\"or gE.status==\"connected\")then error(\"attempt to close a \"..gE.status..\" handle\",2)end;return do_syscall(\"__socketcall\",gE.id,\"close\")end;function bB:transfer()return do_syscall(\"__socketcall\",gE.id,\"transfer\")end;return bB end;function gp.recv.link(info,ag)expect.field(ag,\"source\",\"number\")expect.field(ag,\"destination\",\"number\")expect.field(ag,\"payload\",\"table\")syslog.debug(\"Received link message from\",ag.source,\"to\",ag.destination)if ag.destination~=os.computerID()then return end;info.sourceID=ag.source;assert(ag.payload.PhoenixNetworking)expect.field(ag.payload,\"type\",\"string\")if not gp.recv[ag.payload.type]then error(\"Unknown protocol '\"..ag.payload.type..\"'\")end;return gp.recv[ag.payload.type](info,ag.payload)end;function gp.recv.arp(info,ag)expect.field(ag,\"source\",\"number\")expect.field(ag,\"reply\",\"boolean\")syslog.debug(\"Received arp message from\",ag.source)if not ag.reply and ag.destinationIP and ag.sourceIP~=ag.destinationIP then local ge=gd(expect.field(ag,\"destinationIP\",\"string\"))if gm[info.device.uuid]and gm[info.device.uuid].ip==ge then gp.send.arp_reply(info,ag.source,ag.sourceIP)end end;if ag.sourceIP then local ge=gd(expect.field(ag,\"sourceIP\",\"string\"))go[info.device.uuid]=go[info.device.uuid]or{}go[info.device.uuid][ge]=ag.source;local gM={}for x,k in ipairs(gt.arp)do gM[x]=k end;for B,k in ipairs(gM)do k(k,ag.sourceIP,ag.source)end end end;function gp.recv.internet(info,ag)info.sourceIP=gd(expect.field(ag,\"source\",\"string\"))local bF=gd(expect.field(ag,\"destination\",\"string\"))info.localIP=bF;syslog.debug(\"Received internet message from\",ag.source,\"to\",ag.destination)expect.field(ag,\"payload\",\"table\")if gu[expect.field(ag,\"messageID\",\"number\",\"string\")]then return end;gu[ag.messageID]=os.epoch\"utc\"if not gm[info.device.uuid]or gm[info.device.uuid].ip~=bF then local a7=false;for B,k in pairs(gs)do a7=k(ag)or a7 end;return a7 end;info.ipPacket=ag;assert(ag.payload.PhoenixNetworking)expect.field(ag.payload,\"type\",\"string\")if not gp.recv[ag.payload.type]then error(\"Unknown protocol '\"..ag.payload.type..\"'\")end;return gp.recv[ag.payload.type](info,ag.payload)end;function gp.recv.control(info,ag)expect.field(ag,\"messageType\",\"string\")syslog.debug(\"Received control message\",ag.messageType)local a7=false;if ag.messageType==\"ping\"then gp.send.control({device=info.device},info.sourceIP,\"pong\",nil,info.ipPacket)else for B,k in pairs(gs)do a7=k{type=\"control\",messageType=ag.messageType,error=ag.error,payload=ag.payload,sender=gf(info.sourceIP)}or a7 end end;return a7 end;function gp.recv.socket(info,ag)expect.field(ag,\"sequence\",\"number\")expect.field(ag,\"acknowledgement\",\"number\",\"nil\")expect.field(ag,\"windowSize\",\"number\",\"nil\")expect.field(ag,\"payload\",\"string\",\"nil\")if info.channel==0 or info.replyChannel==0 then syslog.debug(\"Received socket event on channel 0; discarding.\")return end;local gE=(gq[info.channel]or{})[info.replyChannel]or(gq[info.channel]or{}).listen;if not gE then if ag.acknowledgement then gp.send.socket.reset(info,info.sourceIP,info.replyChannel,ag.acknowledgement,nil,info.channel)else gp.send.socket.reset(info,info.sourceIP,info.replyChannel,0,ag.sequence+(ag.windowSize or 0),info.channel)end;return end;do local bt={}for j,k in pairs(gE)do if j~=\"process\"then bt[j]=k end end;syslog.debug(\"Received socket message:\",serialize(ag),\"\\nSocket info:\",serialize(bt))end;if gE.status==\"listening\"then if ag.reset then return end;if ag.acknowledgement then gp.send.socket.reset(info,info.sourceIP,info.replyChannel,ag.acknowledgement,nil,info.channel)return end;if not ag.synchronize then return end;gE.ip=info.sourceIP;gE.localIP=gf(info.localIP)gE.port=info.replyChannel;gE.recvSeq=ag.sequence+1;gE.recvSeqMax=gE.recvSeq+(ag.windowSize or 0)gE.sendSeq=math.floor(math.random()*0x10000000000)gE.sendSeqNext=gE.sendSeq+2;gE.sendSeqMax=gE.sendSeq+(ag.windowSize or 0)gE.status=\"syn-received\"gE.nextUpdate=os.epoch\"utc\"+5000;gE.retryCount=0;gq[info.channel][info.replyChannel]=gE;gq[info.channel].listen=nil;gp.send.internet({inPort=info.channel,outPort=info.replyChannel},gE.ip,{PhoenixNetworking=true,type=\"socket\",sequence=gE.sendSeqNext-1,acknowledgement=gE.recvSeq,windowSize=256,synchronize=true})elseif gE.status==\"syn-sent\"then if ag.reset then gE.status=\"error\"gE.error=\"Connection refused\"gq[info.channel][info.replyChannel]=nil;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={\"handle_status_change\",{id=gE.id,status=\"error\"}}end;return true end;if not ag.synchronize or not ag.acknowledgement or ag.acknowledgement<gE.sendSeq then gp.send.socket.reset(info,info.sourceIP,info.replyChannel,ag.acknowledgement,nil,info.channel)gE.status=\"error\"gE.error=\"Connection refused\"gq[info.channel][info.replyChannel]=nil;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={\"handle_status_change\",{id=gE.id,status=\"error\"}}end;return true end;gE.localIP=gf(info.localIP)gE.status=\"connected\"gE.sendSeq=ag.acknowledgement;gE.sendSeqMax=gE.sendSeq+256;gE.recvSeq=ag.sequence+1;gE.recvSeqMax=gE.recvSeq+(ag.windowSize or 0)gE.outQueue={}gE.nextUpdate=os.epoch\"utc\"+2000;gp.send.socket.ack({},gE.recvSeq,gE)if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={\"handle_status_change\",{id=gE.id,status=\"connected\"}}end;return true else if ag.sequence<gE.recvSeq or ag.sequence>gE.recvSeqMax then syslog.debug(\"Sequence out of range\")if ag.reset then gE.status=\"error\"gE.error=\"Connection reset by peer\"gq[info.channel][info.replyChannel]=nil;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={\"handle_status_change\",{id=gE.id,status=\"error\"}}end;return true else gp.send.socket.ack({},gE.recvSeq,gE)return end end;if ag.reset then syslog.debug(\"Received reset\")if gE.status==\"syn-received\"then gE.status=\"listening\"return elseif gE.status==\"connected\"or gE.status==\"fin-wait\"then gE.status=\"error\"gE.error=\"Connection reset by peer\"gq[info.channel][info.replyChannel]=nil;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={\"handle_status_change\",{id=gE.id,status=\"error\"}}end;return true else gE.status=\"closed\"gq[info.channel][info.replyChannel]=nil;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={\"handle_status_change\",{id=gE.id,status=\"closed\"}}end;return true end end;if ag.synchronize then gp.send.socket.reset(info,info.sourceIP,info.replyChannel,ag.acknowledgement,nil,info.channel)gE.status=\"error\"gE.error=\"Connection reset by host\"gq[info.channel][info.replyChannel]=nil;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={\"handle_status_change\",{id=gE.id,status=\"error\"}}end;return true end;local a7;if not ag.acknowledgement then syslog.debug(\"No acknowledgement\")return end;if gE.status==\"syn-received\"then if ag.acknowledgement>=gE.sendSeq and ag.acknowledgement<=gE.sendSeqNext then gE.status=\"connected\"gE.outQueue={}gE.nextUpdate=os.epoch\"utc\"+2000;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={\"network_request\",{uri=gE.uri,ip=gf(info.sourceIP),handle=gL(gE)}}end;a7=true else gp.send.socket.reset(info,info.sourceIP,info.replyChannel,ag.acknowledgement,nil,info.channel)gE.status=\"error\"gE.error=\"Connection reset by host\"gq[info.channel][info.replyChannel]=nil;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={\"handle_status_change\",{id=gE.id,status=\"error\"}}end;return true end elseif gE.status==\"close-wait\"then if ag.acknowledgement==gE.sendSeqMax then syslog.debug(\"Socket closed\")gE.status=\"closed\"gq[info.channel][info.replyChannel]=nil;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={\"handle_status_change\",{id=gE.id,status=\"closed\"}}end;return true end elseif gE.status==\"time-wait\"then if ag.final then gp.send.socket.ack({},ag.sequence,gE)gE.nextUpdate=os.epoch\"utc\"+10000;return end else if ag.acknowledgement>gE.sendSeq and ag.acknowledgement<=gE.sendSeqNext then for x=gE.sendSeq,ag.acknowledgement do gE.outQueue[x]=nil end;gE.sendSeq=ag.acknowledgement;if ag.windowSize then gE.sendSeqMax=gE.sendSeq+ag.windowSize end end;if gE.status==\"fin-wait\"then if ag.acknowledgement==gE.sendSeqMax then if not ag.final then gp.send.socket.reset(info,info.sourceIP,info.replyChannel,ag.acknowledgement,nil,info.channel)gE.status=\"error\"gE.error=\"Connection reset by host\"gq[info.channel][info.replyChannel]=nil;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={\"handle_status_change\",{id=gE.id,status=\"error\"}}end;return true end;gE.status=\"time-wait\"gE.nextUpdate=os.epoch\"utc\"+10000 end elseif gE.status==\"closing\"then if ag.acknowledgement==gE.sendSeqMax then gE.status=\"time-wait\"gE.nextUpdate=os.epoch\"utc\"+10000 end end end;if gE.status==\"connected\"and ag.sequence==gE.recvSeq then if ag.payload then gE.buffer=gE.buffer..ag.payload;gE.nextAck=true;gE.nextUpdate=os.epoch\"utc\"+100;if gE.process then syslog.debug(\"Sending data event to PID \"..gE.process.id)gE.process.eventQueue[#gE.process.eventQueue+1]={\"handle_data_ready\",{id=gE.id}}end;a7=true end;gE.recvSeq=gE.recvSeq+1 end;if ag.final then syslog.debug(\"Got final message\")gE.recvSeq=ag.sequence+1;if gE.status==\"syn-received\"or gE.status==\"connected\"then gE.sendSeqMax=gE.sendSeqNext;gp.send.socket.data({},{final=true,acknowledgement=ag.sequence},gE)gE.status=\"close-wait\"if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={\"handle_status_change\",{id=gE.id,status=\"closed\"}}end;return true elseif gE.status==\"fin-wait\"then gp.send.socket.ack({},ag.sequence,gE)if ag.acknowledgement~=gE.sendSeqMax then gE.status=\"closing\"else gE.status=\"time-wait\"gE.nextUpdate=os.epoch\"utc\"+10000 end else gp.send.socket.ack({},ag.sequence,gE)end;syslog.debug(gE.status)end;return a7 end end;local function gN()local ca=os.epoch\"utc\"local cd=false;for gD,be in pairs(gq)do for gO,gE in pairs(be)do if ca>=gE.nextUpdate then if gE.status==\"syn-sent\"then gE.status=\"error\"gE.error=\"Connection timed out (syn-sent)\"gq[gD][gO]=nil;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={\"handle_status_change\",{id=gE.id,status=\"error\"}}cd=true end elseif gE.status==\"syn-received\"then gE.retryCount=gE.retryCount+1;if gE.retryCount>3 then gE.status=\"error\"gE.error=\"Connection timed out (syn-received)\"gq[gD][gO]=nil;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={\"handle_status_change\",{id=gE.id,status=\"error\"}}cd=true end else gE.nextUpdate=os.epoch\"utc\"+2000 end elseif gE.status==\"connected\"then for x=gE.sendSeq+1,gE.sendSeqNext-1 do if gE.outQueue[x]then gp.send.socket.data({},{sequence=x,payload=gE.outQueue[x]},gE)end end;if gE.nextAck then gp.send.socket.ack({},gE.recvSeq-1,gE)gE.nextAck=nil end;gE.nextUpdate=os.epoch\"utc\"+2000 elseif gE.status==\"fin-wait\"then elseif gE.status==\"close-wait\"then elseif gE.status==\"time-wait\"then syslog.debug(\"Time wait finished on port \"..gD)gE.status=\"closed\"gq[gD][gO]=nil end end end end;return cd end;eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(au)if type(au[5])==\"table\"and au[5].PhoenixNetworking and type(au[5].type)==\"string\"and gp.recv[au[5].type]then local dX=getNodeById(au[2])or hardware.get(au[2])if not dX then syslog.log({level=\"notice\",module=\"Network\"},\"Received network event for device ID \"..au[2]..\", but no device node was found; ignoring\")return end;if not gm[dX.uuid]or not gm[dX.uuid].up then return end;syslog.debug(au[2],serialize(au[5]))local bh,q=pcall(gp.recv[au[5].type],{channel=au[3],replyChannel=au[4],device=dX},au[5])if not bh then syslog.log({level=\"debug\",module=\"Network\"},\"Network event errored while processing:\",q)else return q end end end;local gP=os.startTimer(1)eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=function(au)if au[2]==gP then gP=os.startTimer(1)return gN()end end;local function gQ(process,bK)local gc=gb(bK.url)if not gc.port then error(\"No port specified\")end;local ge=gd(gc.host)local gD=gc.port;local gE={process=process,buffer=\"\"}gp.send.socket.connect({process=process},ge,gD,gE)return gL(gE)end;local gR={}local gS={}local gT={}local gU=os.computerID()%65500;local gV={}eventHooks.http_success=eventHooks.http_success or{}eventHooks.http_success[#eventHooks.http_success+1]=function(au)local info=gR[au[2]]if info then info.handle,info.status=au[3],\"open\"info.process.eventQueue[#info.process.eventQueue+1]={\"handle_status_change\",{id=info.id,status=\"open\"}}gR[au[2]]=nil;return true else syslog.log({level=\"notice\"},\"Received HTTP response for \"..au[2]..\" but nobody requested it; ignoring.\")end end;eventHooks.http_failure=eventHooks.http_failure or{}eventHooks.http_failure[#eventHooks.http_failure+1]=function(au)local info=gR[au[2]]if info then if au[4]then info.handle,info.status=au[4],\"open\"else info.status,info.error=\"error\",au[3]end;info.process.eventQueue[#info.process.eventQueue+1]={\"handle_status_change\",{id=info.id,status=info.status}}gR[au[2]]=nil;return true else syslog.log({level=\"notice\"},\"Received HTTP response for \"..au[2]..\" but nobody requested it; ignoring.\")end end;eventHooks.websocket_success=eventHooks.websocket_success or{}eventHooks.websocket_success[#eventHooks.websocket_success+1]=function(au)local info=gR[au[2]]if info then info.handle,info.status=au[3],\"open\"info.process.eventQueue[#info.process.eventQueue+1]={\"handle_status_change\",{id=info.id,status=\"open\"}}return true else syslog.log({level=\"notice\"},\"Received WebSocket response for \"..au[2]..\" but nobody requested it; ignoring.\")end end;eventHooks.websocket_failure=eventHooks.websocket_failure or{}eventHooks.websocket_failure[#eventHooks.websocket_failure+1]=function(au)local info=gR[au[2]]if info then info.status,info.error=\"error\",au[3]info.process.eventQueue[#info.process.eventQueue+1]={\"handle_status_change\",{id=info.id,status=info.status}}return true else syslog.log({level=\"notice\"},\"Received WebSocket response for \"..au[2]..\" but nobody requested it; ignoring.\")end end;eventHooks.websocket_message=eventHooks.websocket_message or{}eventHooks.websocket_message[#eventHooks.websocket_message+1]=function(au)local info=gR[au[2]]if info then info.buffer=info.buffer..au[3]info.process.eventQueue[#info.process.eventQueue+1]={\"handle_data_ready\",{id=info.id}}return true else syslog.log({level=\"notice\"},\"Received WebSocket message for \"..au[2]..\" but nobody requested it; ignoring.\")end end;eventHooks.websocket_closed=eventHooks.websocket_closed or{}eventHooks.websocket_closed[#eventHooks.websocket_closed+1]=function(au)local info=gR[au[2]]if info then info.status=\"closed\"info.process.eventQueue[#info.process.eventQueue+1]={\"handle_status_change\",{id=info.id,status=info.status}}gR[au[2]]=nil;return true else syslog.log({level=\"notice\"},\"Received WebSocket message for \"..au[2]..\" but it's not open; ignoring.\")end end;eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(au)local a7=false;if gS[au[2]]and(au[3]==gU or au[3]==65535)and type(au[5])==\"table\"and type(au[5].nMessageID)==\"number\"and au[5].nMessageID==au[5].nMessageID and not gV[au[5].nMessageID]and(au[5].nRecipient and au[5].nRecipient==os.computerID()or au[3]==65535)then if gT[au[5].nSender]then for B,k in ipairs(gT[au[5].nSender])do if not k.protocol or k.protocol==au[5].sProtocol then k.buffer[#k.buffer+1]=deepcopy(au[5].message)gV[au[5].nMessageID]=os.clock()+9.5;k.process.eventQueue[#k.process.eventQueue+1]={\"handle_data_ready\",{id=k.id}}a7=true end end end;if gT[0xFFFFFFFF]then for B,k in ipairs(gT[0xFFFFFFFF])do if not k.protocol or k.protocol==au[5].sProtocol then k.buffer[#k.buffer+1]=deepcopy(au[5].message)gV[au[5].nMessageID]=os.clock()+9.5;k.process.eventQueue[#k.process.eventQueue+1]={\"handle_data_ready\",{id=k.id}}a7=true end end end;for j,k in pairs(gV)do if k<os.clock()then gV[j]=nil end end end;return a7 end;local gW=http.request;local function gX(process,bK)expect.field(bK,\"encoding\",\"string\",\"nil\")expect.field(bK,\"headers\",\"table\",\"nil\")expect.field(bK,\"method\",\"string\",\"nil\")expect.field(bK,\"redirect\",\"boolean\",\"nil\")local info={status=\"ready\",process=process,id=gl}local bB=setmetatable({id=gl},{__name=\"socket\"})gl=gl+1;function bB:status()return info.status,info.error end;function bB:read(p,...)if info.status~=\"open\"then error(\"attempt to read from a \"..info.status..\" handle\",2)end;p=p or\"*l\"if type(p)~=\"string\"and type(p)~=\"number\"then error(\"bad argument (expected string or number, got \"..type(p)..\")\",2)end;p=p:gsub(\"^%*\",\"\")if p==\"a\"then if select(\"#\",...)>0 then return info.handle.readAll(),self:read(...)else return info.handle.readAll()end elseif p==\"l\"then if select(\"#\",...)>0 then return info.handle.readLine(false),self:read(...)else return info.handle.readLine(false)end elseif p==\"L\"then if select(\"#\",...)>0 then return info.handle.readLine(true),self:read(...)else return info.handle.readLine(true)end elseif p==\"n\"then local a2;repeat a2=info.handle.read(1)if not a2 then return nil end until tonumber(a2)while true do local ab=info.handle.read(1)if not ab or not ab:match\"%d\"then break end;a2=a2 ..ab end;if select(\"#\",...)>0 then return tonumber(a2),self:read(...)else return tonumber(a2)end elseif type(p)==\"number\"then if select(\"#\",...)>0 then return info.handle.read(p),self:read(...)else return info.handle.read(p)end else error(\"bad argument (invalid mode '\"..p..\"')\",2)end end;function bB:write(...)if info.status~=\"ready\"then error(\"attempt to write to a \"..info.status..\" handle\",2)end;local bk;if select(\"#\",...)>0 then bk=\"\"for B,k in ipairs{...}do bk=bk..tostring(k)end end;local gY=bK.url..\"#\"..info.id;local bh,q=gW{url=gY,body=bk,headers=bK.headers,binary=bK.encoding==\"binary\"or bK.encoding==nil,method=bK.method,redirect=bK.redirect}if bh then gR[gY]=info;info.status=\"connecting\"else info.status,info.error=\"error\",q end end;function bB:close()if info.status~=\"open\"then error(\"attempt to close a \"..info.status..\" handle\",2)end;info.handle.close()info.status=\"closed\"end;function bB:responseHeaders()if info.status~=\"open\"then error(\"attempt to read from a \"..info.status..\" handle\",2)end;return info.handle.getResponseHeaders()end;function bB:responseCode()if info.status~=\"open\"then error(\"attempt to read from a \"..info.status..\" handle\",2)end;return info.handle.getResponseCode()end;return bB end;local function gZ(process,bK)expect.field(bK,\"encoding\",\"string\",\"nil\")expect.field(bK,\"headers\",\"table\",\"nil\")local info={process=process,id=gl,buffer=\"\"}local bB=setmetatable({id=gl},{__name=\"socket\"})gl=gl+1;function bB:status()return info.status,info.error end;function bB:read(p,...)if info.status~=\"open\"then error(\"attempt to read from a \"..info.status..\" handle\",2)end;p=p or\"*l\"if type(p)~=\"string\"and type(p)~=\"number\"then error(\"bad argument (expected string or number, got \"..type(p)..\")\",2)end;if info.buffer==\"\"then return nil end;p=p:gsub(\"^%*\",\"\")if p==\"a\"then local a2=info.buffer;info.buffer=\"\"return a2 elseif p==\"l\"then local a2,a9=info.buffer:match\"^([^\\n]*)\\n?()\"if a2 then info.buffer=info.buffer:sub(a9)if select(\"#\",...)>0 then return a2,self:read(...)else return a2 end else return nil end elseif p==\"L\"then local a2,a9=info.buffer:match\"^([^\\n]*\\n?)()\"if a2 then info.buffer=info.buffer:sub(a9)if select(\"#\",...)>0 then return a2,self:read(...)else return a2 end else return nil end elseif p==\"n\"then local a2,a9=info.buffer:match\"(%d+)()\"if a2 then info.buffer=info.buffer:sub(a9)if select(\"#\",...)>0 then return tonumber(a2),self:read(...)else return tonumber(a2)end else return nil end elseif type(p)==\"number\"then local a2=info.buffer:sub(1,p)info.buffer=info.buffer:sub(p+1)if select(\"#\",...)>0 then return a2,self:read(...)else return a2 end else error(\"bad argument (invalid mode '\"..p..\"')\",2)end end;function bB:write(bk,...)if info.status~=\"open\"then error(\"attempt to write to a \"..info.status..\" handle\",2)end;info.handle.send(tostring(bk),bK.encoding==\"binary\")if select(\"#\",...)>0 then return self:write(...)end end;function bB:close()if info.status~=\"open\"then error(\"attempt to close a \"..info.status..\" handle\",2)end;info.handle.close()info.status=\"closed\"end;local gY=bK.url..\"#\"..info.id;local bh,q=http.websocket(gY,bK.headers)if bh then gR[gY]=info;info.status=\"connecting\"else return nil,q end;return bB end;local function g_(process,bK)expect.field(bK,\"device\",\"string\",\"nil\")local h0;if bK.device then h0={hardware.get(bK.device)}else h0={hardware.find(\"modem\")}end;if#h0==0 then error(\"Could not find a modem\",2)end;for B,k in ipairs(h0)do gk(k)if not gS[k]then hardware.call(process,k,\"open\",gU)hardware.call(process,k,\"open\",65535)gS[k]=1 else gS[k]=gS[k]+1 end end;local gc=gb(bK.url)if not gc.host then error(\"Missing host\",2)end;local aD=gd(gc.host)local info={process=process,id=gl,buffer={},protocol=gc.scheme:match\"rednet%+(.+)\"}local bB=setmetatable({id=gl},{__name=\"socket\"})gl=gl+1;function bB:status()return info.closed and\"closed\"or\"open\"end;function bB:read(p,...)if info.closed then error(\"attempt to read from a \"..info.status..\" handle\",2)end;p=p or\"*l\"if type(p)~=\"string\"and type(p)~=\"number\"then error(\"bad argument (expected string or number, got \"..type(p)..\")\",2)end;if#info.buffer==0 then return nil end;p=p:gsub(\"^%*\",\"\")if p==\"a\"then return table.remove(info.buffer,1)elseif p==\"l\"then info.buffer[1]=tostring(info.buffer[1])local a2,a9=info.buffer[1]:match\"^([^\\n]*)\\n?()\"if a2 then info.buffer[1]=info.buffer[1]:sub(a9)if select(\"#\",...)>0 then return a2,self:read(...)else return a2 end else table.remove(info.buffer,1)return self:read(p,...)end elseif p==\"L\"then info.buffer[1]=tostring(info.buffer[1])local a2,a9=info.buffer[1]:match\"^([^\\n]*\\n?)()\"if a2 then info.buffer[1]=info.buffer[1]:sub(a9)if select(\"#\",...)>0 then return a2,self:read(...)else return a2 end else table.remove(info.buffer,1)return self:read(p,...)end elseif p==\"n\"then info.buffer[1]=tostring(info.buffer[1])local a2,a9=info.buffer[1]:match\"(%d+)()\"if a2 then info.buffer[1]=info.buffer[1]:sub(a9)if select(\"#\",...)>0 then return tonumber(a2),self:read(...)else return tonumber(a2)end else table.remove(info.buffer,1)return self:read(p,...)end elseif type(p)==\"number\"then local a2=\"\"while#a2<p do info.buffer[1]=tostring(info.buffer[1])a2=a2 ..info.buffer[1]:sub(1,p-#a2)info.buffer[1]=info.buffer[1]:sub(p-#a2+1)if info.buffer[1]==\"\"then table.remove(info.buffer,1)end;if#info.buffer==0 then break end end;if select(\"#\",...)>0 then return a2,self:read(...)else return a2 end else error(\"bad argument (invalid mode '\"..p..\"')\",2)end end;function bB:write(bk,...)if info.closed then error(\"attempt to write to a \"..info.status..\" handle\",2)end;local h1=math.random(1,0x7FFFFFFF)local ep={nMessageID=h1,nRecipient=aD,nSender=os.computerID(),message=bk,sProtocol=info.protocol}if aD==os.computerID()then for B,k in ipairs(h0)do os.queueEvent(\"modem_message\",k.id,gU,gU,ep,0)end else gV[h1]=os.clock()+9.5;for B,k in ipairs(h0)do hardware.call(process,k,\"transmit\",aD==0xFFFFFFFF and 65535 or aD%65500,gU,ep)hardware.call(process,k,\"transmit\",65533,gU,ep)end end;if select(\"#\",...)>0 then return self:write(...)end end;function bB:close()if info.closed then error(\"attempt to close a \"..info.status..\" handle\",2)end;for B,k in ipairs(h0)do gS[k]=gS[k]-1;if gS[k]==0 then hardware.call(process,k,\"close\",gU)hardware.call(process,k,\"close\",65535)gS[k]=nil end end;info.status=\"closed\"end;return bB end;uriSchemes={[\"https?\"]=gX,[\"wss?\"]=gZ,[\"rednet\"]=g_,[\"rednet%+%a+\"]=g_,[\"psp\"]=gQ}function syscalls.connect(process,at,bK)if type(bK)==\"string\"then bK={url=bK}end;expect(1,bK,\"table\")expect.field(bK,\"url\",\"string\")local gc=gb(bK.url)local bB,q;for j,k in pairs(uriSchemes)do if gc.scheme:match(j)then bB,q=k(process,bK)break end end;if not bB and not q then error(\"Invalid protocol \"..gc.scheme)end;if bB then for B,k in pairs(bB)do if type(k)==\"function\"then setfenv(k,process.env)debug.protect(k)end end end;return bB,q end;function syscalls.listen(process,at,gc)expect(1,gc,\"string\")local h2=gb(gc)if http.addListener then if h2.scheme==\"http\"then http.addListener(h2.port or 80)return elseif h2.scheme==\"ws\"then http.websocket(h2.port or 80)return end end;if h2.scheme==\"psp\"then if not h2.port then error(\"Missing port\")end;local ge=gd(h2.host)for j,k in pairs(gm)do if k.up and(ge==0 or k.ip==ge)then hardware.call(process,hardware.get(j),\"open\",h2.port)end end;local gE={localPort=h2.port,id=gl,status=\"listening\",process=process,nextUpdate=math.huge,retryCount=0,uri=gc,buffer=\"\"}gl=gl+1;gq[h2.port]=gq[h2.port]or{}gq[h2.port].listen=gE;gr[gE.id]=gE;return end;error(\"Invalid protocol \"..h2.scheme)end;function syscalls.unlisten(process,at,gc)end;function syscalls.ipconfig(process,at,fp,info)if info and process.user~=\"root\"then error(\"Permission denied\")end;expect(1,fp,\"string\")expect(2,info,\"table\",\"nil\")local dX=gk(hardware.get(fp))local A=gm[dX.uuid]if not A then if info then expect.field(info,\"ip\",\"string\",\"number\")expect.field(info,\"netmask\",\"string\",\"number\")A={up=true}gm[dX.uuid]=A;hardware.call(KERNEL,dX,\"open\",0)else return nil end end;if info then expect.field(info,\"ip\",\"string\",\"number\",\"nil\")expect.field(info,\"netmask\",\"string\",\"number\",\"nil\")expect.field(info,\"up\",\"boolean\",\"nil\")local h3,h4;if A.ip then for B,k in ipairs(gn[0])do if k.source==bit32.band(A.ip,A.netmask)and k.netmask==A.netmask then h3=k elseif k.source==bit32.bor(bit32.band(A.ip,A.netmask),bit32.bnot(A.netmask))and k.netmask==0xFFFFFFFF then h4=k end end end;if info.ip then if go[dX.uuid]then go[dX.uuid][A.ip]=nil end;if type(info.ip)==\"number\"then A.ip=bit32.band(info.ip,0xFFFFFFFF)else A.ip=gd(info.ip)end;if h3 then h3.source=bit32.band(A.ip,A.netmask)end;if h4 then h4.source=bit32.bor(bit32.band(A.ip,A.netmask),bit32.bnot(A.netmask))end;go[dX.uuid]=go[dX.uuid]or{}go[dX.uuid][A.ip]=os.computerID()end;if info.netmask then if type(info.netmask)==\"number\"then A.netmask=gi(info.netmask)else A.netmask=gd(info.netmask)end;if h3 then h3.source=bit32.band(A.ip,A.netmask)end;if h4 then h4.source=bit32.bor(bit32.band(A.ip,A.netmask),bit32.bnot(A.netmask))end end;if info.up~=nil then A.up=info.up;if A.up then hardware.call(KERNEL,dX,\"open\",0)else hardware.call(KERNEL,dX,\"close\",0)end end;if not h3 then gn[0][#gn[0]+1]={source=bit32.band(A.ip,A.netmask),sourceNetmask=A.netmask,action=\"local\",device=dX}end;if not h4 then gn[0][#gn[0]+1]={source=bit32.bor(bit32.band(A.ip,A.netmask),bit32.bnot(A.netmask)),sourceNetmask=0xFFFFFFFF,action=\"broadcast\",device=dX}end end;return{ip=gf(A.ip),netmask=gj(A.netmask),up=A.up}end;function syscalls.routelist(process,at,b)b=expect(1,b,\"number\",\"nil\")or 1;expect.range(b,0)if not gn[b]then return nil end;local a7={}for x,A in ipairs(gn[b])do a7[x]={source=gf(A.source),sourceNetmask=gj(A.sourceNetmask),action=A.action,device=A.device and hardware.path(A.device),destination=A.destination and gf(A.destination)}end;return a7 end;local h5={unicast=true,broadcast=true,[\"local\"]=true,unreachable=true,prohibit=true,blackhole=true}function syscalls.routeadd(process,at,bK)if process.user~=\"root\"then error(\"Permission denied\")end;expect(1,bK,\"table\")expect.field(bK,\"source\",\"string\",\"number\")expect.field(bK,\"sourceNetmask\",\"string\",\"number\")expect.field(bK,\"action\",\"string\")expect.field(bK,\"device\",\"string\",bK.action~=\"unicast\"and bK.action~=\"broadcast\"and bK.action~=\"local\"and\"nil\"or nil)expect.field(bK,\"destination\",\"string\",bK.action~=\"unicast\"and\"nil\"or nil)expect.range(expect.field(bK,\"table\",\"number\",\"nil\")or 1,1)bK.table=bK.table or 1;if not h5[bK.action]then error(\"bad field 'action' (invalid option '\"..bK.action..\"')\")end;local A={}if type(bK.source)==\"number\"then A.source=bit32.band(bK.source,0xFFFFFFFF)else A.source=gd(bK.source)end;if type(bK.sourceNetmask)==\"number\"then A.sourceNetmask=gi(bK.sourceNetmask)else A.sourceNetmask=gd(bK.sourceNetmask)end;A.source=bit32.band(A.source,A.sourceNetmask)A.action=bK.action;A.device=bK.device and gk(hardware.get(bK.device))A.destination=bK.destination and gd(bK.destination)gn[bK.table]=gn[bK.table]or{}for B,k in ipairs(gn[bK.table])do if k.source==A.source and k.sourceNetmask==A.sourceNetmask then error(\"Route already exists\")end end;gn[bK.table][#gn[bK.table]+1]=A;gn.maxn=math.max(gn.maxn,bK.table)end;function syscalls.routedel(process,at,h6,y,b)if process.user~=\"root\"then error(\"Permission denied\")end;expect(1,h6,\"string\",\"number\")expect(2,y,\"string\",\"number\")b=expect(3,b,\"number\",\"nil\")or 1;expect.range(b,1)if type(y)==\"number\"then y=gi(y)else y=gd(y)end;if type(h6)==\"number\"then h6=bit32.band(h6,y)else h6=bit32.band(gd(h6),y)end;if not gn[b]then error(\"Route table does not exist\")end;for x,k in ipairs(gn[b])do if k.source==h6 and k.sourceNetmask==y then table.remove(gn[b],x)return end end end;function syscalls.arplist(process,at,fp)expect(1,fp,\"string\")local dX=gk(hardware.get(fp))local a7={}for j,k in pairs(go[dX.uuid]or{})do a7[gf(j)]=k end;return a7 end;function syscalls.arpset(process,at,fp,ge,aD)if process.user~=\"root\"then error(\"Permission denied\")end;expect(1,fp,\"string\")expect(2,ge,\"string\",\"number\")expect(3,aD,\"number\")local dX=gk(hardware.get(fp))if type(ge)==\"string\"then ge=gd(ge)else ge=bit32.band(ge,0xFFFFFFFF)end;go[dX.uuid]=go[dX.uuid]or{}go[dX.uuid][ge]=aD end;local h7={ping=true,pong=true,unreachable=true,timeout=true}function syscalls.netcontrol(process,at,ge,f0,q,gx)if process.user~=\"root\"then error(\"Permission denied\")end;expect(1,ge,\"string\",\"number\")expect(2,f0,\"string\")expect(3,q,\"string\",\"nil\")expect(4,gx,\"number\",\"nil\")if not h7[f0]then error(\"bad argument #2 (invalid option '\"..f0 ..\"')\")end;if type(ge)==\"string\"then ge=gd(ge)else ge=bit32.band(ge,0xFFFFFFFF)end;gp.send.control({process=process},ge,f0,q,gx)end;function syscalls.netevent(process,at,dA)if process.user~=\"root\"then error(\"Permission denied\")end;expect(1,dA,\"boolean\",\"nil\")if dA==true then gs[process]=function(ag)process.eventQueue[#process.eventQueue+1]={\"network_event\",deepcopy(ag)}return true end elseif dA==false then gs[process]=nil end;return gs[process]~=nil end;function syscalls.checkuri(process,at,gc)end;function registerLoopback()local dX=hardware.get(\"/lo\")if dX then gm[dX.uuid]={ip=0x7F000001,netmask=0xFF000000,up=true}gn[0][#gn[0]+1]={source=0x7F000000,sourceNetmask=0xFF000000,action=\"local\",device=dX}gn[0][#gn[0]+1]={source=0x7FFFFFFF,sourceNetmask=0xFFFFFFFF,action=\"broadcast\",device=dX}go[dX.uuid]=setmetatable({},{__index=function()return os.computerID()end})syslog.log(\"Configured IP for loopback device\")end end;function syscalls.listmodules()local a7={}for j in pairs(modules)do a7[#a7+1]=j end;return a7 end;function syscalls.loadmodule(process,at,g)expect(1,g,\"string\")if process.user~=\"root\"then error(\"Could not load kernel module: Permission denied\",2)end;local bL=filesystem.stat(process,g)if bL.type==\"directory\"then error(\"Could not load kernel module: Is a directory\",2)end;if bL.owner~=\"root\"or bL.worldPermissions.write then error(\"Insecure permissions set on kernel module, refusing to load\",2)end;local o=g:match\"([^%./]+)[^/]*$\"syslog.log(\"Loading kernel module \"..o..\" from \"..g)local a,q=filesystem.open(process,g,\"rb\")if a then local bk=a.readAll()or\"\"a.close()local i,q=load(bk,\"@\"..g)if i then local bh,w=pcall(i,g)if bh then modules[o]=w or true else syslog.log({level=\"error\"},\"Kernel module \"..o..\" threw an error:\",w)end else syslog.log({level=\"error\"},\"Could not load \"..o..\":\",q)end else syslog.log({level=\"error\"},\"Could not open \"..g..\":\",q)end end;function syscalls.unloadmodule(process,at,o)expect(1,o,\"string\")if process.user~=\"root\"then error(\"Could not load kernel module: Permission denied\",2)end;if type(modules[o])==\"table\"and modules[o].unload then modules[o].unload(process,at)end;modules[o]=nil end;function syscalls.callmodule(process,at,o,aC,...)expect(1,o,\"string\")expect(2,aC,\"string\")if not modules[o]then error(\"Module '\"..o..\"' does not exist\",2)elseif type(modules[o])~=\"table\"then error(\"Module '\"..o..\"' does not have a callable interface\",2)elseif aC==\"unload\"or type(modules[o][aC])~=\"function\"then error(\"Module '\"..o..\"' does not have a method '\"..aC..\"'\",2)end;return modules[o][aC](process,at,...)end;syslog.log(\"Loading kernel modules from /lib/modules\")local bh,h8=pcall(filesystem.list,KERNEL,\"/lib/modules\")if bh then for B,k in ipairs(h8)do local G=filesystem.combine(\"/lib/modules\",k)local bL=filesystem.stat(KERNEL,G)if bL.type~=\"directory\"then local bh,q=pcall(syscalls.loadmodule,KERNEL,nil,G)if not bh then syslog.log({level=\"error\"},\"Could not load module from \"..G..\": \"..q)end end end else syslog.log({level=\"notice\"},\"Could not open /lib/modules:\",h8)end;xpcall(hardware.register,function(error)panic(\"An error occurred while registering devices: \"..error)end,deviceTreeRoot,rootDriver)local as={n=0}local h9=processes[syscalls.fork(KERNEL,nil,function()end,\"init\")]local ha=h9.id;local hb,hc;if args.init then hb,hc=pcall(syscalls.exec,h9,nil,args.initrd and\"/init\"or args.init)end;if not hb then syslog.log({level=\"error\",process=0},\"Could not load init:\",hc)syslog.log(\"Could not find provided init, trying default locations\")for B,k in ipairs{\"/sbin/init\",\"/etc/init\",\"/bin/init\",\"/bin/sh\"}do syslog.log(\"Trying\",k)hb,hc=pcall(syscalls.exec,h9,nil,k)if not hb then syslog.log({level=\"error\",process=0},\"Could not load init:\",hc)end;if hb then break end end;if not hb then panic(\"No working init found\")end end;syslog.log(\"Starting init from \"..processes[ha].name)local aw=false;local hd=setmetatable({},{__mode=\"k\"})function wakeup(process)if#process.eventQueue>0 and not hd[process]then aw=false end end;local da=coroutine.yield;function coroutine.yield(...)if coroutine.running()==mainThread then error(\"attempt to yield from kernel main thread\",2)end;return da(...)end;debug.protect(coroutine.yield)eventHooks.key=eventHooks.key or{}eventHooks.key[#eventHooks.key+1]=function(au)if keysHeld.ctrl and keysHeld.shift and au[2]==keys.f10 then term.clear()term.setCursorPos(1,1)term.write(\"Entering debug console.\")local s=2;local aZ=true;term.setCursorPos(1,s)while aZ do local al=\"\"local ah,ai=term.getSize()term.write(\"lua> \")term.setCursorBlink(true)while true do local au={da()}if au[1]==\"char\"or au[1]==\"paste\"then al=al..au[2]term.write(au[2])elseif au[1]==\"key\"then if au[2]==keys.backspace and#al>0 then al=al:sub(1,-2)term.setCursorPos(term.getCursorPos()-1,s)term.write(\" \")term.setCursorPos(term.getCursorPos()-1,s)elseif au[2]==keys.enter then break end end end;s=s+1;if s>ai then s=s-1;term.scroll(1)end;term.setCursorPos(1,s)local i,q=load(\"return \"..al,\"=lua\",\"t\",setmetatable({exit=function()aZ=false end},{__index=_G}))if not i then i,q=load(al,\"=lua\",\"t\",setmetatable({exit=function()aZ=false end},{__index=_G}))end;if i then local w=table.pack(pcall(i))if w[1]then for x=2,w.n do term.write(tostring(w[x]))s=s+1;if s>ai then s=s-1;term.scroll(1)end;term.setCursorPos(1,s)end else term.setTextColor(16384)term.write(w[2])term.setTextColor(1)s=s+1;if s>ai then s=s-1;term.scroll(1)end;term.setCursorPos(1,s)end else term.setTextColor(16384)term.write(q)term.setTextColor(1)s=s+1;if s>ai then s=s-1;term.scroll(1)end;term.setCursorPos(1,s)end end;term.setCursorBlink(false)term.clear()terminal.redraw(currentTTY,true)end end;local he={char=true,key=true,key_up=true,mouse_click=true,mouse_up=true,mouse_drag=true,mouse_scroll=true,paste=true}local bh,q=xpcall(function()while processes[ha]do if not aw then os.queueEvent(\"__event_queue_back\")end;while true do local au=table.pack(da())local o=au[1]if o==\"__event_queue_back\"then break end;local hf=false;if eventHooks[o]then for B,k in ipairs(eventHooks[o])do hf=k(au)or hf end end;if eventParameterMap[o]then local ay={}for x=2,#eventParameterMap[o]+1 do ay[eventParameterMap[o][x-1]]=au[x]end;if o==\"key\"or o==\"key_up\"then ay.keycode=keymap[ay.keycode]ay.ctrlHeld=keysHeld.ctrl;ay.altHeld=keysHeld.alt;ay.shiftHeld=keysHeld.shift end;if o==\"mouse_scroll\"then ay.direction=ay.direction>0 end;if he[o]and currentTTY.frontmostProcess then currentTTY.frontmostProcess.eventQueue[#currentTTY.frontmostProcess.eventQueue+1]={o,ay}hf=true elseif o==\"timer\"or o==\"alarm\"then local hg;if o==\"timer\"then hg=timerMap[au[2]]else hg,ay.id=alarmMap[au[2]],bit32.bor(ay.id,0x80000000)end;if hg then hg.eventQueue[#hg.eventQueue+1],hf={o,ay},true end end end;if aw and hf then break end end;aw=true;hd=setmetatable({},{__mode=\"k\"})for cZ,process in pairs(processes)do if cZ~=0 and not process.paused then local fR,au=false,nil;local av=true;for eZ,at in pairs(process.threads)do if not fR and at.status==\"suspended\"then au=table.remove(process.eventQueue,1)fR=true end;if au or at.status~=\"suspended\"then local hh;av,hh=executeThread(process,at,au or as,av,aw)aw=hh and aw else av=false end end;if av then process.isDead=true;if process.lastReturnValue then if cZ==ha then init_retval=process.lastReturnValue.value or process.lastReturnValue.error elseif processes[process.parent]then process.lastReturnValue.id=cZ;processes[process.parent].eventQueue[#processes[process.parent].eventQueue+1]={\"process_complete\",process.lastReturnValue}end end;reap_process(process)processes[cZ]=nil;aw=false end;hd[process]=true end end;terminal.redraw(currentTTY)end end,debug.traceback)if not bh then syslog.log({level=\"critical\",traceback=true},q)end;if postkill then postkill()end;if init_retval~=nil then syslog.log({level=4},\"init exited with result\",init_retval)end;panic(\"init program exited\")\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881290993,size=272215},["config.lua"]={type="file",created=1740881293681,worldPermissions={write=false,read=true,execute=false},data="\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293679,size=1},["pxboot.lua"]={type="file",created=1740881293682,worldPermissions={execute=false,read=true,write=false},data="if not(fs or term or os.pullEvent)then error(\"This program must be run from CraftOS.\")end;local a=require\"cc.expect\"if not getmetatable(a)then setmetatable(a,{__call=function(self,...)return self.expect(...)end})elseif not getmetatable(a).__call then getmetatable(a).__call=function(self,...)return self.expect(...)end end;local b={}local c={}local d={}local e={}local f={}local g;local function h(i,...)local j=_G.dofile;local k=table.pack(...)local l={bit32=true,bit=true,ccemux=true,config=true,coroutine=true,debug=true,ffi=true,fs=true,http=true,io=true,jit=true,mounter=true,os=true,periphemu=true,peripheral=true,redstone=true,rs=true,term=true,utf8=true,_HOST=true,_CC_DEFAULT_SETTINGS=true,_CC_DISABLE_LUA51_FEATURES=true,_VERSION=true,assert=true,collectgarbage=true,error=true,gcinfo=true,getfenv=true,getmetatable=true,ipairs=true,load=true,loadstring=true,math=true,newproxy=true,next=true,pairs=true,pcall=true,rawequal=true,rawget=true,rawlen=true,rawset=true,select=true,setfenv=true,setmetatable=true,string=true,table=true,tonumber=true,tostring=true,type=true,unpack=true,xpcall=true,turtle=true,pocket=true,commands=true,_G=true,sound=true}local m={}for n in pairs(_G)do if not l[n]and not f[n]then table.insert(m,n)end end;for o,n in ipairs(m)do _G[n]=nil end;local p=g or _G.term.native()for o,q in ipairs{\"nativePaletteColor\",\"nativePaletteColour\",\"screenshot\"}do p[q]=_G.term[q]end;_G.term=p;_G.http.checkURL=_G.http.checkURLAsync;_G.http.websocket=_G.http.websocketAsync;if _G.commands then _G.commands=_G.commands.native end;if _G.turtle then _G.turtle.native,_G.turtle.craft=nil end;local r={os={\"version\",\"pullEventRaw\",\"pullEvent\",\"run\",\"loadAPI\",\"unloadAPI\",\"sleep\"},http={\"get\",\"post\",\"put\",\"delete\",\"patch\",\"options\",\"head\",\"trace\",\"listen\",\"checkURLAsync\",\"websocketAsync\"},fs={\"complete\",\"isDriveRoot\"}}for n,s in pairs(r)do for o,t in ipairs(s)do _G[n][t]=nil end end;local u=error;_G.error=function()end;_G.term.redirect=function()end;function _G.term.native()_G.term.native=nil;_G.term.redirect=nil;_G.error=u;term.setBackgroundColor(32768)term.setTextColor(1)term.setCursorPos(1,1)term.setCursorBlink(true)term.clear()local v;if type(i)==\"function\"then v=i else local w=fs.open(i,\"r\")if w==nil then term.setCursorBlink(false)term.setTextColor(16384)term.write(\"Could not find kernel. pxboot cannot continue.\")term.setCursorPos(1,2)term.write(\"Press any key to continue\")coroutine.yield(\"key\")os.shutdown()end;local x;v,x=loadstring(w.readAll(),\"=kernel\")w.close()if v==nil then term.setCursorBlink(false)term.setTextColor(16384)term.write(\"Could not load kernel. pxboot cannot continue.\")term.setCursorPos(1,2)term.write(x)term.setCursorPos(1,3)term.write(\"Press any key to continue\")coroutine.yield(\"key\")os.shutdown()end end;setfenv(v,_G)local y=os.shutdown;os.shutdown=function()os.shutdown=y;return v(table.unpack(k,1,k.n))end end;if debug then local function z(A,B,C,D)local E,F,G=1,debug.getupvalue(A[B],D)while F~=C and not(F==nil and E>1)do F,G=debug.getupvalue(A[B],E)E=E+1 end;A[B]=G or A[B]end;z(_G,\"loadstring\",\"nativeloadstring\",1)z(_G,\"load\",\"nativeload\",5)z(http,\"request\",\"nativeHTTPRequest\",3)z(os,\"shutdown\",\"nativeShutdown\",1)z(os,\"reboot\",\"nativeReboot\",1)if turtle then z(turtle,\"equipLeft\",\"v\",1)z(turtle,\"equipRight\",\"v\",1)end;do local E,F,G=1,debug.getupvalue(peripheral.isPresent,2)while F~=\"native\"and F~=nil do F,G=debug.getupvalue(peripheral.isPresent,E)E=E+1 end;_G.peripheral=G or peripheral end;if debug.getupvalue(j,2)==\"status\"then local o,H=debug.getupvalue(j,2)o,_G.discord=debug.getupvalue(H,4)end end;coroutine.yield()end;function e.kernel(m)d.fn=h;d.args={m.path}end;function e.chainloader(m)d.fn=shell and shell.run or function(i,...)os.run({},i,...)end;d.args={m.path}end;function e.craftos(m)d.fn=function()term.setTextColor(colors.yellow)print(os.version())term.setTextColor(colors.white)if settings.get(\"motd.enable\")then if shell then shell.run(\"motd\")else os.run({},\"/rom/programs/motd.lua\")end end end;d.args={}end;function e.args(m)if not d.args then error(\"config.lua:\"..m.line..\": args command must come after boot type\",0)end;for E=1,#m.args do d.args[#d.args+1]=m.args[E]end end;function e.global(m)_G[m.key]=m.value;f[m.key]=true end;function e.monitor(m)if peripheral.hasType then assert(peripheral.hasType(m.name,\"monitor\"),\"peripheral '\"..m.name..\"' does not exist or is not a monitor\")else assert(peripheral.getType(m.name)==\"monitor\",\"peripheral '\"..m.name..\"' does not exist or is not a monitor\")end;g=peripheral.wrap(m.name)term.redirect(g)end;function e.insmod(m)local i;if m.name:match\"^/\"then i=m.name elseif m.name:find\"[/%.]\"then i=fs.combine(shell and fs.getDir(shell.getRunningProgram())or\"pxboot\",m.name)else i=fs.combine(shell and fs.getDir(shell.getRunningProgram())or\"pxboot\",\"modules/\"..m.name..\".lua\")end;assert(loadfile(i,nil,setmetatable({entries=b,bootcfg=d,cmds=e,userGlobals=f,unbios=h},{__index=_ENV})))(m.args,i)end;local function I(J)term.setBackgroundColor(colors.black)term.setTextColor(colors.white)term.clear()term.setCursorPos(1,1)for E=0,15 do term.setPaletteColor(2^E,term.nativePaletteColor(2^E))end;for o,s in ipairs(J.commands)do local K,x;if type(s)==\"function\"then K,x=pcall(s)else K,x=pcall(e[s.cmd],s)end;if not K then d={}printError(\"Could not run boot script: \"..x)print(\"Press any key to continue.\")os.pullEventRaw(\"key\")return false end end;if not d.fn then d={}printError(\"Could not run boot script: missing boot type command\")print(\"Press any key to continue.\")os.pullEventRaw(\"key\")return false end;d.fn(table.unpack(d.args))return true end;local L;local M=setmetatable({title=\"Phoenix pxboot\",titlecolor=colors.white,backgroundcolor=colors.black,textcolor=colors.white,boxcolor=colors.white,boxbackground=colors.black,selectcolor=colors.white,selecttext=colors.black,background=nil,defaultentry=nil,timeout=30,menuentry=function(C)a(1,C,\"string\")return function(J)a(2,J,\"table\")local N=1;for E,s in pairs(J)do if type(E)==\"number\"then N=math.max(E,N)end end;local O={name=C,commands={}}for E=1,N do local P=J[E]if type(P)~=\"table\"and type(P)~=\"function\"or not P.cmd then error(\"bad command entry #\"..E..(P==nil and\" (unknown command)\"or\" (missing arguments)\"),2)end;if type(P)==\"function\"then O.commands[#O.commands+1]=P elseif P.cmd==\"description\"then O.description=P.text elseif e[P.cmd]then O.commands[#O.commands+1]=P else error(\"bad command entry #\"..E..\" (unknown command \"..P.cmd..\")\",2)end end;b[#b+1]=O;c[C]=O end end,include=function(i)a(1,i,\"string\")for o,s in ipairs(fs.find(fs.combine(L,i)))do repeat local v,x=loadfile(s,\"t\",getfenv(2))if not v then printError(\"Could not load config file: \"..x)print(\"Press any key to continue...\")os.pullEvent(\"key\")break end;local Q=L;L=fs.getDir(s)local K,x=pcall(v)L=Q;if not K then printError(\"Failed to execute config file: \"..x)print(\"Press any key to continue...\")os.pullEvent(\"key\")break end until true end end,description=function(R)a(1,R,\"string\")return{cmd=\"description\",text=R,line=debug.getinfo(2,\"l\").currentline}end,kernel=function(i)a(1,i,\"string\")return{cmd=\"kernel\",path=i,line=debug.getinfo(2,\"l\").currentline}end,chainloader=function(i)a(1,i,\"string\")return{cmd=\"chainloader\",path=i,line=debug.getinfo(2,\"l\").currentline}end,args=function(S)a(1,S,\"string\",\"table\")if type(S)==\"table\"then return{cmd=\"args\",args=S,line=debug.getinfo(2,\"l\").currentline}else local m={\"\"}local T;for P in S:gmatch\".\"do if T then if P==T then T=nil else m[#m]=m[#m]..P end elseif P=='\"'or P==\"'\"then T=P elseif P==' 'then m[#m+1]=\"\"else m[#m]=m[#m]..P end end;local N=2;return setmetatable({cmd=\"args\",args=m,line=debug.getinfo(2,\"l\").currentline},{__call=function(self,U)a(N,U,\"string\")N=N+1;local m=self.args;local T;m[#m+1]=\"\"for P in U:gmatch\".\"do if T then if P==T then T=nil else m[#m]=m[#m]..P end elseif P=='\"'or P==\"'\"then T=P elseif P==' 'then m[#m+1]=\"\"else m[#m]=m[#m]..P end end;return self end})end end,craftos={cmd=\"craftos\"},global=function(F)return function(G)return{cmd=\"global\",key=F,value=G}end end,monitor=function(C)return{cmd=\"monitor\",name=C}end,insmod=function(C)a(1,C,\"string\")return setmetatable({cmd=\"insmod\",name=C,line=debug.getinfo(2,\"l\").currentline},{__call=function(self,S)a(2,S,\"table\")self.args=S;setmetatable(self,nil)return self end})end},{__index=_ENV})term.clear()term.setCursorPos(1,1)repeat local v,x=loadfile(shell and fs.combine(fs.getDir(shell.getRunningProgram()),\"config.lua\")or\"pxboot/config.lua\",\"t\",M)if not v then printError(\"Could not load config file: \"..x)print(\"Press any key to continue...\")os.pullEvent(\"key\")break end;L=shell and fs.getDir(shell.getRunningProgram())or\"pxboot\"local K,x=pcall(v)L=nil;if not K then printError(\"Failed to execute config file: \"..x)print(\"Press any key to continue...\")os.pullEvent(\"key\")break end until true;local function V()end;if#b==0 then return V()end;local function W(N)return(\"0123456789abcdef\"):sub(N,N)end;local X,Y=term.getSize()local Z=Y-11;local _=window.create(term.current(),2,4,X-2,Y-9)local a0=window.create(_,2,2,X-4,Z)term.setBackgroundColor(M.backgroundcolor)term.clear()_.setBackgroundColor(M.boxbackground or M.backgroundcolor)_.clear()a0.setBackgroundColor(M.boxbackground or M.backgroundcolor)a0.clear()local a1,a2=1,1;if M.defaultentry then for E=1,#b do if b[E].name==M.defaultentry then a1=E;break end end;if M.timeout==0 and I(b[a1])then return end end;local function a3()a0.setVisible(false)a0.setBackgroundColor(M.boxbackground or M.backgroundcolor)a0.clear()for E=a2,a2+Z-1 do local a4=b[E]if not a4 then break end;a0.setCursorPos(2,E-a2+1)if E==a1 then a0.setBackgroundColor(M.selectcolor)a0.setTextColor(M.selecttext)else a0.setBackgroundColor(M.boxbackground or M.backgroundcolor)a0.setTextColor(M.textcolor)end;a0.clearLine()a0.write(#a4.name>X-6 and a4.name:sub(1,X-9)..\"...\"or a4.name)if E==a1 and M.timeout then local a5=tostring(M.timeout)a0.setCursorPos(X-4-#a5,E-a2+1)a0.write(a5)a0.setCursorPos(2,E-a2+1)end end;a0.setVisible(true)term.setCursorPos(5,Y-5)term.clearLine()term.setTextColor(M.titlecolor)term.write(b[a1].description or\"\")end;local function a6()local a7,a8=W(select(2,math.frexp(M.boxbackground or M.backgroundcolor))),W(select(2,math.frexp(M.boxcolor or M.textcolor)))_.setTextColor(M.boxcolor or M.textcolor)_.setCursorPos(1,1)_.write(\"\\x9C\"..(\"\\x8C\"):rep(X-4))_.blit(\"\\x93\",a7,a8)for a9=2,Y-10 do _.setCursorPos(1,a9)_.blit(\"\\x95\",a8,a7)_.setCursorPos(X-2,a9)_.blit(\"\\x95\",a7,a8)end;_.setCursorPos(1,Y-9)_.setBackgroundColor(M.boxbackground or M.backgroundcolor)_.setTextColor(M.boxcolor or M.textcolor)_.write(\"\\x8D\"..(\"\\x8C\"):rep(X-4)..\"\\x8E\")term.setCursorPos((X-#M.title)/2,2)term.setTextColor(M.titlecolor or M.textcolor)term.write(M.title)term.setCursorPos(5,Y-3)term.write(\"Use the \\x18 and \\x19 keys to select.\")term.setCursorPos(5,Y-2)term.write(\"Press enter to boot the selected OS.\")term.setCursorPos(5,Y-1)term.write(\"'c' for shell, 'e' to edit.\")a3()end;a6()local aa=M.defaultentry and M.timeout and os.startTimer(1)while true do local ab={coroutine.yield()}if ab[1]==\"timer\"and ab[2]==aa then M.timeout=M.timeout-1;if M.timeout==0 then if I(c[M.defaultentry])then return end end;a3()aa=os.startTimer(1)elseif ab[1]==\"key\"then if aa then os.cancelTimer(aa)M.timeout,aa=nil;a3()end;if(ab[2]==keys.down or ab[2]==keys.numPad2)and a1<#b then a1=a1+1;if a1>a2+Z-1 then a2=a2+1 end;a3()elseif(ab[2]==keys.up or ab[2]==keys.numPad8)and a1>1 then a1=a1-1;if a1<a2 then a2=a2-1 end;a3()elseif ab[2]==keys.enter then if I(b[a1])then return end elseif ab[2]==keys.c then V()a6()end elseif ab[1]==\"terminate\"then break end end\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881293680,size=11564},["config.lua.d"]={type="directory",created=1740881293682,worldPermissions={write=false,read=true,execute=true},contents={["99-craftos.lua"]={type="file",created=1740881293682,worldPermissions={execute=false,read=true,write=false},data="menuentry\"CraftOS\"{description\"Boot into CraftOS.\",craftos}\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881293679,size=60}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881293682,size=0}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294723,size=0},usr={type="directory",setuser=false,created=1740881291738,worldPermissions={write=false,read=true,execute=true},contents={libexec={type="directory",created=1740881294446,worldPermissions={write=false,read=true,execute=true},contents={["ftpmgr.lua"]={type="file",created=1740881292189,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.expect\"local b=require\"system.filesystem\"local c=require\"system.log\"local d=require\"system.network\"local e=require\"system.process\"local f=require\"system.serialization\"local g=require\"system.terminal\"local h=require\"ftp\"local i=require\"sha2\"local j;if e.getuser()~=\"root\"then error(\"This program must be run as root.\")end;local k=f.toml.load(\"/etc/ftpmgr.conf\")a(0,k,a.struct{ip=a.match\"^[%d%.]+$\",port=\"number\",passivePortRange=a.array\"number\",allUsers={\"boolean\",\"nil\"},users=a.table{a.struct{systemUser={\"string\",\"nil\"},password={\"string\",\"nil\"},passwordHash={\"string\",\"nil\"},passwordSalt={\"string\",\"nil\"},useSystemLogin={\"boolean\",\"nil\"},root={\"string\",\"nil\"}}}})local l=k.users;for m,n in pairs(k.users)do n.systemUser=n.systemUser or m;if n.passwordHash then a.field(n,\"passwordSalt\",\"string\")end;if n.useSystemLogin==nil then n.useSystemLogin=true end;if n.useSystemLogin and not j then j=require\"usermgr\"end;n.root=n.root or\"/\"end;local o=c.create(\"ftpmgr\",true,\"/var/log/ftpmgr.log\")local function p(q)if not l[q]then l[q]={systemUser=q,root=\"/\",useSystemLogin=true,allowWrite=true}end;o.info(\"Logging in as \"..q)b.chroot(l[q].root)e.setuser(l[q].systemUser)e.getenv().didAuthenticate=true;e.getenv().allowWrite=l[q].allowWrite end;local function r(q,s)if e.getenv().didAuthenticate then return true end;if q then local t=l[q]local u=false;if not t then u=k.allUsers and s and j.authenticate(q,s)elseif not t.password and not t.passwordHash and not t.useSystemLogin then u=true elseif s then if t.passwordHash then u=i.sha256(s..t.passwordSalt)==t.passwordHash elseif t.password then u=s==t.password elseif t.useSystemLogin then u=j.authenticate(t.systemUser,s)end end;if u then p(q)return true else o.info(\"Login attempt for user\",q,\"failed: Invalid password\")return false end elseif l.anonymous then p(\"anonymous\")return true else o.info(\"Login attempt for user\",q,\"failed: No anonymous user available\")return false end end;local v={}local function w(x)if x then o.info(\"Closed data port \"..x)v[x]=nil;return end;if not v[20]then o.info(\"Opened data port 20\")v[20]=true;return 20 end;for y=k.passivePortRange[1],k.passivePortRange[2]do if not v[y]then o.info(\"Opened data port \"..y)v[y]=true;return y end end;return nil end;local z=h.server(k.ip,k.port,r,w)local A,B,C,D,E,F,G,H=z.commands.STOR,z.commands.STOU,z.commands.APPE,z.commands.RNFR,z.commands.RNTO,z.commands.DELE,z.commands.RMD,z.commands.MKD;function z.commands.REIN(self,I)return\"502 Not supported\"end;function z.commands.STOR(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return A(...)end;function z.commands.STOU(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return B(...)end;function z.commands.APPE(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return C(...)end;function z.commands.RNFR(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return D(...)end;function z.commands.RNTO(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return E(...)end;function z.commands.DELE(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return F(...)end;function z.commands.RMD(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return G(...)end;function z.commands.MKD(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return H(...)end;local J=\"psp://\"..k.ip..\":\"..k.port;d.listen(J)while true do local K,L=coroutine.yield()if K==\"network_request\"and L.uri==J then o.info(\"Received connection from \"..L.ip)e.fork(function()g.stdin(nil)g.stdout(nil)g.stderr(nil)L.handle:transfer()z:run(L.handle)end,\"[ftpmgr] connection to \"..L.ip)d.listen(J)end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292169,size=3715},["diskmgr.lua"]={type="file",created=1740881291830,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.hardware\"local c=require\"system.log\"local d=c.create(\"diskmgr\",true)local e={}local function f(g)local h=b.call(g,\"getState\")if h and h.id then local i=\"/media/\"if h.label then i=i..h.label else i=i..h.id end;local j,k=pcall(function()a.mkdir(i)a.mount(\"drivefs\",g,i,{})e[g]=i end)if j then d.info(\"Mounted drive \"..g..\" to \"..i)else d.error(\"Could not mount drive: \"..k)end end end;local function l(i,m)if b.hasType(i,\"drive\")or b.hasType(i,\"modem\")then b.listen(i)end;if m and b.hasType(i,\"drive\")then f(i)end;for n,o in ipairs(b.children(i))do l(i..\"/\"..o,m)end end;b.listen(\"/\")l(\"/\",true)while true do local p,q=coroutine.yield()if p==\"disk\"then f(q.device)elseif p==\"disk_eject\"and e[q.device]then a.unmount(e[q.device])a.remove(e[q.device])e[q.device]=nil elseif p==\"device_added\"then l(q.device,false)end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291827,size=874},["dhcpmgr.lua"]={type="file",created=1740881291741,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.expect\"local b=require\"system.hardware\"local c=require\"system.log\"local d=require\"system.network\"local e=require\"system.serialization\"local f=require\"system.util\"local function g(h)if h:match\"^%d+$\"then return tonumber(h)elseif h:match\"^%d+%.%d+$\"then return tonumber(h:match\"^%d+\")*0x1000000+tonumber(h:match\"^%d+%.(%d+)\")elseif h:match\"^%d+%.%d+%.%d+$\"then return tonumber(h:match\"^(%d+)\")*0x1000000+tonumber(h:match\"^%d+%.(%d+)\")*0x10000+tonumber(h:match\"^%d+%.%d+%.(%d+)\")elseif h:match\"^%d+%.%d+%.%d+%.%d+$\"then return tonumber(h:match\"^(%d+)\")*0x1000000+tonumber(h:match\"^%d+%.(%d+)\")*0x10000+tonumber(h:match\"^%d+%.%d+%.(%d+)\")*0x100+tonumber(h:match\"^%d+%.%d+%.%d+%.(%d+)\")else error(\"Invalid IP address\",2)end end;local function i(j)if not j then return nil end;return(\"%d.%d.%d.%d\"):format(bit32.band(bit32.rshift(j,24),0xFF),bit32.band(bit32.rshift(j,16),0xFF),bit32.band(bit32.rshift(j,8),0xFF),bit32.band(j,0xFF))end;local function k(j)return bit32.bnot(2^(32-j)-1)end;local function l(m)local n=0;while bit32.btest(m,0x80000000)do m,n=bit32.lshift(m,1),n+1 end;return n end;local o=e.toml.load(\"/etc/dhcpmgr.conf\")a(0,o,a.struct{interface={\"string\",\"nil\"},firstaddr=a.match\"^[%d%.]+$\",lastaddr=a.match\"^[%d%.]+$\",netmask={a.match\"^[%d%.]+$\",\"number\",\"nil\"},gateway={a.match\"^[%d%.]+$\",\"nil\"},dns={a.array{a.match\"^[%d%.]+$\",\"number\"},\"nil\"},leasetime={\"number\",\"nil\"},allowrequests=\"boolean\",storeassignments=\"boolean\",forcereassign=\"boolean\",static=a.table{a.match\"^[%d%.]+$\"},options=\"table\"})local p={}for q,r in pairs(o.static)do p[tonumber(q)]=r end;o.static=p;o.firstaddr=g(o.firstaddr)o.lastaddr=g(o.lastaddr)if type(o.netmask)==\"string\"then o.netmask=g(o.netmask)elseif type(o.netmask)==\"number\"then o.netmask=k(o.netmask)else o.netmask=k(l(bit32.bnot(bit32.bxor(o.firstaddr,o.lastaddr))))end;o.options.dns=o.dns;o.options.gateway=o.gateway;o.options.netmask=i(o.netmask)local s=c.create(\"dhcpmgr\",true,\"/var/log/dhcpmgr.log\")local t;if o.interface then t=b.wrap(o.interface)else t=b.find(\"modem\")end;if not t or not b.hasType(t,\"modem\")then s.error(\"Requested interface does not exist or is not a modem:\")error(\"Requested interface does not exist or is not a modem:\")end;t:open(67)b.listen(t,true)local u=d.ipconfig(b.path(t))local v=b.info(\"/\").metadata.id;local w={}local x={}if o.storeassignments then local y=io.open(\"/var/lib/misc/dhcpmgr\",\"r\")if y then for z in y:lines()do local A,h,B=z:match\"^(%d+)%s+([%d%.]+)%s+(%d+)\"if A then w[tonumber(A)]={address=g(h),expires=tonumber(B)}x[g(h)]=tonumber(A)end end;y:close()end end;for q,r in pairs(o.static)do w[q]={address=g(r),expires=0}x[g(r)]=q end;local function C(A)if w[A]then if o.forcereassign then x[w[A].address]=nil;w[A]=nil else return w[A]end end;for h=o.firstaddr,o.lastaddr do if not x[h]then s.info(\"Assigning address \"..i(h)..\" to ID \"..A)x[h]=A;w[A]={address=h,expires=o.leasetime and math.floor(os.time()+o.leasetime)or 0,pending=true}return w[A]end end;s.warn(\"Could not allocate address for ID \"..A)return nil end;local function D()if o.storeassignments then local y,E=io.open(\"/var/lib/misc/dhcpmgr\",\"w\")if y then for q,r in pairs(w)do if not r.pending then y:write((\"%d %s %d\\n\"):format(q,i(r.address),r.expires))end end;y:close()else s.warn(\"Could not open address database for writing:\",E)end end end;local F=f.timer(60)while true do local G,H=coroutine.yield()if G==\"modem_message\"and H.channel==67 and H.replyChannel==68 and type(H.message)==\"table\"and H.message.dhcp==true and type(H.message.from)==\"number\"then local I=H.message.type;if I==\"discover\"then local h;if type(H.message.requestedIP)==\"string\"and o.allowrequests then local J,K=pcall(g,H.message.requestedIP)if J and K>=o.firstaddr and K<=o.lastaddr and not x[K]then h={address=K,expires=o.leasetime and math.floor(os.time()+o.leasetime)or 0,pending=true}x[K]=H.message.from;w[H.message.from]=h end end;if not h then h=C(H.message.from)end;if h then local L={dhcp=true,type=\"offer\",from=v,to=H.message.from,serverIP=u.ip,offeredIP=i(h.address),messageID=H.message.messageID,options={}}if type(H.message.options)==\"table\"then for q in pairs(H.message.options)do if o.options[q]then L.options[q]=o.options[q]end end end;t:transmit(68,67,L)end elseif I==\"request\"and w[H.message.from]then local h=w[H.message.from]if H.message.to==v then h.pending=nil;D()local L={dhcp=true,type=\"acknowledgement\",from=v,to=H.message.from,serverIP=u.ip,offeredIP=i(h.address),messageID=H.message.messageID,options={}}if type(H.message.options)==\"table\"then for q in pairs(H.message.options)do if o.options[q]then L.options[q]=o.options[q]end end end;t:transmit(68,67,L)else x[h.address]=nil;w[H.message.from]=nil end end elseif G==\"timer\"and H.id==F then local M=os.time()local N=false;for q,r in pairs(w)do if r.expires>0 and M>r.expires then w[q]=nil;x[r.address]=nil;N=true end end;if N then D()end;F=f.timer(60)end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291738,size=4888},["usermgr.lua"]={type="file",created=1740881294446,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.ipc\"local b=require\"system.log\"local c=require\"system.serialization\".base64;local d=require\"system.util\"local e=require\"sha2\"local f={[\"1\"]=e.md5,[\"5\"]=e.sha256,[\"6\"]=e.sha512,[\"\"]=\"\",[\"!\"]=\"Password authentication disabled\",[\"*\"]=\"Password authentication disabled\",[\"*LK*\"]=\"User locked\",[\"*NP*\"]=\"No password set\",[\"!!\"]=\"No password set\"}local g={[e.md5]=\"1\",[e.sha256]=\"5\",[e.sha512]=\"6\",[\"Password authentication disabled\"]=\"!\",[\"User locked\"]=\"*LK*\",[\"No password set\"]=\"!!\"}local h=5000;assert(a.register(\"usermgr\"),\"Could not register usermgr service. Is another instance running?\")local i={}local function j()local k,l=io.open(\"/etc/passwd\",\"r\")if not k then b.warn(\"Could not open /etc/passwd:\",l)return end;for m in k:lines()do local n=d.split(m,\":\",true)if#n>=7 then local o=d.split(n[5],\",\",true)i[n[1]]={fullName=o[1],home=n[6],shell=n[7]}end end;k:close()k,l=io.open(\"/etc/shadow\",\"r\")if not k then b.warn(\"Could not open /etc/shadow:\",l)return end;for m in k:lines()do local n=d.split(m,\":\",true)if#n>=9 then local p=d.split(n[2],\"%$\")i[n[1]].password={hashType=f[p[1]],salt=p[2]and c.decode(p[2]),password=p[3]and c.decode(p[3]),lastChange=tonumber(n[3]),nextChange=tonumber(n[4]),expirationTime=tonumber(n[5]),expirationWarning=tonumber(n[6]),lockTime=tonumber(n[7]),expirationDate=tonumber(n[8])}end end;k:close()end;local function q()local r,l=io.open(\"/etc/passwd\",\"w\")if not r then b.warn(\"Could not open /etc/passwd:\",l)return end;local s,t=io.open(\"/etc/shadow\",\"w\")if not s then r:close()b.warn(\"Could not open /etc/shadow:\",t)return end;for u,v in pairs(i)do local p;if type(v.password.hashType)==\"string\"then p=g[v.password.hashType]else p=\"$\"..g[v.password.hashType]..\"$\"..c.encode(v.password.salt)..\"$\"..c.encode(v.password.password)end;r:write((\"%s:x:::%s:%s:%s\\n\"):format(u,v.fullName or\"\",v.home or\"\",v.shell or\"\"))s:write((\"%s:%s:%d:%s:%s:%s:%s:%s:\\n\"):format(u,p,v.password.lastChange,v.password.nextChange or\"\",v.password.expirationTime or\"\",v.password.expirationWarning or\"\",v.password.lockTime or\"\",v.password.expirationDate or\"\"))end;r:close()s:close()end;j()d.addEventListener(\"remote_event\",function(w,x)local y=d.syscall.getpinfo(x.sender)if x.type==\"usermgr.request.authenticate\"then if type(x.data)~=\"table\"or type(x.data.user)~=\"string\"or type(x.data.password)~=\"string\"then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{error=\"Invalid request\"})return end;if y.user~=\"root\"then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{error=\"Permission denied\"})return end;local z=i[x.data.user]local A;if not z then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{error=\"Unknown user\"})return end;if z.password.hashType==\"\"then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{result=true})return elseif type(z.password.hashType)==\"string\"then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{error=z.password.hashType})return end;if z.password.expirationTime then if z.password.lockTime and os.time()>=(z.password.lastChange+z.password.expirationTime+z.password.lockTime)*86400 then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{error=\"User locked\"})if not z.password.expirationDate then z.password.expirationDate=math.floor(os.time()/86400)end;z.password.hashType=\"User locked\"z.password.password=nil;z.password.salt=nil;q()return elseif os.time()>=(z.password.lastChange+z.password.expirationTime)*86400 then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{error=\"Password expired\"})if not z.password.expirationDate then z.password.expirationDate=math.floor(os.time()/86400)q()end;return elseif z.password.expirationWarning and os.time()>=(z.password.lastChange+z.password.expirationTime-z.password.expirationWarning)*86400 then A=\"Password expires in \"..math.floor(os.time()/86400)-(z.password.lastChange+z.password.expirationTime)..\" days\"end end;local B=x.data.password..z.password.salt;for C=1,h do B=z.password.hashType(B)end;if B==z.password.password then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{result=true,message=A})else a.sendEvent(x.sender,\"usermgr.response.authenticate\",{error=\"Incorrect password\"})end elseif x.type==\"usermgr.request.getUserInfo\"then if type(x.data)~=\"table\"or type(x.data.user)~=\"string\"then a.sendEvent(x.sender,\"usermgr.response.getUserInfo\",{error=\"Invalid request\"})return end;local z=i[x.data.user]a.sendEvent(x.sender,\"usermgr.response.getUserInfo\",{result=z and{name=x.data.user,fullName=z.fullName,home=z.home,shell=z.shell,lastChange=z.password.lastChange*86400,nextChange=z.password.nextChange and(z.password.lastChange+z.password.nextChange)*86400,expirationTime=z.password.expirationTime and(z.password.lastChange+z.password.expirationTime)*86400,expirationWarning=z.password.expirationTime and z.password.expirationWarning and(z.password.lastChange+z.password.expirationTime-z.password.expirationWarning)*86400,lockTime=z.password.expirationTime and z.password.lockTime and(z.password.lastChange+z.password.expirationTime+z.password.lockTime)*86400,isExpired=z.password.expirationDate~=nil,isLocked=z.password.hash and z.password.hash:match\"^!\",hasPassword=z.password.type~=\"No password set\"}})elseif x.type==\"usermgr.request.addUser\"then if type(x.data)~=\"table\"or type(x.data.user)~=\"string\"or x.data.password~=nil and type(x.data.password)~=\"string\"then a.sendEvent(x.sender,\"usermgr.response.addUser\",{error=\"Invalid request\"})return end;if y.user~=\"root\"then a.sendEvent(x.sender,\"usermgr.response.addUser\",{error=\"Permission denied\"})return end;if i[x.data.user]then a.sendEvent(x.sender,\"usermgr.response.addUser\",{error=\"User already exists\"})return end;local z={fullName=tostring(x.data.fullName or\"\"),home=tostring(x.data.home or\"\"),shell=tostring(x.data.shell or\"\"),password={lastChange=math.floor(os.time()/86400)}}if type(x.data.lockTime)==\"number\"then z.password.lockTime=x.data.lockTime end;if x.data.password==nil then z.password.hashType=\"No password set\"elseif x.data.password==\"\"then z.password.hashType=\"\"else local D=\"\"for C=1,16 do D=D..string.char(math.random(0,255))end;local B=x.data.password..D;z.password.hashType=e.sha256;for C=1,h do B=z.password.hashType(B)end;z.password.salt=D;z.password.password=B end;i[x.data.user]=z;q()a.sendEvent(x.sender,\"usermgr.response.addUser\",{result=true})elseif x.type==\"usermgr.request.editUser\"then if type(x.data)~=\"table\"or type(x.data.user)~=\"string\"then a.sendEvent(x.sender,\"usermgr.response.editUser\",{error=\"Invalid request\"})return end;if y.user~=\"root\"and y.user~=x.data.user then a.sendEvent(x.sender,\"usermgr.response.editUser\",{error=\"Permission denied\"})return end;local z=i[x.data.user]if not z then a.sendEvent(x.sender,\"usermgr.response.editUser\",{error=\"User does not exist\"})return end;if type(x.data.fullName)==\"string\"then z.fullName=x.data.fullName end;if type(x.data.home)==\"string\"then z.home=x.data.home end;if type(x.data.shell)==\"string\"then z.shell=x.data.shell end;q()a.sendEvent(x.sender,\"usermgr.response.editUser\",{result=true})elseif x.type==\"usermgr.request.removeUser\"then if type(x.data)~=\"table\"or type(x.data.user)~=\"string\"then a.sendEvent(x.sender,\"usermgr.response.removeUser\",{error=\"Invalid request\"})return end;if y.user~=\"root\"then a.sendEvent(x.sender,\"usermgr.response.removeUser\",{error=\"Permission denied\"})return end;if not i[x.data.user]then a.sendEvent(x.sender,\"usermgr.response.removeUser\",{error=\"User does not exist\"})return end;i[x.data.user]=nil;q()a.sendEvent(x.sender,\"usermgr.response.removeUser\",{result=true})elseif x.type==\"usermgr.request.setPassword\"then if type(x.data)~=\"table\"or type(x.data.user)~=\"string\"or x.data.password~=nil and type(x.data.password)~=\"string\"then a.sendEvent(x.sender,\"usermgr.response.setPassword\",{error=\"Invalid request\"})return end;if y.user~=\"root\"then a.sendEvent(x.sender,\"usermgr.response.setPassword\",{error=\"Permission denied\"})return end;local z=i[x.data.user]if not z then a.sendEvent(x.sender,\"usermgr.response.setPassword\",{error=\"Unknown user\"})return end;if x.data.password==nil then if x.data.isLocked==true then if z.password.password then z.password.password=\"!\"..z.password.password end elseif x.data.isLocked==false then if z.password.password then z.password.password=z.password.password:gsub(\"^!*\",\"\")end elseif x.data.expirationTime then z.password.expirationTime=z.password.lastChange+x.data.expirationTime else z.password.hashType=\"No password set\"z.password.salt,z.password.password=nil end else local D=\"\"for C=1,16 do D=D..string.char(math.random(0,255))end;local B=x.data.password..D;z.password.hashType=e.sha256;for C=1,h do B=z.password.hashType(B)end;z.password.salt=D;z.password.password=B;z.password.lastChange=math.floor(os.time()/86400)if type(x.data.nextChange)==\"number\"then z.password.nextChange=x.data.nextChange end;if type(x.data.expirationTime)==\"number\"then z.password.expirationTime=x.data.expirationTime end;if type(x.data.expirationWarning)==\"number\"then z.password.expirationWarning=x.data.expirationWarning end;if type(x.data.lockTime)==\"number\"then z.password.lockTime=x.data.lockTime end end;q()a.sendEvent(x.sender,\"usermgr.response.setPassword\",{result=true})elseif x.type:match(\"^usermgr%.request%.\")then a.sendEvent(x.sender,x.type:gsub(\"^usermgr%.request%.\",\"usermgr.response.\"),{error=\"Unknown request\"})end end)d.runEvents()\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294391,size=9305},["netmgr.lua"]={type="file",created=1740881292983,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.expect\"local b=require\"system.hardware\"local c=require\"system.log\"local d=require\"system.network\"local e=require\"system.serialization\"local f=require\"system.util\"local g=e.toml.load(\"/etc/network.conf\")a(0,g,a.table{a.struct{acquire=\"string\",address={a.match\"^[%d%.]+/?%d*$\",\"number\",\"nil\"},netmask={a.match\"^[%d%.]+$\",\"number\",\"nil\"},gateway={a.match\"^[%d%.]+$\",\"number\",\"nil\"},dns={a.array{a.match\"^[%d%.]+$\",\"number\"},\"nil\"}}})local h=c.create(\"netmgr\",true,\"/var/log/netmgr.log\")local function i(j,k)local l=b.wrap(j)if not l or not b.hasType(l,\"modem\")then error(\"Device does not exist or is not a modem\")end;l:open(68)b.listen(l,true)local m=math.random(0,2^31-1)local n=b.info(\"/\").metadata.id;l:transmit(67,68,{dhcp=true,type=\"discover\",from=n,messageID=m,requestedIP=k,options={netmask=true,gateway=true,dns=true}})local o=f.timer(2)local p={}while true do local q,r=coroutine.yield()if q==\"modem_message\"and r.channel==68 and r.replyChannel==67 and type(r.message)==\"table\"and r.message.dhcp==true and r.message.to==n and r.message.messageID==m and r.message.type==\"offer\"then p[r.message.from]={ip=r.message.offeredIP,netmask=r.message.options.netmask,gateway=r.message.options.gateway,dns=r.message.options.dns,up=true}elseif q==\"timer\"and r.id==o then break end end;if#p==0 then b.listen(l,false)l:close(68)error(\"Could not get IP address: Timed out\")end;for s,t in pairs(p)do d.control(t.ip,\"ping\")f.sleep(2)if not d.arp.list(j)[t.ip]then l:transmit(67,68,{dhcp=true,type=\"request\",from=n,to=s,messageID=m,options={netmask=true}})o=f.timer(2)while true do local q,r=coroutine.yield()if q==\"modem_message\"and r.channel==68 and r.replyChannel==67 and type(r.message)==\"table\"and r.message.dhcp==true and r.message.to==n and r.message.messageID==m and r.message.type==\"acknowledgement\"then d.ipconfig(j,t)if t.gateway then d.route.add({source=\"0.0.0.0\",sourceNetmask=0,action=\"unicast\",destination=t.gateway,device=j})end;b.listen(l,false)l:close(68)f.cancel(o)return elseif q==\"timer\"and r.id==o then b.listen(l,false)l:close(68)error(\"Could not get IP address: No response from server\")end end end end;b.listen(l,false)l:close(68)error(\"Could not get IP address: No usable offers\")end;for u,v in ipairs{b.find(\"modem\")}do local s=b.path(v)local t=g[s]if not t then t=g[b.info(v).uuid]end;if not t then t=g.auto end;if not t then error(\"No config found for \"..s..\" (UUID \"..b.info(v).uuid..\"), and no auto fallback configured\")end;if t.acquire==\"dhcp\"then local w,x=pcall(i,s,nil)if not w then h.error(x)end elseif t.acquire==\"dhcp-static\"then local w,x=pcall(i,s,t.address)if not w then h.error(x)end elseif t.acquire==\"static\"then d.ipconfig(s,{ip=t.address,netmask=t.netmask,up=true})if t.gateway then d.route.add({source=\"0.0.0.0\",sourceNetmask=0,action=\"unicast\",destination=t.gateway,device=s})end end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292980,size=2847}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294446,size=0},share={type="directory",created=1740881291057,worldPermissions={execute=true,read=true,write=false},contents={man={type="directory",created=1740881294554,worldPermissions={execute=true,read=true,write=false},contents={[".mandb"]={type="file",created=1740881294717,worldPermissions={write=false,read=true,execute=true},data="craftos(1): run CraftOS programs under Phoenix\nlogger(1): view, post to, create, and delete logs\nlogin(1): \npasswd(1): \nshell(1): CraftOS shell wrapper for Phoenix\nshutdown(1): \nstartctl(1): \nstartmgr(1): \nsu(1): \nsudo(1): \ntar(1): \nyellowbox(1): access and administrate YellowBox boxes\n_template(2): \nacquiresemaphore(2): acquires a resource from a semaphore object\nalarm(2): sets an alarm\narplist(2): returns the list of known IP to computer ID mappings\narpset(2): sets the computer ID mapping for the specified IP\nattach(2): attaches a peripheral of the specified type to the computer\ncallmodule(2): calls a function on a kernel module\ncancel(2): cancels a previously set timer or alarm\ncchost(2): returns the value of the _HOST variable\ncheckuri(2): returns whether the specified URI is valid\nchmod(2): changes the permissions of a file or directory\nchown(2): changes the owner of a file or directory\nchroot(2): changes the root directory\ncombine(2): combines a set of path components into a valid path\nconnect(2): creates a connection to a remote resource\ndetach(2): detaches a peripheral from a side\ndevalias(2): sets or removes an alias for a device\ndevcall(2): calls the specified method on the device\ndevchildren(2): returns a list of names of all children of the current device\ndevfind(2): finds devices with a specific type\ndevinfo(2): returns a table with information describing a device node\ndevlisten(2): enables listening for events from this device\ndevlock(2): locks the specified device to this process\ndevlookup(2): returns all paths to devices that have the specified node name\ndevmethods(2): returns a list of methods that can be called on this device\ndevproperties(2): returns a list of properties on the device\ndevunlock(2): unlocks the specified device\nipconfig(2): queries or modifies the current PIP config\nkernargs(2): returns the arguments passed to the kernel\nkill(2): sends a signal to another process\nlink(2): creates a new symbolic link\nlist(2): returns a list of file names present in a directory\nlisten(2): starts listening for connections on the specified URI\nlistmodules(2): returns a list of currently loaded kernel module names\nloadCraftOSAPI(2): loads a CraftOS API or module from the ROM\nloadmodule(2): attempts to load a kernel module into memory\nlockmutex(2): locks the specified mutex\nmkdir(2): creates a new directory\nmkfifo(2): creates a new FIFO pipe file\nmount(2): mounts a disk device to a path\nmountlist(2): returns a list of mounts on the system\nnetcontrol(2): sends a control message to the specified IP address\nnetevent(2): returns or toggles the current state of network event reporting\nopen(2): opens a file for reading or writing\nqueueEvent(2): queues an arbitrary event to be sent back to the current process\nreleasesemaphore(2): releases a resource from a semaphore\nremove(2): deletes a file at a path\nrename(2): renames a file or directory from one path to another\nrouteadd(2): adds a new route to the specified route table\nroutedel(2): removes the specified route from the specified table\nroutelist(2): returns a list of route entries in the specified route table\nsendEvent(2): queues a remote event to be sent to another process\nsignal(2): registers a handler function to be called for a signal\nstat(2): returns a table with information about a file or directory\ntimeacquiresemaphore(2): acquires a resource from a semaphore object, waiting until available or timeout\ntimelockmutex(2): locks the specified mutex, waiting until the mutex is unlocked or timeout\ntimer(2): sets a timer\ntrylockmutex(2): attempts to lock the mutex\nunlisten(2): stops listening on a URI previously passed to listen\nunloadmodule(2): unloads a kernel module from memory\nunlockmutex(2): unlocks the specified mutex\nunmount(2): unmounts the mount at the specified path\nuptime(2): returns the amount of time the computer has been running\nversion(2): returns the Phoenix version or build number\nftp(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nusermgr(3): \nftpmgr(5): configuration file for ftpmgr\nmotd(5): \npasswd(5): \nshadow(5): \nyahtcc(6): Yahtzee clone for Phoenix\nadvanced-peripherals(7): \nfuse(7): filesystem in userspace kernel module\ngithubfs(7): GitHub read-only FUSE filesystem\nspanfs(7): RAID-like spanning filesystem across disk peripherals\nyellowbox(7): kernel level CraftOS virtualization\ncomponents(8): \ndpkg(8): \nftpmgr(8): \nmkspanfs(8): Create and format new spanfs disks\nspanadd(8): add drives to an existing span\nspaninfo(8): shows information about a span\nupdate-initrd(8): \nupdate(8): \nuseradd(8): \nuserdel(8): \nusermgr(8): \nusermod(8): \nkernel(9): \n",setuser=false,permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294717,size=4742},man7={type="directory",created=1740881294690,worldPermissions={execute=true,read=true,write=false},contents={["spanfs.md"]={type="file",created=1740881293904,worldPermissions={write=false,read=true,execute=false},data="<summary>RAID-like spanning filesystem across disk peripherals</summary>\n# NAME\nspanfs - RAID-like spanning filesystem across disk peripherals\n\n# DESCRIPTION\nspanfs is a kernel module that implements a spanning filesystem layer across a\nnumber of disk peripherals. It concatenates the contents of the disks together\ninto a single drive, which can store large files across multiple disks.\n\nspanfs stores file information using a single index disk, which holds the\nentire filesystem structure, plus up to 65535 of disks to store file\ncontents. Each disk has a file called \".spanfs\", which contains three lines:\nthe user-friendly name of the filesystem, a UUID identifying it, and the ID\nof the disk in the array. The ID is used to identify the disk's position in\nthe array regardless of mountpoint.\n\nDisk ID 0 is the index disk. This disk contains only one file called \"index\"\nwhich is a binary file that stores the entire filesystem tree, including\nfile names, metadata, and directory contents. A directory entry consists of\nthe following data (all integers are little-endian):\n\n| Format | Size | Description       |\n|--------|------|-------------------|\n| `I`    | 4    | Directory entry length (excluding contents) |\n| `I`    | 4    | File size         |\n| `I8`   | 8    | Creation date     |\n| `I8`   | 8    | Modification date |\n| `B`    | 1    | Type (using TAR file types) |\n| `B`    | 1    | Bits 0-2: world permissions, bit 7: set user |\n| `s2`   | 2+x  | File name         |\n| `s2`   | 2+x  | Owner name        |\n| `B`    | 1    | Number of permission entries |\n| `s2B`* | (3+x)*y | List of permissions - each entry is a name followed by a 3-bit mode |\n\nThe index file consists of one directory entry for the root of the\nfilesystem, which is always of type \"directory\".\n\nIf the entry points to a file, it is followed by a 16-byte string containing\nthe UUID of the file data, then a 2-byte integer indicating the number of\ndisks the file is split across, and then a list of 2-byte integers holding\nthe IDs of the disks which hold the data, in sequence, and finally a CRC-32\nchecksum of the file (4 bytes).\n\nIf the entry is a directory, it is followed by a 4-byte integer with the\nnumber of files in the directory, followed by each entry in sequence. If the\nentry is a link, it is followed by a 2-byte length string with the path that\nthe link points to. If the entry is a FIFO there is no data after the entry.\n\nNote that the entry length does not include the length of the contents -\nthis is to allow the format to be extended for more metadata in the future.\nSkip over the entire entry length to get to the contents - do not rely on\nthe contents being at the end of the above table! The order of the above\nfields will not change in the future - fields will only be added at the end.\n\nFile data is stored by a random UUID assigned to the file. Each part of a\nfile is distributed across independent chunks on each disk, with each chunk\nnamed with the file's UUID. The file can be reconstructed by concatenating\nthe contents of each chunk in the order specified in the ID list in the file\nentry.\n\nThe default allocation algorithm will first attempt to store the entire file\non a single disk, finding the disk with the least amount of free space that\ncan still fit the whole file. If there are no disks that can store the\nentire file, then the file will be split across as few disks as possible,\nusing the disks with the largest free space in order. If two disks have the\nsame amount of free space, the disk with the lowest ID is preferred.\n\n# CONFIGURATION\n**spanfs** can be installed by dropping the `spanfs.lua` kernel module into\n`/lib/modules`. Ensure the file is not world-writable, and is executable by root.\n\nUse the **mkspanfs**(8) program to create new spanfs volumes across disks.\n\n# SEE ALSO\n**mkspanfs**(8), **spaninfo**(8)",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293888,size=3841},["fuse.md"]={type="file",created=1740881292259,worldPermissions={write=false,read=true,execute=false},data="<summary>filesystem in userspace kernel module</summary>\n# NAME\nfuse - filesystem in userspace kernel module\n\n# DESCRIPTION\n**fuse** is a kernel module that implements an interface for filesystems written\nin userspace. This allows user programs to create and mount filesystem types\nwithout needing to load a kernel module. Filesystem operations are executed in a\nuser-mode process, with the results being sent back to the process that requested\nthe operation.\n\n# USAGE\nTo mount a **fuse**-based filesystem, simply use the **mount**(1) command with\nthe filesystem type **fuse**, and pass the filesystem to mount in the **fs**\noption. For example, an FTP filesystem could be mounted with the following command:\n\n```sh\nmount -t fuse -o fs=ftp,pasv ftp://user:password@10.0.1.1 /mnt/ftpshare\n```\n\nThis will mount the `ftp` filesystem (from `/lib/fuse/ftp.lua`) to `/mnt/ftpshare`,\nusing the mount source `ftp://user:password@10.0.1.1` and passing the `pasv`\noption to the filesystem.\n\nFilesystem modules are located in `/lib/fuse` by default. Filesystems located in\nother locations may be loaded by passing the path as the `fs` option.\n\n# WRITING FILESYSTEMS\nA **fuse** filesystem is simply a Lua library which returns a table with the\nrequired filesystem methods. The library is run with two parameters: the path to\nthe filesystem to mount, and a key-value table with the mount options. It is run\nin a thread under the process that called **mount**(2) (usually **mount**(1)).\n\nEach method in the filesystem is called with at least two arguments: the table\nreturned (as in `:` methods), and a process table filled from **getpinfo**(2).\nMost methods also have at least one path argument as a string. There is no need\nto do argument type checking: this is done in the kernel before calling the\nfilesystem methods.\n\nThe following methods are expected to be exported by the filesystem:\n\n```ts\ninterface Filesystem {\n    open(self: table, process: ProcessInfo, path: string, mode: string): table | string | ((data: string, reset: boolean): void);\n    list(self: table, process: ProcessInfo, path: string): string[];\n    stat(self: table, process: ProcessInfo, path: string, nolink?: boolean): Stat?;\n    remove(self: table, process: ProcessInfo, path: string): void;\n    rename(self: table, process: ProcessInfo, path: string, to: string): void;\n    mkdir(self: table, process: ProcessInfo, path: string): void;\n    link(self: table, process: ProcessInfo, path: string, location: string): void;\n    mkfifo(self: table, process: ProcessInfo, path: string): void;\n    chmod(self: table, process: ProcessInfo, path: string, user: string | nil, mode: string | number | table): void;\n    chown(self: table, process: ProcessInfo, path: string, owner: string): void;\n    unmount?(self: table, process: ProcessInfo): void;\n    init?(self: table, process: ProcessInfo): void;\n}\n```\n\nAll functions are optional, but calls on unimplemented functions will throw an\nerror to the caller. A minimal filesystem should implement at least `open`,\n`list`, and `stat`. The `unmount` method is called when the filesystem is about\nto be unmounted, and can be used to clean up resources before unmounting. If it\nis not present, no error is emitted, and the filesystem is removed as usual. The\n`init` method is called right after the filesystem is mounted, and can be used\nto initialize certain things that have to run on the client process.\n\nMost methods function the same as their respective syscalls. However, the `open`\nmethod has extra functionality: if it returns a string, then a read file handle\nwill be synthesized automatically (with a second boolean return value indicating\nwhether it should be binary). Likewise, if it returns a function, it'll return\na write file handle which will call the function to flush data to the file. This\ncan be used to simplify basic file open operations, reducing code duplication in\nthe process.\n\nEach mounted filesystem is given its own process to run as, which is forked from\nthe initial mount process, and is disconnected from TTYs. Methods are called in\nnew threads under that process. When the filesystem is unmounted, the main\nthread exits, which will cause the process to exit once the last remaining\nfilesystem method returns.\n\n# EXAMPLES\nHere is an example of a minimal filesystem:\n\n```lua\nlocal fs = {}\n\nfunction fs:open(process, path, mode)\n    if path == \"\" then return nil, \"Is a directory\"\n    elseif path == \"zero\" then\n        if mode:find \"[wa]\" then\n            return {\n                close = function() end,\n                seek = function() end,\n                write = function() end,\n                writeLine = function() end,\n                flush = function() end\n            }\n        end\n        return {\n            close = function() end,\n            seek = function() end,\n            read = function(n)\n                if not n then return 0\n                else return (\"\\0\"):rep(n) end\n            end,\n            readLine = function() return \"\" end,\n            readAll = function() return \"\" end\n        }\n    elseif path == \"random\" then\n        if mode:find \"[wa]\" then\n            return {\n                close = function() end,\n                seek = function() end,\n                write = function() end,\n                writeLine = function() end,\n                flush = function() end\n            }\n        end\n        return {\n            close = function() end,\n            seek = function() end,\n            read = function(n)\n                if not n then return math.random(0, 255)\n                else\n                    local s = \"\"\n                    for i = 1, n do s = s .. string.char(math.random(0, 255)) end\n                    return s\n                end\n            end,\n            readLine = function() return \"\" end,\n            readAll = function() return \"\" end\n        }\n    else return nil, \"No such file\" end\nend\n\nfunction fs:list(process, path)\n    if path == \"\" then\n        return {\"zero\", \"random\"}\n    else\n        error(\"No such directory\")\n    end\nend\n\nfunction fs:stat(process, path)\n    if path == \"zero\" then\n        return {\n            size = 0,\n            type = \"file\",\n            created = 0,\n            modified = 0,\n            owner = \"root\",\n            permissions = {},\n            worldPermissions = {read = true, write = false, execute = false},\n            setuser = false,\n            capacity = 0,\n            freeSpace = 0,\n            special = {}\n        }\n    elseif path == \"random\" then\n        return {\n            size = 0,\n            type = \"file\",\n            created = 0,\n            modified = 0,\n            owner = \"root\",\n            permissions = {},\n            worldPermissions = {read = true, write = false, execute = false},\n            setuser = false,\n            capacity = 0,\n            freeSpace = 0,\n            special = {}\n        }\n    elseif path == \"\" then\n        return {\n            size = 0,\n            type = \"directory\",\n            created = 0,\n            modified = 0,\n            owner = \"root\",\n            permissions = {},\n            worldPermissions = {read = true, write = false, execute = true},\n            setuser = false,\n            capacity = 0,\n            freeSpace = 0,\n            special = {}\n        }\n    else return nil end\nend\n\nreturn fs\n```\n\n# SEE ALSO\n**mount**(1)\n\n# AUTHORS\n**fuse** was written by JackMacWindows, based on the concepts of FUSE/libfuse\nfor *nix.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881292254,size=7444},["githubfs.md"]={type="file",created=1740881292321,worldPermissions={write=false,read=true,execute=false},data="<summary>GitHub read-only FUSE filesystem</summary>\n# NAME\ngithubfs - GitHub read-only FUSE filesystem\n\n# DESCRIPTION\n**githubfs** is a FUSE filesystem that allows mounting GitHub repositories to\nthe local filesystem. It allows read-only access to public repositories, as well\nas private repositories with a personal access key.\n\n# USAGE\nSimply mount the repo URL using a **fuse**(7) mount:\n\n```sh\nmount -t fuse -o fs=githubfs https://github.com/username/repo /mnt/path\n```\n\nThe URL must be in the form `http[s]://github.com/<username>/<repo>[/|.git]`.\n\nThe following extra options are available:\n- **token**: The PAK to use for authorization, if desired. This is required for\n  private repositories.\n- **branch**: The branch to access (defaults to the repo's default branch).\n\n# SEE ALSO\n**mount**(1), **fuse**(7)\n\n# AUTHORS\n**githubfs** was written by JackMacWindows for Phoenix.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881292317,size=882},["advanced-peripherals.md"]={type="file",created=1740881291060,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881291057,size=0},["yellowbox.md"]={type="file",created=1740881294690,worldPermissions={write=false,read=true,execute=false},data="<summary>kernel level CraftOS virtualization</summary>\n# NAME\nYellowBox - kernel level CraftOS virtualization\n\n# DESCRIPTION\n**yellowbox** is a kernel module which implements a ComputerCraft virtual machine for running CraftOS programs on Phoenix. It acts as a more robust alternative to **libcraftos**, which is a simple translation layer from CraftOS APIs to Phoenix syscalls - instead, it runs a full CraftOS machine, which avoids the quirks that come from call translation.\n\nYellowBox operates on constructs known as *boxes*. A box holds an entire CraftOS runtime, and is represented by a numerical ID (which corresponds to the user process for the box). Boxes have a main coroutine, a TTY, and a process associated with them, among other things. The TTY holds the contents of the computer's terminal, which can be read to display the screen elsewhere. The box's process represents the box in userspace, and it sends events coming from Phoenix programs into the machine, as well as triggering the machine to continue running.\n\nTo ensure compatibility with CraftOS programs, YellowBox runs as a kernel service, which avoids issues caused by yielding for preemption or system calls. The ComputerCraft APIs directly call the respective underlying kernel routines, which means that no yielding is required (though some filesystems which yield internally may cause spurious yields - this is mitigated through some hacks). This also means that Phoenix programs will not run while the box is running - avoid running heavy programs inside the box.\n\nWhile YellowBox runs directly in the kernel instead of userspace, the APIs exposed still call out to Phoenix syscalls and functions. The box has an associated root directory and user, and filesystem calls go through the Phoenix VFS layer, allowing permissions and mounts to be used from CraftOS. \n\n# INTERFACING WITH BOXES\nThe **yellowbox** kernel module exposes a module API (i.e. the `callmodule` syscall) which allows programs to interact with boxes. To create a box, call the **create** method, which takes a single table argument with options for the box, and returns the ID of the box. Creating a box requires root privileges, as boxes run at a higher privilege level. The options available include:\n- *bios*: The contents of the BIOS program to use (required)\n- *root*: The root directory for the box\n- *user*: The user to run as\n- *peripherals*: A key-value mapping of peripherals to expose to the machine (key is CraftOS name, value is Phoenix hardware node path/UUID)\n- *http*: A boolean specifying whether to expose the `http` API\n\nThe box will start executing directly after calling this method. To access the TTY with the box's terminal contents, call the **getTTY** method with the ID of the box. This will return a TTY object like `mktty` does. It will also assign the calling process to the TTY, meaning that it will get `tty_redraw` events when the box writes to the screen. Note that the box only uses the exclusive-text-mode buffer (`tty.textBuffer`), so the main buffer will always be empty.\n\nEvents that are requested by CraftOS APIs, as well as peripheral events for devices that are forwarded, will be sent to the machine automatically. However, user-interactive events like `key` aren't handled by YellowBox itself. To send events to the box, including user-interactive events, send a remote event to the userspace program (whose PID is the box ID). The remote event name should be the event to queue, and the parameter should be a list of parameters for the event, with an optional `n` field for the number of parameters. The event will be queued into the box with no modification. Because of this, for `key` events, make sure to convert the key ID to a proper CraftOS key code. The included library contains a routine to convert Phoenix keycodes into CraftOS keycodes using a `keys` API loaded from the CraftOS ROM.\n\nThe box can be restarted or shut down using the `reboot` and `shutdown` methods, respectively. The box can also be stopped entirely by calling the `stop` method, which requires root privileges.\n\n# SEE ALSO\n**yellowbox**(1)",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881294680,size=4110}},permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294690,size=0},man6={type="directory",created=1740881294561,worldPermissions={execute=true,read=true,write=false},contents={["yahtcc.md"]={type="file",created=1740881294561,worldPermissions={write=false,read=true,execute=false},data="<summary>Yahtzee clone for Phoenix</summary>\n# NAME\n    yahtcc - Yahtzee clone for Phoenix\n\n# SYNOPSIS\n    **yahtcc**\n\n# DESCRIPTION\n**yahtcc** is a clone of the popular dice game \"Yahtzee\". Players roll a set of\nfive dice up to three times per round, trying to get the dice to roll in\ncertain patterns. Each pattern grants a number of points, and the goal of the\ngame is to achieve the highest number of points.\n\nThe main screen shows a scorecard with the available categories and the number\nof points already scored or available to score. Locked scores are colored white,\npossible scores are colored blue, and possible scores worth 0 points are colored\ngray. Below that, the current set of dice is displayed. Locked dice are colored\nyellow, while unlocked dice are colored white. The roll cup shows whether\nanother roll is available. The current total score and number of available rolls\nis displayed above the scorecard.\n\nTo roll the dice, press the **R** key or click on the roll cup. The unlocked\ndice will be rolled fresh, leaving the locked dice in-place. Dice may then be\nlocked or unlocked by pressing the **1**-**5** keys, or by clicking on any of\nthe dice. To lock a score, use the arrow keys to select the category to score,\nand press **Enter** to score it. Alternatively, double-click on any of the\nunscored categories.\n\n# GAMEPLAY\nA game of **yahtcc** consists of 13 rounds, with each round having three dice\nrolls, and ends when the player selects a pattern to score the current set of\ndice on. Between rolls, the player may lock any of the five dice, which will\nprevent them from being changed in the next roll. The player may score during\nany roll, but they must score after the third roll. Once a pattern is scored, it\ncannot be changed later.\n\nSix of the patterns are scored based on the number of dice in the set that match\nthe number for the score. The score is calculated by summing the values of those\ndice. For example, the *Threes* pattern will sum the value of all of the dice\nwith a value of 3.\n\nSix of the patterns are all-or-nothing based on whether the set of dice contains\ndice matching a pattern. If the pattern matches, the category gets the full score; otherwise, it is worth 0 points. The patterns in this category are scored as follows:\n\n- *Three of a Kind*: Matches when any three dice have the same value. Worth\nthe sum of all dice in the set.\n- *Four of a Kind*: Matches when any four dive have the same value. Worth\nthe sum of all dice in the set.\n- *Full House*: Matches when three dice have the same value, and two differently-valued dice are equal. Worth 25 points.\n- *Small Straight*: Matches when four dice have sequential values (i.e. 1-2-3-4,\n2-3-4-5, 3-4-5-6). Worth 30 points.\n- *Large Straight*: Matches when five dice have sequential values (i.e.\n1-2-3-4-5, 2-3-4-5-6). Worth 40 points.\n- *Yahtzee*: Matches when all five dice have the same value. Worth 50 points.\n\nThe last pattern, *Chance*, is a wildcard pattern that is always worth points.\nIts value is equal to the sum of the values of all dice.\n\nTwo bonuses can be triggered during the game. The *Bonus* score on the left is\nactivated when the sum of all of the numbered scores is greater than or equal to\n63, which corresponds to at least 3 dice in each category. When activated, it is\nworth 35 points. The *Yahtzee Bonus* score on the right is automatically\nactivated when all five dice rolled have the same value and the *Yahtzee*\ncategory has been scored with 50 points. It is worth 100 points.\n\nOnce all 13 categories have been scored, the game ends, and the final score is\nsimply the sum of all points awarded in each category. The final score is\nprinted to the console after the game ends.\n\n# AUTHORS\nYahtCC was written by JackMacWindows in 2020, and ported to Phoenix in 2022. It is licensed under the GPL license.\n\n*Yahtzee* is a registered trademark of Hasbro, Inc.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881294556,size=3884}},permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294561,size=0},man9={type="directory",created=1740881293595,worldPermissions={execute=true,read=true,write=false},contents={["kernel.md"]={type="file",created=1740881293595,worldPermissions={write=false,read=true,execute=false},data="---\nlayout: default\ntitle: Kernel API\n---\n\n# Kernel API\nThis page contains documentation for the public kernel module API.\n\nThis is a work-in-progress! Some parts may be broken or don't make sense.\n\n## `version: string`\nVersion number of Phoenix.\n\n## `do_syscall(call: string, ...: any): any...`\nSmall function to execute a syscall and error if it fails.\n\n### Arguments\n1. `call`: The syscall to execute\n2. `...`: The arguments to pass to the syscall\n\n### Return Values\nThe values returned from the syscall\n\n## `deepcopy(tab: any): any`\nCopies a value.  If the value is a table, copies all of its contents too.\n\n### Arguments\n1. `tab`: The value to copy\n\n### Return Values\nThe new copied value\n\n## `split(str: string[, sep: string = \"%s\"]): {string}`\nSplits a string by a separator.\n\n### Arguments\n1. `str`: The string to split\n2. `sep`: The separator pattern to split by (defaults to \"%s\")\n\n### Return Values\nA list of items in the string\n\n## `executeThread(process: Process, thread: Thread, ev: table, dead: boolean, allWaiting: boolean): boolean, boolean`\nResumes a thread's coroutine, handling different yield types.\n\n### Arguments\n1. `process`: The process that owns the thread\n2. `thread`: The thread to resume\n3. `ev`: An event to pass to the thread, if present\n4. `dead`: Whether a thread in the current run cycle has died\n5. `allWaiting`: Whether all previous threads were waiting for an event\n\n### Return Values\nThis function may return the following values:\n1. Whether this thread or a previous thread has died\n2. Whether all threads (including this one) are waiting for an event\n\n## `userModeCallback(process: Process, func: function, ...: any): boolean, any`\nExecutes a function in user mode from kernel code.\n\n### Arguments\n1. `process`: The process to execute as\n2. `func`: The function to execute\n3. `...`: Any parameters to pass to the function\n\n### Return Values\nThis function may return the following values:\n1. Whether the function returned successfully\n2. The value that the function returned.\n\n## `make_ENV(env: table): table`\nCreates a new _ENV shadow environment for a table.  The resulting table can\n have its environment set through `t._ENV = val`.\n\n### Arguments\n1. `env`: The environment table to use\n\n### Return Values\nA new _ENV-ized table\n\n## `args`\nStores all kernel arguments passed on the command line.\n\n### Fields\n- `init`:\n- `root`:\n- `rootfstype`:\n- `preemptive`:\n- `quantum`:\n- `splitkernpath`:\n- `loglevel`:\n- `console`:\n- `traceback`:\n\n## `syscalls`\nContains every syscall defined in the kernel.\n\n## `processes`\nStores all currently running processes.\n\n### Fields\n- `[0]`:\n- `id`:\n- `user`:\n- `dir`:\n- `dependents`:\n\n## `modules`\nStores all currently loaded kernel modules.\n\n## `eventHooks`\nStores a list of hooks to call on certain CraftOS events.  Each entry has the\n event name as a key, and a list of functions to call as the value. The\n functions are called with a single table parameter with the event parameters.\n\n## `process`\nProcess API\n\n## `filesystem`\nFilesystem API\n\n## `terminal`\nTerminal API\n\n## `user`\nUser API\n\n## `syslog`\nSystem logger API\n\n## `hardware`\nHardware API\n\n## `PHOENIX_BUILD`\nBuild string of Phoenix.\n\n### Fields\nThis function does not take any arguments.\n\n## `systemStartTime`\nStores the start time of the kernel.\n\n### Fields\nThis function does not take any arguments.\n\n## `KERNEL`\nStores a quick reference to the kernel process object.\n\n### Fields\nThis function does not take any arguments.\n\n# filesystem\n\n\n## `mounts`\nStores the current mounts as a key-value table of paths to filesystem objects.\n\n## `filesystems`\nThis table contains all filesystem types.  Use this to insert more filesystem\n types into the system.\n\n A filesystem type has to implement one method for each function in the\n filesystem API, with the exception of mounting-related functions and `combine`,\n as well as a `new` method that is called with the process, the source device,\n and the options table (if present). Paths passed to these methods (outside\n `new`) take a relative path to the mountpoint, NOT the absolute path.\n\n### Fields\n- `craftos`:\n- `owner`:\n- `permissions`:\n- `write`:\n- `execute`:\n\n## `filesystem.open(process: Process, path: string, mode: string): Handle / nil, string`\nOpens a file for reading or writing.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The file path to open, which may be absolute or relative\n to the process's working directory\n3. `mode`: The mode to open the file as\n\n### Return Values\nThis function may return the following values:\n1. The new file handle\n\nOr:\n1. If an error occurred\n2. An error message describing why the file couldn't be opened\n\n## `filesystem.list(process: Process, path: string): {string}`\nReturns a list of file names in the directory.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The file path to list, which may be absolute or relative\n to the process's working directory\n\n### Return Values\nA list of file names present in the directory\n\n## `filesystem.stat(process: Process, path: string): table / nil, string`\nReturns a table with information about the selected path.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The file path to stat, which may be absolute or relative\n to the process's working directory\n\n### Return Values\nThis function may return the following values:\n1. A table with information about the path (see the docs for\n the `stat` syscall for more info)\n\nOr:\n1. If an error occurred\n2. An error message describing why the file couldn't be opened\n\n## `filesystem.remove(process: Process, path: string)`\nRemoves a file or directory.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The file path to remove, which may be absolute or relative\n to the process's working directory\n\n### Return Values\nThis function does not return anything.\n\n## `filesystem.rename(process: Process, path: string, new: The)`\nRenames (moves) a file or directory.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The file path to rename, which may be absolute or relative\n to the process's working directory\n3. `new`: path the file will be at, which may be in another directory\n but must be on the same mountpoint\n\n### Return Values\nThis function does not return anything.\n\n## `filesystem.mkdir(process: Process, path: string)`\nCreates a new directory and any parent directories.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The directory to create, which may be absolute or relative\n to the process's working directory\n\n### Return Values\nThis function does not return anything.\n\n## `filesystem.chmod(process: Process, path: string, user: string|nil, boolean: number|string|{read)`\nChanges the permissions (mode) of a file or directory for the specified user.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The file path to modify, which may be absolute or relative\n to the process's working directory\n3. `user`: The user to change the permissions for, or `nil` for all users\n4. `boolean`: ?, write = boolean?, execute = boolean?} mode The\n new permissions for the user (see the docs for the `chmod` syscall for more info)\n\n### Return Values\nThis function does not return anything.\n\n## `filesystem.chown(process: Process, path: string, user: string)`\nChanges the owner of a file or directory.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The file path to modify, which may be absolute or relative\n to the process's working directory\n3. `user`: The user that will own the file\n\n### Return Values\nThis function does not return anything.\n\n## `filesystem.mount(process: Process, type: string, src: string, dest: string, options: table?)`\nMounts a disk device to a path using the specified filesystem and options.\n\n### Arguments\n1. `process`: The process to operate as\n2. `type`: The type of filesystem to mount\n3. `src`: The source device to mount\n4. `dest`: The destination mountpoint\n5. `options`: Any options to pass to the mounter (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `filesystem.unmount(process: Process, path: string)`\nUnmounts a filesystem at a mountpoint.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The mountpoint to remove, which may be absolute or relative\n to the process's working directory\n\n### Return Values\nThis function does not return anything.\n\n## `filesystem.combine(first: string, ...: string): string`\nCombines the specified path components into a single path.\n\n### Arguments\n1. `first`: The first path component\n2. `...`: Any additional path components to add\n\n### Return Values\nThe final combined path\n\n## `createLuaLib(process: Process): _G`\nCreates a new global table with a Lua 5.2 standard library installed.\n\n### Arguments\n1. `process`: The process to generate for\n\n### Return Values\nA new global table for the process\n\n# terminal\n\n\n## `terminal.makeTTY(term: table, width: number, height: number): TTY`\nReturns a new TTY object.\n\n### Arguments\n1. `term`: The CraftOS terminal object to render on\n2. `width`: The width of the TTY\n3. `height`: The height of the TTY\n\n### Return Values\nThe new TTY object\n\n## `TTY`\nStores all virtual TTYs for the main screen.\n\n### Fields\n- `terminal`:\n- `terminal`:\n- `terminal`:\n- `terminal`:\n- `terminal`:\n- `terminal`:\n- `terminal`:\n- `terminal`:\n\n## `currentTTY`\nStores the TTY that is currently shown on screen.\n\n### Fields\nThis function does not take any arguments.\n\n## `terminal.userTTYs`\nStores all TTYs that have been created in user mode.\n\n## `keysHeld`\nStores what modifier keys are currently being held.\n\n### Fields\n- `ctrl`:\n- `alt`:\n- `shift`:\n\n## `terminal.redraw(tty: TTY, full: boolean)`\nRedraws the specified TTY if on-screen.\n\n### Arguments\n1. `tty`: The TTY to redraw\n2. `full`: Whether to draw the full screen, or just the changed regions\n\n### Return Values\nThis function does not return anything.\n\n## `terminal.resize(tty: TTY, width: number, height: number)`\nResizes the TTY.\n\n### Arguments\n1. `tty`: The TTY to resize\n2. `width`: The new width\n3. `height`: The new height\n\n### Return Values\nThis function does not return anything.\n\n## `terminal.write(tty: TTY, text: string)`\nWrites some text to a TTY's text buffer, allowing ANSI escapes.\n\n### Arguments\n1. `tty`: The TTY to write to\n2. `text`: The text to write\n\n### Return Values\nThis function does not return anything.\n\n# syslog\n\n\n## `syslogs`\nStores all open system logs.\n\n### Fields\n- `default`: file = filesystem.open(KERNEL, \"/var/log/default.log\", \"a\"),\n\n## `panic(message: any?)`\nImmediately halts the system and shows an error message on screen.\n This function can be called either standalone or from within xpcall.\n This function never returns.\n\n### Arguments\n1. `message`: A message to display on screen (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `createRequire(process: Process, G: _G)`\nCreates a new `package` and `require` set in a global table for the specified process.\n\n### Arguments\n1. `process`: The process to make the functions for\n2. `G`: The global environment to install in\n\n### Return Values\nThis function does not return anything.\n\n## `timerMap`\nStores a list of used timers.\n\n## `alarmMap`\nStores a list of used alarms.\n\n## `reap_process(process: Process)`\nFinishes a process's resources so it can be removed cleanly.\n\n### Arguments\n1. `process`: The process to reap\n\n### Return Values\nThis function does not return anything.\n\n# hardware\n\n\n## `deviceTreeRoot`\nStores the root device for hardware.\n\n### Fields\n- `id`:\n- `uuid`:\n- `parent`:\n- `displayName`:\n- `drivers`:\n\n## `hardware.get(path: string): Device...`\nReturns all devices that match a path specifier.\n\n### Arguments\n1. `path`: The path to query\n\n### Return Values\nThe device objects that match\n\n## `hardware.find(type: string): Device...`\nReturns all devices that match a type.\n\n### Arguments\n1. `type`: The type to find\n\n### Return Values\nThe device objects that match\n\n## `hardware.path(node: Device): string`\nReturns the absolute path to a device node.\n\n### Arguments\n1. `node`: The node to lookup\n\n### Return Values\nThe path to the node\n\n## `hardware.add(parent: Device, name: string): Device`\nAdds a new child to the specified node.\n\n### Arguments\n1. `parent`: The parent of the new node\n2. `name`: The name of the new node\n\n### Return Values\nThe newly added node\n\n## `hardware.remove(node: Device): boolean, string?`\nRemoves a node from its parent and the device tree.  The device node should\n no longer be used.\n\n### Arguments\n1. `node`: The node to remove\n\n### Return Values\nThis function may return the following values:\n1. Whether the operation succeeded\n2. An error message if it failed\n\n## `hardware.register(node: Device, driver: Driver): boolean, string?`\nRegisters a device driver on a node.\n\n### Arguments\n1. `node`: The node to modify\n2. `driver`: The driver to add\n\n### Return Values\nThis function may return the following values:\n1. Whether the operation succeeded\n2. An error message if it failed\n\n## `hardware.register_callback(driver: Driver): function`\nReturns a function that automatically attaches a driver to a node.\n\n### Arguments\n1. `driver`: The driver to use\n\n### Return Values\nA function that takes a node and registers the driver on it\n\n## `hardware.deregister(node: Device, driver: Driver): boolean, string?`\nDeregisters a driver from a node.\n\n### Arguments\n1. `node`: The node to modify\n2. `driver`: The driver to remove\n\n### Return Values\nThis function may return the following values:\n1. Whether the operation succeeded\n2. An error message if it failed\n\n## `hardware.listen(callback: function, parent: Device?, pattern: string?)`\nAdds a function that is called when either a parent node or pattern matches on a new node.\n\n### Arguments\n1. `callback`: A function that is called with a node when the pattern matches\n2. `parent`: A parent node to watch on (optional)\n3. `pattern`: A Lua pattern to match on the device name (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `hardware.unlisten(callback: function)`\nRemoves a listener callback from the listener list.\n\n### Arguments\n1. `callback`: The function to remove\n\n### Return Values\nThis function does not return anything.\n\n## `hardware.broadcast(node: Device, event: string, param: table)`\nBroadcasts an event to all processes listening to events on a node.\n\n### Arguments\n1. `node`: The node to broadcast for\n2. `event`: The event to broadcast\n3. `param`: The parameters to pass for the event\n\n### Return Values\nThis function does not return anything.\n\n## `hardware.call(process: Process, node: Device, method: string, ...: any): any...`\nCalls a method on a device.\n\n### Arguments\n1. `process`: The process to run as\n2. `node`: The node to call on\n3. `method`: The method to call\n4. `...`: Any arguments to pass\n\n### Return Values\nAny return values from the method\n\n## `uriSchemes`\nStores all URI scheme handlers using Lua patterns as keys.\n\n### Fields\n- `[https?]`:\n- `[wss?]`:\n- `[rednet]`:\n- `[rednet%+%a+]`:\n- `[psp]`:\n\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293545,size=15004}},permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293595,size=0},man3={type="directory",created=1740881294450,worldPermissions={execute=true,read=true,write=false},contents={["usermgr.md"]={type="file",created=1740881294450,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881294408,size=0},["system.keys.md"]={type="file",created=1740881293590,worldPermissions={write=false,read=true,execute=false},data="# system.keys\nThe keys module assigns names to the keycode constants that Phoenix sends in\n key events, and adds a few functions to make using them easier.  This module\n uses the same names as the CraftOS `keys` API, so porting programs should be\n trivial.\n\n\n## `getName(id: number): string|nil`\nReturns the name for the specified keycode.\n\n### Arguments\n1. `id`: The keycode to check\n\n### Return Values\nThe name (which is a key in `keys`), or `nil` if the code is invalid\n\n## `getCharacter(id: number): string|nil`\nReturns a printable representation of the keycode if available.\n\n### Arguments\n1. `id`: The keycode to check\n\n### Return Values\nThe keycode's character (in lowercase), or `nil` if the code doesn't have a printable representation\n\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293518,size=746},["system.pretty.md"]={type="file",created=1740881293592,worldPermissions={write=false,read=true,execute=false},data="# system.pretty\nProvides a \"pretty printer\", for rendering data structures in an\naesthetically pleasing manner.\n\nIn order to display something using @{pretty}, you build up a series of\n@{Doc|documents}. These behave a little bit like strings; you can concatenate\nthem together and then print them to the screen.\n\nHowever, documents also allow you to control how they should be printed. There\nare several functions (such as @{nest} and @{group}) which allow you to control\nthe \"layout\" of the document. When you come to display the document, the 'best'\n(most compact) layout is used.\n\nThe structure of this module is based on [A Prettier Printer][prettier].\n\n[prettier]: https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf \"A Prettier Printer\"\n\n\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293526,size=760},["system.hardware.md"]={type="file",created=1740881293589,worldPermissions={write=false,read=true,execute=false},data="# system.hardware\nThe hardware module implements functions for operating on peripherals and\n other hardware devices.\n\n## `wrap(device: string): device`\nWraps a device into an indexable object, allowing accessing properties and\n methods of the device by indexing the table.\n If an object is passed, this simply re-wraps the device in a new object.\n\n### Arguments\n1. `device`: The device specifier or object to wrap\n\n### Return Values\nThe wrapped device\n\n## `find(type: string): device...`\nReturns a list of wrapped devices that implement the specified type.\n\n### Arguments\n1. `type`: The type to search for\n\n### Return Values\nThe devices found, or `nil` if none were found\n\n## `path(device: string|device): string...`\nReturns a list of device paths that match the device specifier or object.\n If an absolute path is specified, this returns the same path back.\n If a device object is specified, this returns the path to the device.\n\n### Arguments\n1. `device`: The device specifier or object to read\n\n### Return Values\nThe paths that match the specifier or device object.\n\n## `hasType(device: string|device, type: string): boolean`\nReturns whether the device implements the specified type.\n\n### Arguments\n1. `device`: The device specifier or object to query\n2. `type`: The type to check for\n\n### Return Values\nWhether the device implements the type\n\n## `info(device: string|device): HWInfo|nil`\nReturns a table of information about the specified device.\n\n### Arguments\n1. `device`: The device specifier or object to query\n\n### Return Values\nThe hardware info table, or `nil` if no device was found\n\n## `methods(device: string|device): {string...}`\nReturns a list of methods implemented by this device.\n\n### Arguments\n1. `device`: The device specifier or object to query\n\n### Return Values\nThe methods available to call on this device\n\n## `properties(device: string|device): {string...}`\nReturns a list of properties implemented by this device.\n\n### Arguments\n1. `device`: The device specifier or object to query\n\n### Return Values\nThe properties available on this device\n\n## `children(device: string|device): {string...}`\nReturns a list of children of this device.\n\n### Arguments\n1. `device`: The device specifier or object to query\n\n### Return Values\nThe names of children of the device\n\n## `call(device: string|device, method: string, ...: any): any...`\nCalls a method on a device.\n\n### Arguments\n1. `device`: The device specifier or object to call on\n2. `method`: The method to call\n3. `...`: Any arguments to pass to the method\n\n### Return Values\nThe return values from the method\n\n## `listen(device: string|device[, state: boolean = true])`\nToggles whether this process should receive events from the device.\n\n### Arguments\n1. `device`: The device specifier or object to modify\n2. `state`: Whether to allow events (defaults to true)\n\n### Return Values\nThis function does not return anything.\n\n## `lock(device: string|device[, wait: boolean = true]): boolean`\nLocks the device from being called on or listened to by other processes.\n\n### Arguments\n1. `device`: The device specifier or object to modify\n2. `wait`: Whether to wait for the device to unlock if\n it's currently locked by another process (defaults to true)\n\n### Return Values\nWhether the current process now owns the lock\n\n## `unlock(device: string|device)`\nUnlocks the device after previously locking it.\n\n### Arguments\n1. `device`: The device specifier or object to modify\n\n### Return Values\nThis function does not return anything.\n\n## `tree`\nA table that allows accessing device object pointers in a tree.  This is\n simply syntax sugar for real paths.\n\n### Fields\nThis function does not take any arguments.\n\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293512,size=3673},["system.log.md"]={type="file",created=1740881293591,worldPermissions={write=false,read=true,execute=false},data="# system.log\nThe log module exposes functions for interacting with the logging subsystem.\n The default system log is available under the root `log` table. Other logs\n created through @{log.create} can be accessed by indexing the `log` table with\n the name of the log, e.g. `log.mylog.info(\"hello\")`. Both the main and\n subtables may also be called directly, e.g. `log(\"test\")` or `log.mylog(\"hello\")`.\n\n\n## `log(options: table?, ...: any)`\nWrites a message to the log.\n\n### Arguments\n1. `options`: A table of options to supply. See the documentation\n for the syslog syscall for more information. (optional)\n2. `...`: The values to print to the log, which will be concatenated as\n strings with \\t.\n\n### Return Values\nThis function does not return anything.\n\n## `debug(options: table?, ...: any)`\nWrites a debug message to the log.\n\n### Arguments\n1. `options`: A table of options to supply. See the documentation\n for the syslog syscall for more information. (optional)\n2. `...`: The values to print to the log, which will be concatenated as\n strings with \\t.\n\n### Return Values\nThis function does not return anything.\n\n## `info(options: table?, ...: any)`\nWrites an info message to the log.\n\n### Arguments\n1. `options`: A table of options to supply. See the documentation\n for the syslog syscall for more information. (optional)\n2. `...`: The values to print to the log, which will be concatenated as\n strings with \\t.\n\n### Return Values\nThis function does not return anything.\n\n## `notice(options: table?, ...: any)`\nWrites a notice message to the log.\n\n### Arguments\n1. `options`: A table of options to supply. See the documentation\n for the syslog syscall for more information. (optional)\n2. `...`: The values to print to the log, which will be concatenated as\n strings with \\t.\n\n### Return Values\nThis function does not return anything.\n\n## `warning(options: table?, ...: any)`\nWrites a warning message to the log.\n\n### Arguments\n1. `options`: A table of options to supply. See the documentation\n for the syslog syscall for more information. (optional)\n2. `...`: The values to print to the log, which will be concatenated as\n strings with \\t.\n\n### Return Values\nThis function does not return anything.\n\n## `error(options: table?, ...: any)`\nWrites an error message to the log.\n\n### Arguments\n1. `options`: A table of options to supply. See the documentation\n for the syslog syscall for more information. (optional)\n2. `...`: The values to print to the log, which will be concatenated as\n strings with \\t.\n\n### Return Values\nThis function does not return anything.\n\n## `critical(options: table?, ...: any)`\nWrites a critical error message to the log.\n\n### Arguments\n1. `options`: A table of options to supply. See the documentation\n for the syslog syscall for more information. (optional)\n2. `...`: The values to print to the log, which will be concatenated as\n strings with \\t.\n\n### Return Values\nThis function does not return anything.\n\n## `traceback(message: string?)`\nWrites a traceback error message to the log.\n\n### Arguments\n1. `message`: A message to attach to the traceback (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `create(name: string, streamed: boolean?, file: string?): table`\nCreates a new log.\n\n### Arguments\n1. `name`: The name of the log to create\n2. `streamed`: Whether to make the log available for streaming (optional)\n3. `file`: The path to the file to write the log to (optional)\n\n### Return Values\nA logger object from `log.*`\n\n## `remove(name: string)`\nRemoves a previously created log.\n\n### Arguments\n1. `name`: The log to remove\n\n### Return Values\nThis function does not return anything.\n\n## `open(name: string, filter: string?): number`\nOpens a log for listening to messages.\n\n### Arguments\n1. `name`: The name of the log to listen to\n2. `filter`: A filter command to filter messages with (see the\n openlog syscall docs for more info) (optional)\n\n### Return Values\nAn ID to identify the logged messages with\n\n## `close(name: string|number)`\nCloses a log or stream for listening.\n\n### Arguments\n1. `name`: The log name to close (closes all streams), or an\n ID returned by <a href=\"log.html#open\">log.open</a>.\n\n### Return Values\nThis function does not return anything.\n\n## `setTTY(name: string, tty: TTY|nil, level: number?)`\nSets the TTY to output a log to.  (Requires root)\n\n### Arguments\n1. `name`: The log to set the TTY of\n2. `tty`: The TTY to use, or `nil` to disable\n3. `level`: The minimum log level to show messages (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `levels`\nConstants for log levels.\n\n### Fields\n- `debug`:\n- `info`:\n- `notice`:\n- `warning`:\n- `error`:\n- `critical`:\n\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293521,size=4678},["system.filesystem.md"]={type="file",created=1740881293587,worldPermissions={write=false,read=true,execute=false},data="# system.filesystem\nThe filesystem module implements common operations for working with the\n filesystem, including wrappers for syscalls.\n\n## `open(path: string, mode: string): FileHandle / nil, string`\nOpens a file for reading or writing.\n\n### Arguments\n1. `path`: The path to the file to open\n2. `mode`: The mode to open the file in: [rwa]b?\n\n### Return Values\nThis function may return the following values:\n1. The file handle, which has the same functions as CraftOS file handles\n\nOr:\n1. If the file could not be opened\n2. An error message describing why the file couldn't be opened\n\n## `list(path: string): table`\nReturns a list of files in a directory.\n\n### Arguments\n1. `path`: The path to query\n\n### Return Values\nA list of files and folders in the directory\n\n## `stat(path: string[, nolink: boolean = false]): FileStat`\nReturns a table with various information about a file or directory.\n\n### Arguments\n1. `path`: The path to query\n2. `nolink`: Whether to not resolve links to the file (defaults to false)\n\n### Return Values\nA table with information about the path\n\n## `remove(path: string)`\nDeletes a file or directory at a path, removing any subentries if present.\n\n### Arguments\n1. `path`: The path to remove\n\n### Return Values\nThis function does not return anything.\n\n## `rename(from: string, to: string)`\nMoves a file or directory on the same filesystem.\n\n### Arguments\n1. `from`: The original file to move\n2. `to`: The new path for the file\n\n### Return Values\nThis function does not return anything.\n\n## `mkdir(path: string)`\nCreates a directory, making any parent paths that don't exist.\n\n### Arguments\n1. `path`: The directory to create\n\n### Return Values\nThis function does not return anything.\n\n## `link(path: string, location: string)`\nCreates a (symbolic) link to a file.\n\n### Arguments\n1. `path`: The path of the new link\n2. `location`: The location to point the link to\n\n### Return Values\nThis function does not return anything.\n\n## `mkfifo(path: string)`\nCreates a FIFO.\n\n### Arguments\n1. `path`: The FIFO to create\n\n### Return Values\nThis function does not return anything.\n\n## `chmod(path: string, user: string|nil, mode: number|string|{read?=boolean,write?=boolean,execute?=boolean})`\nChanges the permissions (mode) of the file at a path.\n\n### Arguments\n1. `path`: The path to modify\n2. `user`: The user to modify, or nil to modify world permissions\n3. `mode`: The new permissions, as either an octal bitmask, a string in the format \"[+-=][rwx]+\" or \"[r-][w-][x-]\", or a table with the permissions to set (any `nil` arguments are left unset).\n\n### Return Values\nThis function does not return anything.\n\n## `chown(path: string, user: string)`\nChanges the owner of a file or directory.\n\n### Arguments\n1. `path`: The path to modify\n2. `user`: The new owner of the file\n\n### Return Values\nThis function does not return anything.\n\n## `chroot(path: string)`\nChanges the root directory of the current and future child processes.\n This function requires root.\n\n### Arguments\n1. `path`: The new root path to change to\n\n### Return Values\nThis function does not return anything.\n\n## `mount(type: string, src: string, dest: string, options: table?)`\nMounts a filesystem of the specified type to a directory.\n\n### Arguments\n1. `type`: The type of filesystem to mount\n2. `src`: The source of the mount (depends on the FS type)\n3. `dest`: The destination directory to mount to\n4. `options`: A table of options to pass to the filesystem (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `unmount(path: string)`\nUnmounts a mounted filesystem.\n\n### Arguments\n1. `path`: The filesystem to unmount\n\n### Return Values\nThis function does not return anything.\n\n## `mountlist(): [{path:string,type:string,source:string,options:table}]`\nReturns a list of mounts currently available.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nA list of mounts and their properties.\n\n## `combine(...: string): string`\nCombines the specified path components into a single path, canonicalizing any links and ./..  paths.\n\n### Arguments\n1. `...`: The path components to combine\n\n### Return Values\nThe combined and canonicalized path\n\n## `copy(from: string, to: string, preserve: boolean?)`\nCopies a file or directory.\n\n### Arguments\n1. `from`: The path to copy from\n2. `to`: The path to copy to\n3. `preserve`: Whether to preserve permissions when copying (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `move(from: string, to: string)`\nMoves a file or directory, allowing cross-filesystem operations.\n\n### Arguments\n1. `from`: The path to move from\n2. `to`: The path to move to\n\n### Return Values\nThis function does not return anything.\n\n## `basename(path: string): string`\nReturns the file name for a path.\n\n### Arguments\n1. `path`: The path to use\n\n### Return Values\nThe file name of the path\n\n## `dirname(path: string): string`\nReturns the parent directory for a path.\n\n### Arguments\n1. `path`: The path to use\n\n### Return Values\nThe parent directory of the path\n\n## `find(wildcard: string): table`\nSearches the filesystem for paths matching a glob-style wildcard.\n\n### Arguments\n1. `wildcard`: The pathspec to match\n\n### Return Values\nA list of matching file paths\n\n## `exists(path: string): boolean`\nConvenience function for determining whether a file exists.\n This simply checks that @{stat} does not return `nil`.\n\n### Arguments\n1. `path`: The path to check\n\n### Return Values\nWhether the path exists\n\n## `isFile(path: string): boolean`\nReturns whether the path exists and is a file.\n\n### Arguments\n1. `path`: The path to check\n\n### Return Values\nWhether the path is a file\n\n## `isDir(path: string): boolean`\nReturns whether the path exists and is a directory.\n\n### Arguments\n1. `path`: The path to check\n\n### Return Values\nWhether the path is a directory\n\n## `isLink(path: string): boolean`\nReturns whether the path exists and is a link.\n\n### Arguments\n1. `path`: The path to check\n\n### Return Values\nWhether the path is a link\n\n## `effectivePermissions(file: string|FileStat, user: string?): {read:boolean,write:boolean,execute:boolean}|nil`\nReturns the effective permissions on a file or stat entry for the selected user.\n\n### Arguments\n1. `file`: The file path or stat to check\n2. `user`: The user to check for (defaults to the current user) (optional)\n\n### Return Values\nThe permissions for the user, or `nil` if the file doesn't exist\n\n# Class FileStat\nA table which stores file statistics.\n\n## `FileStat.type`\nStores the type of file: one of \"file\", \"directory\", \"link\", \"special\"\n\n### Fields\nThis function does not take any arguments.\n\n## `FileStat.size`\nThe size of the file\n\n### Fields\nThis function does not take any arguments.\n\n## `FileStat.created`\nThe creation date of the file, in milliseconds since January 1, 1970\n\n### Fields\nThis function does not take any arguments.\n\n## `FileStat.modified`\nThe modification date of the file, in milliseconds since January 1, 1970\n\n### Fields\nThis function does not take any arguments.\n\n## `FileStat.owner`\nThe owner of the file\n\n### Fields\nThis function does not take any arguments.\n\n## `FileStat.permissions`\nThe permissions of the file for each user, indexed by user name\n\n### Fields\n- `read`: Whether the file can be read\n- `write`: Whether the file can be written to\n- `execute`: Whether the file can be executed\n\n## `FileStat.worldPermissions`\nThe permissions of the file for all users not in @{FileStat.permissions}\n\n### Fields\n- `read`: Whether the file can be read\n- `write`: Whether the file can be written to\n- `execute`: Whether the file can be executed\n\n## `FileStat.special`\nAny additional data from the filesystem\n\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293505,size=7653},["ftp.md"]={type="file",created=1740881292190,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881292173,size=0},["system.network.md"]={type="file",created=1740881293591,worldPermissions={write=false,read=true,execute=false},data="# system.network\nThe network module implements functions for making and hosting connections\n with local and Internet-connected computers, as well as managing the network\n stack configuration.\n\n## `connect(options: string|table): Handle`\nCreates a new connection to a remote server.\n\n### Arguments\n1. `options`: The URI to connect with, or a table of options\n (see the connect syscall docs for more information)\n\n### Return Values\nA handle to the connection\n\n## `get(options: string|table): Handle / nil, string`\nConnects to an HTTP(S) server, sends a GET request and waits for a response.\n\n### Arguments\n1. `options`: The URL to connect to, or a table of options\n (see the connect syscall docs for more information)\n\n### Return Values\nThis function may return the following values:\n1. The handle to the response data\n\nOr:\n1. If the connection failed\n2. An error describing why the connection failed\n\n## `getData(url: string, headers: table?): string / nil, string`\nConnects to an HTTP(S) server, sends a GET request, waits for a response,\n and returns the data received after closing the connection.\n\n### Arguments\n1. `url`: The URL to connect to\n2. `headers`: Any headers to send in the request (optional)\n\n### Return Values\nThis function may return the following values:\n1. The response data sent from the server\n\nOr:\n1. If the connection failed\n2. An error describing why the connection failed\n\n## `head(options: string|table): Handle / nil, string`\nConnects to an HTTP(S) server, sends a HEAD request and waits for a response.\n\n### Arguments\n1. `options`: The URL to connect to, or a table of options\n (see the connect syscall docs for more information)\n\n### Return Values\nThis function may return the following values:\n1. The handle to the response data\n\nOr:\n1. If the connection failed\n2. An error describing why the connection failed\n\n## `options(options: string|table): Handle / nil, string`\nConnects to an HTTP(S) server, sends an OPTIONS request and waits for a response.\n\n### Arguments\n1. `options`: The URL to connect to, or a table of options\n (see the connect syscall docs for more information)\n\n### Return Values\nThis function may return the following values:\n1. The handle to the response data\n\nOr:\n1. If the connection failed\n2. An error describing why the connection failed\n\n## `post(options: string|table, data: string): Handle / nil, string`\nConnects to an HTTP(S) server, sends a POST request and waits for a response.\n\n### Arguments\n1. `options`: The URL to connect to, or a table of options\n (see the connect syscall docs for more information)\n2. `data`: The data to send to the server\n\n### Return Values\nThis function may return the following values:\n1. The handle to the response data\n\nOr:\n1. If the connection failed\n2. An error describing why the connection failed\n\n## `put(options: string|table, data: string): Handle / nil, string`\nConnects to an HTTP(S) server, sends a PUT request and waits for a response.\n\n### Arguments\n1. `options`: The URL to connect to, or a table of options\n (see the connect syscall docs for more information)\n2. `data`: The data to send to the server\n\n### Return Values\nThis function may return the following values:\n1. The handle to the response data\n\nOr:\n1. If the connection failed\n2. An error describing why the connection failed\n\n## `delete(options: string|table, data: string?): Handle / nil, string`\nConnects to an HTTP(S) server, sends a DELETE request and waits for a response.\n\n### Arguments\n1. `options`: The URL to connect to, or a table of options\n (see the connect syscall docs for more information)\n2. `data`: The data to send to the server, if required (optional)\n\n### Return Values\nThis function may return the following values:\n1. The handle to the response data\n\nOr:\n1. If the connection failed\n2. An error describing why the connection failed\n\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293523,size=3820},["system.framebuffer.md"]={type="file",created=1740881293588,worldPermissions={write=false,read=true,execute=false},data="# system.framebuffer\nThe framebuffer library provides functions to make \"window\" and \"framebuffer\"\n objects.  These objects imitate a Terminal object (as returned by\n @{system.terminal.openterm}) or GFXTerminal object (as returned by\n @{system.terminal.opengfx}) that may or may not draw to a parent object.\n Windows and framebuffers may be used as parents to other windows and\n framebuffers, in addition to the root terminal object.\n\n A framebuffer object holds its own state, can be redrawn onto the parent\n terminal even if the parent is changed, can be removed from the parent and\n used independently, and its contents can be accessed from code. A window\n object simply changes the coordinates of writing methods, and is entirely\n dependent on the parent.\n\n The type of object returned by each function is dependent on the parent\n passed in. If a Terminal object is passed, a Terminal object is created; if a\n GFXTerminal object is passed, a GFXTerminal object is created. When creating\n a framebuffer with no parent, the @{empty} fields are used to specify the type.\n\n\n## `window(parent: Terminal|GFXTerminal, x: number, y: number, width: number, height: number): Terminal|GFXTerminal`\nCreates a new window object.\n\n### Arguments\n1. `parent`: The parent object to render to\n2. `x`: The X coordinate in the parent to start at\n3. `y`: The Y coordinate in the parent to start at\n4. `width`: The width of the window\n5. `height`: The height of the window\n\n### Return Values\nThe new window object\n\n## `framebuffer(parent: Terminal|GFXTerminal, wx: number|nil, wy: number|nil, w: number, h: number, visible: boolean?): Terminal|GFXTerminal`\nCreates a new framebuffer object.\n\n### Arguments\n1. `parent`: The parent object to render to, or a member of <a href=\"framebuffer.html#empty\">empty</a> to not use a parent\n2. `wx`: The X coordinate in the parent to start at (`nil` if there's no parent)\n3. `wy`: The Y coordinate in the parent to start at (`nil` if there's no parent)\n4. `w`: The width of the framebuffer\n5. `h`: The height of the framebuffer\n6. `visible`: Whether the window should be visible upon creation (optional)\n\n### Return Values\nThe new framebuffer object\n\n## `empty`\nEmpty objects for use when creating framebuffers with no parents.\n\n### Fields\n- `text`: Used to create a text mode Terminal framebuffer\n- `graphics`: Used to create a graphics mode GFXTerminal framebuffer\n\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293507,size=2388},["system.process.md"]={type="file",created=1740881293592,worldPermissions={write=false,read=true,execute=false},data="# system.process\nThe process module allows querying various properties about the current\n process, as well as creating, modifying, and searching other processes.\n\n## `getpid(): number`\nReturns the process ID of the current process.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe process ID of the current process\n\n## `getppid(): number`\nReturns the process ID of the parent process, if available.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe process ID of the parent process, if available\n\n## `getuser(): string`\nReturns the username the process is running under.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe username the process is running under\n\n## `setuser(user: string)`\nSets the user of the current process.  This can only be run by root.\n\n### Arguments\n1. `user`: The user to switch to\n\n### Return Values\nThis function does not return anything.\n\n## `clock(): number`\nReturns the amount of time this process has executed.  This may not be\n entirely accurate due to a lack of precision in the system clock.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe amount of time this process has executed\n\n## `getenv(): table`\nReturns the environment table for the current process.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe environment table for the current process\n\n## `getname(): string`\nReturns the name of the current process.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe name of the current process\n\n## `getcwd(): string`\nReturns the working directory of the current process.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe working directory of the current process\n\n## `chdir(dir: string)`\nSets the working directory of the current process.\n\n### Arguments\n1. `dir`: The new working directory, which must be absolute and existent.\n\n### Return Values\nThis function does not return anything.\n\n## `fork(func: function, name: string, ...: any): number`\nCreates a new process running the specified function with arguments.\n\n### Arguments\n1. `func`: The function to run in the new process. This will be the\n main function of the first thread, and will have its environment set to the\n new process's environment.\n2. `name`: ? The name of the new process.\n3. `...`: Any arguments to pass to the function.\n\n### Return Values\nThe PID of the new process.\n\n## `exec(path: string, ...: any)`\nReplaces the current process with the contents of the specified file.\n This function does not return - it can only throw an error.\n\n### Arguments\n1. `path`: The path to the file to execute.\n2. `...`: Any arguments to pass to the file.\n\n### Return Values\nThis function does not return anything.\n\n## `execp(command: string, ...: any)`\nReplaces the current process with the contents of the specified file or\n command, searching the PATH environment variable if necessary.\n This function does not return - it can only throw an error.\n\n### Arguments\n1. `command`: The command or file to execute.\n2. `...`: Any arguments to pass to the file.\n\n### Return Values\nThis function does not return anything.\n\n## `start(path: string, ...: any): number`\nStarts a new process from the specified path.\n\n### Arguments\n1. `path`: The path to the file to execute.\n2. `...`: Any arguments to pass to the file.\n\n### Return Values\nThe PID of the new process.\n\n## `run(path: string, ...: any): true, any / false, string`\nRuns a program from the specified path in a new process, waiting until it completes.\n\n### Arguments\n1. `path`: The command or file to execute\n2. `...`: Any arguments to pass to the file\n\n### Return Values\nThis function may return the following values:\n1. When the process succeeded\n2. The return value from the process\n\nOr:\n1. When the process errored\n2. The error message from the process\n\n## `newthread(func: function, ...: any): number`\nCreates a new thread running the specified function with arguments.\n Threads in the same process share the same environment, event queue, and\n other properties.\n\n### Arguments\n1. `func`: The function to start\n2. `...`: Any arguments to pass to the function\n\n### Return Values\nThe ID of the new thread\n\n## `exit(code: number)`\nEnds the current process immediately, stopping all threads and sending the\n specified return value to the parent.  This function does not return.\n\n### Arguments\n1. `code`: ? The value to return.\n\n### Return Values\nThis function does not return anything.\n\n## `getplist(): table`\nReturns a list of all valid PIDs.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nA list of all valid PIDs\n\n## `getpinfo(pid: number): {id=number,name=string,user=string,parent?=number,dir=string,stdin?=number,stdout?=number,stderr?=number,cputime=number,systime=number,threads={[number]={id=number,name=string,status=string}}}|nil`\nReturns a table with various information about the specified process.\n\n### Arguments\n1. `pid`: The process ID to query.\n\n### Return Values\nThe process information, or nil if the process doesn't exist.\n\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293529,size=5130},["system.util.md"]={type="file",created=1740881293595,worldPermissions={write=false,read=true,execute=false},data="# system.util\nThe util module contains various functions that don't have any specific\n system function, or help improve the usability of the general system.\n\n## `argparse(arguments: {[string]=string|boolean|nil}, ...: string): {[string]=string|number|boolean|nil,string...} / nil, string`\nTakes a list of valid arguments + the arguments to a program, and returns a\n table with the extracted arguments (and values if requested).\n If an argument with all `-`s is passed, processing of arguments stops, and\n all subsequent arguments are added to the list.\n\n### Arguments\n1. `arguments`: A list of arguments that\n the program accepts. Single-character arguments are handled through `-a`, and\n longer arguments are handled through `--argument`. The value of the entry\n specifies how the argument is handled:\n * If the value is a truthy value, this argument requires a parameter.\n * If the value is `\"number\"`, the argument requires a number parameter.\n * If the value is `\"multiple\"`, the argument can be specified multiple times,\n   and will require a parameter. The values returned will be in a table.\n * If the value is `\"multiple number\"`, the argument can be specified multiple\n   times, and will require a number parameter. These are also in a table.\n * If the value is `false`, the argument does not take a parameter.\n * If the value is `nil`, the argument does not exist and will throw an error\n   if passed.\n * If the value starts with `@`, the parameter is an alias and will be stored\n   in that argument instead, following the same rules as that argument as well.\n Special parameters to the parser can be added in a `[\"\"]` table. The following\n parameters are specified:\n * `stopProcessingOnPositionalArgument` [boolean]: Whether to stop processing\n   arguments when a positional argument is passed, e.g. `myprog -s arg -i` will\n   return `args.s = true`, but `args.i = nil`.\n2. `...`: The arguments as passed to the program.\n\n### Return Values\nThis function may return the following values:\n1.  The arguments\n as parsed from the arguments table as key-value entries, plus positional\n arguments as list entries.\n\nOr:\n1. If the arguments passed are invalid.\n2. An error string describing what was invalid, which can be\n printed for the user.\n\n## `timer(time: number): number`\nStarts a timer that will run for the specified number of seconds.\n A timer event will be queued on completion.\n\n### Arguments\n1. `time`: The number of seconds to wait until sending the event\n\n### Return Values\nThe ID of the newly created timer\n\n## `alarm(time: number): number`\nStarts an alarm that will run until the specified time.\n A timer event will be queued on completion.\n\n### Arguments\n1. `time`: The time to send the event at\n\n### Return Values\nThe ID of the newly created alarm\n\n## `cancel(id: number)`\nCancels a timer or alarm.  This prevents the event from triggering.\n\n### Arguments\n1. `id`: The ID of the timer or alarm to cancel\n\n### Return Values\nThis function does not return anything.\n\n## `sleep(time: number)`\nPauses the process for a certain amount of time.\n\n### Arguments\n1. `time`: The amount of time to wait for, in seconds\n\n### Return Values\nThis function does not return anything.\n\n## `pullEvent(): string, table`\nReturns the next event from the event queue.  This is intended to make it more\n clear when events are being pulled, and also has the benefit of supporting\n libsystem-craftos better.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function may return the following values:\n1. The event pulled\n2. The parameters for the event\n\n## `filterEvent(...: string): string, table`\nWaits until an event of the specified type(s) occurs.\n\n### Arguments\n1. `...`: The event names to filter for\n\n### Return Values\nThis function may return the following values:\n1. The event type that was matched\n2. The parameters for the event\n\n## `queueEvent(event: string, param: table)`\nQueues an event to loop back to the process.\n\n### Arguments\n1. `event`: The event name to send\n2. `param`: The parameter table to send with the event\n\n### Return Values\nThis function does not return anything.\n\n## `split(str: string[, sep: string = \"%s\"][, includeEmpty: boolean = false]): {string...}`\nSplits a string into components.\n\n### Arguments\n1. `str`: The string to split\n2. `sep`: The delimiter match class to split by (defaults to \"%s\")\n3. `includeEmpty`: Whether to include empty matches (defaults to false)\n\n### Return Values\nThe components of the string\n\n## `copy(value: any): any`\nCopies a value recursively, including all its keys and values.\n\n### Arguments\n1. `value`: The value to copy\n\n### Return Values\nA copy of the value, with all keys, values, and metatables duplicated.\n\n## `addEventListener(event: string, callback: function(string,table):boolean)`\nAdds an event listener to the listening module.\n\n### Arguments\n1. `event`: The event to listen for\n2. `callback`: The function to call when\n the event is queued. If the function returns a truthy value, processing for\n the current event will stop. If the function throws an error, the loop will\n stop.\n\n### Return Values\nThis function does not return anything.\n\n## `removeEventListener(event: string, callback: function(string,table))`\nRemoves an event listener from the listening module.\n\n### Arguments\n1. `event`: The event to listen for\n2. `callback`: The function to remove\n\n### Return Values\nThis function does not return anything.\n\n## `runEvents(): string`\nRuns the event listening loop on the current thread, blocking forever.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe error that caused the function to stop\n\n## `startEvents(): number`\nRuns the event listening loop on a new thread, allowing code to run after.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe ID of the new thread\n\n## `type(value: any): string`\nReturns the type of the parameter, with the ability to check the __name\n metamethod for custom types.\n\n### Arguments\n1. `value`: The value to check\n\n### Return Values\nThe type of the value\n\n## `crc32(str: string[, polynomial: table|number = 0xEDB88320][, crc: number = 0xFFFFFFFF]): number`\nCalculates the CRC-32 checksum of the specified data.\n\n### Arguments\n1. `str`: The data to checksum\n2. `polynomial`: The polynomial for the CRC, or the lookup table to use (defaults to 0xEDB88320)\n3. `crc`: The initial CRC value (defaults to 0xFFFFFFFF)\n\n### Return Values\nThe calculated CRC checksum\n\n## `syscall`\nutil.syscall wraps all available syscalls into a table of functions, making\n it possible to call syscalls using direct function calls instead of manually\n yielding and managing the return values.\n\n### Fields\nThis function does not take any arguments.\n\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293540,size=6732},["system.serialization.md"]={type="file",created=1740881293593,worldPermissions={write=false,read=true,execute=false},data="# system.serialization\nThe serialization module provides functions for serializing and deserializing\n objects in multiple formats, as well as some miscellaneous encoding types.\n\n# serialization.base64\n\n\n## `serialization.base64.encode(str: string): string`\nEncodes a binary string into Base64.\n\n### Arguments\n1. `str`: The string to encode\n\n### Return Values\nThe string's representation in Base64\n\n## `serialization.base64.decode(str: string): string`\nDecodes a Base64 string to binary.\n\n### Arguments\n1. `str`: The Base64 to decode\n\n### Return Values\nThe decoded data\n\n# serialization.json\n\n\n## `serialization.json.encode(val: any): string`\nSerializes an arbitrary Lua object into a JSON string.\n\n### Arguments\n1. `val`: The value to encode\n\n### Return Values\nThe JSON representation of the object\n\n## `serialization.json.decode(str: string): any`\nParses a JSON string and returns a Lua value represented by the string.\n\n### Arguments\n1. `str`: The JSON string to decode\n\n### Return Values\nThe Lua value from the JSON\n\n## `serialization.json.save(val: any, path: string)`\nSaves a Lua value to a JSON file.\n\n### Arguments\n1. `val`: The value to save\n2. `path`: The path to the file to save\n\n### Return Values\nThis function does not return anything.\n\n## `serialization.json.load(path: string): any`\nLoads a JSON file into a Lua value.\n\n### Arguments\n1. `path`: The path to the file to load\n\n### Return Values\nThe loaded value\n\n# serialization.lua\n\n\n## `serialization.lua.encode(val: any, opts: {minified=boolean,allow_functions=boolean}?): string`\nSerializes an arbitrary Lua object into a serialized Lua string.\n\n### Arguments\n1. `val`: The value to encode\n2. `opts`: Any options to specify while encoding (optional)\n\n### Return Values\nThe serialized Lua representation of the object\n\n## `serialization.lua.decode(str: string, opts: {allow_functions=boolean}?): any`\nParses a serialized Lua string and returns a Lua value represented by the string.\n\n### Arguments\n1. `str`: The serialized Lua string to decode\n2. `opts`: Any options to specify while decoding (optional)\n\n### Return Values\nThe Lua value from the serialized Lua\n\n## `serialization.lua.save(val: any, path: string, opts: {minified=boolean,allow_functions=boolean}?)`\nSaves a Lua value to a serialized Lua file.\n\n### Arguments\n1. `val`: The value to save\n2. `path`: The path to the file to save\n3. `opts`: Any options to specify while encoding (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `serialization.lua.load(path: string, opts: {allow_functions=boolean}?): any`\nLoads a serialized Lua file into a Lua value.\n\n### Arguments\n1. `path`: The path to the file to load\n2. `opts`: Any options to specify while decoding (optional)\n\n### Return Values\nThe loaded value\n\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293531,size=2757},["system.terminal.md"]={type="file",created=1740881293594,worldPermissions={write=false,read=true,execute=false},data="# system.terminal\nThe terminal module defines functions to allow interacting with the terminal\n and screen, as well as handling user input.\n\n## `toEscape(color: number[, background: boolean = false]): string`\nConverts a @{terminal.colors} constant to an ANSI escape code.\n\n### Arguments\n1. `color`: The color to convert\n2. `background`: Whether the escape should set the background (defaults to false)\n\n### Return Values\nThe escape code generated for the color\n\n## `write(...)`\nWrites text to the standard output stream.\n\n### Arguments\n1. `...`: The entries to write. Each one will be separated by tabs (`\\t`).\n\n### Return Values\nThis function does not return anything.\n\n## `writeerr(...)`\nWrites text to the standard error stream.\n\n### Arguments\n1. `...`: The entries to write. Each one will be separated by tabs (`\\t`).\n\n### Return Values\nThis function does not return anything.\n\n## `read(n: number): string|nil`\nReads a number of characters from the standard input stream.\n\n### Arguments\n1. `n`: The number of characters to read\n\n### Return Values\nThe text read, or nil if EOF was reached.\n\n## `readline(): string|nil`\nReads a single line of text from the standard input stream.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe text read, or nil if EOF was reached.\n\n## `termctl(flags: {cbreak?=boolean,delay?=boolean,echo?=boolean,keypad?=boolean,nlcr?=boolean,raw?=boolean}): {cbreak=boolean,delay=boolean,echo=boolean,keypad=boolean,nlcr=boolean,raw=boolean}|nil`\nSets certain terminal control flags on the current TTY if available.\n\n### Arguments\n1. `flags`: ? The flags to set, or nil to just query.\n\n### Return Values\nThe flags that are currently set on the TTY, or nil if no TTY is available.\n\n## `openterm(): Terminal / nil, string`\nOpens the current output TTY in exclusive text mode, allowing direct\n manipulation of the screen buffer.  Only one process may open the terminal at\n a time. Once opened, the screen will be cleared, and stdout will be sent to\n an off-screen buffer to be shown once the terminal is closed. The terminal\n will automatically be closed on process exit.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function may return the following values:\n1. A terminal object for the current TTY.\n\nOr:\n1. If the terminal could not be opened.\n2. An error message describing why the terminal couldn't be opened.\n\n## `opengfx(): GFXTerminal / nil, string`\nOpens the current output TTY in exclusive graphics mode, allowing direct\n manipulation of the pixels if available.  Only one process may open the terminal\n at a time. Once opened, the screen will be cleared, and stdout will be sent to\n an off-screen buffer to be shown once the terminal is closed. The terminal\n will automatically be closed on process exit. This only works on CraftOS-PC.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function may return the following values:\n1. A graphical terminal object for the current TTY.\n\nOr:\n1. If the terminal could not be opened.\n2. An error message describing why the terminal couldn't be opened.\n\n## `mktty(width: number, height: number): TTY`\nCreates a new virtual TTY with the specified size.  This can later be used in\n a call to stdin/stdout/stderr.\n\n### Arguments\n1. `width`: The width of the new TTY.\n2. `height`: The height of the new TTY.\n\n### Return Values\nA new TTY object which is registered with the kernel.\n\n## `stdin(handle: number|TTY|FileHandle|nil)`\nSets the standard input of the current process.\n\n### Arguments\n1. `handle`: The input handle to switch to, as\n either a physical TTY, a virtual TTY, a file, or nil.\n\n### Return Values\nThis function does not return anything.\n\n## `stdout(handle: number|TTY|FileHandle|nil)`\nSets the standard output of the current process.\n\n### Arguments\n1. `handle`: The output handle to switch to, as\n either a physical TTY, a virtual TTY, a file, or nil.\n\n### Return Values\nThis function does not return anything.\n\n## `stderr(handle: number|TTY|FileHandle|nil)`\nSets the standard error of the current process.\n\n### Arguments\n1. `handle`: The output handle to switch to, as\n either a physical TTY, a virtual TTY, a file, or nil.\n\n### Return Values\nThis function does not return anything.\n\n## `istty(): boolean, boolean`\nReturns whether the current stdio are linked to a TTY.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function may return the following values:\n1. Whether the current stdin is linked to a TTY.\n2. Whether the current stdout is linked to a TTY.\n\n## `termsize(): number, number / nil`\nReturns the current size of the TTY if available.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function may return the following values:\n1. The width of the screen.\n2. The height of the screen.\n\nOr:\n1. If the current stdout is not a screen.\n\n## `colors`\nConstants for colors.  This includes both normal and British spelling.\n\n### Fields\n- `white`:\n- `orange`:\n- `magenta`:\n- `lightBlue`:\n- `yellow`:\n- `lime`:\n- `pink`:\n- `gray`:\n- `grey`:\n- `lightGray`:\n- `lightGrey`:\n- `cyan`:\n- `purple`:\n- `blue`:\n- `brown`:\n- `green`:\n- `red`:\n- `black`:\n\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293537,size=5197},["system.ipc.md"]={type="file",created=1740881293590,worldPermissions={write=false,read=true,execute=false},data="# system.ipc\nThe IPC module provides functions for sending messages to other processes.\n\n## `kill(pid: number, signal: number)`\nSends a basic signal to a process.\n\n### Arguments\n1. `pid`: The PID of the process to send to\n2. `signal`: The signal to send to the process\n\n### Return Values\nThis function does not return anything.\n\n## `sigaction(signal: number, fn: function|nil)`\nSets the handler for a signal.\n\n### Arguments\n1. `signal`: The signal to modify\n2. `fn`: The function to call, or `nil` to remove\n\n### Return Values\nThis function does not return anything.\n\n## `sendEvent(pid: number, event: string, param: table): boolean`\nSends a remote event to a process.\n\n### Arguments\n1. `pid`: The PID of the process to send to\n2. `event`: The event name to send\n3. `param`: The parameter table to send with the event\n\n### Return Values\nWhether the event was sent\n\n## `register(name: string): boolean`\nRegisters the current process as the receiver of a service name.\n\n### Arguments\n1. `name`: The service name to register for\n\n### Return Values\nWhether the service was registered\n\n## `lookup(name: string): number|nil`\nReturns the ID of the process that receives a service name.\n\n### Arguments\n1. `name`: The service to lookup\n\n### Return Values\nThe PID of the process that owns it (if available)\n\n## `sendServiceEvent(name: string, event: string, param: table): boolean`\nSends an event to the owner of a service.\n\n### Arguments\n1. `name`: The service to send to\n2. `event`: The event name to send\n3. `param`: The parameter table to send with the event\n\n### Return Values\nWhether the event was sent\n\n## `receiveEvent(pid: number?, event: string?, timeout: number?): string, table / nil`\nWaits for a remote event, filtering for processes or event names, with an optional timeout.\n\n### Arguments\n1. `pid`: The PID to wait for an event from (optional)\n2. `event`: The event to filter for (optional)\n3. `timeout`: The maximum number of seconds to wait for (optional)\n\n### Return Values\nThis function may return the following values:\n1. The event name received\n2. The parameters for the event\n\nOr:\n1. If the function timed out\n\n## `signal`\nConstants for signal numbers\n\n### Fields\n- `SIGHUP`:\n- `SIGINT`:\n- `SIGQUIT`:\n- `SIGTRAP`:\n- `SIGABRT`:\n- `SIGKILL`:\n- `SIGPIPE`:\n- `SIGTERM`:\n- `SIGCONT`:\n- `SIGSTOP`:\n- `SIGTTIN`:\n- `SIGTTOU`:\n\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293515,size=2331},["system.sync.md"]={type="file",created=1740881293593,worldPermissions={write=false,read=true,execute=false},data="# system.sync\nThe sync library exposes interfaces for various synchronization structures.\n\n# Class mutex\nA mutex is an object that controls access to a variable across multiple threads.\n It ensures only one thread accesses a resource at a time by blocking other\n threads from locking the mutex until the current thread unlocks it.\n\n## `sync.mutex.new(recursive: boolean?): mutex`\nCreates a new mutex.\n\n### Arguments\n1. `recursive`: Whether to make the mutex recursive (optional)\n\n### Return Values\nThe new mutex object\n\n## `sync.mutex:lock()`\nLocks the mutex, waiting if it's currently owned by another thread.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.mutex:unlock()`\nUnlocks the mutex.  This is only valid from the thread that owns the lock.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.mutex:tryLock(): boolean`\nTries to lock the thread, returning false if it could not be locked.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nWhether the mutex is now locked\n\n## `sync.mutex:tryLockFor(timeout: number): boolean`\nLocks the mutex, waiting until it's unlocked or until the specified timeout.\n\n### Arguments\n1. `timeout`: The number of seconds to wait\n\n### Return Values\nWhether the mutex is now locked\n\n# Class semaphore\nA semaphore controls access to a limited number of resources.  A function may\n acquire a resource from the semaphore, decrementing its available count. If\n the count is zero, it waits until another function releases a resource, at\n which point it will acquire it and return.\n\n## `sync.semaphore.new([init: number = 1]): semaphore`\nCreates a new semaphore.\n\n### Arguments\n1. `init`: The initial count of the semaphore (defaults to 1)\n\n### Return Values\nThe new semaphore object\n\n## `sync.semaphore:acquire()`\nAcquires a resource from the semaphore, waiting until there is one available.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.semaphore:tryAcquireFor(timeout: number): boolean`\nAcquires a resource from the semaphore, waiting until there is one available or until a timeout.\n\n### Arguments\n1. `timeout`: The number of seconds to wait\n\n### Return Values\nWhether the resource was acquired\n\n## `sync.semaphore:release()`\nReleases a resource to the semaphore.  This can be called from any thread.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n# Class conditionVariable\nA condition variable allows threads to wait until another thread notifies\n them to resume.\n\n## `sync.conditionVariable.new(): conditionVariable`\nCreates a new condition variable.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe new condition variable.\n\n## `sync.conditionVariable:wait()`\nWaits for a notification from another thread.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.conditionVariable:waitFor(timeout: number): boolean`\nWaits for a notification from another thread, or until a timeout occurs.\n\n### Arguments\n1. `timeout`: The number of seconds to wait\n\n### Return Values\nWhether a notification occurred\n\n## `sync.conditionVariable:notifyOne()`\nNotifies a single (unspecified) thread to continue.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.conditionVariable:notifyAll()`\nNotifies all waiting threads to continue.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n# Class barrier\nA barrier is a lock that waits for a specific number of threads to wait on\n the object, at which point all threads will be released together.\n\n## `sync.barrier.new(count: number): barrier`\nCreates a new barrier object.\n\n### Arguments\n1. `count`: The number of threads to wait for\n\n### Return Values\nA new barrier object\n\n## `sync.barrier:wait(): boolean`\nAdds one to the thread wait count, and waits until it meets the limit.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nWhether this call directly resulted in the barrier being met\n\n# Class rwlock\nA readers-writer lock implements two related locks: a read lock, which can\n be held by multiple threads, and a write lock, which can only be held by one\n thread.  Multiple threads can hold a read lock, but a write lock blocks both\n read and write locks.\n\n## `sync.rwLock.new(): rwlock`\nCreates a new RW lock.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe new RW lock\n\n## `sync.rwLock:lockRead()`\nAcquires the lock for reading, waiting for the write lock to be released first.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.rwLock:unlockRead()`\nReleases the lock for reading.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.rwLock:lockWrite()`\nAcquires the lock for writing, waiting for the read and write locks to be released.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.rwLock:unlockWrite()`\nReleases the lock for writing.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `rwlock:lockGuard(mutex: mutex, fn: function, ...: any): any...`\nCalls a function, ensuring that the mutex is locked before calling and unlocked\n after calling, even if the function returns early or throws an error.\n\n### Arguments\n1. `mutex`: The mutex to lock\n2. `fn`: The function to call\n3. `...`: Any parameters to pass\n\n### Return Values\nThe return values from the function\n\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293535,size=5981},["system.expect.md"]={type="file",created=1740881293587,worldPermissions={write=false,read=true,execute=false},data="# system.expect\nThe expect module provides error checking functions for other libraries.\n\n## `expect(index: number, value: any, ...: string): any`\nCheck that a numbered argument matches the expected type(s).  If the type\n doesn't match, throw an error.\n This function supports custom types by checking the __name metaproperty.\n\n### Arguments\n1. `index`: The index of the argument to check\n2. `value`: The value to check\n3. `...`: The types to check for\n\n### Return Values\n`value`\n\n## `field(tbl: any, key: any, ...: string): any`\nCheck that a key in a table matches the expected type(s).  If the type\n doesn't match, throw an error.\n This function supports custom types by checking the __name metaproperty.\n\n### Arguments\n1. `tbl`: The table (or other indexable value) to search through\n2. `key`: The key of the table to check\n3. `...`: The types to check for\n\n### Return Values\nThe indexed value in the table\n\n## `range(num: number[, min: number = -math.huge][, max: number = math.huge]): number`\nCheck that a number is between the specified minimum and maximum values.  If\n the number is out of bounds, throw an error.\n\n### Arguments\n1. `num`: The number to check\n2. `min`: The minimum value of the number (inclusive) (defaults to -math.huge)\n3. `max`: The maximum value of the number (inclusive) (defaults to math.huge)\n\n### Return Values\n`num`\n\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293501,size=1349},["system.graphics.md"]={type="file",created=1740881293588,worldPermissions={write=false,read=true,execute=false},data="# system.graphics\nThe graphics module provides functions to draw primitive geometry on a locked\n terminal object.  It supports both text and graphics mode terminals.\n The state of text terminals is preserved, so using these functions doesn't\n change the cursor position or colors.\n\n\n## `drawPixel(term: Terminal|GFXTerminal, x: number, y: number, color: number)`\nDraws a single pixel on screen.\n\n### Arguments\n1. `term`: The terminal to draw on\n2. `x`: The X coordinate to draw at\n3. `y`: The Y coordinate to draw at\n4. `color`: The color to draw with\n\n### Return Values\nThis function does not return anything.\n\n## `drawLine(term: Terminal|GFXTerminal, x1: number, y1: number, x2: number, y2: number, color: number)`\nDraws a line between two points.\n\n### Arguments\n1. `term`: The terminal to draw on\n2. `x1`: The start X coordinate to draw at\n3. `y1`: The start Y coordinate to draw at\n4. `x2`: The end X coordinate to draw at\n5. `y2`: The end Y coordinate to draw at\n6. `color`: The color to draw with\n\n### Return Values\nThis function does not return anything.\n\n## `drawBox(term: Terminal|GFXTerminal, x: number, y: number, width: number, height: number, color: number)`\nDraws an outlined rectangle on screen.\n\n### Arguments\n1. `term`: The terminal to draw on\n2. `x`: The upper-left X coordinate to draw at\n3. `y`: The upper-left Y coordinate to draw at\n4. `width`: The width of the rectangle\n5. `height`: The height of the rectangle\n6. `color`: The color to draw with\n\n### Return Values\nThis function does not return anything.\n\n## `drawFilledBox(term: Terminal|GFXTerminal, x: number, y: number, width: number, height: number, color: number)`\nDraws a filled rectangle on screen.\n\n### Arguments\n1. `term`: The terminal to draw on\n2. `x`: The upper-left X coordinate to draw at\n3. `y`: The upper-left Y coordinate to draw at\n4. `width`: The width of the rectangle\n5. `height`: The height of the rectangle\n6. `color`: The color to draw with\n\n### Return Values\nThis function does not return anything.\n\n## `drawCircle(term: Terminal|GFXTerminal, x: number, y: number, width: number, height: number, color: number[, startAngle: number = 0][, arcCircumference: number = 2*math.pi])`\nDraws an outlined circle (or arc) on screen.\n\n### Arguments\n1. `term`: The terminal to draw on\n2. `x`: The upper-left X coordinate to draw at\n3. `y`: The upper-left Y coordinate to draw at\n4. `width`: The width of the circle\n5. `height`: The height of the circle\n6. `color`: The color to draw with\n7. `startAngle`: The angle to start from in radians (starting at the right side) (defaults to 0)\n8. `arcCircumference`: The amount of the arc to draw in radians (defaults to 2*math.pi)\n\n### Return Values\nThis function does not return anything.\n\n## `drawFilledTriangle(term: Terminal|GFXTerminal, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, color: number)`\nDraws a filled triangle on screen.\n\n### Arguments\n1. `term`: The terminal to draw on\n2. `x1`: The first X coordinate to draw at\n3. `y1`: The first Y coordinate to draw at\n4. `x2`: The second X coordinate to draw at\n5. `y2`: The second Y coordinate to draw at\n6. `x3`: The third X coordinate to draw at\n7. `y3`: The third Y coordinate to draw at\n8. `color`: The color to draw with\n\n### Return Values\nThis function does not return anything.\n\n## `drawImage(term: Terminal|GFXTerminal, x: number, y: number, image: table)`\nDraws an image on screen.  The image may be either a valid graphics mode\n pixel region (using either string or table rows), or a blit table with\n {text, text color, background color} table rows (text mode only).\n\n### Arguments\n1. `term`: The terminal to draw on\n2. `x`: The X coordinate to draw at\n3. `y`: The Y coordinate to draw at\n4. `image`: The image to draw\n\n### Return Values\nThis function does not return anything.\n\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293510,size=3803}},permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294450,size=0},man2={type="directory",created=1740881293586,worldPermissions={execute=true,read=true,write=false},contents={["mkfifo.md"]={type="file",created=1740881293572,worldPermissions={write=false,read=true,execute=false},data="<summary>creates a new FIFO pipe file</summary>\n# NAME\nmkfifo - creates a new FIFO pipe file\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**mkfifo**(*path*: string)\n\n# DESCRIPTION\nCreates a new FIFO (first in first out) pipe file at a path, creating any parent directories if they don't exist.\n\n# PARAMETERS\n1. `path`: The path to the FIFO to create.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user does not have permission to write the parent directory of the first directory created.\n* The path already exists.\n\n# HISTORY\nIntroduced in Phoenix 0.0.3.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293429,size=681},["ipconfig.md"]={type="file",created=1740881293565,worldPermissions={write=false,read=true,execute=false},data="<summary>queries or modifies the current PIP config</summary>\n# NAME\nipconfig - queries or modifies the current PIP config\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**ipconfig**(*device*: string, *info*: table?): table?\n\n# DESCRIPTION\nReturns a table with information about the current PIP configuration for the specified modem, and optionally sets new options (requires root).\n\nIf no configuration is present, then both the IP and netmask must be specified if `info` is set.\n\n# PARAMETERS\n1. `device`: The path to the modem to operate on\n2. `info`: If provided, a table of configuration options to set on the device, in the same format as the returned table\n\n# RETURN VALUE\nA table of PIP configuration entries. These are the currently used members:\n* `ip: string`: The IP address of the modem. No IP is indicated with an empty string. (When setting, this may also be a 32-bit number representing the IP in big-endian format.)\n* `netmask: number`: The subnet mask expressed as a number of bits, as in CIDR notation. No subnet mask is indicated with a value of `0`. (When setting, this may also be an IP-formatted address string.)\n* `up: boolean`: Whether the link is currently up. If a link is down, no Phoenix networking protocols will be serviced on this device. (This allows user applications to manually manage the protocols instead, if required.)\n\nIf the device does not have any IP configuration, returns `nil`.\n\n# ERRORS\nThis syscall may throw an error if:\n* The device is not present.\n* The device is not a valid modem.\n* A non-root user attempted to set configurations.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293400,size=1673},["detach.md"]={type="file",created=1740881293558,worldPermissions={write=false,read=true,execute=false},data="<summary>detaches a peripheral from a side</summary>\n# NAME\ndetach - detaches a peripheral from a side\n\n# SYNOPSIS\n**detach**(*side*: string|number): boolean, string?\n\n# DESCRIPTION\nIf using an emulator, detaches a peripheral from a side. This syscall requires root.\n\n# PARAMETERS\n1. `side`: The side or ID to detach\n\n# RETURN VALUE\n1. Whether the detachment succeeded\n2. If it failed, an optional error message (this may be `nil`!)\n\n# ERRORS\nThis syscall may throw an error if:\n* The user is not root.\n\n# HISTORY\nIntroduced in Phoenix 0.0.2.\n\n# SEE ALSO\n**attach**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293368,size=569},["_template.md"]={type="file",created=1740881293550,worldPermissions={write=false,read=true,execute=false},data="<summary></summary>\n# NAME\n - \n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n\n\n# DESCRIPTION\n\n\n# PARAMETERS\n\n\n# RETURN VALUE\n\n\n# ERRORS\n\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293329,size=239},["listmodules.md"]={type="file",created=1740881293569,worldPermissions={write=false,read=true,execute=false},data="<summary>returns a list of currently loaded kernel module names</summary>\n# NAME\nlistmodules - returns a list of currently loaded kernel module names\n\n# SYNOPSIS\n**listmodules**(): string[]\n\n# DESCRIPTION\nReturns a list of currently loaded kernel module names.\n\n# PARAMETERS\nThis syscall does not take any arguments.\n\n# RETURN VALUE\nA list of currently loaded kernel module names.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293416,size=471},["netcontrol.md"]={type="file",created=1740881293574,worldPermissions={write=false,read=true,execute=false},data="<summary>sends a control message to the specified IP address</summary>\n# NAME\nnetcontrol - sends a control message to the specified IP address\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**netcontrol**(*ip*: string, *type*: string, *err*: string?)\n\n# DESCRIPTION\nSends a control message to the specified IP address.\n\n# PARAMETERS\n1. `ip`: The IP address to send to\n2. `type`: The message type to send. See **network**(5) for more information.\n3. `err`: An optional error message to send if necessary.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user is not root.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293437,size=725},["unmount.md"]={type="file",created=1740881293585,worldPermissions={write=false,read=true,execute=false},data="<summary>unmounts the mount at the specified path</summary>\n# NAME\nunmount - unmounts the mount at the specified path\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**unmount**(*path*: string)\n\n# DESCRIPTION\nUnmounts the mount at the specified path.\n\n# PARAMETERS\n1. `path`: The path to the mount.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The path does not exist.\n* The path specified is not a mount.\n* The user does not have permission to write to the path.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**mount**(2), **mountlist**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293491,size=658},["version.md"]={type="file",created=1740881293586,worldPermissions={write=false,read=true,execute=false},data="<summary>returns the Phoenix version or build number</summary>\n# NAME\nversion - returns the Phoenix version or build number\n\n# SYNOPSIS\n**version**(*buildnum*: boolean?): string\n\n# DESCRIPTION\nReturns the Phoenix version or build number.\n\n# PARAMETERS\n1. `buildnum`: `true` to return the minor build string/information, `false` to return the version number\n\n# RETURN VALUE\nThe version number of the current Phoenix kernel.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**cchost**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293497,size=539},["kill.md"]={type="file",created=1740881293566,worldPermissions={write=false,read=true,execute=false},data="<summary>sends a signal to another process</summary>\n# NAME\nkill - sends a signal to another process\n\n# LIBRARY\nStandard system library, IPC module (*libsystem*, `system.ipc`)\n\n# SYNOPSIS\n**kill**(*pid*: number, *signal*: number)\n\n# DESCRIPTION\nSends a signal to another process. The signal may be any numerical value, though the system will only respond to certain values.\n\n# PARAMETERS\n1. `pid`: The ID of the process to send to\n2. `signal`: The signal ID to send\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The target process ID does not exist.\n* The current user does not have permission to send a signal to the target.\n  * The target process must be under the same user as the current one.\n  * If the current process is running as root, it may send a signal to any process.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**signal**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293406,size=904},["uptime.md"]={type="file",created=1740881293586,worldPermissions={write=false,read=true,execute=false},data="<summary>returns the amount of time the computer has been running</summary>\n# NAME\nuptime - returns the amount of time the computer has been running\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**uptime**(): number\n\n# DESCRIPTION\nReturns the amount of time the computer has been running.\n\n# PARAMETERS\nThis syscall does not take any arguments.\n\n# RETURN VALUE\nThe amount of time the computer has been running in seconds.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293494,size=563},["unlockmutex.md"]={type="file",created=1740881293585,worldPermissions={write=false,read=true,execute=false},data="<summary>unlocks the specified mutex</summary>\n# NAME\nunlockmutex - unlocks the specified mutex\n\n# LIBRARY\nStandard system library, synchronization module (*libsystem*, `system.sync`)\n\n# SYNOPSIS\n**unlockmutex**(*mtx*: mutex)\n\n# DESCRIPTION\nUnlocks the specified mutex.\n\n# PARAMETERS\n1. `mtx`: The mutex to unlock.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The mutex is already unlocked.\n* The mutex is currently locked by a different thread.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**lockmutex**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293489,size=573},["trylockmutex.md"]={type="file",created=1740881293583,worldPermissions={write=false,read=true,execute=false},data="<summary>attempts to lock the mutex</summary>\n# NAME\ntrylockmutex - attempts to lock the mutex\n\n# LIBRARY\nStandard system library, synchronization module (*libsystem*, `system.sync`)\n\n# SYNOPSIS\n**trylockmutex**(*mtx*: mutex): boolean\n\n# DESCRIPTION\nAttempts to lock the mutex, returning immediately if the mutex could not be locked.\n\n# PARAMETERS\n1. `mtx`: The mutex to lock.\n\n# RETURN VALUE\nWhether the mutex could be locked.\n\n# ERRORS\nThis syscall may throw an error if:\n* The mutex is already claimed by the current thread and is not recursive.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**lockmutex**(2), **unlockmutex**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293480,size=638},["cancel.md"]={type="file",created=1740881293554,worldPermissions={write=false,read=true,execute=false},data="<summary>cancels a previously set timer or alarm</summary>\n# NAME\ncancel - cancels a previously set timer or alarm\n\n# LIBRARY\nStandard system library, utility module (*libsystem*, `system.util`)\n\n# SYNOPSIS\n**cancel**(*tm*: number)\n\n# DESCRIPTION\nCancels a previously set timer or alarm.\n\n# PARAMETERS\n1. `tm`: The ID of the timer or alarm to cancel.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**alarm**(2), **timer**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293347,size=531},["devlookup.md"]={type="file",created=1740881293563,worldPermissions={write=false,read=true,execute=false},data="<summary>returns all paths to devices that have the specified node name</summary>\n# NAME\ndevlookup - returns all paths to devices that have the specified node name\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devlookup**(*name*: string): string...\n\n# DESCRIPTION\nReturns all paths to devices that have the specified node name. If a path or UUID is specified, returns the path of the singular device node.\n\n# PARAMETERS\n1. `name`: The device name to search for\n\n# RETURN VALUE\nThe path to each node in the device tree that has the specified name.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**devfind**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293389,size=717},["unloadmodule.md"]={type="file",created=1740881293584,worldPermissions={write=false,read=true,execute=false},data="<summary>unloads a kernel module from memory</summary>\n# NAME\nunloadmodule - unloads a kernel module from memory\n\n# SYNOPSIS\n**unloadmodule**(*path*: string)\n\n# DESCRIPTION\nUnloads a kernel module from memory. This syscall requires root.\n\n# PARAMETERS\n1. `name`: The name of the module to unload\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The user is not root.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**loadmodule**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293486,size=491},["timer.md"]={type="file",created=1740881293582,worldPermissions={write=false,read=true,execute=false},data="<summary>sets a timer</summary>\n# NAME\ntimer - sets a timer\n\n# LIBRARY\nStandard system library, utility module (*libsystem*, `system.util`)\n\n# SYNOPSIS\n**timer**(*timeout*: number): number\n\n# DESCRIPTION\nSets a timer that will send a `timer` event after the specified number of seconds.\n\n# PARAMETERS\n1. `timeout`: The amount of time to set the timer for.\n\n# RETURN VALUE\nThe ID of the new timer created.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**alarm**(2), **cancel**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293478,size=531},["timelockmutex.md"]={type="file",created=1740881293582,worldPermissions={write=false,read=true,execute=false},data="<summary>locks the specified mutex, waiting until the mutex is unlocked or timeout</summary>\n# NAME\ntimelockmutex - locks the specified mutex, waiting until the mutex is unlocked or timeout\n\n# LIBRARY\nStandard system library, synchronization module (*libsystem*, `system.sync`)\n\n# SYNOPSIS\n**timelockmutex**(*mtx*: mutex, *timeout*: number): boolean\n\n# DESCRIPTION\nLocks the specified mutex, waiting for the resource to be freed before claiming it. If the mutex isn't unlocked after the specified timeout, the syscall returns without locking.\n\n# PARAMETERS\n1. `mtx`: The mutex to lock.\n2. `timeout`: The amount of time to wait in seconds.\n\n# RETURN VALUE\nWhether the mutex could be locked.\n\n# ERRORS\nThis syscall may throw an error if:\n* The mutex is already claimed by the current thread and is not recursive.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**lockmutex**(2), **unlockmutex**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293475,size=900},["timeacquiresemaphore.md"]={type="file",created=1740881293581,worldPermissions={write=false,read=true,execute=false},data="<summary>acquires a resource from a semaphore object, waiting until available or timeout</summary>\n# NAME\ntimeacquiresemaphore - acquires a resource from a semaphore object, waiting until available or timeout\n\n# LIBRARY\nStandard system library, synchronization module (*libsystem*, `system.sync`)\n\n# SYNOPSIS\n**timeacquiresemaphore**(*sem*: semaphore, *timeout*: number): boolean\n\n# DESCRIPTION\nAcquires a resource from a semaphore object, waiting if none are available, until the specified timeout passes.\n\n# PARAMETERS\n1. `sem`: The semaphore to acquire.\n2. `timeout`: The amount of time to wait in seconds.\n\n# RETURN VALUE\nWhether a resource was successfully acquired.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**acquiresemaphore**(2), **releasesemaphore**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293472,size=823},["rename.md"]={type="file",created=1740881293577,worldPermissions={write=false,read=true,execute=false},data="<summary>renames a file or directory from one path to another</summary>\n# NAME\nrename - renames a file or directory from one path to another\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**rename**(*from*: string, *to*: string)\n\n# DESCRIPTION\nRenames (moves) a file or directory from one path to another. The source and destination must be on the same filesystem.\n\n# PARAMETERS\n1. `from`: The file to move.\n2. `to`: The new destination path for the file.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The original file does not exist.\n* The new file already exists.\n* The current user does not have permission to read the original file.\n* The current user does not have permission to write the new file.\n* The current user does not have permission to write the parent directory of the new file.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293453,size=947},["signal.md"]={type="file",created=1740881293580,worldPermissions={write=false,read=true,execute=false},data="<summary>registers a handler function to be called for a signal</summary>\n# NAME\nsignal - registers a handler function to be called for a signal\n\n# LIBRARY\nStandard system library, IPC module (*libsystem*, `system.ipc`)\n\n# SYNOPSIS\n**signal**(*signal*: number, *handler*: function(signal: number))\n\n# DESCRIPTION\nRegisters a handler function to be called for a signal.\n\n# PARAMETERS\n1. `signal`: The signal ID to register for.\n2. `handler`: The handler function to call, which takes the signal ID as its only argument.\n\n# RETURN VALUES\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**kill**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293467,size=685},["kernargs.md"]={type="file",created=1740881293566,worldPermissions={write=false,read=true,execute=false},data="<summary>returns the arguments passed to the kernel</summary>\n# NAME\nkernargs - Returns the arguments passed to the kernel\n\n# SYNOPSIS\n**kernargs**(): table\n\n# DESCRIPTION\nReturns the arguments passed to the kernel in a key-value table.\n\n# PARAMETERS\nThis syscall does not take any arguments.\n\n# RETURN VALUE\nA key-value table of all arguments passed to the kernel.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.4.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293403,size=456},["remove.md"]={type="file",created=1740881293577,worldPermissions={write=false,read=true,execute=false},data="<summary>deletes a file at a path</summary>\n# NAME\nremove - deletes a file at a path\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**remove**(*path*: string)\n\n# DESCRIPTION\nDeletes a file at a path. If the file is a directory, this also removes all files and directories contained within it. If the file does not exist, this does nothing and returns successfully.\n\n# PARAMETERS\n1. `path`: The path to the file to delete.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user does not have permission to write the file.\n* The current user does not have permission to write child subfiles and subdirectories.\n* The current user does not have permission to write the parent directory.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293451,size=843},["sendEvent.md"]={type="file",created=1740881293580,worldPermissions={write=false,read=true,execute=false},data="<summary>queues a remote event to be sent to another process</summary>\n# NAME\nsendEvent - queues a remote event to be sent to another process\n\n# LIBRARY\nStandard system library, IPC module (*libsystem*, `system.ipc`)\n\n# SYNOPSIS\n**sendEvent**(*pid*: number, *name*: string, *params*: any)\n\n# DESCRIPTION\nQueues a remote event to be sent to another process. This creates an event called `remote_event` with the name and parameters passed as parameters. It does *not* allow sending arbitrary events to a process.\n\n# PARAMETERS\n1. `pid`: The ID of the process to send to.\n2. `name`: The name of the remote event to send.\n3. `params`: The data to send with the event.\n\n# RETURN VALUES\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293464,size=806},["devfind.md"]={type="file",created=1740881293561,worldPermissions={write=false,read=true,execute=false},data="<summary>finds devices with a specific type</summary>\n# NAME\ndevfind - finds devices with a specific type\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devfind**(*type*: string): string...\n\n# DESCRIPTION\nReturns all paths to devices that have the specified type implemented.\n\n# PARAMETERS\n1. `name`: The device type to search for\n\n# RETURN VALUE\nThe path to each node in the device tree that has the specified type.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**devlookup**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293379,size=588},["checkuri.md"]={type="file",created=1740881293555,worldPermissions={write=false,read=true,execute=false},data="<summary>returns whether the specified URI is valid</summary>\n# NAME\ncheckuri - returns whether the specified URI is valid\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**checkuri**(*uri*: string): boolean\n\n# DESCRIPTION\nReturns whether the specified URI is valid and the scheme is supported.\n\n# PARAMETERS\n1. `uri`: The URI to check\n\n# RETURN VALUE\nWhether the URI is valid. This will always return `false` for an unsupported URI scheme. For HTTP and WebSocket URLs, this will check that the URL can be connected to as well.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293352,size=665},["routelist.md"]={type="file",created=1740881293579,worldPermissions={write=false,read=true,execute=false},data="<summary>returns a list of route entries in the specified route table</summary>\n# NAME\nroutelist - returns a list of route entries in the specified route table\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**routelist**(*num*: number?): table?\n\n# DESCRIPTION\nReturns a list of route entries in the specified route table.\n\n# PARAMETERS\n1. `num`: The table number to check as an integer starting at 0 (default 1)\n\n# RETURN VALUE\nA list of route entries with the following fields:\n* `source: string`: The bottom end of the source IP range.\n* `sourceNetmask: number`: The source subnet mask. For a single IP, this is 32. For all IPs (`default`), this is 0.\n* `action: string`: The action to take on the message. Valid values:\n  * `\"unicast\"`: Send all messages to the specified destination.\n  * `\"broadcast\"`: Broadcast the message to all destinations on the device.\n  * `\"local\"`: Send the message to a known destination on a local network.\n  * `\"unreachable\"`: Send a Destination Unreachable message back to the sender.\n  * `\"prohibit\"`: Send a Prohibit message back to the sender.\n  * `\"blackhole\"`: Ignore the message altogether.\n* `device: string?`: The device path to send the message to.\n* `destination: string?`: The destination IP to forward to.\n\nIf the specified table does not exist, this will return `nil`.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**routeadd**(2), **routedel**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293462,size=1499},["routeadd.md"]={type="file",created=1740881293578,worldPermissions={write=false,read=true,execute=false},data="<summary>adds a new route to the specified route table</summary>\n# NAME\nrouteadd - adds a new route to the specified route table\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**routeadd**(*options*: table)\n\n# DESCRIPTION\nAdds a new route to the specified route table. If the table does not exist, it will be created.\n\n# PARAMETERS\n1. `options`: A table with options for the route entry, with the following fields:\n  * `source: string`: The bottom end of the source IP range.\n  * `sourceNetmask: number`: The source subnet mask. For a single IP, this is 32. For all IPs (`default`), this is 0.\n  * `action: string`: The action to take on the message. Valid values:\n    * `\"unicast\"`: Send all messages to the specified destination.\n    * `\"broadcast\"`: Broadcast the message to all destinations on the device.\n    * `\"local\"`: Send the message to a known destination on a local network.\n    * `\"unreachable\"`: Send a Destination Unreachable message back to the sender.\n    * `\"prohibit\"`: Send a Prohibit message back to the sender.\n    * `\"blackhole\"`: Ignore the message altogether.\n  * `device: string?`: The device path to send the message to.\n  * `destination: string?`: The destination IP to forward to.\n  * `table: number?`: A number specifying the table index to insert into (integer starting at 1; defaults to 1).\n\nThe actions `\"local\"`, `\"unicast\"` and `\"broadcast\"` require `device`; `\"unicast\"` also requires `destination`.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* A non-root user attempted to add routes.\n* A route already exists with the same IP and netmask.\n* The device (if specified) is not present.\n* The device (if specified) is not a valid modem.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**routedel**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293456,size=1845},["routedel.md"]={type="file",created=1740881293579,worldPermissions={write=false,read=true,execute=false},data="<summary>removes the specified route from the specified table</summary>\n# NAME\nroutedel - removes the specified route from the specified table\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**routedel**(*source*: string, *mask*: number, *num*: number?)\n\n# DESCRIPTION\nRemoves the specified route from the specified table.\n\n# PARAMETERS\n1. `source`: The source IP address to remove in CIDR notation (e.g. `192.168.0.0/16`)\n2. `mask`: The netmask prefix length of the IP to remove\n3. `num`: The table number to modify as an integer starting at 1 (default 1)\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* A non-root user attempted to remove routes.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**routeadd**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293459,size=819},["stat.md"]={type="file",created=1740881293581,worldPermissions={write=false,read=true,execute=false},data="<summary>returns a table with information about a file or directory</summary>\n# NAME\nstat - returns a table with information about a file or directory\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**stat**(*path*: string): StatInfo | **nil**, string\n\n# DESCRIPTION\nReturns a table with information about a file or directory. If the file does not exist, this returns `nil` and an error message.\n\n# PARAMETERS\n1. `path`: The path to the file or directory to inspect.\n\n# RETURN VALUE\nA table with the following contents:\n* `size: number`: The total size of the file in bytes\n* `type: string`: The type of file, which can be `\"file\"`, `\"directory\"`, `\"link\"`, `\"fifo\"`, or `\"special\"`\n* `created: number`: The time the file was created, in milliseconds since the UNIX epoch\n* `modified: number`: The time the file was last modified, in milliseconds since the UNIX epoch\n* `owner: string`: The owner of the file\n* `mountpoint: string`: The path to the mountpoint the file is on\n* `link: string?`: If the file is a link, the path it links to\n* `capacity: number`: The total number of bytes the mount can store\n* `freeSpace: number`: The total number of bytes available on the mount\n* `permissions: table`: The permissions for each user/group\n  * `<string>: table`: The permissions for each user/group who has manual permissions\n    * `read: boolean`: Whether the user can read the file\n    * `write: boolean`: Whether the user can write to the file\n    * `execute: boolean`: Whether the user can execute the file\n* `worldPermissions: table`: The permissions for all other users\n  * `read: boolean`: Whether everyone else can read the file\n  * `write: boolean`: Whether everyone else can write to the file\n  * `execute: boolean`: Whether everyone else can execute the file\n* `setuser: boolean`: Whether executing the file will set the user to the owner\n* `special: table?`: A table that can contain mount-specific data.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293469,size=2054},["callmodule.md"]={type="file",created=1740881293553,worldPermissions={write=false,read=true,execute=false},data="<summary>calls a function on a kernel module</summary>\n# NAME\ncallmodule - calls a function on a kernel module\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**callmodule**(*name*: string, *func*: string, *args...*: any): any...\n\n# DESCRIPTION\nCalls a function on a kernel module, if the module exposes an API.\n\n# PARAMETERS\n1. `name`: The name of the module to call on\n2. `func`: The name of the function to call\n3. `args...`: Any arguments to pass to the function\n\n# RETURN VALUE\nAny values returned from the function call.\n\n# ERRORS\nThis syscall may throw an error if:\n* The module requested is not loaded.\n* The module does not have an exported API.\n* The module does not have the requested function.\n* The function throws an error.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293345,size=827},["devunlock.md"]={type="file",created=1740881293565,worldPermissions={write=false,read=true,execute=false},data="<summary>unlocks the specified device</summary>\n# NAME\ndevunlock - unlocks the specified device\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devunlock**(*device*: string)\n\n# DESCRIPTION\nUnlocks the specified device, allowing access to the device in other processes. This syscall does nothing if the device is not locked.\n\n# PARAMETERS\n1. `device`: The device path or UUID to operate on\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n* Another process has locked this device.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**devlock**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293397,size=689},["open.md"]={type="file",created=1740881293575,worldPermissions={write=false,read=true,execute=false},data="<summary>opens a file for reading or writing</summary>\n# NAME\nopen - opens a file for reading or writing\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**open**(*path*: string, *mode*: string): file\n\n# DESCRIPTION\nOpens a file for reading or writing.\n\n# PARAMETERS\n1. `path`: The path to the file to open. This may be a relative path to the current working directory, or an absolute path relative to the root.\n2. `mode`: The mode to open the file in. This may be `r`, `w`, or `a`, with an additional `b` at the end to open in binary mode.\n\n# RETURN VALUE\nA file handle object.\n\n# ERRORS\nThis syscall may throw an error if:\n* The mode argument is invalid.\n* The file was opened in read mode and it does not exist.\n* The parent directory of the file does not exist.\n* The file is a directory.\n* The current user does not have permission to access the file.\n* If creating a new file and the current user does not have permission to write the parent directory.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293443,size=1051},["queueEvent.md"]={type="file",created=1740881293576,worldPermissions={write=false,read=true,execute=false},data="<summary>queues an arbitrary event to be sent back to the current process</summary>\n# NAME\nqueueEvent - queues an arbitrary event to be sent back to the current process\n\n# LIBRARY\nStandard system library, IPC module (*libsystem*, `system.ipc`)\n\n# SYNOPSIS\n**queueEvent**(*name*: string, *params*: table)\n\n# DESCRIPTION\nQueues an arbitrary event to be sent back to the current process.\n\n# PARAMETERS\n1. `name`: The name of the event to send.\n2. `params`: The parameter list to send in the event.\n\n# RETURN VALUES\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293445,size=637},["releasesemaphore.md"]={type="file",created=1740881293576,worldPermissions={write=false,read=true,execute=false},data="<summary>releases a resource from a semaphore</summary>\n# NAME\nreleasesemaphore - releases a resource from a semaphore\n\n# LIBRARY\nStandard system library, synchronization module (*libsystem*, `system.sync`)\n\n# SYNOPSIS\n**releasesemaphore**(*sem*: semaphore)\n\n# DESCRIPTION\nReleases a resource from a semaphore. This is a guaranteed atomic alternative to `sem.count = sem.count + 1`, and should be preferred.\n\n# PARAMETERS\n1. `sem`: The semaphore to release.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**acquiresemaphore**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293448,size=639},["netevent.md"]={type="file",created=1740881293574,worldPermissions={write=false,read=true,execute=false},data="<summary>returns or toggles the current state of network event reporting</summary>\n# NAME\nnetevent - returns or toggles the current state of network event reporting\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**netevent**(*state*: boolean?): boolean\n\n# DESCRIPTION\nReturns the current state of network event reporting in the current process, and toggles it if desired. This allows listening to events such as control messages, PSP messages, send failures, etc.\n\n# PARAMETERS\n1. `state`: If specified, whether to send general network events to the current process\n\n# RETURN VALUE\nThe current state of network event reporting.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user is not root.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293440,size=794},["chroot.md"]={type="file",created=1740881293557,worldPermissions={write=false,read=true,execute=false},data="<summary>changes the root directory</summary>\n# NAME\nchroot - changes the root directory\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**chroot**(*path*: string)\n\n# DESCRIPTION\nChanges the root directory of the current and future child processes. This syscall requires root.\n\n# PARAMETERS\n1. `path`: The path to the new root directory.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user is not root.\n* The new root directory does not exist.\n\n# HISTORY\nIntroduced in Phoenix 0.0.3.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293361,size=605},["mountlist.md"]={type="file",created=1740881293573,worldPermissions={write=false,read=true,execute=false},data="<summary>returns a list of mounts on the system</summary>\n# NAME\nmountlist - returns a list of mounts on the system\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**mountlist**(): [{*path*: string, *type*: string, *source*: string, *options*: table}]\n\n# DESCRIPTION\nReturns a list of mounts on the system.\n\n# PARAMETERS\nThis syscall does not take any arguments.\n\n# RETURN VALUE\nA list of tables containing the mount path, the filesystem type, the source path, and any options stored in the mount.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**mount**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293434,size=666},["devproperties.md"]={type="file",created=1740881293564,worldPermissions={write=false,read=true,execute=false},data="<summary>returns a list of properties on the device</summary>\n# NAME\ndevproperties - returns a list of properties on the device\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devproperties**(*device*: string): string[]\n\n# DESCRIPTION\nReturns a list of properties on the device.\n\nProperties are intended for use by wrapper APIs (such as `libsystem.hardware`), and specify an alternate name for a corresponding `get<Property>` method. To retrieve the property, capitalize the first character of the property name, prepend `get` to the name, and call that method on the device with no arguments. To set the property, first check for a `set<Property>` method in the same format as `get`, then call that method with one argument (the new value). If no `set` method is available, then that property is read-only.\n\n# PARAMETERS\n1. `device`: The device path or UUID to look up\n\n# RETURN VALUE\nA list of properties that are available. This table may be empty.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293395,size=1128},["attach.md"]={type="file",created=1740881293553,worldPermissions={write=false,read=true,execute=false},data="<summary>attaches a peripheral of the specified type to the computer</summary>\n# NAME\nattach - attaches a peripheral of the specified type to the computer\n\n# SYNOPSIS\n**attach**(*side*: string|number, *type*: string, *args...*: any): boolean, string?\n\n# DESCRIPTION\nIf using an emulator, attaches a peripheral of the specified type to the computer. This syscall requires root.\n\n# PARAMETERS\n1. `side`: The side to attach to, or an ID to attach as\n2. `type`: The type of peripheral to attach. The peripherals use standard CC/CraftOS-PC naming.\n3. `args...`: Any arguments to pass to the peripheral constructor\n\n# RETURN VALUE\n1. Whether the attachment succeeded\n2. If it failed, an optional error message (this may be `nil`!)\n\n# ERRORS\nThis syscall may throw an error if:\n* The user is not root.\n\n# HISTORY\nIntroduced in Phoenix 0.0.2.\n\n# SEE ALSO\n**detach**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293342,size=861},["mount.md"]={type="file",created=1740881293572,worldPermissions={write=false,read=true,execute=false},data="<summary>mounts a disk device to a path</summary>\n# NAME\nmount - mounts a disk device to a path\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**mount**(*type*: string, *src*: string, *dest*: string, *options*: table?)\n\n# DESCRIPTION\nMounts a disk device to a path using the specified filesystem and options.\n\n# PARAMETERS\n1. `type`: The filesystem type to use when mounting.\n2. `src`: The source device to mount. This argument's meaning depends on the filesystem type.\n3. `dest`: The directory to mount the new filesystem to.\n4. `options`: A table of options to pass to the filesystem mounter. The available options are specified by each individual filesystem.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The filesystem type does not exist.\n* The source device is invalid for the specified filesystem type.\n* The destination path does not exist.\n* The options passed to the mounter are invalid for the specified filesystem type.\n* The current user does not have permission to access to the source device.\n* The current user does not have permission to write to to the destination path.\n* The mounter ran into an issue while mounting the device.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**mountlist**(2), **unmount**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293432,size=1344},["devlock.md"]={type="file",created=1740881293562,worldPermissions={write=false,read=true,execute=false},data="<summary>locks the specified device to this process</summary>\n# NAME\ndevlock - locks the specified device to this process\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devlock**(*device*: string, *wait*: boolean = true): boolean\n\n# DESCRIPTION\nLocks the specified device to this process. This prevents any calls to the device from other processes, and will suppress events from being sent to other processes. If the current process already owns the lock, this syscall returns `true` immediately. (It does not act like a recursive mutex in this case - only one unlock is required no matter how many times it's locked.)\n\n# PARAMETERS\n1. `device`: The device path or UUID to operate on\n2. `wait`: `true` to wait for the lock to be released before returning; `false` to return immediately if the lock is already owned by another process\n\n# RETURN VALUE\n`true` if the current process now owns the lock; `false` otherwise.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**devunlock**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293387,size=1124},["devchildren.md"]={type="file",created=1740881293560,worldPermissions={write=false,read=true,execute=false},data="<summary>returns a list of names of all children of the current device</summary>\n# NAME\ndevchildren - returns a list of names of all children of the current device\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\ndevchildren(device: string): string[]\n\n# DESCRIPTION\nReturns a list of names of all children of the current device.\n\n# PARAMETERS\n1. `device`: The device path or UUID to look up\n\n# RETURN VALUE\nA list of child names, in an unspecified order. This table may be empty.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293376,size=653},["arpset.md"]={type="file",created=1740881293552,worldPermissions={write=false,read=true,execute=false},data="<summary>sets the computer ID mapping for the specified IP</summary>\n# NAME\narpset - sets the computer ID mapping for the specified IP\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**arpset**(*device*: string, *ip*: string, *id*: number?)\n\n# DESCRIPTION\nSets the computer ID mapping for the specified IP on the requested device.\n\n# PARAMETERS\n1. `device`: The path to the modem to add for.\n2. `ip`: The IP address of the target computer.\n3. `id`: The computer ID of the target computer, or `nil` to remove the entry.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user is not root.\n* The device is not present.\n* The device is not a valid modem.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**arplist**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293340,size=830},["combine.md"]={type="file",created=1740881293557,worldPermissions={write=false,read=true,execute=false},data="<summary>combines a set of path components into a valid path</summary>\n# NAME\ncombine - combines a set of path components into a valid path\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**combine**(*components...*: string): string\n\n# DESCRIPTION\nCombines a set of path components into a valid path.\n\n# PARAMETERS\n1. `components...`: The components in the path\n\n# RETURN VALUE\nThe final path composed of the passed components.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293363,size=567},["lockmutex.md"]={type="file",created=1740881293570,worldPermissions={write=false,read=true,execute=false},data="<summary>locks the specified mutex</summary>\n# NAME\nlockmutex - locks the specified mutex\n\n# LIBRARY\nStandard system library, synchronization module (*libsystem*, `system.sync`)\n\n# SYNOPSIS\n**lockmutex**(*mtx*: mutex)\n\n# DESCRIPTION\nLocks the specified mutex, waiting for the resource to be freed before claiming it.\n\n# PARAMETERS\n1. `mtx`: The mutex to lock.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The mutex is already claimed by the current thread and is not recursive.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**timelockmutex**(2) **trylockmutex**(2), **unlockmutex**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293424,size=649},["listen.md"]={type="file",created=1740881293568,worldPermissions={write=false,read=true,execute=false},data="<summary>starts listening for connections on the specified URI</summary>\n# NAME\nlisten - starts listening for connections on the specified URI\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**listen**(*uri*: string)\n\n# DESCRIPTION\nStarts listening for connections on the specified URI, using the protocol, IP, and port indicated in the URI. For PSP connections, the IP is used to determine the device to listen on - if this is `0.0.0.0`, then all connections are accepted.\n\nWhen a request is received, a `network_request` event is sent with the URI of the listener, the IP of the other computer (if available), and a handle to the connection. Listening will continue until `unlisten` is called with the same URI. (Note: PSP can only handle one connection at once per port.)\n\nThe following URI schemes are built-in:\n* `http`: Internet HTTP requests (CraftOS-PC only)\n* `ws`: Internet WebSocket connections (CraftOS-PC only)\n* `psp`: Phoenix Socket Protocol connections\n\nOther schemes may be implemented in kernel modules.\n\n# PARAMETERS\n1. `uri`: The URI to listen on. The path portion is ignored.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The URI specified is malformed.\n* The scheme in the URI is not supported.\n* The computer does not own the IP in the URI.\n* The computer is already using the IP/port specified.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**unlisten**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293413,size=1491},["connect.md"]={type="file",created=1740881293558,worldPermissions={write=false,read=true,execute=false},data="<summary>creates a connection to a remote resource</summary>\n# NAME\nconnect - creates a connection to a remote resource\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**connect**(*options*: table|string): Handle?\n\n# DESCRIPTION\nCreates a connection to a remote resource using the specified options table or URI.\n\n# PARAMETERS\n1. `options`: Either a string with a URI (no options), or a table with any of the following elements:\n  * `url: string`: The URI to connect to (required)\n  * `encoding: \"utf8\" | \"utf-8\" | \"binary\"`: HTTP/WS: Encoding to use when transferring data (defaults to `\"binary\"`)\n  * `headers: {[string] = string}`: HTTP/WS: Any headers to send in the request\n  * `method: string`: HTTP: The method to use when connecting (defaults to `\"GET\"`)\n  * `redirect: boolean`: HTTP: Whether to automatically redirect responses that indicate a redirect (defaults to `true`)\n  * `device: string`: Rednet/PSP: The path to the device to use to establish the connection (usually a modem), or `nil` to use all modems (note: if this path points to multiple devices, all are used)\n\n# RETURN VALUE\nA handle object that can be used to send/receive data, or `nil` + an error if the handle could not be created. The handle is not guaranteed to be ready to send/receive data immediately, however, so the `status` method should be checked before using.\n\n# ERRORS\nThis syscall may throw an error if:\n* The URI specified is malformed.\n* The scheme in the URI is not supported.\n* The device is not present.\n* The device is not a valid modem.\n\n# NOTES\nThe **connect** syscall returns a handle object for the specific protocol that was requested. These handles all contain a common set of methods, as well as some special methods that are specific to each protocol.\n\nAll handles have an `id` field, which is a number that uniquely identifies the connection. This ID is used in `handle_status_change` events to indicate which handle has changed status.\n\n`status(): \"ready\"|\"connecting\"|\"error\"|\"open\"|\"closed\", string?`  \nReturns the current status of the handle/connection.\n\n*Arguments*  \nThis method does not take any arguments.\n\n*Return Values*  \nThe current status of the handle/connection. These are the currently assigned statuses:\n* `ready`: Indicates the handle is ready to send data, but a connection has not yet been established.\n* `connecting`: Indicates the handle sent a connection request, and is currently awaiting a response. The handle is not ready to send or receive data.\n* `error`: Indicates an error has occurred while connecting to the server, and no data has been sent or received. This handle may no longer be used. More information may be supplied in a second return value.\n* `open`: Indicates the connection has been established, and data can be received (and possibly sent).\n* `closed`: Indicates the connection has been closed, and no data may be sent or received. This handle may no longer be used.\n\n*Errors*  \nThis method does not throw any errors.\n\n`read(mode...: string|number): string|number|nil...`  \nRead one or more values from the connection in a manner similar to `io.file:read`.\n\n*Arguments*  \n1. `mode...`: The read mode to use. This may be one of the following options:\n  * `*a`: Read all data available in the connection.\n  * `*l`: Read a line, excluding the final newline.\n  * `*L`: Read a line, including the final newline.\n  * `*n`: Read a number value if available.\n  * (any number): Read the specified number of characters/bytes.\n  If no arguments are specified, this defaults to `read(\"*l\")`.\n\n*Return Values*  \nThe values extracted from the connection. If one of the modes could not be read, the value returned for that parameter and all ones after are `nil`.\n\n*Errors*  \nThis method may throw an error if:\n* The handle is not currently open.\n\n`write(data...: any)`  \nWrites the supplied values to the connection.\n\n*Arguments*  \n1. `data...`: The values to write. Values that are not strings will be converted with `tostring`, unless otherwise specified by the handle type.\n\n*Return Values*  \nThis method does not return anything.\n\n*Errors*  \nThis method may throw an error if:\n* The handle is not currently open or ready.\n\n`close()`  \nCloses the connection.\n\n*Arguments*  \nThis method does not take any arguments.\n\n*Return Values*  \nThis method does not return anything.\n\n*Errors*  \nThis method may throw an error if:\n* The connection is not currently open.\n\n## HTTP handles\nHTTP\\[S\\] handles have a special flow to work properly. Upon creating the handle, it will be set in the `ready` state, and no request is sent yet. The request is only sent once the `write` method is called once. After that, the `write` method will no longer function, so make sure to add all data in the request in that `write` call. Even if no data needs to be sent (e.g. `GET` method), `write` must be called exactly once, even if it's with no data.\n\nAfter calling `write`, the handle will shift into `connecting` status, awaiting a response from the server. The client must wait for `status` to change to `open` before attempting to read data. After that, the handle functions like a normal read-only handle.\n\nHTTP handles have the following additional methods:\n\n`responseHeaders(): {[string]: string}`  \nReturns the headers contained in the response.\n\n*Arguments*  \nThis method does not take any arguments.\n\n*Return Values*  \nA key-value table of headers sent back from the server.\n\n*Errors*  \nThis method may throw an error if:\n* The connection is not currently open.\n\n`responseCode(): number`  \nReturns the HTTP response code returned from the server.\n\n*Arguments*  \nThis method does not take any arguments.\n\n*Return Values*  \nThe response code sent from the server.\n\n*Errors*  \nThis method may throw an error if:\n* The connection is not currently open.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293366,size=5863},["chmod.md"]={type="file",created=1740881293556,worldPermissions={write=false,read=true,execute=false},data="<summary>changes the permissions of a file or directory</summary>\n# NAME\nchmod - changes the permissions of a file or directory\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**chmod**(*path*: string, *user*: string?, *mode*: number|string|table)\n\n# DESCRIPTION\nChanges the permissions (mode) of a file or directory for the specified user. If any setuser bit is specified, this will be applied for all users.\n\n# PARAMETERS\n1. `path`: The path to the file to modify.\n2. `user`: The user to set the permissions for. If this is `nil`, sets the permissions for all users.\n3. `mode`: A value representing the permissions. This may be:\n  * A UNIX-style octal mode (e.g. `5`) - setuid bit is bit 4 (010)\n  * A UNIX-style mode modification string, without the user specifier (e.g. `\"+rx\"`) (this does not work with `\"-wx\"` - use `\"-xw\"` instead)\n  * A 3-character string with \"r\", \"w\", and \"x\" or \"s\" (or \"-\") (e.g. `\"r-s\"`)\n  * A table with `read: boolean?`, `write: boolean?`, `execute: boolean?`, and `setuser: boolean?` fields (if a field is `nil`, it uses the previous value)\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The file does not exist.\n* The current user is not the owner of the file or root.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**chown**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293355,size=1377},["loadmodule.md"]={type="file",created=1740881293570,worldPermissions={write=false,read=true,execute=false},data="<summary>attempts to load a kernel module into memory</summary>\n# NAME\nloadmodule - attempts to load a kernel module into memory\n\n# SYNOPSIS\n**loadmodule**(*path*: string)\n\n# DESCRIPTION\nAttempts to load a kernel module into memory. This syscall requires root.\n\n# PARAMETERS\n1. `path`: The path to the module to load.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The user is not root.\n* The path refers to a directory.\n* The module is either not owned by root or world-writable.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**unloadmodule**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293422,size=609},["list.md"]={type="file",created=1740881293568,worldPermissions={write=false,read=true,execute=false},data="<summary>returns a list of file names present in a directory</summary>\n# NAME\nlist - returns a list of file names present in a directory\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**list**(*path*: string): string[]\n\n# DESCRIPTION\nReturns a list of file names present in a directory.\n\n# PARAMETERS\n1. `path`: The path to the directory to list.\n\n# RETURN VALUE\nA list of file names. This may or may not be sorted.\n\n# ERRORS\nThis syscall may throw an error if:\n* The path does not exist.\n* The path is not directory.\n* The current user does not have permission to access the directory.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293411,size=681},["devcall.md"]={type="file",created=1740881293560,worldPermissions={write=false,read=true,execute=false},data="<summary>calls the specified method on the device</summary>\n# NAME\ndevcall - calls the specified method on the device\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devcall**(*device*: string, *method*: string, *args...*: any): any...\n\n# DESCRIPTION\nCalls the specified method on the device with arguments.\n\n# PARAMETERS\n1. `device`: The device path or UUID to operate on\n2. `method`: The name of the method to call\n3. `args...`: Any arguments to pass to the method\n\n# RETURN VALUE\nAll values returned from the method.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n* Another process has locked this device.\n* The specified method does not exist on the device.\n* The method threw an error while executing.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293373,size=836},["loadCraftOSAPI.md"]={type="file",created=1740881293569,worldPermissions={write=false,read=true,execute=false},data="<summary>loads a CraftOS API or module from the ROM</summary>\n# NAME\nloadCraftOSAPI - loads a CraftOS API or module from the ROM\n\n# SYNOPSIS\n**loadCraftOSAPI**(*apiName*: string): table\n\n# DESCRIPTION\nLoads a CraftOS API or module from the ROM. This can be used to get access to certain functions without having to mount the entire ROM.\n\nThis uses the current process's environment as the parent environment. This means the API will use the process's globals. If the API you need requires certain globals (like `colors`), load these in as globals first.\n\n# PARAMETERS\n1. `apiName`: The name of the API or module to load. If this starts with `cc.`, it loads a module from `rom/modules/main`. Otherwise, it loads an API from `rom/apis`.\n\n# RETURN VALUE\nA table with the loaded API or module.\n\n# ERRORS\nThis syscall may throw an error if:\n* The API name is malformed.\n* The API does not exist.\n* An error occurred while loading the API.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293418,size=974},["unlisten.md"]={type="file",created=1740881293583,worldPermissions={write=false,read=true,execute=false},data="<summary>stops listening on a URI previously passed to listen</summary>\n# NAME\nunlisten - stops listening on a URI previously passed to listen\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**unlisten**(*uri*: string)\n\n# DESCRIPTION\nStops listening on a URI previously passed to `listen`. This does not close any handles that are in use.\n\n# PARAMETERS\n1. `uri`: The URI to listen on. The path portion is ignored.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The computer is not listening on the specified URI.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**listen**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293483,size=682},["devinfo.md"]={type="file",created=1740881293561,worldPermissions={write=false,read=true,execute=false},data="<summary>returns a table with information describing a device node</summary>\n# NAME\ndevinfo - returns a table with information describing a device node\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devinfo**(*device*: string): HWInfo?\n\n# DESCRIPTION\nReturns a table with information describing a device node.\n\n# PARAMETERS\n1. `device`: The device path or UUID to look up\n\n# RETURN VALUE\nA table with the following information:\n```ts\ntype HWInfo = {\n    id: string,                // Device hardware ID\n    uuid: string,              // Assigned UUID\n    alias: string?,            // User-specified alias\n    parent: string,            // Path to parent device\n    displayName: string,       // Display name for users\n    types: {[string]: string}, // Types of devices implemented: type = driver name\n    metadata: Object           // Extra static metadata provided by drivers\n}\n```\nIf the device does not exist, this returns `nil`.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**devmethods**(2), **devproperties**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293382,size=1128},["link.md"]={type="file",created=1740881293567,worldPermissions={write=false,read=true,execute=false},data="<summary>creates a new symbolic link</summary>\n# NAME\nlink - creates a new symbolic link\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**link**(*path*: string, *location*: string)\n\n# DESCRIPTION\nCreates a new symbolic link at a path, creating any parent directories if they don't exist.\n\n# PARAMETERS\n1. `path`: The path to the link to create.\n2. `location`: The location the link should point to. This may be on another filesystem, as the link is symbolic.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user does not have permission to write the parent directory of the first directory created.\n* The path already exists.\n\n# HISTORY\nIntroduced in Phoenix 0.0.3.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293408,size=787},["devalias.md"]={type="file",created=1740881293559,worldPermissions={write=false,read=true,execute=false},data="<summary>sets or removes an alias for a device</summary>\n# NAME\ndevalias - sets or removes an alias for a device\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devalias**(*device*: string, *alias*: string?)\n\n# DESCRIPTION\nSets or removes an alias for a device.\n\n# PARAMETERS\n1. `device`: The device path or UUID to modify\n2. `alias`: The new alias to set (`nil` to remove)\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293371,size=605},["cchost.md"]={type="file",created=1740881293555,worldPermissions={write=false,read=true,execute=false},data="<summary>returns the value of the _HOST variable</summary>\n# NAME\ncchost - returns the value of the _HOST variable\n\n# SYNOPSIS\n**cchost**(): string\n\n# DESCRIPTION\nReturns the value of the `_HOST` variable.\n\n# PARAMETERS\nThis syscall does not take any arguments.\n\n# RETURN VALUE\nThe value of `_HOST`, which is in the format `ComputerCraft [0-9%.]+ %b()`.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**version**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293350,size=471},["chown.md"]={type="file",created=1740881293556,worldPermissions={write=false,read=true,execute=false},data="<summary>changes the owner of a file or directory</summary>\n# NAME\nchown - changes the owner of a file or directory\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**chown**(*path*: string, *user*: string)\n\n# DESCRIPTION\nChanges the owner of a file or directory, clearing the `setuser` bit if it's set.\n\n# PARAMETERS\n1. `path`: The path to the file to modify.\n2. `user`: The user who will own the file.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The file does not exist.\n* The current user is not the owner of the file or root.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**chmod**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293358,size=706},["alarm.md"]={type="file",created=1740881293551,worldPermissions={write=false,read=true,execute=false},data="<summary>sets an alarm</summary>\n# NAME\nalarm - sets an alarm\n\n# LIBRARY\nStandard system library, utility module (*libsystem*, `system.util`)\n\n# SYNOPSIS\n**alarm**(*timeout*: number): number\n\n# DESCRIPTION\nSets an alarm that will send an `alarm` event at the specified time.\n\n# PARAMETERS\n1. `timeout`: The time to set the alarm to.\n\n# RETURN VALUE\nThe ID of the new alarm created.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**cancel**(2), **timer**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293334,size=508},["devlisten.md"]={type="file",created=1740881293562,worldPermissions={write=false,read=true,execute=false},data="<summary>enables listening for events from this device</summary>\n# NAME\ndevlisten - enables listening for events from this device\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devlisten**(*device*: string, *state*: boolean = true)\n\n# DESCRIPTION\nEnables (or disables) listening for events from this device.\n\n# PARAMETERS\n1. `device`: The device path or UUID to operate on\n2. `state`: `true` to allow events to be passed to this process; `false` to stop events from being sent\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293384,size=709},["acquiresemaphore.md"]={type="file",created=1740881293551,worldPermissions={write=false,read=true,execute=false},data="<summary>acquires a resource from a semaphore object</summary>\n# NAME\nacquiresemaphore - acquires a resource from a semaphore object\n\n# LIBRARY\nStandard system library, synchronization module (*libsystem*, `system.sync`)\n\n# SYNOPSIS\n**acquiresemaphore**(*sem*: semaphore)\n\n# DESCRIPTION\nAcquires a resource from a semaphore object, waiting if none are available.\n\n# PARAMETERS\n1. `sem`: The semaphore to acquire.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**timeacquiresemaphore**(2), **releasesemaphore**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293331,size=623},["mkdir.md"]={type="file",created=1740881293571,worldPermissions={write=false,read=true,execute=false},data="<summary>creates a new directory</summary>\n# NAME\nmkdir - creates a new directory\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**mkdir**(*path*: string)\n\n# DESCRIPTION\nCreates a new directory at a path, creating any parent directories if they don't exist. If the directory already exists, this function does nothing and exits successfully.\n\n# PARAMETERS\n1. `path`: The path of the directory to create.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user does not have permission to write the parent directory of the first directory created.\n* A path component already exists and is a file.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293427,size=754},["devmethods.md"]={type="file",created=1740881293563,worldPermissions={write=false,read=true,execute=false},data="<summary>returns a list of methods that can be called on this device</summary>\n# NAME\ndevmethods - returns a list of methods that can be called on this device\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devmethods**(*device*: string): string[]\n\n# DESCRIPTION\nReturns a list of methods that can be called on this device.\n\n# PARAMETERS\n1. `device`: The device path or UUID to look up\n\n# RETURN VALUE\nA list of valid methods that can be called.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293392,size=622},["arplist.md"]={type="file",created=1740881293552,worldPermissions={write=false,read=true,execute=false},data="<summary>returns the list of known IP to computer ID mappings</summary>\n# NAME\narplist - returns the list of known IP to computer ID mappings\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**arplist**(*device*: string): {[string] = number}\n\n# DESCRIPTION\nReturns the list of known IP to computer ID mappings for the specified device.\n\n# PARAMETERS\n1. `device`: The path to the modem to query for.\n\n# RETURN VALUE\nA key-value table of mappings from IP addresses to computer IDs.\n\n# ERRORS\nThis syscall may throw an error if:\n* The device is not present.\n* The device is not a valid modem.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**arpset**(2)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293337,size=702}},permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293586,size=0},man8={type="directory",created=1740881294455,worldPermissions={execute=true,read=true,write=false},contents={["usermgr.md"]={type="file",created=1740881294454,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881294428,size=0},["mkspanfs.md"]={type="file",created=1740881293905,worldPermissions={write=false,read=true,execute=false},data="<summary>Create and format new spanfs disks</summary>\n# NAME\nmkspanfs - Create and format new spanfs disks\n\n# SYNOPSIS\n**mkspanfs** *volume name* *index drive* *data drive* ...\n\n# DESCRIPTION\n**mkspanfs** creates a new *spanfs* filesystem across the drives specified,\nusing the volume name given as the first argument to name the volume. The command\nwill first verify that all drives provided are valid, and prompts the user to\nconfirm that these drives are correct. Once confirmed, all disks are erased and\nformatted with a new *spanfs* filesystem with the specified name and a random\nUUID. After creation, the disk usage stats are reported.\n\n# EXAMPLE\nCreate a new volume named *Span Volume* on four disks, using `drive_0` to store\nthe index.\n\n`mkspanfs \"Span Volume\" drive_0 drive_1 drive_2 drive_3`\n\n# SEE ALSO\n**spanfs**(7)",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293893,size=828},["spanadd.md"]={type="file",created=1740881293906,worldPermissions={write=false,read=true,execute=false},data="<summary>add drives to an existing span</summary>\n# NAME\n    spanadd - add drives to an existing span\n\n# SYNOPSIS\n    **spanadd** *mount point* *drives ...*\n\n# DESCRIPTION\n**spanadd** adds one or more disk drives to an existing span filesystem. This\nallows effectively resizing the span.\n\nThe first argument points to the span to resize. The span must be mounted to be\nable to add drives.\n\nEach remaining argument is the device name of the drive to add. This can be a\ndevice ID, UUID, or path, as would be used with hardware APIs. **The disk in the drives will be erased.**\n\nThe filesystem must be remounted for the changes to take effect.\n\n# HISTORY\nIntroduced in spanfs 0.1.\n\n# SEE ALSO\n**mkspanfs**(8)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293895,size=705},["useradd.md"]={type="file",created=1740881294452,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881294423,size=0},["userdel.md"]={type="file",created=1740881294453,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881294425,size=0},["components.md"]={type="file",created=1740881291984,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881291965,size=0},["usermod.md"]={type="file",created=1740881294455,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881294431,size=0},["spaninfo.md"]={type="file",created=1740881293907,worldPermissions={write=false,read=true,execute=false},data="<summary>shows information about a span</summary>\n# NAME\n    spaninfo - shows information about a span\n\n# SYNOPSIS\n    **spaninfo** *mount path*\n\n# DESCRIPTION\n**spaninfo** shows various information about a mounted span, including UUID, name,\ncapacity, free space, and space info on individual disks.\n\n# HISTORY\nIntroduced in spanfs 0.1.\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293898,size=338},["dpkg.md"]={type="file",created=1740881291985,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881291967,size=0},["update-initrd.md"]={type="file",created=1740881292396,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881292388,size=0},["update.md"]={type="file",created=1740881291986,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881291970,size=0},["ftpmgr.md"]={type="file",created=1740881292192,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881292183,size=0}},permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294455,size=0},man5={type="directory",created=1740881294452,worldPermissions={execute=true,read=true,write=false},contents={["motd.md"]={type="file",created=1740881294450,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881294413,size=0},["shadow.md"]={type="file",created=1740881294452,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881294418,size=0},["passwd.md"]={type="file",created=1740881294451,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881294415,size=0},["ftpmgr.conf.md"]={type="file",created=1740881292191,worldPermissions={write=false,read=true,execute=false},data="<summary>configuration file for ftpmgr</summary>\n\n# NAME\n    **ftpmgr.conf** - configuration file for ftpmgr\n\n# SYNOPSIS\n    /etc/ftpmgr.conf\n\n# DESCRIPTION\nThe /etc/ftpmgr.conf file configures settings for the **ftpmgr(8)** FTP server.\n\nThe file uses a code-like syntax, with comments using `#`. Options are set using *key* **=** *value* **;** syntax, and users are defined using **user \"** *name* **\" {** *options* **}**. Strings may be delimited with **\"** or **'**. `#` characters in strings are not recommended, as they may be mistaken for comments while parsing.\n\n# GLOBAL OPTIONS\n* **ip =** *string*: The IP address to serve on. \"0.0.0.0\" indicates any IP/interface.\n* **port =** *number*: The port to serve the command stream on. FTP standard is 21.\n* **passivePortRange = {** *number* **,** *number* **}**: The range of ports to reserve for passive connections.\n* **allUsers =** *boolean*: Whether to allow all users on the system to log in. These users will use their system username and password for login, and have access to the full system root with their permissions. This requires **usermgr(8)** to be installed.\n\n# USER OPTIONS\nThere are three methods of authentication available:\n* No authentication: No password is required for the user. This is used when `useSystemLogin` is false, and no password or hash is set.\n* Password authentication: A password for the user is supplied in the config file. This is used when `password` or `passwordHash` is set for a user.\n* System authentication: The user's password is stored in the system database (i.e. **passwd(5)**), and authentication is done through **usermgr(8)**, which must be installed. This is used when `useSystemLogin` is true (default) and no `password` is set.\n\nA user named `anonymous` is used when no username or password is entered. It is disabled by default for security, but can be configured to provide, for example, public read-only access to a certain folder on the system.\n\nThe following options may be configured in each user directive:\n* **systemUser =** *string*: The Phoenix username to run the server as. Defaults to the name of the FTP user.\n* **password =** *string*: The password for the user in plaintext.\n* **passwordHash =** *string*: The hex SHA-256 hash of the password + hash.\n* **useSystemLogin =** *boolean*: Whether to use system credentials for the user (requires **usermgr(8)**). Defaults to true. Overridden by `password` and `passwordHash`.\n* **allowWrite =** *boolean*: Whether to allow writing files, irrespective of the system user's permissions. Defaults to true.\n* **root =** *string*: The root of the filesystem to expose to the share. Defaults to `/`.\n\n# SEE ALSO\n**ftpmgr(8)**\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881292178,size=2691}},permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294452,size=0},man1={type="directory",created=1740881294689,worldPermissions={execute=true,read=true,write=false},contents={["shell.md"]={type="file",created=1740881292596,worldPermissions={write=false,read=true,execute=false},data="<summary>CraftOS shell wrapper for Phoenix</summary>\n# NAME\n    shell - CraftOS shell wrapper for Phoenix\n\n# SYNOPSIS\n    **shell**\n\n# DESCRIPTION\n**shell** executes the CraftOS shell program using libcraftos. It requires the\nROM to be mounted at `/rom` - if run as root, it will automatically mount the\nROM as needed.\n\nThe filesystem is the same as the Phoenix filesystem, so all Phoenix files will\nstill be present in the shell. Compatibility caveats with libcraftos still apply,\nbut the `shell`, `package`, and `require` APIs will be replaced with the\noriginal CraftOS versions, so issues relating to those will no longer apply.\n\nPhoenix programs will still be executable in the CraftOS shell. However, the\nprograms will execute in the same process context as the shell. This means that\ncalls that affect global process state, such as **exit**(2) or **stdin**(2),\nwill also affect the shell, as well as other programs run in the shell (e.g.\ncalling **exit**(2) will quit the entire shell).\n\n# HISTORY\nIntroduced in libcraftos 0.2.\n\n# SEE ALSO\n**craftos**(1)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881292590,size=1061},["logger.md"]={type="file",created=1740881293549,worldPermissions={write=false,read=true,execute=false},data="<summary>view, post to, create, and delete logs</summary>\n# NAME\nlogger - view, post to, create, and delete logs\n\n# SYNOPSIS\n**logger log** [**-n** *log name*] [**-c** *category*] [**-l** **debug**|**info**|**notice**|**warning**|**error**|**critical**] [**-m** *module*] *message* ...\n**logger create** [**-F** *path*] [**-s**] *log name*\n**logger delete** [**-p**] *log name*\n**logger view** *log name*\n**logger follow** [**-f** *filter*] *log name*\n\n# DESCRIPTION\n**logger** provides a simple command-line interface to the system logger module. It allows viewing logs (including streaming), posting messages to a log, and creating and deleting logs.\n\n# PARAMETERS\nFor the **log** subcommand:\n\n**-c** *category*  \n    Sets the category for the message.\n\n**-l** **debug**|**info**|**notice**|**warning**|**error**|**critical**  \n    Sets the level of the log messgae.\n\n**-m** *module*  \n    Sets the name of the module for the message.\n\n**-n** *log name*  \n    Sets the name of the log to write to.\n\nFor the **create** subcommand:\n\n**-F** *path*  \n    Sets the file to write logs to.\n\n**-s**  \n    Specifies that the log should be streamable.\n\nFor the **delete** subcommand:\n\n**-p**  \n    Purges all logs on disk.\n\nFor the **follow** subcommand:\n\n**-f** *filter*  \n    Specifies a filter expression to apply to the listener.\n    \n    A filter consists of a series of clauses separated by semicolons. Each clause consists of a name, operator, and one or more values separated by bars (`|`). String values may be surrounded with double quotes to allow semicolons, bars, and leading spaces. If multiple values are specified, any value matching will cause the clause to resolve to true. All clauses must be true for the filter to match.\n    \n    Available operators: `==`, `!=`/`~=`, `=%` (match), `!%`/`~%` (not match), `<`, `<=`, `>=`, `>` (numbers only).\n    \n    Example: `level == 3 | 4 | 5; category != filesystem; process > 0; message =% \"Unexpected error\"`\n\n# HISTORY\nIntroduced in baseutils 0.2.\n\n# SEE ALSO\n**syslog**(2), **system.log**(3)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881293324,size=2047},["startctl.md"]={type="file",created=1740881294015,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881294003,size=0},["tar.md"]={type="file",created=1740881294121,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881294115,size=0},["yellowbox.md"]={type="file",created=1740881294689,worldPermissions={write=false,read=true,execute=false},data="<summary>access and administrate YellowBox boxes</summary>\n# NAME\nyellowbox - access and administrate YellowBox boxes\n\n# SYNOPSIS\n**yellowbox status**  \n**yellowbox start** [*options*] ...\n**yellowbox stop** *id*\n**yellowbox view** *id*\n**yellowbox get-bios** [*version*]\n\n# DESCRIPTION\n**yellowbox** \n\n# EXAMPLE\n\n\n# SEE ALSO\n**yellowbox**(7)",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881294676,size=342},["startmgr.md"]={type="file",created=1740881294016,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881294005,size=0},["shutdown.md"]={type="file",created=1740881294014,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881294000,size=0},["su.md"]={type="file",created=1740881294448,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881294400,size=0},["sudo.md"]={type="file",created=1740881294449,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881294403,size=0},["craftos.md"]={type="file",created=1740881292596,worldPermissions={write=false,read=true,execute=false},data="<summary>run CraftOS programs under Phoenix</summary>\n# NAME\n    craftos - run CraftOS programs under Phoenix\n\n# SYNOPSIS\n    **craftos** *program path* [*arguments ...*]\n\n# DESCRIPTION\n**craftos** allows running programs written for CraftOS on top of Phoenix. It\nuses *libcraftos* to implement a compatibility layer between CraftOS APIs and\nPhoenix system calls. It loads all of the CraftOS APIs into the program's global\ntable, and then executes the program with the specified arguments.\n\n**craftos** functions as if the program was called from the CraftOS shell, or\nusing `shell.run`. It should be compatible with many programs, but some that\nrequire specific details of CraftOS's inner workings may not be compatible.\n\n# HISTORY\nIntroduced in libcraftos 0.1.\n\n# SEE ALSO\n**shell**(1)\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881292587,size=788},["login.md"]={type="file",created=1740881294447,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881294395,size=0},["passwd.md"]={type="file",created=1740881294448,worldPermissions={write=false,read=true,execute=false},data="",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881294398,size=0}},permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294689,size=0}},permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294554,size=0}},permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291057,size=0},lib={type="directory",setuser=false,created=1740881294445,worldPermissions={write=false,read=true,execute=true},contents={cert={type="directory",created=1740881292490,worldPermissions={write=false,read=true,execute=true},contents={["util.lua"]={type="file",created=1740881292490,worldPermissions={execute=false,read=true,write=false},data="local a={}local b=bit32.band;local c=bit32.bxor;local d=bit32.rshift;local e=unpack or table.unpack;function a.reduceName(f)local g={}for h,i in ipairs(f.rdnSequence)do local j=i[1].value;if type(j)==\"table\"then j=select(2,next(j))end;g[i[1].type.string]=j end;return g end;function a.compareNames(k,l)local m=a.reduceName(k)local n=a.reduceName(l)for o,i in pairs(m)do if n[o]~=i then return false end end;for o,i in pairs(n)do if m[o]~=i then return false end end;return true end;function a.pbkdf2(p,q,r,s,t,u)s=type(s)==\"table\"and s or{tostring(s):byte(1,-1)}u=u or 32;local v=1;local w={}while u>0 do local x={}local y={e(s)}local z=u>q and q or u;y[#y+1]=b(d(v,24),0xFF)y[#y+1]=b(d(v,16),0xFF)y[#y+1]=b(d(v,8),0xFF)y[#y+1]=b(v,0xFF)for A=1,t do y=p(y,r)for o=1,z do x[o]=c(y[o],x[o]or 0)end end;u=u-z;v=v+1;for o=1,z do w[#w+1]=x[o]end end;return string.char(e(w))end;function a.pkcs7pad(B,C)local D=C-#B%C;for h=1,D do B[#B+1]=D end;return B end;function a.pkcs7unpad(B)local D=B[#B]for h=1,D do B[#B]=nil end;return B end;return a\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292484,size=1038},["signature.lua"]={type="file",created=1740881292489,worldPermissions={execute=false,read=true,write=false},data="local a=require\"container\"local b=require\"chain\"local c=require\"cert.util\"local d=require\"sha2\"local e=require\"ccryptolib.ed25519\"local f={}function f.sign(g,h,i,j)local k=a.pkcs7ContentTypeOIDs.data;if type(i)==\"table\"then k=i.type;i=a.savePKCS7(i)end;assert(h.privateKeyAlgorithm.type.string==a.signatureAlgorithmOIDs.ED25519,\"Private key must be Ed25519\")assert(g.toBeSigned.subjectPublicKeyInfo.algorithm.type.string==a.signatureAlgorithmOIDs.ED25519,\"Certificate must be Ed25519\")local l=os.date(\"!*t\")l.type=\"UTCTime\"local m={{type=a.pkcs7AttributeOIDs.contentType,values={contentType=k}},{type=a.pkcs7AttributeOIDs.messageDigest,values={messageDigest=d.hex_to_bin(d.sha3_512(i))}},{type=a.pkcs7AttributeOIDs.signingTime,values={signingTime={utcTime=l}}}}local n={g}if j then for o,p in ipairs(j)do n[#n+1]=p end end;local q={type=a.pkcs7ContentTypeOIDs.signedData,content={version=1,digestAlgorithms={{type=a.digestAlgorithmOIDs.SHA3_512}},encapContentInfo={eContentType=k,eContent=nil},certificates=n,crls=nil,signerInfos={{version=1,sid={issuerAndSerialNumber={issuer=g.toBeSigned.issuer,serialNumber=g.toBeSigned.serialNumber}},digestAlgorithm={type=a.digestAlgorithmOIDs.SHA3_512},signedAttrs=m,signatureAlgorithm={type=a.signatureAlgorithmOIDs.ED25519},signature=e.sign(h.privateKey,g.toBeSigned.subjectPublicKeyInfo.subjectPublicKey.data,a.encodePKCS7SignedAttrs(m))}}}}return q end;function f.getCertificate(q,r)local s=c.reduceName(q.content.signerInfos[r].sid.issuerAndSerialNumber.issuer)for o,t in ipairs(q.content.certificates)do local u=c.reduceName(t.toBeSigned.issuer)local v=true;for w,x in pairs(s)do if u[w]~=x then v=false;break end end;if v and t.toBeSigned.serialNumber.data==q.content.signerInfos[1].sid.issuerAndSerialNumber.serialNumber.data then return t end end;return nil end;function f.verify(q,i,y)y=y or 1;if q.type.string~=a.pkcs7ContentTypeOIDs.signedData then return false,\"PKCS#7 block is not signed data\"end;if q.content.digestAlgorithms[1].type.string~=a.digestAlgorithmOIDs.SHA3_512 then return false,\"Unsupported digest algorithm\"end;if q.content.signerInfos[y].digestAlgorithm.type.string~=a.digestAlgorithmOIDs.SHA3_512 then return false,\"Unsupported digest algorithm\"end;if q.content.signerInfos[y].signatureAlgorithm.type.string~=a.signatureAlgorithmOIDs.ED25519 then return false,\"Unsupported signature algorithm\"end;local g=f.getCertificate(q,y)if not g then return false,\"Could not find certificate in signature\"end;local z=a.encodePKCS7SignedAttrs(q.content.signerInfos[y].signedAttrs)if not e.verify(g.toBeSigned.subjectPublicKeyInfo.subjectPublicKey.data,z,q.content.signerInfos[y].signature)then return false,\"Failed to validate signature\"end;local A;for o,p in ipairs(q.content.signerInfos[y].signedAttrs)do if p.type.string==a.pkcs7AttributeOIDs.messageDigest then A=p.values.messageDigest;break end end;if d.hex_to_bin(d.sha3_512(i))~=A then return false,\"Failed to validate digest\"end;return true end;return f\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292483,size=2970},["init.lua"]={type="file",created=1740881292489,worldPermissions={execute=false,read=true,write=false},data="local a=require\"system.expect\"local b=require\"chain\"local c=require\"container\"local d=require\"crypto\"local e=require\"csr\"local f=require\"signature\"local g=require\"cert.util\"local h=require\"ccryptolib.random\"local i={chain=b,container=c,crypto=d,csr=e,signature=f}function i.generatePrivateKeyForSigning(j)a(1,j,\"string\",\"nil\")local k=h.random(32)local l={version=1,privateKeyAlgorithm={type=c.signatureAlgorithmOIDs.ED25519},privateKey=k}if j then return k,c.encodePEM(c.savePKCS8Encrypted(d.encryptKey(l,j)),\"ENCRYPTED PRIVATE KEY\")else return k,c.encodePEM(c.savePKCS8(l),\"PRIVATE KEY\")end end;function i.generatePrivateKeyForEncryption(j)a(1,j,\"string\",\"nil\")local k=h.random(32)local l={version=1,privateKeyAlgorithm={type=c.publicKeyAlgorithmOIDs.X25519},privateKey=k}if j then return k,c.encodePEM(c.savePKCS8Encrypted(d.encryptKey(l,j)),\"ENCRYPTED PRIVATE KEY\")else return k,c.encodePEM(c.savePKCS8(l),\"PRIVATE KEY\")end end;local m={[c.nameOIDs.uniqueIdentifier]=true,[c.nameOIDs.dnQualifier]=true,[c.nameOIDs.serialNumber]=true,[c.nameOIDs.countryName]=true}function i.generateCSR(l,n,j)a(1,l,\"string\")a(2,n,\"table\")a(3,j,\"string\",\"nil\")local o,p=c.decodePEM(l)if p==\"ENCRYPTED PRIVATE KEY\"then if not j then error(\"Private key is encrypted, but no password was provided\",2)end;l=d.decryptKey(c.loadPKCS8Encrypted(o),j)else l=c.loadPKCS8(o)end;local q={rdnSequence={}}for r,s in pairs(n)do if not m[r]then s={uTF8String=s}end;q.rdnSequence[#q.rdnSequence+1]={{type=r,value=s}}end;return c.encodePEM(c.savePKCS10(e.generate(l,q)),\"CERTIFICATE REQUEST\")end;function i.signCSR(t,u,l,v,w,j)a(1,t,\"string\")a(2,u,\"string\")a(3,l,\"string\")a(4,v,\"number\",\"string\")a(5,w,\"number\")a(6,j,\"string\",\"nil\")local o,p=c.decodePEM(l)if p==\"ENCRYPTED PRIVATE KEY\"then if not j then error(\"Private key is encrypted, but no password was provided\",2)end;l=d.decryptKey(c.loadPKCS8Encrypted(o),j)else l=c.loadPKCS8(o)end;if type(v)==\"string\"then v={type=\"INTEGER\",data=v}end;return c.encodePEM(c.saveX509(e.sign(c.loadPKCS10(c.decodePEM(t)),c.loadX509(c.decodePEM(u)),l,v,w)),\"CERTIFICATE\")end;function i.selfSignCSR(t,l,v,w,j)a(1,t,\"string\")a(2,l,\"string\")a(3,v,\"number\",\"string\")a(4,w,\"number\")a(5,j,\"string\",\"nil\")local o,p=c.decodePEM(l)if p==\"ENCRYPTED PRIVATE KEY\"then if not j then error(\"Private key is encrypted, but no password was provided\",2)end;l=d.decryptKey(c.loadPKCS8Encrypted(o),j)else l=c.loadPKCS8(o)end;if type(v)==\"string\"then v={type=\"INTEGER\",data=v}end;return c.encodePEM(c.saveX509(e.selfSign(c.loadPKCS10(c.decodePEM(t)),l,v,w)),\"CERTIFICATE\")end;function i.encrypt(x,j)a(1,x,\"string\")a(2,j,\"string\")return c.encodePEM(c.savePKCS7(d.encrypt(x,d.passwordKey(j))),\"CMS\")end;function i.decrypt(x,j)a(1,x,\"string\")a(2,j,\"string\")return d.decrypt(c.loadPKCS7(c.decodePEM(x)),d.passwordKey(j))end;function i.encryptExchange(x,y,z,A,j)a(1,x,\"string\")a(2,y,\"string\")a(3,z,\"string\")a(4,A,\"string\")a(5,j,\"string\",\"nil\")local l,p=c.decodePEM(y)if p==\"ENCRYPTED PRIVATE KEY\"then if not j then error(\"Private key is encrypted, but no password was provided\",2)end;l=d.decryptKey(c.loadPKCS8Encrypted(l),j)else l=c.loadPKCS8(l)end;return c.encodePEM(c.savePKCS7(d.encrypt(x,d.exchangedKey(l,c.loadX509(c.decodePEM(z)),c.loadX509(c.decodePEM(A))))),\"CMS\")end;function i.decryptExchange(x,y,z,A,j)a(1,x,\"string\")a(2,y,\"string\")a(3,z,\"string\")a(4,A,\"string\")a(5,j,\"string\",\"nil\")local l,p=c.decodePEM(y)if p==\"ENCRYPTED PRIVATE KEY\"then if not j then error(\"Private key is encrypted, but no password was provided\",2)end;l=d.decryptKey(c.loadPKCS8Encrypted(l),j)else l=c.loadPKCS8(l)end;return d.decrypt(c.loadPKCS7(c.decodePEM(x)),d.exchangedKey(l,c.loadX509(c.decodePEM(A)),c.loadX509(c.decodePEM(z))))end;function i.sign(u,k,x,B)a(1,u,\"string\",\"table\")a(2,k,\"string\",\"table\")a(3,x,\"string\")a(4,B,\"table\",\"nil\")if B then for C,s in ipairs(B)do B[C]=c.loadX509(c.decodePEM(s))end end;if type(u)==\"string\"then u=c.loadX509(c.decodePEM(u))end;if type(k)==\"string\"then k=c.loadPKCS8(c.decodePEM(k))end;return c.encodePEM(c.savePKCS7(f.sign(u,k,x,B)),\"PKCS7\")end;function i.verify(D,x,E,F,G)if E==nil then E=true end;a(1,D,\"string\",\"table\")a(2,x,\"string\")a(3,E,\"boolean\")a(4,F,\"string\",\"nil\")a(5,G,\"table\",\"nil\")if type(D)==\"string\"then D=c.loadPKCS7(c.decodePEM(D))end;local H,I=f.verify(D,x)if not H then return false,I end;if E then if G then for C,s in ipairs(G)do if type(s)==\"string\"then G[C]=c.loadX509(c.decodePEM(s))end end end;return b.validate(f.getCertificate(D,1),D.content.certificates,F,G)end;return true end;function i.validate(u,J,F,G)a(1,u,\"string\",\"table\")a(2,J,\"table\",\"nil\")a(3,F,\"string\",\"nil\")a(4,G,\"string\",\"nil\")if type(u)==\"string\"then u=c.loadX509(c.decodePEM(u))end;if J then for C,s in ipairs(J)do if type(s)==\"string\"then J[C]=c.loadX509(c.decodePEM(s))end end end;if G then for C,s in ipairs(G)do if type(s)==\"string\"then G[C]=c.loadX509(c.decodePEM(s))end end end;return b.validate(u,J,F,G)end;function i.print(x)local o,p=c.decodePEM(x)local K;if p==\"CERTIFICATE\"then K=c.loadX509(o)elseif p==\"PKCS#7\"or p==\"CMS\"then K=c.loadPKCS7(o)elseif p==\"PRIVATE KEY\"then K=c.loadPKCS8(o)elseif p==\"ENCRYPTED PRIVATE KEY\"then K=c.loadPKCS8Encrypted(o)elseif p==\"CERTIFICATE REQUEST\"then K=c.loadPKCS10(o)else error(\"Unknown PEM data type\",2)end;return c.print(K)end;return i\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292483,size=5287},["container.lua"]={type="file",created=1740881292487,worldPermissions={execute=false,read=true,write=false},data="local a=require\"system.expect\"local b=require\"system.serialization\"local c=require\"asn1\"local d={}d.nameOIDs={commonName=\"2.5.4.3\",countryName=\"2.5.4.6\",localityName=\"2.5.4.7\",stateOrProvinceName=\"2.5.4.8\",streetAddress=\"2.5.4.9\",organizationIdentifier=\"2.5.4.97\",organizationName=\"2.5.4.10\",organizationalUnitName=\"2.5.4.11\",serialNumber=\"2.5.4.5\",surname=\"2.5.4.4\",givenName=\"2.5.4.42\",title=\"2.5.4.12\",initials=\"2.5.4.43\",generationQualifier=\"2.5.4.44\",uniqueIdentifier=\"2.5.4.45\",dnQualifier=\"2.5.4.46\",pseudonym=\"2.5.4.65\",userID=\"0.9.2342.19200300.100.1.1\",domainComponent=\"0.9.2342.19200300.100.1.25\",emailAddress=\"1.2.840.113549.1.9.1\",jurisdictionLocalityName=\"1.3.6.1.4.1.311.60.2.1.1\",jurisdictionStateOrProvinceName=\"1.3.6.1.4.1.311.60.2.1.2\",jurisdictionCountryName=\"1.3.6.1.4.1.311.60.2.1.3\",businessCategory=\"2.5.4.15\",postalAddress=\"1.5.4.16\",postalCode=\"1.5.4.17\",unstructuredName=\"1.2.840.113549.1.9.2\"}d.signatureAlgorithmOIDs={RSA_MD5=\"1.2.840.113549.1.1.4\",RSA_SHA1=\"1.2.840.113549.1.1.5\",RSA_SHA224=\"1.2.840.113549.1.1.14\",RSA_SHA256=\"1.2.840.113549.1.1.11\",RSA_SHA384=\"1.2.840.113549.1.1.12\",RSA_SHA512=\"1.2.840.113549.1.1.13\",RSA_SHA3_224=\"2.16.840.1.101.3.4.3.13\",RSA_SHA3_256=\"2.16.840.1.101.3.4.3.14\",RSA_SHA3_384=\"2.16.840.1.101.3.4.3.15\",RSA_SHA3_512=\"2.16.840.1.101.3.4.3.16\",RSASSA_PSS=\"1.2.840.113549.1.1.10\",ECDSA_SHA1=\"1.2.840.10045.4.1\",ECDSA_SHA224=\"1.2.840.10045.4.3.1\",ECDSA_SHA256=\"1.2.840.10045.4.3.2\",ECDSA_SHA384=\"1.2.840.10045.4.3.3\",ECDSA_SHA512=\"1.2.840.10045.4.3.4\",ECDSA_SHA3_224=\"2.16.840.1.101.3.4.3.9\",ECDSA_SHA3_256=\"2.16.840.1.101.3.4.3.10\",ECDSA_SHA3_384=\"2.16.840.1.101.3.4.3.11\",ECDSA_SHA3_512=\"2.16.840.1.101.3.4.3.12\",DSA_SHA1=\"1.2.840.10040.4.3\",DSA_SHA224=\"2.16.840.1.101.3.4.3.1\",DSA_SHA256=\"2.16.840.1.101.3.4.3.2\",DSA_SHA384=\"2.16.840.1.101.3.4.3.3\",DSA_SHA512=\"2.16.840.1.101.3.4.3.4\",ED25519=\"1.3.101.112\",ED448=\"1.3.101.113\"}d.extendedKeyUsageOIDs={serverAuth=\"1.3.6.1.5.5.7.3.1\",clientAuth=\"1.3.6.1.5.5.7.3.2\",codeSigning=\"1.3.6.1.5.5.7.3.3\",emailProtection=\"1.3.6.1.5.5.7.3.4\",timeStamping=\"1.3.6.1.5.5.7.3.8\",ocspSigning=\"1.3.6.1.5.5.7.3.9\",anyExtendedKeyUsage=\"2.5.29.37.0\",smartcardLogon=\"1.3.6.1.4.1.311.20.2.2\",kerberosPKInitKDC=\"1.3.6.1.5.2.3.5\",IPSec_IKE=\"1.3.6.1.5.5.7.3.17\",certificateTransparency=\"1.3.6.1.4.1.11129.2.4.4\"}d.extensionOIDs={basicConstraints=\"2.5.29.19\",keyUsage=\"2.5.29.15\",subjectAlternativeName=\"2.5.29.17\",issuerAlternativeName=\"2.5.29.18\",subjectKeyIdentifier=\"2.5.29.14\",nameConstraints=\"2.5.29.30\",crlDistributionPoints=\"2.5.29.31\"}d.publicKeyAlgorithmOIDs={DSA=\"1.2.840.10040.4.1\",EC_PUBLIC_KEY=\"1.2.840.10045.2.1\",RSAES_PKCS1v15=\"1.2.840.113549.1.1.1\",RSASSA_PSS=\"1.2.840.113549.1.1.10\",X25519=\"1.3.101.110\",X448=\"1.3.101.111\",ED25519=\"1.3.101.112\",ED448=\"1.3.101.113\"}d.digestAlgorithmOIDs={SHA1=\"1.3.14.3.2.26\",SHA224=\"2.16.840.1.101.3.4.2.4\",SHA256=\"2.16.840.1.101.3.4.2.1\",SHA384=\"2.16.840.1.101.3.4.2.2\",SHA512=\"2.16.840.1.101.3.4.2.3\",SHA3_224=\"2.16.840.1.101.3.4.2.7\",SHA3_256=\"2.16.840.1.101.3.4.2.8\",SHA3_384=\"2.16.840.1.101.3.4.2.9\",SHA3_512=\"2.16.840.1.101.3.4.2.10\"}d.encryptionAlgorithmOIDs={AES128_CBC=\"2.16.840.1.101.3.4.1.2\",AES192_CBC=\"2.16.840.1.101.3.4.1.22\",AES256_CBC=\"2.16.840.1.101.3.4.1.42\",ChaCha20_Poly1305=\"1.2.840.113549.1.9.16.0.66\"}d.keyDerivationAlgorithmOIDs={PBKDF2=\"1.2.840.113549.1.5.12\"}d.passwordBasedEncryptionSchemeOIDs={PBES2=\"1.2.840.113549.1.5.13\"}d.pseudoRandomFunctionOIDs={HMAC_SHA1=\"1.2.840.113549.2.7\",HMAC_SHA224=\"1.2.840.113549.2.8\",HMAC_SHA256=\"1.2.840.113549.2.9\",HMAC_SHA384=\"1.2.840.113549.2.10\",HMAC_SHA512=\"1.2.840.113549.2.11\",HMAC_SHA512_224=\"1.2.840.113549.2.12\",HMAC_SHA512_256=\"1.2.840.113549.2.13\"}local e=c.sequence{{\"fieldType\",c.oid},{\"parameters\",c.optional(c.any)}}local f=c.sequence{{\"a\",c.octet_string},{\"b\",c.octet_string},{\"seed\",c.optional(c.bit_string)}}local g=c.sequence{{\"version\",c.integer},{\"fieldID\",e},{\"curve\",f},{\"base\",c.octet_string},{\"order\",c.integer},{\"cofactor\",c.optional(c.integer)}}local h=c.choice{{\"ecParameters\",g},{\"namedCurve\",c.oid},{\"implicitlyCA\",c.null}}local i={[d.publicKeyAlgorithmOIDs.EC_PUBLIC_KEY]={{\"ecParameters\",h}},[d.signatureAlgorithmOIDs.ECDSA_SHA1]={},[d.signatureAlgorithmOIDs.ECDSA_SHA224]={},[d.signatureAlgorithmOIDs.ECDSA_SHA256]={},[d.signatureAlgorithmOIDs.ECDSA_SHA384]={},[d.signatureAlgorithmOIDs.ECDSA_SHA512]={},[d.signatureAlgorithmOIDs.ECDSA_SHA3_224]={},[d.signatureAlgorithmOIDs.ECDSA_SHA3_256]={},[d.signatureAlgorithmOIDs.ECDSA_SHA3_384]={},[d.signatureAlgorithmOIDs.ECDSA_SHA3_512]={},[d.signatureAlgorithmOIDs.ED25519]={},[d.publicKeyAlgorithmOIDs.X25519]={},[d.digestAlgorithmOIDs.SHA1]={},[d.digestAlgorithmOIDs.SHA224]={},[d.digestAlgorithmOIDs.SHA256]={},[d.digestAlgorithmOIDs.SHA384]={},[d.digestAlgorithmOIDs.SHA512]={},[d.digestAlgorithmOIDs.SHA3_224]={},[d.digestAlgorithmOIDs.SHA3_256]={},[d.digestAlgorithmOIDs.SHA3_384]={},[d.digestAlgorithmOIDs.SHA3_512]={},[d.encryptionAlgorithmOIDs.AES128_CBC]={{\"iv\",c.octet_string}},[d.encryptionAlgorithmOIDs.AES192_CBC]={{\"iv\",c.octet_string}},[d.encryptionAlgorithmOIDs.AES256_CBC]={{\"iv\",c.octet_string}},[d.encryptionAlgorithmOIDs.ChaCha20_Poly1305]={{\"nonce\",c.octet_string}},[d.pseudoRandomFunctionOIDs.HMAC_SHA1]={},[d.pseudoRandomFunctionOIDs.HMAC_SHA224]={},[d.pseudoRandomFunctionOIDs.HMAC_SHA256]={},[d.pseudoRandomFunctionOIDs.HMAC_SHA384]={},[d.pseudoRandomFunctionOIDs.HMAC_SHA512]={},[d.pseudoRandomFunctionOIDs.HMAC_SHA512_224]={},[d.pseudoRandomFunctionOIDs.HMAC_SHA512_256]={}}local j=c.class(i)local function k(l)return c.sequence{{\"toBeSigned\",l},{\"signatureAlgorithm\",j},{\"signature\",c.bit_string}}end;local m=c.choice{{\"teletexString\",c.teletex_string},{\"printableString\",c.printable_string},{\"bmpString\",c.bmp_string},{\"universalString\",c.universal_string},{\"uTF8String\",c.utf8string}}local n=c.class{[d.nameOIDs.commonName]={{\"value\",m}},[d.nameOIDs.surname]={{\"value\",m}},[d.nameOIDs.givenName]={{\"value\",m}},[d.nameOIDs.initials]={{\"value\",m}},[d.nameOIDs.generationQualifier]={{\"value\",m}},[d.nameOIDs.uniqueIdentifier]={{\"value\",c.octet_string}},[d.nameOIDs.dnQualifier]={{\"value\",c.printable_string}},[d.nameOIDs.serialNumber]={{\"value\",c.printable_string}},[d.nameOIDs.pseudonym]={{\"value\",m}},[d.nameOIDs.countryName]={{\"value\",c.printable_string}},[d.nameOIDs.localityName]={{\"value\",m}},[d.nameOIDs.jurisdictionLocalityName]={{\"value\",m}},[d.nameOIDs.stateOrProvinceName]={{\"value\",m}},[d.nameOIDs.jurisdictionStateOrProvinceName]={{\"value\",m}},[d.nameOIDs.streetAddress]={{\"value\",m}},[d.nameOIDs.organizationName]={{\"value\",m}},[d.nameOIDs.organizationalUnitName]={{\"value\",m}},[d.nameOIDs.title]={{\"value\",m}},[d.nameOIDs.organizationIdentifier]={{\"value\",m}},[d.nameOIDs.businessCategory]={{\"value\",m}},[d.nameOIDs.postalAddress]={{\"value\",m}},[d.nameOIDs.postalCode]={{\"value\",m}}}local o=c.set_of(n)local p=c.sequence_of(o)local q=c.choice{{\"rdnSequence\",p}}local r=c.choice{{\"utcTime\",c.utc_time},{\"generalTime\",c.generalized_time}}local s=c.sequence{{\"notBefore\",r},{\"notAfter\",r}}local t=c.sequence{{\"algorithm\",j},{\"subjectPublicKey\",c.bit_string}}local u=c.sequence{{\"extnId\",c.oid},{\"critical\",c.optional(c.boolean)},{\"extnValue\",c.octet_string}}local v=c.sequence{{\"version\",c.default(c.explicit(0,c.integer),1)},{\"serialNumber\",c.integer},{\"signature\",j},{\"issuer\",q},{\"validity\",s},{\"subject\",q},{\"subjectPublicKeyInfo\",t},{\"issuerUniqueID\",c.optional(c.implicit(1,c.bit_string))},{\"subjectUniqueID\",c.optional(c.implicit(2,c.bit_string))},{\"extensions\",c.optional(c.explicit(3,c.sequence_of(u)))}}local w=k(v)local x=c.sequence{{\"version\",c.optional(c.integer)},{\"signature\",j},{\"issuer\",q},{\"thisUpdate\",r},{\"nextUpdate\",c.optional(r)},{\"revokedCertificates\",c.optional(c.sequence_of(c.sequence{{\"serialNumber\",c.integer},{\"revocationDate\",r},{\"crlEntryExtensions\",c.optional(c.sequence_of(u))}}))},{\"crlExtensions\",c.optional(c.explicit(0,c.sequence_of(u)))}}local y=k(x)d.pkcs9AttributeOIDs={emailAddress=\"1.2.840.113549.1.9.1\",unstructuredName=\"1.2.840.113549.1.9.2\",contentType=\"1.2.840.113549.1.9.3\",messageDigest=\"1.2.840.113549.1.9.4\",signingTime=\"1.2.840.113549.1.9.5\",countersignature=\"1.2.840.113549.1.9.6\",challengePassword=\"1.2.840.113549.1.9.7\",unstructuredAddress=\"1.2.840.113549.1.9.8\",extendedCertificateAttributes=\"1.2.840.113549.1.9.9\",signingDescription=\"1.2.840.113549.1.9.13\",extensionRequest=\"1.2.840.113549.1.9.14\",smimeCapabilities=\"1.2.840.113549.1.9.15\",friendlyName=\"1.2.840.113549.1.9.20\",localKeyId=\"1.2.840.113549.1.9.21\",userPKCS12=\"2.16.840.1.113730.3.1.216\",pkcs15Token=\"1.2.840.113549.1.9.25.1\",encryptedPrivateKeyInfo=\"1.2.840.113549.1.9.25.2\",randomNonce=\"1.2.840.113549.1.9.25.3\",sequenceNumber=\"1.2.840.113549.1.9.25.4\",pkcs7PDU=\"1.2.840.113549.1.9.25.5\",dateOfBirth=\"1.3.6.1.5.5.7.9.1\",placeOfBirth=\"1.3.6.1.5.5.7.9.2\",gender=\"1.3.6.1.5.5.7.9.3\",countryOfCitizenship=\"1.3.6.1.5.5.7.9.4\",countryOfResidence=\"1.3.6.1.5.5.7.9.5\",pseudonym=\"2.5.4.65\"}local z=c.choice{{\"ia5string\",c.ia5string},{\"directoryString\",m}}local A={[d.pkcs9AttributeOIDs.emailAddress]={{\"values\",c.set{{\"emailAddress\",c.ia5string}}}},[d.pkcs9AttributeOIDs.unstructuredName]={{\"values\",c.set{{\"unstructuredName\",z}}}},[d.pkcs9AttributeOIDs.unstructuredAddress]={{\"values\",c.set{{\"unstructuredAddress\",m}}}},[d.pkcs9AttributeOIDs.dateOfBirth]={{\"values\",c.set{{\"dateOfBirth\",c.generalized_time}}}},[d.pkcs9AttributeOIDs.placeOfBirth]={{\"values\",c.set{{\"placeOfBirth\",m}}}},[d.pkcs9AttributeOIDs.gender]={{\"values\",c.set{{\"gender\",c.printable_string}}}},[d.pkcs9AttributeOIDs.countryOfCitizenship]={{\"values\",c.set{{\"countryOfCitizenship\",c.printable_string}}}},[d.pkcs9AttributeOIDs.countryOfResidence]={{\"values\",c.set{{\"countryOfResidence\",c.printable_string}}}},[d.pkcs9AttributeOIDs.pseudonym]={{\"values\",c.set{{\"pseudonym\",m}}}},[d.pkcs9AttributeOIDs.contentType]={{\"values\",c.set{{\"contentType\",c.oid}}}},[d.pkcs9AttributeOIDs.messageDigest]={{\"values\",c.set{{\"messageDigest\",c.octet_string}}}},[d.pkcs9AttributeOIDs.signingTime]={{\"values\",c.set{{\"signingTime\",r}}}},[d.pkcs9AttributeOIDs.randomNonce]={{\"values\",c.set{{\"randomNonce\",c.octet_string}}}},[d.pkcs9AttributeOIDs.sequenceNumber]={{\"values\",c.set{{\"sequenceNumber\",c.integer}}}},[d.pkcs9AttributeOIDs.challengePassword]={{\"values\",c.set{{\"challengePassword\",m}}}},[d.pkcs9AttributeOIDs.extensionRequest]={{\"values\",c.set{{\"extensionRequest\",c.sequence_of(u)}}}},[d.pkcs9AttributeOIDs.friendlyName]={{\"values\",c.set{{\"friendlyName\",c.bmp_string}}}},[d.pkcs9AttributeOIDs.localKeyId]={{\"values\",c.set{{\"localKeyId\",c.octet_string}}}},[d.pkcs9AttributeOIDs.signingDescription]={{\"values\",c.set{{\"signingDescription\",m}}}},[d.pkcs9AttributeOIDs.smimeCapabilities]={{\"values\",c.set{{\"smimeCapabilities\",c.sequence_of(j)}}}}}local B=c.class(A)A[d.pkcs9AttributeOIDs.extendedCertificateAttributes]={{\"values\",c.set{{\"extendedCertificateAttributes\",c.set_of(B)}}}}local C=c.sequence{{\"version\",c.integer},{\"subject\",q},{\"subjectPKInfo\",t},{\"attributes\",c.explicit(0,c.set_of(B))}}local D=k(C)local E=c.sequence{{\"encryptionAlgorithm\",j},{\"encryptedData\",c.octet_string}}A[d.pkcs9AttributeOIDs.encryptedPrivateKeyInfo]={{\"values\",c.set{{\"encryptedPrivateKeyInfo\",E}}}}local F=c.sequence{{\"version\",c.integer},{\"privateKeyAlgorithm\",j},{\"privateKey\",c.octet_string},{\"attributes\",c.optional(c.set_of(B))}}d.pkcs7ContentTypeOIDs={data=\"1.2.840.113549.1.7.1\",signedData=\"1.2.840.113549.1.7.2\",envelopedData=\"1.2.840.113549.1.7.3\",digestedData=\"1.2.840.113549.1.7.5\",encryptedData=\"1.2.840.113549.1.7.6\",authData=\"1.2.840.113549.1.9.16.1.2\",authEnvelopedData=\"1.2.840.113549.1.9.16.1.23\"}local G=c.sequence{{\"eContentType\",c.oid},{\"eContent\",c.optional(c.explicit(0,c.octet_string))}}local H=c.sequence{{\"issuer\",q},{\"serialNumber\",c.integer}}local I=c.choice{{\"issuerAndSerialNumber\",H},{\"subjectKeyIdentifier\",c.explicit(0,c.octet_string)}}local J=c.sequence{{\"version\",c.integer},{\"sid\",I},{\"digestAlgorithm\",j},{\"signedAttrs\",c.optional(c.implicit(0,c.set_of(B)))},{\"signatureAlgorithm\",j},{\"signature\",c.octet_string},{\"unsignedAttrs\",c.optional(c.implicit(1,c.set_of(B)))}}A[d.pkcs9AttributeOIDs.countersignature]={{\"countersignature\",J}}local K=c.sequence{{\"version\",c.integer},{\"digestAlgorithms\",c.set_of(j)},{\"encapContentInfo\",G},{\"certificates\",c.optional(c.implicit(0,c.set_of(w)))},{\"crls\",c.optional(c.implicit(1,c.set_of(y)))},{\"signerInfos\",c.set_of(J)}}local L=c.sequence{{\"certs\",c.optional(c.implicit(0,c.set_of(w)))},{\"crls\",c.optional(c.implicit(1,c.set_of(y)))}}local M=c.sequence{{\"version\",c.integer},{\"rid\",I},{\"keyEncryptionAlgorithm\",j},{\"encryptedKey\",c.octet_string}}local N=c.choice{{\"issuerAndSerialNumber\",H},{\"subjectKeyIdentifier\",c.explicit(0,c.integer)},{\"originatorKey\",c.explicit(1,c.sequence{{\"algorithm\",j},{\"publicKey\",c.bit_string}})}}local O=c.sequence{{\"type\",c.oid},{\"value\",c.any}}local P=c.sequence{{\"subjectKeyIdentifier\",c.octet_string},{\"date\",c.optional(c.generalized_time)},{\"other\",c.optional(O)}}local Q=c.choice{{\"issuerAndSerialNumber\",H},{\"rKeyId\",c.implicit(0,P)}}local R=c.sequence{{\"rid\",Q},{\"encryptedKey\",c.octet_string}}local S=c.sequence{{\"version\",c.integer},{\"originator\",c.explicit(0,N)},{\"ukm\",c.optional(c.explicit(1,c.octet_string))},{\"keyEncryptionAlgorithm\",j},{\"recipientEncryptedKeys\",c.sequence_of(R)}}local T=c.sequence{{\"version\",c.integer},{\"kekid\",P},{\"keyEncryptionAlgorithm\",j},{\"encryptedKey\",c.octet_string}}local U=c.sequence{{\"version\",c.integer},{\"keyDerivationAlgorithm\",c.optional(c.explicit(0,j))},{\"keyEncryptionAlgorithm\",j},{\"encryptedKey\",c.octet_string}}local V=c.sequence{{\"type\",c.oid},{\"value\",c.any}}local W=c.choice{{\"ktri\",M},{\"kari\",c.explicit(1,S)},{\"kekri\",c.explicit(2,T)},{\"pwri\",c.explicit(3,U)},{\"ori\",c.explicit(4,V)}}local X=c.sequence{{\"contentType\",c.oid},{\"contentEncryptionAlgorithm\",j},{\"encryptedContent\",c.optional(c.implicit(0,c.octet_string))}}local Y=c.sequence{{\"version\",c.integer},{\"originatorInfo\",c.optional(c.implicit(0,L))},{\"recipientInfos\",c.set_of(W)},{\"encryptedContentInfo\",X},{\"unprotectedAttrs\",c.optional(c.explicit(1,c.set_of(B)))}}local Z=c.sequence{{\"version\",c.integer},{\"digestAlgorithm\",j},{\"encapContentInfo\",G},{\"digest\",c.octet_string}}local _=c.sequence{{\"version\",c.integer},{\"encryptedContentInfo\",X},{\"unprotectedAttrs\",c.optional(c.implicit(1,c.set_of(B)))}}local a0=c.sequence{{\"version\",c.integer},{\"originatorInfo\",c.optional(c.implicit(0,L))},{\"recipientInfos\",c.set_of(W)},{\"macAlgorithm\",j},{\"digestAlgorithm\",c.optional(c.explicit(1,j))},{\"encapContentInfo\",G},{\"authAttrs\",c.optional(c.implicit(2,c.set_of(B)))},{\"mac\",c.octet_string},{\"unauthAttrs\",c.optional(c.implicit(3,c.set_of(B)))}}local a1=c.sequence{{\"version\",c.integer},{\"originatorInfo\",c.optional(c.implicit(0,L))},{\"recipientInfos\",c.set_of(W)},{\"authEncryptedContentInfo\",X},{\"authAttrs\",c.optional(c.implicit(2,c.set_of(B)))},{\"mac\",c.octet_string},{\"unauthAttrs\",c.optional(c.implicit(3,c.set_of(B)))}}local a2=c.class{[d.pkcs7ContentTypeOIDs.data]={{\"content\",c.explicit(0,c.octet_string)}},[d.pkcs7ContentTypeOIDs.signedData]={{\"content\",c.explicit(0,K)}},[d.pkcs7ContentTypeOIDs.envelopedData]={{\"content\",c.explicit(0,Y)}},[d.pkcs7ContentTypeOIDs.digestedData]={{\"content\",c.explicit(0,Z)}},[d.pkcs7ContentTypeOIDs.encryptedData]={{\"content\",c.explicit(0,_)}},[d.pkcs7ContentTypeOIDs.authData]={{\"content\",c.explicit(0,a0)}},[d.pkcs7ContentTypeOIDs.authEnvelopedData]={{\"content\",c.explicit(0,a1)}}}A[d.pkcs9AttributeOIDs.pkcs7PDU]={{\"values\",c.set{{\"contentInfo\",a2}}}}local a3=c.sequence{{\"salt\",c.choice{{\"specified\",c.octet_string},{\"otherSource\",j}}},{\"iterationCount\",c.integer},{\"keyLength\",c.optional(c.integer)},{\"prf\",c.optional(j)}}local a4=c.sequence{{\"keyDerivationFunc\",j},{\"encryptionScheme\",j}}i[d.keyDerivationAlgorithmOIDs.PBKDF2]={{\"pbkdf2Parameters\",a3}}i[d.passwordBasedEncryptionSchemeOIDs.PBES2]={{\"pbes2Parameters\",a4}}function d.decodePEM(a5)local type=a5:match(\"^%-%-%-%-%-BEGIN ([^%-]+)\")local a6=b.base64.decode(a5:match(\"%-%-%-%-%-BEGIN [^%-]+%-%-%-%-%-\\n(.+)\\n%-%-%-%-%-END [^%-]+%-%-%-%-%-\"):gsub(\"[^A-Za-z0-9/+=]\",\"\"))return a6,type end;function d.encodePEM(a5,type)return([[-----BEGIN %s-----\n%s\n-----END %s-----\n]]):format(type,b.base64.encode(a5):gsub((\".\"):rep(64),\"%0\\n\"),type)end;function d.loadPKCS7(a5)local a7=a2.decode(a5)return a7 end;function d.loadPKCS8(a5)local a8=F.decode(a5)if a8.privateKeyAlgorithm.type.string==d.publicKeyAlgorithmOIDs.ED25519 then a8.privateKey=c.octet_string.decode(a8.privateKey)end;return a8 end;function d.loadPKCS8Encrypted(a5)return E.decode(a5)end;function d.loadPKCS10(a5)return D.decode(a5)end;function d.loadPKCS12(a5)end;function d.loadX509(a5)local a9=w.decode(a5)return a9 end;function d.savePKCS7(a7)return a2.encode(a7)end;function d.encodePKCS7SignedAttrs(aa)return c.set_of(B).encode(aa)end;function d.savePKCS8(a8)if(a8.privateKeyAlgorithm.type.string or a8.privateKeyAlgorithm.type)==d.publicKeyAlgorithmOIDs.ED25519 then return F.encode{version=a8.version,privateKeyAlgorithm=a8.privateKeyAlgorithm,privateKey=c.octet_string.encode(a8.privateKey),attributes=a8.attributes}end;return F.encode(a8)end;function d.savePKCS8Encrypted(a8)return E.encode(a8)end;function d.encodePKCS10InnerInfo(ab)return C.encode(ab.toBeSigned)end;function d.savePKCS10(ab)return D.encode(ab)end;function d.savePKCS12(ac)end;function d.encodeX509InnerCertificate(a9)return v.encode(a9.toBeSigned)end;function d.saveX509(a9)return w.encode(a9)end;function d.print(a9,ad)ad=ad or 0;for ae,af in pairs(a9)do io.write((\"  \"):rep(ad)..(type(ae)==\"string\"and ae:gsub(\"%f[A-Z]([A-Z])\",\" %1\"):gsub(\"^%w\",string.upper)or ae)..\": \")if type(af)==\"table\"and type(af.type)~=\"string\"then io.write(\"\\n\")d.print(af,ad+1)elseif type(af)==\"table\"then if af.type==\"INTEGER\"then io.write(af.data:gsub(\".\",function(ag)return(\"%02X \"):format(string.byte(ag))end)..\"\\n\")elseif af.type==\"BIT STRING\"then io.write(af.data:gsub(\".\",function(ag)return(\"%02X \"):format(string.byte(ag))end)..\"\\n\")elseif af.type==\"OBJECT IDENTIFIER\"then io.write(af.string)for ah,ai in pairs(d)do if type(ai)==\"table\"then for aj,ak in pairs(ai)do if ak==af.string then io.write(\" (\"..aj..\")\")break end end end end;io.write(\"\\n\")elseif af.type==\"UTCTime\"then io.write(os.date(\"%c\\n\",os.time(af)))else io.write(\" (\"..af.type..\")\\n\")end elseif type(af)==\"string\"or type(af)==\"number\"then if string.match(af,\"[^\\32-\\126]\")then io.write(string.gsub(af,\".\",function(ag)return(\"%02X \"):format(string.byte(ag))end)..\"\\n\")else io.write(af..\"\\n\")end else io.write(\"\\n\")end end end;return d\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292481,size=18528},["csr.lua"]={type="file",created=1740881292488,worldPermissions={execute=false,read=true,write=false},data="local a=require\"system.expect\"local b=require\"container\"local c=require\"ccryptolib.ed25519\"local d=require\"ccryptolib.x25519\"local e={}function e.generate(f,g,h)a(1,f,\"table\")a(2,g,\"table\")a(3,h,\"table\",\"nil\")local i=f.privateKeyAlgorithm.type.string or f.privateKeyAlgorithm.type;local j;if i==b.signatureAlgorithmOIDs.ED25519 then j=c.publicKey(f.privateKey)elseif i==b.publicKeyAlgorithmOIDs.X25519 then j=d.publicKey(f.privateKey)else error(\"Unsupported private key algorithm\",2)end;local k={toBeSigned={version=0,subject=g,subjectPKInfo={algorithm=f.privateKeyAlgorithm,subjectPublicKey={type=\"BIT STRING\",data=j,unused=0}},attributes=h or{}},signatureAlgorithm={type=b.signatureAlgorithmOIDs.ED25519},signature={type=\"BIT STRING\",data=\"\",unused=0}}k.signature.data=c.sign(f.privateKey,c.publicKey(f.privateKey),b.encodePKCS10InnerInfo(k))return k end;function e.sign(k,l,f,m,n,o)a(1,k,\"table\")a(2,l,\"table\")a(3,f,\"table\")a(4,m,\"number\",\"table\")a(5,n,\"number\")local i=f.privateKeyAlgorithm.type.string or f.privateKeyAlgorithm.type;if i~=b.signatureAlgorithmOIDs.ED25519 and i~=b.publicKeyAlgorithmOIDs.X25519 then error(\"Unsupported private key algorithm\",2)end;i=l.toBeSigned.subjectPublicKeyInfo.algorithm.type.string or l.toBeSigned.subjectPublicKeyInfo.algorithm.type;if i~=b.signatureAlgorithmOIDs.ED25519 then error(\"Unsupported certificate public key algorithm\",2)end;i=k.signatureAlgorithm.type.string or k.signatureAlgorithm.type;if i~=b.signatureAlgorithmOIDs.ED25519 then error(\"Unsupported request signature algorithm\",2)end;if not c.verify(o or k.toBeSigned.subjectPKInfo.subjectPublicKey.data,b.encodePKCS10InnerInfo(k),k.signature.data)then error(\"Unable to verify request signature\",2)end;local p=os.date(\"!*t\")local q=os.date(\"!*t\",os.time()+n*86400)local r={toBeSigned={version=1,issuer=l.toBeSigned.subject,serialNumber=m,signature={type=b.signatureAlgorithmOIDs.ED25519},subject=k.toBeSigned.subject,subjectPublicKeyInfo=k.toBeSigned.subjectPKInfo,validity={notBefore={generalTime=p},notAfter={generalTime=q}}},signatureAlgorithm={type=b.signatureAlgorithmOIDs.ED25519},signature={type=\"BIT STRING\",data=\"\",unused=0}}for s,t in ipairs(k.toBeSigned.attributes)do if(t.type.string or t.type)==b.pkcs9AttributeOIDs.extensionRequest then r.toBeSigned.version=3;r.toBeSigned.extensions=t.values.extensionRequest end end;r.signature.data=c.sign(f.privateKey,l.toBeSigned.subjectPublicKeyInfo.subjectPublicKey.data,b.encodeX509InnerCertificate(r))return r end;function e.selfSign(k,f,m,n)a(1,k,\"table\")a(2,f,\"table\")a(3,m,\"number\",\"table\")a(4,n,\"number\")local i=f.privateKeyAlgorithm.type.string or f.privateKeyAlgorithm.type;if i~=b.signatureAlgorithmOIDs.ED25519 and i~=b.publicKeyAlgorithmOIDs.X25519 then error(\"Unsupported private key algorithm\",2)end;i=k.signatureAlgorithm.type.string or k.signatureAlgorithm.type;if i~=b.signatureAlgorithmOIDs.ED25519 then error(\"Unsupported request signature algorithm\",2)end;if not c.verify(c.publicKey(f.privateKey),b.encodePKCS10InnerInfo(k),k.signature.data)then error(\"Unable to verify request signature\",2)end;local p=os.date(\"!*t\")local q=os.date(\"!*t\",os.time()+n*86400)local r={toBeSigned={version=1,issuer=k.toBeSigned.subject,serialNumber=m,signature={type=b.signatureAlgorithmOIDs.ED25519},subject=k.toBeSigned.subject,subjectPublicKeyInfo=k.toBeSigned.subjectPKInfo,validity={notBefore={generalTime=p},notAfter={generalTime=q}}},signatureAlgorithm={type=b.signatureAlgorithmOIDs.ED25519},signature={type=\"BIT STRING\",data=\"\",unused=0}}for s,t in ipairs(k.toBeSigned.attributes)do if(t.type.string or t.type)==b.pkcs9AttributeOIDs.extensionRequest then r.toBeSigned.version=3;r.toBeSigned.extensions=t.values.extensionRequest end end;r.signature.data=c.sign(f.privateKey,c.publicKey(f.privateKey),b.encodeX509InnerCertificate(r))return r end;return e\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292482,size=3825},["crypto.lua"]={type="file",created=1740881292488,worldPermissions={execute=false,read=true,write=false},data="local a=require\"container\"local b=require\"cert.util\"local c=require\"ccryptolib.chacha20\"local d=require\"ccryptolib.poly1305\"local e=require\"ccryptolib.random\"local f=require\"ccryptolib.x25519\"local g=require\"aes\"local h=require\"sha2\"local i={}function i.exchangedKey(j,k,l)local m=j.privateKeyAlgorithm.type.string or j.privateKeyAlgorithm.type;local n=k.toBeSigned.subjectPublicKeyInfo.algorithm.type.string or k.toBeSigned.subjectPublicKeyInfo.algorithm.type;local o=l.toBeSigned.subjectPublicKeyInfo.algorithm.type.string or l.toBeSigned.subjectPublicKeyInfo.algorithm.type;assert(m==a.publicKeyAlgorithmOIDs.ED25519 or m==a.publicKeyAlgorithmOIDs.X25519,\"Unsupported originator private key type\")assert(n==a.publicKeyAlgorithmOIDs.X25519,\"Unsupported originator public key type\")assert(o==a.publicKeyAlgorithmOIDs.X25519,\"Unsupported receiver public key type\")return{encrypt=function(p)local q=e.random(16)local r=f.exchange(j.privateKey,l.toBeSigned.subjectPublicKeyInfo.subjectPublicKey.data)local s={kari={version=3,originator={issuerAndSerialNumber={issuer=k.toBeSigned.issuer,serialNumber=k.toBeSigned.serialNumber}},keyEncryptionAlgorithm={type=a.encryptionAlgorithmOIDs.AES256_CBC,iv=q},recipientEncryptedKeys={{encryptedKey=g.TableToString(g.EncryptCBC(b.pkcs7pad(g.StringToTable(p),16),g.StringToTable(r),g.StringToTable(q))),rid={issuerAndSerialNumber={issuer=l.toBeSigned.issuer,serialNumber=l.toBeSigned.serialNumber}}}}}}return s end,decrypt=function(t)if not t.kari or t.kari.version~=3 then return nil end;if not t.kari.originator.issuerAndSerialNumber then return nil end;if not b.compareNames(t.kari.originator.issuerAndSerialNumber.issuer,k.toBeSigned.issuer)then return nil end;if t.kari.originator.issuerAndSerialNumber.serialNumber~=k.toBeSigned.serialNumber then return nil end;local u=t.kari.keyEncryptionAlgorithm.type.string or t.kari.keyEncryptionAlgorithm.type;if u~=a.encryptionAlgorithmOIDs.AES128_CBC and u~=a.encryptionAlgorithmOIDs.AES192_CBC and u~=a.encryptionAlgorithmOIDs.AES256_CBC then return nil end;for v,w in ipairs(t.kari.recipientEncryptedKeys)do if w.rid.issuerAndSerialNumber and b.compareNames(w.rid.issuerAndSerialNumber.issuer,l.toBeSigned.issuer)and w.rid.issuerAndSerialNumber.serialNumber==l.toBeSigned.serialNumber then local r=f.exchange(j.privateKey,k.toBeSigned.subjectPublicKeyInfo.subjectPublicKey.data)local x,y=pcall(g.DecryptCBC,g.StringToTable(w.encryptedKey),g.StringToTable(r),g.StringToTable(t.kari.keyEncryptionAlgorithm.iv))if x and y and y[#y]>0 and y[#y]<17 then return g.TableToString(b.pkcs7unpad(y))end end end;return nil end}end;function i.sharedKey(z,A)local B;if#z==16 then B=a.encryptionAlgorithmOIDs.AES128_CBC elseif#z==24 then B=a.encryptionAlgorithmOIDs.AES192_CBC elseif#z==32 then B=a.encryptionAlgorithmOIDs.AES256_CBC else error(\"Invalid key length\",2)end;return{encrypt=function(p)local q=e.random(16)local s={kekri={version=4,kekid={subjectKeyIdentifier=A},keyEncryptionAlgorithm={type=B,iv=q},encryptedKey=g.TableToString(g.EncryptCBC(b.pkcs7pad(g.StringToTable(p),16),g.StringToTable(z),g.StringToTable(q)))}}return s end,decrypt=function(t)if not t.kekri or t.kekri.version~=4 then return nil end;if t.kekri.kekid.subjectKeyIdentifier~=A then return nil end;local u=t.kekri.keyEncryptionAlgorithm.type.string or t.kekri.keyEncryptionAlgorithm.type;if u~=B then return nil end;local x,y=pcall(g.DecryptCBC,g.StringToTable(t.kekri.encryptedKey),g.StringToTable(z),g.StringToTable(t.kekri.keyEncryptionAlgorithm.iv))if x and y and y[#y]>0 and y[#y]<17 then return g.TableToString(b.pkcs7unpad(y))end;return nil end}end;function i.passwordKey(C,D,E)D=D or h.sha256;local F,G;if D==h.sha1 then F=a.pseudoRandomFunctionOIDs.HMAC_SHA1;G=20 elseif D==h.sha224 then F=a.pseudoRandomFunctionOIDs.HMAC_SHA224;G=28 elseif D==h.sha256 then F=a.pseudoRandomFunctionOIDs.HMAC_SHA256;G=32 elseif D==h.sha384 then F=a.pseudoRandomFunctionOIDs.HMAC_SHA384;G=48 elseif D==h.sha512 then F=a.pseudoRandomFunctionOIDs.HMAC_SHA512;G=64 elseif D==h.sha512_224 then F=a.pseudoRandomFunctionOIDs.HMAC_SHA512_224;G=28 elseif D==h.sha512_256 then F=a.pseudoRandomFunctionOIDs.HMAC_SHA512_256;G=32 else error(\"Unknown hashing algorithm\",2)end;return{encrypt=function(p)local s={pwri={version=0,keyDerivationAlgorithm={type=a.keyDerivationAlgorithmOIDs.PBKDF2,pbkdf2Parameters={iterationCount=E or 4096,salt={specified=e.random(16)},keyLength=32,prf={type=F}}},keyEncryptionAlgorithm={type=a.encryptionAlgorithmOIDs.AES256_CBC,iv=e.random(16)},encryptedKey=\"\"}}local H=b.pbkdf2(function(I,J)return{h.hmac(D,J,string.char(table.unpack(I))):byte(1,-1)}end,G,C,s.pwri.keyDerivationAlgorithm.pbkdf2Parameters.salt.specified,E or 4096,32)s.pwri.encryptedKey=g.TableToString(g.EncryptCBC(b.pkcs7pad(g.StringToTable(p),16),g.StringToTable(H),g.StringToTable(s.pwri.keyEncryptionAlgorithm.iv)))return s end,decrypt=function(t)if not t.pwri or t.pwri.version~=0 then return nil end;if not t.pwri.keyDerivationAlgorithm or(t.pwri.keyDerivationAlgorithm.type.string or t.pwri.keyDerivationAlgorithm.type)~=a.keyDerivationAlgorithmOIDs.PBKDF2 then return nil end;if not t.pwri.keyDerivationAlgorithm.pbkdf2Parameters.prf then return nil end;local K=t.pwri.keyDerivationAlgorithm.pbkdf2Parameters.prf.type.string or t.pwri.keyDerivationAlgorithm.pbkdf2Parameters.prf.type;if K~=F then return nil end;local u=t.pwri.keyEncryptionAlgorithm.type.string or t.pwri.keyEncryptionAlgorithm.type;local L;if u==a.encryptionAlgorithmOIDs.AES128_CBC then L=16 elseif u==a.encryptionAlgorithmOIDs.AES192_CBC then L=24 elseif u==a.encryptionAlgorithmOIDs.AES256_CBC then L=32 else return nil end;local H=b.pbkdf2(function(I,J)return{h.hmac(D,J,string.char(table.unpack(I))):byte(1,-1)}end,G,C,t.pwri.keyDerivationAlgorithm.pbkdf2Parameters.salt.specified,t.pwri.keyDerivationAlgorithm.pbkdf2Parameters.iterationCount,L)local x,y=pcall(g.DecryptCBC,g.StringToTable(t.pwri.encryptedKey),g.StringToTable(H),g.StringToTable(t.pwri.keyEncryptionAlgorithm.iv))if x and y and y[#y]>0 and y[#y]<17 then return g.TableToString(b.pkcs7unpad(y))end;return nil end}end;function i.encrypt(M,...)local N=a.pkcs7ContentTypeOIDs.data;if type(M)==\"table\"then N=M.type.string or M.type;M=a.savePKCS7(M)end;local p=e.random(32)local O=e.random(12)local P={type=a.pkcs7ContentTypeOIDs.authEnvelopedData,content={version=0,recipientInfos={},authEncryptedContentInfo={contentEncryptionAlgorithm={type=a.encryptionAlgorithmOIDs.ChaCha20_Poly1305,nonce=O},contentType=N,encryptedContent=c.crypt(p,O,M)},mac=d.mac(p,M)}}for Q,w in ipairs{...}do P.content.recipientInfos[Q]=w.encrypt(p)if not P.content.recipientInfos[Q].pwri then P.content.version=2 end end;return P end;function i.decrypt(P,...)if(P.type.string or P.type)~=a.pkcs7ContentTypeOIDs.authEnvelopedData then error(\"Not an authenticated data object\",2)end;if(P.content.authEncryptedContentInfo.contentEncryptionAlgorithm.type.string or P.content.authEncryptedContentInfo.contentEncryptionAlgorithm.type)~=a.encryptionAlgorithmOIDs.ChaCha20_Poly1305 then error(\"Unsupported algorithm\",2)end;local p;for v,t in ipairs{...}do for v,s in ipairs(P.content.recipientInfos)do p=t.decrypt(s)if p then break end end;if p then break end end;if not p then error(\"Could not find valid key encryptor\",2)end;local M=c.crypt(p,P.content.authEncryptedContentInfo.contentEncryptionAlgorithm.nonce,P.content.authEncryptedContentInfo.encryptedContent)if d.mac(p,M)~=P.content.mac then error(\"Could not authenticate data\",2)end;if(P.content.authEncryptedContentInfo.contentType.string or P.content.authEncryptedContentInfo.contentType)==a.pkcs7ContentTypeOIDs.data then return M end;return a.loadPKCS7(M)end;function i.encryptKey(j,C,D,E)D=D or h.sha256;local M=a.savePKCS8(j)local R={encryptionAlgorithm={type=a.passwordBasedEncryptionSchemeOIDs.PBES2,pbes2Parameters={encryptionScheme={type=a.encryptionAlgorithmOIDs.AES256_CBC,iv=e.random(16)},keyDerivationFunc={type=a.keyDerivationAlgorithmOIDs.PBKDF2,pbkdf2Parameters={salt={specified=e.random(16)},iterationCount=E or 4096,prf={type=\"\"}}}}},encryptedData=\"\"}local G;if D==h.sha1 then R.encryptionAlgorithm.pbes2Parameters.keyDerivationFunc.pbkdf2Parameters.prf.type=a.pseudoRandomFunctionOIDs.HMAC_SHA1;G=20 elseif D==h.sha224 then R.encryptionAlgorithm.pbes2Parameters.keyDerivationFunc.pbkdf2Parameters.prf.type=a.pseudoRandomFunctionOIDs.HMAC_SHA224;G=28 elseif D==h.sha256 then R.encryptionAlgorithm.pbes2Parameters.keyDerivationFunc.pbkdf2Parameters.prf.type=a.pseudoRandomFunctionOIDs.HMAC_SHA256;G=32 elseif D==h.sha384 then R.encryptionAlgorithm.pbes2Parameters.keyDerivationFunc.pbkdf2Parameters.prf.type=a.pseudoRandomFunctionOIDs.HMAC_SHA384;G=48 elseif D==h.sha512 then R.encryptionAlgorithm.pbes2Parameters.keyDerivationFunc.pbkdf2Parameters.prf.type=a.pseudoRandomFunctionOIDs.HMAC_SHA512;G=64 elseif D==h.sha512_224 then R.encryptionAlgorithm.pbes2Parameters.keyDerivationFunc.pbkdf2Parameters.prf.type=a.pseudoRandomFunctionOIDs.HMAC_SHA512_224;G=28 elseif D==h.sha512_256 then R.encryptionAlgorithm.pbes2Parameters.keyDerivationFunc.pbkdf2Parameters.prf.type=a.pseudoRandomFunctionOIDs.HMAC_SHA512_256;G=32 else error(\"Unknown hashing algorithm\",2)end;local p=b.pbkdf2(function(I,J)return{h.hmac(D,J,string.char(table.unpack(I))):byte(1,-1)}end,G,C,R.encryptionAlgorithm.pbes2Parameters.keyDerivationFunc.pbkdf2Parameters.salt.specified,E or 4096,32)R.encryptedData=g.TableToString(g.EncryptCBC(b.pkcs7pad(g.StringToTable(M),16),g.StringToTable(p),g.StringToTable(R.encryptionAlgorithm.pbes2Parameters.encryptionScheme.iv)))return R end;function i.decryptKey(R,C)local G,D,L;local S=R.encryptionAlgorithm.pbes2Parameters.keyDerivationFunc.pbkdf2Parameters.prf.type;local T=R.encryptionAlgorithm.pbes2Parameters.encryptionScheme.type;if type(S)==\"table\"then S=S.string end;if type(T)==\"table\"then T=T.string end;if S==a.pseudoRandomFunctionOIDs.HMAC_SHA1 then D=h.sha1;G=20 elseif S==a.pseudoRandomFunctionOIDs.HMAC_SHA224 then D=h.sha224;G=28 elseif S==a.pseudoRandomFunctionOIDs.HMAC_SHA256 then D=h.sha256;G=32 elseif S==a.pseudoRandomFunctionOIDs.HMAC_SHA384 then D=h.sha384;G=48 elseif S==a.pseudoRandomFunctionOIDs.HMAC_SHA512 then D=h.sha512;G=64 elseif S==a.pseudoRandomFunctionOIDs.HMAC_SHA512_224 then D=h.sha512_224;G=28 elseif S==a.pseudoRandomFunctionOIDs.HMAC_SHA512_256 then D=h.sha512_256;G=32 else error(\"Unknown hashing algorithm\",2)end;if T==a.encryptionAlgorithmOIDs.AES128_CBC then L=16 elseif T==a.encryptionAlgorithmOIDs.AES192_CBC then L=24 elseif T==a.encryptionAlgorithmOIDs.AES256_CBC then L=32 else error(\"Unknown encryption algorithm\",2)end;local p=b.pbkdf2(function(I,J)return{h.hmac(D,J,string.char(table.unpack(I))):byte(1,-1)}end,G,C,R.encryptionAlgorithm.pbes2Parameters.keyDerivationFunc.pbkdf2Parameters.salt.specified,R.encryptionAlgorithm.pbes2Parameters.keyDerivationFunc.pbkdf2Parameters.iterationCount,L)return a.loadPKCS8(g.TableToString(b.pkcs7unpad(g.DecryptCBC(g.StringToTable(R.encryptedData),g.StringToTable(p),g.StringToTable(R.encryptionAlgorithm.pbes2Parameters.encryptionScheme.iv)))))end;return i\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292481,size=11075},["chain.lua"]={type="file",created=1740881292486,worldPermissions={execute=false,read=true,write=false},data="local a=require\"system.expect\"local b=require\"system.filesystem\"local c=require\"ccryptolib.ed25519\"local d=require\"container\"local e=require\"cert.util\"local f={}local function g(h,i,j)local k,l;for m,n in ipairs(i)do if e.compareNames(n.toBeSigned.subject,h.toBeSigned.issuer)then k,l=n,false end end;for m,n in ipairs(j)do if e.compareNames(n.toBeSigned.subject,h.toBeSigned.issuer)then k,l=n,true end end;if not k then return false,\"Could not find path to root\"end;local o=d.encodeX509InnerCertificate(h)if k.toBeSigned.subjectPublicKeyInfo.algorithm.type.string~=d.signatureAlgorithmOIDs.ED25519 then return false,\"Certificate has unsupported signature type\"end;if not c.verify(k.toBeSigned.subjectPublicKeyInfo.subjectPublicKey.data,o,h.signature.data)then return false,\"Could not verify signature of certificate\"end;if l then return true end;if e.compareNames(h.toBeSigned.subject,h.toBeSigned.issuer)then return false,\"Chain certificate is self-signed\"end;return g(k,i,j)end;function f.validate(h,i,p,q)a(1,h,\"table\")a(2,i,\"table\",\"nil\")p=a(3,p,\"string\",\"nil\")or\"/etc/certs\"a(4,q,\"table\",\"nil\")local j={}if q then for m,n in ipairs(q)do j[#j+1]=n end end;if p~=\"\"and b.isDir(p)then for m,r in ipairs(b.list(p))do if b.isFile(b.combine(p,r))then local s=io.open(b.combine(p,r),\"rb\")if s then local t=s:read(\"*a\")s:close()if t:match(\"^%-%-%-%-%-BEGIN\")then t=d.decodePEM(t)end;local u,v=pcall(d.loadX509,t)if u then j[#j+1]=v end end end end end;return g(h,i or{},j)end;return f\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292480,size=1483}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881292490,size=0},["usermgr.lua"]={type="file",created=1740881294445,worldPermissions={execute=false,read=true,write=false},data="local a=require\"system.expect\"local b=require\"system.ipc\"local c=require\"system.process\"local d={}local e;local function f(g,h)if not e then e=b.lookup(\"usermgr\")end;if not e then error(\"Could not connect to user authentication service\",2)end;b.sendEvent(e,\"usermgr.request.\"..g,h)local i,j=b.receiveEvent(e,\"usermgr.response.\"..g,5)if not j then error(\"Timed out waiting for user authentication service\",2)end;return j end;function d.authenticate(k,l)a(1,k,\"string\")a(2,l,\"string\")if c.getuser()~=\"root\"then error(\"Permission denied\",2)end;local m=f(\"authenticate\",{user=k,password=l})return m.result or false,m.error or m.message end;function d.getUserInfo(k)a(1,k,\"string\")local m=f(\"getUserInfo\",{user=k})if m.error then error(m.error,2)end;return m.result end;function d.addUser(k,l,n)a(1,k,\"string\")a(2,l,\"string\",\"nil\")n=a(3,n,\"table\",\"nil\")or{}a.field(n,\"fullName\",\"string\",\"nil\")a.field(n,\"home\",\"string\",\"nil\")a.field(n,\"shell\",\"string\",\"nil\")n.user=k;n.password=l;if c.getuser()~=\"root\"then error(\"Permission denied\",2)end;local m=f(\"addUser\",n)if m.error then error(m.error,2)end;return m.result or false end;function d.removeUser(k)a(1,k,\"string\")if c.getuser()~=\"root\"then error(\"Permission denied\",2)end;local m=f(\"removeUser\",{user=k})if m.error then error(m.error,2)end;return m.result or false end;function d.editUser(k,n)a(1,k,\"string\")a(2,n,\"table\")a.field(n,\"fullName\",\"string\",\"nil\")a.field(n,\"home\",\"string\",\"nil\")a.field(n,\"shell\",\"string\",\"nil\")n.user=k;local o=c.getuser()if o~=\"root\"and o~=k then error(\"Permission denied\",2)end;local m=f(\"editUser\",n)if m.error then error(m.error,2)end;return m.result or false end;function d.setPassword(k,l,n)a(1,k,\"string\")a(2,l,\"string\",\"nil\")n=a(3,n,\"table\",\"nil\")or{}a.field(n,\"nextChange\",\"number\",\"nil\")a.field(n,\"expirationTime\",\"number\",\"nil\")a.field(n,\"expirationWarning\",\"number\",\"nil\")a.field(n,\"lockTime\",\"number\",\"nil\")a.field(n,\"isLocked\",\"boolean\",\"nil\")if c.getuser()~=\"root\"then error(\"Permission denied\",2)end;n.user,n.password=k,l;local m=f(\"setPassword\",n)if m.error then error(m.error,2)end;return m.result or false end;return d\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881294390,size=2114},["asn1.lua"]={type="file",created=1740881291313,worldPermissions={execute=false,read=true,write=false},data="local a={}local function b(c)local d={tag=c:byte(),len=c:byte(2)}local e=2;assert(bit32.band(d.tag,0x1F)~=0x1F)if bit32.btest(d.len,0x80)then e=2+bit32.band(d.len,0x7F)if e<3 then error('Invalid long length encoding')end;d.len=0;for f,g in ipairs{c:byte(3,e)}do d.len=bit32.bor(bit32.lshift(d.len,8),g)end end;d.total_len=e+d.len;return d,c:sub(e+1,-1)end;local function h(i,j)local k=type(i)if k~=j then error('Invalid value ('..j..' expected, got '..k..')')end end;local function l(m,n,o)if not o then o={}end;local function p(c)return m(c,o)end;local function q(r)return n(r,o)end;return setmetatable({_decode=p,decode=function(c)local r=p(c)if r~=nil then return r end;if not o.optional then error('DER data does not conform to type definition')end end,encode=q,extend=function(s,t)return l(function(c)return s(p(c))end,function(r)return q(t(r))end,o)end,_params=o},{__call=function(j,u)if u then if u.tag and not u.class then u.class='context'end;setmetatable(u,{__index=o})else u=o end;return l(m,n,u)end})end;local function v(m,n)local function w(o)assert(o.tag<0x1F)local x=bit32.bor(({universal=0x00,context=0x80})[o.class],o.tag)if o.constructed then x=bit32.bor(x,0x20)end;return x end;local function y(r,z)return(not z.min or r>=z.min)and(not z.max or r<=z.max)end;local function A(r,o)return not o.size or y(#r,o.size)end;return l(function(c,o)local d,c=b(c)if#c~=d.len then error('Data length ('..#c..') does not match with the DER-encoded length ('..d.len..')')return end;if o.tag~=nil and d.tag~=w(o)then return end;local r=m(c,o)if A(r,o)and y(r,o)then return r end end,function(r,o)if o.value_type then h(r,o.value_type)end;if not A(r,o)then error('Value to be encoded is of invalid length ('..#r..')')end;if not y(r,o)then error('Value to be encoded is outside the allowed range ('..r..')')end;local c=n(r,o)local B=#c;local C={}if B<0x80 then C[1]=B else while B>0 do table.insert(C,1,bit32.band(B,0xFF))B=bit32.rshift(B,8)end;table.insert(C,1,bit32.bor(0x80,#C))end;return string.char(w(o),table.unpack(C))..c end)end;local function D(w)local function E(F)return F end;return v(E,E){class='universal',constructed=false,tag=w,value_type='string'}end;local function G(m,n)return v(m,n){class='universal',constructed=true,tag=0x10,value_type='table'}end;local function H(m,n)return v(m,n){class='universal',constructed=true,tag=0x11,value_type='table'}end;function a.choice(I)return l(function(c)for f,J in ipairs(I)do local r=J[2]._decode(c)if r then return{[J[1]]=r}end end end,function(r)local c;for f,J in ipairs(I)do local i=r[J[1]]if i then if c then error('Ambiguous choice definition')end;c=J[2].encode(i)end end;if c then return c end;error('Value to be encoded does not conform to any choice alternative')end)end;function a.optional(K)return l(function(c)return K._decode(c)end,function(r)if r~=nil then return K.encode(r)end;return\"\"end,{optional=true})end;function a.default(K,L)return l(function(c)local r=K._decode(c)if r==nil then r=L end;return r end,function(r)if r~=nil then return K.encode(r)end;return\"\"end,{optional=true})end;a.any=l(function(i)return i end,function(i)return i end)a.null=v(function()return nil end,function()return\"\"end){class='universal',constructed=false,tag=0x05,value_type='nil',optional=true}a.boolean=v(function(c)return string.byte(c)~=0x00 end,function(r)return string.char(r and 0xFF or 0x00)end){class='universal',constructed=false,tag=0x01,value_type='boolean'}local M={__eq=function(N,g)return N.data==g.data end}a.integer=v(function(c)if#c>6 then return setmetatable({type=\"INTEGER\",data=c},M)end;local r=string.byte(c)assert(bit32.band(r,0x80)==0x00)for f,g in ipairs{string.byte(c,2,-1)}do r=r*256+g end;return r end,function(r)if type(r)==\"table\"and r.type==\"INTEGER\"then return r.data end;h(r,\"number\")if r~=math.floor(r)then error('Not an integer: '..r)end;assert(r>-1)local O={}while r>0 do table.insert(O,1,r%256)r=math.floor(r/256)end;if#O==0 then O[1]=0 end;if bit32.band(O[1],0x80)==0x80 then table.insert(O,1,0)end;return string.char(table.unpack(O))end){class='universal',constructed=false,tag=0x02}a.bit_string=v(function(c,o)local P=c:byte()if P>7 then error('Invalid DER encoding for unused bits')end;if not o.enum then return{type=\"BIT STRING\",data=c:sub(2),unused=P}end;local r=''while#c>1 do c=c:sub(2,-1)local Q=c:byte()for R=7,#c==1 and P or 0,-1 do local S=bit32.lshift(R,1)r=r..(bit32.band(Q,S)==S and'1'or'0')end end;local T={}for R=1,#r do T[o.enum[R]]=r:sub(R,R)=='1'end;return T end,function(r,o)if o.enum then h(r,'table')local F=''for f,U in ipairs(o.enum)do F=F..(r[U]and'1'or'0')end;r=F;local O={}local P=0;while r>''do local Q=0;P=8;while r>''and P>0 do P=P-1;Q=bit32.bor(Q,bit32.lshift(tonumber(r:sub(1,1),2),P))r=r:sub(2,-1)end;table.insert(O,Q)end;table.insert(O,1,P)return string.char(table.unpack(O))else h(r,'table')return string.char(r.unused)..r.data end end){class='universal',constructed=false,tag=0x03}a.octet_string=D(0x04)a.ia5string=D(0x16)a.printable_string=D(0x13)a.teletex_string=D(0x15)a.bmp_string=D(0x1E)a.universal_string=D(0x1C)a.utf8string=v(function(c)local V=\"\"for f,W in utf8.codes(c)do if W<256 then V=V..string.char(W)else V=V..\"\\x1A\"end end;return V end,function(r)h(r,\"string\")return utf8.char(r:byte(1,-1))end){class='universal',constructed=false,tag=0x0C}a.oid=v(function(c,o)local X=c:byte()local Y={type=\"OBJECT IDENTIFIER\",math.floor(X/40),X%40}local Z=2;while Z<=#c do local W=c:byte(Z)Z=Z+1;X=bit32.band(W,0x7F)while bit32.btest(W,0x80)do W=c:byte(Z)Z=Z+1;X=bit32.lshift(X,7)+bit32.band(W,0x7F)end;Y[#Y+1]=X end;Y.string=table.concat(Y,\".\")return Y end,function(r,o)if type(r)==\"string\"then local j={}for X in r:gmatch\"%d+\"do j[#j+1]=tonumber(X)end;r=j end;h(r,\"table\")local V=string.char(r[1]*40+r[2])for R=3,#r do local X=r[R]if X>0x7F then local O={}while X>0x7F do table.insert(O,1,bit32.band(X,0x7F)+0x80)X=bit32.rshift(X,7)end;table.insert(O,1,X+0x80)O[#O]=bit32.band(O[#O],0x7F)V=V..string.char(table.unpack(O))else V=V..string.char(X)end end;return V end){class='universal',constructed=false,tag=0x06}a.utc_time=v(function(c,o)local _,a,a0,a1,T,F,a2=c:match(\"(%d%d)(%d%d)(%d%d)(%d%d)(%d%d)(%d?%d?)Z?([%+%-]?%d*)\")_,a,a0=tonumber(_),tonumber(a),tonumber(a0)a1,T,F=tonumber(a1),tonumber(T),tonumber(F)or 0;if#a2>0 then local a3=a2:sub(1,1)==\"+\"and 1 or-1;a2=tonumber(a2:sub(2))a2=(a2%100+math.floor(a2/100)*60)*a3 else a2=0 end;return{type=\"UTCTime\",year=_+(_>=50 and 1900 or 2000),month=a,day=a0,hour=a1,min=T,sec=F,offset=0}end,function(r,o)return(\"%02d%02d%02d%02d%02d%02dZ\"):format(r.year%100,r.month,r.day,r.hour,r.min,r.sec or 0)end){class='universal',constructed=false,tag=0x17}a.generalized_time=v(function(c,o)local _,a,a0,a1,T,F,a2=c:match(\"(%d%d%d%d)(%d%d)(%d%d)(%d%d)(%d%d)(%d?%d?)Z?([%+%-]?%d*)\")_,a,a0=tonumber(_),tonumber(a),tonumber(a0)a1,T,F=tonumber(a1),tonumber(T),tonumber(F)or 0;if#a2>0 then local a3=a2:sub(1,1)==\"+\"and 1 or-1;a2=tonumber(a2:sub(2))a2=(a2%100+math.floor(a2/100)*60)*a3 else a2=0 end;return{type=\"GeneralizedTime\",year=_,month=a,day=a0,hour=a1,min=T,sec=F,offset=a2}end,function(r,o)return(\"%04d%02d%02d%02d%02d%02dZ\"):format(r.year,r.month,r.day,r.hour,r.min,r.sec or 0,r.offset)end){class='universal',constructed=false,tag=0x18}function a.explicit(w,a4)return v(function(c)return a4.decode(c)end,function(r)return a4.encode(r)end){class='context',constructed=true,tag=w}end;function a.implicit(w,a4)return a4{class='context',tag=w}end;function a.sequence(a5)return G(function(c)local r={}for f,a6 in ipairs(a5)do if#c==0 then if not a6[2]._params.optional then error(\"Incomplete sequence\")end else local d=b(c)local i;if a6[2]==a.any then i=c:sub(1,d.total_len)else i=a6[2].decode(c:sub(1,d.total_len))end;r[a6[1]]=i;if i~=nil then c=c:sub(d.total_len+1,-1)end end end;if#c>0 then error('Excess data after a DER-encoded sequence')end;return r end,function(r)local c=''for f,a6 in ipairs(a5)do if a6[2]==a.any then c=c..r[a6[1]]else c=c..a6[2].encode(r[a6[1]])end end;return c end)end;function a.sequence_of(a5)return G(function(c)local r={}while#c>0 do local d=b(c)table.insert(r,a5.decode(c:sub(1,d.total_len)))c=c:sub(d.total_len+1,-1)end;return r end,function(r)local c=''for f,a6 in ipairs(r)do c=c..a5.encode(a6)end;return c end)end;function a.set(a5)return H(function(c)local r={}for f,a6 in ipairs(a5)do local d=b(c)local i;if a6[2]==a.any then i=c:sub(1,d.total_len)else i=a6[2].decode(c:sub(1,d.total_len))end;r[a6[1]]=i;if i~=nil then c=c:sub(d.total_len+1,-1)end end;if#c>0 then error('Excess data after a DER-encoded sequence')end;return r end,function(r)local c=''for f,a6 in ipairs(a5)do if a6[2]==a.any then c=c..r[a6[1]]else c=c..a6[2].encode(r[a6[1]])end end;return c end)end;function a.set_of(a5)return H(function(c)local r={}while#c>0 do local d=b(c)table.insert(r,a5.decode(c:sub(1,d.total_len)))c=c:sub(d.total_len+1,-1)end;return r end,function(r)local t={}for f,a6 in ipairs(r)do t[#t+1]=a5.encode(a6)end;table.sort(t)return table.concat(t)end)end;function a.class(a5)return G(function(c)local r={}do local d=b(c)r.type=a.oid.decode(c:sub(1,d.total_len))c=c:sub(d.total_len+1,-1)end;local K=a5[r.type.string]if K==nil then error(\"Unknown type for class\")end;for f,a6 in ipairs(K)do if#c==0 then if not a6[2]._params.optional then error(\"Incomplete sequence\")end else local d=b(c)if a6[2]==a.any then r[a6[1]]=c:sub(1,d.total_len)else r[a6[1]]=a6[2].decode(c:sub(1,d.total_len))end;c=c:sub(d.total_len+1,-1)end end;if c>''then error('Excess data after a DER-encoded sequence')end;return r end,function(r)local c=a.oid.encode(r.type)local V=type(r.type)==\"string\"and r.type or r.type.string;local K=a5[V]if K==nil then error(\"Unknown type for class\")end;for f,a6 in ipairs(K)do if a6[2]==a.any then c=c..r[a6[1]]else c=c..a6[2].encode(r[a6[1]])end end;return c end)end;return a\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291311,size=9783},["tracc.lua"]={type="file",created=1740881294229,worldPermissions={execute=false,read=true,write=false},data="local a={interpolation=\"none\"}local b={banjo=3,basedrum=3,bass=1,bell=5,bit=3,chime=5,cow_bell=4,didgeridoo=1,flute=4,guitar=2,harp=3,hat=3,iron_xylophone=3,pling=3,snare=3,xylophone=5}local c={[0]=907,900,894,887,881,875,868,862,856,850,844,838,832,826,820,814,808,802,796,791,785,779,774,768,762,757,752,746,741,736,730,725,720,715,709,704,699,694,689,684,678,675,670,665,660,655,651,646,640,636,632,628,623,619,614,610,604,601,597,592,588,584,580,575,570,567,563,559,555,551,547,543,538,535,532,528,524,520,516,513,508,505,502,498,494,491,487,484,480,477,474,470,467,463,460,457,453}local d={[0]=1712,1616,1524,1440,1356,1280,1208,1140,1076,1016,960,907}local e=192;local function f()local g={channels={},version=2,interpolation=a.interpolation}for h=1,32 do g.channels[h]={frequency=0,volume=0,panning=0}end;function g.getFrequency(i)return g.channels[i].frequency end;function g.setFrequency(i,j)g.channels[i].frequency=j end;function g.getVolume(i)return g.channels[i].volume end;function g.setVolume(i,k)g.channels[i].volume=k end;function g.setWaveType(i,type,l,m,n,o)if type==\"none\"then g.channels[i].wavetable=nil elseif type==\"custom\"then if m>=#l then m=0 end;local p=g.channels[i]p.wavetable,p.pos,p.loopStart,p.loopType,p.dir=l,o and p.pos or 0,m or 0,n or 1,1 else error(\"Invalid wave type\",2)end end;function g.setPan(i,q)g.channels[i].pan=q end;function g.fadeOut(i,r)local s=g.channels[i]if r<-0.000001 then s.fadeSamplesInit=1-s.volume;s.fadeDirection=1;s.fadeSamples,s.fadeSamplesMax=-r*48000,-r*48000 elseif r<0.000001 then s.fadeSamplesInit=0.0;s.fadeSamples,s.fadeSamplesMax=0,0 else s.fadeSamplesInit=s.volume;s.fadeDirection=-1;s.fadeSamples,s.fadeSamplesMax=r*48000,r*48000 end end;function g.setPosition(i,q)g.channels[i].pos=q/#g.channels[i].wavetable%1 end;function g.setInterpolation(i,h)g.channels[i].interpolation=h end;local function t(u)return math.log(1+9*math.abs(u),10)end;function g.generate(v,w,x,y)local z,A,B={},{},{}for C=1,w do local D,E=0,0;local F=0;for h=1,x or 32 do local i=g.channels[h]local G=i.interpolation or g.interpolation;if i.wavetable and i.volume>0 and i.frequency>0 then local q=i.pos*#i.wavetable;local H;if G==\"none\"then H=i.wavetable[math.floor(q)+1]*i.volume elseif G==\"linear\"then H=(i.wavetable[math.floor(q)+1]+(i.wavetable[math.floor(q+1)%#i.wavetable+1]-i.wavetable[math.floor(q)+1])*(q-math.floor(q)))*i.volume end;if y then D,E=D+H*math.min(i.pan+1,1)*v.mixVolume,E+H*math.min(1-i.pan,1)*v.mixVolume;if B[h]then B[h][1],B[h][2]=B[h][1]+t(v.globalVolume/64*H*math.min(i.pan+1,1)*v.mixVolume),B[h][2]+t(v.globalVolume/64*H*math.min(1-i.pan,1)*v.mixVolume)else B[h]={t(v.globalVolume/64*H*math.min(i.pan+1,1)),t(v.globalVolume/64*H*math.min(1-i.pan,1)*v.mixVolume)}end else D=D+H*v.mixVolume;if B[h]then B[h][1],B[h][2]=B[h][1]+t(v.globalVolume/64*H),B[h][2]+t(v.globalVolume/64*H)else B[h]={t(v.globalVolume/64*H),t(v.globalVolume/64*H)}end end;i.pos=i.pos+i.frequency/48000*i.dir;if i.pos<0 then i.pos,i.dir=0,1 end;while i.pos>=1 do if i.loopType==0 then i.wavetable,i.pos=nil,0 elseif i.loopType==1 then i.pos=i.pos-1+i.loopStart/#i.wavetable else i.pos,i.dir=1-i.frequency/48000,-1 end end;if(i.fadeSamplesMax or 0)>0 then i.volume=i.volume+i.fadeSamplesInit/i.fadeSamplesMax*i.fadeDirection;i.fadeSamples=i.fadeSamples-1;if i.fadeSamples<=0 then i.fadeSamples,i.fadeSamplesMax=0,0;i.fadeSamplesInit=0.0;i.volume=i.fadeDirection==1 and 1 or 0 end end;F=F+1 end end;z[C]=math.max(math.min(v.globalVolume/64*D/2,1),-1)*127;A[C]=math.max(math.min(v.globalVolume/64*E/2,1),-1)*127 end;for h=1,x or 32 do B[h]=B[h]and{B[h][1]/w,B[h][2]/w}or{0,0}end;return z,A,B end;return g end;local function I(J)if not J then error(debug.traceback(\"Bad str\"),2)end;local u=0;for h=1,#J do u=u+bit32.lshift(J:byte(h),8*(h-1))end;return u end;local function K(v,L,M,D)if v.module.amigaSlides then local N=(L%12*8+math.floor(M/16))%96;return(v.type==\"xm\"and 14317456 or 14187580)/((c[N]*(1-M/16%1)+c[N+1]*(M/16%1))*16/2^math.floor(L/12-1))else return 8363*2^((6*12*16*4-(10*12*16*4-(L-1)*16*4-math.floor(M/2)))/(12*16*4))end end;local function O(v,P,Q,R)if R and v.type==\"xm\"then Q=Q*2 elseif R and v.type==\"s3m\"then Q=Q/2 end;if v.module.amigaSlides then local S=v.type==\"xm\"and 3579364 or 3546895;return S/(S/P-Q)else return P*2^(Q/e)end end;local function T(L,U)return L-12*(b[U]-1)-7 end;local function V(L)return 2^((L-49)/12)end;local function W(v,X,D)return v.sound.getFrequency(X)*#D.wavetable end;local function Y(v,X,j,D)v.sound.setFrequency(X,j/#D.wavetable)end;local function Z(v,X,k)X.volume=k;if not X.speaker then if v.mutedChannels[X.num]then v.sound.setVolume(X.num,0)else v.sound.setVolume(X.num,k/64*X.volumeEnvelope.volume/64*(X.instrument and X.instrument.volume or 1))end end end;local function _(v,X,a0)X.pan=a0;if not X.speaker then v.sound.setPan(X.num,-math.max((a0-127)/127,-1))end end;local function a1(v,X,a2)if not v.module.instruments[a2]then return end;X.instrument=v.module.instruments[a2]if#X.instrument.volumeEnvelope.points>0 then if#X.instrument.volumeEnvelope.points==1 or bit32.btest(X.instrument.volumeEnvelope.loopType,2)and X.instrument.volumeEnvelope.sustain==1 then X.volumeEnvelope={volume=X.instrument.volumeEnvelope.points[1].y,pos=1,x=0,sustain=true}else X.volumeEnvelope={volume=X.instrument.volumeEnvelope.points[1].y,pos=1,x=0,rate=(X.instrument.volumeEnvelope.points[2].y-X.instrument.volumeEnvelope.points[1].y)/(X.instrument.volumeEnvelope.points[2].x-X.instrument.volumeEnvelope.points[1].x)}end else X.volumeEnvelope={volume=64,pos=0,x=0}end;if#X.instrument.panningEnvelope.points>0 then if#X.instrument.panningEnvelope.points==1 or bit32.btest(X.instrument.panningEnvelope.loopType,2)and X.instrument.panningEnvelope.sustain==1 then X.panningEnvelope={panning=X.instrument.panningEnvelope.points[1].y,pos=1,x=0,sustain=true}else X.panningEnvelope={panning=X.instrument.panningEnvelope.points[1].y,pos=1,x=0,rate=(X.instrument.panningEnvelope.points[2].y-X.instrument.panningEnvelope.points[1].y)/(X.instrument.panningEnvelope.points[2].x-X.instrument.panningEnvelope.points[1].x)}end else X.panningEnvelope={panning=32,pos=0,x=0}end;if X.instrument.vibrato.sweep>0 then X.instrument.vibrato.sweep_mult=0 else X.instrument.vibrato.sweep_mult=1 end end;local function a3(v,X,L,o)X.speaker=nil;if L==97 or L>=254 then if not X.speaker then if X.instrument and#X.instrument.volumeEnvelope.points>1 and not(X.playing and X.playing.effect==0xE and X.playing.effect_param and bit32.band(X.playing.effect_param,0xF0)==0xD0)and X.instrument.fadeOut>0 then v.sound.fadeOut(X.num,32768/X.instrument.fadeOut*2.5/v.bpm)elseif X.instrument and#X.instrument.volumeEnvelope.points-1==X.instrument.volumeEnvelope.sustain then v.sound.fadeOut(X.num,(X.instrument.volumeEnvelope.points[#X.instrument.volumeEnvelope.points].x-X.instrument.volumeEnvelope.points[#X.instrument.volumeEnvelope.points-1].x)*2.5/v.bpm)else v.sound.setVolume(X.num,0)v.sound.setFrequency(X.num,0)X.frequency=0 end end;X.note=nil elseif L~=0 and X.instrument then local D=X.instrument.samples[L]if not D then elseif D.name==\"unused\"then if not X.speaker then v.sound.setVolume(X.num,0)end elseif not X.speaker and v.sound.version then X.finetune=D.finetune;X.frequency=K(v,L+D.note,X.finetune,D)v.sound.setWaveType(X.num,\"custom\",D.wavetable,D.loopStart,bit32.band(D.type,3),o)if D.name:byte(1)==33 then v.sound.setInterpolation(X.num,\"linear\")else v.sound.setInterpolation(X.num,nil)end;Y(v,X.num,X.frequency,D)elseif b[D.name]then local a4;for a5,a6 in ipairs(v.speakers)do if a6.usage<1 then a4=a6.speaker;a6.usage=a6.usage+1/a.notesPerTick;break end end;if not a4 then error(\"Not enough speakers to play module\")end;X.speaker=a4;v.sound.setVolume(X.num,0)if T(L,D.name)>=0 and T(L,D.name)<=24 and not v.mutedChannels[X.num]then a4.playNote(D.name,X.volume/64*v.globalVolume/64,T(L,D.name))end else local a4;for a5,a6 in ipairs(v.speakers)do if a6.usage==0 then a4=a6.speaker;a6.usage=1;break end end;if not a4 then error(\"Not enough speakers to play module\")end;X.speaker=a4;v.sound.setVolume(X.num,0)if not v.mutedChannels[X.num]then a4.playSound(D.name,X.volume/64*v.globalVolume/64,V(L))end end;X.note=L;X.didSetInstrument=true end end;local a7={function(a6)return math.max(a6-1,0)end,function(a6)return math.max(a6-2,0)end,function(a6)return math.max(a6-4,0)end,function(a6)return math.max(a6-8,0)end,function(a6)return math.max(a6-16,0)end,function(a6)return math.max(a6*2/3,0)end,function(a6)return math.max(a6/2,0)end,function(a6)return a6 end,function(a6)return math.min(a6+1,0)end,function(a6)return math.min(a6+2,0)end,function(a6)return math.min(a6+4,0)end,function(a6)return math.min(a6+8,0)end,function(a6)return math.min(a6+16,0)end,function(a6)return math.min(a6/(2/3),0)end,function(a6)return math.min(a6*2,0)end}local a8={[0]=function(v,X,a9)end,function(v,X,a9)if a9==0 then a9=X.effectMemory[0xE1]or 0 else X.effectMemory[0xE1]=a9 end;if not X.speaker and v.tick==1 and X.note then X.frequency=O(v,X.frequency,a9)Y(v,X.num,O(v,W(v,X.num,X.instrument.samples[X.note]),a9),X.instrument.samples[X.note])end end,function(v,X,a9)if a9==0 then a9=X.effectMemory[0xE2]or 0 else X.effectMemory[0xE2]=a9 end;if not X.speaker and v.tick==1 and X.note then X.frequency=O(v,X.frequency,-a9)Y(v,X.num,O(v,W(v,X.num,X.instrument.samples[X.note]),-a9),X.instrument.samples[X.note])end end,function(v,X,a9)end,function(v,X,a9)X.vibrato.type=a9 end,function(v,X,a9)if not X.speaker then X.finetune=a9;if X.playing then X.frequency=K(v,X.playing.note+X.instrument.samples[X.playing.note].note,X.finetune,X.instrument.samples[X.playing.note])Y(v,X.num,X.frequency,X.instrument.samples[X.playing.note])end end end,function(v,X,a9)if a9==0 then X.effectMemory[0xE6]=v.row else if not v.usedE6 or v.usedE6>0 then v.row=X.effectMemory[0xE6]or v.row;v.usedE6=(v.usedE6 or a9)-1 else v.usedE6=nil end end end,function(v,X,a9)end,function(v,X,a9)_(v,X,a9*16)end,function(v,X,a9)if a9>0 and v.tick>1 and(v.tick-1)%a9==0 then a3(v,X,X.playing.note or 97)end end,function(v,X,a9)if a9==0 then a9=X.effectMemory[0xEA]or 0 else X.effectMemory[0xEA]=a9 end;if v.tick==1 then Z(v,X,math.min(X.volume+math.floor(a9),64))end end,function(v,X,a9)if a9==0 then a9=X.effectMemory[0xEB]or 0 else X.effectMemory[0xEB]=a9 end;if v.tick==1 then Z(v,X,math.max(X.volume-a9,0))end end,function(v,X,a9)if v.tick==a9+1 then Z(v,X,0)end end,function(v,X,a9)if v.tick==1 then return 0 end;if v.tick-1==a9 then a3(v,X,X.playing.note)end end,function(v,X,a9)if not v.usedEE or v.usedEE>0 then local aa=v.usedEE~=nil;v.row=v.row-1;v.usedEE=(v.usedEE or a9)-1;if aa then return 0 end else v.usedEE=nil end end,function(v,X,a9)end}local ab={[0]=function(v,X,a9)end,function(v,X,a9)if a9==0 then a9=X.effectMemory[0x211]or 0 else X.effectMemory[0x211]=a9 end;if not X.speaker and v.tick==1 and X.note then X.frequency=O(v,X.frequency,a9/16)Y(v,X.num,O(v,W(v,X.num,X.instrument.samples[X.note]),a9/16),X.instrument.samples[X.note])end end,function(v,X,a9)if a9==0 then a9=X.effectMemory[0x212]or 0 else X.effectMemory[0x212]=a9 end;if not X.speaker and v.tick==1 and X.note then X.frequency=O(v,X.frequency,a9/-16)Y(v,X.num,O(v,W(v,X.num,X.instrument.samples[X.note]),a9/-16),X.instrument.samples[X.note])end end,function(v,X,a9)end,function(v,X,a9)end,function(v,X,a9)end,function(v,X,a9)end,function(v,X,a9)end,function(v,X,a9)v.order=math.huge end,function(v,X,a9)end,function(v,X,a9)end,function(v,X,a9)end,function(v,X,a9)end,function(v,X,a9)end,function(v,X,a9)end,function(v,X,a9)end}local function ac(v,X,ad,ae,af)local ag;if ad==0 then ag=math.sin(X.vibrato.pos*math.pi)elseif ad==1 then ag=X.vibrato.pos*2-1 elseif ad==2 then ag=X.vibrato.pos>=0.5 and-1 or 1 elseif ad==8 then ag=(1-X.vibrato.pos)*2-1 else ag=math.random()*2-1 end;if X.instrument and X.note then local D=X.instrument.samples[X.note]Y(v,X.num,O(v,X.frequency,ag*af*2),D)end;X.vibrato.pos=(X.vibrato.pos+ae/64)%1 end;local ah;ah={[0]=function(v,X,a9)if not X.instrument then return end;if v.tick%3==1 then a3(v,X,X.lastNote or X.playing.note,true)elseif v.tick%3==2 then a3(v,X,(X.lastNote or X.playing.note)+bit32.rshift(a9,4),true)else a3(v,X,(X.lastNote or X.playing.note)+bit32.band(a9,0xF),true)end end,function(v,X,a9)if a9==0 then a9=X.effectMemory[1]or 0 else X.effectMemory[1]=a9 end;if not X.speaker and v.tick>1 and X.note then X.frequency=O(v,X.frequency,a9)Y(v,X.num,O(v,W(v,X.num,X.instrument.samples[X.note]),a9),X.instrument.samples[X.note])end end,function(v,X,a9)if a9==0 then a9=X.effectMemory[2]or 0 else X.effectMemory[2]=a9 end;if not X.speaker and v.tick>1 and X.note then X.frequency=O(v,X.frequency,-a9)Y(v,X.num,math.max(O(v,W(v,X.num,X.instrument.samples[X.note]),-a9),0),X.instrument.samples[X.note])end end,function(v,X,a9)if a9==0 then a9=X.effectMemory[3]or 0 else X.effectMemory[3]=a9 end;if not X.speaker and X.note and X.instrument then local L=X.playing.note or X.lastNote;local D=X.instrument.samples[L]if D then if v.tick==1 and X.playing.note then L=X.lastNote;D=X.instrument.samples[L]if D then X.finetune=D.finetune;X.frequency=K(v,L+D.note,X.finetune,D)Y(v,X.num,X.frequency,D)if X.playing and X.playing.note then X.lastNote=X.playing.note end end;return 0 elseif X.frequency<O(v,K(v,L+D.note,D.finetune,D),-a9,true)then X.frequency=O(v,X.frequency,a9,true)Y(v,X.num,O(v,W(v,X.num,D),a9,true),D)elseif X.frequency>O(v,K(v,L+D.note,D.finetune,D),a9,true)then X.frequency=O(v,X.frequency,-a9,true)Y(v,X.num,O(v,W(v,X.num,D),-a9,true),D)elseif X.frequency~=K(v,L+D.note,D.finetune,D)then X.frequency=K(v,L+D.note,D.finetune,D)Y(v,X.num,X.frequency,D)end end end end,function(v,X,a9)if a9==0 then a9=X.effectMemory[4]or 0 else X.effectMemory[4]=a9 end;if v.tick==1 and X.playing and X.playing.note and bit32.btest(X.vibrato.type,4)then X.vibrato.pos=0 end;ac(v,X,bit32.band(X.vibrato.type,3),bit32.rshift(a9,4),bit32.band(a9,0x0f))end,function(v,X,a9)ah[0x3](v,X,0)return ah[0xA](v,X,a9)end,function(v,X,a9)ah[0x4](v,X,0)return ah[0xA](v,X,a9)end,function(v,X,a9)end,function(v,X,a9)_(v,X,a9)end,function(v,X,a9)if v.tick==1 and not v.mutedChannels[X.num]then v.sound.setPosition(X.num,a9*256)end end,function(v,X,a9)if a9==0 then a9=X.effectMemory[0xA]or 0 else X.effectMemory[0xA]=a9 end;if v.tick>1 then if a9<16 then Z(v,X,math.max(X.volume-a9,0))else Z(v,X,math.min(X.volume+math.floor(a9/16),64))end end end,function(v,X,a9)if v.tick==1 then v.order=a9+1;v.usedB=true end end,function(v,X,a9)Z(v,X,a9)end,function(v,X,a9)if v.tick==1 then v.row=bit32.rshift(a9,4)*10+bit32.band(a9,15)+1;v.usedD=true;if v.order==v.currentOrder and not v.usedB then if v.order==#v.module.order then v.order=1 else v.order=v.order+1 end end end end,function(v,X,a9)return a8[bit32.rshift(a9,4)](v,X,bit32.band(a9,0xF))end,function(v,X,a9)if a9<0x20 then if a9==0 then v.order=math.huge else v.tempo=a9 end else v.bpm=a9 end end,function(v,X,a9)v.globalVolume=math.min(math.max(a9,0),64)end,function(v,X,a9)if a9==0 then a9=X.effectMemory[0x11]or 0 else X.effectMemory[0x11]=a9 end;if v.tick>1 then if a9<16 then v.globalVolume=math.max(v.globalVolume-a9,0)else v.globalVolume=math.min(v.globalVolume+math.floor(a9/16),64)end;Z(v,X,X.volume)end end,function(v,X,a9)end,function(v,X,a9)end,function(v,X,a9)if v.tick==a9+1 then a3(v,X,97)end end,function(v,X,a9)if#X.instrument.volumeEnvelope.points>0 and X.instrument.volumeEnvelope.loopType%2==1 then X.volumeEnvelope.x=a9;X.volumeEnvelope.pos=1;while X.instrument.volumeEnvelope.points[X.volumeEnvelope.pos+1].x<a9 do X.volumeEnvelope.pos=X.volumeEnvelope.pos+1 end;if X.volumeEnvelope.pos+1>#X.instrument.volumeEnvelope.points or bit32.btest(X.instrument.volumeEnvelope.loopType,2)and X.volumeEnvelope.pos==X.instrument.volumeEnvelope.sustain then X.volumeEnvelope.sustain=true;X.volumeEnvelope.volume=X.instrument.volumeEnvelope.points[X.volumeEnvelope.pos].y else X.volumeEnvelope.volume=X.instrument.volumeEnvelope.points[X.volumeEnvelope.pos].y+(a9-X.instrument.volumeEnvelope.points[X.volumeEnvelope.pos].x)*X.volumeEnvelope.rate;X.volumeEnvelope.rate=(X.instrument.volumeEnvelope.points[X.volumeEnvelope.pos+1].y-X.instrument.volumeEnvelope.points[X.volumeEnvelope.pos].y)/(X.instrument.volumeEnvelope.points[X.volumeEnvelope.pos+1].x-X.instrument.volumeEnvelope.points[X.volumeEnvelope.pos].x)end;Z(v,X,X.volumeEnvelope.volume)end end,function(v,X,a9)end,function(v,X,a9)end,function(v,X,a9)end,function(v,X,a9)if a9==0 then a9=X.effectMemory[0x19]or 0 else X.effectMemory[0x19]=a9 end;if v.tick==1 then if a9<16 then _(v,X,math.max(X.pan-a9,0))else _(v,X,math.min(X.pan+math.floor(a9/16),128))end end end,function(v,X,a9)end,function(v,X,a9)if a9==0 then a9=X.effectMemory[0x1B]or 0 else X.effectMemory[0x1B]=a9 end;if math.floor(a9/16)==0 then a9=a9+(X.effectMemory[0x1B0]or 0x80)else X.effectMemory[0x1B0]=bit32.band(a9,0xF0)end;if v.tick>1 and(v.tick-1)%(a9%16)==0 then Z(v,X,a7[math.floor(a9/16)](X.volume))a3(v,X,X.playing.note or 97)end end,function(v,X,a9)end,function(v,X,a9)end,function(v,X,a9)end,function(v,X,a9)end,function(v,X,a9)end,function(v,X,a9)return ab[bit32.rshift(a9,4)](v,X,bit32.band(a9,0xF))end,function(v,X,a9)end,function(v,X,a9)end,function(v,X,a9)end}local ai;ai={[0]=function(v,X,a9)end,function(v,X,a9)Z(v,X,a9)end,function(v,X,a9)return ai[1](v,X,a9+16)end,function(v,X,a9)return ai[1](v,X,a9+32)end,function(v,X,a9)return ai[1](v,X,a9+48)end,function(v,X,a9)return ai[1](v,X,64)end,function(v,X,a9)return ah[0xA](v,X,a9)end,function(v,X,a9)return ah[0xA](v,X,a9*16)end,function(v,X,a9)return a8[0xB](v,X,a9)end,function(v,X,a9)return a8[0xA](v,X,a9)end,function(v,X,a9)end,function(v,X,a9)end,function(v,X,a9)_(v,X,a9*16)end,function(v,X,a9)return ah[0x19](v,X,a9)end,function(v,X,a9)return ah[0x19](v,X,a9*16)end,function(v,X,a9)return ah[3](v,X,a9*16)end}function a.readXMFile(aj)local ak,al,am={},{},{}local U,an;local ao,ap,aq,ar,as;local at=64;if aj.read(17)~=\"Extended Module: \"then aj.close()error(\"Not an XM module\")end;U=aj.read(20):gsub(\"[ %z]+$\",\"\")aj.read()an=aj.read(20):gsub(\"[ %z]+$\",\"\")aj.read(2)local au=aj.seek()local av=I(aj.read(4))local aw=I(aj.read(2))ao=I(aj.read(2))ap=I(aj.read(2))local ax=I(aj.read(2))local ay=I(aj.read(2))as=not bit32.btest(aj.read(),1)aj.read()aq=I(aj.read(2))ar=I(aj.read(2))for h=1,aw do al[h]=aj.read()end;aj.seek(\"set\",au+av)for h=1,ax do ak[h]={}au=aj.seek()local az=I(aj.read(4))aj.read()local aA=I(aj.read(2))local aB=I(aj.read(2))if az>9 then aj.seek(\"set\",au+az)end;local aC=aj.seek()for aD=1,aA do ak[h][aD]={}for aE=1,ap do local aF=aj.read()if bit32.btest(aF,0x80)then if aF~=0x80 then ak[h][aD][aE]={}if bit32.btest(aF,0x01)then ak[h][aD][aE].note=aj.read()end;if bit32.btest(aF,0x02)then ak[h][aD][aE].instrument=aj.read()end;if bit32.btest(aF,0x04)then ak[h][aD][aE].volume=aj.read()end;if bit32.btest(aF,0x08)then ak[h][aD][aE].effect=aj.read()end;if bit32.btest(aF,0x10)then if not ak[h][aD][aE].effect then ak[h][aD][aE].effect=0 end;ak[h][aD][aE].effect_param=aj.read()end end else ak[h][aD][aE]={}ak[h][aD][aE].note=aF;ak[h][aD][aE].instrument=aj.read()ak[h][aD][aE].volume=aj.read()ak[h][aD][aE].effect=aj.read()ak[h][aD][aE].effect_param=aj.read()end end end;aj.seek(\"set\",aC+aB)end;for h=1,ay do local a2={}am[h]=a2;local aG=I(aj.read(4))a2.name=aj.read(22):gsub(\"[ %z]+$\",\"\")aj.read()local aH=I(aj.read(2))if aH>0 then a2.samples={}a2.samplesByNumber={}a2.volumeEnvelope={points={}}a2.panningEnvelope={points={}}a2.vibrato={}for C=1,aH do a2.samplesByNumber[C]={}end;local aI=I(aj.read(4))for C=1,96 do a2.samples[C]=a2.samplesByNumber[aj.read()+1]end;for C=1,12 do a2.volumeEnvelope.points[C]={x=I(aj.read(2)),y=I(aj.read(2))}end;for C=1,12 do a2.panningEnvelope.points[C]={x=I(aj.read(2)),y=I(aj.read(2))}end;for C=aj.read()+1,12 do a2.volumeEnvelope.points[C]=nil end;for C=aj.read()+1,12 do a2.panningEnvelope.points[C]=nil end;a2.volumeEnvelope.sustain=aj.read()+1;a2.volumeEnvelope.loopStart=aj.read()+1;a2.volumeEnvelope.loopEnd=aj.read()+1;a2.panningEnvelope.sustain=aj.read()+1;a2.panningEnvelope.loopStart=aj.read()+1;a2.panningEnvelope.loopEnd=aj.read()+1;a2.volumeEnvelope.loopType=aj.read()a2.panningEnvelope.loopType=aj.read()a2.vibrato.type=aj.read()if a2.vibrato.type==1 then a2.vibrato.type=2 elseif a2.vibrato.type==2 then a2.vibrato.type=1 elseif a2.vibrato.type==3 then a2.vibrato.type=8 end;a2.vibrato.sweep=aj.read()a2.vibrato.depth=aj.read()a2.vibrato.rate=aj.read()a2.vibrato.sweep_mult=0;a2.fadeOut=I(aj.read(2))aj.seek(\"cur\",aG-241)for C=1,aH do local D=a2.samplesByNumber[C]D.size=I(aj.read(4))D.loopStart=I(aj.read(4))D.loopLength=I(aj.read(4))D.volume=aj.read()D.finetune=aj.read()if D.finetune>0x7F then D.finetune=D.finetune-256 end;D.type=aj.read()if bit32.btest(D.type,0x20)then D.size,D.loopStart,D.loopLength=D.size/2,D.loopStart/2,D.loopLength/2 end;if D.loopLength==0 or D.loopLength>D.size then D.type=bit32.band(D.type,0xFC)end;D.pan=aj.read()D.note=aj.read()if D.note>0x7F then D.note=D.note-256 end;aj.read()D.name=aj.read(22):gsub(\"[ %z]+$\",\"\")aj.seek(\"cur\",aI-40)end;for C=1,aH do local D=a2.samplesByNumber[C]local aB=D.size;D.wavetable={}for i=1,bit32.btest(D.type,0x20)and 2 or 1 do if bit32.btest(D.type,0x10)then local aJ=0;for aK=1,aB/2 do local aL=I(aj.read(2))if aL>0x7FFF then aL=aL-0x10000 end;D.wavetable[aK],aJ=math.max(math.min((aJ+aL)/(aJ+aL>0 and 0x7FFF or 0x8000),1),-1),aJ+aL;while aJ>0x7FFF do aJ=aJ-0x10000 end;while aJ<-0x8000 do aJ=aJ+0x10000 end end else local aJ=0;for aK=1,aB do local aL=aj.read()if aL>0x7F then aL=aL-256 end;D.wavetable[aK],aJ=math.max(math.min((aJ+aL)/(aJ+aL>0 and 127 or 128),1),-1),aJ+aL;while aJ>127 do aJ=aJ-256 end;while aJ<-128 do aJ=aJ+256 end end end end end else aj.seek(\"cur\",aG-29)end end;local v={type=\"xm\",tempo=aq,bpm=ar,channels={},module={instruments=am,patterns=ak,order=al,name=U,tracker=an,amigaSlides=as,restartPosition=ao},speakers={},order=1,row=1,globalVolume=at,mutedChannels={},mixVolume=1,loop=true,sound=f()}for h=1,ap do v.channels[h]={num=h,effectMemory={},playing={note=0,instrument=0,volume=0,effect=0,effect_param=0},volume=64,volumeEnvelope={volume=64,pos=0,x=0},vibrato={type=0,pos=0}}end;return v end;local aM={\"Scream Tracker %d.%d%d\",\"Imago Orpheus %d.%d%d\",\"Impulse Tracker %d.%d%d\",\"Schism Tracker %d.%d%d\",\"OpenMPT %d.%d%d\",\"BeRoTracker %d.%d%d\",\"CreamTracker %d.%d%d\"}local function aN(F)if F==0x0208 then return\"Akord\"elseif F==0xCA00 then return\"Camoto/libgamemusic\"elseif F==0x4100 then return\"BeRoTracker\"end;local aO=aM[bit32.rshift(bit32.band(F,0xF000),12)]if aO then return aO:format(bit32.rshift(bit32.band(F,0x0F00),8),bit32.rshift(bit32.band(F,0xF0),4),bit32.band(F,0xF))else return\"Unknown\"end end;local aP={function(q)return 0x0F,q end,function(q)return 0x0B,q end,function(q)return 0x0D,q end,function(q,aQ)if q==0 then q=aQ.x end;aQ.x=q;local aR,aS=bit32.rshift(q,4),bit32.band(q,15)if aR==0 or aS==0 then return 0x0A,q elseif aR==0xF then return 0x0E,0xB0+aS elseif aS==0xF then return 0x0E,0xA0+aR end end,function(q,aQ)if q==0 then q=aQ.x end;aQ.x=q;local aR,aS=bit32.rshift(q,4),bit32.band(q,15)if aR==0xF then return 0x0E,0x20+aS elseif aR==0xE then return 0x21,0x20+aS else return 0x02,q end end,function(q,aQ)if q==0 then q=aQ.x end;aQ.x=q;local aR,aS=bit32.rshift(q,4),bit32.band(q,15)if aR==0xF then return 0x0E,0x10+aS elseif aR==0xE then return 0x21,0x10+aS else return 0x01,q end end,function(q)return 0x03,q end,function(q)return 0x04,q end,function(q,aQ)if q==0 then q=aQ.x end;aQ.x=q;return 0x1D,q end,function(q,aQ)if q==0 then q=aQ.x end;aQ.x=q;return 0x00,q end,function(q,aQ)if q==0 then q=aQ.x end;aQ.x=q;local aR,aS=bit32.rshift(q,4),bit32.band(q,15)if aR==0 or aS==0 then return 0x06,q elseif aR==0xF then return 0x04,0,0x80+aS elseif aS==0xF then return 0x04,0,0x90+aR end end,function(q,aQ)if q==0 then q=aQ.x end;aQ.x=q;local aR,aS=bit32.rshift(q,4),bit32.band(q,15)if aR==0 or aS==0 then return 0x05,q elseif aR==0xF then return 0x03,0,0x80+aS elseif aS==0xF then return 0x03,0,0x90+aR end end,function(q)end,function(q)end,function(q)return 0x09,q end,function(q)local aR,aS=bit32.rshift(q,4),bit32.band(q,15)if aR==0 then return 0x19,aS*16 elseif aS==0 then return 0x19,aR end end,function(q,aQ)if q==0 then q=aQ.x end;aQ.x=q;return 0x1B,q end,function(q,aQ)if q==0 then q=aQ.x end;aQ.x=q;return 0x07,q end,function(q)local aR,aS=bit32.rshift(q,4),bit32.band(q,15)if aR==1 then return 0x0E,0x30+aS elseif aR==2 then return 0x0E,0x50+aS elseif aR==3 then return 0x0E,0x40+aS elseif aR==4 then return 0x0E,0x70+aS elseif aR==5 or aR==6 or aR==9 or aR==10 then return 0x21,q elseif aR==8 or aR==0xC or aR==0xD or aR==0xE then return 0x0E,q elseif aR==0xB then return 0x0E,0x60+aS end;error(\"Unknown S effect\")end,function(q)if q>=0x20 then return 0x0F,q end end,function(q)end,function(q)return 0x10,q end,function(q)return 0x11,q end,function(q)return 0x08,math.min(q*2,255)end,function(q)return 0x22,q end,function(q)return 0x23,q end}function a.readS3MFile(aj)local ak,al,am,aT={},{},{},{}local U,an;local ao,ap,aq,ar,as;local at=64;U=aj.read(28):gsub(\"[ %z]+$\",\"\")aj.read()if aj.read()~=16 then aj.close()error(\"Not a valid XM/S3M module\")end;aj.read(2)local aw=I(aj.read(2))local ay=I(aj.read(2))local ax=I(aj.read(2))aj.read(2)an=aN(I(aj.read(2)))or\"Unknown\"if I(aj.read(2))~=2 then aj.close()error(\"Unsupported S3M module\")end;if aj.read(4)~=\"SCRM\"then aj.close()error(\"Not an S3M module\")end;at=aj.read()/256;aq=aj.read()ar=aj.read()ao=0;as=true;aj.read()aj.read()local aU=aj.read()==252;aj.read(10)for h=1,32 do local H=aj.read()if H==255 or ap then if not ap then ap=h-1 end else if bit32.btest(H,0x80)then aT[h]=true end;if bit32.btest(H,0x10)then aj.close()error(\"Unsupported S3M module\")end end end;if not ap then ap=32 end;for h=1,aw do local u=aj.read()al[h]=u end;local aV,aW={},{}for h=1,ay do aV[h]=I(aj.read(2))*16 end;for h=1,ax do aW[h]=I(aj.read(2))*16 end;for h=1,ay do local D={wavetable={},volume=64,pan=128}local a2={samples={},samplesByNumber={D},volumeEnvelope={points={},sustain=0,loopStart=0,loopEnd=0,loopType=0},panningEnvelope={points={},sustain=0,loopStart=0,loopEnd=0,loopType=0},vibrato={type=0,sweep=0,depth=0,rate=0,sweep_mult=0},fadeOut=0}for C=1,96 do a2.samples[C]=D end;am[h]=a2;aj.seek(\"set\",aV[h])aj.read(13)local aX=(aj.read()*65536+I(aj.read(2)))*16;D.size=I(aj.read(2))+I(aj.read(2))*65536;D.loopStart=I(aj.read(2))+I(aj.read(2))*65536;D.loopLength=I(aj.read(2))+I(aj.read(2))*65536-D.loopStart;D.volume=aj.read()aj.read()aj.read()local aY=aj.read()D.type=bit32.band(aY,0x01)+bit32.band(aY,0x04)*4;local aZ=I(aj.read(2))+I(aj.read(2))*65536;local L=12*math.log(aZ/8363,2)D.note=math.floor(L)D.finetune=math.floor((L-D.note)*127)aj.read(12)a2.name=aj.read(28):gsub(\"[ %z]+$\",\"\")D.name=a2.name;if aj.read(4)~=\"SCRS\"then end;aj.seek(\"set\",aX)if bit32.btest(aY,0x04)then for C=1,D.size do D.wavetable[C]=I(aj.read(2))-32768 end else for C=1,D.size do D.wavetable[C]=aj.read()-128 end end;if bit32.btest(aY,0x02)then aj.seek(\"cur\",D.size*bit32.btest(aY,0x04)/2)end end;for h=1,ax do local a_={}ak[h]=a_;aj.seek(\"set\",aW[h]+2)local aQ={}for aE=1,32 do aQ[aE]={x=0}end;for aD=1,64 do a_[aD]={}repeat local b0=aj.read()if b0~=0 then local aE=bit32.band(b0,0x1F)+1;a_[aD][aE]={}if bit32.btest(b0,0x20)then local u=aj.read()if u==254 then a_[aD][aE].note=97 elseif u<=96 then a_[aD][aE].note=bit32.rshift(u,4)*12+bit32.band(u,15)+1 end;u=aj.read()if u~=0 then a_[aD][aE].instrument=u end end;if bit32.btest(b0,0x40)then local a6=aj.read()if a6~=255 then a_[aD][aE].volume=a6+0x10 end end;if bit32.btest(b0,0x80)then local b1,q=aj.read(),aj.read()if b1~=0 and aP[b1]then local b2,b3,b4=aP[b1](q,aQ[aE])a_[aD][aE].effect,a_[aD][aE].effect_param=b2,b3;if b4 and not a_[aD][aE].volume then a_[aD][aE].volume=b4 end end end end until b0==0 end end;local v={type=\"s3m\",tempo=aq,bpm=ar,channels={},module={instruments=am,patterns=ak,order=al,name=U,tracker=an,amigaSlides=as,restartPosition=ao},speakers={},order=1,row=1,globalVolume=at,mutedChannels=aT,mixVolume=1,loop=true,sound=f()}for h=1,ap do v.channels[h]={num=h,effectMemory={},playing={note=0,instrument=0,volume=0,effect=0,effect_param=0},volume=64,volumeEnvelope={volume=64,pos=0,x=0},vibrato={type=0,pos=0}}end;return v end;local b5={[0]=\"Impulse Tracker %d.%d%d\",\"Schism Tracker %d.%d%d\",nil,nil,\"pyIT %d.%d%d\",\"OpenMPT %d.%d%d\",\"BeRoTracker %d.%d%d\",\"ITMCK %d.%d.%d\",\"Tralala %d.%d%d\",nil,nil,nil,\"ChickDune ChipTune Tracker %d.%d%d\"}local function b6(F)if F==0x7FFF then return\"munch.py\"elseif F==0xDAEB then return\"spc2it\"end;local aO=b5[bit32.rshift(bit32.band(F,0xF000),12)]if aO then return aO:format(bit32.rshift(bit32.band(F,0x0F00),8),bit32.rshift(bit32.band(F,0xF0),4),bit32.band(F,0xF))else return\"Unknown\"end end;local b7=setmetatable({},{__index=aP})function a.readITFile(aj)local ak,al,am,aT={},{},{},{}local U,an;local ao,ap,aq,ar,as,b8;local at=64;if aj.read(4)~=\"IMPM\"then aj.close()error(\"Not an IT module\")end;U=aj.read(26):gsub(\"[ %z]+$\",\"\")aj.read(2)local aw=I(aj.read(2))local ay=I(aj.read(2))local aH=I(aj.read(2))local ax=I(aj.read(2))an=b6(I(aj.read(2)))or\"Unknown\"local b9=I(aj.read(2))local ba=I(aj.read(2))aj.read(2)at=aj.read()/2;b8=aj.read()/128;aq=aj.read()ar=aj.read()aj.read()ao=0;as=not bit32.btest(ba,8)aj.read(11)for h=1,64 do local H=aj.read()if H==255 or ap then else if bit32.btest(H,0x80)then if not ap then ap=h-1 end;aT[h]=true else ap=nil end end end;b8=b8/ap;aj.read(64)if not ap then ap=32 end;for h=1,aw do local u=aj.read()al[h]=u end;local aV,aW,bb={},{},{}for h=1,ay do aV[h]=I(aj.read(4))end;for h=1,aH do bb[h]=I(aj.read(4))end;for h=1,ax do aW[h]=I(aj.read(4))end;local bc={}for h=1,aH do local D={wavetable={},volume=64,pan=128}bc[h]=D;aj.seek(\"set\",bb[h])assert(aj.read(4)==\"IMPS\",\"Invalid file\")aj.read(12)aj.read()D.globalVolume=aj.read()local aY=aj.read()D.type=(bit32.btest(aY,0x10)and(bit32.btest(aY,0x40)and 2 or 1)or 0)+(bit32.btest(aY,2)and 0x10 or 0)D.volume=aj.read()D.name=aj.read(26):gsub(\"[ %z]+$\",\"\")local bd=I(aj.read(2))local aB=I(aj.read(4))D.loopStart=I(aj.read(4))D.loopLength=I(aj.read(4))-D.loopStart;local be=I(aj.read(4))local L=12*math.log(be/8363,2)D.note=math.ceil(L-0.5)D.finetune=math.floor((L-D.note)*127)aj.read(8)local bf=I(aj.read(4))D.vibrato={sweep=aj.read(),depth=aj.read(),type=aj.read(),rate=aj.read(),sweep_mult=0}aj.seek(\"set\",bf)local bg=bit32.btest(bd,1)local bh=bit32.btest(aY,2)local bi=bh and 32768 or 128;local bj=bg and bi or 0;local bk;if bh then if bit32.btest(bd,2)then bk=\">\"else bk=\"<\"end;if bg then bk=bk..\"h\"else bk=bk..\"H\"end else if bg then bk=\"b\"else bk=\"B\"end end;local bl=bk:packsize()local bm=bit32.btest(bd,0xC)local aJ=0;for C=1,aB do local u=bk:unpack(aj.read(bl))-bj;if bm then u=aJ+u end;aJ=u;u=u/(u<0 and bi or bi-1)D.wavetable[C]=u end end;for h=1,ay do local a2={samples={},samplesByNumber={},volumeEnvelope={points={},sustain=0,loopStart=0,loopEnd=0,loopType=0},panningEnvelope={points={},sustain=0,loopStart=0,loopEnd=0,loopType=0},pitchEnvelope={points={},sustain=0,loopStart=0,loopEnd=0,loopType=0},vibrato={type=0,sweep=0,depth=0,rate=0,sweep_mult=0},fadeOut=0}am[h]=a2;aj.seek(\"set\",aV[h])assert(aj.read(4)==\"IMPI\",\"Invalid file\")aj.read(13)aj.read(3)a2.fadeOut=I(aj.read(2))*128;aj.read(2)a2.volume=aj.read()/64;aj.read()aj.read(6)a2.name=aj.read(26):gsub(\"[ %z]+$\",\"\")aj.read(6)for C=0,119 do aj.read()local u=aj.read()a2.samples[C]=bc[u]if a2.samples[C]then a2.vibrato=a2.samples[C].vibrato end end;do local type=aj.read()a2.volumeEnvelope.loopType=bit32.band(type,1)+(bit32.btest(type,4)and 2 or 0)+(bit32.btest(type,2)and 4 or 0)local bn=aj.read()a2.volumeEnvelope.loopStart=aj.read()+1;a2.volumeEnvelope.loopEnd=aj.read()+1;a2.volumeEnvelope.sustain=aj.read()+1;aj.read()for C=1,bn do a2.volumeEnvelope.points[C]={y=aj.read(),x=I(aj.read(2))}end;aj.read((25-bn)*3+1)end;do local type=aj.read()a2.panningEnvelope.loopType=bit32.band(type,1)+(bit32.btest(type,4)and 2 or 0)+(bit32.btest(type,2)and 4 or 0)local bn=aj.read()a2.panningEnvelope.loopStart=aj.read()+1;a2.panningEnvelope.loopEnd=aj.read()+1;a2.panningEnvelope.sustain=aj.read()+1;aj.read()for C=1,bn do a2.panningEnvelope.points[C]={y=(\"b\"):unpack(aj.read(1))+32,x=I(aj.read(2))}end;aj.read((25-bn)*3+1)end;do local type=aj.read()a2.pitchEnvelope.loopType=bit32.band(type,1)+(bit32.btest(type,4)and 2 or 0)+(bit32.btest(type,2)and 4 or 0)local bn=aj.read()a2.pitchEnvelope.loopStart=aj.read()+1;a2.pitchEnvelope.loopEnd=aj.read()+1;a2.pitchEnvelope.sustain=aj.read()+1;aj.read()for C=1,bn do a2.pitchEnvelope.points[C]={y=aj.read(),x=I(aj.read(2))}end;aj.read((25-bn)*3+1)end end;for h=1,ax do aj.seek(\"set\",aW[h]+2)ak[h]={}local aA=I(aj.read(2))aj.read(4)local bo,bp,bq,br,bs={},{},{},{},{}local aQ={}for aE=1,ap do aQ[aE]={x=0}end;for aD=1,aA do ak[h][aD]={}while true do local aE=aj.read()if aE==0 then break end;local aF=bit32.btest(aE,0x80)and aj.read()or bo[bit32.band(aE,0x3F)]aE=bit32.band(aE,0x3F)if aF~=0 then ak[h][aD][aE]={}if bit32.btest(aF,0x01)then bp[aE]=aj.read()if bp[aE]<254 then bp[aE]=bp[aE]-11 end;ak[h][aD][aE].note=bp[aE]end;if bit32.btest(aF,0x02)then bq[aE]=aj.read()ak[h][aD][aE].instrument=bq[aE]end;if bit32.btest(aF,0x04)then local a6=aj.read()if a6<=0x40 then a6=a6+0x10 elseif a6>=0x80 and a6<0xC0 then a6=0xC0+bit32.rshift(a6-0x80,2)elseif a6>=65 and a6<=74 then a6=0x80+a6-65 elseif a6>=75 and a6<=84 then a6=0x90+a6-75 elseif a6>=85 and a6<=94 then a6=0x60+a6-85 elseif a6>=95 and a6<=104 then a6=0x70+a6-95 elseif a6>=105 and a6<=114 then a6=0xD0+a6-105 elseif a6>=115 and a6<=124 then a6=0xE0+a6-115 elseif a6>=193 and a6<=203 then a6=0xF0+a6-193 elseif a6>=203 and a6<=213 then a6=0xB0+a6-213 end;br[aE]=a6;ak[h][aD][aE].volume=br[aE]end;if bit32.btest(aF,0x08)then bs[aE]={aj.read(),aj.read()}ak[h][aD][aE].effect,ak[h][aD][aE].effect_param=b7[bs[aE][1]](bs[aE][2],aQ)end;if bit32.btest(aF,0x10)then ak[h][aD][aE].note=bp[aE]end;if bit32.btest(aF,0x20)then ak[h][aD][aE].instrument=bq[aE]end;if bit32.btest(aF,0x40)then ak[h][aD][aE].volume=br[aE]end;if bit32.btest(aF,0x80)then ak[h][aD][aE].effect,ak[h][aD][aE].effect_param=b7[bs[aE][1]](bs[aE][2],aQ)end end;bo[aE]=aF end end end;local v={type=\"it\",tempo=aq,bpm=ar,channels={},module={instruments=am,patterns=ak,order=al,name=U,tracker=an,amigaSlides=as,restartPosition=ao},speakers={},order=1,row=1,globalVolume=at,mutedChannels=aT,mixVolume=b8,loop=true,sound=f()}for h=1,ap do v.channels[h]={num=h,effectMemory={},playing={note=0,instrument=0,volume=0,effect=0,effect_param=0},volume=64,volumeEnvelope={volume=64,pos=0,x=0},vibrato={type=0,pos=0}}end;return v end;local function bt(v,b1,bu,E,B)for a5,i in ipairs(v.channels)do if b1 and i.playing and i.playing.effect then ah[i.playing.effect](v,i,i.playing.effect_param or 0)end;if b1 and i.playing and i.playing.volume and i.playing.volume>0x50 then ai[math.floor(i.playing.volume/16)](v,i,i.playing.volume%16)end;if i.instrument and i.instrument.volumeEnvelope.loopType%2==1 and i.volumeEnvelope.pos>0 and not i.volumeEnvelope.sustain and i.note then i.volumeEnvelope.x=i.volumeEnvelope.x+1;i.volumeEnvelope.volume=i.volumeEnvelope.volume+i.volumeEnvelope.rate;if i.volumeEnvelope.x==i.instrument.volumeEnvelope.points[i.volumeEnvelope.pos+1].x then i.volumeEnvelope.pos=i.volumeEnvelope.pos+1;if bit32.btest(i.instrument.volumeEnvelope.loopType,4)and i.volumeEnvelope.pos==i.instrument.volumeEnvelope.loopEnd then i.volumeEnvelope.pos=i.instrument.volumeEnvelope.loopStart;i.volumeEnvelope.x=i.instrument.volumeEnvelope.points[i.volumeEnvelope.pos].x end;i.volumeEnvelope.volume=i.instrument.volumeEnvelope.points[i.volumeEnvelope.pos].y;if i.volumeEnvelope.pos>=#i.instrument.volumeEnvelope.points or bit32.btest(i.instrument.volumeEnvelope.loopType,2)and i.volumeEnvelope.pos==i.instrument.volumeEnvelope.sustain then i.volumeEnvelope.sustain=true else i.volumeEnvelope.rate=(i.instrument.volumeEnvelope.points[i.volumeEnvelope.pos+1].y-i.instrument.volumeEnvelope.points[i.volumeEnvelope.pos].y)/(i.instrument.volumeEnvelope.points[i.volumeEnvelope.pos+1].x-i.instrument.volumeEnvelope.points[i.volumeEnvelope.pos].x)end end;Z(v,i,i.volume)end;if i.instrument and i.instrument.panningEnvelope.loopType%2==1 and not i.panningEnvelope.sustain and i.note then i.panningEnvelope.x=i.panningEnvelope.x+1;i.panningEnvelope.panning=i.panningEnvelope.panning+i.panningEnvelope.rate;if i.panningEnvelope.x==i.instrument.panningEnvelope.points[i.panningEnvelope.pos+1].x then i.panningEnvelope.pos=i.panningEnvelope.pos+1;if bit32.btest(i.instrument.panningEnvelope.loopType,4)and i.panningEnvelope.pos==i.instrument.panningEnvelope.loopEnd then i.panningEnvelope.pos=i.instrument.panningEnvelope.loopStart;i.panningEnvelope.x=i.instrument.panningEnvelope.points[i.panningEnvelope.pos].x end;i.panningEnvelope.panning=i.instrument.panningEnvelope.points[i.panningEnvelope.pos].y;if i.panningEnvelope.pos+1>#i.instrument.panningEnvelope.points or bit32.btest(i.instrument.panningEnvelope.loopType,2)and i.panningEnvelope.pos==i.instrument.panningEnvelope.sustain then i.panningEnvelope.sustain=true else i.panningEnvelope.rate=(i.instrument.panningEnvelope.points[i.panningEnvelope.pos+1].y-i.instrument.panningEnvelope.points[i.panningEnvelope.pos].y)/(i.instrument.panningEnvelope.points[i.panningEnvelope.pos+1].x-i.instrument.panningEnvelope.points[i.panningEnvelope.pos].x)end end;_(v,i,i.panningEnvelope.panning*4)end;if i.instrument and i.instrument.vibrato.depth>0 then ac(v,i,i.instrument.vibrato.type,i.instrument.vibrato.rate/4,i.instrument.vibrato.depth*i.instrument.vibrato.sweep_mult/4)if i.instrument.vibrato.sweep_mult<1 then i.instrument.vibrato.sweep_mult=i.instrument.vibrato.sweep_mult+1/i.instrument.vibrato.sweep end end;i.didSetInstrument=false end;local bv,bw,bx=v.sound.generate(v,2.5/v.bpm*48000,#v.channels,E)local by,bz=#bu,E and#E;for h=1,#bv do bu[by+h]=bv[h]end;if E then for h=1,#bw do E[bz+h]=bw[h]end end;if B[1]then for h=1,#bx do B[h][1],B[h][2]=B[h][1]+bx[h][1],B[h][2]+bx[h][2]end else for h=1,#bx do B[h]=bx[h]end end;B.count=(B.count or 0)+1 end;function a.tick(v,y,bA,A,B)bA=bA or{}A=A or(y and{}or nil)B=B or{}if v.tick then if v.tick<v.tempo then v.tick=v.tick+1;bt(v,true,bA,A,B)return bA,A,B end;if v.order~=v.currentOrder then if not v.usedD then v.row=1 end;v.currentOrder=v.order elseif v.row==v.currentRow then v.row=v.row+1 end end;local a6=v.module.order[v.order]if not a6 then return nil end;while a6>=254 or v.row>#v.module.patterns[a6+1]do if v.order==v.currentOrder then v.row=1;v.order=v.order+1;if v.loop and v.order>#v.module.order then v.order=v.module.restartPosition+1 end end;v.currentOrder=v.order;a6=v.module.order[v.order]if not a6 then return nil end end;v.tick=1;v.currentRow=v.row;v.usedB,v.usedD=nil,nil;local bB=v.module.patterns[a6+1][v.row]if not bB then error(a6+1 ..\"/\"..v.row)end;for a5,aE in ipairs(v.speakers)do aE.usage=0 end;for aK,i in ipairs(v.channels)do i.playing=bB[aK]if i.playing then if i.playing.instrument and v.module.instruments[i.playing.instrument]then a1(v,i,i.playing.instrument)if(i.playing.note or i.lastNote)~=97 then _(v,i,i.instrument.samples[i.playing.note or i.lastNote].pan)end;if v.type~=\"xm\"and not(i.playing.note and i.playing.note~=0)and i.lastNote then a3(v,i,i.lastNote)Z(v,i,i.instrument.samples[i.lastNote].volume)end end;if i.playing.volume then ai[math.floor(i.playing.volume/16)](v,i,i.playing.volume%16)end;if i.playing.note and i.playing.note~=0 then if(not i.playing.volume or i.playing.volume<0x10 or i.playing.volume>=0x60)and i.playing.note<97 then Z(v,i,i.instrument.samples[i.playing.note].volume)end;if not i.playing.effect or i.playing.effect==9 or ah[i.playing.effect](v,i,i.playing.effect_param or 0)~=0 then if i.playing.note~=97 then i.lastNote=i.playing.note end;a3(v,i,i.playing.note)end end;if(not i.playing.note or i.playing.note==0 or i.playing.effect==9)and i.playing.effect then ah[i.playing.effect](v,i,i.playing.effect_param or 0)end end end;bt(v,false,bA,A,B)return bA,A,B end;function a.row(v,y,bA,A,B)bA=bA or{}A=A or(y and{}or nil)B=B or{}if not v.tick or v.tick>=v.tempo then if not a.tick(v,y,bA,A,B)then return nil end end;while v.tick<v.tempo do if not a.tick(v,y,bA,A,B)then return nil end end;return bA,A,B end;function a.play(v,bC,bD,...)local bE={...}if type(bC)==\"table\"then table.insert(bE,1,bC)bC=nil end;if type(bD)==\"table\"then table.insert(bE,1,bD)bD=nil end;local bF={}while true do local bA,A={},{}while#bA<(bD or 48000)do if not a.row(v,#bE>1,bA,A)then return end end;while next(bF)do local U;repeat local bG,a9=coroutine.yield()if bG==\"speaker_audio_empty\"then U=a9.device end until U;bF[U]=nil end;for h=1,#bE do bE[h].playAudio(h%2==1 and bA or A,bC)bF[peripheral.getName(bE[h])]=true end end end;function a.makeFile(bH)local bI=1;local bJ=false;return{readLine=function(bK)if bJ then error(\"attempt to use a closed file\",2)end;if bI>#bH then return nil end;local aL;aL,bI=bH:match(\"([^\\n]*\"..(bK and\"\\n?)\"or\")\\n?\")..\"()\",bI)return aL end,readAll=function()if bJ then error(\"attempt to use a closed file\",2)end;if bI>#bH then return nil end;local aL=bH:sub(bI)bI=#aL+1;return aL end,read=function(u)if bJ then error(\"attempt to use a closed file\",2)end;if u~=nil and type(u)~=\"number\"then error(\"bad argument #1 (expected number, got \"..type(u)..\")\",2)end;if bI>#bH then return nil end;if u then local aL=bH:sub(bI,bI+u-1)bI=bI+u;return aL else local aL=bH:byte(bI)bI=bI+1;return aL end end,seek=function(bL,bj)if bL~=nil and type(bL)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(bL)..\")\",2)end;if bj~=nil and type(bj)~=\"number\"then error(\"bad argument #2 (expected number, got \"..type(bj)..\")\",2)end;bL=bL or\"cur\"bj=bj or 0;if bJ then error(\"attempt to use closed file\",2)end;if bL==\"set\"then bI=bj+1 elseif bL==\"cur\"then bI=bI+bj elseif bL==\"end\"then bI=math.max(#bH-bj,1)else error(\"Invalid whence\",2)end;return bI-1 end,close=function()if bJ then error(\"attempt to use a closed file\",2)end;bJ=true end}end;return a\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881294226,size=41892},dpkg={type="directory",setuser=false,created=1740881291983,worldPermissions={write=false,read=true,execute=true},contents={["query.lua"]={type="file",created=1740881291982,worldPermissions={execute=false,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"control\"local function c(d)return string.match(d,'^()[%s%z]*$')and''or string.match(d,'^[%s%z]*(.*[^%s%z])')end;local e={status={not_installed=1,config_files=2,half_installed=3,unpacked=4,half_configured=5,triggers_awaited=6,triggers_pending=7,installed=8}}e.admindir=\"/var/lib/dpkg\"if not a.isDir(e.admindir)then a.mkdir(e.admindir)end;function e.readDatabase()local f=io.open(a.combine(e.admindir,\"status\"),\"r\")if f==nil then error(\"Couldn't find status file\")end;local g={{}}local h=nil;local d=1;for i in f:lines()do if i==\"\"then d=d+1;g[d]={}h=nil else if string.sub(i,1,1)==\" \"and h~=nil then if h==\"Description\"then if type(g[d][h])==\"string\"then g[d][h]={Short=g[d][h],Long=\"\"}end;g[d][h].Long=g[d][h].Long..(string.sub(i,2)==\".\"and\"\\n\\n\"or string.sub(i,2))else g[d][h]=g[d][h]..(string.sub(i,2)==\".\"and\"\\n\\n\"or string.sub(i,2))end else h=string.sub(i,1,(string.find(i,\":\")or 0)-1)g[d][h]=c(string.sub(i,(string.find(i,\":\")or-1)+1))end end end;f:close()local j={}for k,l in pairs(g)do if l.Package then j[l.Package]=l end end;return j end;function e.writeDatabase(m)a.copy(a.combine(e.admindir,\"status\"),a.combine(e.admindir,\"status-old\"))local f=a.open(a.combine(e.admindir,\"status\"),\"w\")if f==nil then error(\"Couldn't find status file\")end;local function n(l)if type(l)==\"table\"then return(l.Short or\"\")..\"\\n \"..string.gsub(l.Long or\"\",\"\\n\\n\",\"\\n .\\n\")else return l end end;for k,l in pairs(m)do if not(string.match(l.Status,\"(%S+) %S+ %S+\")==\"unknown\"and string.match(l.Status,\"%S+ %S+ (%S+)\")==\"not-installed\")then f.writeLine(\"Package: \"..k)for o,p in pairs(l)do if o~=\"Package\"and o~=\"Description\"then f.writeLine(o..\": \"..n(p))end end;if l.Description then f.writeLine(\"Description: \"..n(l.Description))end;f.writeLine(\"\")end end;f.close()end;function e.findPackage(q,r)r=r or e.readDatabase()for k,l in pairs(r)do if q==k then return l,r end end;return nil,r end;function e.readFileLists()local g={duplicates={}}local s=0;for t,l in ipairs(a.find(a.combine(e.admindir,\"info/*.list\")))do local u=string.match(l,\"info/(.+)%.list$\")local f=io.open(l,\"r\")for i in f:lines()do if g[i]~=nil and not a.isDir(i)then g.duplicates[i]=g.duplicates[i]or{}table.insert(g.duplicates[i],u)else g[i]=u;s=s+1 end end end;return g,s end;function e.status.configured(v)return v==\"triggers-pending\"or v==\"installed\"end;function e.status.present(v)return v~=\"not-installed\"and v~=\"config-files\"and v~=\"half-installed\"end;function e.status.needs_configure(v)return v==\"config-failed\"or v==\"half-configured\"or v==\"unpacked\"end;function e.status.get_number(v)for k,l in ipairs({\"not-installed\",\"config-files\",\"half-installed\",\"unpacked\",\"half-configured\",\"triggers-awaited\",\"triggers-pending\",\"installed\"})do if l==v then return k end end;return nil end;return e\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291958,size=2805},["trigger.lua"]={type="file",created=1740881291983,worldPermissions={execute=false,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=require\"query\"local d={}d.admindir=\"/var/lib/dpkg\"d.log=function(e)end;local f={}local function g(h)return a.combine(d.admindir,h)end;local function i(j,k)local l={}for m in string.gmatch(j,\"([^\"..(k or\"%s\")..\"]+)\")do table.insert(l,m)end;return l end;function d.list()return a.list(g(\"triggers\"))end;function d.lock()while a.exists(g(\"triggers/Lock\"))do coroutine.yield()end;local n=a.open(g(\"triggers/Lock\"),\"w\")n.write(\"Lock\")n.flush()return function()n.close()a.remove(g(\"triggers/Lock\"))if a.exists(g(\"triggers/Lock\"))then error(\"Lock still exists!\")end end end;function d.readDatabase()local n=io.open(g(\"triggers/File\"),\"r\")if not n then error(\"Missing trigger file\")end;local o=d.lock()local p={}for q in n:lines()do local r,s=string.match(q,\"([^ ]+) ([^ ]+)\")if r then p[r]={package=s,await=true}if string.find(s,\"/noawait\")then p[r].await=false end end end;n:close()o()return p end;function d.register(t,s,u)if u==nil then u=true end;local o=d.lock()if string.find(t,\"/\")then local n=a.open(g(\"triggers/File\"),a.exists(g(\"triggers/File\"))and\"a\"or\"w\")n.writeLine(t..\" \"..s..(not u and\"/noawait\"or\"\"))n.close()else local n=a.open(g(\"triggers/\"..t),\"w\")n.writeLine(s..(not u and\"/noawait\"or\"\"))n.close()end;o()end;function d.deregister(t)if string.find(t,\"/\")then local o=d.lock()local n=io.open(g(\"triggers/File\"),\"r\")if not n then return o()end;local p=\"\"for q in n:lines()do if not string.match(q,\"^\"..t..\" \")then p=p..q..\"\\n\"end end;n:close()n=a.open(g(\"triggers/File\"),\"w\")n.write(p)n.close()o()else a.remove(g(\"triggers/\"..t))end end;function d.activate(t,s,u,v,w)if u==nil then u=true end;if string.find(t,\"/\")then v=v or d.readDatabase()local x=false;for y,z in pairs(v)do if string.match(t,\"^\"..y)then x=z end end;if not x then return false end;u=u and x.await;w=w or c.readDatabase()local A,B,C=string.match(w[x.package].Status,\"([^ ]+) ([^ ]+) ([^ ]+)\")if C~=\"triggers-awaited\"then w[x.package].Status=A..\" \"..B..\" triggers-pending\"end;A,B,C=string.match(w[s].Status,\"([^ ]+) ([^ ]+) ([^ ]+)\")if u then w[s].Status=A..\" \"..B..\" triggers-awaited\"w[s][\"Triggers-Awaited\"]=(w[s][\"Triggers-Awaited\"]or\"\")..(w[s][\"Triggers-Awaited\"]and\" \"or\"\")..x.package end;w[x.package][\"Triggers-Pending\"]=(w[x.package][\"Triggers-Pending\"]or\"\")..(w[x.package][\"Triggers-Pending\"]and\" \"or\"\")..t;local o=d.lock()local n=io.open(g(\"triggers/Unincorp\"),\"r\")local D=a.open(g(\"triggers/Unincorp.new\"),\"w\")local E=false;for z in n:lines()do if not E and string.match(z,\"^\"..t..\" \")then E=true;if u then if string.match(z,\"[^ ]+ (.+)\")==\"-\"then z=t end;z=z..\" \"..s end end;D.writeLine(z)end;if not E then D.writeLine(t..\" \"..(u and s or\"-\"))end;n:close()D.close()a.remove(g(\"triggers/Unincorp\"))a.move(g(\"triggers/Unincorp.new\"),g(\"triggers/Unincorp\"))o()return true,v,w else if not a.exists(g(\"triggers/\"..t))then error(\"Invalid trigger \"..t,2)end;local n=io.open(g(\"triggers/\"..t),\"r\")if n==nil then error(\"Could not open trigger file\")end;w=w or c.readDatabase()local F;for q in n:lines()do if w[q]==nil then d.log(\"Package \"..q..\" is interested in trigger \"..t..\" but is not installed\")else local A,B,C=string.match(w[q].Status,\"([^ ]+) ([^ ]+) ([^ ]+)\")w[q].Status=A..\" \"..B..\" triggers-pending\"w[q][\"Triggers-Pending\"]=(w[q][\"Triggers-Pending\"]or\"\")..(w[q][\"Triggers-Pending\"]and\" \"or\"\")..t;A,B,C=string.match(w[s].Status,\"([^ ]+) ([^ ]+) ([^ ]+)\")if u then w[s].Status=A..\" \"..B..\" triggers-awaited\"w[s][\"Triggers-Awaited\"]=(w[s][\"Triggers-Awaited\"]or\"\")..(w[s][\"Triggers-Awaited\"]and\" \"or\"\")..q end;F=(F or\"\")..(F and\" \"or\"\")..q end end;n:close()local o=d.lock()n=io.open(g(\"triggers/Unincorp\"),\"r\")local D=a.open(g(\"triggers/Unincorp.new\"),\"w\")local E=false;for z in n:lines()do if not E and string.match(z,\"^\"..t..\" \")then E=true;if u then if string.match(z,\"[^ ]+ (.+)\")==\"-\"then z=t end;z=z..\" \"..s end end;D.writeLine(z)end;if not E then D.writeLine(t..\" \"..(u and s or\"-\"))end;n:close()D.close()a.remove(g(\"triggers/Unincorp\"))a.move(g(\"triggers/Unincorp.new\"),g(\"triggers/Unincorp\"))o()return true,v,w end end;function d.commit(s,v,w)w=w or c.readDatabase()if w[s]==nil then error(\"Package \"..s..\" not found\")end;local A,B,C=string.match(w[s].Status,\"([^ ]+) ([^ ]+) ([^ ]+)\")if w[s][\"Triggers-Pending\"]==nil or not c.status.configured(C)then return false,v,w end;local G=w[s][\"Triggers-Pending\"]w[s][\"Triggers-Pending\"]=nil;local H=b.run(g(\"info/\"..s..\".postinst\"),\"triggered\",G)w[s].Status=A..\" \"..B..(H and(w[s][\"Triggers-Awaited\"]and\" triggers-awaited\"or\" installed\")or\" config-failed\")local o=d.lock()local I=a.open(g(\"triggers/Unincorp.new\"),\"w\")for J in io.lines(g(\"triggers/Unincorp\"))do local K=string.gsub(G,string.find(G,string.match(J,\"^([^ ]+)\"),1,true))if K then for L,z in ipairs(i(string.match(J,\"^[^ ]+ (.+)\")))do if w[z]~=nil and w[z][\"Triggers-Awaited\"]~=nil then w[z][\"Triggers-Awaited\"]=string.gsub(string.gsub(w[z][\"Triggers-Awaited\"],\"( ?)\"..s..\"( ?)\",\"%1\"),\" $\",\"\")if w[z][\"Triggers-Awaited\"]==\"\"then w[z][\"Triggers-Awaited\"]=nil;w[z].Status=string.gsub(w[z].Status,\"triggers%-awaited\",\"installed\")end end end else I.writeLine(J)end end;I.close()a.remove(g(\"triggers/Unincorp\"))a.move(g(\"triggers/Unincorp.new\"),g(\"triggers/Unincorp\"))o()return H and 1 or 0,v,w end;return d\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291959,size=5278},["deb.lua"]={type="file",created=1740881291980,worldPermissions={execute=false,read=true,write=false},data="local a=require\"ar\"local b=require\"tar\"local c=require\"control\"local d=require\"LibDeflate\"local e=require\"muxzcat\"local f={verbose=false}function f.load(g,h,i)if f.verbose then print(\"Loading package...\")end;local j=a.load(g)if j==nil then error(\"Invalid deb file\",2)end;if#j<3 or j[1].name~=\"debian-binary\"or j[1].data~=\"2.0\\n\"then error(\"Invalid deb file\",2)end;local k,l,m;if f.verbose then print(\"Extracting control...\")end;if j[2].name==\"control.tar.gz\"then k,m=d:DecompressGzip(j[2].data)elseif j[2].name==\"control.tar.xz\"then k,m=e.DecompressXzOrLzmaString(j[2].data)else error(\"Unsupported compression format: \"..j[2].name)end;if k==nil then error(\"Could not decompress control file: \"..m)end;local n=b.load(k,false,true)if n[\".\"]~=nil then n=n[\".\"]end;if f.verbose then print(\"Extracting data...\")end;if j[3].name==\"data.tar.gz\"then l,m=d:DecompressGzip(j[3].data)elseif j[3].name==\"data.tar.xz\"or j[3].name==\"data.tar.lzma\"then l,m=e.DecompressXzOrLzmaString(j[3].data)else error(\"Unsupported compression format: \"..j[2].name)end;if l==nil then error(\"Could not decompress data file: \"..m)end;if i then return{k,l}end;local o=b.load(l,h,true)if o[\".\"]~=nil and not h then o=o[\".\"]end;local p={}p.control_size=string.len(j[2].data)p.data_size=string.len(j[3].data)p.control_archive=n;p.control=c.parseControl(n.control.data)p.name=p.control.Package;p.version=p.control.Version;p.section=p.control.Section;p.priority=p.control.Priority;if p.control[\"Pre-Depends\"]~=nil then p.predepends=c.parseDependencies(p.control[\"Pre-Depends\"])end;if p.control.Depends~=nil then p.depends=c.parseDependencies(p.control.Depends)end;if p.control.Recommends~=nil then p.recommends=c.parseDependencies(p.control.Recommends)end;if p.control.Suggests~=nil then p.suggests=c.parseDependencies(p.control.Suggests)end;if p.control.Enhances~=nil then p.enhances=c.parseDependencies(p.control.Enhances)end;if p.control.Breaks~=nil then p.breaks=c.parseDependencies(p.control.Breaks)end;if p.control.Conflicts~=nil then p.conflicts=c.parseDependencies(p.control.Conflicts)end;if p.control.Provides~=nil then p.provides=c.parseDependencies(p.control.Provides)end;if p.control.Replaces~=nil then p.replaces=c.parseDependencies(p.control.Replaces)end;p.conffiles={}if n.conffiles~=nil then for q in string.gmatch(n.conffiles.data,\"[^\\n]+\")do table.insert(p.conffiles,q)end end;p.md5sums={}if n.md5sums~=nil then for q in string.gmatch(n.md5sums.data,\"[^\\n]+\")do local r,s=q:match(\"^(%x+)  (.+)$\")if r then p.md5sums[\"/\"..s]=r end end end;if n.preinst~=nil then p.preinst=n.preinst.data end;if n.prerm~=nil then p.prerm=n.prerm.data end;if n.postinst~=nil then p.postinst=n.postinst.data end;if n.postrm~=nil then p.postrm=n.postrm.data end;if n.config~=nil then p.config=n.config.data end;if n.triggers~=nil then p.triggers=n.triggers.data end;if n.templates~=nil then p.templates=c.parseControlList(n.templates.data)for r,s in pairs(p.templates)do local t={}for u,v in pairs(s)do if string.match(u,\"%a+%-[%a@_]+%.UTF%-8\")then table.insert(t,u)end end;for u,v in pairs(t)do s[v]=nil end end end;p.data=o;return p end;return f\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291955,size=3107},["control.lua"]={type="file",created=1740881291979,worldPermissions={write=false,read=true,execute=false},data="local function a(b)return string.match(b,'^()[%s%z]*$')and''or string.match(b,'^[%s%z]*(.*[^%s%z])')end;local c={}function c.parseControl(d)local e={}local f=nil;for g in string.gmatch(d,\"[^\\n]+\")do if string.sub(g,1,1)==\" \"and f~=nil then if f==\"Description\"then if type(e[f])==\"string\"then e[f]={Short=e[f],Long=\"\"}end;e[f].Long=e[f].Long..(string.sub(g,2)==\".\"and\"\\n\\n\"or string.sub(g,2))else e[f]=e[f]..\"\\n\"..(string.sub(g,2)==\".\"and\"\\n\"or string.sub(g,2))end else f=string.sub(g,1,(string.find(g,\":\")or 0)-1)e[f]=a(string.sub(g,(string.find(g,\":\")or-1)+1))end end;return e end;function c.parseControlList(d,h)local e={}local i={}local j={}local b=1;for k,g in string.gmatch(d,\"()([^\\n]*\\n)\")do if g==\"\\n\"or g==\"\"then b=b+1 else j[b]=j[b]or k;i[b]=(i[b]or\"\")..g end end;for l,m in pairs(i)do local n=c.parseControl(m)if h then n.__pos=j[l]end;table.insert(e,n)end;return e end;function c.parseDependencies(o)local e={}for p in string.gmatch(o,\"[^,]+\")do p=a(p)local q={}if string.find(p,\"|\")then q.multiple=true;q.names={}for r in string.gmatch(p,\"[^|]+\")do r=a(r)local s={}s.name=string.match(r,\"%S+\")if string.match(r,\"%([<>=]+ [%w.%-%+%~]+%)\")then s.rel=string.match(r,\"%(([<>=]+) [%w.%-%+%~]+%)\")s.version=string.match(r,\"%([<>=]+ ([%w.%-%+%~]+)%)\")end;table.insert(q.names,s)end else q.name=string.match(p,\"%S+\")if string.match(p,\"%([<>=]+ [%w%.%-%+%~]+%)\")then q.rel=string.match(p,\"%(([<>=]+) [%w.%-%+%~]+%)\")q.version=string.match(p,\"%([<>=]+ ([%w.%-%+%~]+)%)\")end end;table.insert(e,q)end;return e end;return c\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881291954,size=1524},["divert.lua"]={type="file",created=1740881291981,worldPermissions={execute=false,read=true,write=false},data="local a=require\"system.filesystem\"local b={}b.admindir=\"/var/lib/dpkg\"function b.parse()local c=io.open(a.combine(b.admindir,\"diversions\"),\"r\")local d=1;local e={}local f;for g in c:lines()do if d==1 then e[g]={}f=g elseif d==2 then e[f].name=g elseif d==3 then e[f].package=g end;d=d+1;if d>3 then d=1 end end;c:close()return e end;function b.get(c,h,i)i=i or b.parse()local e=i[c]if not e or e.package==h then return nil end;return e end;local function j(k)a.copy(a.combine(b.admindir,\"diversions\"),a.combine(b.admindir,\"diversions-old\"))local c=a.open(a.combine(b.admindir,\"diversions\"),\"w\")for l,m in pairs(k)do c.writeLine(l)c.writeLine(m.name)c.writeLine(m.package)end;c.close()end;function b.add(n,o,h)local p=b.parse()p[n]={name=o or n..\".distrib\",package=h or\":\"}j(p)end;function b.remove(n)local p=b.parse()p[n]=nil;j(p)end;return b\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291956,size=843},["init.lua"]={type="file",created=1740881291982,worldPermissions={execute=false,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=(function()local d={__add=true,__sub=true,__mul=true,__div=true,__mod=true,__pow=true,__unm=true,__concat=true,__len=true,__eq=true,__lt=true,__le=true,__newindex=true,__call=true,__metatable=true}local function e(f,g,...)local h=getfenv(g)h.self=f;h.super=setmetatable({},{__index=getmetatable(f).__index})setfenv(g,h)return g(...)end;local function i(j,k,l)local m,n={__class=j},{}if l.static then for o,p in pairs(l.static)do if d[o]then n[o]=p else m[o]=p end end end;l.static=nil;if k.extends then if k.extends[1]then n.__index=function(self,j)for q,p in ipairs(k.extends)do if p[j]then return p[j]end end end else n.__index=k.extends end end;local r=l.__init;l.__init=nil;n.__call=function(self,...)local s,t={},{}local f=setmetatable({__class=j},s)if k.extends and not r then if k.extends[1]then for q,p in ipairs(k.extends)do t[q]=p()end;s.__index=function(self,j)for q,p in ipairs(t)do if p[j]then return p[j]end end end else s.__index=k.extends(...)end end;for o,p in pairs(l)do if type(p)==\"function\"then f[o]=function(...)return e(f,p,...)end elseif o~=\"__class\"then f[o]=p end;if d[o]then s[o]=f[o]f[o]=nil end end;if r then local h=getfenv(r)h.self=f;h.super=setmetatable({},{__index=s.__index})if k.extends then if k.extends[1]then s.__index=function(self,j)if#t<#k.extends then for q,p in ipairs(k.extends)do t[q]=p()end end;for q,p in ipairs(t)do if p[j]then return p[j]end end end;for q,p in ipairs(k.extends)do h[p.__class]=function(...)t[q]=p(...)end end else s.__index=function(self,j)s.__index=k.extends()return s.__index[j]end;h[k.extends.__class]=function(...)s.__index=k.extends(...)end end end;setfenv(r,h)r(...)if k.extends and k.extends[1]then s.__index=function(self,j)for q,p in ipairs(t)do if p[j]then return p[j]end end end end end;return f end;setmetatable(m,n)return m end;return setmetatable({},{__call=function(self,j)return function(u)if u.extends or u.implements then return function(v)return i(j,u,v)end else return i(j,{},u)end end end})end)()local w=require\"diff\"local x=require\"control\"local y=require\"deb\"local z=require\"divert\"local A=require\"query\"local B=require\"trigger\"local C=require\"sha2\"local D=require\"tar\"local E={}E.admindir=\"/var/lib/dpkg\"E.rootdir=\"/\"E.write=io.write;E.print=print;E.read=io.read;E.warn=function(F)print(\"dpkg: warning: \"..F)end;E.error=function(F)print(\"dpkg: \\x1b[31merror:\\x1b[0m \"..F)end;E.debug=function(F)end;local function G(H)return a.combine(E.admindir,H)end;local function I(H)return a.combine(E.rootdir,H)end;local function J(K)return string.match(K,'^()[%s%z]*$')and''or string.match(K,'^[%s%z]*(.*[^%s%z])')end;local function L(M)local N=a.open(M,\"r\")local O=N.readAll()N.close()return O end;local function P(M)local O={}for Q in io.lines(M)do table.insert(O,Q)end;return O end;local function R(M,S)local N=a.open(M,\"w\")N.write(S)N.close()end;local function T(M,U)local N=a.open(M,\"w\")for V,p in ipairs(U)do N.writeLine(p)end;N.close()end;local function W(X,Y)return({string.match(X.Status,\"(%S+) (%S+) (%S+)\")})[Y]end;local function Z(X,Y,_)local a0={string.match(X.Status,\"(%S+) (%S+) (%S+)\")}a0[Y]=_;X.Status=table.concat(a0,\" \")return X.Status end;local function a1(a2,a3)local a4={}for K in string.gmatch(a2,\"([^\"..(a3 or\"%s\")..\"]+)\")do table.insert(a4,K)end;return a4 end;local function a5(F)local b=io.popen(\"/bin/less\",\"w\")b:write(F)b:close()end;local a6={preinst=\"postrm\",prerm=\"postinst\",postrm=\"preinst\"}self={}E.options={triggers=true,pager=true,auto_deconfigure=false,skip_same_version=false,dry_run=false,ignore_depends={}}E.force={downgrade=false,configure_any=false,hold=false,remove_reinstreq=false,remove_essential=false,depends=false,depends_version=false,breaks=false,conflicts=false,confmiss=false,confmode=nil,overwrite=false,overwrite_dir=false,overwrite_diverted=false,statoverride_add=false,statoverride_remove=false,architecture=false,bad_version=false,bad_verify=false}local a7=_G.package;E.package=c\"package\"{static={packagedb=nil,triggerdb=nil,filedb=nil,filecount=0,scriptCallStack={},setPackageDB=function(a8)E.package.packagedb=a8 or A.readDatabase()end,setTriggerDB=function(a8)E.package.triggerdb=a8 or B.readDatabase()end,setFileDB=function(a8,a9)if a8 then E.package.filedb,E.package.filecount=a8,a9 else E.package.filedb,E.package.filecount=A.readFileLists()end end,unwindScriptErrors=function(aa)local O=true;while#E.package.scriptCallStack>0 do local ab=table.remove(E.package.scriptCallStack)if a6[ab.script]then local ac=ab.pkg.callMaintainerScript(a6[ab.script],\"abort-\"..ab.args[1],table.unpack(ab.args,2,ab.args.n))if aa then aa(ab.pkg,ac,ab.script,table.unpack(ab.args,1,ab.args.n))end;if not ac then O=false end end end;return O end,clearScriptErrors=function()E.package.scriptCallStack={}end},__init=function(M)if a.exists(M)then local ad=y.load(M,true)self.isUnpacked=false;self.name=ad.name;self.path=a.basename(M)self.files=ad.data;self.filelist=nil;self.control=ad.control;self.controlArchive=ad.control_archive;self.conffiles=ad.conffiles;self.md5sums=ad.md5sums;self.preinst=ad.preinst;self.postinst=ad.postinst;self.prerm=ad.prerm;self.postrm=ad.postrm;self.triggers=ad.triggers elseif E.package.packagedb~=nil and E.package.packagedb[M]~=nil then self.isUnpacked=true;self.name=M;self.path=nil;self.files=nil;self.filelist=a.exists(G(\"info/\"..M..\".list\"))and P(G(\"info/\"..M..\".list\"))or nil;self.control=E.package.packagedb[M]self.controlArchive=nil;self.conffiles=a.exists(G(\"info/\"..M..\".conffiles\"))and P(G(\"info/\"..M..\".conffiles\"))or nil;if a.exists(G(\"info/\"..M..\".md5sums\"))then local ae=L(G(\"info/\"..M..\".md5sums\"))self.md5sums={}for af in string.gmatch(ae,\"[^\\n]+\")do local o,p=af:match(\"^(%x+)  (.+)$\")if o then self.md5sums[\"/\"..p]=o end end end;self.preinst=a.exists(G(\"info/\"..M..\".preinst\"))and L(G(\"info/\"..M..\".preinst\"))or nil;self.postinst=a.exists(G(\"info/\"..M..\".postinst\"))and L(G(\"info/\"..M..\".postinst\"))or nil;self.prerm=a.exists(G(\"info/\"..M..\".prerm\"))and L(G(\"info/\"..M..\".prerm\"))or nil;self.postrm=a.exists(G(\"info/\"..M..\".postrm\"))and L(G(\"info/\"..M..\".postrm\"))or nil;self.triggers=a.exists(G(\"info/\"..M..\".triggers\"))and L(G(\"info/\"..M..\".triggers\"))or nil else error(\"Could not find package \"..M)end end,callMaintainerScript=function(ag,...)local M,ah=nil,false;if string.sub(ag,#ag)=='!'then ah=true end;ag=ag:gsub(\"!$\",\"\")if self.isUnpacked or string.sub(ag,1,1)=='.'then M=G(\"info/\"..self.name..\".\"..string.gsub(ag,\"^%.\",\"\"))else M=G(\"tmp.ci/\"..ag)end;local ai=...if not ah and ai:find(\"abort\")==nil then table.insert(E.package.scriptCallStack,{pkg=self,script=ag,args=table.pack(...)})end;ag=ag:gsub(\"^%.\",\"\")if not a.exists(M)then return true end;return b.run(M,...)end,unpack=function()local self=self;if self.isUnpacked then E.error(\"internal error: attempted to unpack package without archive\")return false end;if E.package.packagedb[self.name]~=nil and W(E.package.packagedb[self.name],1)==\"hold\"then if E.force.hold then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package is currently held\")else E.error(\"package is currently held\")return false end end;if self.control.Architecture~=\"phoenix\"and self.control.Architecture~=\"all\"then if E.force.architecture then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package architecture (\"..self.control.Architecture..\") does not match the system (phoenix)\")else E.error(\"package architecture (\"..self.control.Architecture..\") does not match the system (phoenix)\")return false end end;if a.isDir(G(\"tmp.ci\"))then a.remove(G(\"tmp.ci\"))end;D.extract(self.controlArchive,G(\"tmp.ci\"))E.print(\"Preparing to unpack \"..self.path..\" ...\")local aj=false;if E.package.packagedb[self.name]~=nil and W(E.package.packagedb[self.name],3)==\"installed\"and E.compareVersions(self.control.Version,E.package.packagedb[self.name].Version)==-1 then if E.force.downgrade then E.warn(\"overriding problem because --force enabled:\")E.warn(\"downgrading \"..self.name..\" from \"..E.package.packagedb[self.name].Version..\" to \"..self.control.Version)aj=true else E.error(\"attempted to downgrade \"..self.name..\" from \"..E.package.packagedb[self.name].Version..\" to \"..self.control.Version)return false end end;local ak={}if self.control[\"Pre-Depends\"]~=nil and not aj then for V,p in ipairs(a1(self.control[\"Pre-Depends\"],\",\"))do local al,j=E.checkDependency(p,function(am,X)return A.status.configured(am)or X[\"Config-Version\"]~=nil and A.status.present(am)end)if not al and not E.options.ignore_depends[j]then table.insert(ak,{j,J(p)})end end end;if#ak>0 then if E.force.depends then E.warn(\"overriding problem because --force enabled:\")E.warn(\"dependency problems prevent unpacking of \"..self.name..\":\")for V,p in ipairs(ak)do E.print(\" \"..self.name..\" pre-depends on \"..p[2]..\"; however:\\n  Package \"..p[1]..\" is not installed.\\n\")end else E.error(\"dependency problems prevent unpacking of \"..self.name..\":\")for V,p in ipairs(ak)do E.print(\" \"..self.name..\" pre-depends on \"..p[2]..\"; however:\\n  Package \"..p[1]..\" is not installed.\\n\")end;return false end end;local an={}for o,p in pairs(E.package.packagedb)do if p.Conflicts and A.status.present(W(p,3))and E.findRelationship(self.name,self.control.Version,p.Conflicts)then table.insert(an,o)end end;if#an>0 then if E.force.conflicts then E.warn(\"overriding problem because --force enabled:\")E.warn(\"conflicting packages prevent unpacking of \"..self.name..\":\")for V,p in ipairs(an)do E.print(\" \"..p..\" conflicts with \"..self.name..\", however:\\n  Package \"..self.name..\" (\"..self.control.Version..\") is being installed.\\n\")end else E.error(\"conflicting packages prevent unpacking of \"..self.name..\":\")for V,p in ipairs(an)do E.print(\" \"..p..\" conflicts with \"..self.name..\", however:\\n  Package \"..self.name..\" (\"..self.control.Version..\") is being installed.\\n\")end;return false end end;if E.package.packagedb[self.name]~=nil and W(E.package.packagedb[self.name],3)==\"installed\"then E.debug(\"Upgrading pre-existing package (\"..E.package.packagedb[self.name].Version..\" => \"..self.control.Version..\")\")if not self.callMaintainerScript(\".prerm\",\"upgrade\",self.control.Version)then E.debug(\"Old package's prerm upgrade failed\")if not self.callMaintainerScript(\"prerm!\",\"failed-upgrade\",E.package.packagedb[self.name].Version)then E.debug(\"New package's prerm failed-upgrade failed\")if E.package.unwindScriptErrors()then E.error(\"package pre-upgrade script failed to run\")Z(E.package.packagedb[self.name],3,\"installed\")else E.debug(\"Old package's postinst abort-upgrade failed\")E.error(\"package pre-upgrade script failed to run, and old package failed to revert changes\")Z(E.package.packagedb[self.name],3,\"half-configured\")end;a.remove(G(\"tmp.ci\"))return false end end end;local ao={}do local ap,j;if self.control.Breaks~=nil then for V,p in ipairs(a1(self.control.Breaks,\",\"))do ap,j=E.checkDependency(p)if ap then ao[j]=0 end end end;if self.control.Conflicts~=nil then for V,p in ipairs(a1(self.control.Conflicts,\",\"))do ap,j=E.checkDependency(p,true)if ap then ao[j]=1 end end end end;if not E.options.auto_deconfigure and next(ao)~=nil then if E.force.conflicts then E.warn(\"dependency problems, but unpacking \"..self.name..\" anyway as you requested:\")else E.error(\"dependency problems prevent unpacking of \"..self.name..\":\")end;for p,V in ipairs(ao)do E.print(\" \"..p..\" conflicts with \"..self.name..\".\")end;if not E.force.conflicts then E.unwindScriptErrors()a.remove(G(\"tmp.ci\"))return false end end;local aq,ar=next(ao)and true or false,ao;while aq do local as,at={},{}aq=false;for o,p in pairs(E.package.packagedb)do for Q,au in pairs(ar)do if p.Depends and E.findRelationship(Q,E.package.packagedb[Q].Version,p.Depends)or p[\"Pre-Depends\"]and E.findRelationship(Q,E.package.packagedb[Q].Version,p[\"Pre-Depends\"])then aq=true;at[o]=p[\"Pre-Depends\"]and E.findRelationship(Q,E.package.packagedb[Q].Version,p[\"Pre-Depends\"])and 1 or 0;local av=E.package(o)E.debug(\"Deconfiguring \"..o..\" since it depends on conflicting package \"..Q)if av.prerm then if av.callMaintainerScript(\"prerm\",\"deconfigure\",\"in-favour\",self.name,self.control.Version,\"removing\",Q,E.package.packagedb[Q].Version)then p[\"Config-Version\"]=p.Version;Z(p,3,\"unpacked\")else E.debug(\"Deconfigure failed.\")table.insert(as,{o,Q})end else p[\"Config-Version\"]=p.Version;Z(p,3,\"unpacked\")end end end end;if#as>0 then if E.force.depends and E.force.conflicts then E.warn(\"overriding problem because --force enabled:\")E.warn(\"dependency problems prevent unpacking of \"..self.name..\":\")else E.error(\"dependency problems prevent unpacking of \"..self.name..\":\")end;for V,p in ipairs(as)do E.print(\" \"..p[1]..\" depends on \"..p[2]..\" which conflicts with \"..self.name..\", however:\")E.print(\"  deconfiguring \"..p[1]..\" failed\\n\")end;if not(E.force.depends and E.force.conflicts)then E.package.unwindScriptErrors(function(aw,ac,ag)if aw.name~=self.name and ag==\"prerm\"then if ac then Z(E.package.packagedb[aw.name],3,\"installed\")else Z(E.package.packagedb[aw.name],3,\"half-configured\")end end end)a.remove(G(\"tmp.ci\"))return false end end;ar=at end;local ax={}for o,p in pairs(ao)do if o~=self.name then local av=E.package(o)E.debug(\"Deconfiguring \"..o..\" since it conflicts with the current package\")if av.callMaintainerScript(\"prerm\",\"deconfigure\",\"in-favour\",self.name,self.control.Version)then E.package.packagedb[o][\"Config-Version\"]=E.package.packagedb[o].Version;Z(E.package.packagedb[o],3,\"unpacked\")if p==1 then Z(E.package.packagedb[o],3,\"half-installed\")if not av.callMaintainerScript(\"prerm\",\"remove\",\"in-favour\",self.name,self.control.Version)then E.debug(\"Pre-remove failed, aborting.\")table.insert(ax,o)end end else E.debug(\"Deconfigure failed, aborting.\")table.insert(ax,o)end end end;if#ax>0 then if E.force.conflicts then E.warn(\"overriding problem because --force enabled:\")E.warn(\"dependency problems prevent unpacking of \"..self.name..\":\")else E.error(\"dependency problems prevent unpacking of \"..self.name..\":\")end;for V,p in ipairs(ax)do E.print(\" \"..p..\" conflicts with \"..self.name..\", however:\")E.print(\"  deconfiguring \"..p..\" failed\\n\")end;if not E.force.conflicts then E.unwindScriptErrors(function(aw,ac,ag,...)if aw.name~=self.name and ag==\"prerm\"then if...==\"remove\"then if ac then Z(E.package.packagedb[aw.name],3,\"unpacked\")end elseif...==\"deconfigure\"then if ac then Z(E.package.packagedb[aw.name],3,\"installed\")else Z(E.package.packagedb[aw.name],3,\"half-configured\")end end end end)a.remove(G(\"tmp.ci\"))return false end end;local ay;if E.package.packagedb[self.name]~=nil and W(E.package.packagedb[self.name],3)~=\"not-installed\"then ay=E.package.packagedb[self.name].Version;if W(E.package.packagedb[self.name],3)~=\"config-files\"then E.debug(\"Upgrading from \"..E.package.packagedb[self.name].Version..\" to \"..self.control.Version)if not self.callMaintainerScript(\"preinst!\",\"upgrade\",E.package.packagedb[self.name].Version)then E.debug(\"New preinst upgrade failed\")if self.callMaintainerScript(\"postrm\",\"abort-upgrade\",E.package.packagedb[self.name].Version)then if self.callMaintainerScript(\".postinst\",\"abort-upgrade\",self.control.Version)then E.debug(\"Leaving package as-is\")E.error(\"package pre-install script failed to upgrade, leaving old version installed\")Z(E.package.packagedb[self.name],3,\"installed\")E.package.unwindScriptErrors()return false else E.debug(\"Old postinst abort-upgrade failed\")E.error(\"package pre-install script failed to upgrade, and previous version failed to revert changes\")Z(E.package.packagedb[self.name],3,\"unpacked\")E.package.unwindScriptErrors()return false end else E.debug(\"New postrm abort-upgrade failed\")E.error(\"package pre-install script failed to run\")Z(E.package.packagedb[self.name],3,\"half-installed\")E.package.unwindScriptErrors()return false end end else E.debug(\"Installing with config files\")if not self.callMaintainerScript(\"preinst\",\"install\",E.package.packagedb[self.name][\"Config-Version\"])then E.debug(\"Preinst install failed\")if E.package.unwindScriptErrors()then E.error(\"package pre-install script failed to install\")Z(E.package.packagedb[self.name],3,\"config-files\")return false else E.error(\"package pre-install script failed to run, reinstallation required\")Z(E.package.packagedb[self.name],2,\"reinstreq\")Z(E.package.packagedb[self.name],3,\"half-installed\")return false end end end else E.debug(\"Installing new\")if not self.callMaintainerScript(\"preinst\",\"install\")then E.debug(\"Preinst install failed\")if E.package.unwindScriptErrors()then E.error(\"package pre-install script failed to install\")Z(E.package.packagedb[self.name],3,\"not-installed\")return false else E.error(\"package pre-install script failed to run, reinstallation required\")Z(E.package.packagedb[self.name],2,\"reinstreq\")Z(E.package.packagedb[self.name],3,\"half-installed\")return false end end end;if ay then E.print(\"Unpacking \"..self.name..\" (\"..self.control.Version..\") over (\"..ay..\") ...\")else E.print(\"Unpacking \"..self.name..\" (\"..self.control.Version..\") ...\")end;self.filelist={}local az={}local function aA()for V,p in ipairs(self.filelist)do if not a.isDir(I(p))then a.remove(I(p..\".dpkg-new\"))if a.exists(I(p..\".dpkg-old\"))then a.rename(I(p..\".dpkg-old\"),I(p))end end end;self.filelist=nil;if E.package.packagedb[self.name]~=nil and W(E.package.packagedb[self.name],3)~=\"not-installed\"then if W(E.package.packagedb[self.name],3)~=\"config-files\"then if self.callMaintainerScript(\"postrm\",\"abort-upgrade\",E.package.packagedb[self.name].Version)then if self.callMaintainerScript(\".postinst\",\"abort-upgrade\",self.control.Version)then Z(E.package.packagedb[self.name],3,\"installed\")E.package.unwindScriptErrors()return false else E.error(\"previous version failed to revert changes\")Z(E.package.packagedb[self.name],3,\"unpacked\")E.package.unwindScriptErrors()return false end else E.error(\"package post-removal script failed to run\")Z(E.package.packagedb[self.name],3,\"half-installed\")E.package.unwindScriptErrors()return false end else if E.package.unwindScriptErrors()then Z(E.package.packagedb[self.name],3,\"config-files\")return false else E.error(\"package post-remove script failed to run, reinstallation required\")Z(E.package.packagedb[self.name],2,\"reinstreq\")Z(E.package.packagedb[self.name],3,\"half-installed\")return false end end else if E.package.unwindScriptErrors()then Z(E.package.packagedb[self.name],3,\"not-installed\")return false else E.error(\"package post-removal script failed to run, reinstallation required\")Z(E.package.packagedb[self.name],2,\"reinstreq\")Z(E.package.packagedb[self.name],3,\"half-installed\")return false end end end;local aB={}for V,p in ipairs(self.files)do local o=p.name:gsub(\"^./+\",\"/\"):gsub(\"^[^/]\",\"/%1\")E.debug(\"Writing \"..o)if E.package.filedb[o]~=nil and E.package.filedb[o]~=self.name and p.type==0 then if not(self.control.Replaces and E.findRelationship(E.package.filedb[o],E.package.packagedb[E.package.filedb[o]].Version,self.control.Replaces))then if E.force.overwrite_dir and a.isDir(I(o))or E.force.overwrite and not a.isDir(I(o))then E.warn(\"overriding problem because --force enabled:\")E.print((\"dpkg: error processing archive %s:\\n trying to overwrite '%s', which is also in package %s %s\"):format(self.path,o,E.package.filedb[o],E.package.packagedb[E.package.filedb[o]].Version))else E.print((\"dpkg: error processing archive %s:\\n trying to overwrite '%s', which is also in package %s %s\"):format(self.path,o,E.package.filedb[o],E.package.packagedb[E.package.filedb[o]].Version))return aA()end else az[E.package.filedb[o]]=az[E.package.filedb[o]]or{}table.insert(az[E.package.filedb[o]],o)end end;if p.type==5 then a.mkdir(I(o))elseif p.type==2 then a.link(I(o..\".dpkg-new\"),p.link)if a.exists(I(o))then a.rename(I(o),I(o..\".dpkg-old\"))end elseif p.type==0 then if self.md5sums and self.md5sums[o:gsub(\"^/+\",\"\")]and C.md5(p.data)~=self.md5sums[o:gsub(\"^/+\",\"\")]then E.debug((\"Invalid checksum for file %s (expected %s, got %s)\"):format(o,self.md5sums[o:gsub(\"^/+\",\"\")],C.md5(p.data)))if E.force.bad_verify then E.warn(\"overriding problem because --force enabled:\")E.warn(\"invalid checksum for file \"..o)else E.error(\"invalid checksum for file \"..o)return aA()end end;local N=a.open(I(o..\".dpkg-new\"),\"wb\")if not N then E.print((\"dpkg: error processing archive %s:\\n could not open destination file %s.dpkg-new for writing\"):format(self.path,o))return aA()end;N.write(p.data or\"\")N.close()a.chmod(I(o..\".dpkg-new\"),nil,bit32.band(p.mode,7))a.chmod(I(o..\".dpkg-new\"),p.ownerName or\"root\",bit32.rshift(bit32.band(p.mode,0x1C0),6))a.chown(I(o..\".dpkg-new\"),p.ownerName or\"root\")if bit32.btest(p.mode,0x800)then a.chmod(I(o..\".dpkg-new\"),p.ownerName or\"root\",\"+s\")end;local aC=false;if self.conffiles and self.md5sums and E.package.packagedb[self.name]~=nil and W(E.package.packagedb[self.name],3)~=\"not-installed\"then for V,au in ipairs(self.conffiles)do if au==o then if self.md5sums[o]==E.package(self.name).md5sums[o]then if a.exists(I(o))then a.remove(I(o..\".dpkg-new\"))aC=true end elseif a.exists(I(o))and p.data~=L(o)or not a.exists(I(o))then local aD=a.exists(I(o))and E.force.confmode or(E.force.confmiss and 0 or nil)E.print(\"Configuration file `\"..o..[['\n==> Modified (by you or by a script) since installation.\n==> Package distributor has shipped an updated version.\nWhat would you like to do about it? Your options are:\n    Y or I  : install the package maintainer's version\n    N or O  : keep your currently-installed version\n    D     : show the differences between the versions\n    Z     : start a shell to examine the situation\nThe default action is to keep your current version.]])while aD==nil do E.write(\"*** \"..a.basename(o)..\" (Y/I/N/O/D/Z) [default=N] ? \")local aE=E.read()if aE==\"Y\"or aE==\"y\"or aE==\"I\"or aE==\"i\"then aD=0 elseif aE==\"N\"or aE==\"n\"or aE==\"O\"or aE==\"o\"then aD=1 elseif aE==\"D\"or aE==\"d\"then local U={}local aF=w.diff(L(o),p.data,\"\\n\")for V,aG in ipairs(aF)do if aG[2]==\"in\"then table.insert(U,\"+++ \"..aG[1])elseif aG[2]==\"out\"then table.insert(U,\"--- \"..aG[1])else table.insert(U,\"    \"..aG[1])end end;if E.options.pager then a5(table.concat(U,\"\\n\"))else E.print(table.concat(U,\"\\n\"))end elseif aE==\"Z\"or aE==\"z\"then b.run(\"/bin/sh\")elseif aE==\"\"then aD=2 end end;if aD==0 then aB[o]=true else aC=true;a.remove(I(o..\".dpkg-dist\"))a.rename(I(o..\".dpkg-new\"),I(o..\".dpkg-dist\"))end end end end end;if not aC and a.exists(I(o))then a.rename(I(o),I(o..\".dpkg-old\"))end else E.debug(\"Unknown type \"..p.type..\" for path \"..o)end;table.insert(self.filelist,o)B.activate(o,self.name,false,E.package.triggerdb,E.package.packagedb)end;if E.package.packagedb[self.name]~=nil and W(E.package.packagedb[self.name],3)~=\"not-installed\"then if not self.callMaintainerScript(\".postrm!\",\"upgrade\",self.control.Version)and not self.callMaintainerScript(\"postrm\",\"failed-upgrade\",E.package.packagedb[self.name].Version)then E.debug(\"postrm upgrade failed\")if self.callMaintainerScript(\".preinst\",\"abort-upgrade\",self.control.Version)then E.debug(\"Reverting changes\")for V,p in ipairs(self.filelist)do if not a.isDir(I(p))then a.remove(I(p..\".dpkg-new\"))if a.exists(I(p..\".dpkg-old\"))then a.rename(I(p..\".dpkg-old\"),I(p))end end end;self.filelist=nil;if not self.callMaintainerScript(\"postrm\",\"abort-upgrade\",E.package.packagedb[self.name].Version)or not self.callMaintainerScript(\".postinst\",\"abort-upgrade\",self.control.Version)then E.debug(\"postrm/.postinst abort-upgrade failed\")E.error(\"package postrm script failed to finish upgrade, and upgrade failed to abort\")Z(self.name,3,\"half-installed\")E.package.unwindScriptErrors()return false end;E.error(\"package upgrade failed to finish\")Z(self.name,3,\"unpacked\")E.package.unwindScriptErrors()return false else E.debug(\"preinst abort-upgrade failed\")E.error(\"package postrm script failed to finish upgrade, and preinst script failed to abort upgrade\")Z(self.name,3,\"half-installed\")E.package.unwindScriptErrors()return false end end;local aH=P(G(\"info/\"..self.name..\".list\"))for V,p in pairs(aH)do local aq=false;for V,au in ipairs(self.filelist)do if a.combine(p)==a.combine(au)then aq=true;break end end;if not aq then if a.isDir(I(p))then if#a.list(I(p))==0 then E.debug(\"Deleting removed directory \"..p)a.remove(I(p))end else E.debug(\"Deleting removed file \"..p)a.remove(I(p))end end end end;T(G(\"info/\"..self.name..\".list\"),self.filelist)if self.conffiles then T(G(\"info/\"..self.name..\".conffiles\"),self.conffiles)end;if self.md5sums then local N=a.open(G(\"info/\"..self.name..\".md5sums\"),\"w\")for o,p in pairs(self.md5sums)do N.writeLine(p..\"  \"..o:sub(2))end;N.close()end;if self.triggers then local U=a1(self.triggers,'\\n')for V,p in ipairs(U)do p=J(p:gsub(\"#.+$\",\"\"))if string.find(p,\"interest\")==1 then local aI=a1(p)if aI[1]==\"interest\"or aI[1]==\"interest-await\"then B.register(aI[2],self.name,true)elseif aI[1]==\"interest-noawait\"then B.register(aI[2],self.name,false)end end end;E.package.setTriggerDB()end;for V,p in ipairs{\"postinst\",\"postrm\",\"preinst\",\"prerm\",\"triggers\"}do if self[p]then R(G(\"info/\"..self.name..\".\"..p),self[p])end end;for o,p in pairs(az)do local aJ=P(G(\"info/\"..o..\".list\"))for V,au in ipairs(p)do for q,aG in ipairs(aJ)do if au==aG then table.remove(aJ,q)break end end end;if#aJ==0 then E.package(o).callMaintainerScript(\"postrm\",\"disappear\",self.name,self.control.Version)for V,au in ipairs{\"conffiles\",\"md5sums\",\"postinst\",\"postrm\",\"preinst\",\"prerm\",\"triggers\"}do a.remove(G(\"info/\"..o..\".\"..au))end;E.package.packagedb[o].Status=\"purge ok not-installed\"else T(G(\"info/\"..o..\".list\"),aJ)end end;for V,p in ipairs(self.filelist)do E.package.filedb[p]=self.name;if a.exists(I(p..\".dpkg-old\"))and not aB[p]then a.remove(I(p..\".dpkg-old\"))end;if a.exists(I(p..\".dpkg-new\"))then local aK=a.stat(I(p..\".dpkg-new\"),true)a.rename(I(p..\".dpkg-new\"),I(p))if aK.setuser then a.chmod(I(p),aK.owner,\"+s\")end end end;a.remove(G(\"tmp.ci\"))E.package.packagedb[self.name]=E.package.packagedb[self.name]or{}for o,p in pairs(self.control)do E.package.packagedb[self.name][o]=p end;E.package.packagedb[self.name].Status=\"install ok unpacked\"self.isUnpacked=true;for o,p in pairs(ao)do if p==1 then E.package(o).remove()end end;E.package.clearScriptErrors()return true end,configure=function()if not self.isUnpacked then E.error(\"internal error: package is not unpacked\")return false end;if W(E.package.packagedb[self.name],1)==\"hold\"then if E.force.hold then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package is currently held\")else E.error(\"package is currently held\")return false end end;if not A.status.needs_configure(W(E.package.packagedb[self.name],3))then E.error(\"package is already configured\")return false end;local aL={}if self.control.Depends~=nil then for V,p in ipairs(a1(self.control.Depends,\",\"))do local al,j=E.checkDependency(p,function(am,X)return A.status.configured(am)or X[\"Config-Version\"]~=nil and A.status.present(am)end)if not al and not E.options.ignore_depends[j]then table.insert(aL,{j,J(p)})end end end;if#aL>0 then if E.force.depends then E.warn(\"overriding problem because --force enabled:\")E.warn(\"dependency problems prevent configuration of \"..self.name..\":\")for V,p in ipairs(aL)do E.print(\" \"..self.name..\" depends on \"..p[2]..\"; however:\\n  Package \"..p[1]..\" is not installed.\\n\")end else E.error(\"dependency problems prevent configuration of \"..self.name..\":\")for V,p in ipairs(aL)do E.print(\" \"..self.name..\" depends on \"..p[2]..\"; however:\\n  Package \"..p[1]..\" is not installed.\\n\")end;return false end end;local an={}for o,p in pairs(E.package.packagedb)do if p.Breaks and A.status.get_number(W(p,3))>=A.status.unpacked and E.findRelationship(self.name,self.control.Version,p.Breaks)then table.insert(an,o)end end;if#an>0 then if E.force.breaks then E.warn(\"overriding problem because --force enabled:\")E.warn(\"conflicting packages prevent unpacking of \"..self.name..\":\")for V,p in ipairs(an)do E.print(\" \"..p..\" breaks \"..self.name..\", however:\\n  Package \"..self.name..\" (\"..self.control.Version..\") is being configured.\\n\")end else E.error(\"conflicting packages prevent unpacking of \"..self.name..\":\")for V,p in ipairs(an)do E.print(\" \"..p..\" breaks \"..self.name..\", however:\\n  Package \"..self.name..\" (\"..self.control.Version..\") is being configured.\\n\")end;return false end end;E.print(\"Setting up \"..self.name..\" (\"..self.control.Version..\") ...\")if not self.callMaintainerScript(\"postinst!\",\"configure\",self.control[\"Config-Version\"])then E.print(\"dpkg: an error occurred while configuring \"..self.name)Z(E.package.packagedb[self.name],3,\"half-configured\")return false end;if self.triggers then local U=a1(self.triggers,'\\n')for V,p in ipairs(U)do p=J(p:gsub(\"#.+$\",\"\"))if string.find(p,\"activate\")==1 then local aI=a1(p)if aI[1]==\"activate\"or aI[1]==\"activate-await\"then B.activate(aI[2],self.name,true,E.package.triggerdb,E.package.packagedb)elseif aI[1]==\"activate-noawait\"then B.activate(aI[2],self.name,false,E.package.triggerdb,E.package.packagedb)end end end end;if E.package.packagedb[self.name][\"Triggers-Pending\"]and E.options.triggers then E.print(\"Processing triggers for \"..self.name..\" (\"..self.control.Version..\") ...\")B.commit(self.name,E.package.triggerdb,E.package.packagedb)else Z(E.package.packagedb[self.name],3,\"installed\")end;E.package.clearScriptErrors()return true end,remove=function(aM)if not self.isUnpacked then E.error(\"internal error: package is not unpacked\")return false end;if W(E.package.packagedb[self.name],1)==\"hold\"then if E.force.hold then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package is currently held\")else E.error(\"package is currently held\")return false end end;if not A.status.present(W(E.package.packagedb[self.name],3))then if aM then return self.purge()end;E.error(\"cannot remove package: package is not installed\")return false end;if W(E.package.packagedb[self.name],2)==\"reinstreq\"then if E.force.remove_reinstreq then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package requires reinstallation\")else E.error(\"package requires reinstallation\")return false end end;if E.package.packagedb[self.name].Essential==\"yes\"then if E.force.remove_essential then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package is marked as essential\")else E.error(\"package is marked as essential\")return false end end;do local as={}for o,p in pairs(E.package.packagedb)do if p.Depends and E.findRelationship(self.name,self.control.Version,p.Depends)then table.insert(as,o)end end;if#as>0 then if E.force.depends then E.print(\"dpkg: \"..self.name..\": dependency problems, but removing anyway as you requested:\")else E.error(\"dependency problems prevent removal of \"..self.name..\":\")end;for V,p in ipairs(as)do E.print(\" \"..p[1]..\" depends on \"..self.name..\".\")end;if not E.force.depends then return false end end end;if not self.callMaintainerScript(\"prerm\",\"remove\")then E.debug(\"Prerm failed\")if E.package.unwindScriptErrors()then E.error(\"prerm failed, leaving installed\")Z(E.package.packagedb[self.name],3,\"installed\")return false else E.error(\"prerm failed to run\")Z(E.package.packagedb[self.name],3,\"half-configured\")return false end end;E.print(\"Removing \"..self.name..\" (\"..self.control.Version..\") ...\")local aN={}for V,p in ipairs(self.conffiles)do aN[p]=true end;local aO={}local aP={}for q,p in ipairs(self.filelist)do if p~=\"/\"then E.debug(\"Removing \"..p)if not aN[p]then table.insert(aP,q)if a.isDir(I(p))then table.insert(aO,p)else a.remove(I(p))end end end end;table.sort(aO,function(ai,aQ)return#ai>#aQ end)for V,p in ipairs(aO)do if#a.list(I(p))==0 then a.remove(I(p))end end;for V,p in ipairs(aP)do self.filelist[p]=nil end;if not self.callMaintainerScript(\"postrm\",\"remove\")then E.error(\"postrm failed to run\")E.package.clearScriptErrors()Z(E.package.packagedb[self.name],3,\"half-installed\")return false end;if self.triggers then local U=a1(self.triggers,'\\n')for V,p in ipairs(U)do p=J(p:gsub(\"#.+$\",\"\"))if string.find(p,\"interest\")==1 then local aI=a1(p)B.deregister(aI[2])end end;E.package.setTriggerDB()end;for V,p in ipairs(a.find(G(\"info/\"..self.name..\".*\")))do local aR=p:match(\"[^.]+$\")if not(aR==\"postrm\"or aR==\"conffiles\"or aR==\"list\"or aR==\"md5sums\")then a.remove(I(p))end end;T(G(\"info/\"..self.name..\".list\"),self.filelist)Z(E.package.packagedb[self.name],3,\"config-files\")if not a.exists(G(\"info/\"..self.name..\".postrm\"))and not a.exists(G(\"info/\"..self.name..\".conffiles\"))then a.remove(G(\"info/\"..self.name..\".list\"))Z(E.package.packagedb[self.name],3,\"not-installed\")return true elseif aM then return self.purge()else return true end end,purge=function()if not self.isUnpacked then E.error(\"internal error: package is not unpacked\")return false end;if W(E.package.packagedb[self.name],1)==\"hold\"then if E.force.hold then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package is currently held\")else E.error(\"package is currently held\")return false end end;if W(E.package.packagedb[self.name],3)~=\"config-files\"then E.error(\"cannot purge package: package is\"..(W(E.package.packagedb[self.name],3)==\"not-installed\"and\" not \"or\" \")..\"installed\")return false end;E.print(\"Removing config files for \"..self.name..\" (\"..self.control.Version..\") ...\")for V,p in ipairs(self.conffiles)do a.remove(I(p))end;if not self.callMaintainerScript(\"postrm\",\"purge\")then E.error(\"postrm failed to run\")E.package.clearScriptErrors()Z(E.package.packagedb[self.name],3,\"config-files\")return false end;if a.exists(G(\"info/\"..self.name..\".postrm\"))then a.remove(G(\"info/\"..self.name..\".postrm\"))end;if a.exists(G(\"info/\"..self.name..\".conffiles\"))then a.remove(G(\"info/\"..self.name..\".conffiles\"))end;Z(E.package.packagedb[self.name],3,\"not-installed\")return true end,verify=function()if not self.isUnpacked then E.error(\"internal error: package is not unpacked\")return false end;if W(E.package.packagedb[self.name],1)==\"hold\"then if E.force.hold then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package is currently held\")else E.error(\"package is currently held\")return false end end;if not self.md5sums then E.error(\"cannot verify package: no md5 sums are available\")return false end;local aS=true;for o,p in pairs(self.md5sums)do if C.md5(L(o))~=p then E.print(\"dpkg: \"..self.name..\": checksum failed for file \"..o)aS=false end end;return aS end}_G.package=a7;local function aT(aU,aV)if aU=='~'and aV~='~'then return 1 elseif aU~='~'and aV=='~'then return-1 elseif aU==''and aV~=''then return 1 elseif aU~=''and aV==''then return-1 elseif string.match(aU,\"%a\")and not string.match(aV,\"%a\")then return 1 elseif not string.match(aU,\"%a\")and string.match(aV,\"%a\")then return-1 elseif aU>aV then return 1 elseif aU<aV then return-1 else return 0 end end;local function aW(ai,aQ)if ai==aQ then return 0 end;while ai~=\"\"or aQ~=\"\"do local aX,aY;aX,ai=string.match(ai,\"^(%D*)(.*)$\")aY,aQ=string.match(aQ,\"^(%D*)(.*)$\")while aX~=\"\"or aY~=\"\"do local aZ,a_;aZ,aX=string.match(aX,\"^(.?)(.*)$\")a_,aY=string.match(aY,\"^(.?)(.*)$\")local ac=aT(aZ,a_)if ac~=0 then return ac end end;if ai==\"\"and aQ==\"\"then break end;aX,ai=string.match(ai,\"^(%d*)(.*)$\")aY,aQ=string.match(aQ,\"^(%d*)(.*)$\")if tonumber(aX)>tonumber(aY)then return 1 elseif tonumber(aX)<tonumber(aY)then return-1 end end;return 0 end;function E.compareVersions(ai,aQ)if string.match(ai,\"^%d+:\")or string.match(aQ,\"^%d+:\")then local b0=tonumber(string.match(ai,\"^(%d+):\")or 0)local b1=tonumber(string.match(aQ,\"^(%d+):\")or 0)ai,aQ=string.match(ai,\"^%d+:(.*)\")or ai,string.match(aQ,\"^%d+:(.*)\")or aQ;if b0<b1 then return-1 elseif b0>b1 then return 1 end end;local b2=string.match(ai,\"^([%w.+-~]+)%-?[%w.+~]*$\")local b3=string.match(aQ,\"^([%w.+-~]+)%-?[%w.+~]*$\")if b2==nil or b3==nil then return nil end;local ac=aW(b2,b3)if ac~=0 then return ac end;if string.match(ai,\"%-[^-]+$\")or string.match(aQ,\"%-[%w.+~]+$\")then return aW(string.match(ai,\"%-([%w.+~]+)$\")or\"0\",string.match(aQ,\"%-([%w.+~]+)$\")or\"0\")end;return 0 end;function E.findRelationship(X,b4,b5)local b6,b7;b5=string.match(J(b5),\"^(\"..X..\"%s+%([<=>][<=>]?%s*[^ )]+%))\")or string.match(J(b5),\"[, ](\"..X..\"%s+%([<=>][<=>]?%s*[^ )]+%))\")or string.match(J(b5),\"^(\"..X..\")%s*,\")or string.match(J(b5),\"[, ](\"..X..\")%s*,\")or string.match(J(b5),\"^(\"..X..\")$\")or string.match(J(b5),\"[, ](\"..X..\")$\")if b5==nil then return false end;if string.match(b5,\"%S+%s+%([<=>][<=>]?%s*[^ )]+%)\")then b5,b7,b6=string.match(b5,\"(%S+)%s+%(([<=>][<=>]?)%s*([^ )]+)%)\")if not({[\"<<\"]=true,[\"<=\"]=true,[\"=\"]=true,[\">=\"]=true,[\">>\"]=true})[b7]then return nil end end;if b6 and b7 then local ac=E.compareVersions(b4,b6)return b7==\"<<\"and ac==-1 or b7==\"<=\"and ac~=1 or b7==\"=\"and ac==0 or b7==\">=\"and ac~=-1 or b7==\">>\"and ac==1 else return true end end;function E.checkDependency(b8,b9)local b6,b7;b8=J(b8)if string.match(b8,\"%S+%s+%([<=>][<=>]?%s*[^ )]+%)\")then b8,b7,b6=string.match(b8,\"(%S+)%s+%(([<=>][<=>]?)%s*([^ )]+)%)\")if not({[\"<<\"]=true,[\"<=\"]=true,[\"=\"]=true,[\">=\"]=true,[\">>\"]=true})[b7]then return nil end end;local ba={}if E.package.packagedb[b8]~=nil then table.insert(ba,{E.package.packagedb[b8],E.package.packagedb[b8].Version})end;for V,p in pairs(E.package.packagedb)do if p.Provides and string.find(p.Provides,\"[, ]\"..b8 ..\"[(, ]\")then if b6 and string.match(p.Provides,\"[, ]\"..b8 ..\"%s+%(=%s*[^ )]+%)\")then table.insert(ba,{p,string.match(p.Provides,\"[, ]\"..b8 ..\"%s+%(=%s*([^ )]+)%)\")})elseif not b6 then table.insert(ba,{p,p.Version})end end end;for V,bb in ipairs(ba)do if A.status.configured(W(bb[1],3))or b9==true and A.status.present(W(bb[1],3))or type(b9)==\"function\"and b9(W(bb[1],3),bb[1])then if b6 and b7 and not E.force.depends_version then local ac=E.compareVersions(bb[2],b6)if b7==\"<<\"and ac==-1 or b7==\"<=\"and ac~=1 or b7==\"=\"and ac==0 or b7==\">=\"and ac~=-1 or b7==\">>\"and ac==1 then return true,bb[1].Package end else return true,bb[1].Package end end end;return false,b8 end;function E.readDatabase()E.write(\"(Reading database ...\")E.package.setPackageDB()E.package.setTriggerDB()E.package.setFileDB()E.print(\" \"..E.package.filecount..\" files and directories installed.)\")end;return E\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291957,size=37928}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881291983,size=0},["ftp.lua"]={type="file",created=1740881292189,worldPermissions={execute=false,read=true,write=false},data="local a=require(\"system.filesystem\")local b;b=require(\"system.hardware\").call;local c,d,e;do local f=require(\"system.network\")c,d,e=f.connect,f.listen,f.unlisten end;local g;g=require(\"system.process\").newthread;local h;h=require(\"system.sync\").barrier;local i,j,k;do local f=require(\"system.util\")i,j,k=f.timer,f.cancel,f.sleep end;local l;l=function(m,n)local o=c(\"psp://\"..m..\":\"..n)while o:status()==\"connecting\"do coroutine.yield()end;if o:status()==\"error\"then return nil,select(2,o:status())end;return o end;local p;p=function(m,n,q)local r=\"psp://\"..m..\":\"..n;d(r)local s;if q then s=i(q)end;while true do local t,u=coroutine.yield()if t==\"network_request\"and u.uri==r then e(r)if q then j(s)end;return u.handle elseif t==\"timer\"and u.id==s then e(r)return nil end end end;local v;v=function(o,w)local x=o:read(w or\"*a\")while x==nil and o:status()==\"open\"do coroutine.yield()x=o:read(w or\"*a\")end;return x end;local y;y=function(z,A)if#z<A then return z..(\" \"):rep(A-z)else return z:sub(1,A)end end;local B;B=function()local C={}return function(D)if D==nil then if C[20]==nil then C[20]=true;return 20 else local E=5000;while E<65536 and C[E]do E=E+1 end;if E>65535 then return nil else return E end end else C[D]=nil end end end;local F;do local G;local H={_send_command=function(self,I)if not self.connection:status()==\"open\"then return false,421,\"Connection closed\"end;if I~=nil then self.connection:write(I..\"\\r\\n\")end;local x=v(self.connection,\"*l\")if x==nil then error(\"Could not receive reply\",2)end;local J=x:sub(1,3)if tonumber(J)==nil then error(\"Malformed reply (invalid code): \"..x)end;local K=\"\"if x:sub(4,4)=='-'then for L in x:sub(5):gmatch(\"[^\\n]+\")do if L:sub(1,4)==J..\" \"then K=K..L:sub(5)break else K=K..L..\"\\n\"end end elseif x:sub(4,4)==' 'then K=x:sub(5)else error(\"Malformed reply (invalid code separator):\"..x)end;local M=math.floor(tonumber(J)/100)if 1==M then return self:_send_command()elseif 2==M or 3==M then return true,tonumber(J),K elseif 4==M or 5==M then return false,tonumber(J),K else return error(\"Malformed reply (invalid code): \"..J)end end,_receive_data=function(self,I)if self.pasv then local n=self:pasv()if n==nil then error(\"Ran out of ports for data connection\")end;local N,J,x=self:_send_command(\"PORT \"..self.connection:localIP():gsub(\"%.\",\",\")..\",\"..math.floor(n/256)..\",\"..n%256)if J~=200 then return nil,J,x end;local O,P,Q;local R=h.new(3)g(function()N,J,Q=self:_send_command(I)if not N then P:close()end;R:wait()end)g(function()P=p(self.connection:localIP(),n,self.timeout)if not P then return end;while true do local S=v(P)if not S then break end;local M=self.transfer_params.mode;if\"S\"==M then O=(O or\"\")..S elseif\"B\"==M then local T=S:byte(1)local A=S:byte(2)*256+S:byte(3)O=(O or\"\")..y(S,A)if math.floor(T/128)==1 then P:close()break end elseif\"C\"==M then R=S:byte(1)if R==0 and math.floor(S:byte(2)/128)==1 then P:close()break elseif math.floor(R/128)==0 then O=(O or\"\")..S:sub(2,R%128+1)elseif math.floor(R/64)%2==0 then O=(O or\"\")..S:sub(2,2):rep(R%64)else if self.transfer_params.type==\"A\"or self.transfer_params.type==\"E\"then O=(O or\"\")..(\" \"):rep(R%64)elseif self.transfer_params.type==\"I\"or self.transfer_params.type==\"L\"then O=(O or\"\")..(\"\\0\"):rep(R%64)end end end end;R:wait()end)R:wait()if P:status()==\"open\"then P:close()end;self:pasv(n)if self.transfer_params.type==\"A\"and O~=nil then O=O:gsub(\"[\\128-\\255]\",\"?\")end;return O,J,Q else local N,J,x=self:_send_command(\"PASV\")if J~=227 then return false,J,x end;local U,V,W,X,Y,Z=x:match((\"(%d+),\"):rep(5)..\"(%d+)\")local _=U..\".\"..V..\".\"..W..\".\"..X;local n=tonumber(Y)*256+tonumber(Z)local P,Q=l(_,n)if P==nil then return false,0,\"Could not connect to server: \"..Q end;local O,Q;local R=h.new(3)g(function()N,J,Q=self:_send_command(I)if not N then P:close()end;R:wait()end)g(function()while true do local S=v(P)if not S then break end;local M=self.transfer_params.mode;if\"S\"==M then O=(O or\"\")..S elseif\"B\"==M then local T=S:byte(1)local A=S:byte(2)*256+S:byte(3)O=(O or\"\")..y(S,A)if math.floor(T/128)==1 then P:close()break end elseif\"C\"==M then R=S:byte(1)if R==0 and math.floor(S:byte(2)/128)==1 then P:close()break elseif math.floor(R/128)==0 then O=(O or\"\")..S:sub(2,R%128+1)elseif math.floor(R/64)%2==0 then O=(O or\"\")..S:sub(2,2):rep(R%64)else if self.transfer_params.type==\"A\"or self.transfer_params.type==\"E\"then O=(O or\"\")..(\" \"):rep(R%64)elseif self.transfer_params.type==\"I\"or self.transfer_params.type==\"L\"then O=(O or\"\")..(\"\\0\"):rep(R%64)end end end end;R:wait()end)R:wait()if P:status()==\"open\"then P:close()end;if self.transfer_params.type==\"A\"and O~=nil then O=O:gsub(\"[\\128-\\255]\",\"?\")end;return O,J,Q end end,_send_data=function(self,I,O)if self.transfer_params.type==\"A\"then O=O:gsub(\"[\\128-\\255]\",\"?\")end;if self.pasv then local n=self:pasv()if n==nil then error(\"Ran out of ports for data connection\")end;local N,J,x=self:_send_command(\"PORT \"..self.connection:localIP():gsub(\"%.\",\",\")..\",\"..math.floor(n/256)..\",\"..n%256)if J~=200 then return false,J,x end;local P,Q;local R=h.new(2)g(function()N,J,Q=self:_send_command(I)if N then while true do coroutine.yield()end end;if R then R:wait()end end)g(function()P=p(self.connection:localIP(),n,self.timeout)if not P then return end;local M=self.transfer_params.mode;if\"S\"==M then for E=1,#O,65536 do P:write(O:sub(E,E+65535))end elseif\"B\"==M then for E=1,#O,65535 do local S=O:sub(E,E+65534)P:write((function()if#S<65535 then return\"\\0\"else return\"\\128\"end end)()..string.char(#S/256)..string.char(#S%256)..S)end elseif\"C\"==M then for E=1,#O,127 do local S=O:sub(E,E+126)P:write(string.char(#S)..S)end;P:write(\"\\0\\128\")end;P:close()if R then R:wait()end end)R:wait()R=nil;self:pasv(n)return N,J,Q else local N,J,x=self:_send_command(\"PASV\")if J~=227 then return false,J,x end;local U,V,W,X,Y,Z=x:match((\"(%d+),\"):rep(5)..\"(%d+)\")local _=U..\".\"..V..\".\"..W..\".\"..X;local n=tonumber(Y)*256+tonumber(Z)local P,Q=l(_,n)if P==nil then return false,0,\"Could not connect to server: \"..Q end;N,J,Q=self:_send_command(I)if not N then P:close()return N,J,Q end;local M=self.transfer_params.mode;if\"S\"==M then for E=1,#O,65536 do P:write(O:sub(E,E+65535))end elseif\"B\"==M then for E=1,#O,65535 do local S=O:sub(E,E+65534)P:write((function()if#S<65535 then return\"\\0\"else return\"\\128\"end end)()..string.char(#S/256)..string.char(#S%256)..S)end elseif\"C\"==M then for E=1,#O,127 do local S=O:sub(E,E+126)P:write(string.char(#S)..S)end;P:write(\"\\0\\128\")end;P:close()return true end end,login=function(self,a0,a1)if type(a0)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a0)..\")\",2)end;if a1~=nil and type(a1)~=\"string\"then error(\"bad argument #2 (expected string, got \"..type(a1)..\")\",2)end;local N,J,Q=self:_send_command(\"USER \"..a0)local M=J;if 230==M then return true elseif 500==M or 501==M or 421==M or 530==M then return false,Q elseif 331==M or 332==M then if a1==nil then return false,\"Password required\"end else error(\"Malformed reply (invalid code): \"..J)end;N,J,Q=self:_send_command(\"PASS \"..a1)local a2=J;if 230==a2 then return true elseif 202==a2 then return true elseif 500==a2 or 502==a2 or 421==a2 or 530==a2 then return false,Q elseif 332==a2 then return false,Q else return error(\"Malformed reply (invalid code): \"..J)end end,close=function(self)self:_send_command(\"QUIT\")return self.connection:close()end,setTransferParams=function(self,a3,w)if a3==nil then a3=self.transfer_params.type end;if w==nil then w=self.transfer_params.mode end;if type(a3)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a3)..\")\",2)end;if type(w)~=\"string\"then error(\"bad argument #2 (expected string, got \"..type(w)..\")\",2)end;if a3~=\"A\"and a3~=\"I\"then error(\"bad argument #1 (invalid data type)\",2)end;if w~=\"S\"and w~=\"B\"and w~=\"C\"then error(\"bad argument #2 (invalid transmission mode)\",2)end;if a3~=self.transfer_params.type then local N,J,Q=self:_send_command(\"TYPE \"..a3)if J==200 then self.transfer_params.type=a3 end end;if w~=self.transfer_params.mode then local N,J,Q=self:_send_command(\"MODE \"..w)if J==200 then self.transfer_params.mode=w end end;return self.transfer_params.type,self.transfer_params.mode end,list=function(self,a4)if type(a4)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a4)..\")\",2)end;if a4==\"\"then a4=\"/\"end;local a5;if self.transfer_params.type~=\"A\"then a5=self.transfer_params.type;if self:setTransferParams(\"A\")~=\"A\"then error(\"Could not switch to ASCII data type\")end end;local O,J,Q=self:_receive_data(\"NLST \"..a4)if a5 then self:setTransferParams(a5)end;if not O then error(Q..\" (\"..J..\")\",2)end;local a6={}local a7=1;for L in O:gmatch(\"[^\\r\\n]+\")do a6[a7]=L;a7=a7+1 end;return a6 end,stat=function(self,a4)return{size=0,type=self:isDir(a4)and\"directory\"or\"file\",created=0,modified=0,owner=\"root\",permissions={},worldPermissions={read=true,write=true,execute=true},setuser=false,capacity=0,freeSpace=0,special={}}end,isDir=function(self,a4)if type(a4)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a4)..\")\",2)end;if a4==\"\"then a4=\"/\"end;local N,J,Q=self:_send_command(\"CWD \"..a4)local M=J;if 533==M or 550==M then return false elseif 200==M or 250==M then self:_send_command(\"CWD /\")return true else return error(Q..\" (\"..J..\")\",2)end end,mkdir=function(self,a4)if type(a4)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a4)..\")\",2)end;local N,J,Q=self:_send_command(\"MKD \"..a4)if not N then return error(Q..\" (\"..J..\")\",2)end end,rename=function(self,a8,a9)if type(a8)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a8)..\")\",2)end;if type(a9)~=\"string\"then error(\"bad argument #2 (expected string, got \"..type(a9)..\")\",2)end;local N,J,Q=self:_send_command(\"RNFR \"..a8)if not N then error(Q..\" (\"..J..\")\",2)end;N,J,Q=self:_send_command(\"RNTO \"..a9)if not N then return error(Q..\" (\"..J..\")\",2)end end,remove=function(self,a4)if type(a4)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a4)..\")\",2)end;local N,J,Q=self:_send_command(\"DELE \"..a4)if not N then N=self:_send_command(\"RMD \"..a4)if N then for aa in ipairs(self:list(a4))do self:remove(a.combine(a4,aa))end else return error(Q..\" (\"..J..\")\",2)end end end,open=function(self,a4,w)if type(a4)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a4)..\")\",2)end;if type(w)~=\"string\"then error(\"bad argument #2 (expected string, got \"..type(w)..\")\",2)end;local M=w;if\"r\"==M then if self:setTransferParams(\"A\")~=\"A\"then error(\"Could not switch to ASCII data type\")end;local O,J,Q=self:_receive_data(\"RETR \"..a4)if O==nil then return nil,Q..\" (\"..J..\")\"end;local ab=1;return{close=function()return nil end,readLine=function()if ab>=#O then return nil end;local E=O:find(\"\\n\",ab)or#O+1;local ac=O:sub(ab,E-1)ab=E+1;return ac end,readAll=function()if ab>=#O then return nil end;local ac=O:sub(ab)ab=#O;return ac end,read=function(A)if ab>=#O then return nil end;local ac=O:sub(ab,ab+A)ab=ab+A;return ac end,seek=function(ad,ae)ae=ae or 0;if type(ad)==\"number\"and type(ae)==nil then ae=ad;ad=\"cur\"end;local a2=ad;if\"cur\"==a2 then ab=ab+math.max(math.min(ae,#O),0)elseif\"set\"==a2 then ab=math.max(math.min(ae,#O),0)elseif\"end\"==a2 then ab=math.max(math.min(#O-ae,#O),0)end;return ab end}elseif\"w\"==M then local O=\"\"local ab=1;local af={flush=function()if self:setTransferParams(\"A\")~=\"A\"then error(\"Could not switch to ASCII data type\")end;local N,J,Q=self:_send_data(\"STOR \"..a4,O)if not N then return error(Q..\" (\"..J..\")\")end end,write=function(z)O=O:sub(1,ab-1)..z..O:sub(ab)ab=ab+#z end,writeLine=function(z)O=O:sub(1,ab-1)..z..\"\\n\"..O:sub(ab)ab=ab+#z+1 end,seek=function(ad,ae)ae=ae or 0;if type(ad)==\"number\"and type(ae)==nil then ae=ad;ad=\"cur\"end;local a2=ad;if\"cur\"==a2 then ab=ab+math.max(math.min(ae,#O),0)elseif\"set\"==a2 then ab=math.max(math.min(ae,#O),0)elseif\"end\"==a2 then ab=math.max(math.min(#O-ae,#O),0)end;return ab end}af.close=af.flush;return af elseif\"a\"==M then local O=\"\"local ab=1;return{close=function()if self:setTransferParams(\"A\")~=\"A\"then error(\"Could not switch to ASCII data type\")end;local N,J,Q=self:_send_data(\"STOA \"..a4,O)if not N then return error(Q..\" (\"..J..\")\")end end,write=function(z)O=O:sub(1,ab-1)..z..O:sub(ab)ab=ab+#z end,writeLine=function(z)O=O:sub(1,ab-1)..z..\"\\n\"..O:sub(ab)ab=ab+#z+1 end,flush=function()return nil end}elseif\"rb\"==M then if self:setTransferParams(\"I\")~=\"I\"then error(\"Could not switch to Image data type\")end;local O,J,Q=self:_receive_data(\"RETR \"..a4)if O==nil then return nil,Q..\" (\"..J..\")\"end;local ab=1;return{close=function()return nil end,readAll=function()if ab>=#O then return nil end;local ac=O:sub(ab)ab=#O;return ac end,read=function(A)if ab>=#O then return nil end;if A==nil then ab=ab+1;return O:byte(ab-1)end;local ac=O:sub(ab,ab+A)ab=ab+A;return ac end,seek=function(ad,ae)ae=ae or 0;if type(ad)==\"number\"and type(ae)==nil then ae=ad;ad=\"cur\"end;local a2=ad;if\"cur\"==a2 then ab=ab+math.max(math.min(ae,#O),0)elseif\"set\"==a2 then ab=math.max(math.min(ae,#O),0)elseif\"end\"==a2 then ab=math.max(math.min(#O-ae,#O),0)end;return ab end}elseif\"wb\"==M then local O=\"\"local ab=1;local af={flush=function()if self:setTransferParams(\"I\")~=\"I\"then error(\"Could not switch to Image data type\")end;local N,J,Q=self:_send_data(\"STOR \"..a4,O)if not N then return error(Q..\" (\"..J..\")\")end end,write=function(z)O=O:sub(1,ab-1)..(function()if type(z)==\"number\"then return string.char(z)else return z end end)()..O:sub(ab)ab=ab+#z end,seek=function(ad,ae)ae=ae or 0;if type(ad)==\"number\"and type(ae)==nil then ae=ad;ad=\"cur\"end;local a2=ad;if\"cur\"==a2 then ab=ab+math.max(math.min(ae,#O),0)elseif\"set\"==a2 then ab=math.max(math.min(ae,#O),0)elseif\"end\"==a2 then ab=math.max(math.min(#O-ae,#O),0)end;return ab end}af.close=af.flush;return af elseif\"ab\"==M then local O=\"\"local ab=1;return{close=function()if self:setTransferParams(\"I\")~=\"I\"then error(\"Could not switch to Image data type\")end;local N,J,Q=self:_send_data(\"STOA \"..a4,O)if not N then return error(Q..\" (\"..J..\")\")end end,write=function(z)O=O:sub(1,ab-1)..(function()if type(z)==\"number\"then return string.char(z)else return z end end)()..O:sub(ab)ab=ab+#z end,flush=function()return nil end}else return nil,\"Unknown mode \\\"\"..w..'\"'end end}H.__index=H;G=setmetatable({__init=function(self,m,n,ag,q)if n==nil then n=21 end;if ag==nil then ag=false end;if q==nil then q=5 end;self.timeout=q;local Q;self.connection,Q=l(m,n)if self.connection==nil then error(\"Could not connect to server: \"..Q,2)end;self.pasv=ag;self.transfer_params={type=\"A\",mode=\"S\"}return self:_send_command()end,__base=H,__name=\"client\"},{__index=H,__call=function(ah,...)local ai=setmetatable({},H)ah.__init(ai,...)return ai end})H.__class=G;F=G end;local aj;do local G;local H={send=function(self,S)self.connection.socket:write(S)self.status.total_bytes=self.status.total_bytes+#S;self.status.current_bytes=self.status.current_bytes+#S end,send_data=function(self,O,ak)self.status.current_bytes=0;self.status.target_bytes=#O;local M=self.transfer_params.mode;if\"S\"==M then for E=1,#O,65536 do self:send(O:sub(E,E+65535))end elseif\"B\"==M then for E=1,#O,65535 do local S=O:sub(E,E+65534)self:send((function()if#S<65535 then return\"\\0\"else return\"\\128\"end end)()..string.char(#S/256)..string.char(#S%256)..S)end elseif\"C\"==M then for E=1,#O,127 do local S=O:sub(E,E+126)self:send(string.char(#S)..S)end;self:send(\"\\0\\128\")end;self.socket:write(\"226 Transfer complete\\n\")self.connection.socket:close()if self.connection.ip==nil then return ak(self.connection.port)end end,receive_data=function(self,ak)local O=\"\"while self.connection.socket:status()==\"open\"do local S=v(self.connection.socket)local M=self.transfer_params.mode;if\"S\"==M then O=(O or\"\")..S elseif\"B\"==M then local T=S:byte(1)local A=S:byte(2)*256+S:byte(3)O=(O or\"\")..y(S,A)if math.floor(T/128)==1 then self.connection.socket:close()break end elseif\"C\"==M then local R=S:byte(1)if R==0 and math.floor(S:byte(2)/128)==1 then self.connection.socket:close()break elseif math.floor(R/128)==0 then O=(O or\"\")..S:sub(2,R%128+1)elseif math.floor(R/64)%2==0 then O=(O or\"\")..S:sub(2,2):rep(R%64)else if self.transfer_params.type==\"A\"or self.transfer_params.type==\"E\"then O=(O or\"\")..(\" \"):rep(R%64)elseif self.transfer_params.type==\"I\"or self.transfer_params.type==\"L\"then O=(O or\"\")..(\"\\0\"):rep(R%64)end end end end;if self.connection.ip==nil then ak(self.connection.port)end;return O end}H.__index=H;G=setmetatable({__init=function(self,o)self.socket=o;self.dir=\"\"self.transfer_params={type=\"A\",mode=\"S\"}self.status={total_bytes=0,current_bytes=nil,target_bytes=nil,current_command=nil}end,__base=H,__name=\"server_connection\"},{__index=H,__call=function(ah,...)local ai=setmetatable({},H)ah.__init(ai,...)return ai end})H.__class=G;aj=G end;local al;do local G;local H={commands={USER=function(self,am,a0)if a0==nil then return\"501 Missing username\"end;am.username=a0;if self.auth==nil or self.auth(am.username)then return\"230 User logged in, proceed.\"else return\"331 User name okay, need password.\"end end,PASS=function(self,am,a1)if a1==nil then return\"501 Missing password\"end;am.password=a1;if self.auth==nil then return\"202 Password not required for this server.\"elseif self.auth(am.username,am.password)then return\"230 User logged in, proceed.\"else return\"530 Login incorrect.\"end end,ACCT=function(self,am)return\"502 ACCT command not implemented\"end,CWD=function(self,am,an)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if an==nil then return\"501 Missing file name\"end;local a4;if an:sub(1,1)==\"/\"then a4=an else a4=a.combine(am.dir,an)end;if not a.isDir(a4)then return\"550 Not a directory\"end;am.dir=a4;return\"200 OK\"end,CDUP=function(self,am)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;am.dir=a.combine(am.dir,\"..\")return\"200 OK\"end,SMNT=function(self,am)return\"502 SMNT command not implemented\"end,REIN=function(self,am)am.username=nil;am.password=nil;am.dir=\"\"am.connection=nil;am.transfer_params={type=\"A\",mode=\"S\"}return\"220 Service ready for new user.\"end,QUIT=function(self,am)am.socket:write(\"221 Goodbye.\\n\")return am.socket:close()end,PORT=function(self,am,n)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if n==nil then return\"501 Missing ID/port\"end;local ao={n:match(\"(%d+),(%d+),(%d+),(%d+),(%d+),(%d+)\")}if tonumber(ao[1])==nil or tonumber(ao[2])==nil or tonumber(ao[3])==nil or tonumber(ao[4])==nil or tonumber(ao[5])==nil or tonumber(ao[6])==nil then return\"501 Port specified is not correctly formatted\"end;am.connection={ip=(\"%d.%d.%d.%d\"):format(ao[1],ao[2],ao[3],ao[4]),port=bit32.lshift(tonumber(ao[5]),8)+tonumber(ao[6])}return\"200 OK\"end,PASV=function(self,am)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;am.connection={ip=nil,port=self.port_provider()}if not am.connection.port then return\"425 Can't open data connection.\"end;local _=am.socket.localIP()am.connection.task=self:_add_task(function()am.connection.socket=p(_,am.connection.port)end,\"passive listener \"..am.connection.port)return(\"227 Entering passive mode. %s,%d,%d\"):format(_:gsub(\"%.\",\",\"),bit32.rshift(bit32.band(am.connection.port,0xFF00),8),bit32.band(am.connection.port,0xFF))end,TYPE=function(self,am,type)local ap=type:sub(1,1):upper()if ap==\"E\"or ap==\"L\"then return\"504 Transfer type \"..ap..\" not supported\"end;if ap~=\"A\"and ap~=\"I\"then return\"501 Unknown transfer type \"..ap end;am.transfer_params.type=ap;return\"200 OK\"end,STRU=function(self,am)return\"502 STRU command not implemented\"end,MODE=function(self,am,w)local ap=w:sub(1,1):upper()if ap~=\"S\"and ap~=\"B\"and ap~=\"C\"then return\"501 Unknown transfer mode \"..ap end;am.transfer_params.mode=ap;return\"200 OK\"end,RETR=function(self,am,aq)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if aq==nil then return\"501 Missing file name\"end;if am.connection.port==nil then return\"503 Bad sequence of commands\"end;if am.current_task~=nil then return\"425 Data connection already open\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;if not a.exists(a4)or a.isDir(a4)then am.connection=nil;return\"550 \"..(a.isDir(a4)and\"Path is directory\"or\"File '\"..a4 ..\"' does not exist\")end;am.current_task=self:_add_task(function()if am.connection.ip~=nil then am.connection.socket=l(am.connection.ip,self.connection.port)end;if am.connection.socket==nil then if am.connection.task~=nil then self.tasks[am.connection.task]=nil end;am.connection=nil;am.socket:write(\"425 Unable to open data connection.\")end;local O;if am.transfer_params.type==\"A\"then local ar=a.open(a4,\"r\")O=ar.readAll()ar.close()else local ar=a.open(a4,\"rb\")O=ar.read(a.getSize(a4))ar.close()end;am:send_data(O,self.port_provider)am.connection=nil;am.current_task=nil;am.status.current_bytes=nil;am.status.target_bytes=nil;am.status.current_command=nil end,\"send data \"..aq)am.status.current_command=\"RETR \"..a4;if am.connection.socket==nil then return\"150 Opening data connection\"else return\"125 Data connection already open; transfer starting.\"end end,STOR=function(self,am,aq)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if aq==nil then return\"501 Missing file name\"end;if am.connection.port==nil then return\"503 Bad sequence of commands\"end;if am.current_task~=nil then return\"425 Data connection already open\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;if a.isDir(a4)then am.connection=nil;return\"550 Path is directory\"end;am.current_task=self:_add_task(function()if am.connection.ip~=nil then am.connection.socket=l(am.connection.ip,self.connection.port)end;if am.connection.socket==nil then if am.connection.task~=nil then self.tasks[am.connection.task]=nil end;am.connection=nil;am.socket:write(\"425 Unable to open data connection.\")end;local O=am:receive_data(self.port_provider)local ar;if am.transfer_params.type==\"A\"then ar=a.open(a4,\"w\")else ar=a.open(a4,\"wb\")end;ar.write(O)ar.close()am.socket:write(\"250 Transfer complete\")am.connection=nil;am.current_task=nil;am.status.current_bytes=nil;am.status.target_bytes=nil;am.status.current_command=nil end,\"receive data \"..aq)am.status.current_command=\"STOR \"..a4;if am.connection.socket==nil then return\"150 Opening data connection\"else return\"125 Data connection already open; transfer starting.\"end end,STOU=function(self,am)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if am.connection.port==nil then return\"503 Bad sequence of commands\"end;if am.current_task~=nil then return\"425 Data connection already open\"end;local as,a4;as=table.concat((function()local a6={}local a7=1;for E=1,8 do a6[a7]=string.char(math.random(65,90))a7=a7+1 end;return a6 end)())..\".\"..table.concat((function()local a6={}local a7=1;for E=1,3 do a6[a7]=string.char(math.random(65,90))a7=a7+1 end;return a6 end)())a4=a.combine(am.dir,as)while a.exists(a4 or a.isDir(a4))do as=table.concat((function()local a6={}local a7=1;for E=1,8 do a6[a7]=string.char(math.random(65,90))a7=a7+1 end;return a6 end)())..\".\"..table.concat((function()local a6={}local a7=1;for E=1,3 do a6[a7]=string.char(math.random(65,90))a7=a7+1 end;return a6 end)())a4=a.combine(am.dir,as)end;am.current_task=self:_add_task(function()if am.connection.ip~=nil then am.connection.socket=l(am.connection.ip,self.connection.port)end;if am.connection.socket==nil then if am.connection.task~=nil then self.tasks[am.connection.task]=nil end;am.connection=nil;am.socket:write(\"425 Unable to open data connection.\")end;local O=am:receive_data(self.port_provider)local ar;if am.transfer_params.type==\"A\"then ar=a.open(a4,\"w\")else ar=a.open(a4,\"wb\")end;ar.write(O)ar.close()am.socket:write(\"250 Transfer complete: \"..as)am.connection=nil;am.current_task=nil;am.status.current_bytes=nil;am.status.target_bytes=nil;am.status.current_command=nil end,\"store unique \"..a4)am.status.current_command=\"STOU \"..a4;if am.connection.socket==nil then return\"150 Opening data connection\"else return\"125 Data connection already open; transfer starting.\"end end,APPE=function(self,am,aq)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if aq==nil then return\"501 Missing file name\"end;if am.connection.port==nil then return\"503 Bad sequence of commands\"end;if am.current_task~=nil then return\"425 Data connection already open\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;if a.isDir(a4)then am.connection=nil;return\"550 Path is directory\"end;am.current_task=self:_add_task(function()if am.connection.ip~=nil then am.connection.socket=l(am.connection.ip,self.connection.port)end;if am.connection.socket==nil then if am.connection.task~=nil then self.tasks[am.connection.task]=nil end;am.connection=nil;am.socket:write(\"425 Unable to open data connection.\")end;local O=am:receive_data(self.port_provider)local ar;if am.transfer_params.type==\"A\"then ar=a.open(a4,\"a\")else ar=a.open(a4,\"ab\")end;ar.write(O)ar.close()am.socket:write(\"250 Transfer complete\")am.connection=nil;am.current_task=nil;am.status.current_bytes=nil;am.status.target_bytes=nil;am.status.current_command=nil end,\"append \"..aq)am.status.current_command=\"APPE \"..a4;if am.connection.socket==nil then return\"150 Opening data connection\"else return\"125 Data connection already open; transfer starting.\"end end,ALLO=function(self,am)return\"502 ALLO command not implemented\"end,REST=function(self,am)return\"502 REST command not implemented\"end,RNFR=function(self,am,as)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if as==nil then return\"501 Missing file name\"end;am.rename_from=as;return\"350 Awaiting name to rename to.\"end,RNTO=function(self,am,as)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if as==nil then return\"501 Missing file name\"end;if am.rename_from==nil then return\"503 Bad sequence of commands\"end;local at;if am.rename_from:sub(1,1)==\"/\"then at=am.rename_from else at=a.combine(am.dir,am.rename_from)end;local au;if as:sub(1,1)==\"/\"then au=as else au=a.combine(am.dir,as)end;a.move(at,au)am.rename_from=nil;return\"250 File operation succeeded\"end,ABOR=function(self,am)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if self.current_task==nil then return\"226 No data transfer in progress\"end;self.tasks[am.current_task]=nil;am.socket:write(\"426 Data transfer aborted.\")return\"226 Data transfer successfully aborted.\"end,DELE=function(self,am,aq)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if aq==nil then return\"501 Missing file name\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;if not fs.exists(a4)then return\"550 File not found\"end;if fs.isDir(a4)then return\"550 Path is directory\"end;a.delete(a4)return\"250 File deleted\"end,RMD=function(self,am,aq)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if aq==nil then return\"501 Missing file name\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;if not fs.exists(a4)then return\"550 Directory not found\"end;if not fs.isDir(a4)then return\"550 Path is not directory\"end;a.delete(a4)return\"250 Directory deleted\"end,MKD=function(self,am,aq)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if aq==nil then return\"501 Missing file name\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;a.makeDir(a4)return'257 Created directory \"'..a4 ..'\"'end,PWD=function(self,am)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;return'257 \"/'..am.dir..'\"'end,LIST=function(self,am,aq)if aq==nil then aq=am.dir end;if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if am.connection.port==nil then return\"503 Bad sequence of commands\"end;if am.current_task~=nil then return\"425 Data connection already open\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;if not a.isDir(a4)then am.connection=nil;return\"550 Path is not a directory\"end;am.current_task=self:_add_task(function()if am.connection.ip~=nil then am.connection.socket=l(am.connection.ip,self.connection.port)end;if am.connection.socket==nil then if am.connection.task~=nil then self.tasks[am.connection.task]=nil end;am.connection=nil;am.socket:write(\"425 Unable to open data connection.\")end;local av={}for E,aw in ipairs(a.list(a4))do local ao=a.combine(a4,aw)local ax=a.attributes(ao)av[E]=(\"%s%s % 4d craftos craftos % 8d %s %s\"):format(ax.isDir and\"d\"or\"-\",(ax.isReadOnly and\"r-x\"or\"rwx\"):rep(3),ax.isDir and#a.list(ao)or 1,ax.size,os.date(\"%h %e  %Y\",ax.modified/1000),aw)end;am:send_data(table.concat(av,\"\\n\")..\"\\n\",self.port_provider)am.connection=nil;am.current_task=nil;am.status.current_bytes=nil;am.status.target_bytes=nil;am.status.current_command=nil end,\"name list \"..aq)am.status.current_command=\"NLST \"..a4;if am.connection.socket==nil then return\"150 Opening data connection\"else return\"125 Data connection already open; transfer starting.\"end end,NLST=function(self,am,aq)if aq==nil then aq=am.dir end;if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if am.connection.port==nil then return\"503 Bad sequence of commands\"end;if am.current_task~=nil then return\"425 Data connection already open\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;if not a.isDir(a4)then am.connection=nil;return\"550 Path is not a directory\"end;am.current_task=self:_add_task(function()if am.connection.ip~=nil then am.connection.socket=l(am.connection.ip,self.connection.port)end;if am.connection.socket==nil then if am.connection.task~=nil then self.tasks[am.connection.task]=nil end;am.connection=nil;am.socket:write(\"425 Unable to open data connection.\")end;am:send_data(table.concat((function()local a6={}local a7=1;for ay,aw in ipairs(a.list(a4))do a6[a7]=aw;a7=a7+1 end;return a6 end)(),\"\\n\")..\"\\n\",self.port_provider)am.connection=nil;am.current_task=nil;am.status.current_bytes=nil;am.status.target_bytes=nil;am.status.current_command=nil end,\"name list \"..aq)am.status.current_command=\"NLST \"..a4;if am.connection.socket==nil then return\"150 Opening data connection\"else return\"125 Data connection already open; transfer starting.\"end end,SITE=function(self,am)return\"202 Not implemented\"end,SYST=function(self,am)return\"215 UNKNOWN Phoenix\"end,STAT=function(self,am)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;return\"211-Status of '\"..tostring(b(\"/\",\"getLabel\"))..\"'\\n Connected from ID \"..tostring(am.socket.id)..\"\\n Logged in as \"..tostring(am.username)..\"\\n TYPE: \"..tostring(am.transfer.params==\"A\"and\"ASCII\"or\"Image\")..\", STRUcture: File, Mode: \"..tostring(am.transfer.params==\"S\"and\"Stream\"or(am.transfer.params==\"B\"and\"Block\"or\"Compressed\"))..\"\\n Total bytes transferred for session: \"..tostring(am.status.total_bytes)..\"\\n\"..(self.current_task==nil and\"No data connection\"or tostring(am.connection.id==nil and\"Passive\"or\"Active\")..\" data transfer from \"..tostring(am.connection.socket.id)..\" port \"..tostring(am.connection.port)..\"\\n\"..tostring(am.status.current_command)..\" (\"..tostring(am.status.target_bytes)..\"/\"..tostring(am.status.current_bytes)..\")\")..\"\\n211 End of status\"end,HELP=function(self,am,az)return\"202 Not implemented (yet)\"end,NOOP=function(self,am)return\"200 NOOP command successful\"end},_add_task=function(self,aA,as)return g(aA)end,listen=function(self)local r=\"psp://\"..self.ip..\":\"..self.port;d(r)while true do local t,u=coroutine.yield()if t==\"network_request\"and u.uri==r then self:_add_task(function()return self:run(u.handle)end,\"connection \"..u.handle.id)end end end,run=function(self,o)return self:_run_connection(aj(o))end,_run_connection=function(self,am)am.socket:write(\"220 Hello!\\n\")while am.socket:status()==\"open\"do local aB=v(am.socket)if not aB then break end;local I,aC=aB:gsub(\"%s+$\",\"\")if aB:find(\" \")then I,aC=aB:sub(1,aB:find(\" \")-1):upper():gsub(\"%s+$\",\"\"),aB:sub(aB:find(\" \")+1):gsub(\"%s+$\",\"\")end;if self.commands[I]==nil then am.socket:write(\"500 Unknown command '\"..I..\"'\\n\")else if aC==\"\"then aC=nil end;local K=self.commands[I](self,am,aC)if not(am.socket:status()==\"open\")then break end;if K and self.commands[I]~=nil then am.socket:write(K..\"\\n\")end end end;return am.socket:close()end}H.__index=H;G=setmetatable({__init=function(self,m,n,aD,ak)if m==nil then m=\"0.0.0.0\"end;if n==nil then n=21 end;if aD==nil then aD=nil end;if ak==nil then ak=B()end;self.port=n;self.auth=aD;self.filesystem=a;self.port_provider=ak;self.ip=m end,__base=H,__name=\"server\"},{__index=H,__call=function(ah,...)local ai=setmetatable({},H)ah.__init(ai,...)return ai end})H.__class=G;al=G end;return{client=F,server=al}\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292168,size=32975},["pgp.lua"]={type="file",created=1740881293154,worldPermissions={execute=false,read=true,write=false},data="local a=require\"system.expect\"local b=require\"system.serialization\"local c=require\"ccryptolib.ed25519\"local d=require\"sha2\"local e={}local function f(g)local h=0xB704CE;for i in g:gmatch\".\"do h=bit32.bxor(h,i:byte()*0x10000)for _=1,8 do h=h*2;if h>0xFFFFFF then h=bit32.bxor(bit32.band(h,0xFFFFFF),0x864CFB)end end end;return bit32.band(h,0xFFFFFF)end;local j={d.md5,d.sha1,nil,nil,nil,nil,nil,d.sha256,d.sha384,d.sha512,d.sha224,d.sha3_256,nil,d.sha3_512}function e.decodeASC(k)a(1,k,\"string\")local l,m,n,o=k:match(\"%-%-%-%-%-BEGIN ([^%-]+)%-%-%-%-%-(.*)\\n\\n(.+)\\n%-%-%-%-%-END %1%-%-%-%-%-\")if not l then error(\"Invalid ASCII armor data\",2)end;n=n:gsub(\"%s+$\",\"\")if n:match(\"\\n=....$\")then o,n=n:sub(-4),n:sub(1,-7)end;local p=b.base64.decode(n:gsub(\"[^A-Za-z0-9/+=]\",\"\"))if o then local q=(\">I3\"):unpack(b.base64.decode(o))local r=f(p)if q~=r then error(\"Checksum failed\",2)end end;return p,l end;function e.encodeASC(g,l)a(1,g,\"string\")return(\"-----BEGIN %s-----\\n\\n%s\\n=%s\\n-----END %s-----\\n\"):format(l,b.base64.encode(g):gsub((\".\"):rep(76),\"%0\\n\"),b.base64.encode((\">I3\"):pack(f(g))),l)end;function e.readKeys(g)a(1,g,\"string\")local s=1;local t={}while s<=#g do local u=g:byte(s)if u<0x80 then error(\"Invalid packet data\",2)end;local v,w;if u>=0xC0 then v=bit32.band(u,0x3F)if g:byte(s+1)<0xC0 then w,s=g:byte(s+1),s+2 elseif g:byte(s+1)~=0xFF then w,s=(g:byte(s+1)-192)*256+g:byte(s+2)+192,s+3 else w,s=(\">I4\"):unpack(g,s+1)end else local x=bit32.band(u,3)if x==3 then error(\"Unsupported packet length\",2)end;v,w,s=bit32.band(bit32.rshift(u,2),0x0F),(\">I\"..2^x):unpack(g,s+1)end;if v==5 or v==6 or v==7 or v==14 then local y=s;local z=g:byte(s)if z==4 then local A,B;A,B,s=(\">I4B\"):unpack(g,s+1)if B==0x16 then local C;C,s=(\">s1\"):unpack(g,s)if C==\"\\x2B\\x06\\x01\\x04\\x01\\xDA\\x47\\x0F\\x01\"then local D;D,s=(\">I2\"):unpack(g,s)if D~=0x0107 or g:byte(s)~=0x40 then error(\"Invalid key in data stream\",2)end;local E=g:sub(s+1,s+32)s=s+33;local F=d.sha1(\"\\x99\"..(\">I2\"):pack(s-y)..g:sub(y,s-1))t[#t+1]={public=E,creationTime=A,fingerprint=F,keyID=F:sub(25,40)}else error(\"Unsupported algorithm encountered; cannot determine key length\",2)end elseif B==0x1B then local E=g:sub(s,s+31)s=s+32;local F=d.sha1(\"\\x99\"..(\">I2\"):pack(s-y)..g:sub(y,s-1))t[#t+1]={public=E,creationTime=A,fingerprint=F,keyID=F:sub(25,40)}elseif B==0x12 then local D;_,D,s=(\">s1I2\"):unpack(g,s)s=s+math.ceil(D/8)_,s=(\">s1\"):unpack(g,s)elseif B==0x19 then s=s+32 else error(\"Unsupported algorithm encountered; cannot determine key length\",2)end elseif z==6 then local A,B,G;A,B,G,s=(\">I4Bs4\"):unpack(g,s+1)if B==0x16 then local C,H=(\">s1\"):unpack(G)if C==\"\\x2B\\x06\\x01\\x04\\x01\\xDA\\x47\\x0F\\x01\"then local D;D,H=(\">I2\"):unpack(G,H)if D~=0x0107 or G:byte(H)~=0x40 then error(\"Invalid key in data stream\",2)end;local E=G:sub(H+1,H+32)local F=d.sha256(\"\\x9B\"..(\">I2\"):pack(s-y)..g:sub(y,s-1))t[#t+1]={public=E,creationTime=A,fingerprint=F,keyID=F:sub(1,16)}end elseif B==0x1B then local F=d.sha256(\"\\x9B\"..(\">I2\"):pack(s-y)..g:sub(y,s-1))t[#t+1]={public=G,creationTime=A,fingerprint=F,keyID=F:sub(1,16)}end else s=s+w end else s=s+w end end;return t end;function e.verify(g,I,t)a(1,g,\"string\")a(2,I,\"string\")a(3,t,\"table\")local s=1;local u=I:byte(s)if u<0x80 then error(\"Invalid packet data\",2)end;local v,w;if u>=0xC0 then v=bit32.band(u,0x3F)if I:byte(s+1)<0xC0 then w,s=I:byte(s+1),s+2 elseif I:byte(s+1)~=0xFF then w,s=(I:byte(s+1)-192)*256+I:byte(s+2)+192,s+3 else w,s=(\">I4\"):unpack(I,s+1)end else local x=bit32.band(u,3)if x==3 then error(\"Unsupported packet length\",2)end;v,w,s=bit32.band(bit32.rshift(u,2),0x0F),(\">I\"..2^x):unpack(I,s+1)end;if v~=2 then error(\"Not a valid signature\",2)end;local y=s;local z=I:byte(s)if z==4 or z==6 then local J={(z==4 and\">BBBs2s2I2\"or\">BBBs4s4I2s1\"):unpack(I,s+1)}s=table.remove(J)if J[1]==1 then g=g:gsub(\"([^\\r])\\n\",\"%1\\r\\n\"):gsub(\"^\\n\",\"\\r\\n\")end;local K=(J[7]or\"\")..g..(z==4 and\">BBBBs2\"or\">BBBBs4  \"):pack(z,J[1],J[2],J[3],J[4])..string.char(z)..\"\\xFF\"..(\">I4\"):pack(#J[4]+(z==4 and 6 or 8))local L=d.hex_to_bin(assert(j[J[3]],\"Unsupported hashing algorithm\")(K))if(\">I2\"):unpack(L:sub(1,2))~=J[6]then return false end;if J[2]==0x16 then local M,N,O,P;M,N,O,P,s=(\">I2c32I2c32\"):unpack(I,s)for _,Q in ipairs(t)do if c.verify(Q.public,L,N..P)then return true end end;return false elseif J[2]==0x1B then local R=I:sub(s,s+63)for _,Q in ipairs(t)do if c.verify(Q.public,L,R)then return true end end;return false else error(\"Unsupported signature algorithm\",2)end else error(\"Unsupported signature version\")end end;function e.verifyMessage(S,t)a(1,S,\"string\")a(2,t,\"table\")local m,g,I=S:match(\"%-%-%-%-%-BEGIN PGP SIGNED MESSAGE%-%-%-%-%-(.*)\\n\\n(.-)\\n(%-%-%-%-%-BEGIN PGP SIGNATURE%-%-%-%-%-\\n.-\\n%-%-%-%-%-END PGP SIGNATURE%-%-%-%-%-)\")if not m then error(\"Invalid message format\",2)end;return e.verify(g:gsub(\"\\n%- \",\"\\n-\"):gsub(\"^%- \",\"-\"),e.decodeASC(I),t),g end;return e\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881293152,size=4887},["aes.lua"]={type="file",created=1740881291114,worldPermissions={write=false,read=true,execute=false},data="local a={[0]=99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22}local b={[0]=82,9,106,213,48,54,165,56,191,64,163,158,129,243,215,251,124,227,57,130,155,47,255,135,52,142,67,68,196,222,233,203,84,123,148,50,166,194,35,61,238,76,149,11,66,250,195,78,8,46,161,102,40,217,36,178,118,91,162,73,109,139,209,37,114,248,246,100,134,104,152,22,212,164,92,204,93,101,182,146,108,112,72,80,253,237,185,218,94,21,70,87,167,141,157,132,144,216,171,0,140,188,211,10,247,228,88,5,184,179,69,6,208,44,30,143,202,63,15,2,193,175,189,3,1,19,138,107,58,145,17,65,79,103,220,234,151,242,207,206,240,180,230,115,150,172,116,34,231,173,53,133,226,249,55,232,28,117,223,110,71,241,26,113,29,41,197,137,111,183,98,14,170,24,190,27,252,86,62,75,198,210,121,32,154,219,192,254,120,205,90,244,31,221,168,51,136,7,199,49,177,18,16,89,39,128,236,95,96,81,127,169,25,181,74,13,45,229,122,159,147,201,156,239,160,224,59,77,174,42,245,176,200,235,187,60,131,83,153,97,23,43,4,126,186,119,214,38,225,105,20,99,85,33,12,125}local c={[0]=0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,27,25,31,29,19,17,23,21,11,9,15,13,3,1,7,5,59,57,63,61,51,49,55,53,43,41,47,45,35,33,39,37,91,89,95,93,83,81,87,85,75,73,79,77,67,65,71,69,123,121,127,125,115,113,119,117,107,105,111,109,99,97,103,101,155,153,159,157,147,145,151,149,139,137,143,141,131,129,135,133,187,185,191,189,179,177,183,181,171,169,175,173,163,161,167,165,219,217,223,221,211,209,215,213,203,201,207,205,195,193,199,197,251,249,255,253,243,241,247,245,235,233,239,237,227,225,231,229}local d={[0]=0,3,6,5,12,15,10,9,24,27,30,29,20,23,18,17,48,51,54,53,60,63,58,57,40,43,46,45,36,39,34,33,96,99,102,101,108,111,106,105,120,123,126,125,116,119,114,113,80,83,86,85,92,95,90,89,72,75,78,77,68,71,66,65,192,195,198,197,204,207,202,201,216,219,222,221,212,215,210,209,240,243,246,245,252,255,250,249,232,235,238,237,228,231,226,225,160,163,166,165,172,175,170,169,184,187,190,189,180,183,178,177,144,147,150,149,156,159,154,153,136,139,142,141,132,135,130,129,155,152,157,158,151,148,145,146,131,128,133,134,143,140,137,138,171,168,173,174,167,164,161,162,179,176,181,182,191,188,185,186,251,248,253,254,247,244,241,242,227,224,229,230,239,236,233,234,203,200,205,206,199,196,193,194,211,208,213,214,223,220,217,218,91,88,93,94,87,84,81,82,67,64,69,70,79,76,73,74,107,104,109,110,103,100,97,98,115,112,117,118,127,124,121,122,59,56,61,62,55,52,49,50,35,32,37,38,47,44,41,42,11,8,13,14,7,4,1,2,19,16,21,22,31,28,25,26}local e={[0]=0,9,18,27,36,45,54,63,72,65,90,83,108,101,126,119,144,153,130,139,180,189,166,175,216,209,202,195,252,245,238,231,59,50,41,32,31,22,13,4,115,122,97,104,87,94,69,76,171,162,185,176,143,134,157,148,227,234,241,248,199,206,213,220,118,127,100,109,82,91,64,73,62,55,44,37,26,19,8,1,230,239,244,253,194,203,208,217,174,167,188,181,138,131,152,145,77,68,95,86,105,96,123,114,5,12,23,30,33,40,51,58,221,212,207,198,249,240,235,226,149,156,135,142,177,184,163,170,236,229,254,247,200,193,218,211,164,173,182,191,128,137,146,155,124,117,110,103,88,81,74,67,52,61,38,47,16,25,2,11,215,222,197,204,243,250,225,232,159,150,141,132,187,178,169,160,71,78,85,92,99,106,113,120,15,6,29,20,43,34,57,48,154,147,136,129,190,183,172,165,210,219,192,201,246,255,228,237,10,3,24,17,46,39,60,53,66,75,80,89,102,111,116,125,161,168,179,186,133,140,151,158,233,224,251,242,205,196,223,214,49,56,35,42,21,28,7,14,121,112,107,98,93,84,79,70}local f={[0]=0,11,22,29,44,39,58,49,88,83,78,69,116,127,98,105,176,187,166,173,156,151,138,129,232,227,254,245,196,207,210,217,123,112,109,102,87,92,65,74,35,40,53,62,15,4,25,18,203,192,221,214,231,236,241,250,147,152,133,142,191,180,169,162,246,253,224,235,218,209,204,199,174,165,184,179,130,137,148,159,70,77,80,91,106,97,124,119,30,21,8,3,50,57,36,47,141,134,155,144,161,170,183,188,213,222,195,200,249,242,239,228,61,54,43,32,17,26,7,12,101,110,115,120,73,66,95,84,247,252,225,234,219,208,205,198,175,164,185,178,131,136,149,158,71,76,81,90,107,96,125,118,31,20,9,2,51,56,37,46,140,135,154,145,160,171,182,189,212,223,194,201,248,243,238,229,60,55,42,33,16,27,6,13,100,111,114,121,72,67,94,85,1,10,23,28,45,38,59,48,89,82,79,68,117,126,99,104,177,186,167,172,157,150,139,128,233,226,255,244,197,206,211,216,122,113,108,103,86,93,64,75,34,41,52,63,14,5,24,19,202,193,220,215,230,237,240,251,146,153,132,143,190,181,168,163}local g={[0]=0,13,26,23,52,57,46,35,104,101,114,127,92,81,70,75,208,221,202,199,228,233,254,243,184,181,162,175,140,129,150,155,187,182,161,172,143,130,149,152,211,222,201,196,231,234,253,240,107,102,113,124,95,82,69,72,3,14,25,20,55,58,45,32,109,96,119,122,89,84,67,78,5,8,31,18,49,60,43,38,189,176,167,170,137,132,147,158,213,216,207,194,225,236,251,246,214,219,204,193,226,239,248,245,190,179,164,169,138,135,144,157,6,11,28,17,50,63,40,37,110,99,116,121,90,87,64,77,218,215,192,205,238,227,244,249,178,191,168,165,134,139,156,145,10,7,16,29,62,51,36,41,98,111,120,117,86,91,76,65,97,108,123,118,85,88,79,66,9,4,19,30,61,48,39,42,177,188,171,166,133,136,159,146,217,212,195,206,237,224,247,250,183,186,173,160,131,142,153,148,223,210,197,200,235,230,241,252,103,106,125,112,83,94,73,68,15,2,21,24,59,54,33,44,12,1,22,27,56,53,34,47,100,105,126,115,80,93,74,71,220,209,198,203,232,229,242,255,180,185,174,163,128,141,154,151}local h={[0]=0,14,28,18,56,54,36,42,112,126,108,98,72,70,84,90,224,238,252,242,216,214,196,202,144,158,140,130,168,166,180,186,219,213,199,201,227,237,255,241,171,165,183,185,147,157,143,129,59,53,39,41,3,13,31,17,75,69,87,89,115,125,111,97,173,163,177,191,149,155,137,135,221,211,193,207,229,235,249,247,77,67,81,95,117,123,105,103,61,51,33,47,5,11,25,23,118,120,106,100,78,64,82,92,6,8,26,20,62,48,34,44,150,152,138,132,174,160,178,188,230,232,250,244,222,208,194,204,65,79,93,83,121,119,101,107,49,63,45,35,9,7,21,27,161,175,189,179,153,151,133,139,209,223,205,195,233,231,245,251,154,148,134,136,162,172,190,176,234,228,246,248,210,220,206,192,122,116,102,104,66,76,94,80,10,4,22,24,50,60,46,32,236,226,240,254,212,218,200,198,156,146,128,142,164,170,184,182,12,2,16,30,52,58,40,38,124,114,96,110,68,74,88,86,55,57,43,37,15,1,19,29,71,73,91,85,127,113,99,109,215,217,203,197,239,225,243,253,167,169,187,181,159,145,131,141}local i={{0x01,0x00,0x00,0x00},{0x02,0x00,0x00,0x00},{0x04,0x00,0x00,0x00},{0x08,0x00,0x00,0x00},{0x10,0x00,0x00,0x00},{0x20,0x00,0x00,0x00},{0x40,0x00,0x00,0x00},{0x80,0x00,0x00,0x00},{0x1b,0x00,0x00,0x00},{0x36,0x00,0x00,0x00}}local function j(k,l)if l==nil then l=\"%s\"end;local m={}for n in string.gmatch(k,\"([^\"..l..\"]+)\")do table.insert(m,n)end;return m end;local o={[16]=4,[24]=6,[32]=8}local p=4;local q={[16]=10,[24]=12,[32]=14}local function r(s)local t={[\"0\"]=0,[\"1\"]=1,[\"2\"]=2,[\"3\"]=3,[\"4\"]=4,[\"5\"]=5,[\"6\"]=6,[\"7\"]=7,[\"8\"]=8,[\"9\"]=9,[\"a\"]=10,[\"b\"]=11,[\"c\"]=12,[\"d\"]=13,[\"e\"]=14,[\"f\"]=15}local u=0;for v=1,#s do u=u+t[s:sub(v,v)]*16^(#s-v)end;return u end;local function w(s)local t={[0]=\"0\",[1]=\"1\",[2]=\"2\",[3]=\"3\",[4]=\"4\",[5]=\"5\",[6]=\"6\",[7]=\"7\",[8]=\"8\",[9]=\"9\",[10]=\"a\",[11]=\"b\",[12]=\"c\",[13]=\"d\",[14]=\"e\",[15]=\"f\"}local u=\"\"while s>0 do u=t[s%16]..u;s=math.floor(s/16)end;return u end;local function x(n)local u={}for v=1,#n do table.insert(u,n:sub(v,v):byte())end;return u end;local function y(z)local u=\"\"for v=1,#z do u=u..string.char(z[v])end;return u end;local function A(z,B,C)local u={}for v=B,C do table.insert(u,z[v])end;return u end;local function D(E)local u={a[E[1]],a[E[2]],a[E[3]],a[E[4]]}return u end;local function F(E)local G={E[2],E[3],E[4],E[1]}return G end;local function H(E,I)local u={bit32.bxor(E[1],I[1]),bit32.bxor(E[2],I[2]),bit32.bxor(E[3],I[3]),bit32.bxor(E[4],I[4])}return u end;local function J(K,L,M)local N;local O={}for v=1,L do O[v]={K[4*(v-1)+1],K[4*(v-1)+2],K[4*(v-1)+3],K[4*(v-1)+4]}end;for v=L+1,p*(M+1)do N=O[v-1]if(v-1)%L==0 then N=H(D(F(N)),i[(v-1)/L])elseif L>6 and(v-1)%L==4 then N=D(N)end;O[v]=H(O[v-L],N)end;return O end;local function P(Q)local u={}for R,S in ipairs(Q)do u[R]=S end;return u end;local function T(Q)local U={{a[Q[1][1]],a[Q[1][2]],a[Q[1][3]],a[Q[1][4]]},{a[Q[2][1]],a[Q[2][2]],a[Q[2][3]],a[Q[2][4]]},{a[Q[3][1]],a[Q[3][2]],a[Q[3][3]],a[Q[3][4]]},{a[Q[4][1]],a[Q[4][2]],a[Q[4][3]],a[Q[4][4]]}}return U end;local function V(Q)local U={{Q[1][1],Q[1][2],Q[1][3],Q[1][4]},{Q[2][2],Q[2][3],Q[2][4],Q[2][1]},{Q[3][3],Q[3][4],Q[3][1],Q[3][2]},{Q[4][4],Q[4][1],Q[4][2],Q[4][3]}}return U end;local function W(...)local X={...}local Y=X[1]table.remove(X,1)for R,S in ipairs(X)do Y=bit32.bxor(Y,S)end;return Y end;local function Z(Q)local _={{Q[1][1],Q[2][1],Q[3][1],Q[4][1]},{Q[1][2],Q[2][2],Q[3][2],Q[4][2]},{Q[1][3],Q[2][3],Q[3][3],Q[4][3]},{Q[1][4],Q[2][4],Q[3][4],Q[4][4]}}local a0={}for R,S in ipairs(_)do table.insert(a0,{})a0[R][1]=W(c[S[1]],d[S[2]],S[3],S[4])a0[R][2]=W(S[1],c[S[2]],d[S[3]],S[4])a0[R][3]=W(S[1],S[2],c[S[3]],d[S[4]])a0[R][4]=W(d[S[1]],S[2],S[3],c[S[4]])end;local U={{a0[1][1],a0[2][1],a0[3][1],a0[4][1]},{a0[1][2],a0[2][2],a0[3][2],a0[4][2]},{a0[1][3],a0[2][3],a0[3][3],a0[4][3]},{a0[1][4],a0[2][4],a0[3][4],a0[4][4]}}return U end;local function a1(Q,O,a2)local _={{Q[1][1],Q[2][1],Q[3][1],Q[4][1]},{Q[1][2],Q[2][2],Q[3][2],Q[4][2]},{Q[1][3],Q[2][3],Q[3][3],Q[4][3]},{Q[1][4],Q[2][4],Q[3][4],Q[4][4]}}local a3={}for v=4*(a2-1)+1,4*a2 do table.insert(a3,O[v])end;for R,S in ipairs(_)do _[R]=H(S,a3[R])end;local U={{_[1][1],_[2][1],_[3][1],_[4][1]},{_[1][2],_[2][2],_[3][2],_[4][2]},{_[1][3],_[2][3],_[3][3],_[4][3]},{_[1][4],_[2][4],_[3][4],_[4][4]}}return U end;local function a4(Q,O,M)local a5=P(Q)a5=a1(a5,O,1)for a6=1,M-1 do a5=T(a5)a5=V(a5)a5=Z(a5)a5=a1(a5,O,a6+1)end;a5=T(a5)a5=V(a5)a5=a1(a5,O,M+1)return a5 end;local function a7(a8)local u={{},{},{},{}}for a9=1,4 do for aa=1,4 do u[aa][a9]=a8[(a9-1)*4+aa]end end;return u end;local function ab(ac,K)if type(ac)~=\"table\"then error(\"AES_Encrypt: bad argument #1 (expected table, got \"..type(ac)..\")\")end;for R,S in ipairs(ac)do if type(S)~=\"number\"then error(\"AES_Encrypt: Invalid plaintext at \"..R..\" (expected number (0-255), got \"..type(S)..\")\")end;if S<0 or S>255 then error(\"AES_Encrypt: Invalid plaintext at \"..R..\" (expected number (0-255), got \"..S..\")\")end end;if type(K)~=\"table\"then error(\"AES_Encrypt: bad argument #2 (expected table, got \"..type(K)..\")\")end;for R,S in ipairs(K)do if type(S)~=\"number\"then error(\"AES_Encrypt: Invalid key at \"..R..\" (expected number (0-255), got \"..type(S)..\")\")end;if S<0 or S>255 then error(\"AES_Encrypt: Invalid key at \"..R..\" (expected number (0-255), got \"..S..\")\")end end;if#K>32 then K=A(K,1,32)end;if o[#K]==nil then error(\"AES_Encrypt: Key must be 16, 24, 32 characters long\")end;local ad={}for v=1,math.ceil(#ac/16)do table.insert(ad,a7(A(ac,16*(v-1)+1,16*(v-1)+16)))end;local O=J(K,o[#K],q[#K])for R,S in ipairs(ad)do ad[R]=a4(S,O,q[#K])end;local u={}for R,S in ipairs(ad)do for a9=1,4 do for aa=1,4 do table.insert(u,S[aa][a9])end end end;return u end;local function ae(Q)local U={{Q[1][1],Q[1][2],Q[1][3],Q[1][4]},{Q[2][4],Q[2][1],Q[2][2],Q[2][3]},{Q[3][3],Q[3][4],Q[3][1],Q[3][2]},{Q[4][2],Q[4][3],Q[4][4],Q[4][1]}}return U end;local function af(Q)local U={{b[Q[1][1]],b[Q[1][2]],b[Q[1][3]],b[Q[1][4]]},{b[Q[2][1]],b[Q[2][2]],b[Q[2][3]],b[Q[2][4]]},{b[Q[3][1]],b[Q[3][2]],b[Q[3][3]],b[Q[3][4]]},{b[Q[4][1]],b[Q[4][2]],b[Q[4][3]],b[Q[4][4]]}}return U end;local function ag(Q)local _={{Q[1][1],Q[2][1],Q[3][1],Q[4][1]},{Q[1][2],Q[2][2],Q[3][2],Q[4][2]},{Q[1][3],Q[2][3],Q[3][3],Q[4][3]},{Q[1][4],Q[2][4],Q[3][4],Q[4][4]}}local a0={}for R,S in ipairs(_)do table.insert(a0,{})a0[R][1]=W(h[S[1]],f[S[2]],g[S[3]],e[S[4]])a0[R][2]=W(e[S[1]],h[S[2]],f[S[3]],g[S[4]])a0[R][3]=W(g[S[1]],e[S[2]],h[S[3]],f[S[4]])a0[R][4]=W(f[S[1]],g[S[2]],e[S[3]],h[S[4]])end;local U={{a0[1][1],a0[2][1],a0[3][1],a0[4][1]},{a0[1][2],a0[2][2],a0[3][2],a0[4][2]},{a0[1][3],a0[2][3],a0[3][3],a0[4][3]},{a0[1][4],a0[2][4],a0[3][4],a0[4][4]}}return U end;local function ah(Q,O,M)local a5=P(Q)a5=a1(a5,O,M+1)for a6=M-1,1,-1 do a5=ae(a5)a5=af(a5)a5=a1(a5,O,a6+1)a5=ag(a5)end;a5=ae(a5)a5=af(a5)a5=a1(a5,O,1)return a5 end;local function ai(aj,K)if type(aj)~=\"table\"then error(\"AES_Decrypt: bad argument #1 (expected table, got \"..type(aj)..\")\")end;for R,S in ipairs(aj)do if type(S)~=\"number\"then error(\"AES_Decrypt: Invalid ciphertext at \"..R..\" (expected number (0-255), got \"..type(S)..\")\")end;if S<0 or S>255 then error(\"AES_Decrypt: Invalid ciphertext at \"..R..\" (expected number (0-255), got \"..S..\")\")end end;if type(K)~=\"table\"then error(\"AES_Decrypt: bad argument #2 (expected table, got \"..type(K)..\")\")end;for R,S in ipairs(K)do if type(S)~=\"number\"then error(\"AES_Decrypt: Invalid key at \"..R..\" (expected number (0-255), got \"..type(S)..\")\")end;if S<0 or S>255 then error(\"AES_Decrypt: Invalid key at \"..R..\" (expected number (0-255), got \"..S..\")\")end end;if#K>32 then K=A(K,1,32)end;if o[#K]==nil then error(\"AES_Decrypt: Key must be 16, 24, 32 characters long\")end;local ad={}for v=1,math.ceil(#aj/16)do table.insert(ad,a7(A(aj,16*(v-1)+1,16*(v-1)+16)))end;local O=J(K,o[#K],q[#K])for R,S in ipairs(ad)do ad[R]=ah(S,O,q[#K])end;local u={}for R,S in ipairs(ad)do for a9=1,4 do for aa=1,4 do table.insert(u,S[aa][a9])end end end;return u end;local function ak(n)local u={}for v=1,#n do table.insert(u,n:sub(v,v):byte())end;return u end;local function al(n)local function am(an)local u=\"\"for v=#an,1,-1 do u=u..an:sub(v,v)end;return u end;if n:match(\"e\")==nil then return am(n)else local ao=\"[\"..j(n,\".\")[1]..\".]\"n=n:gsub(ao,\"\")local ap=\"[e\"..j(n,\"e\")[2]..\"]\"n=n:gsub(ap,\"\")n=am(n)n=ao:gsub(\"[[]\",\"\"):gsub(\"[]]\",\"\")..n..ap:gsub(\"[[]\",\"\"):gsub(\"[]]\",\"\")return n end end;local function aq(z)local u=\"\"for v=1,#z do u=u..w(z[v])end;return u end;local function ar(ac,as,at,au)ac=ak(ac)for a6=0,as-1 do if a6%2~=0 then for v=1,#ac do ac[v]=ac[v]+(ac[v+1]~=nil and ac[v+1]or ac[1])+at end else for v=1,#ac do ac[v]=math.floor(tonumber(al(tostring(ac[v]))))end;for v=#ac,1,-1 do ac[v]=ac[v]+(ac[v-1]~=nil and ac[v-1]or ac[#ac])+at end end end;local u=aq(ac)while#u<au do u=u..u end;if#u>au then u=u:sub(1,au)end;return u end;local function av(n,at)if type(n)~=\"string\"then error(\"StringToKey: bad argument #1 (expected string, got \"..type(n)..\")\")end;if type(at)~=\"number\"then error(\"StringToKey: bad argument #2 (expected number, got \"..type(at)..\")\")end;local aw=ar(n,32,at,32)local K={}for v=1,#aw do table.insert(K,aw:sub(v,v):byte())end;return K end;local function ax()local ay={}local K={}for v=1,32 do local az=0;while az==0 or ay[az]~=nil do az=math.random(1,255)end;ay[az]=true;table.insert(K,az)end;return K end;local function aA(aB,aC)local u=P(aB)for aa=1,4 do for a9=1,4 do u[aa][a9]=W(u[aa][a9],aC[aa][a9])end end;return u end;local function aD(ac,K,aE)if type(ac)~=\"table\"then error(\"AES_EncryptCBC: bad argument #1 (expected table, got \"..type(ac)..\")\")end;for R,S in ipairs(ac)do if type(S)~=\"number\"then error(\"AES_EncryptCBC: Invalid plaintext at \"..R..\" (expected number (0-255), got \"..type(S)..\")\")end;if S<0 or S>255 then error(\"AES_EncryptCBC: Invalid plaintext at \"..R..\" (expected number (0-255), got \"..S..\")\")end end;if type(K)~=\"table\"then error(\"AES_EncryptCBC: bad argument #2 (expected table, got \"..type(K)..\")\")end;for R,S in ipairs(K)do if type(S)~=\"number\"then error(\"AES_EncryptCBC: Invalid key at \"..R..\" (expected number (0-255), got \"..type(S)..\")\")end;if S<0 or S>255 then error(\"AES_EncryptCBC: Invalid key at \"..R..\" (expected number (0-255), got \"..S..\")\")end end;if#K>32 then K=A(K,1,32)end;if o[#K]==nil then error(\"AES_EncryptCBC: Key must be 16, 24, 32 characters long\")end;if type(aE)~=\"table\"then error(\"AES_EncryptCBC: bad argument #3 (expected table, got \"..type(aE)..\")\")end;for R,S in ipairs(aE)do if type(S)~=\"number\"then error(\"AES_EncryptCBC: Invalid iv at \"..R..\" (expected number (0-255), got \"..type(S)..\")\")end;if S<0 or S>255 then error(\"AES_EncryptCBC: Invalid iv at \"..R..\" (expected number (0-255), got \"..S..\")\")end end;if#aE>16 then aE=A(aE,1,16)end;if#aE~=16 then error(\"AES_EncryptCBC: Iv must be 16 characters long\")end;local ad={}table.insert(ad,a7(aE))for v=1,math.ceil(#ac/16)do table.insert(ad,a7(A(ac,16*(v-1)+1,16*(v-1)+16)))end;local O=J(K,o[#K],q[#K])for v=2,#ad do ad[v]=aA(ad[v],ad[v-1])ad[v]=a4(ad[v],O,q[#K])end;local u={}table.remove(ad,1)for R,S in ipairs(ad)do for a9=1,4 do for aa=1,4 do table.insert(u,S[aa][a9])end end end;return u end;local function aF(aj,K,aE)if type(aj)~=\"table\"then error(\"AES_DecryptCBC: bad argument #1 (expected table, got \"..type(aj)..\")\")end;for R,S in ipairs(aj)do if type(S)~=\"number\"then error(\"AES_DecryptCBC: Invalid ciphertext at \"..R..\" (expected number (0-255), got \"..type(S)..\")\")end;if S<0 or S>255 then error(\"AES_DecryptCBC: Invalid ciphertext at \"..R..\" (expected number (0-255), got \"..S..\")\")end end;if type(K)~=\"table\"then error(\"AES_DecryptCBC: bad argument #2 (expected table, got \"..type(K)..\")\")end;for R,S in ipairs(K)do if type(S)~=\"number\"then error(\"AES_DecryptCBC: Invalid key at \"..R..\" (expected number (0-255), got \"..type(S)..\")\")end;if S<0 or S>255 then error(\"AES_DecryptCBC: Invalid key at \"..R..\" (expected number (0-255), got \"..S..\")\")end end;if#K>32 then K=A(K,1,32)end;if o[#K]==nil then error(\"AES_DecryptCBC: Key must be 16, 24, 32 characters long\")end;if type(aE)~=\"table\"then error(\"AES_DecryptCBC: bad argument #3 (expected table, got \"..type(aE)..\")\")end;for R,S in ipairs(aE)do if type(S)~=\"number\"then error(\"AES_DecryptCBC: Invalid iv at \"..R..\" (expected number (0-255), got \"..type(S)..\")\")end;if S<0 or S>255 then error(\"AES_DecryptCBC: Invalid iv at \"..R..\" (expected number (0-255), got \"..S..\")\")end end;if#aE>16 then aE=A(aE,1,16)end;if#aE~=16 then error(\"AES_DecryptCBC: Iv must be 16 characters long\")end;local aG={}local ad={}table.insert(aG,a7(aE))table.insert(ad,a7(aE))for v=1,math.ceil(#aj/16)do table.insert(ad,a7(A(aj,16*(v-1)+1,16*(v-1)+16)))table.insert(aG,a7(A(aj,16*(v-1)+1,16*(v-1)+16)))end;local O=J(K,o[#K],q[#K])for v=2,#ad do ad[v]=ah(ad[v],O,q[#K])ad[v]=aA(ad[v],aG[v-1])end;local u={}table.remove(ad,1)for R,S in ipairs(ad)do for a9=1,4 do for aa=1,4 do table.insert(u,S[aa][a9])end end end;return u end;return{Encrypt=ab,Decrypt=ai,EncryptCBC=aD,DecryptCBC=aF,StringToKey=av,GenerateRandomKey=ax,StringToTable=x,TableToString=y}\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881291112,size=19408},["libccryptolib.a"]={type="file",created=1740881291601,worldPermissions={execute=false,read=true,write=false},data="!<arch>\n//              0           0     0     666     114       `\ninternal_curve25519.lua/\ninternal_edwards25519.lua/\ninternal_packing.lua/\ninternal_sha512.lua/\ninternal_util.lua/\naead.lua/       1722465588  0     0     775     1508      `\nlocal a=require\"system.expect\".expect;local b=require\"internal_util\".lassert;local c=require\"internal_packing\"local d=require\"chacha20\"local e=require\"poly1305\"local f,g=c.compilePack(\"<I8\")local h,i=c.compileUnpack(\"<I4I4I4I4\")local j=bit32.bxor;local function k(l,m,n,o,p)a(1,l,\"string\")b(#l==32,\"key length must be 32\",2)a(2,m,\"string\")b(#m==12,\"nonce length must be 12\",2)a(3,n,\"string\")a(4,o,\"string\")p=a(5,p,\"number\",\"nil\")or 20;b(p%2==0,\"round number must be even\",2)b(p>=8,\"round number must be no smaller than 8\",2)b(p<=20,\"round number must be no larger than 20\",2)local q=(\"\\0\"):rep(64)..n;local r=d.crypt(l,m,q,p,0)local s=r:sub(1,32)local t=r:sub(65)local u=(\"\\0\"):rep(-#o%16)local v=(\"\\0\"):rep(-#t%16)local w=f(\"<I8\",#o)local x=f(\"<I8\",#t)local y=o..u..t..v..w..x;local z=e.mac(s,y)return t,z end;local function A(l,m,z,t,o,p)a(1,l,\"string\")b(#l==32,\"key length must be 32\",2)a(2,m,\"string\")b(#m==12,\"nonce length must be 12\",2)a(3,z,\"string\")b(#z==16,\"tag length must be 16\",2)a(4,t,\"string\")a(5,o,\"string\")p=a(6,p,\"number\",\"nil\")or 20;b(p%2==0,\"round number must be even\",2)b(p>=8,\"round number must be no smaller than 8\",2)b(p<=20,\"round number must be no larger than 20\",2)local s=d.crypt(l,m,(\"\\0\"):rep(32),p,0)local u=(\"\\0\"):rep(-#o%16)local v=(\"\\0\"):rep(-#t%16)local w=f(g,#o)local x=f(g,#t)local y=o..u..t..v..w..x;local B,C,D,E=h(i,z,1)local F,G,H,I=h(i,e.mac(s,y),1)local J=j(B,F)+j(C,G)+j(D,H)+j(E,I)if J~=0 then return nil end;return d.crypt(l,m,t,p)end;return{encrypt=k,decrypt=A}\nblake3.lua/     1722465587  0     0     775     3468      `\nlocal a=require\"system.expect\".expect;local b=require\"internal_util\".lassert;local c=require\"internal_packing\"local unpack=unpack or table.unpack;local d=bit32.bxor;local e=bit32.lrotate;local f,g=c.compilePack(\"<I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\")local h=c.compileUnpack(g)local i,j=c.compileUnpack(\"<I4I4I4I4I4I4I4I4\")local k=0x01;local l=0x02;local m=0x04;local n=0x08;local o=0x10;local p=0x20;local q=0x40;local r={0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19}local function s(t,u,v,w,x,y)local z,A,B,C,D,E,F,G=unpack(t)local H,I,J,K=z,A,B,C;local L,M,N,O=D,E,F,G;local P,Q,R,S=0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a;local T=v%2^32;local U=(v-T)*2^-32;local V,W,X,Y,Z,_,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9=unpack(u)local aa;for ab=1,7 do H=H+L+V;T=e(d(T,H),16)P=P+T;L=e(d(L,P),20)H=H+L+W;T=e(d(T,H),24)P=P+T;L=e(d(L,P),25)I=I+M+X;U=e(d(U,I),16)Q=Q+U;M=e(d(M,Q),20)I=I+M+Y;U=e(d(U,I),24)Q=Q+U;M=e(d(M,Q),25)J=J+N+Z;w=e(d(w,J),16)R=R+w;N=e(d(N,R),20)J=J+N+_;w=e(d(w,J),24)R=R+w;N=e(d(N,R),25)K=K+O+a0;x=e(d(x,K),16)S=S+x;O=e(d(O,S),20)K=K+O+a1;x=e(d(x,K),24)S=S+x;O=e(d(O,S),25)H=H+M+a2;x=e(d(x,H),16)R=R+x;M=e(d(M,R),20)H=H+M+a3;x=e(d(x,H),24)R=R+x;M=e(d(M,R),25)I=I+N+a4;T=e(d(T,I),16)S=S+T;N=e(d(N,S),20)I=I+N+a5;T=e(d(T,I),24)S=S+T;N=e(d(N,S),25)J=J+O+a6;U=e(d(U,J),16)P=P+U;O=e(d(O,P),20)J=J+O+a7;U=e(d(U,J),24)P=P+U;O=e(d(O,P),25)K=K+L+a8;w=e(d(w,K),16)Q=Q+w;L=e(d(L,Q),20)K=K+L+a9;w=e(d(w,K),24)Q=Q+w;L=e(d(L,Q),25)if ab~=7 then aa=X;X=Y;Y=a4;a4=a6;a6=a3;a3=a5;a5=_;_=V;V=aa;aa=a0;a0=Z;Z=a1;a1=a7;a7=a8;a8=a9;a9=a2;a2=W;W=aa end end;if y then return{d(H,P),d(I,Q),d(J,R),d(K,S),d(L,T),d(M,U),d(N,w),d(O,x),d(P,z),d(Q,A),d(R,B),d(S,C),d(T,D),d(U,E),d(w,F),d(x,G)}else return{d(H,P),d(I,Q),d(J,R),d(K,S),d(L,T),d(M,U),d(N,w),d(O,x)}end end;local function ac(ad,ae)for ab=1,8 do ad[ab+8]=ae[ab]end;return ad end;local function af(ag,ah,u,ai)local aj={}local ak=ag;local al=0;local am=0;local an=k;local ao=0;for ab=1,#u-64,64 do local ap={h(g,u,ab)}local aq=ah+an+ao;ak=s(ak,ap,al,64,aq)an=0;am=am+1;if am==15 then ao=l elseif am==16 then local ar=ak;local as=al+1;while as%2==0 do local ap=ac(table.remove(aj),ar)ar=s(ag,ap,0,64,ah+m)as=as/2 end;table.insert(aj,ar)ak=ag;al=al+1;am=0;an=k;ao=0 end end;local at=#u==0 and 0 or(#u-1)%64+1;local au=u:sub(-at)..(\"\\0\"):rep(64)local av={h(g,au,1)}local aw,ax,ay,az;if al>0 then local aq=ah+an+l;local ar=s(ak,av,al,at,aq)for ab=#aj,2,-1 do local ap=ac(aj[ab],ar)ar=s(ag,ap,0,64,ah+m)end;aw=ag;ax=ac(aj[1],ar)ay=64;az=ah+n+m else aw=ak;ax=av;ay=at;az=ah+an+l+n end;local aA={}for ab=0,ai/64 do local aB=s(aw,ax,ab,ay,az,true)aA[ab+1]=f(g,unpack(aB))end;return table.concat(aA):sub(1,ai)end;local function aC(aD,ai)a(1,aD,\"string\")ai=a(2,ai,\"number\",\"nil\")or 32;b(ai%1==0,\"desired output length must be an integer\",2)b(ai>=1,\"desired output length must be positive\",2)return af(r,0,aD,ai)end;local function aE(aF,aD,ai)a(1,aF,\"string\")b(#aF==32,\"key length must be 32\",2)a(2,aD,\"string\")ai=a(3,ai,\"number\",\"nil\")or 32;b(ai%1==0,\"desired output length must be an integer\",2)b(ai>=1,\"desired output length must be positive\",2)return af({i(j,aF,1)},o,aD,ai)end;local function aG(aH)a(1,aH,\"string\")local ag={i(j,af(r,p,aH,32),1)}return function(aI,ai)a(1,aI,\"string\")ai=a(2,ai,\"number\",\"nil\")or 32;b(ai%1==0,\"desired output length must be an integer\",2)b(ai>=1,\"desired output length must be positive\",2)return af(ag,q,aI,ai)end end;return{digest=aC,digestKeyed=aE,deriveKey=aG}\nchacha20.lua/   1722465587  0     0     775     2047      `\nlocal a=require\"system.expect\".expect;local b=require\"internal_util\".lassert;local c=require\"internal_packing\"local d=bit32.bxor;local e=bit32.lrotate;local f,g=c.compileUnpack(\"<I4I4I4I4I4I4I4I4\")local h,i=c.compileUnpack(\"<I4I4I4\")local j,k=c.compilePack(\"<I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\")local l=c.compileUnpack(k)local function m(n,o,p,q,r)a(1,n,\"string\")b(#n==32,\"key length must be 32\",2)a(2,o,\"string\")b(#o==12,\"nonce length must be 12\",2)a(3,p,\"string\")q=a(4,q,\"number\",\"nil\")or 20;b(q%2==0,\"round number must be even\",2)b(q>=8,\"round number must be no smaller than 8\",2)b(q<=20,\"round number must be no larger than 20\",2)r=a(5,r,\"number\",\"nil\")or 1;b(r%1==0,\"offset must be an integer\",2)b(r>=0,\"offset must be nonnegative\",2)b(#p+64*r<=2^38,\"offset too large\",2)local s,t,u,v=0x61707865,0x3320646e,0x79622d32,0x6b206574;local w,x,y,z,A,B,C,D=f(g,n,1)local E,F,G,H=r,h(i,o,1)local I=p..(\"\\0\"):rep(-#p%64)local J={}local K=1;for L=1,#I/64 do local M,N,O,P=s,t,u,v;local Q,R,S,T=w,x,y,z;local U,V,W,X=A,B,C,D;local Y,Z,_,a0=E,F,G,H;for a1=1,q,2 do M=M+Q;Y=e(d(Y,M),16)U=U+Y;Q=e(d(Q,U),12)M=M+Q;Y=e(d(Y,M),8)U=U+Y;Q=e(d(Q,U),7)N=N+R;Z=e(d(Z,N),16)V=V+Z;R=e(d(R,V),12)N=N+R;Z=e(d(Z,N),8)V=V+Z;R=e(d(R,V),7)O=O+S;_=e(d(_,O),16)W=W+_;S=e(d(S,W),12)O=O+S;_=e(d(_,O),8)W=W+_;S=e(d(S,W),7)P=P+T;a0=e(d(a0,P),16)X=X+a0;T=e(d(T,X),12)P=P+T;a0=e(d(a0,P),8)X=X+a0;T=e(d(T,X),7)M=M+R;a0=e(d(a0,M),16)W=W+a0;R=e(d(R,W),12)M=M+R;a0=e(d(a0,M),8)W=W+a0;R=e(d(R,W),7)N=N+S;Y=e(d(Y,N),16)X=X+Y;S=e(d(S,X),12)N=N+S;Y=e(d(Y,N),8)X=X+Y;S=e(d(S,X),7)O=O+T;Z=e(d(Z,O),16)U=U+Z;T=e(d(T,U),12)O=O+T;Z=e(d(Z,O),8)U=U+Z;T=e(d(T,U),7)P=P+Q;_=e(d(_,P),16)V=V+_;Q=e(d(Q,V),12)P=P+Q;_=e(d(_,P),8)V=V+_;Q=e(d(Q,V),7)end;local a2,a3,a4,a5,a6,a7,a8,a9;local aa,ab,ac,ad,ae,af,ag,ah;a2,a3,a4,a5,a6,a7,a8,a9,aa,ab,ac,ad,ae,af,ag,ah,K=l(k,I,K)J[L]=j(k,d(a2,M+s),d(a3,N+t),d(a4,O+u),d(a5,P+v),d(a6,Q+w),d(a7,R+x),d(a8,S+y),d(a9,T+z),d(aa,U+A),d(ab,V+B),d(ac,W+C),d(ad,X+D),d(ae,Y+E),d(af,Z+F),d(ag,_+G),d(ah,a0+H))E=E+1 end;return table.concat(J):sub(1,#p)end;return{crypt=m}\n\ned25519.lua/    1722465587  0     0     775     1243      `\nlocal a=require\"system.expect\".expect;local b=require\"internal_util\".lassert;local c=require\"internal_fq\"local d=require\"internal_sha512\"local e=require\"internal_edwards25519\"local f=require\"random\"local function g(h)a(1,h,\"string\")assert(#h==32,\"secret key length must be 32\")local i=d.digest(h)local j=c.decodeClamped(i:sub(1,32))return e.encode(e.mulG(c.bits(j)))end;local function k(h,l,m)a(1,h,\"string\")b(#h==32,\"secret key length must be 32\",2)a(2,l,\"string\")b(#l==32,\"public key length must be 32\",2)a(3,m,\"string\")local i=d.digest(h)local j=c.decodeClamped(i:sub(1,32))local n=c.decodeWide(f.random(64))local o=e.mulG(c.bits(n))local p=e.encode(o)local q=c.decodeWide(d.digest(p..l..m))local r=c.decodeWide(f.random(64))local s=c.sub(c.add(n,c.mul(c.add(j,r),q)),c.mul(r,q))local t=c.encode(s)return p..t end;local function u(l,m,v)a(1,l,\"string\")b(#l==32,\"public key length must be 32\",2)a(2,m,\"string\")a(3,v,\"string\")b(#v==64,\"signature length must be 64\",2)local w=e.decode(l)if not w then return false end;local p=v:sub(1,32)local t=v:sub(33)local q=c.decodeWide(d.digest(p..l..m))local x=e.mulG(c.bits(c.decode(t)))local y=e.mul(w,c.bits(q))local z=e.sub(x,e.niels(y))return e.encode(z)==p end;return{publicKey=g,sign=k,verify=u}\n\npoly1305.lua/   1722465588  0     0     775     2009      `\nlocal a=require\"system.expect\".expect;local b=require\"internal_util\".lassert;local c=require\"internal_packing\"local d,e=c.compileUnpack(\"<I4I4I4I4\")local f=c.compilePack(e)local function g(h,i)a(1,h,\"string\")b(#h==32,\"key length must be 32\",2)a(2,i,\"string\")local j=#i-15;if#i%16~=0 or#i==0 then i=i..\"\\1\"i=i..(\"\\0\"):rep(-#i%16)end;local k,l,m,n=d(e,h,1)k=k%2^28;l=(l-l%4)%2^28*2^32;m=(m-m%4)%2^28*2^64;n=(n-n%4)%2^28*2^96;local o=k%2^18;local p=k-o;local q=l%2^50;local r=l-q;local s=m%2^82;local t=m-s;local u=n%2^112;local v=n-u;local w=5/2^130*l;local x=5/2^130*m;local y=5/2^130*n;local z=w%2^-80;local A=w-z;local B=x%2^-48;local C=x-B;local D=y%2^-16;local E=y-D;local F,G,H,I,J,K,L,M=0,0,0,0,0,0,0,0;for N=1,#i,16 do local O,P,Q,R=d(e,i,N)local S=F+G+O;local T=H+I+P*2^32;local U=J+K+Q*2^64;local V=L+M+R*2^96;if N<=j then V=V+2^128 end;F=S*o+T*D+U*B+V*z;G=S*p+T*E+U*C+V*A;H=S*q+T*o+U*D+V*B;I=S*r+T*p+U*E+V*C;J=S*s+T*q+U*o+V*D;K=S*t+T*r+U*p+V*E;L=S*u+T*s+U*q+V*o;M=S*v+T*t+U*r+V*p;local W=F+3*2^69-3*2^69;F=F-W;G=G+W;local X=G+3*2^83-3*2^83;G=G-X;H=H+X;local Y=H+3*2^101-3*2^101;H=H-Y;I=I+Y;local Z=I+3*2^115-3*2^115;I=I-Z;J=J+Z;local _=J+3*2^133-3*2^133;J=J-_;K=K+_;local a0=K+3*2^147-3*2^147;K=K-a0;L=L+a0;local a1=L+3*2^163-3*2^163;L=L-a1;M=M+a1;local a2=M+3*2^181-3*2^181;M=M-a2;F=F+5/2^130*a2 end;local a3=F%2^16;G=F-a3+G;local a4=G%2^32;H=G-a4+H;local a5=H%2^48;I=H-a5+I;local a6=I%2^64;J=I-a6+J;local a7=J%2^80;K=J-a7+K;local a8=K%2^96;L=K-a8+L;local a9=L%2^112;M=L-a9+M;local aa=M%2^130;F=a3+5/2^130*(M-aa)a3=F%2^16;a4=F-a3+a4;if aa==0x3ffff*2^112 and a9==0xffff*2^96 and a8==0xffff*2^80 and a7==0xffff*2^64 and a6==0xffff*2^48 and a5==0xffff*2^32 and a4==0xffff*2^16 and a3>=0xfffb then aa,a9,a8,a7,a6,a5,a4,a3=0,0,0,0,0,0,0,a3-0xfffb end;local ab,ac,z,A=d(e,h,17)local ad=ab+a3+a4;local ae=ad%2^32;local af=ad-ae+ac*2^32+a5+a6;local ag=af%2^64;local ah=af-ag+z*2^64+a7+a8;local ai=ah%2^96;local aj=ah-ai+A*2^96+a9+aa;local ak=aj%2^128;return f(e,ae,ag/2^32,ai/2^64,ak/2^96)end;return{mac=g}\n\nrandom.lua/     1722465588  0     0     775     1531      `\nlocal a=require\"system.expect\".expect;local b=require\"blake3\"local c=require\"chacha20\"local d=require\"internal_util\"local e=d.lassert;local f;if KERNEL then f={\"ccryptolib 2023-04-11T19:43Z random.lua initialization context\",os.epoch(\"utc\"),os.epoch(\"ingame\"),math.random(0,2^24-1),math.random(0,2^24-1),tostring({}),tostring({})}else f={\"ccryptolib 2023-04-11T19:43Z random.lua initialization context\",os.time()*1000,os.time(\"ingame\")*1000,math.random(0,2^24-1),math.random(0,2^24-1),tostring({}),tostring({})}end;local g=b.digest(table.concat(f,\"|\"))local h=false;local function i(j)a(1,j,\"string\")g=b.digestKeyed(g,j)h=true end;local function k()return h end;local function l()local m;if KERNEL then assert(os.epoch(\"utc\")~=0)m=assert(load(\"local e=os.epoch return{\"..(\"e'utc',\"):rep(256)..\"}\"))else assert(os.time()~=0)m=assert(load(\"local e=os.time return{\"..(\"e(),\"):rep(256)..\"}\"))end;do local n=m()while n[256]-n[1]>1 do n=m()end end;local o={}for p=1,512 do local n=m()while n[256]==n[1]do n=m()end;for q=1,256 do if n[q]~=n[1]then o[p]=q-1;break end end end;local r={}for p=0,255 do r[p]=0 end;for p=1,#o do r[o[p]]=r[o[p]]+1 end;for p=0,255 do assert(r[p]<20)end;i(string.char(table.unpack(o)))end;local function s(t)a(1,t,\"string\")g=b.digestKeyed(g,t)end;local function u(v)a(1,v,\"number\")e(h,\"attempt to use an uninitialized random generator\",2)local w=(\"\\0\"):rep(math.max(v,0)+32)local x=(\"\\0\"):rep(12)local y=c.crypt(g,x,w,8,0)g=y:sub(1,32)return y:sub(33)end;return{init=i,isInit=k,initWithTiming=l,mix=s,random=u}\n\nsha256.lua/     1722465588  0     0     775     2074      `\nlocal a=require\"system.expect\".expect;local b=require\"internal_util\".lassert;local c=require\"internal_packing\"local d=bit32.lrotate;local e=bit32.rshift;local f=bit32.bxor;local g=bit32.bnot;local h=bit32.band;local unpack=unpack or table.unpack;local i,j=c.compilePack(\">I8\")local k,l=c.compilePack(\">I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\")local m=c.compileUnpack(l)local n,o=c.compilePack(\">I4I4I4I4I4I4I4I4\")local p=c.compileUnpack(o)local function q(r,s)local t={}local u=2;for v=1,r do t[v]=f(u^s%1*2^32)repeat u=u+1 until 2^u%u==2 end;return t end;local w=q(64,1/3)local x=q(8,1/2)local function y(z,A)local x,B,C,D,E,F,G,H=unpack(z)local w=w;for I=17,64 do local J=A[I-15]local K=A[I-2]local L=f(d(J,25),d(J,14),e(J,3))local M=f(d(K,15),d(K,13),e(K,10))A[I]=A[I-16]+L+A[I-7]+M end;local N,O,P,Q,R,S,T,z=x,B,C,D,E,F,G,H;for I=1,64 do local M=f(d(R,26),d(R,21),d(R,7))local U=f(h(R,S),h(g(R),T))local V=z+M+U+w[I]+A[I]local L=f(d(N,30),d(N,19),d(N,10))local W=f(h(N,O),h(N,P),h(O,P))local X=L+W;z=T;T=S;S=R;R=Q+V;Q=P;P=O;O=N;N=V+X end;return{(x+N)%2^32,(B+O)%2^32,(C+P)%2^32,(D+Q)%2^32,(E+R)%2^32,(F+S)%2^32,(G+T)%2^32,(H+z)%2^32}end;local function Y(Z)a(1,Z,\"string\")local _=#Z*8;local a0=-(#Z+9)%64;Z=Z..\"\\x80\"..(\"\\0\"):rep(a0)..i(j,_)local z=x;for v=1,#Z,64 do z=y(z,{m(l,Z,v)})end;return n(o,unpack(z))end;local a1=50;local function a2(a3,a4,a5,a6)a(1,a3,\"string\")a(2,a4,\"string\")a(3,a5,\"number\")b(a5%1==0,\"iteration number must be an integer\",2)b(a5>0,\"iteration number must be positive\",2)a(4,a6,\"function\",\"nil\")if#a3>64 then a3=Y(a3)end;a3={m(l,a3 ..(\"\\0\"):rep(64),1)}local a7={}local a8={}for v=1,16 do a7[v]=f(a3[v],0x36363636)a8[v]=f(a3[v],0x5c5c5c5c)end;local a9=y(x,a7)local aa=y(x,a8)local ab={2^31,0,0,0,0,0,0,0x300}local ac=k(l,unpack(a7))local ad={p(o,Y(ac..a4 ..\"\\0\\0\\0\\1\"),1)}for v=1,8 do ad[v+8]=ab[v]end;ad=y(aa,ad)local t={unpack(ad)}for v=2,a5 do for I=1,8 do ad[I+8]=ab[I]end;ad=y(a9,ad)for I=1,8 do ad[I+8]=ab[I]end;ad=y(aa,ad)for I=1,8 do t[I]=f(t[I],ad[I])end;if a6 and v%a1==0 then a6(v)end end;return n(o,unpack(t))end;return{digest=Y,pbkdf2=a2}\nutil.lua/       1722465588  0     0     775     508       `\nlocal a=require\"system.expect\".expect;local b=require\"random\"local c=require\"poly1305\"local function d(e)a(1,e,\"string\")return(\"%02x\"):rep(#e):format(e:byte(1,-1))end;local function f(g)a(1,g,\"string\")local h={}local i=0;for j in g:gmatch(\"%x%x\")do i=i+1;h[i]=tonumber(j,16)end;if 2*i==#g then return string.char(table.unpack(h))end end;local function k(l,m)a(1,l,\"string\")a(2,m,\"string\")if#l~=#m then return false end;local n=b.random(32)return c.mac(n,l)==c.mac(n,m)end;return{toHex=d,fromHex=f,compare=k}\nx25519.lua/     1722465588  0     0     775     498       `\nlocal a=require\"system.expect\".expect;local b=require\"internal_util\".lassert;local c=require\"internal_util\"local d=require\"internal_curve25519\"local function e(f)a(1,f,\"string\")assert(#f==32,\"secret key length must be 32\")return d.encode(d.scale(d.mulG(c.bits(f))))end;local function g(f,h)a(1,f,\"string\")b(#f==32,\"secret key length must be 32\",2)a(2,h,\"string\")b(#h==32,\"public key length must be 32\",2)return d.encode(d.scale(d.ladder8(d.decode(h),c.bits8(f))))end;return{publicKey=e,exchange=g}\nx25519c.lua/    1722465588  0     0     775     1905      `\nlocal a=require\"system.expect\".expect;local b=require\"internal_util\".lassert;local c=require\"internal_fq\"local d=require\"internal_fp\"local e=require\"internal_curve25519\"local f=require\"internal_sha512\"local g=require\"random\"local function h(i)a(1,i,\"string\")b(#i==32,\"secret key length must be 32\",2)local h=g.random(32)local j=c.decodeClamped(i)local k=c.decodeClamped(h)local l=c.sub(j,k)return c.encode(l)..h end;local function m(i)a(1,i,\"string\")b(#i==32,\"secret key length must be 32\",2)return h(f.digest(i):sub(1,32))end;local function n(o)a(1,o,\"string\")b(#o==64,\"masked secret key length must be 64\",2)local p=g.random(32)local l=c.decode(o:sub(1,32))local k=c.decodeClamped(o:sub(33))local q=c.decodeClamped(p)local r=c.add(l,c.sub(k,q))return c.encode(r)..p end;local function s(o)a(1,o,\"string\")b(#o==64,\"masked secret key length must be 64\",2)return o:sub(33)end;local function t(i,u)local l=c.decode(i:sub(1,32))local k=c.decodeClamped(i:sub(33))local v,w,x=e.prac(u,c.makeRuleset(c.eighth(k),c.eighth(l)))if not v then local y=d.encode(d.num(0))return y,y end;local z=e.dadd(x,v,w)local A,B=u[1],u[2]local C,D=z[1],z[2]local E,F=v[1],v[2]A,B=d.mul(A,B),d.square(B)C,D=d.mul(C,D),d.square(D)E,F=d.mul(E,F),d.square(F)local G=d.square(A)local H=d.square(B)local I=d.mul(A,B)local J=d.kmul(I,486662)local K=d.mul(A,d.add(G,d.carry(d.add(J,H))))local L=d.sqrtDiv(d.num(1),d.mul(d.mul(D,F),K))if not L then local y=d.encode(d.num(0))return y,y end;local M=d.mul(d.square(L),K)local N=d.mul(M,F)local O=d.mul(M,D)return d.encode(d.mul(C,N)),d.encode(d.mul(E,O))end;local function P(o)a(1,o,\"string\")b(#o==64,\"masked secret key length must be 64\",2)return t(o,e.G)end;local function Q(i,R)a(1,i,\"string\")b(#i==64,\"masked secret key length must be 64\",2)a(2,R,\"string\")b(#R==32,\"public key length must be 32\",2)return t(i,e.decode(R))end;return{mask=h,remask=n,publicKey=P,ephemeralSk=s,exchange=Q}\n\n/0              1722465587  0     0     775     2808      `\nlocal a=require\"internal_fp\"local b=require\"internal_edwards25519\"local c=require\"random\"local function d(e)local f,g=e[1],e[2]local h=a.add(f,g)local i=a.square(h)local j=a.sub(f,g)local k=a.square(j)local l=a.sub(i,k)local m=a.mul(i,k)local n=a.mul(l,a.add(k,a.kmul(l,121666)))return{m,n}end;local function o(p,e,q)local r,s=p[1],p[2]local f,g=e[1],e[2]local t,u=q[1],q[2]local h=a.add(f,g)local j=a.sub(f,g)local l=a.add(t,u)local v=a.sub(t,u)local w=a.mul(v,h)local x=a.mul(l,j)local m=a.mul(s,a.square(a.add(w,x)))local n=a.mul(r,a.square(a.sub(w,x)))return{m,n}end;local function y(p,e,q)local r,s=p[1],p[2]local f,g=e[1],e[2]local t,u=q[1],q[2]local h=a.add(f,g)local i=a.square(h)local j=a.sub(f,g)local k=a.square(j)local z=a.sub(i,k)local l=a.add(t,u)local v=a.sub(t,u)local w=a.mul(v,h)local x=a.mul(l,j)local A=a.mul(s,a.square(a.add(w,x)))local B=a.mul(r,a.square(a.sub(w,x)))local m=a.mul(i,k)local n=a.mul(z,a.add(k,a.kmul(z,121666)))return{m,n},{A,B}end;local function C(p,D)local E={a.num(1),a.num(0)}local F=p;for G=#D,1,-1 do if D[G]==0 then E,F=y(p,E,F)else F,E=y(p,F,E)end end;return E end;local function H(E,D)local I=a.decode(c.random(32))E={a.mul(E[1],I),a.mul(E[2],I)}return d(d(d(C(E,D))))end;local function J(E)return{a.mul(E[1],a.invert(E[2])),a.num(1)}end;local function K(E)return a.encode(E[1])end;local function L(M)return{a.decode(M),a.num(1)}end;local function N(M)local O=a.decode(M)local P=a.carry(a.add(a.num(1),O))local v=a.carry(a.sub(a.num(1),O))if a.eqz(v)then return{a.num(0),a.num(1)}else return{P,v}end end;local function Q(D)local E=b.mulG(D)local R,S=E[2],E[3]local T=a.carry(a.add(R,S))local U=a.carry(a.sub(S,R))return{T,U}end;local function V(E,W)local I=a.decode(c.random(32))local X={a.mul(E[1],I),a.mul(E[2],I)}local X=d(d(d(X)))if a.eqz(X[2])then return end;X=C(X,W[1])local Y=W[2]if#Y==0 then return end;local Z,_;local a0=Y[#Y]if a0==2 then local a1=d(X)X,Z,_=o(X,a1,X),X,a1 elseif a0==3 or a0==5 then X,Z,_=d(X),X,X elseif a0==6 then local a1=d(X)local a2=o(X,a1,X)X,Z,_=d(a2),X,o(X,a2,a1)elseif a0==7 then local a1=d(X)local a2=o(X,a1,X)local a3=d(a1)X,Z,_=o(a2,a3,X),X,a3 elseif a0==8 then local a1=d(X)local a2=o(X,a1,X)X,Z,_=d(a1),X,a2 else X,Z,_=X,d(X),X end;for G=#Y-1,1,-1 do local a0=Y[G]if a0==0 then X,Z=Z,X elseif a0==1 then local a4=o(_,X,Z)X,Z=o(Z,a4,X),o(X,a4,Z)elseif a0==2 then X,_=o(Z,o(_,X,Z),X),d(X)elseif a0==3 then X,_=o(_,X,Z),X elseif a0==5 then X,_=d(X),o(Z,X,_)elseif a0==6 then local a4=o(_,X,Z)local a5=d(a4)X,_=o(a4,a5,a4),o(o(X,a4,Z),a5,X)elseif a0==7 then local a4=o(_,X,Z)local a6=o(Z,a4,X)X,_=o(X,a6,a4),o(a4,a6,X)elseif a0==8 then local a7=d(X)X,_=o(_,a7,o(_,X,Z)),o(X,a7,X)else Z,_=d(Z),o(X,_,Z)end end;return X,Z,_ end;return{G={a.num(9),a.num(1)},dadd=o,scale=J,encode=K,decode=L,decodeEd=N,ladder8=H,mulG=Q,prac=V}\n/25             1722465587  0     0     775     3211      `\nlocal a=require\"internal_fp\"local unpack=unpack or table.unpack;local b=a.mul(a.num(-121665),a.invert(a.num(121666)))local c=a.kmul(b,2)local d={a.num(0),a.num(1),a.num(1),a.num(0)}local e=nil;local function f(g)local h,i,j=unpack(g)local k=a.square(h)local l=a.square(i)local m=a.square(j)local n=a.add(m,m)local o=a.add(k,l)local p=a.add(h,i)local q=a.square(p)local r=a.carry(a.sub(q,o))local s=a.sub(l,k)local t=a.carry(a.sub(n,s))local u=a.mul(r,t)local v=a.mul(s,o)local w=a.mul(t,s)local x=a.mul(r,o)return{u,v,w,x}end;local function y(g,z)local h,i,j,A=unpack(g)local B,C,D,E=unpack(z)local k=a.sub(i,h)local l=a.mul(k,C)local m=a.add(i,h)local n=a.mul(m,B)local o=a.mul(A,E)local p=a.mul(j,D)local q=a.sub(n,l)local r=a.sub(p,o)local s=a.add(p,o)local t=a.add(n,l)local u=a.mul(q,r)local v=a.mul(s,t)local w=a.mul(r,s)local x=a.mul(q,t)return{u,v,w,x}end;local function F(g,z)local h,i,j,A=unpack(g)local B,C,D,E=unpack(z)local k=a.sub(i,h)local l=a.mul(k,B)local m=a.add(i,h)local n=a.mul(m,C)local o=a.mul(A,E)local p=a.mul(j,D)local q=a.sub(n,l)local r=a.add(p,o)local s=a.sub(p,o)local t=a.add(n,l)local u=a.mul(q,r)local v=a.mul(s,t)local w=a.mul(r,s)local x=a.mul(q,t)return{u,v,w,x}end;local function G(g)local h,i,j,A=unpack(g)local H=a.add(i,h)local I=a.sub(i,h)local J=a.add(j,j)local K=a.mul(A,c)return{H,I,J,K}end;local function L(g)local h,i,j=unpack(g)local M=a.invert(j)local u=a.mul(h,M)local v=a.mul(i,M)local w=a.num(1)local x=a.mul(u,v)return{u,v,w,x}end;local function N(g)g=L(g)local h,i=unpack(g)local O=a.encode(i)local P=a.canonicalize(h)[1]%2;return O:sub(1,-2)..string.char(O:byte(-1)+P*128)end;local function Q(R)local v=a.decode(R)local k=a.square(v)local l=a.sub(k,a.num(1))local m=a.mul(k,b)local n=a.add(m,a.num(1))local u=a.sqrtDiv(l,n)if not u then return nil end;local P=a.canonicalize(u)[1]%2;if P~=bit32.extract(R:byte(-1),7)then u=a.carry(a.neg(u))end;local w=a.num(1)local x=a.mul(u,v)return{u,v,w,x}end;e=Q(\"Xfffffffffffffffffffffffffffffff\")local function S(T,U)local V=2^U;local W=V/2;local X={}local Y=0;local Z=1;for s=1,#T do Y=Y+T[s]*Z;Z=Z*2;while s==#T and Y>0 or Z>V do local _=Y%V;if _>=W then _=_-V end;Y=(Y-_)/V;Z=Z/V;X[#X+1]=_ end end;return X end;local function a0(a1,U)local X={}for s=1,math.ceil(256/U)do local a2={G(a1)}for t=2,2^U/2 do a1=y(a1,a2[1])a2[t]=G(a1)end;X[s]=a2;a1=f(a1)end;return X end;local a3=5;local a4=a0(e,a3)local function a5(T,U)local V=2^U;local W=V/2;local X={}local Y=0;local Z=1;for s=1,#T do Y=Y+T[s]*Z;Z=Z*2;while s==#T and Y>0 or Z>V do if Y%2==0 then Y=Y/2;Z=Z/2;X[#X+1]=0 else local _=Y%V;if _>=W then _=_-V end;Y=Y-_;X[#X+1]=_ end end end;while X[#X]==0 do X[#X]=nil end;return X end;local function a6(a1,U)local a7=f(a1)local X={G(a1)}for s=3,2^U,2 do X[s]=G(y(a7,X[s-2]))end;return X end;local function a8(T)local a9=S(T,a3)local aa=d;for s=1,#a9 do local l=a9[s]if l>0 then aa=y(aa,a4[s][l])elseif l<0 then aa=F(aa,a4[s][-l])end end;return aa end;local function Z(a1,T)local ab=a5(T,5)local ac=a6(a1,5)local aa=d;for s=#ab,1,-1 do local l=ab[s]if l==0 then aa=f(aa)elseif l>0 then aa=y(aa,ac[l])else aa=F(aa,ac[-l])end end;return aa end;return{double=f,add=y,sub=F,niels=G,scale=L,encode=N,decode=Q,mulG=a8,mul=Z}\n\ninternal_fp.lua/1722465587  0     0     775     6803      `\nlocal a=require\"internal_packing\"local unpack=unpack or table.unpack;local b,c=a.compileUnpack(\"<I3I3I2I3I3I2I3I3I2I3I3I2\")local d={0958640*2^0,0826664*2^22,1613251*2^43,1041528*2^64,0013673*2^85,0387171*2^107,1824679*2^128,0313839*2^149,0709440*2^170,0122635*2^192,0262782*2^213,0712905*2^234}local function e(f)return{f,0,0,0,0,0,0,0,0,0,0,0}end;local function g(h)local i,j,k,l,m,n,o,p,q,r,s,t=unpack(h)return{-i,-j,-k,-l,-m,-n,-o,-p,-q,-r,-s,-t}end;local function u(h,v)local i,j,k,l,m,n,o,p,q,r,s,t=unpack(h)local w,x,y,z,A,B,C,D,E,F,G,H=unpack(v)return{i+w,j+x,k+y,l+z,m+A,n+B,o+C,p+D,q+E,r+F,s+G,t+H}end;local function I(h,v)local i,j,k,l,m,n,o,p,q,r,s,t=unpack(h)local w,x,y,z,A,B,C,D,E,F,G,H=unpack(v)return{i-w,j-x,k-y,l-z,m-A,n-B,o-C,p-D,q-E,r-F,s-G,t-H}end;local function J(h)local i,j,k,l,m,n,o,p,q,r,s,t=unpack(h)local K,L,M,N,O,P,Q,R,S,T,U,V;V=t+3*2^306-3*2^306;i=i+19/2^255*V;K=i+3*2^73-3*2^73;j=j+K;L=j+3*2^94-3*2^94;k=k+L;M=k+3*2^115-3*2^115;l=l+M;N=l+3*2^136-3*2^136;m=m+N;O=m+3*2^158-3*2^158;n=n+O;P=n+3*2^179-3*2^179;o=o+P;Q=o+3*2^200-3*2^200;p=p+Q;R=p+3*2^221-3*2^221;q=q+R;S=q+3*2^243-3*2^243;r=r+S;T=r+3*2^264-3*2^264;s=s+T;U=s+3*2^285-3*2^285;t=t-V+U;V=t+3*2^306-3*2^306;return{i-K+19/2^255*V,j-L,k-M,l-N,m-O,n-P,o-Q,p-R,q-S,r-T,s-U,t-V}end;local function W(h)local i,j,k,l,m,n,o,p,q,r,s,t=unpack(h)local K,L,M,N,O,P,Q,R,S,T,U,V;K=i%2^22;j=i-K+j;L=j%2^43;k=j-L+k;M=k%2^64;l=k-M+l;N=l%2^85;m=l-N+m;O=m%2^107;n=m-O+n;P=n%2^128;o=n-P+o;Q=o%2^149;p=o-Q+p;R=p%2^170;q=p-R+q;S=q%2^192;r=q-S+r;T=r%2^213;s=r-T+s;U=s%2^234;t=s-U+t;V=t%2^255;K=K+19/2^255*(t-V)if V/2^234==2^21-1 and U/2^213==2^21-1 and T/2^192==2^21-1 and S/2^170==2^22-1 and R/2^149==2^21-1 and Q/2^128==2^21-1 and P/2^107==2^21-1 and O/2^85==2^22-1 and N/2^64==2^21-1 and M/2^43==2^21-1 and L/2^22==2^21-1 and K>=2^22-19 then return{19-2^22+K,0,0,0,0,0,0,0,0,0,0,0}else return{K,L,M,N,O,P,Q,R,S,T,U,V}end end;local function X(h,v)local Y=W(I(h,v))for Z=1,12 do if Y[Z]~=0 then return false end end;return true end;local function _(h,v)local i,j,k,l,m,n,o,p,q,r,s,t=unpack(h)local w,x,y,z,A,B,C,D,E,F,G,H=unpack(v)local K,L,M,N,O,P,Q,R,S,T,U,V;K=t*x+s*y+r*z+q*A+p*B+o*C+n*D+m*E+l*F+k*G+j*H;L=t*y+s*z+r*A+q*B+p*C+o*D+n*E+m*F+l*G+k*H;M=t*z+s*A+r*B+q*C+p*D+o*E+n*F+m*G+l*H;N=t*A+s*B+r*C+q*D+p*E+o*F+n*G+m*H;O=t*B+s*C+r*D+q*E+p*F+o*G+n*H;P=t*C+s*D+r*E+q*F+p*G+o*H;Q=t*D+s*E+r*F+q*G+p*H;R=t*E+s*F+r*G+q*H;S=t*F+s*G+r*H;T=t*G+s*H;U=t*H;K=K*19/2^255+i*w;L=L*19/2^255+j*w+i*x;M=M*19/2^255+k*w+j*x+i*y;N=N*19/2^255+l*w+k*x+j*y+i*z;O=O*19/2^255+m*w+l*x+k*y+j*z+i*A;P=P*19/2^255+n*w+m*x+l*y+k*z+j*A+i*B;Q=Q*19/2^255+o*w+n*x+m*y+l*z+k*A+j*B+i*C;R=R*19/2^255+p*w+o*x+n*y+m*z+l*A+k*B+j*C+i*D;S=S*19/2^255+q*w+p*x+o*y+n*z+m*A+l*B+k*C+j*D+i*E;T=T*19/2^255+r*w+q*x+p*y+o*z+n*A+m*B+l*C+k*D+j*E+i*F;U=U*19/2^255+s*w+r*x+q*y+p*z+o*A+n*B+m*C+l*D+k*E+j*F+i*G;V=t*w+s*x+r*y+q*z+p*A+o*B+n*C+m*D+l*E+k*F+j*G+i*H;s=U+3*2^285-3*2^285;V=V+s;t=V+3*2^306-3*2^306;K=K+19/2^255*t;i=K+3*2^73-3*2^73;L=L+i;j=L+3*2^94-3*2^94;M=M+j;k=M+3*2^115-3*2^115;N=N+k;l=N+3*2^136-3*2^136;O=O+l;m=O+3*2^158-3*2^158;P=P+m;n=P+3*2^179-3*2^179;Q=Q+n;o=Q+3*2^200-3*2^200;R=R+o;p=R+3*2^221-3*2^221;S=S+p;q=S+3*2^243-3*2^243;T=T+q;r=T+3*2^264-3*2^264;U=U-s+r;s=U+3*2^285-3*2^285;V=V-t+s;t=V+3*2^306-3*2^306;return{K-i+19/2^255*t,L-j,M-k,N-l,O-m,P-n,Q-o,R-p,S-q,T-r,U-s,V-t}end;local function a0(h)local i,j,k,l,m,n,o,p,q,r,s,t=unpack(h)local a1,a2,a3,a4,a5,a6,a7,a8,a9,aa,ab;local K,L,M,N,O,P,Q,R,S,T,U,V;a1=i+i;a2=j+j;a3=k+k;a4=l+l;a5=m+m;a6=n+n;a7=o+o;a8=p+p;a9=q+q;aa=r+r;ab=s+s;K=t*a2+s*a3+r*a4+q*a5+p*a6+o*o;L=t*a3+s*a4+r*a5+q*a6+p*a7;M=t*a4+s*a5+r*a6+q*a7+p*p;N=t*a5+s*a6+r*a7+q*a8;O=t*a6+s*a7+r*a8+q*q;P=t*a7+s*a8+r*a9;Q=t*a8+s*a9+r*r;R=t*a9+s*aa;S=t*aa+s*s;T=t*ab;U=t*t;K=K*19/2^255+i*i;L=L*19/2^255+j*a1;M=M*19/2^255+k*a1+j*j;N=N*19/2^255+l*a1+k*a2;O=O*19/2^255+m*a1+l*a2+k*k;P=P*19/2^255+n*a1+m*a2+l*a3;Q=Q*19/2^255+o*a1+n*a2+m*a3+l*l;R=R*19/2^255+p*a1+o*a2+n*a3+m*a4;S=S*19/2^255+q*a1+p*a2+o*a3+n*a4+m*m;T=T*19/2^255+r*a1+q*a2+p*a3+o*a4+n*a5;U=U*19/2^255+s*a1+r*a2+q*a3+p*a4+o*a5+n*n;V=t*a1+s*a2+r*a3+q*a4+p*a5+o*a6;s=U+3*2^285-3*2^285;V=V+s;t=V+3*2^306-3*2^306;K=K+19/2^255*t;i=K+3*2^73-3*2^73;L=L+i;j=L+3*2^94-3*2^94;M=M+j;k=M+3*2^115-3*2^115;N=N+k;l=N+3*2^136-3*2^136;O=O+l;m=O+3*2^158-3*2^158;P=P+m;n=P+3*2^179-3*2^179;Q=Q+n;o=Q+3*2^200-3*2^200;R=R+o;p=R+3*2^221-3*2^221;S=S+p;q=S+3*2^243-3*2^243;T=T+q;r=T+3*2^264-3*2^264;U=U-s+r;s=U+3*2^285-3*2^285;V=V-t+s;t=V+3*2^306-3*2^306;return{K-i+19/2^255*t,L-j,M-k,N-l,O-m,P-n,Q-o,R-p,S-q,T-r,U-s,V-t}end;local function ac(h,ad)local i,j,k,l,m,n,o,p,q,r,s,t=unpack(h)local K,L,M,N,O,P,Q,R,S,T,U,V;i=i*ad;j=j*ad;k=k*ad;l=l*ad;m=m*ad;n=n*ad;o=o*ad;p=p*ad;q=q*ad;r=r*ad;s=s*ad;t=t*ad;V=t+3*2^306-3*2^306;i=i+19/2^255*V;K=i+3*2^73-3*2^73;j=j+K;L=j+3*2^94-3*2^94;k=k+L;M=k+3*2^115-3*2^115;l=l+M;N=l+3*2^136-3*2^136;m=m+N;O=m+3*2^158-3*2^158;n=n+O;P=n+3*2^179-3*2^179;o=o+P;Q=o+3*2^200-3*2^200;p=p+Q;R=p+3*2^221-3*2^221;q=q+R;S=q+3*2^243-3*2^243;r=r+S;T=r+3*2^264-3*2^264;s=s+T;U=s+3*2^285-3*2^285;t=t-V+U;V=t+3*2^306-3*2^306;return{i-K+19/2^255*V,j-L,k-M,l-N,m-O,n-P,o-Q,p-R,q-S,r-T,s-U,t-V}end;local function ae(h,f)for af=1,f do h=a0(h)end;return h end;local function ag(h)local ah=a0(h)local ai=_(h,ae(ah,2))local t=_(ai,ah)local aj=_(a0(t),ai)local ak=_(ae(aj,5),aj)local al=_(ae(ak,10),ak)local am=_(ae(al,20),al)local an=_(ae(am,10),ak)local ao=_(ae(an,50),an)local ap=_(ae(ao,100),ao)local aq=_(ae(ap,50),an)return _(ae(aq,5),t)end;local function ar(as,at)as=J(as)local au=a0(at)local av=_(at,au)local aw=a0(av)local ax=_(at,aw)local ay=_(as,ax)local az=_(a0(ay),ay)local aA=_(ae(az,2),az)local aB=_(ae(aA,4),aA)local aC=_(ae(aB,8),aB)local aD=_(ae(aC,2),az)local aE=_(ae(aC,16),aC)local an=_(ae(aE,18),aD)local ao=_(ae(an,50),an)local ap=_(ae(ao,100),ao)local aq=_(ae(ap,50),an)local aF=_(ae(aq,2),ay)local aG=_(as,av)local v=_(aG,aF)local aH=a0(v)local aI=_(at,aH)if not X(aI,as)then v=_(v,d)aH=a0(v)aI=_(at,aH)end;if X(aI,as)then return v else return nil end end;local function aJ(h)h=W(h)local i,j,k,l,m,n,o,p,q,r,s,t=unpack(h)local aK={}local aL=i;local function aM(f)for af=1,f do local aN=aL%256;aK[#aK+1]=aN;aL=(aL-aN)/256 end end;aM(2)aL=aL+j/2^16;aM(3)aL=aL+k/2^40;aM(3)aL=aL+l/2^64;aM(2)aL=aL+m/2^80;aM(3)aL=aL+n/2^104;aM(3)aL=aL+o/2^128;aM(2)aL=aL+p/2^144;aM(3)aL=aL+q/2^168;aM(3)aL=aL+r/2^192;aM(2)aL=aL+s/2^208;aM(3)aL=aL+t/2^232;aM(3)return string.char(unpack(aK))end;local function aO(v)local aP,aQ,aR,aS,aT,aU,aV,aW,aX,aY,aZ,a_=b(c,v,1)a_=a_%2^15;return J{aP,aQ*2^24,aR*2^48,aS*2^64,aT*2^88,aU*2^112,aV*2^128,aW*2^152,aX*2^176,aY*2^192,aZ*2^216,a_*2^240}end;local function b0(h)local Y=W(h)local K,L,M,N,O,P,Q,R,S,T,U,V=unpack(Y)return K+L+M+N+O+P+Q+R+S+T+U+V==0 end;return{num=e,neg=g,add=u,sub=I,kmul=ac,mul=_,canonicalize=W,square=a0,carry=J,invert=ag,sqrtDiv=ar,encode=aJ,decode=aO,eqz=b0}\n\ninternal_fq.lua/1722465587  0     0     775     3077      `\nlocal a=require\"internal_mp\"local b=require\"internal_util\"local c=require\"internal_packing\"local unpack=unpack or table.unpack;local d,e=c.compilePack(\"<I3I3I3I3I3I3I3I3I3I3I2\")local f=c.compileUnpack(e)local g,h=c.compileUnpack(\"<I3I3I3I3I3I3I3I3I3I3I3\")local i,j=c.compileUnpack(\"<I3I3I3I3I3I3I3I3I3I3I1\")local k={16110573,06494812,14047250,10680220,14612958,00000020,00000000,00000000,00000000,00000000,00004096}local l={05537307,01942290,16765621,16628356,10618610,07072433,03735459,01369940,15276086,13038191,13409718}local m={11711996,01747860,08326961,03814718,01859974,13327461,16105061,07590423,04050668,08138906,00000283}local n={5110253,3039345,2503500,11779568,15416472,16766550,16777215,16777215,16777215,16777215,4095}local o=a.num(0)local function p(q)local r=a.sub(q,k)if a.approx(r)<0 then return a.carry(q)end;return a.carry(r)end;local function s(q,t)return p(a.add(q,t))end;local function u(q)return p(a.sub(k,q))end;local function v(q,t)return s(q,u(t))end;local function w(q,t)local x,y=a.mul(q,t)local z,A=a.mul(a.lmul(x,l),k)local B,C=a.dwadd(x,y,z,A)return p(C)end;local function D(q)return w(q,m)end;local function E(q)local z,A=a.mul(a.lmul(q,l),k)local B,C=a.dwadd(q,o,z,A)return p(C)end;local function F(q)return d(e,unpack(E(q)))end;local function G(H)local I={f(e,H,1)}I[12]=nil;return D(I)end;local function J(H)local K={g(h,H,1)}K[12]=nil;local L={i(j,H,34)}L[12]=nil;return s(D(K),D(D(L)))end;local function M(H)local N={f(e,H,1)}N[12]=nil;N[1]=bit32.band(N[1],0xfffff8)N[11]=bit32.band(N[11],0x7fff)N[11]=bit32.bor(N[11],0x4000)return D(N)end;local function O(q)return w(q,n)end;local function P(q)local Q=b.rebaseLE(E(q),2^24,2)for R=254,289 do Q[R]=nil end;return Q end;local function S(q,t)local T=E(q)local U=E(t)local V=a.sub(T,U)local W=a.mod2(T)local X=a.mod2(U)local Y=a.mod3(T)local Z=a.mod3(U)local _=a.approx(U)local a0=a.approx(V)local a1={[0]=0,2,1}local a2={}while a0~=0 do if a0<0 then a2[#a2+1]=0;T,U=U,T;W,X=X,W;Y,Z=Z,Y;_=a.approx(U)V=a.sub(T,U)a0=-a0 elseif 4*a0<_ and Y==a1[Z]then a2[#a2+1]=1;T,U=a.third(a.add(T,V)),a.third(a.sub(U,V))W,X=X,W;Y,Z=a.mod3(T),a.mod3(U)_=a.approx(U)elseif 4*a0<_ and W==X and Y==Z then a2[#a2+1]=2;T=a.half(V)W=a.mod2(T)Y=a1[(Y-Z)%3]V=a.sub(T,U)a0=a.approx(V)elseif a0<3*_ then a2[#a2+1]=3;T=a.carryWeak(V)W=(W-X)%2;Y=(Y-Z)%3;V=a.sub(T,U)a0=a.approx(V)elseif W==X then a2[#a2+1]=2;T=a.half(V)W=a.mod2(T)Y=a1[(Y-Z)%3]V=a.sub(T,U)a0=a.approx(V)elseif W==0 then a2[#a2+1]=5;T=a.half(T)W=a.mod2(T)Y=a1[Y]V=a.sub(T,U)a0=a.approx(V)elseif Y==0 then a2[#a2+1]=6;T=a.carryWeak(a.sub(a.third(T),U))W=(W-X)%2;Y=a.mod3(T)V=a.sub(T,U)a0=a.approx(V)elseif Y==a1[Z]then a2[#a2+1]=7;T=a.third(a.sub(V,U))Y=a.mod3(T)V=a.sub(T,U)a0=a.approx(V)elseif Y==Z then a2[#a2+1]=8;T=a.third(V)W=(W-X)%2;Y=a.mod3(T)V=a.sub(T,U)a0=a.approx(V)else a2[#a2+1]=9;U=a.half(U)X=a.mod2(U)Z=a1[Z]_=a.approx(U)V=a.sub(T,U)a0=a.approx(V)end end;local a3=b.rebaseLE(T,2^24,2)while a3[#a3]==0 do a3[#a3]=nil end;return{a3,a2}end;return{add=s,sub=v,mul=w,encode=F,decode=G,decodeWide=J,decodeClamped=M,eighth=O,bits=P,makeRuleset=S}\n\ninternal_mp.lua/1722465588  0     0     775     3120      `\nlocal unpack=unpack or table.unpack;local function a(b)local c,d,e,f,g,h,i,j,k,l,m=unpack(b)local n=c+3*2^75-3*2^75;d=d+n*2^-24;local o=d+3*2^75-3*2^75;e=e+o*2^-24;local p=e+3*2^75-3*2^75;f=f+p*2^-24;local q=f+3*2^75-3*2^75;g=g+q*2^-24;local r=g+3*2^75-3*2^75;h=h+r*2^-24;local s=h+3*2^75-3*2^75;i=i+s*2^-24;local t=i+3*2^75-3*2^75;j=j+t*2^-24;local u=j+3*2^75-3*2^75;k=k+u*2^-24;local v=k+3*2^75-3*2^75;l=l+v*2^-24;local w=l+3*2^75-3*2^75;m=m+w*2^-24;local x=m+3*2^75-3*2^75;return{c-n,d-o,e-p,f-q,g-r,h-s,i-t,j-u,k-v,l-w,m-x},x*2^-24 end;local function y(b)local c,d,e,f,g,h,i,j,k,l,m=unpack(b)local z=c%2^24;d=d+(c-z)*2^-24;local A=d%2^24;e=e+(d-A)*2^-24;local B=e%2^24;f=f+(e-B)*2^-24;local C=f%2^24;g=g+(f-C)*2^-24;local D=g%2^24;h=h+(g-D)*2^-24;local E=h%2^24;i=i+(h-E)*2^-24;local F=i%2^24;j=j+(i-F)*2^-24;local G=j%2^24;k=k+(j-G)*2^-24;local H=k%2^24;l=l+(k-H)*2^-24;local I=l%2^24;m=m+(l-I)*2^-24;local J=m%2^24;local x=(m-J)*2^-24;return{z,A,B,C,D,E,F,G,H,I,J},x end;local function K(b,L)local c,d,e,f,g,h,i,j,k,l,m=unpack(b)local M,N,O,P,Q,R,S,T,U,V,W=unpack(L)return{c+M,d+N,e+O,f+P,g+Q,h+R,i+S,j+T,k+U,l+V,m+W}end;local function X(b,L)local c,d,e,f,g,h,i,j,k,l,m=unpack(b)local M,N,O,P,Q,R,S,T,U,V,W=unpack(L)return{c-M,d-N,e-O,f-P,g-Q,h-R,i-S,j-T,k-U,l-V,m-W}end;local function Y(b,L)local c,d,e,f,g,h,i,j,k,l,m=unpack(b)local M,N,O,P,Q,R,S,T,U,V,W=unpack(L)return y{c*M,d*M+c*N,e*M+d*N+c*O,f*M+e*N+d*O+c*P,g*M+f*N+e*O+d*P+c*Q,h*M+g*N+f*O+e*P+d*Q+c*R,i*M+h*N+g*O+f*P+e*Q+d*R+c*S,j*M+i*N+h*O+g*P+f*Q+e*R+d*S+c*T,k*M+j*N+i*O+h*P+g*Q+f*R+e*S+d*T+c*U,l*M+k*N+j*O+i*P+h*Q+g*R+f*S+e*T+d*U+c*V,m*M+l*N+k*O+j*P+i*Q+h*R+g*S+f*T+e*U+d*V+c*W}end;local function Z(b,L)local _,a0=Y(b,L)local a1,d,e,f,g,h,i,j,k,l,m=unpack(b)local a1,N,O,P,Q,R,S,T,U,V,W=unpack(L)return _,y{a0+m*N+l*O+k*P+j*Q+i*R+h*S+g*T+f*U+e*V+d*W,m*O+l*P+k*Q+j*R+i*S+h*T+g*U+f*V+e*W,m*P+l*Q+k*R+j*S+i*T+h*U+g*V+f*W,m*Q+l*R+k*S+j*T+i*U+h*V+g*W,m*R+l*S+k*T+j*U+i*V+h*W,m*S+l*T+k*U+j*V+i*W,m*T+l*U+k*V+j*W,m*U+l*V+k*W,m*V+l*W,m*W,0}end;local function a2(a3,a4,a5,a6)local _,a7=y(K(a3,a5))local a8=K(a4,a6)a8[1]=a8[1]+a7;return _,y(a8)end;local function a9(b)local c,d,e,f,g,h,i,j,k,l,m=unpack(b)return a{c*0.5+d*2^23,e*2^23,f*2^23,g*2^23,h*2^23,i*2^23,j*2^23,k*2^23,l*2^23,m*2^23,0}end;local function aa(b)local c,d,e,f,g,h,i,j,k,l,m=unpack(b)local ab=c*0xaaaaaa;local ac=d*0xaaaaaa+ab;local ad=e*0xaaaaaa+ac;local ae=f*0xaaaaaa+ad;local af=g*0xaaaaaa+ae;local ag=h*0xaaaaaa+af;local ah=i*0xaaaaaa+ag;local ai=j*0xaaaaaa+ah;local aj=k*0xaaaaaa+ai;local ak=l*0xaaaaaa+aj;local al=m*0xaaaaaa+ak;return a{c+ab,d+ac,e+ad,f+ae,g+af,h+ag,i+ah,j+ai,k+aj,l+ak,m+al}end;local function am(b)return b[1]%2 end;local function an(b)local c,d,e,f,g,h,i,j,k,l,m=unpack(b)return(c+d+e+f+g+h+i+j+k+l+m)%3 end;local function ao(b)local c,d,e,f,g,h,i,j,k,l,m=unpack(b)return c+d*2^24+e*2^48+f*2^72+g*2^96+h*2^120+i*2^144+j*2^168+k*2^192+l*2^216+m*2^240 end;local function ap(b,L)return ao(X(b,L))end;local function aq(b)return{b,0,0,0,0,0,0,0,0,0,0}end;return{carry=y,carryWeak=a,add=K,sub=X,dwadd=a2,lmul=Y,mul=Z,half=a9,third=aa,mod2=am,mod3=an,approx=ao,cmp=ap,num=aq}\n/52             1722465588  0     0     775     1676      `\nlocal a=string.format;local function b(c,d)local e=\"local C=string.char return function(_,\"local f=0;for g=1,#c do e=e..a(\"n%d,\",g)f=f+c[g]end;e=e:sub(1,-2)..\")local \"for g=1,f do e=e..a(\"b%d,\",g)end;e=e:sub(1,-2)..\" \"local h=1;for g=1,#c do for i=1,c[g]-1 do e=e..a(\"b%d=n%d%%2^8 n%d=(n%d-b%d)*2^-8 \",h,g,g,g,h)h=h+1 end;h=h+1 end;e=e..\"return C(\"h=1;if not d then for g=1,#c do for i=1,c[g]-1 do e=e..a(\"b%d,\",h)h=h+1 end;e=e..a(\"n%d%%2^8,\",g)h=h+1 end else for g=1,#c do e=e..a(\"n%d%%2^8,\",g)h=h+c[g]-2;for i=1,c[g]-1 do e=e..a(\"b%d,\",h)h=h-1 end;h=h+c[g]+1 end end;e=e:sub(1,-2)..\")end\"return load(e)()end;local function j(c,d)local e=\"local B=string.byte return function(_,s,i)local \"local h=1;if not d then for g=1,#c do for i=1,c[g]do e=e..a(\"b%d,\",h)h=h+1 end end else for g=1,#c do h=h+c[g]-1;for i=1,c[g]do e=e..a(\"b%d,\",h)h=h-1 end;h=h+c[g]+1 end end;e=e:sub(1,-2)..a(\"=B(s,i,i+%d)return \",h-2)h=1;for g=1,#c do e=e..a(\"b%d\",h)h=h+1;for k=2,c[g]do e=e..a(\"+b%d*2^%d\",h,8*k-8)h=h+1 end;e=e..\",\"end;e=e..a(\"i+%d end\",h-1)return load(e)()end;if not string.pack or pcall(string.dump,string.pack)then local function l(a,m)local n=assert(a:match(\"^([><])I[I%d]+$\"),\"invalid format string\")local o={}for g in a:gmatch(\"I([%d]+)\")do local p=tonumber(g)or 4;assert(p>0 and p<=16,\"integral size out of limits\")o[#o+1]=p end;return m(o,n==\">\")end;local q={}local r={}local function s(a)if not q[a]then q[a]=l(a,b)end;return q[a],a end;local function t(a)if not r[a]then r[a]=l(a,j)end;return r[a],a end;return{compilePack=s,compileUnpack=t}else local function s(a)return string.pack,a end;local function t(a)return string.unpack,a end;return{compilePack=s,compileUnpack=t}end\n/74             1722465588  0     0     775     4043      `\nlocal a=require\"system.expect\".expect;local b=require\"internal_packing\"local c=bit32.lshift;local d=bit32.rshift;local e=bit32.bxor;local f=bit32.bnot;local g=bit32.band;local h,i=b.compilePack(\">I16\")local j,k=b.compilePack(\">I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\")local l,m=b.compileUnpack(\">I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\")local function n(o,p)local q=p%2^32;o=o+(p-q)/2^32;return o%2^32,q end;local r={0x428a2f98,0xd728ae22,0x71374491,0x23ef65cd,0xb5c0fbcf,0xec4d3b2f,0xe9b5dba5,0x8189dbbc,0x3956c25b,0xf348b538,0x59f111f1,0xb605d019,0x923f82a4,0xaf194f9b,0xab1c5ed5,0xda6d8118,0xd807aa98,0xa3030242,0x12835b01,0x45706fbe,0x243185be,0x4ee4b28c,0x550c7dc3,0xd5ffb4e2,0x72be5d74,0xf27b896f,0x80deb1fe,0x3b1696b1,0x9bdc06a7,0x25c71235,0xc19bf174,0xcf692694,0xe49b69c1,0x9ef14ad2,0xefbe4786,0x384f25e3,0x0fc19dc6,0x8b8cd5b5,0x240ca1cc,0x77ac9c65,0x2de92c6f,0x592b0275,0x4a7484aa,0x6ea6e483,0x5cb0a9dc,0xbd41fbd4,0x76f988da,0x831153b5,0x983e5152,0xee66dfab,0xa831c66d,0x2db43210,0xb00327c8,0x98fb213f,0xbf597fc7,0xbeef0ee4,0xc6e00bf3,0x3da88fc2,0xd5a79147,0x930aa725,0x06ca6351,0xe003826f,0x14292967,0x0a0e6e70,0x27b70a85,0x46d22ffc,0x2e1b2138,0x5c26c926,0x4d2c6dfc,0x5ac42aed,0x53380d13,0x9d95b3df,0x650a7354,0x8baf63de,0x766a0abb,0x3c77b2a8,0x81c2c92e,0x47edaee6,0x92722c85,0x1482353b,0xa2bfe8a1,0x4cf10364,0xa81a664b,0xbc423001,0xc24b8b70,0xd0f89791,0xc76c51a3,0x0654be30,0xd192e819,0xd6ef5218,0xd6990624,0x5565a910,0xf40e3585,0x5771202a,0x106aa070,0x32bbd1b8,0x19a4c116,0xb8d2d0c8,0x1e376c08,0x5141ab53,0x2748774c,0xdf8eeb99,0x34b0bcb5,0xe19b48a8,0x391c0cb3,0xc5c95a63,0x4ed8aa4a,0xe3418acb,0x5b9cca4f,0x7763e373,0x682e6ff3,0xd6b2b8a3,0x748f82ee,0x5defb2fc,0x78a5636f,0x43172f60,0x84c87814,0xa1f0ab72,0x8cc70208,0x1a6439ec,0x90befffa,0x23631e28,0xa4506ceb,0xde82bde9,0xbef9a3f7,0xb2c67915,0xc67178f2,0xe372532b,0xca273ece,0xea26619c,0xd186b8c7,0x21c0c207,0xeada7dd6,0xcde0eb1e,0xf57d4f7f,0xee6ed178,0x06f067aa,0x72176fba,0x0a637dc5,0xa2c898a6,0x113f9804,0xbef90dae,0x1b710b35,0x131c471b,0x28db77f5,0x23047d84,0x32caab7b,0x40c72493,0x3c9ebe0a,0x15c9bebc,0x431d67c4,0x9c100d4c,0x4cc5d4be,0xcb3e42b6,0x597f299c,0xfc657e2a,0x5fcb6fab,0x3ad6faec,0x6c44198c,0x4a475817}local function s(t)a(1,t,\"string\")local u=#t*8;local v=-(#t+17)%128;t=t..\"\\x80\"..(\"\\0\"):rep(v)..h(i,u)local w,x=0x6a09e667,0xf3bcc908;local y,z=0xbb67ae85,0x84caa73b;local A,B=0x3c6ef372,0xfe94f82b;local C,D=0xa54ff53a,0x5f1d36f1;local E,F=0x510e527f,0xade682d1;local G,H=0x9b05688c,0x2b3e6c1f;local I,J=0x1f83d9ab,0xfb41bd6b;local K,L=0x5be0cd19,0x137e2179;for M=1,#t,128 do local N={l(m,t,M)}for O=33,160,2 do local P,Q=N[O-30],N[O-29]local R=d(P,1)+c(Q,31)local S=d(Q,1)+c(P,31)local T=d(P,8)+c(Q,24)local U=d(Q,8)+c(P,24)local V=d(P,7)local W=d(Q,7)+c(P,25)local X,Y=N[O-4],N[O-3]local Z=d(X,19)+c(Y,13)local _=d(Y,19)+c(X,13)local a0=d(X,29)+c(Y,3)local a1=d(Y,29)+c(X,3)local a2=d(X,6)local a3=d(Y,6)+c(X,26)local a4,q=N[O-32]+e(R,T,V)+N[O-14]+e(Z,a1,a2),N[O-31]+e(S,U,W)+N[O-13]+e(_,a0,a3)N[O],N[O+1]=n(a4,q)end;local o,p=w,x;local a5,a6=y,z;local a7,a8=A,B;local a9,aa=C,D;local ab,ac=E,F;local ad,ae=G,H;local af,ag=I,J;local ah,ai=K,L;for O=1,160,2 do local R=d(ab,14)+c(ac,18)local S=d(ac,14)+c(ab,18)local T=d(ab,18)+c(ac,14)local U=d(ac,18)+c(ab,14)local W=d(ab,9)+c(ac,23)local V=d(ac,9)+c(ab,23)local aj=e(R,T,V)local ak=e(S,U,W)local al=e(g(ab,ad),g(f(ab),af))local am=e(g(ac,ae),g(f(ac),ag))local an=ah+aj+al+r[O]+N[O]local ao=ai+ak+am+r[O+1]+N[O+1]local Z=d(o,28)+c(p,4)local _=d(p,28)+c(o,4)local a0=d(o,2)+c(p,30)local a1=d(p,2)+c(o,30)local a3=d(o,7)+c(p,25)local a2=d(p,7)+c(o,25)local ap=e(Z,a1,a2)local aq=e(_,a0,a3)local ar=e(g(o,a5),g(o,a7),g(a5,a7))local as=e(g(p,a6),g(p,a8),g(a6,a8))local at=ap+ar;local au=aq+as;ah=af;ai=ag;af=ad;ag=ae;ad=ab;ae=ac;ab,ac=n(a9+an,aa+ao)a9=a7;aa=a8;a7=a5;a8=a6;a5=o;a6=p;o,p=n(an+at,ao+au)end;w,x=n(w+o,x+p)y,z=n(y+a5,z+a6)A,B=n(A+a7,B+a8)C,D=n(C+a9,D+aa)E,F=n(E+ab,F+ac)G,H=n(G+ad,H+ae)I,J=n(I+af,J+ag)K,L=n(K+ah,L+ai)end;return j(k,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L)end;return{digest=s}\n\n/95             1722465588  0     0     775     538       `\nlocal function a(b,c,d)if not b then error(c,d+1)end;return b end;local function e(f,g,h)local i={}local j=1;local k=0;local l=1;for m=1,#f do k=k+f[m]*l;l=l*g;while l>=h do local n=k%h;k=(k-n)/h;l=l/h;i[j]=n;j=j+1 end end;if l>0 then i[j]=k end;return i end;local function o(p)local q={p:byte(1,32)}local i={}for m=1,32 do local r=q[m]for s=-7,0 do local t=r%2;i[8*m+s]=t;r=(r-t)/2 end end;i[1]=0;i[2]=0;i[3]=0;i[255]=1;i[256]=0;return i end;local function u(p)return{table.unpack(o(p),4)}end;return{lassert=a,rebaseLE=e,bits=o,bits8=u}\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291599,size=43338},apt={type="directory",created=1740881291221,worldPermissions={write=false,read=true,execute=true},contents={solvers={type="directory",created=1740881291221,worldPermissions={write=false,read=true,execute=true},contents={["80-default.lua"]={type="file",created=1740881291221,worldPermissions={execute=false,read=true,write=false},data="local a=require\"dpkg\"local function b(c)local d=1;while d<=#c do local e,f=1,false;while e<=#c[d]do if c[d][e]==true then table.remove(c,d)f=true;break elseif c[d][e]==false then table.remove(c[d],e)else e=e+1 end end;if not f then d=d+1 end end;return c end;local function g(c,h,i)for d,j in ipairs(c)do for e,k in ipairs(j)do if k==h then j[e]=i elseif k==\"!\"..h then j[e]=not i end end end;return b(c)end;local function l(c)local m={}for d,j in ipairs(c)do local n={}for e,k in ipairs(j)do n[e]=k end;m[d]=n end;return m end;local function o(c,p)local m,q={},{}repeat local r=false;for d,j in ipairs(c)do if#j==1 then local s,t=j[1]:match\"^(!?)(.*)$\"if t:sub(1,1)==\"*\"then local u,v,w=t:match\"%*(%S+) %(([<=>]+) ([^)]+)%)\"if q[u]then if v==\"<<\"then if q[u].lower and a.compareVersions(w,q[u].lower)<=0 then return nil end;if not q[u].upper or a.compareVersions(w,q[u].upper)<=0 then q[u].upper,q[u].upperTight=w,true end elseif v==\"<=\"then if q[u].lower and a.compareVersions(w,q[u].lower)<0 then return nil end;if not q[u].upper or a.compareVersions(w,q[u].upper)<0 then q[u].upper,q[u].upperTight=w,false end elseif v==\"=\"then if q[u].lower and a.compareVersions(w,q[u].lower)~=0 then return nil end;if q[u].upper and a.compareVersions(w,q[u].upper)~=0 then return nil end;q[u]={lower=w,lowerTight=false,upper=w,upperTight=false}elseif v==\">=\"then if q[u].upper and a.compareVersions(w,q[u].upper)>0 then return nil end;if not q[u].lower or a.compareVersions(w,q[u].lower)>0 then q[u].lower,q[u].lowerTight=w,false end elseif v==\">>\"then if q[u].upper and a.compareVersions(w,q[u].upper)>=0 then return nil end;if not q[u].lower or a.compareVersions(w,q[u].lower)>=0 then q[u].lower,q[u].lowerTight=w,true end else error(\"Invalid version relation \"..v)end else if v==\"<<\"then q[u]={upper=w,upperTight=true}elseif v==\"<=\"then q[u]={upper=w,upperTight=false}elseif v==\"=\"then q[u]={lower=w,lowerTight=false,upper=w,upperTight=false}elseif v==\">=\"then q[u]={lower=w,lowerTight=false}elseif v==\">>\"then q[u]={lower=w,lowerTight=true}else error(\"Invalid version relation \"..v)end end;table.remove(c,d)else m[t]=s==\"\"table.remove(c,d)g(c,t,s==\"\")end;r=true;break end end until not r;repeat local r=false;local x={}for y,j in ipairs(c)do for y,k in ipairs(j)do local z,A=k:match\"^(!?)%*?(%S*)\"x[A]=x[A]or{}if z==\"!\"then x[A][2]=true else x[A][1]=true end end end;for B,j in pairs(x)do if j[1]and not j[2]then g(c,B,true)r=true elseif not j[1]and j[2]then g(c,B,false)r=true end end until not r;if#c==0 then return m,q end;for y,j in ipairs(c)do if#j==0 then return nil end end;local C=c[1][1]:gsub(\"^!\",\"\")local D=p[C]~=nil;local E,F=o(g(l(c),C,D),p)if not E then D=not D;E,F=o(g(l(c),C,D),p)if not E then return nil end end;for B,j in pairs(E)do m[B]=j end;m[C]=D;for B,j in pairs(F)do if q[B]then if q[B].upper and j.upper then local G=a.compareVersions(j.upper,q[B].upper)if G<0 then q[B].upper,q[B].upperTight=j.upper,j.upperTight elseif G==0 then q[B].upperTight=q[B].upperTight or j.upperTight end else q[B].upper,q[B].upperTight=q[B].upper or j.upper,q[B].upperTight or j.upperTight end;if q[B].lower and j.lower then local G=a.compareVersions(j.lower,q[B].lower)if G>0 then q[B].lower,q[B].lowerTight=j.lower,j.lowerTight elseif G==0 then q[B].lowerTight=q[B].lowerTight or j.lowerTight end else q[B].lower,q[B].lowerTight=q[B].lower or j.lower,q[B].lowerTight or j.lowerTight end else q[B]=j end;if q[B].lower and q[B].upper and a.compareVersions(q[B].lower,q[B].upper)>((q[B].lowerTight or q[B].upperTight)and-1 or 0)then return nil end end;return m,q end;local function H(I,c,J)if c[J]then return end;c[J]=true;for y,j in ipairs(J.preDepends)do if j.alternate then c[#c][#c[#c]+1]=j.package else c[#c+1]={\"!\"..J.name,j.package}end;if j.version then c[#c+1]={\"!\"..j.package,\"*\"..j.package..\" (\"..j.relation..\" \"..j.version..\")\"}end;H(I,c,assert(I:get(j.package),\"Could not find package '\"..j.package..\"' in cache\"))end;for y,j in ipairs(J.depends)do if j.alternate then c[#c][#c[#c]+1]=j.package else c[#c+1]={\"!\"..J.name,j.package}end;if j.version then c[#c+1]={\"!\"..j.package,\"*\"..j.package..\" (\"..j.relation..\" \"..j.version..\")\"}end;H(I,c,assert(I:get(j.package),\"Could not find package '\"..j.package..\"' in cache\"))end;for y,j in ipairs(J.conflicts)do if j.alternate then c[#c][#c[#c]+1]=\"!\"..j.package else c[#c+1]={\"!\"..J.name,\"!\"..j.package}end;if j.version then c[#c+1]={\"!\"..j.package,\"!*\"..j.package..\" (\"..j.relation..\" \"..j.version..\")\"}end;H(I,c,assert(I:get(j.package),\"Could not find package '\"..j.package..\"' in cache\"))end;for y,j in ipairs(J.breaks)do if j.alternate then c[#c][#c[#c]+1]=\"!\"..j.package else c[#c+1]={\"!\"..J.name,\"!\"..j.package}end;if j.version then c[#c+1]={\"!\"..j.package,\"!*\"..j.package..\" (\"..j.relation..\" \"..j.version..\")\"}end;H(I,c,assert(I:get(j.package),\"Could not find package '\"..j.package..\"' in cache\"))end;for y,j in ipairs(J.preDepended)do H(I,c,assert(I:get(j.package),\"Could not find package '\"..j.package..\"' in cache\"))end;for y,j in ipairs(J.depended)do H(I,c,assert(I:get(j.package),\"Could not find package '\"..j.package..\"' in cache\"))end;for y,j in ipairs(J.conflicted)do H(I,c,assert(I:get(j.package),\"Could not find package '\"..j.package..\"' in cache\"))end;for y,j in ipairs(J.broken)do H(I,c,assert(I:get(j.package),\"Could not find package '\"..j.package..\"' in cache\"))end end;return function(p,I,K,L)local c={}for B,j in pairs(K)do c[#c+1]={(j and\"\"or\"!\")..B}H(I,c,assert(I:get(B),\"Could not find package '\"..B..\"' in cache\"))end;local M,q=o(c,p)if not M then return nil end;for B,j in pairs(q)do local J=assert(I:get(B),\"Could not find package '\"..B..\"' in cache\")if j.lower and a.compareVersions(j.lower,J.version)>(j.lowerTight and-1 or 0)or j.upper and a.compareVersions(j.upper,J.version)<(j.upperTight and 1 or 0)then return nil end end;local m={}for B,j in pairs(M)do if p[B]~=nil~=j or K[B]and j and(L.reinstall or a.compareVersions(I:get(B).version,p[B].Version)~=0)or q[B]and(q[B].lower and a.compareVersions(q[B].lower,p[B].Version)>(q[B].lowerTight and-1 or 0)or q[B].upper and a.compareVersions(q[B].upper,p[B].Version)<(q[B].upperTight and 1 or 0))then m[B]=j end end;return m,q end\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291208,size=6166}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881291221,size=0},["repo.lua"]={type="file",created=1740881291221,worldPermissions={execute=false,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"dpkg.control\"local c=require\"pgp\"local d=require\"apt.config\"local e={}function e.parseSources(f)local g={}for h in f:gmatch\"[^\\r\\n]+\"do h=h:gsub(\"#.*$\",\"\")if h:match\"^deb \"then local type,i,j,k,l=h:match\"^(deb)%s+(%b[])%s+(%S+)%s+(%S+)%s*(.*)$\"if not type then type,j,k,l=h:match\"^(deb)%s+(%S+)%s+(%S+)%s*(.*)$\"end;if not type then error(\"Malformed line in sources.list:\\n\"..h,2)end;local m={}if i then for n in i:gsub(\"^%[\",\"\"):gsub(\"%]$\",\"\"):gmatch\"%S+\"do local o,v=n:match(\"^([^=]+)=(.+)$\")if not o then error(\"Malformed option in sources.list: \"..n,2)end;m[o]=v end end;for p in l:gmatch\"%S+\"do local q={type=type,url=j,suite=k,component=p,options={}}g[#g+1]=q;if m.arch then q.options.arch={}for r in m.arch:gmatch\"[^,]+\"do q.options.arch[#q.options.arch+1]=r end end;if m.lang then q.options.lang={}for r in m.lang:gmatch\"[^,]+\"do q.options.lang[#q.options.lang+1]=r end end;if m.targets then q.options.targets={}for r in m.targets:gmatch\"[^,]+\"do q.options.targets[#q.options.targets+1]=r end end;if m.pdiffs then q.options.pdiffs=m.pdiffs==\"yes\"end;if m[\"by-hash\"]then if m[\"by-hash\"]==\"force\"then q.options.byHash=\"force\"else q.options.byHash=m[\"by-hash\"]==\"yes\"end end;if m[\"allow-insecure\"]then q.options.allowInsecure=m[\"allow-insecure\"]==\"yes\"end;if m[\"allow-weak\"]then q.options.allowWeak=m[\"allow-weak\"]==\"yes\"end;if m[\"allow-downgrade-to-insecure\"]then q.options.allowDowngradeToInsecure=m[\"allow-downgrade-to-insecure\"]==\"yes\"end;if m.trusted then q.options.trusted=m.trusted==\"yes\"end;if m[\"signed-by\"]then if m[\"signed-by\"]:match(\"%-%-%-%-%-BEGIN PGP PUBLIC KEY BLOCK%-%-%-%-%-\")then q.options.signedBy=c.readKeys(c.decodeASC(m[\"signed-by\"]))else q.options.signedBy={}for r in m[\"signed-by\"]:gmatch\"[^,]+\"do q.options.signedBy[#q.options.signedBy+1]=r end end end;if m[\"check-valid-until\"]then q.options.checkValidUntil=m[\"check-valid-until\"]==\"yes\"end;if m[\"valid-until-min\"]then q.options.validUntilMin=tonumber(m[\"valid-until-min\"])end;if m[\"valid-until-max\"]then q.options.validUntilMax=tonumber(m[\"valid-until-max\"])end;if m[\"check-date\"]then q.options.checkDate=m[\"check-date\"]==\"yes\"end;if m[\"date-max-future\"]then q.options.dateMaxFuture=tonumber(m[\"date-max-future\"])end;q.options.inreleasePath=m[\"inrelease-path\"]q.options.snapshot=m.snapshot end end end;return g end;function e.parseDeb822(f)local s=b.parseControlList(f)local g={}for t,m in ipairs(s)do for type in m.Types:match\"%S+\"do for p in v.Components:match\"%S+\"do local q={type=type,url=m.URIs,suite=m.Suites,component=p,options={}}g[#g+1]=q;if m.Architectures then q.options.arch={}for r in m.Architectures:gmatch\"%S+\"do q.options.arch[#q.options.arch+1]=r end end;if m.Languages then q.options.lang={}for r in m.Languages:gmatch\"%S+\"do q.options.lang[#q.options.lang+1]=r end end;if m.Targets then q.options.targets={}for r in m.Targets:gmatch\"%S+\"do q.options.targets[#q.options.targets+1]=r end end;if m.PDiffs then q.options.pdiffs=m.PDiffs==\"yes\"end;if m[\"By-Hash\"]then if m[\"By-Hash\"]==\"force\"then q.options.byHash=\"force\"else q.options.byHash=m[\"By-Hash\"]==\"yes\"end end;if m[\"Allow-Insecure\"]then q.options.allowInsecure=m[\"Allow-Insecure\"]==\"yes\"end;if m[\"Allow-Weak\"]then q.options.allowWeak=m[\"Allow-Weak\"]==\"yes\"end;if m[\"Allow-Downgrade-To-Insecure\"]then q.options.allowDowngradeToInsecure=m[\"Allow-Downgrade-To-Insecure\"]==\"yes\"end;if m.Trusted then q.options.trusted=m.Trusted==\"yes\"end;if m[\"Signed-By\"]then if m[\"Signed-By\"]:match(\"%-%-%-%-%-BEGIN PGP PUBLIC KEY BLOCK%-%-%-%-%-\")then q.options.signedBy=c.readKeys(c.decodeASC(m[\"Signed-By\"]))else q.options.signedBy={}for r in m[\"Signed-By\"]:gmatch\"%S+\"do q.options.signedBy[#q.options.signedBy+1]=r end end end;if m[\"Check-Valid-Until\"]then q.options.checkValidUntil=m[\"Check-Valid-Until\"]==\"yes\"end;if m[\"Valid-Until-Min\"]then q.options.validUntilMin=tonumber(m[\"Valid-Until-Min\"])end;if m[\"Valid-Until-Max\"]then q.options.validUntilMax=tonumber(m[\"Valid-Until-Max\"])end;if m[\"Check-Date\"]then q.options.checkDate=m[\"Check-Date\"]==\"yes\"end;if m[\"Date-Max-Future\"]then q.options.dateMaxFuture=tonumber(m[\"Date-Max-Future\"])end;q.options.inreleasePath=m[\"InRelease-Path\"]q.options.snapshot=m.Snapshot end end end;return g end;function e.readSources()local g={}local u=d:getPath(\"Etc\",\"sourcelist\")local w=io.open(u,\"r\")if w then local x=w:read(\"*a\")w:close()local s=e.parseSources(x)for t,v in ipairs(s)do g[#g+1]=v end end;local y=d:getPath(\"Etc\",\"sourceparts\")if a.isDir(y)then for t,z in ipairs(a.list(y))do w=io.open(a.combine(y,z),\"r\")if w then local x=w:read(\"*a\")w:close()local s=z:match\"%.sources$\"and e.parseDeb822(x)or e.parseSources(x)for t,v in ipairs(s)do g[#g+1]=v end end end end;return g end;function e.readTrustedKeys()local g={}local u=d:getPath(\"Etc\",\"trusted\")if a.exists(u)then local w=assert(io.open(u,\"rb\"))local x=w:read(\"*a\")w:close()g=c.readKeys(x)end;local y=d:getPath(\"Etc\",\"trustedparts\")if a.isDir(y)then for t,A in ipairs(a.list(y))do local w=assert(io.open(a.combine(y,A),\"rb\"))local x=w:read(\"*a\")w:close()local B=c.readKeys(x)for t,v in ipairs(B)do g[#g+1]=v end end end;return g end;function e.readRelease(q)local C=a.combine(q.url:gsub(\"^.-://\",\"\"),\"dists\",q.suite):gsub(\"[/:]\",\"_\")local u=a.combine(d:getPath(\"State\",\"lists\"),C)local B;if q.options.signedBy then if type(q.options.signedBy[1])==\"table\"then B=q.options.signedBy else B=e.readTrustedKeys()local D=1;while D<#B do local E=false;for t,v in ipairs(q.options.signedBy)do if B[D].fingerprint:lower()==v:lower()or B[D].keyID:lower()==v:lower()then E=true;break end end;if E then D=D+1 else table.remove(B,D)end end end else B=e.readTrustedKeys()end;local F;if q.options.inreleasePath then local w,G=io.open(u..\"_\"..a.combine(q.options.inreleasePath):gsub(\"[/:]\",\"_\"),\"r\")if not w then return nil,G end;local x=w:read(\"*a\")w:close()local H;H,F=c.verifyMessage(x,B)if not H then return nil,\"No valid keys found for InRelease\"end elseif a.exists(u..\"_InRelease\")then local w,G=io.open(u..\"_InRelease\",\"r\")if not w then return nil,G end;local x=w:read(\"*a\")w:close()local H;H,F=c.verifyMessage(x,B)if not H then return nil,\"No valid keys found for InRelease\"end elseif a.exists(u..\"_Release\")then local w,G=io.open(u..\"_Release\",\"r\")if not w then return nil,G end;F=w:read(\"*a\")w:close()w,G=io.open(u..\"_Release.gpg\",\"rb\")if w then local I=w:read(\"*a\")w:close()if I:match(\"^%-%-%-%-%-\")then I=c.decodeASC(I)end;if not c.verify(F,I,B)then return nil,\"No valid keys found for Release\"end elseif not q.options.allowInsecure then return nil,\"Could not find signed Release file\"end else return nil,\"No cached release file available\"end;local J=b.parseControl(F)local g={architectures={},origin=J.Origin,label=J.Label,suite=J.Suite,codename=J.Codename,version=J.Version,date=J.Date,validUntil=J[\"Valid-Until\"],components={},notAutomatic=J.NotAutomatic==\"yes\",butAutomaticUpgrades=J.ButAutomaticUpgrades==\"yes\",acquireByHash=(J[\"Acquire-By-Hash\"]==\"yes\"or q.options.byHash==\"force\")and q.options.byHash~=false,signedBy=J[\"Signed-By\"],packagesRequireAuthorization=J[\"Packages-Require-Authorization\"]==\"yes\",changelogs=J.Changelogs,snapshots=J.Snapshots}for r in J.Architectures:gmatch\"%S+\"do g.architectures[#g.architectures+1]=r end;for r in J.Components:gmatch\"%S+\"do g.components[#g.components+1]=r end;if J.MD5Sum then g.md5={}for h in J.MD5Sum:gmatch\"[^\\n]+\"do local K,L,M=h:match\"(%x+)%s+(%d+)%s+(.+)\"if K then g.md5[M]=K end end end;if J.SHA1 then g.sha1={}for h in J.SHA1:gmatch\"[^\\n]+\"do local K,L,M=h:match\"(%x+)%s+(%d+)%s+(.+)\"if K then g.sha1[M]=K end end end;if J.SHA256 then g.sha256={}for h in J.SHA256:gmatch\"[^\\n]+\"do local K,L,M=h:match\"(%x+)%s+(%d+)%s+(.+)\"if K then g.sha256[M]=K end end end;return g end;return e\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291207,size=7724},["cache.lua"]={type="file",created=1740881291216,worldPermissions={execute=false,read=true,write=false},data="local a=require\"system.expect\"local b=require\"system.filesystem\"local c=require\"dpkg.control\"local d=require\"dpkg\"local e=require\"apt.config\"local f=require\"apt.repo\"local g=require\"muxzcat\"local h=require\"LibDeflate\"local i=require\"sha2\"local j=1;local k={[0]=\"<<\",\"<=\",\"=\",\">=\",\">>\",[\"<<\"]=0,[\"<=\"]=1,[\"=\"]=2,[\">=\"]=3,[\">>\"]=4}local l={\"preDepends\",\"preDepended\",\"depends\",\"depended\",\"conflicts\",\"conflicted\",\"breaks\",\"broken\"}local m={}local n={}n.__mt={__name=\"Trie\",__index=n}function n:new(o)a(1,o,\"string\",\"nil\")return setmetatable({character=o,children={}},self.__mt)end;function n:isEmpty()return#self.children==0 end;function n:insert(p,q)a(1,p,\"string\")local r=p:byte(1)if not self.children[r or-1]then self.children[r or-1]=n:new(r and string.char(r)or\"\")end;if r then return self.children[r]:insert(p:sub(2),q)else self.children[-1].value=q end end;function n:remove(p)a(1,p,\"string\")local r=p:byte(1)or-1;if self.children[r]then self.children[r]:remove(p:sub(2))if next(self.children[r].children)==nil then self.children[r]=nil end end end;function n:find(p)a(1,p,\"string\")local r=p:byte(1)or-1;if self.character==\"\"and r==-1 then return true,self.value end;if not self.children[r]then return false end;return self.children[r]:find(p:sub(2))end;function n:complete(p)p=a(1,p,\"string\",\"nil\")or\"\"local r=p:byte(1)if r then if self.children[r]then return self.children[r]:complete(p:sub(2))else return{}end end;if self.character==\"\"then return{\"\"}end;local s={}for t,q in pairs(self.children)do local u=q:complete()for t,v in ipairs(u)do s[#s+1]=q.character..v end end;return s end;local function w(x,y,o)local z=x:byte(y)+1;y=y+1;local A=n:new(o)for t=1,z do local B=x:byte(y)if B>=0xC0 then A.children[-1]=n:new(\"\")A.children[-1].value={(\">\"..(\"I\"):rep(bit32.band(B,0x3F)+1)):unpack(x,y+1)}y=table.remove(A.children[-1].value)elseif B>=0x80 then local C;C,y=(\">I\"):unpack(x,y)A.children[-1]=n:new(\"\")A.children[-1].value=bit32.band(C,0x7FFFFFFF)else A.children[B],y=w(x,y+1,string.char(B))end end;return A,y end;local function D(A)local E=1;for F,q in pairs(A.children)do if F==-1 then if type(q.value)==\"table\"then E=E+#q.value*4+1 else E=E+4 end else E=E+D(q)+1 end end;return E end;local function G(A)local s,H=\"\",0;for F,q in pairs(A.children)do H=H+1;if F==-1 then if type(q.value)==\"table\"then s=s..(\">B\"..(\"I\"):rep(#q.value)):pack(#q.value+0xBF,table.unpack(q.value))else s=s..(\">I\"):pack(q.value+0x80000000)end else s=s..string.char(F)..G(q)end end;return string.char(H-1)..s end;local function I(J,y)local K;K,y=(\">H\"):unpack(J.fileData,y)local s={}for L=1,K do local M=J.fileData:byte(y)local N={}s[L]=N;if bit32.btest(M,0x80)then local C;C,y=(\">I\"):unpack(J.fileData,y)N.package=J.packagesByOffset[bit32.band(C,0x1FFFFFFF)].name else local O,P=bit32.band(M,0x1F)if O==0x1F then P,y=(\"z\"):unpack(J.fileData,y+1)else P=J.fileData:sub(y+1,y+O+1)y=y+O+2 end;N.package=P end;if bit32.btest(M,0x40)then local Q=J.fileData:byte(y)N.relation=k[bit32.extract(Q,5,3)]local O=bit32.band(Q,0x1F)if O==0x1F then N.version,y=(\"z\"):unpack(J.fileData,y+1)else N.version=J.fileData:sub(y+1,y+O+1)y=y+O+2 end end;N.alternate=bit32.btest(M,0x20)end;return s,y end;local function R(J,C)local P,S,T,U,V,W,X,Y,y=(\"zzzBBc16c20c32\"):unpack(J.fileData,C+1)local s={name=P,version=S,filename=T,repoIndex=U,essential=bit32.btest(V,1),installed=bit32.btest(V,2),md5=W,sha1=X,sha256=Y,preDepends={},preDepended={},depends={},depended={},conflicts={},conflicted={},breaks={},broken={},provides={}}if not rawget(J.packagesByOffset,C)then J.packagesByOffset[C]=s end;if rawget(J.packagesByName,P)then local Z=d.compareVersions(J.packagesByName[P].version,S)if Z==-1 then J.packagesByName[P..\"=\"..J.packagesByName[P].version]=J.packagesByName[P]J.packagesByName[P]=s elseif Z==1 then J.packagesByName[P..\"=\"..J.packagesByName[P].version]=s end else J.packagesByName[P]=s end;for t,F in ipairs(l)do s[F],y=I(J,y)end;return s,y end;function m:load(_)local a0=b.open(e:getPath(\"Cache\",\"pkgcache\"),\"rb\")if not a0 then if _ then self.db={repos={}}else self.db={fileData=\"\",nameTrie=n:new(),packagesByName={},packagesByOffset={}}end;return false end;local x=a0.readAll()a0.close()if x:sub(1,4)~=\"APTL\"then error(\"Package cache is corrupt\",2)end;if(\">H\"):unpack(x,5)~=j then return false end;local a1,a2=(\">HI\"):unpack(x,7)if _ then local a3=x:byte(a2+1)local y=a2+2;self.db={repos={}}local J;J={fileData=x,packagesByName={},packagesByOffset=setmetatable({},{__index=function(a4,a5)local a6=R(J,a5)a4[a5]=a6;return a6 end})}for L=1,a3 do local a7,a8,a9,aa,ab;a7,a8,a9,aa,ab,y=(\">zzzzI\"):unpack(x,y)local U={url=a7,suite=a8,component=a9,architecture=aa,packages={}}self.db.repos[L]=U;local ac=y+ab-1;while y<ac do local a6;local C=y-1;a6,y=R(J,C)U.packages[a6.name]=J.packagesByOffset[C]end end else self.db={fileData=x,nameTrie=w(x,a1+1,nil),packagesByName=setmetatable({},{__index=function(a4,a5)return self:get(a5)end}),packagesByOffset=setmetatable({},{__index=function(a4,a5)return R(self.db,a5)end})}end;return true end;function m:get(P)if not self.db then return nil end;if self.db.repos then for t,q in ipairs(self.db.repos)do if q.packages[P]then return q.packages[P]end end;return nil end;local a6=rawget(self.db.packagesByName,P)if a6 then return a6 end;local ad,ae=self.db.nameTrie:find(P)if not ad then return nil end;if type(ae)==\"table\"then return nil end;return self.db.packagesByOffset[ae]end;function m:getVirtual(P)if not self.db then error(\"Database not loaded\",2)end;if self.db.repos then return{}end;local ad,ae=self.db.nameTrie:find(P)if not ad then return{}end;if type(ae)~=\"table\"then return{P}end;local s={}for L,q in ipairs(ae)do s[L]=self.db.packagesByOffset[q].name end;return s end;function m:getRepo(af)if not self.db then return nil end;if self.db.repos then return self.db.repos[af]end;local y=(\">I4\"):unpack(self.db.fileData,9)+2;local ag=self.db.fileData:byte(y-1)if af<1 or af>ag then return nil end;while af>=1 do local a7,a8,a9,aa,ah;a7,a8,a9,aa,ah,y=(\">zzzzI4\"):unpack(self.db.fileData,y)if af==1 then return{url=a7,suite=a8,component=a9,architecture=aa,packages={}}end;y=y+ah;af=af-1 end end;local function ai(aj)if aj==nil then return{}end;local ak=c.parseDependencies(aj)local s={}for t,q in ipairs(ak)do if q.multiple then for L,al in ipairs(q.names)do s[#s+1]={package=al.name,alternate=L~=1,relation=al.rel,version=al.version}end else s[#s+1]={package=q.name,alternate=false,relation=q.rel,version=q.version}end end;return s end;function m:update(a7,a8,a9,aa,am)if not self.db or not self.db.repos then error(\"Database not fully loaded\",2)end;local a5=#self.db.repos+1;for L,U in ipairs(self.db.repos)do if U.url==a7 and U.suite==a8 and U.component==a9 and U.architecture==aa then a5=L;break end end;local U={url=a7,suite=a8,component=a9,architecture=aa,packages={}}local an=self.db.repos[a5]self.db.repos[a5]=U;local ao=c.parseControlList(am)for t,q in ipairs(ao)do local a6={name=q.Package,version=q.Version,filename=q.Filename,repoIndex=a5,essential=q.Essential==\"yes\",installed=an and an[q.Package]and an[q.Package].installed,md5=q.MD5sum and q.MD5sum:gsub(\"%x%x\",function(ap)return string.char(tonumber(ap,16))end),sha1=q.SHA1 and q.SHA1:gsub(\"%x%x\",function(ap)return string.char(tonumber(ap,16))end),sha256=q.SHA256 and q.SHA256:gsub(\"%x%x\",function(ap)return string.char(tonumber(ap,16))end),preDepends=ai(q[\"Pre-Depends\"]),preDepended={},depends=ai(q.Depends),depended={},conflicts=ai(q.Conflicts),conflicted={},breaks=ai(q.Breaks),broken={},provides=ai(q.Provides)}if U.packages[q.Package]then local Z=d.compareVersions(U.packages[q.Package].version,q.Version)if Z==-1 then U.packages[q.Package..\"=\"..U.packages[q.Package].version]=U.packages[q.Package]U.packages[q.Package]=a6 elseif Z==1 then U.packages[q.Package..\"=\"..U.packages[q.Package].version]=a6 end else U.packages[q.Package]=a6 end end end;local function aq(N,ar,as)local s,at=(\">H\"):pack(#N),{}for t,q in ipairs(N)do if ar[q.package]and not as[q.package]then at[#at+1]={#s,q.package}s=s..(\">I4\"):pack(0x80000000+(q.relation and 0x40000000 or 0)+(q.alternate and 0x20000000 or 0))else s=s..string.char(math.min(#q.package-1,0x1F)+(q.relation and 0x40 or 0)+(q.alternate and 0x20 or 0))..q.package;if#q.package>0x1F then s=s..\"\\0\"end end;if q.relation then s=s..string.char(math.min(#q.version-1,0x1F)+k[q.relation]*0x20)..q.version;if#q.version>0x1F then s=s..\"\\0\"end end end;return s,at end;function m:save()if not self.db or not self.db.repos then error(\"Database not fully loaded\",2)end;local ar,as={},{}for t,U in ipairs(self.db.repos)do for F,q in pairs(U.packages)do if ar[F]then local Z=d.compareVersions(ar[F].version,q.version)if Z==-1 then ar[F..\"=\"..ar[F].version]=ar[F]ar[F]=q elseif Z==1 then ar[F..\"=\"..ar[F].version]=q end else ar[F]=q end;for t,al in ipairs(q.provides)do as[al.package]=as[al.package]or{}as[al.package][#as[al.package]+1]=q end end end;for t,U in ipairs(self.db.repos)do for F,q in pairs(U.packages)do for L,au in ipairs(q.preDepends)do if ar[au.package]then ar[au.package].preDepended[#ar[au.package].preDepended+1]={package=q.name,alternate=au.alternate or q.depends[L+1]and q.depends[L+1].alternate,relation=q.relation,version=q.version}end end;for L,au in ipairs(q.depends)do if ar[au.package]then ar[au.package].depended[#ar[au.package].depended+1]={package=q.name,alternate=au.alternate or q.depends[L+1]and q.depends[L+1].alternate,relation=q.relation,version=q.version}end end;for L,au in ipairs(q.conflicts)do if ar[au.package]then ar[au.package].conflicted[#ar[au.package].conflicted+1]={package=q.name,alternate=au.alternate or q.depends[L+1]and q.depends[L+1].alternate,relation=q.relation,version=q.version}end end;for L,au in ipairs(q.breaks)do if ar[au.package]then ar[au.package].broken[#ar[au.package].broken+1]={package=q.name,alternate=au.alternate or q.depends[L+1]and q.depends[L+1].alternate,relation=q.relation,version=q.version}end end end end;if next(ar)==nil then return end;local av=n:new()for F,q in pairs(ar)do av:insert(F,0)end;for F,q in pairs(as)do if not ar[F]then local aw={}for L=1,math.min(#q,64)do aw[L]=0 end;av:insert(F,aw)end end;local ax=D(av)local ay=12;local az,aA,at=string.char(#self.db.repos),{},{}for L,U in ipairs(self.db.repos)do az=az..(\">zzzz\"):pack(U.url,U.suite,U.component,U.architecture)local aB=\"\"for F,q in pairs(U.packages)do aA[q]=ay+ax+#az+4+#aB;aB=aB..(\">zzzBBc16c20c32\"):pack(q.name,q.version,q.filename,L,(q.essential and 1 or 0)+(q.installed and 2 or 0)+(q.md5 and 4 or 0)+(q.sha1 and 8 or 0)+(q.sha256 and 16 or 0),q.md5 or(\"\\0\"):rep(16),q.sha1 or(\"\\0\"):rep(20),q.sha256 or(\"\\0\"):rep(32))for t,aC in ipairs(l)do local p,aD=aq(q[aC],ar,as)for t,au in ipairs(aD)do at[#at+1]={au[1]+#az+4+#aB,au[2]}end;aB=aB..p end end;az=az..(\">s4\"):pack(aB)end;for t,q in ipairs(at)do az=az:sub(1,q[1])..(\">I4\"):pack((\">I4\"):unpack(az,q[1]+1)+aA[ar[q[2]]])..az:sub(q[1]+5)end;for F,q in pairs(ar)do av:insert(F,aA[q])end;for F,q in pairs(as)do if not ar[F]then local aw={}for L,al in ipairs(q)do if L>64 then break end;aw[L]=aA[al]end;av:insert(F,aw)end end;local a0=assert(b.open(e:getPath(\"Cache\",\"pkgcache\"),\"wb\"))a0.write((\">c4HHI\"):pack(\"APTL\",j,ay,ay+ax))a0.write(G(av))a0.write(az)a0.close()end;function m:generate()io.write(\"Reading package lists... \")local aE=f.readSources()self.db={repos={}}for t,q in ipairs(aE)do local aF,aG=f.readRelease(q)if aF then for t,aa in ipairs(e:get(\"APT\",\"Architectures\"))do local aH=e:get(\"Acquire\",\"IndexTargets\",q.type,\"Packages\",\"MetaKey\"):gsub(\"%$%(COMPONENT%)\",q.component):gsub(\"%$%(ARCHITECTURE%)\",aa)local T=b.combine(q.url:gsub(\"^.-://\",\"\"),\"dists\",q.suite,aH):gsub(\"[/:]\",\"_\")local aI=b.combine(e:getPath(\"State\",\"lists\"),T)local x;local a0=io.open(aI,\"r\")if a0 then x=a0:read(\"*a\")a0:close()if aF.md5 and i.md5(x):lower()~=aF.md5[q.component..\"/binary-\"..aa..\"/Packages\"]or aF.sha1 and i.sha1(x):lower()~=aF.sha1[q.component..\"/binary-\"..aa..\"/Packages\"]or aF.sha256 and i.sha256(x):lower()~=aF.sha256[q.component..\"/binary-\"..aa..\"/Packages\"]then error(\"Validation failed on \"..aI)end else a0=io.open(aI..\".xz\",\"rb\")if a0 then local aJ=a0:read(\"*a\")a0:close()if aF.md5 and i.md5(aJ)~=aF.md5[q.component..\"/binary-\"..aa..\"/Packages.xz\"]or aF.sha1 and i.sha1(aJ)~=aF.sha1[q.component..\"/binary-\"..aa..\"/Packages.xz\"]or aF.sha256 and i.sha256(aJ)~=aF.sha256[q.component..\"/binary-\"..aa..\"/Packages.xz\"]then error(\"Validation failed on \"..aI..\".xz\")end;x=g.DecompressXzOrLzmaString(aJ)else a0=io.open(aI..\".gz\",\"rb\")if a0 then local aK=a0:read(\"*a\")a0:close()if aF.md5 and i.md5(aK)~=aF.md5[q.component..\"/binary-\"..aa..\"/Packages.gz\"]or aF.sha1 and i.sha1(aK)~=aF.sha1[q.component..\"/binary-\"..aa..\"/Packages.gz\"]or aF.sha256 and i.sha256(aK)~=aF.sha256[q.component..\"/binary-\"..aa..\"/Packages.gz\"]then error(\"Validation failed on \"..aI..\".gz\")end;x=h:DecompressGzip(aK)end end end;if x then self:update(q.url,q.suite,q.component,aa,x)end end elseif aG~=\"No cached release file available\"then error(q.url..\" \"..q.suite..\" \"..q.component..\": \"..aG,2)end end;self:save()io.write(\"Done.\\n\")end;return m\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291202,size=13032},methods={type="directory",created=1740881291223,worldPermissions={write=false,read=true,execute=true},contents={["https.lua"]={type="file",created=1740881291220,worldPermissions={execute=false,read=true,write=false},data="local a=require\"system.network\"return function(b)local c,d=a.getData(b)if c and d==200 then return c elseif c then return nil,\"HTTP status \"..d else return nil,d end end\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291205,size=170},["http.lua"]={type="file",created=1740881291220,worldPermissions={execute=false,read=true,write=false},data="local a=require\"system.network\"return function(b)local c,d=a.getData(b)if c and d==200 then return c elseif c then return nil,\"HTTP status \"..d else return nil,d end end\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291205,size=170},["ftp.lua"]={type="file",created=1740881291219,worldPermissions={execute=false,read=true,write=false},data="local a=require\"system.network\"local b=require\"ftp\"return function(c)local d=a.parseURI(c)local e=b.client(d.host,d.port or 21)local f,g=e:open(d.path,\"rb\")if not f then e:close()return nil,g end;local h=f.readAll()f.close()e:close()return h end\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291205,size=246},["file.lua"]={type="file",created=1740881291218,worldPermissions={execute=false,read=true,write=false},data="return function(a)local b,c=io.open(a:gsub(\"^file://\",\"\"):gsub(\"^[^/]\",\"/%0\"),\"rb\")if not b then return nil,c end;local d=b:read(\"*a\")b:close()return d end\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291204,size=156}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881291223,size=0},planners={type="directory",created=1740881291220,worldPermissions={write=false,read=true,execute=true},contents={["80-default.lua"]={type="file",created=1740881291220,worldPermissions={execute=false,read=true,write=false},data="return function(a,b,c)local d,e,f={},{},{}local g=0;for h,i in pairs(c)do local j=assert(b:get(h),\"Could not find package '\"..h..\"' in cache\")if i then local k,l={},{}l[\"install:\"..h]=true;for m,n in ipairs(j.preDepends)do if c[n.package]==true then k[\"configure:\"..n.package]=true end end;for m,n in ipairs(j.depends)do if c[n.package]==true then l[\"configure:\"..n.package]=true end end;for m,n in ipairs(j.conflicts)do if c[n.package]==false then k[\"remove:\"..n.package]=true end end;for m,n in ipairs(j.breaks)do if c[n.package]==false then l[\"deconfigure:\"..n.package]=true end end;e[\"install:\"..h]=k;e[\"configure:\"..h]=l;if not next(k)then d[#d+1]=\"install:\"..h end else local o,p={},{}p[\"deconfigure:\"..h]=true;for m,n in ipairs(j.preDepended)do if c[n.package]==false then o[\"remove:\"..n.package]=true end end;for m,n in ipairs(j.depended)do if c[n.package]==false then o[\"deconfigure:\"..n.package]=true end end;e[\"deconfigure:\"..h]=o;e[\"remove:\"..h]=p;if not next(o)then d[#d+1]=\"deconfigure:\"..h end end;g=g+2 end;while#d>0 do table.sort(d,function(q,r)local s,t=q:match\"([^:]+):(.+)\"local u,v=r:match\"([^:]+):(.+)\"if s==\"install\"and u==\"configure\"then return true elseif s==\"configure\"and u==\"install\"then return false elseif s==\"remove\"and u==\"deconfigure\"then return false elseif s==\"deconfigure\"and u==\"remove\"then return true else return t<v end end)local w=table.remove(d,1)f[#f+1]=w;for h,i in pairs(e)do if i[w]then i[w]=nil;if not next(i)then d[#d+1]=h end end end end;if#f<g then return nil,\"Cycle in dependency graph\"end;return f end\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291206,size=1554}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881291220,size=0},["config.lua"]={type="file",created=1740881291217,worldPermissions={execute=false,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.process\"local c={apt={architecture=\"phoenix\",architectures={\"phoenix\"},compressor={[\".\"]={name=\".\",extension=\"\",library=\"\",method=\"\",cost=\"0\"},gzip={name=\"gzip\",extension=\".gz\",library=\"LibDeflate\",compressmethod=\"CompressGzip\",decompressmethod=\"DecompressGzip\",cost=\"100\",passself=\"1\"},xz={name=\"xz\",extension=\".xz\",library=\"muxzcat\",decompressmethod=\"DecompressXzOrLzmaString\",cost=\"200\",passself=\"0\"},lzma={name=\"lzma\",extension=\".lzma\",library=\"muxzcat\",decompressmethod=\"DecompressXzOrLzmaString\",cost=\"200\",passself=\"0\"}},[\"install-recommends\"]=\"1\",[\"install-suggests\"]=\"0\",sandbox={user=\"_apt\"}},dir={_=\"/\",state={_=\"var/lib/apt\",lists=\"lists/\",extended_states=\"extended_states\",status=\"/var/lib/dpkg/status\"},cache={_=\"var/cache/apt\",archives=\"archives/\",pkgcache=\"pkgcache.bin\"},etc={_=\"etc/apt\",sourcelist=\"sources.list\",sourceparts=\"sources.list.d\",main=\"apt.conf\",netrc=\"auth.conf\",netrcparts=\"auth.conf.d\",parts=\"apt.conf.d\",preferences=\"preferences\",preferencesparts=\"preferences.d\",trusted=\"trusted.gpg\",trustedparts=\"trusted.gpg.d\"},bin={methods=\"/usr/lib/apt/methods\",solvers={\"/usr/lib/apt/solvers\"},planners={\"/usr/lib/apt/planners\"},dpkg=\"/usr/bin/dpkg.lua\",gzip=\"/usr/bin/gzip.lua\",xz=\"/usr/bin/xz.lua\",lzma=\"/usr/bin/xz.lua\"},log={_=\"var/log/apt\",terminal=\"term.log\",history=\"history.log\",planner=\"eipp.log.xz\"},[\"ignore-files-silently\"]={\"~$\",\"%.disabled$\",\"%.bak$\",\"%.dpkg%-[a-z]+$\",\"%.ucf%-[a-z]+$\",\"%.save$\",\"%.orig$\",\"%.distUpgrade$\"}},acquire={allowinsecurerepositories=\"0\",allowweakrepositories=\"0\",allowdowngradetoinsecurerepositories=\"0\",indextargets={deb={packages={metakey=\"$(COMPONENT)/binary-$(ARCHITECTURE)/Packages\",flatmetakey=\"Packages\",shortdescription=\"Packages\",description=\"$(RELEASE)/$(COMPONENT) $(ARCHITECTURE)/Packages\",flatdescription=\"$(RELEASE) Packages\",optional=\"0\"}}},compressiontypes={xz=\"xz\",lzma=\"lzma\",gz=\"gzip\"}},dpkg={path=\"/usr/sbin:/usr/bin:/sbin:/bin\"},binary={apt={apt={color=\"1\",cache={show={version=\"2\"},allversions=\"0\",showvirtuals=\"1\",search={version=\"2\"},showdependencytype=\"1\",showversion=1},get={[\"upgrade-allow-new\"]=\"1\",update={interactivereleaseinfochanges=\"1\"}},cmd={[\"show-update-stats\"]=\"1\",[\"pattern-only\"]=\"1\"},[\"keep-downloaded-packages\"]=\"0\"},dpkg={[\"progress-fancy\"]=\"1\",lock={timeout=\"-1\"}}}}}local function d(...)local e,f=math.huge,nil;for g,h in ipairs{...}do if h and h<e then f,e=g,h end end;return f end;local function i(j,k)local l=1;local m={}local n={}local o=true;local p=true;while true do local q=k:find(\"//\",l)local r=k:find(\"/%*\",l)local s=k:find(\"[A-Za-z0-9/%-%._+]\",l)local t=k:find(\"{\",l)local u=k:find(\"}\",l)local v=k:find(\"::\",l)local w=k:find('\"',l)local x=k:find(\"#\",l)local e=d(q,r,s,t,u,v,w,x)if e==nil then return elseif e==1 then local y=k:match(\"//.*\\n()\",l)if not y then return end;l=y elseif e==2 then local y=k:match(\"/%*.*%*/()\",l)if not y then return end;l=y elseif e==3 then if o then error(\"Syntax error near \"..k:match(\"[A-Za-z0-9/%-%._+]+\",l))end;n[#n+1],l=k:match(\"([A-Za-z0-9/%-%._+]+)()\",l)o=false elseif e==4 then if#n==0 then error(\"Syntax error near {\")end;if not o then error(\"Syntax error near \"..n[1]..\":: {\")end;for g=1,#n do m[#m+1]=n[g]end;n={}o=true;p=true;l=k:match(\"{()\",l)elseif e==5 then if#n>0 then error(\"Syntax error near \"..table.concat(n,\"::\")..\" }\")end;m[#m]=nil;p=false;l=k:match(\"}()\",l)elseif e==6 then if not o then error(\"Syntax error near :: ::\")end;o=true;l=k:match(\"::()\",l)elseif e==7 then local z,A=k:match('\"([^\"]+)\"()',l)if not z then error(\"Syntax error: unfinished string\")end;if#n==0 and#m==0 then error(\"Syntax error near \\\"\"..z..\"\\\"\")end;local B=j;if#n==0 then for g=1,#m-1 do local C=m[g]:lower()if not B[C]then B[C]={}end;B=B[C]end;local C=m[#m]:lower()if p or not B[C]then B[C]={}end;B=B[C]B[#B+1]=z else for D,C in ipairs(m)do C=C:lower()if not B[C]then B[C]={}end;B=B[C]end;for g=1,#n-1 do local C=n[g]:lower()if not B[C]then B[C]={}end;B=B[C]end;if o then local C=n[#n]:lower()if not B[C]then B[C]={}end;B=B[C]B[#B+1]=z else B[n[#n]:lower()]=z end end;l=k:match(\"^%s*;()\",A)p=false;if not l then error(\"Syntax error: missing semicolon near \\\"\"..z..\"\\\"\")end elseif e==8 then local z,A=k:match(\"#(%a+);()\")if not z then error(\"Syntax error: malformed command\")end;if z==\"clear\"then else error(\"Syntax error: unknown command \"..z)end;l=A end end end;local function E(F,G)for C,h in pairs(G)do if type(h)==\"table\"then if not F[C]then F[C]={}end;E(F[C],h)else F[C]=h end end end;function c:load()self=self or c;local H=b.getenv().APT_CONFIG;if H then local I=io.open(H,\"r\")if I then local J=I:read(\"*a\")I:close()i(self,J)end end;local K=self:getPath(\"Etc\",\"Parts\")if a.isDir(K)then for D,y in ipairs(a.list(K))do local I=io.open(a.combine(K,y),\"r\")if I then local J=I:read(\"*a\")I:close()i(self,J)end end end;local I=io.open(self:getPath(\"Etc\",\"main\"),\"r\")if I then local J=I:read(\"*a\")I:close()i(self,J)end;local L=b.getname():match(\"[^/]+$\")if L then L=L:gsub(\"%.lua$\",\"\")self.binary._=L;if self.binary[L]then E(self,self.binary[L])end end end;function c:append(z)i(self,z)end;local function M(N,O,...)if type(N)==\"string\"then return N end;if not O then return N._ or\"\"end;return a.combine(N._ or\"\",M(N[O:lower()]or{},...))end;function c:getPath(...)return M(self.dir,...)end;function c:get(...)local C=...if not C then return self end;if not self[C:lower()]then return nil end;return c.get(self[C:lower()],select(2,...))end;return c\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291202,size=5450},["get.lua"]={type="file",created=1740881291217,worldPermissions={execute=false,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"apt.config\"local c=require\"apt.cache\"local d=require\"apt.repo\"local e=require\"dpkg.query\"local f=require\"dpkg.trigger\"local g=require\"dpkg\"local h=require\"sha2\"local i={}local j=1;local k=0;local l=os.time()function i.update()local m={}local n=d.readSources()for o,p in ipairs(n)do if m[p.suite]==nil then local q=a.combine(p.url:gsub(\"^.-://\",\"\"),\"dists\",p.suite):gsub(\"[/:]\",\"_\")local r=a.combine(b:getPath(\"State\",\"lists\"),q)local s=require(\"apt.methods.\"..p.url:match(\"^[^:]+\"))local t,u=s(p.url..\"dists/\"..p.suite..\"/InRelease\")if t then local v=true;local w=io.open(r..\"_InRelease\",\"r\")if w then local x=w:read(\"*a\")w:close()v=x~=t end;if v then w=assert(io.open(r..\"_InRelease\",\"w\"))w:write(t)w:close()m[p.suite]=true;print(\"Get:\"..j..\" \"..p.url..\" \"..p.suite..\" InRelease [\"..math.floor(#t/1024)..\" kB]\")j=j+1;k=k+#t else m[p.suite]=false;print(\"Hit:\"..j..\" \"..p.url..\" \"..p.suite..\" InRelease\")j=j+1 end else print(\"Err:\"..j..\" \"..p.url..\" \"..p.suite..\" InRelease (\"..u..\")\")j=j+1;local y,u=s(p.url..\"dists/\"..p.suite..\"/Release\")if y then local v=true;local w=io.open(r..\"_Release\",\"r\")if w then local x=w:read(\"*a\")w:close()v=x~=y end;if v then w=assert(io.open(r..\"_Release\",\"w\"))w:write(y)w:close()print(\"Get:\"..j..\" \"..p.url..\" \"..p.suite..\" Release [\"..math.floor(#y/1024)..\" kB]\")j=j+1;k=k+#y;local z,u=s(p.url..\"dists/\"..p.suite..\"/Release.gpg\",{encoding=\"binary\"})if z then w=assert(io.open(r..\"_Release.gpg\",\"wb\"))w:write(z)w:close()m[p.suite]=true;print(\"Get:\"..j..\" \"..p.url..\" \"..p.suite..\" Release.gpg [\"..math.floor(#z/1024)..\" kB]\")j=j+1;k=k+#z else m[p.suite]=false;print(\"Err:\"..j..\" \"..p.url..\" \"..p.suite..\" Release.gpg (\"..u..\")\")j=j+1 end else m[p.suite]=false;print(\"Hit:\"..j..\" \"..p.url..\" \"..p.suite..\" Release\")j=j+1 end else m[p.suite]=false;print(\"Err:\"..j..\" \"..p.url..\" \"..p.suite..\" Release (\"..u..\")\")j=j+1 end end end end;for o,p in ipairs(n)do if m[p.suite]then local s=require(\"apt.methods.\"..p.url:match(\"^[^:]+\"))for o,A in ipairs(b.apt.architectures)do for B,C in pairs(b.acquire.indextargets[p.type])do local D={[\"$(RELEASE)\"]=p.suite,[\"$(COMPONENT)\"]=p.component,[\"$(LANGUAGE)\"]=\"en\",[\"$(ARCHITECTURE)\"]=A,[\"$(NATIVE_ARCHITECTURE)\"]=b.apt.architecture}local E=C.metakey:gsub(\"%$%b()\",D)local q=a.combine(p.url:gsub(\"^.-://\",\"\"),\"dists\",p.suite,E):gsub(\"[/:]\",\"_\")local r=a.combine(b:getPath(\"State\",\"lists\"),q)local F,u=s(p.url..\"dists/\"..p.suite..\"/\"..E)if F then local w=assert(io.open(r,\"wb\"))w:write(F)w:close()print(\"Get:\"..j..\" \"..p.url..\" \"..C.description:gsub(\"%$%b()\",D)..\" [\"..math.floor(#F/1024)..\" kB]\")j=j+1;k=k+#F else print(\"Err:\"..j..\" \"..p.url..\" \"..C.description:gsub(\"%$%b()\",D)..\" (\"..u..\")\")j=j+1 end end end end end end;function i.download(G)if not c.db then c:load()end;local H=c:get(G)if not H then return nil end;local p=assert(c:getRepo(H.repoIndex),\"Invalid info in cache\")local q=H.name..\"_\"..H.version..\"_\"..p.architecture..\".deb\"local r=a.combine(b:getPath(\"Cache\",\"archives\"),q)if a.exists(r)then local w=assert(io.open(r,\"rb\"))local x=w:read(\"*a\")w:close()if h.sha256(x)==h.bin_to_hex(H.sha256)then return r end end;local s=require(\"apt.methods.\"..p.url:match(\"^[^:]+\"))local F,u=s(p.url..H.filename)if F and h.sha256(F)~=h.bin_to_hex(H.sha256)then F,u=nil,\"Failed to verify package integrity\"end;if F then local w=assert(io.open(r,\"wb\"))w:write(F)w:close()print(\"Get:\"..j..\" \"..p.url..\" \"..p.suite..\"/\"..p.component..\" \"..p.architecture..\" \"..H.name..\" \"..p.architecture..\" \"..H.version..\" [\"..math.floor(#F/1024)..\" kB]\")j=j+1;k=k+#F;return r else print(\"Err:\"..j..\" \"..p.url..\" \"..p.suite..\"/\"..p.component..\" \"..p.architecture..\" \"..H.name..\" \"..p.architecture..\" \"..H.version..\" (\"..u..\")\")j=j+1;return nil end end;function i.showStats()if k==0 then return end;local I=os.difftime(os.time(),l)print(\"Fetched \"..math.ceil(k/1024)..\" kB in \"..I..\"s (\"..math.ceil(k/I/1024)..\" kB/s)\")end;function i.plan(J,K,L)io.write(\"Building dependency tree... \")local M;for o,r in ipairs(b:get(\"Dir\",\"Bin\",\"solvers\")or{})do for o,N in ipairs(a.list(r))do if N:match\"%.lua$\"then local O=dofile(a.combine(r,N))M=O(J,c,K,L)if M then break end end end;if M then break end end;io.write(\"Done.\\n\")if not M then return nil,\"Could not find a valid install strategy\"end;local P;for o,r in ipairs(b:get(\"Dir\",\"Bin\",\"planners\")or{})do for o,N in ipairs(a.list(r))do if N:match\"%.lua$\"then local Q=dofile(a.combine(r,N))P=Q(J,c,M,L)if P then break end end end;if P then break end end;if not P then return nil,\"Failed to create plan for installation\"end;local R={}for B,C in pairs(M)do if C then R[#R+1]=B end end;return P,M,R end;function i.planUpgrade(J,S,L)io.write(\"Calculating upgrade... \")local T={}for B,C in pairs(J)do local H=c:get(B)if H and g.compareVersions(H.version,C.Version)>0 then T[B]=true end end;if S then print(\"Done.\")return T,{},i.plan(J,T,L)end;local U={}while true do local M;for o,r in ipairs(b:get(\"Dir\",\"Bin\",\"solvers\")or{})do for o,N in ipairs(a.list(r))do if N:match\"%.lua$\"then local O=dofile(a.combine(r,N))M=O(J,c,T,L)if M then break end end end;if M then break end end;if not M then print(\"Done.\")return nil end;local V;for B,C in pairs(M)do if J[B]~=nil~=C then V=B;break end end;if not V then print(\"Done.\")return T,U,i.plan(J,T,L)end;local W=T;local X=0;for o in pairs(T)do X=X+1 end;while X>1 do local Y,Z={},{}local _=math.floor(X/2)local a0=0;for B,C in pairs(W)do if a0>=_ then Z[B]=C else Y[B]=C end;a0=a0+1 end;local a1,a2;for o,r in ipairs(b:get(\"Dir\",\"Bin\",\"solvers\")or{})do for o,N in ipairs(a.list(r))do if N:match\"%.lua$\"then local O=dofile(a.combine(r,N))if not a1 then a1=O(J,c,Y,L)end;if not a2 then a2=O(J,c,Z,L)end;if a1 and a2 then break end end end;if a1 and a2 then break end end;if not a1 or not a2 then error(\"Something went wrong while calculating the upgrade.\")end;if a1[V]~=nil then W,X=Y,_ elseif a2[V]~=nil then W,X=Z,math.ceil(X/2)else error(\"Something went wrong while calculating the upgrade.\")end end;local B=next(W)T[B]=nil;U[B]=true end end;local function a3(G,a4,J)local a5={string.match(G.Status,\"(%S+) (%S+) (%S+)\")}a5[a4]=J;G.Status=table.concat(a5,\" \")return G.Status end;function i.execute(P,a6,a7)local a8={}for o,a9 in ipairs(P)do local aa,N=a9:match\"^([^:]+):(.*)$\"if aa==\"install\"then if not a8[N]then a8[N]=g.package(a6[N])end;g.package.packagedb[N]=g.package.packagedb[N]or{Status=\"unknown ok not-installed\"}a3(g.package.packagedb[N],1,\"install\")a8[N].unpack()elseif aa==\"configure\"then if not a8[N]then a8[N]=g.package(N)end;a8[N].configure()elseif aa==\"deconfigure\"then elseif aa==\"remove\"then if not a8[N]then a8[N]=g.package(N)end;a8[N].remove()if a7 then a8[N].purge()end else error(\"Unknown operation \"..aa..\" in plan\",2)end end;for B,C in pairs(g.package.packagedb)do if C[\"Triggers-Pending\"]then g.print(\"Processing triggers for \"..B..\" (\"..C.Version..\") ...\")f.commit(B,g.package.triggerdb,g.package.packagedb)end end;e.writeDatabase(g.package.packagedb)end;return i\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291203,size=6965},["init.lua"]={type="file",created=1740881291218,worldPermissions={execute=false,read=true,write=false},data="\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291203,size=1}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881291221,size=0},["sha2.lua"]={type="file",created=1740881293805,worldPermissions={execute=false,read=true,write=false},data="local a=false;local unpack,b,c,d,e,f,g,h,i,j,k,l,m,tonumber,type,n=table.unpack or unpack,table.concat,string.byte,string.char,string.rep,string.sub,string.gsub,string.gmatch,string.format,math.floor,math.ceil,math.min,math.max,tonumber,type,math.huge;local function o(p)local q,r,s,t=0,p,p;while true do q,t,r,s=q+1,r,r+r+1,s+s+q%2;if q>256 or r-(r-1)~=1 or s-(s-1)~=1 or r==s then return q,false elseif r==t then return q,true end end end;local u=2/3;local v=u*5>3 and u*4<3 and o(1.0)>=53;assert(v,\"at least 53-bit floating point numbers are required\")local w,x=o(1)local y=x and w==64;local z=x and w==32;assert(y or z or not x,\"Lua integers must be either 32-bit or 64-bit\")local A=({false,[1]=true})[1]and _VERSION~=\"Luau\"and(type(jit)~=\"table\"or jit.version_num>=20000)local B;local C;local D;local E;local F;if A then E=require\"bit\"F=\"bit\"local G,H=pcall(require,\"ffi\")if G then D=H end;B=not not loadstring\"b=0b0\"C=type(jit)==\"table\"and jit.arch or D and D.arch or nil else for I,J in ipairs(_VERSION==\"Lua 5.2\"and{\"bit32\",\"bit\"}or{\"bit\",\"bit32\"})do if type(_G[J])==\"table\"and _G[J].bxor then E=_G[J]F=J;break end end end;if a then print(\"Abilities:\")print(\"   Lua version:               \"..(A and\"LuaJIT \"..(B and\"2.1 \"or\"2.0 \")..(C or\"\")..(D and\" with FFI\"or\" without FFI\")or _VERSION))print(\"   Integer bitwise operators: \"..(y and\"int64\"or z and\"int32\"or\"no\"))print(\"   32-bit bitwise library:    \"..(F or\"not found\"))end;local K,L;if A and D then K=\"Using 'ffi' library of LuaJIT\"L=\"FFI\"elseif A then K=\"Using special code for sandboxed LuaJIT (no FFI)\"L=\"LJ\"elseif F then K=\"Using '\"..F..\"' library\"L=\"LIB32\"else K=\"Emulating bitwise operators using look-up table\"L=\"EMUL\"end;if a then print(\"Implementation selected:\")print(\"   \"..K)end;local M,N,O,P,Q,R,S,T,U,V,W;if L==\"FFI\"or L==\"LJ\"or L==\"LIB32\"then M=E.band;N=E.bor;O=E.bxor;P=E.lshift;Q=E.rshift;R=E.rol or E.lrotate;S=E.ror or E.rrotate;T=E.bnot;U=E.tobit;V=E.tohex;assert(M and N and O and P and Q and R and S and T,\"Library '\"..F..\"' is incomplete\")W=O end;V=V or pcall(i,\"%x\",2^31)and function(u)return i(\"%08x\",u%4294967296)end or function(u)return i(\"%08x\",(u+2^31)%2^32-2^31)end;local function X(u,Y)return O(u,Y or 0xA5A5A5A5)%4294967296 end;local function Z()return{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}end;local _,a0,a1,a2,a3,a4,a5,a6;local a7,a8,a9,aa,ab,ac={},{},{},{},{},{}local ad={[224]={},[256]=aa}local ae,af={[384]={},[512]=a9},{[384]={},[512]=aa}local ag,ah={},{0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476,0xC3D2E1F0}local ai={0,0,0,0,0,0,0,0,28,25,26,27,0,0,10,9,11,12,0,15,16,17,18,0,20,22,23,21}local aj,ak;local al={}local am,an,ao=al,al,{}local ap,aq,ar=4294967296,0,0;local as={{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16},{15,11,5,9,10,16,14,7,2,13,1,3,12,8,6,4},{12,9,13,1,6,3,16,14,11,15,4,7,8,2,10,5},{8,10,4,2,14,13,12,15,3,7,6,11,5,1,16,9},{10,1,6,8,3,5,11,16,15,2,12,13,7,9,4,14},{3,13,7,11,1,12,9,4,5,14,8,6,16,15,2,10},{13,6,2,16,15,14,5,11,1,8,7,4,10,3,9,12},{14,12,8,15,13,2,4,10,6,1,16,5,9,7,3,11},{7,16,15,10,12,4,1,9,13,3,14,8,2,5,11,6},{11,3,9,5,8,7,2,6,16,12,10,15,4,13,14,1}}as[11],as[12]=as[1],as[2]local at={1,3,4,11,13,10,12,6,1,3,4,11,13,10,2,7,5,8,14,15,16,9,2,7,5,8,14,15}local function au(av)local aw={}for I,ax in ipairs{1,9,13,17,18,21}do aw[ax]=\"<\"..e(av,ax)end;return aw end;if L==\"FFI\"then local ay=D.new(\"int32_t[?]\",80)an=ay;ao=D.new(\"int32_t[?]\",16)at=D.new(\"uint8_t[?]\",#at+1,0,unpack(at))for az=1,10 do as[az]=D.new(\"uint8_t[?]\",#as[az]+1,0,unpack(as[az]))end;as[11],as[12]=as[1],as[2]function _(aA,aB,aC,ax)local aD,aE=ay,a8;for aF=aC,aC+ax-1,64 do for az=0,15 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aG,24),P(E,16),P(aH,8),aI)end;for az=16,63 do local aG,E=aD[az-15],aD[az-2]aD[az]=U(O(S(aG,7),R(aG,14),Q(aG,3))+O(R(E,15),R(E,13),Q(E,10))+aD[az-7]+aD[az-16])end;local aG,E,aH,aI,aJ,aK,aL,aM=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for az=0,63,8 do local aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az]+aE[az+1]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az+1]+aE[az+2]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az+2]+aE[az+3]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az+3]+aE[az+4]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az+4]+aE[az+5]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az+5]+aE[az+6]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az+6]+aE[az+7]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az+7]+aE[az+8]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)end;aA[1],aA[2],aA[3],aA[4]=U(aG+aA[1]),U(E+aA[2]),U(aH+aA[3]),U(aI+aA[4])aA[5],aA[6],aA[7],aA[8]=U(aJ+aA[5]),U(aK+aA[6]),U(aL+aA[7]),U(aM+aA[8])end end;local aO=D.new(\"int64_t[?]\",80)am=aO;local aP=D.typeof\"int64_t\"local aQ=D.typeof\"int32_t\"local aR=D.typeof\"uint32_t\"aq=aP(2^32)if B then local aS,aT,aU,aV,aW,aX,aY,aZ=M,N,O,T,P,Q,R,S;aj=V;do local a_=D.new(\"int64_t[?]\",16)local aD=am;local function b0(aG,E,aH,aI,b1,b2)local b3,b4,b5,b6=a_[aG],a_[E],a_[aH],a_[aI]b3=aD[b1]+b3+b4;b6=aZ(aU(b6,b3),32)b5=b5+b6;b4=aZ(aU(b4,b5),24)b3=aD[b2]+b3+b4;b6=aZ(aU(b6,b3),16)b5=b5+b6;b4=aY(aU(b4,b5),1)a_[aG],a_[E],a_[aH],a_[aI]=b3,b4,b5,b6 end;function a5(aA,I,aB,aC,ax,b7,b8,b9)local ba,bb,bc,bd,be,bf,bg,bh=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for aF=aC,aC+ax-1,128 do if aB then for az=1,16 do aF=aF+8;local aG,E,aH,aI,aJ,aK,aL,aM=c(aB,aF-7,aF)aD[az]=aU(N(P(aM,24),P(aL,16),P(aK,8),aJ)*aP(2^32),aR(aQ(N(P(aI,24),P(aH,16),P(E,8),aG))))end end;a_[0x0],a_[0x1],a_[0x2],a_[0x3],a_[0x4],a_[0x5],a_[0x6],a_[0x7]=ba,bb,bc,bd,be,bf,bg,bh;a_[0x8],a_[0x9],a_[0xA],a_[0xB],a_[0xD],a_[0xE],a_[0xF]=a9[1],a9[2],a9[3],a9[4],a9[6],a9[7],a9[8]b7=b7+(b8 or 128)a_[0xC]=aU(a9[5],b7)if b8 then a_[0xE]=aV(a_[0xE])end;if b9 then a_[0xF]=aV(a_[0xF])end;for az=1,12 do local bi=as[az]b0(0,4,8,12,bi[1],bi[2])b0(1,5,9,13,bi[3],bi[4])b0(2,6,10,14,bi[5],bi[6])b0(3,7,11,15,bi[7],bi[8])b0(0,5,10,15,bi[9],bi[10])b0(1,6,11,12,bi[11],bi[12])b0(2,7,8,13,bi[13],bi[14])b0(3,4,9,14,bi[15],bi[16])end;ba=aU(ba,a_[0x0],a_[0x8])bb=aU(bb,a_[0x1],a_[0x9])bc=aU(bc,a_[0x2],a_[0xA])bd=aU(bd,a_[0x3],a_[0xB])be=aU(be,a_[0x4],a_[0xC])bf=aU(bf,a_[0x5],a_[0xD])bg=aU(bg,a_[0x6],a_[0xE])bh=aU(bh,a_[0x7],a_[0xF])end;aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]=ba,bb,bc,bd,be,bf,bg,bh;return b7 end end;local bj=D.typeof\"int64_t[?]\"ak=0;ar=aP(2^32)function Z()return bj(30)end;function a3(bk,I,aB,aC,ax,bl)local bm=ab;local bn=Q(bl,3)for aF=aC,aC+ax-1,bl do for az=0,bn-1 do aF=aF+8;local aM,aL,aK,aJ,aI,aH,E,aG=c(aB,aF-7,aF)bk[az]=aU(bk[az],aT(N(P(aG,24),P(E,16),P(aH,8),aI)*aP(2^32),aR(aQ(N(P(aJ,24),P(aK,16),P(aL,8),aM)))))end;for bo=1,24 do for az=0,4 do bk[25+az]=aU(bk[az],bk[az+5],bk[az+10],bk[az+15],bk[az+20])end;local bp=aU(bk[25],aY(bk[27],1))bk[1],bk[6],bk[11],bk[16]=aY(aU(bp,bk[6]),44),aY(aU(bp,bk[16]),45),aY(aU(bp,bk[1]),1),aY(aU(bp,bk[11]),10)bk[21]=aY(aU(bp,bk[21]),2)bp=aU(bk[26],aY(bk[28],1))bk[2],bk[7],bk[12],bk[22]=aY(aU(bp,bk[12]),43),aY(aU(bp,bk[22]),61),aY(aU(bp,bk[7]),6),aY(aU(bp,bk[2]),62)bk[17]=aY(aU(bp,bk[17]),15)bp=aU(bk[27],aY(bk[29],1))bk[3],bk[8],bk[18],bk[23]=aY(aU(bp,bk[18]),21),aY(aU(bp,bk[3]),28),aY(aU(bp,bk[23]),56),aY(aU(bp,bk[8]),55)bk[13]=aY(aU(bp,bk[13]),25)bp=aU(bk[28],aY(bk[25],1))bk[4],bk[14],bk[19],bk[24]=aY(aU(bp,bk[24]),14),aY(aU(bp,bk[19]),8),aY(aU(bp,bk[4]),27),aY(aU(bp,bk[14]),39)bk[9]=aY(aU(bp,bk[9]),20)bp=aU(bk[29],aY(bk[26],1))bk[5],bk[10],bk[15],bk[20]=aY(aU(bp,bk[10]),3),aY(aU(bp,bk[20]),18),aY(aU(bp,bk[5]),36),aY(aU(bp,bk[15]),41)bk[0]=aU(bp,bk[0])bk[0],bk[1],bk[2],bk[3],bk[4]=aU(bk[0],aS(aV(bk[1]),bk[2]),bm[bo]),aU(bk[1],aS(aV(bk[2]),bk[3])),aU(bk[2],aS(aV(bk[3]),bk[4])),aU(bk[3],aS(aV(bk[4]),bk[0])),aU(bk[4],aS(aV(bk[0]),bk[1]))bk[5],bk[6],bk[7],bk[8],bk[9]=aU(bk[8],aS(aV(bk[9]),bk[5])),aU(bk[9],aS(aV(bk[5]),bk[6])),aU(bk[5],aS(aV(bk[6]),bk[7])),aU(bk[6],aS(aV(bk[7]),bk[8])),aU(bk[7],aS(aV(bk[8]),bk[9]))bk[10],bk[11],bk[12],bk[13],bk[14]=aU(bk[11],aS(aV(bk[12]),bk[13])),aU(bk[12],aS(aV(bk[13]),bk[14])),aU(bk[13],aS(aV(bk[14]),bk[10])),aU(bk[14],aS(aV(bk[10]),bk[11])),aU(bk[10],aS(aV(bk[11]),bk[12]))bk[15],bk[16],bk[17],bk[18],bk[19]=aU(bk[19],aS(aV(bk[15]),bk[16])),aU(bk[15],aS(aV(bk[16]),bk[17])),aU(bk[16],aS(aV(bk[17]),bk[18])),aU(bk[17],aS(aV(bk[18]),bk[19])),aU(bk[18],aS(aV(bk[19]),bk[15]))bk[20],bk[21],bk[22],bk[23],bk[24]=aU(bk[22],aS(aV(bk[23]),bk[24])),aU(bk[23],aS(aV(bk[24]),bk[20])),aU(bk[24],aS(aV(bk[20]),bk[21])),aU(bk[20],aS(aV(bk[21]),bk[22])),aU(bk[21],aS(aV(bk[22]),bk[23]))end end end;local bq=0xA5A5A5A5*aP(2^32+1)function X(br,bs)return aU(br,bs or bq)end;function a0(aA,I,aB,aC,ax)local aD,aE=aO,a7;for aF=aC,aC+ax-1,128 do for az=0,15 do aF=aF+8;local aG,E,aH,aI,aJ,aK,aL,aM=c(aB,aF-7,aF)aD[az]=aT(N(P(aG,24),P(E,16),P(aH,8),aI)*aP(2^32),aR(aQ(N(P(aJ,24),P(aK,16),P(aL,8),aM))))end;for az=16,79 do local aG,E=aD[az-15],aD[az-2]aD[az]=aU(aZ(aG,1),aZ(aG,8),aX(aG,7))+aU(aZ(E,19),aY(E,3),aX(E,6))+aD[az-7]+aD[az-16]end;local aG,E,aH,aI,aJ,aK,aL,aM=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for az=0,79,8 do local aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+1]+aD[az]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN;aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+2]+aD[az+1]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN;aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+3]+aD[az+2]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN;aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+4]+aD[az+3]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN;aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+5]+aD[az+4]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN;aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+6]+aD[az+5]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN;aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+7]+aD[az+6]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN;aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+8]+aD[az+7]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN end;aA[1]=aG+aA[1]aA[2]=E+aA[2]aA[3]=aH+aA[3]aA[4]=aI+aA[4]aA[5]=aJ+aA[5]aA[6]=aK+aA[6]aA[7]=aL+aA[7]aA[8]=aM+aA[8]end end else local bt=D.new(\"union{int64_t i64; struct{int32_t \"..(D.abi(\"le\")and\"lo, hi\"or\"hi, lo\")..\";} i32;}[3]\")local function bu(aG)bt[0].i64=aG;local bv,bw=bt[0].i32.lo,bt[0].i32.hi;local bx=O(Q(bv,1),P(bw,31),Q(bv,8),P(bw,24),Q(bv,7),P(bw,25))local by=O(Q(bw,1),P(bv,31),Q(bw,8),P(bv,24),Q(bw,7))return by*aP(2^32)+aR(aQ(bx))end;local function bz(E)bt[0].i64=E;local bA,bB=bt[0].i32.lo,bt[0].i32.hi;local bC=O(Q(bA,19),P(bB,13),P(bA,3),Q(bB,29),Q(bA,6),P(bB,26))local bD=O(Q(bB,19),P(bA,13),P(bB,3),Q(bA,29),Q(bB,6))return bD*aP(2^32)+aR(aQ(bC))end;local function bE(aJ)bt[0].i64=aJ;local bF,bG=bt[0].i32.lo,bt[0].i32.hi;local bC=O(Q(bF,14),P(bG,18),Q(bF,18),P(bG,14),P(bF,23),Q(bG,9))local bD=O(Q(bG,14),P(bF,18),Q(bG,18),P(bF,14),P(bG,23),Q(bF,9))return bD*aP(2^32)+aR(aQ(bC))end;local function bH(aG)bt[0].i64=aG;local bA,bB=bt[0].i32.lo,bt[0].i32.hi;local bC=O(Q(bA,28),P(bB,4),P(bA,30),Q(bB,2),P(bA,25),Q(bB,7))local bD=O(Q(bB,28),P(bA,4),P(bB,30),Q(bA,2),P(bB,25),Q(bA,7))return bD*aP(2^32)+aR(aQ(bC))end;local function bI(aJ,aK,aL)bt[0].i64=aK;bt[1].i64=aL;bt[2].i64=aJ;local bJ,bK=bt[0].i32.lo,bt[0].i32.hi;local bL,bM=bt[1].i32.lo,bt[1].i32.hi;local bF,bG=bt[2].i32.lo,bt[2].i32.hi;local bN=O(bL,M(bF,O(bJ,bL)))local bO=O(bM,M(bG,O(bK,bM)))return bO*aP(2^32)+aR(aQ(bN))end;local function bP(aG,E,aH)bt[0].i64=aG;bt[1].i64=E;bt[2].i64=aH;local bv,bw=bt[0].i32.lo,bt[0].i32.hi;local bA,bB=bt[1].i32.lo,bt[1].i32.hi;local bQ,bR=bt[2].i32.lo,bt[2].i32.hi;local bN=O(M(O(bv,bA),bQ),M(bv,bA))local bO=O(M(O(bw,bB),bR),M(bw,bB))return bO*aP(2^32)+aR(aQ(bN))end;local function bS(aG,E,s)bt[0].i64=aG;bt[1].i64=E;local bv,bw=bt[0].i32.lo,bt[0].i32.hi;local bA,bB=bt[1].i32.lo,bt[1].i32.hi;local bQ,bR=O(bv,bA),O(bw,bB)local bx=O(Q(bQ,s),P(bR,-s))local by=O(Q(bR,s),P(bQ,-s))return by*aP(2^32)+aR(aQ(bx))end;local function bT(aG,E)bt[0].i64=aG;bt[1].i64=E;local bv,bw=bt[0].i32.lo,bt[0].i32.hi;local bA,bB=bt[1].i32.lo,bt[1].i32.hi;local bQ,bR=O(bv,bA),O(bw,bB)local bx=O(P(bQ,1),Q(bR,31))local by=O(P(bR,1),Q(bQ,31))return by*aP(2^32)+aR(aQ(bx))end;local function bU(aG,E)bt[0].i64=aG;bt[1].i64=E;local bv,bw=bt[0].i32.lo,bt[0].i32.hi;local bA,bB=bt[1].i32.lo,bt[1].i32.hi;local by,bx=O(bv,bA),O(bw,bB)return by*aP(2^32)+aR(aQ(bx))end;local function aU(aG,E)bt[0].i64=aG;bt[1].i64=E;local bv,bw=bt[0].i32.lo,bt[0].i32.hi;local bA,bB=bt[1].i32.lo,bt[1].i32.hi;local bx,by=O(bv,bA),O(bw,bB)return by*aP(2^32)+aR(aQ(bx))end;local function bV(aG,E,aH)bt[0].i64=aG;bt[1].i64=E;bt[2].i64=aH;local bv,bw=bt[0].i32.lo,bt[0].i32.hi;local bA,bB=bt[1].i32.lo,bt[1].i32.hi;local bQ,bR=bt[2].i32.lo,bt[2].i32.hi;local bx,by=O(bv,bA,bQ),O(bw,bB,bR)return by*aP(2^32)+aR(aQ(bx))end;function X(br,bs)bt[0].i64=br;local bW,bX=bt[0].i32.lo,bt[0].i32.hi;local bY,bZ=0xA5A5A5A5,0xA5A5A5A5;if bs then bt[1].i64=bs;bY,bZ=bt[1].i32.lo,bt[1].i32.hi end;bW=O(bW,bY)bX=O(bX,bZ)return bX*aP(2^32)+aR(aQ(bW))end;function aj(br)bt[0].i64=br;return V(bt[0].i32.hi)..V(bt[0].i32.lo)end;function a0(aA,I,aB,aC,ax)local aD,aE=aO,a7;for aF=aC,aC+ax-1,128 do for az=0,15 do aF=aF+8;local aG,E,aH,aI,aJ,aK,aL,aM=c(aB,aF-7,aF)aD[az]=N(P(aG,24),P(E,16),P(aH,8),aI)*aP(2^32)+aR(aQ(N(P(aJ,24),P(aK,16),P(aL,8),aM)))end;for az=16,79 do aD[az]=bu(aD[az-15])+bz(aD[az-2])+aD[az-7]+aD[az-16]end;local aG,E,aH,aI,aJ,aK,aL,aM=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for az=0,79,8 do local aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+1]+aD[az]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN;aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+2]+aD[az+1]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN;aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+3]+aD[az+2]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN;aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+4]+aD[az+3]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN;aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+5]+aD[az+4]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN;aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+6]+aD[az+5]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN;aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+7]+aD[az+6]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN;aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+8]+aD[az+7]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN end;aA[1]=aG+aA[1]aA[2]=E+aA[2]aA[3]=aH+aA[3]aA[4]=aI+aA[4]aA[5]=aJ+aA[5]aA[6]=aK+aA[6]aA[7]=aL+aA[7]aA[8]=aM+aA[8]end end;do local a_=D.new(\"int64_t[?]\",16)local aD=am;local function b0(aG,E,aH,aI,b1,b2)local b3,b4,b5,b6=a_[aG],a_[E],a_[aH],a_[aI]b3=aD[b1]+b3+b4;b6=bU(b6,b3)b5=b5+b6;b4=bS(b4,b5,24)b3=aD[b2]+b3+b4;b6=bS(b6,b3,16)b5=b5+b6;b4=bT(b4,b5)a_[aG],a_[E],a_[aH],a_[aI]=b3,b4,b5,b6 end;function a5(aA,I,aB,aC,ax,b7,b8,b9)local ba,bb,bc,bd,be,bf,bg,bh=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for aF=aC,aC+ax-1,128 do if aB then for az=1,16 do aF=aF+8;local aG,E,aH,aI,aJ,aK,aL,aM=c(aB,aF-7,aF)aD[az]=aU(N(P(aM,24),P(aL,16),P(aK,8),aJ)*aP(2^32),aR(aQ(N(P(aI,24),P(aH,16),P(E,8),aG))))end end;a_[0x0],a_[0x1],a_[0x2],a_[0x3],a_[0x4],a_[0x5],a_[0x6],a_[0x7]=ba,bb,bc,bd,be,bf,bg,bh;a_[0x8],a_[0x9],a_[0xA],a_[0xB],a_[0xD],a_[0xE],a_[0xF]=a9[1],a9[2],a9[3],a9[4],a9[6],a9[7],a9[8]b7=b7+(b8 or 128)a_[0xC]=aU(a9[5],b7)if b8 then a_[0xE]=-1-a_[0xE]end;if b9 then a_[0xF]=-1-a_[0xF]end;for az=1,12 do local bi=as[az]b0(0,4,8,12,bi[1],bi[2])b0(1,5,9,13,bi[3],bi[4])b0(2,6,10,14,bi[5],bi[6])b0(3,7,11,15,bi[7],bi[8])b0(0,5,10,15,bi[9],bi[10])b0(1,6,11,12,bi[11],bi[12])b0(2,7,8,13,bi[13],bi[14])b0(3,4,9,14,bi[15],bi[16])end;ba=bV(ba,a_[0x0],a_[0x8])bb=bV(bb,a_[0x1],a_[0x9])bc=bV(bc,a_[0x2],a_[0xA])bd=bV(bd,a_[0x3],a_[0xB])be=bV(be,a_[0x4],a_[0xC])bf=bV(bf,a_[0x5],a_[0xD])bg=bV(bg,a_[0x6],a_[0xE])bh=bV(bh,a_[0x7],a_[0xF])end;aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]=ba,bb,bc,bd,be,bf,bg,bh;return b7 end end end;function a1(aA,aB,aC,ax)local aD,aE=ay,ag;for aF=aC,aC+ax-1,64 do for az=0,15 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aI,24),P(aH,16),P(E,8),aG)end;local aG,E,aH,aI=aA[1],aA[2],aA[3],aA[4]for az=0,15,4 do aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az+1]+aD[az]+aG,7)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az+2]+aD[az+1]+aG,12)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az+3]+aD[az+2]+aG,17)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az+4]+aD[az+3]+aG,22)+E)end;for az=16,31,4 do local aL=5*az;aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az+1]+aD[M(aL+1,15)]+aG,5)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az+2]+aD[M(aL+6,15)]+aG,9)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az+3]+aD[M(aL-5,15)]+aG,14)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az+4]+aD[M(aL,15)]+aG,20)+E)end;for az=32,47,4 do local aL=3*az;aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az+1]+aD[M(aL+5,15)]+aG,4)+E)aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az+2]+aD[M(aL+8,15)]+aG,11)+E)aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az+3]+aD[M(aL-5,15)]+aG,16)+E)aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az+4]+aD[M(aL-2,15)]+aG,23)+E)end;for az=48,63,4 do local aL=7*az;aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az+1]+aD[M(aL,15)]+aG,6)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az+2]+aD[M(aL+7,15)]+aG,10)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az+3]+aD[M(aL-2,15)]+aG,15)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az+4]+aD[M(aL+5,15)]+aG,21)+E)end;aA[1],aA[2],aA[3],aA[4]=U(aG+aA[1]),U(E+aA[2]),U(aH+aA[3]),U(aI+aA[4])end end;function a2(aA,aB,aC,ax)local aD=ay;for aF=aC,aC+ax-1,64 do for az=0,15 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aG,24),P(E,16),P(aH,8),aI)end;for az=16,79 do aD[az]=R(O(aD[az-3],aD[az-8],aD[az-14],aD[az-16]),1)end;local aG,E,aH,aI,aJ=aA[1],aA[2],aA[3],aA[4],aA[5]for az=0,19,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+1]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+2]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+3]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+4]+0x5A827999+aJ)end;for az=20,39,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+1]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+2]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+3]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+4]+0x6ED9EBA1+aJ)end;for az=40,59,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+1]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+2]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+3]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+4]+0x8F1BBCDC+aJ)end;for az=60,79,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+1]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+2]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+3]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+4]+0xCA62C1D6+aJ)end;aA[1],aA[2],aA[3],aA[4],aA[5]=U(aG+aA[1]),U(E+aA[2]),U(aH+aA[3]),U(aI+aA[4]),U(aJ+aA[5])end end end;if L==\"FFI\"and not B or L==\"LJ\"then if L==\"FFI\"then local b_=D.typeof\"int32_t[?]\"function Z()return b_(31)end end;function a3(c0,c1,aB,aC,ax,bl)local c2,c3=ab,ac;local bn=Q(bl,3)for aF=aC,aC+ax-1,bl do for az=1,bn do local aG,E,aH,aI=c(aB,aF+1,aF+4)c0[az]=O(c0[az],N(P(aI,24),P(aH,16),P(E,8),aG))aF=aF+8;aG,E,aH,aI=c(aB,aF-3,aF)c1[az]=O(c1[az],N(P(aI,24),P(aH,16),P(E,8),aG))end;for bo=1,24 do for az=1,5 do c0[25+az]=O(c0[az],c0[az+5],c0[az+10],c0[az+15],c0[az+20])end;for az=1,5 do c1[25+az]=O(c1[az],c1[az+5],c1[az+10],c1[az+15],c1[az+20])end;local c4=O(c0[26],P(c0[28],1),Q(c1[28],31))local c5=O(c1[26],P(c1[28],1),Q(c0[28],31))c0[2],c1[2],c0[7],c1[7],c0[12],c1[12],c0[17],c1[17]=O(Q(O(c4,c0[7]),20),P(O(c5,c1[7]),12)),O(Q(O(c5,c1[7]),20),P(O(c4,c0[7]),12)),O(Q(O(c4,c0[17]),19),P(O(c5,c1[17]),13)),O(Q(O(c5,c1[17]),19),P(O(c4,c0[17]),13)),O(P(O(c4,c0[2]),1),Q(O(c5,c1[2]),31)),O(P(O(c5,c1[2]),1),Q(O(c4,c0[2]),31)),O(P(O(c4,c0[12]),10),Q(O(c5,c1[12]),22)),O(P(O(c5,c1[12]),10),Q(O(c4,c0[12]),22))local c6,aA=O(c4,c0[22]),O(c5,c1[22])c0[22],c1[22]=O(P(c6,2),Q(aA,30)),O(P(aA,2),Q(c6,30))c4=O(c0[27],P(c0[29],1),Q(c1[29],31))c5=O(c1[27],P(c1[29],1),Q(c0[29],31))c0[3],c1[3],c0[8],c1[8],c0[13],c1[13],c0[23],c1[23]=O(Q(O(c4,c0[13]),21),P(O(c5,c1[13]),11)),O(Q(O(c5,c1[13]),21),P(O(c4,c0[13]),11)),O(Q(O(c4,c0[23]),3),P(O(c5,c1[23]),29)),O(Q(O(c5,c1[23]),3),P(O(c4,c0[23]),29)),O(P(O(c4,c0[8]),6),Q(O(c5,c1[8]),26)),O(P(O(c5,c1[8]),6),Q(O(c4,c0[8]),26)),O(Q(O(c4,c0[3]),2),P(O(c5,c1[3]),30)),O(Q(O(c5,c1[3]),2),P(O(c4,c0[3]),30))c6,aA=O(c4,c0[18]),O(c5,c1[18])c0[18],c1[18]=O(P(c6,15),Q(aA,17)),O(P(aA,15),Q(c6,17))c4=O(c0[28],P(c0[30],1),Q(c1[30],31))c5=O(c1[28],P(c1[30],1),Q(c0[30],31))c0[4],c1[4],c0[9],c1[9],c0[19],c1[19],c0[24],c1[24]=O(P(O(c4,c0[19]),21),Q(O(c5,c1[19]),11)),O(P(O(c5,c1[19]),21),Q(O(c4,c0[19]),11)),O(P(O(c4,c0[4]),28),Q(O(c5,c1[4]),4)),O(P(O(c5,c1[4]),28),Q(O(c4,c0[4]),4)),O(Q(O(c4,c0[24]),8),P(O(c5,c1[24]),24)),O(Q(O(c5,c1[24]),8),P(O(c4,c0[24]),24)),O(Q(O(c4,c0[9]),9),P(O(c5,c1[9]),23)),O(Q(O(c5,c1[9]),9),P(O(c4,c0[9]),23))c6,aA=O(c4,c0[14]),O(c5,c1[14])c0[14],c1[14]=O(P(c6,25),Q(aA,7)),O(P(aA,25),Q(c6,7))c4=O(c0[29],P(c0[26],1),Q(c1[26],31))c5=O(c1[29],P(c1[26],1),Q(c0[26],31))c0[5],c1[5],c0[15],c1[15],c0[20],c1[20],c0[25],c1[25]=O(P(O(c4,c0[25]),14),Q(O(c5,c1[25]),18)),O(P(O(c5,c1[25]),14),Q(O(c4,c0[25]),18)),O(P(O(c4,c0[20]),8),Q(O(c5,c1[20]),24)),O(P(O(c5,c1[20]),8),Q(O(c4,c0[20]),24)),O(P(O(c4,c0[5]),27),Q(O(c5,c1[5]),5)),O(P(O(c5,c1[5]),27),Q(O(c4,c0[5]),5)),O(Q(O(c4,c0[15]),25),P(O(c5,c1[15]),7)),O(Q(O(c5,c1[15]),25),P(O(c4,c0[15]),7))c6,aA=O(c4,c0[10]),O(c5,c1[10])c0[10],c1[10]=O(P(c6,20),Q(aA,12)),O(P(aA,20),Q(c6,12))c4=O(c0[30],P(c0[27],1),Q(c1[27],31))c5=O(c1[30],P(c1[27],1),Q(c0[27],31))c0[6],c1[6],c0[11],c1[11],c0[16],c1[16],c0[21],c1[21]=O(P(O(c4,c0[11]),3),Q(O(c5,c1[11]),29)),O(P(O(c5,c1[11]),3),Q(O(c4,c0[11]),29)),O(P(O(c4,c0[21]),18),Q(O(c5,c1[21]),14)),O(P(O(c5,c1[21]),18),Q(O(c4,c0[21]),14)),O(Q(O(c4,c0[6]),28),P(O(c5,c1[6]),4)),O(Q(O(c5,c1[6]),28),P(O(c4,c0[6]),4)),O(Q(O(c4,c0[16]),23),P(O(c5,c1[16]),9)),O(Q(O(c5,c1[16]),23),P(O(c4,c0[16]),9))c0[1],c1[1]=O(c4,c0[1]),O(c5,c1[1])c0[1],c0[2],c0[3],c0[4],c0[5]=O(c0[1],M(T(c0[2]),c0[3]),c2[bo]),O(c0[2],M(T(c0[3]),c0[4])),O(c0[3],M(T(c0[4]),c0[5])),O(c0[4],M(T(c0[5]),c0[1])),O(c0[5],M(T(c0[1]),c0[2]))c0[6],c0[7],c0[8],c0[9],c0[10]=O(c0[9],M(T(c0[10]),c0[6])),O(c0[10],M(T(c0[6]),c0[7])),O(c0[6],M(T(c0[7]),c0[8])),O(c0[7],M(T(c0[8]),c0[9])),O(c0[8],M(T(c0[9]),c0[10]))c0[11],c0[12],c0[13],c0[14],c0[15]=O(c0[12],M(T(c0[13]),c0[14])),O(c0[13],M(T(c0[14]),c0[15])),O(c0[14],M(T(c0[15]),c0[11])),O(c0[15],M(T(c0[11]),c0[12])),O(c0[11],M(T(c0[12]),c0[13]))c0[16],c0[17],c0[18],c0[19],c0[20]=O(c0[20],M(T(c0[16]),c0[17])),O(c0[16],M(T(c0[17]),c0[18])),O(c0[17],M(T(c0[18]),c0[19])),O(c0[18],M(T(c0[19]),c0[20])),O(c0[19],M(T(c0[20]),c0[16]))c0[21],c0[22],c0[23],c0[24],c0[25]=O(c0[23],M(T(c0[24]),c0[25])),O(c0[24],M(T(c0[25]),c0[21])),O(c0[25],M(T(c0[21]),c0[22])),O(c0[21],M(T(c0[22]),c0[23])),O(c0[22],M(T(c0[23]),c0[24]))c1[1],c1[2],c1[3],c1[4],c1[5]=O(c1[1],M(T(c1[2]),c1[3]),c3[bo]),O(c1[2],M(T(c1[3]),c1[4])),O(c1[3],M(T(c1[4]),c1[5])),O(c1[4],M(T(c1[5]),c1[1])),O(c1[5],M(T(c1[1]),c1[2]))c1[6],c1[7],c1[8],c1[9],c1[10]=O(c1[9],M(T(c1[10]),c1[6])),O(c1[10],M(T(c1[6]),c1[7])),O(c1[6],M(T(c1[7]),c1[8])),O(c1[7],M(T(c1[8]),c1[9])),O(c1[8],M(T(c1[9]),c1[10]))c1[11],c1[12],c1[13],c1[14],c1[15]=O(c1[12],M(T(c1[13]),c1[14])),O(c1[13],M(T(c1[14]),c1[15])),O(c1[14],M(T(c1[15]),c1[11])),O(c1[15],M(T(c1[11]),c1[12])),O(c1[11],M(T(c1[12]),c1[13]))c1[16],c1[17],c1[18],c1[19],c1[20]=O(c1[20],M(T(c1[16]),c1[17])),O(c1[16],M(T(c1[17]),c1[18])),O(c1[17],M(T(c1[18]),c1[19])),O(c1[18],M(T(c1[19]),c1[20])),O(c1[19],M(T(c1[20]),c1[16]))c1[21],c1[22],c1[23],c1[24],c1[25]=O(c1[23],M(T(c1[24]),c1[25])),O(c1[24],M(T(c1[25]),c1[21])),O(c1[25],M(T(c1[21]),c1[22])),O(c1[21],M(T(c1[22]),c1[23])),O(c1[22],M(T(c1[23]),c1[24]))end end end end;if L==\"LJ\"then function _(aA,aB,aC,ax)local aD,aE=al,a8;for aF=aC,aC+ax-1,64 do for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aG,24),P(E,16),P(aH,8),aI)end;for az=17,64 do local aG,E=aD[az-15],aD[az-2]aD[az]=U(U(O(S(aG,7),R(aG,14),Q(aG,3))+O(R(E,15),R(E,13),Q(E,10)))+U(aD[az-7]+aD[az-16]))end;local aG,E,aH,aI,aJ,aK,aL,aM=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for az=1,64,8 do local aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az]+aD[az]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az+1]+aD[az+1]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az+2]+aD[az+2]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az+3]+aD[az+3]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az+4]+aD[az+4]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az+5]+aD[az+5]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az+6]+aD[az+6]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az+7]+aD[az+7]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)end;aA[1],aA[2],aA[3],aA[4]=U(aG+aA[1]),U(E+aA[2]),U(aH+aA[3]),U(aI+aA[4])aA[5],aA[6],aA[7],aA[8]=U(aJ+aA[5]),U(aK+aA[6]),U(aL+aA[7]),U(aM+aA[8])end end;local function c7(bv,bw,bA,bB,bQ,bR,c8,c9)local ca=bv%2^32+bA%2^32+bQ%2^32+c8%2^32;local cb=bw+bB+bR+c9;local bN=U(ca)local bO=U(cb+j(ca/2^32))return bN,bO end;if C==\"x86\"then function a0(cc,cd,aB,aC,ax)local aD,ce,cf=al,a7,a8;for aF=aC,aC+ax-1,128 do for az=1,16*2 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aG,24),P(E,16),P(aH,8),aI)end;for cg=17*2,80*2,2 do local bv,bw=aD[cg-30],aD[cg-31]local bx=O(N(Q(bv,1),P(bw,31)),N(Q(bv,8),P(bw,24)),N(Q(bv,7),P(bw,25)))local by=O(N(Q(bw,1),P(bv,31)),N(Q(bw,8),P(bv,24)),Q(bw,7))local bA,bB=aD[cg-4],aD[cg-5]local bC=O(N(Q(bA,19),P(bB,13)),N(P(bA,3),Q(bB,29)),N(Q(bA,6),P(bB,26)))local bD=O(N(Q(bB,19),P(bA,13)),N(P(bB,3),Q(bA,29)),Q(bB,6))aD[cg],aD[cg-1]=c7(bx,by,bC,bD,aD[cg-14],aD[cg-15],aD[cg-32],aD[cg-33])end;local bv,bA,bQ,c8,bF,bJ,bL,ch=cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]local bw,bB,bR,c9,bG,bK,bM,ci=cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]local cj=0;for az=1,80 do local bx=O(bL,M(bF,O(bJ,bL)))local by=O(bM,M(bG,O(bK,bM)))local bC=O(N(Q(bF,14),P(bG,18)),N(Q(bF,18),P(bG,14)),N(P(bF,23),Q(bG,9)))local bD=O(N(Q(bG,14),P(bF,18)),N(Q(bG,18),P(bF,14)),N(P(bG,23),Q(bF,9)))local ca=bC%2^32+bx%2^32+ch%2^32+ce[az]+aD[2*az]%2^32;local ck,cl=U(ca),U(bD+by+ci+cf[az]+aD[2*az-1]+j(ca/2^32))cj=cj+cj;ch,ci,bL,bM,bJ,bK=N(cj,bL),N(cj,bM),N(cj,bJ),N(cj,bK),N(cj,bF),N(cj,bG)local ca=ck%2^32+c8%2^32;bF,bG=U(ca),U(cl+c9+j(ca/2^32))c8,c9,bQ,bR,bA,bB=N(cj,bQ),N(cj,bR),N(cj,bA),N(cj,bB),N(cj,bv),N(cj,bw)bC=O(N(Q(bA,28),P(bB,4)),N(P(bA,30),Q(bB,2)),N(P(bA,25),Q(bB,7)))bD=O(N(Q(bB,28),P(bA,4)),N(P(bB,30),Q(bA,2)),N(P(bB,25),Q(bA,7)))bx=N(M(c8,bQ),M(bA,O(c8,bQ)))by=N(M(c9,bR),M(bB,O(c9,bR)))local ca=ck%2^32+bx%2^32+bC%2^32;bv,bw=U(ca),U(cl+by+bD+j(ca/2^32))end;cc[1],cd[1]=c7(cc[1],cd[1],bv,bw,0,0,0,0)cc[2],cd[2]=c7(cc[2],cd[2],bA,bB,0,0,0,0)cc[3],cd[3]=c7(cc[3],cd[3],bQ,bR,0,0,0,0)cc[4],cd[4]=c7(cc[4],cd[4],c8,c9,0,0,0,0)cc[5],cd[5]=c7(cc[5],cd[5],bF,bG,0,0,0,0)cc[6],cd[6]=c7(cc[6],cd[6],bJ,bK,0,0,0,0)cc[7],cd[7]=c7(cc[7],cd[7],bL,bM,0,0,0,0)cc[8],cd[8]=c7(cc[8],cd[8],ch,ci,0,0,0,0)end end else function a0(cc,cd,aB,aC,ax)local aD,ce,cf=al,a7,a8;for aF=aC,aC+ax-1,128 do for az=1,16*2 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aG,24),P(E,16),P(aH,8),aI)end;for cg=17*2,80*2,2 do local bv,bw=aD[cg-30],aD[cg-31]local bx=O(N(Q(bv,1),P(bw,31)),N(Q(bv,8),P(bw,24)),N(Q(bv,7),P(bw,25)))local by=O(N(Q(bw,1),P(bv,31)),N(Q(bw,8),P(bv,24)),Q(bw,7))local bA,bB=aD[cg-4],aD[cg-5]local bC=O(N(Q(bA,19),P(bB,13)),N(P(bA,3),Q(bB,29)),N(Q(bA,6),P(bB,26)))local bD=O(N(Q(bB,19),P(bA,13)),N(P(bB,3),Q(bA,29)),Q(bB,6))aD[cg],aD[cg-1]=c7(bx,by,bC,bD,aD[cg-14],aD[cg-15],aD[cg-32],aD[cg-33])end;local bv,bA,bQ,c8,bF,bJ,bL,ch=cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]local bw,bB,bR,c9,bG,bK,bM,ci=cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]for az=1,80 do local bx=O(bL,M(bF,O(bJ,bL)))local by=O(bM,M(bG,O(bK,bM)))local bC=O(N(Q(bF,14),P(bG,18)),N(Q(bF,18),P(bG,14)),N(P(bF,23),Q(bG,9)))local bD=O(N(Q(bG,14),P(bF,18)),N(Q(bG,18),P(bF,14)),N(P(bG,23),Q(bF,9)))local ca=bC%2^32+bx%2^32+ch%2^32+ce[az]+aD[2*az]%2^32;local ck,cl=U(ca),U(bD+by+ci+cf[az]+aD[2*az-1]+j(ca/2^32))ch,ci,bL,bM,bJ,bK=bL,bM,bJ,bK,bF,bG;local ca=ck%2^32+c8%2^32;bF,bG=U(ca),U(cl+c9+j(ca/2^32))c8,c9,bQ,bR,bA,bB=bQ,bR,bA,bB,bv,bw;bC=O(N(Q(bA,28),P(bB,4)),N(P(bA,30),Q(bB,2)),N(P(bA,25),Q(bB,7)))bD=O(N(Q(bB,28),P(bA,4)),N(P(bB,30),Q(bA,2)),N(P(bB,25),Q(bA,7)))bx=N(M(c8,bQ),M(bA,O(c8,bQ)))by=N(M(c9,bR),M(bB,O(c9,bR)))local ca=ck%2^32+bC%2^32+bx%2^32;bv,bw=U(ca),U(cl+bD+by+j(ca/2^32))end;cc[1],cd[1]=c7(cc[1],cd[1],bv,bw,0,0,0,0)cc[2],cd[2]=c7(cc[2],cd[2],bA,bB,0,0,0,0)cc[3],cd[3]=c7(cc[3],cd[3],bQ,bR,0,0,0,0)cc[4],cd[4]=c7(cc[4],cd[4],c8,c9,0,0,0,0)cc[5],cd[5]=c7(cc[5],cd[5],bF,bG,0,0,0,0)cc[6],cd[6]=c7(cc[6],cd[6],bJ,bK,0,0,0,0)cc[7],cd[7]=c7(cc[7],cd[7],bL,bM,0,0,0,0)cc[8],cd[8]=c7(cc[8],cd[8],ch,ci,0,0,0,0)end end end;function a1(aA,aB,aC,ax)local aD,aE=al,ag;for aF=aC,aC+ax-1,64 do for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aI,24),P(aH,16),P(E,8),aG)end;local aG,E,aH,aI=aA[1],aA[2],aA[3],aA[4]for az=1,16,4 do aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az]+aD[az]+aG,7)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az+1]+aD[az+1]+aG,12)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az+2]+aD[az+2]+aG,17)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az+3]+aD[az+3]+aG,22)+E)end;for az=17,32,4 do local aL=5*az-4;aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az]+aD[M(aL,15)+1]+aG,5)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az+1]+aD[M(aL+5,15)+1]+aG,9)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az+2]+aD[M(aL+10,15)+1]+aG,14)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az+3]+aD[M(aL-1,15)+1]+aG,20)+E)end;for az=33,48,4 do local aL=3*az+2;aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az]+aD[M(aL,15)+1]+aG,4)+E)aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az+1]+aD[M(aL+3,15)+1]+aG,11)+E)aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az+2]+aD[M(aL+6,15)+1]+aG,16)+E)aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az+3]+aD[M(aL-7,15)+1]+aG,23)+E)end;for az=49,64,4 do local aL=az*7;aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az]+aD[M(aL-7,15)+1]+aG,6)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az+1]+aD[M(aL,15)+1]+aG,10)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az+2]+aD[M(aL+7,15)+1]+aG,15)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az+3]+aD[M(aL-2,15)+1]+aG,21)+E)end;aA[1],aA[2],aA[3],aA[4]=U(aG+aA[1]),U(E+aA[2]),U(aH+aA[3]),U(aI+aA[4])end end;function a2(aA,aB,aC,ax)local aD=al;for aF=aC,aC+ax-1,64 do for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aG,24),P(E,16),P(aH,8),aI)end;for az=17,80 do aD[az]=R(O(aD[az-3],aD[az-8],aD[az-14],aD[az-16]),1)end;local aG,E,aH,aI,aJ=aA[1],aA[2],aA[3],aA[4],aA[5]for az=1,20,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+1]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+2]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+3]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+4]+0x5A827999+aJ)end;for az=21,40,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+1]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+2]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+3]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+4]+0x6ED9EBA1+aJ)end;for az=41,60,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+1]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+2]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+3]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+4]+0x8F1BBCDC+aJ)end;for az=61,80,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+1]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+2]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+3]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+4]+0xCA62C1D6+aJ)end;aA[1],aA[2],aA[3],aA[4],aA[5]=U(aG+aA[1]),U(E+aA[2]),U(aH+aA[3]),U(aI+aA[4]),U(aJ+aA[5])end end;do local cm,cn={},{}local function b0(aG,E,aH,aI,b1,b2)local aD=al;local co,cp,cq,cr=cm[aG],cm[E],cm[aH],cm[aI]local cs,ct,cu,cv=cn[aG],cn[E],cn[aH],cn[aI]local aN=aD[2*b1-1]+co%2^32+cp%2^32;co=U(aN)cs=U(aD[2*b1]+cs+ct+j(aN/2^32))cr,cv=O(cv,cs),O(cr,co)aN=cq%2^32+cr%2^32;cq=U(aN)cu=U(cu+cv+j(aN/2^32))cp,ct=O(cp,cq),O(ct,cu)cp,ct=O(Q(cp,24),P(ct,8)),O(Q(ct,24),P(cp,8))aN=aD[2*b2-1]+co%2^32+cp%2^32;co=U(aN)cs=U(aD[2*b2]+cs+ct+j(aN/2^32))cr,cv=O(cr,co),O(cv,cs)cr,cv=O(Q(cr,16),P(cv,16)),O(Q(cv,16),P(cr,16))aN=cq%2^32+cr%2^32;cq=U(aN)cu=U(cu+cv+j(aN/2^32))cp,ct=O(cp,cq),O(ct,cu)cp,ct=O(P(cp,1),Q(ct,31)),O(P(ct,1),Q(cp,31))cm[aG],cm[E],cm[aH],cm[aI]=co,cp,cq,cr;cn[aG],cn[E],cn[aH],cn[aI]=cs,ct,cu,cv end;function a5(cc,cd,aB,aC,ax,b7,b8,b9)local aD=al;local cw,cx,cy,cz,cA,cB,cC,cD=cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]local cE,cF,cG,cH,cI,cJ,cK,cL=cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]for aF=aC,aC+ax-1,128 do if aB then for az=1,32 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=aI*2^24+N(P(aH,16),P(E,8),aG)end end;cm[0x0],cm[0x1],cm[0x2],cm[0x3],cm[0x4],cm[0x5],cm[0x6],cm[0x7]=cw,cx,cy,cz,cA,cB,cC,cD;cm[0x8],cm[0x9],cm[0xA],cm[0xB],cm[0xC],cm[0xD],cm[0xE],cm[0xF]=a9[1],a9[2],a9[3],a9[4],a9[5],a9[6],a9[7],a9[8]cn[0x0],cn[0x1],cn[0x2],cn[0x3],cn[0x4],cn[0x5],cn[0x6],cn[0x7]=cE,cF,cG,cH,cI,cJ,cK,cL;cn[0x8],cn[0x9],cn[0xA],cn[0xB],cn[0xC],cn[0xD],cn[0xE],cn[0xF]=aa[1],aa[2],aa[3],aa[4],aa[5],aa[6],aa[7],aa[8]b7=b7+(b8 or 128)local cM=b7%2^32;local cN=j(b7/2^32)cm[0xC]=O(cm[0xC],cM)cn[0xC]=O(cn[0xC],cN)if b8 then cm[0xE]=T(cm[0xE])cn[0xE]=T(cn[0xE])end;if b9 then cm[0xF]=T(cm[0xF])cn[0xF]=T(cn[0xF])end;for az=1,12 do local bi=as[az]b0(0,4,8,12,bi[1],bi[2])b0(1,5,9,13,bi[3],bi[4])b0(2,6,10,14,bi[5],bi[6])b0(3,7,11,15,bi[7],bi[8])b0(0,5,10,15,bi[9],bi[10])b0(1,6,11,12,bi[11],bi[12])b0(2,7,8,13,bi[13],bi[14])b0(3,4,9,14,bi[15],bi[16])end;cw=O(cw,cm[0x0],cm[0x8])cx=O(cx,cm[0x1],cm[0x9])cy=O(cy,cm[0x2],cm[0xA])cz=O(cz,cm[0x3],cm[0xB])cA=O(cA,cm[0x4],cm[0xC])cB=O(cB,cm[0x5],cm[0xD])cC=O(cC,cm[0x6],cm[0xE])cD=O(cD,cm[0x7],cm[0xF])cE=O(cE,cn[0x0],cn[0x8])cF=O(cF,cn[0x1],cn[0x9])cG=O(cG,cn[0x2],cn[0xA])cH=O(cH,cn[0x3],cn[0xB])cI=O(cI,cn[0x4],cn[0xC])cJ=O(cJ,cn[0x5],cn[0xD])cK=O(cK,cn[0x6],cn[0xE])cL=O(cL,cn[0x7],cn[0xF])end;cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]=cw%2^32,cx%2^32,cy%2^32,cz%2^32,cA%2^32,cB%2^32,cC%2^32,cD%2^32;cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]=cE%2^32,cF%2^32,cG%2^32,cH%2^32,cI%2^32,cJ%2^32,cK%2^32,cL%2^32;return b7 end end end;if L==\"FFI\"or L==\"LJ\"then do local aD=an;local a_=ao;local function b0(aG,E,aH,aI,b1,b2)local b3,b4,b5,b6=a_[aG],a_[E],a_[aH],a_[aI]b3=U(aD[b1]+b3+b4)b6=S(O(b6,b3),16)b5=U(b5+b6)b4=S(O(b4,b5),12)b3=U(aD[b2]+b3+b4)b6=S(O(b6,b3),8)b5=U(b5+b6)b4=S(O(b4,b5),7)a_[aG],a_[E],a_[aH],a_[aI]=b3,b4,b5,b6 end;function a4(aA,aB,aC,ax,b7,b8,b9)local ba,bb,bc,bd,be,bf,bg,bh=U(aA[1]),U(aA[2]),U(aA[3]),U(aA[4]),U(aA[5]),U(aA[6]),U(aA[7]),U(aA[8])for aF=aC,aC+ax-1,64 do if aB then for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aI,24),P(aH,16),P(E,8),aG)end end;a_[0x0],a_[0x1],a_[0x2],a_[0x3],a_[0x4],a_[0x5],a_[0x6],a_[0x7]=ba,bb,bc,bd,be,bf,bg,bh;a_[0x8],a_[0x9],a_[0xA],a_[0xB],a_[0xE],a_[0xF]=U(aa[1]),U(aa[2]),U(aa[3]),U(aa[4]),U(aa[7]),U(aa[8])b7=b7+(b8 or 64)local cO=b7%2^32;local cP=j(b7/2^32)a_[0xC]=O(aa[5],cO)a_[0xD]=O(aa[6],cP)if b8 then a_[0xE]=T(a_[0xE])end;if b9 then a_[0xF]=T(a_[0xF])end;for az=1,10 do local bi=as[az]b0(0,4,8,12,bi[1],bi[2])b0(1,5,9,13,bi[3],bi[4])b0(2,6,10,14,bi[5],bi[6])b0(3,7,11,15,bi[7],bi[8])b0(0,5,10,15,bi[9],bi[10])b0(1,6,11,12,bi[11],bi[12])b0(2,7,8,13,bi[13],bi[14])b0(3,4,9,14,bi[15],bi[16])end;ba=O(ba,a_[0x0],a_[0x8])bb=O(bb,a_[0x1],a_[0x9])bc=O(bc,a_[0x2],a_[0xA])bd=O(bd,a_[0x3],a_[0xB])be=O(be,a_[0x4],a_[0xC])bf=O(bf,a_[0x5],a_[0xD])bg=O(bg,a_[0x6],a_[0xE])bh=O(bh,a_[0x7],a_[0xF])end;aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]=ba,bb,bc,bd,be,bf,bg,bh;return b7 end;function a6(aB,aC,ax,cQ,cR,cS,cT,cU,cV)cV=cV or 64;local ba,bb,bc,bd,be,bf,bg,bh=U(cS[1]),U(cS[2]),U(cS[3]),U(cS[4]),U(cS[5]),U(cS[6]),U(cS[7]),U(cS[8])cT=cT or cS;for aF=aC,aC+ax-1,64 do if aB then for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aI,24),P(aH,16),P(E,8),aG)end end;a_[0x0],a_[0x1],a_[0x2],a_[0x3],a_[0x4],a_[0x5],a_[0x6],a_[0x7]=ba,bb,bc,bd,be,bf,bg,bh;a_[0x8],a_[0x9],a_[0xA],a_[0xB]=U(aa[1]),U(aa[2]),U(aa[3]),U(aa[4])a_[0xC]=U(cR%2^32)a_[0xD]=j(cR/2^32)a_[0xE],a_[0xF]=cV,cQ;for az=1,7 do b0(0,4,8,12,at[az],at[az+14])b0(1,5,9,13,at[az+1],at[az+2])b0(2,6,10,14,at[az+16],at[az+7])b0(3,7,11,15,at[az+15],at[az+17])b0(0,5,10,15,at[az+21],at[az+5])b0(1,6,11,12,at[az+3],at[az+6])b0(2,7,8,13,at[az+4],at[az+18])b0(3,4,9,14,at[az+19],at[az+20])end;if cU then cT[9]=O(ba,a_[0x8])cT[10]=O(bb,a_[0x9])cT[11]=O(bc,a_[0xA])cT[12]=O(bd,a_[0xB])cT[13]=O(be,a_[0xC])cT[14]=O(bf,a_[0xD])cT[15]=O(bg,a_[0xE])cT[16]=O(bh,a_[0xF])end;ba=O(a_[0x0],a_[0x8])bb=O(a_[0x1],a_[0x9])bc=O(a_[0x2],a_[0xA])bd=O(a_[0x3],a_[0xB])be=O(a_[0x4],a_[0xC])bf=O(a_[0x5],a_[0xD])bg=O(a_[0x6],a_[0xE])bh=O(a_[0x7],a_[0xF])end;cT[1],cT[2],cT[3],cT[4],cT[5],cT[6],cT[7],cT[8]=ba,bb,bc,bd,be,bf,bg,bh end end end;O=O or X;if L==\"LIB32\"or L==\"EMUL\"then function _(aA,aB,aC,ax)local aD,aE=al,a8;local ba,bb,bc,bd,be,bf,bg,bh=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for aF=aC,aC+ax-1,64 do for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=((aG*256+E)*256+aH)*256+aI end;for az=17,64 do local aG,E=aD[az-15],aD[az-2]local cW,cX,cY,cZ=aG/2^7,aG/2^18,E/2^17,E/2^19;aD[az]=(O(cW%1*(2^32-1)+cW,cX%1*(2^32-1)+cX,(aG-aG%2^3)/2^3)+aD[az-16]+aD[az-7]+O(cY%1*(2^32-1)+cY,cZ%1*(2^32-1)+cZ,(E-E%2^10)/2^10))%2^32 end;local aG,E,aH,aI,aJ,aK,aL,aM=ba,bb,bc,bd,be,bf,bg,bh;for az=1,64 do aJ=aJ%2^32;local c_,d0,d1=aJ/2^6,aJ/2^11,aJ*2^7;local d2=d1%2^32;local aN=M(aJ,aK)+M(-1-aJ,aL)+aM+aE[az]+aD[az]+O(c_%1*(2^32-1)+c_,d0%1*(2^32-1)+d0,d2+(d1-d2)/2^32)aM=aL;aL=aK;aK=aJ;aJ=aN+aI;aI=aH;aH=E;E=aG%2^32;local d3,d4,d5=E/2^2,E/2^13,E*2^10;local d6=d5%2^32;aG=aN+M(aI,aH)+M(E,O(aI,aH))+O(d3%1*(2^32-1)+d3,d4%1*(2^32-1)+d4,d6+(d5-d6)/2^32)end;ba,bb,bc,bd=(aG+ba)%2^32,(E+bb)%2^32,(aH+bc)%2^32,(aI+bd)%2^32;be,bf,bg,bh=(aJ+be)%2^32,(aK+bf)%2^32,(aL+bg)%2^32,(aM+bh)%2^32 end;aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]=ba,bb,bc,bd,be,bf,bg,bh end;function a0(cc,cd,aB,aC,ax)local aD,ce,cf=al,a7,a8;local cw,cx,cy,cz,cA,cB,cC,cD=cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]local cE,cF,cG,cH,cI,cJ,cK,cL=cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]for aF=aC,aC+ax-1,128 do for az=1,16*2 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=((aG*256+E)*256+aH)*256+aI end;for cg=17*2,80*2,2 do local bw,bv,bB,bA=aD[cg-31],aD[cg-30],aD[cg-5],aD[cg-4]local d7,d8,d9,da,db,dc,dd,de,df,dg=bB%2^6,bB%2^19,bB%2^29,bA%2^19,bA%2^29,bw%2^1,bw%2^7,bw%2^8,bv%2^1,bv%2^8;local dh=O((bv-df)/2^1+dc*2^31,(bv-dg)/2^8+de*2^24,(bv-bv%2^7)/2^7+dd*2^25)%2^32+O((bA-da)/2^19+d8*2^13,db*2^3+(bB-d9)/2^29,(bA-bA%2^6)/2^6+d7*2^26)%2^32+aD[cg-14]+aD[cg-32]local di=dh%2^32;aD[cg-1]=(O((bw-dc)/2^1+df*2^31,(bw-de)/2^8+dg*2^24,(bw-dd)/2^7)+O((bB-d8)/2^19+da*2^13,d9*2^3+(bA-db)/2^29,(bB-d7)/2^6)+aD[cg-15]+aD[cg-33]+(dh-di)/2^32)%2^32;aD[cg]=di end;local bv,bA,bQ,c8,bF,bJ,bL,ch=cw,cx,cy,cz,cA,cB,cC,cD;local bw,bB,bR,c9,bG,bK,bM,ci=cE,cF,cG,cH,cI,cJ,cK,cL;for az=1,80 do local cg=2*az;local dj,dk,dl,dm,dn,dp=bF%2^9,bF%2^14,bF%2^18,bG%2^9,bG%2^14,bG%2^18;local dh=(M(bF,bJ)+M(-1-bF,bL))%2^32+ch+ce[az]+aD[cg]+O((bF-dk)/2^14+dn*2^18,(bF-dl)/2^18+dp*2^14,dj*2^23+(bG-dm)/2^9)%2^32;local ck=dh%2^32;local cl=M(bG,bK)+M(-1-bG,bM)+ci+cf[az]+aD[cg-1]+(dh-ck)/2^32+O((bG-dn)/2^14+dk*2^18,(bG-dp)/2^18+dl*2^14,dm*2^23+(bF-dj)/2^9)ch=bL;ci=bM;bL=bJ;bM=bK;bJ=bF;bK=bG;dh=ck+c8;bF=dh%2^32;bG=(cl+c9+(dh-bF)/2^32)%2^32;c8=bQ;c9=bR;bQ=bA;bR=bB;bA=bv;bB=bw;local dq,dr,ds,dt,du,dv=bA%2^2,bA%2^7,bA%2^28,bB%2^2,bB%2^7,bB%2^28;dh=ck+(M(c8,bQ)+M(bA,O(c8,bQ)))%2^32+O((bA-ds)/2^28+dv*2^4,dq*2^30+(bB-dt)/2^2,dr*2^25+(bB-du)/2^7)%2^32;bv=dh%2^32;bw=(cl+M(c9,bR)+M(bB,O(c9,bR))+(dh-bv)/2^32+O((bB-dv)/2^28+ds*2^4,dt*2^30+(bA-dq)/2^2,du*2^25+(bA-dr)/2^7))%2^32 end;bv=cw+bv;cw=bv%2^32;cE=(cE+bw+(bv-cw)/2^32)%2^32;bv=cx+bA;cx=bv%2^32;cF=(cF+bB+(bv-cx)/2^32)%2^32;bv=cy+bQ;cy=bv%2^32;cG=(cG+bR+(bv-cy)/2^32)%2^32;bv=cz+c8;cz=bv%2^32;cH=(cH+c9+(bv-cz)/2^32)%2^32;bv=cA+bF;cA=bv%2^32;cI=(cI+bG+(bv-cA)/2^32)%2^32;bv=cB+bJ;cB=bv%2^32;cJ=(cJ+bK+(bv-cB)/2^32)%2^32;bv=cC+bL;cC=bv%2^32;cK=(cK+bM+(bv-cC)/2^32)%2^32;bv=cD+ch;cD=bv%2^32;cL=(cL+ci+(bv-cD)/2^32)%2^32 end;cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]=cw,cx,cy,cz,cA,cB,cC,cD;cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]=cE,cF,cG,cH,cI,cJ,cK,cL end;if L==\"LIB32\"then function a1(aA,aB,aC,ax)local aD,aE,ai=al,ag,ai;local ba,bb,bc,bd=aA[1],aA[2],aA[3],aA[4]for aF=aC,aC+ax-1,64 do for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=((aI*256+aH)*256+E)*256+aG end;local aG,E,aH,aI=ba,bb,bc,bd;local dw=25;for az=1,16 do local dx=S(M(E,aH)+M(-1-E,aI)+aG+aE[az]+aD[az],dw)+E;dw=ai[dw]aG=aI;aI=aH;aH=E;E=dx end;dw=27;for az=17,32 do local dx=S(M(aI,E)+M(-1-aI,aH)+aG+aE[az]+aD[(5*az-4)%16+1],dw)+E;dw=ai[dw]aG=aI;aI=aH;aH=E;E=dx end;dw=28;for az=33,48 do local dx=S(O(O(E,aH),aI)+aG+aE[az]+aD[(3*az+2)%16+1],dw)+E;dw=ai[dw]aG=aI;aI=aH;aH=E;E=dx end;dw=26;for az=49,64 do local dx=S(O(aH,N(E,-1-aI))+aG+aE[az]+aD[(az*7-7)%16+1],dw)+E;dw=ai[dw]aG=aI;aI=aH;aH=E;E=dx end;ba=(aG+ba)%2^32;bb=(E+bb)%2^32;bc=(aH+bc)%2^32;bd=(aI+bd)%2^32 end;aA[1],aA[2],aA[3],aA[4]=ba,bb,bc,bd end end;function a2(aA,aB,aC,ax)local aD=al;local ba,bb,bc,bd,be=aA[1],aA[2],aA[3],aA[4],aA[5]for aF=aC,aC+ax-1,64 do for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=((aG*256+E)*256+aH)*256+aI end;for az=17,80 do local aG=O(aD[az-3],aD[az-8],aD[az-14],aD[az-16])%2^32*2;local E=aG%2^32;aD[az]=E+(aG-E)/2^32 end;local aG,E,aH,aI,aJ=ba,bb,bc,bd,be;for az=1,20 do local dy=aG*2^5;local aN=dy%2^32;aN=aN+(dy-aN)/2^32+M(E,aH)+M(-1-E,aI)+0x5A827999+aD[az]+aJ;aJ=aI;aI=aH;aH=E/2^2;aH=aH%1*(2^32-1)+aH;E=aG;aG=aN%2^32 end;for az=21,40 do local dy=aG*2^5;local aN=dy%2^32;aN=aN+(dy-aN)/2^32+O(E,aH,aI)+0x6ED9EBA1+aD[az]+aJ;aJ=aI;aI=aH;aH=E/2^2;aH=aH%1*(2^32-1)+aH;E=aG;aG=aN%2^32 end;for az=41,60 do local dy=aG*2^5;local aN=dy%2^32;aN=aN+(dy-aN)/2^32+M(aI,aH)+M(E,O(aI,aH))+0x8F1BBCDC+aD[az]+aJ;aJ=aI;aI=aH;aH=E/2^2;aH=aH%1*(2^32-1)+aH;E=aG;aG=aN%2^32 end;for az=61,80 do local dy=aG*2^5;local aN=dy%2^32;aN=aN+(dy-aN)/2^32+O(E,aH,aI)+0xCA62C1D6+aD[az]+aJ;aJ=aI;aI=aH;aH=E/2^2;aH=aH%1*(2^32-1)+aH;E=aG;aG=aN%2^32 end;ba=(aG+ba)%2^32;bb=(E+bb)%2^32;bc=(aH+bc)%2^32;bd=(aI+bd)%2^32;be=(aJ+be)%2^32 end;aA[1],aA[2],aA[3],aA[4],aA[5]=ba,bb,bc,bd,be end;function a3(c0,c1,aB,aC,ax,bl)local c2,c3=ab,ac;local bn=bl/8;for aF=aC,aC+ax-1,bl do for az=1,bn do local aG,E,aH,aI=c(aB,aF+1,aF+4)c0[az]=O(c0[az],((aI*256+aH)*256+E)*256+aG)aF=aF+8;aG,E,aH,aI=c(aB,aF-3,aF)c1[az]=O(c1[az],((aI*256+aH)*256+E)*256+aG)end;local dz,dA,dB,dC,dD,dE,dF,dG,dH,dI,dJ,dK,dL,dM,dN,dO,dP,dQ,dR,dS,dT,dU,dV,dW,dX,dY,dZ,d_,e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,ea,eb,ec,ed,ee,ef,eg,eh,ei,ej,ek,el=c0[1],c1[1],c0[2],c1[2],c0[3],c1[3],c0[4],c1[4],c0[5],c1[5],c0[6],c1[6],c0[7],c1[7],c0[8],c1[8],c0[9],c1[9],c0[10],c1[10],c0[11],c1[11],c0[12],c1[12],c0[13],c1[13],c0[14],c1[14],c0[15],c1[15],c0[16],c1[16],c0[17],c1[17],c0[18],c1[18],c0[19],c1[19],c0[20],c1[20],c0[21],c1[21],c0[22],c1[22],c0[23],c1[23],c0[24],c1[24],c0[25],c1[25]for bo=1,24 do local em=O(dz,dJ,dT,e2,ec)local en=O(dA,dK,dU,e3,ed)local eo=O(dB,dL,dV,e4,ee)local ep=O(dC,dM,dW,e5,ef)local eq=O(dD,dN,dX,e6,eg)local er=O(dE,dO,dY,e7,eh)local es=O(dF,dP,dZ,e8,ei)local et=O(dG,dQ,d_,e9,ej)local eu=O(dH,dR,e0,ea,ek)local ev=O(dI,dS,e1,eb,el)local c4=O(em,eq*2+(er%2^32-er%2^31)/2^31)local c5=O(en,er*2+(eq%2^32-eq%2^31)/2^31)local ew=O(c4,dB)local ex=O(c5,dC)local ey=O(c4,dL)local ez=O(c5,dM)local eA=O(c4,dV)local eB=O(c5,dW)local eC=O(c4,e4)local eD=O(c5,e5)local eE=O(c4,ee)local eF=O(c5,ef)dB=(ey%2^32-ey%2^20)/2^20+ez*2^12;dC=(ez%2^32-ez%2^20)/2^20+ey*2^12;dL=(eC%2^32-eC%2^19)/2^19+eD*2^13;dM=(eD%2^32-eD%2^19)/2^19+eC*2^13;dV=ew*2+(ex%2^32-ex%2^31)/2^31;dW=ex*2+(ew%2^32-ew%2^31)/2^31;e4=eA*2^10+(eB%2^32-eB%2^22)/2^22;e5=eB*2^10+(eA%2^32-eA%2^22)/2^22;ee=eE*2^2+(eF%2^32-eF%2^30)/2^30;ef=eF*2^2+(eE%2^32-eE%2^30)/2^30;c4=O(eo,es*2+(et%2^32-et%2^31)/2^31)c5=O(ep,et*2+(es%2^32-es%2^31)/2^31)ew=O(c4,dD)ex=O(c5,dE)ey=O(c4,dN)ez=O(c5,dO)eA=O(c4,dX)eB=O(c5,dY)eC=O(c4,e6)eD=O(c5,e7)eE=O(c4,eg)eF=O(c5,eh)dD=(eA%2^32-eA%2^21)/2^21+eB*2^11;dE=(eB%2^32-eB%2^21)/2^21+eA*2^11;dN=(eE%2^32-eE%2^3)/2^3+eF*2^29%2^32;dO=(eF%2^32-eF%2^3)/2^3+eE*2^29%2^32;dX=ey*2^6+(ez%2^32-ez%2^26)/2^26;dY=ez*2^6+(ey%2^32-ey%2^26)/2^26;e6=eC*2^15+(eD%2^32-eD%2^17)/2^17;e7=eD*2^15+(eC%2^32-eC%2^17)/2^17;eg=(ew%2^32-ew%2^2)/2^2+ex*2^30%2^32;eh=(ex%2^32-ex%2^2)/2^2+ew*2^30%2^32;c4=O(eq,eu*2+(ev%2^32-ev%2^31)/2^31)c5=O(er,ev*2+(eu%2^32-eu%2^31)/2^31)ew=O(c4,dF)ex=O(c5,dG)ey=O(c4,dP)ez=O(c5,dQ)eA=O(c4,dZ)eB=O(c5,d_)eC=O(c4,e8)eD=O(c5,e9)eE=O(c4,ei)eF=O(c5,ej)dF=eC*2^21%2^32+(eD%2^32-eD%2^11)/2^11;dG=eD*2^21%2^32+(eC%2^32-eC%2^11)/2^11;dP=ew*2^28%2^32+(ex%2^32-ex%2^4)/2^4;dQ=ex*2^28%2^32+(ew%2^32-ew%2^4)/2^4;dZ=eA*2^25%2^32+(eB%2^32-eB%2^7)/2^7;d_=eB*2^25%2^32+(eA%2^32-eA%2^7)/2^7;e8=(eE%2^32-eE%2^8)/2^8+eF*2^24%2^32;e9=(eF%2^32-eF%2^8)/2^8+eE*2^24%2^32;ei=(ey%2^32-ey%2^9)/2^9+ez*2^23%2^32;ej=(ez%2^32-ez%2^9)/2^9+ey*2^23%2^32;c4=O(es,em*2+(en%2^32-en%2^31)/2^31)c5=O(et,en*2+(em%2^32-em%2^31)/2^31)ew=O(c4,dH)ex=O(c5,dI)ey=O(c4,dR)ez=O(c5,dS)eA=O(c4,e0)eB=O(c5,e1)eC=O(c4,ea)eD=O(c5,eb)eE=O(c4,ek)eF=O(c5,el)dH=eE*2^14+(eF%2^32-eF%2^18)/2^18;dI=eF*2^14+(eE%2^32-eE%2^18)/2^18;dR=ey*2^20%2^32+(ez%2^32-ez%2^12)/2^12;dS=ez*2^20%2^32+(ey%2^32-ey%2^12)/2^12;e0=eC*2^8+(eD%2^32-eD%2^24)/2^24;e1=eD*2^8+(eC%2^32-eC%2^24)/2^24;ea=ew*2^27%2^32+(ex%2^32-ex%2^5)/2^5;eb=ex*2^27%2^32+(ew%2^32-ew%2^5)/2^5;ek=(eA%2^32-eA%2^25)/2^25+eB*2^7;el=(eB%2^32-eB%2^25)/2^25+eA*2^7;c4=O(eu,eo*2+(ep%2^32-ep%2^31)/2^31)c5=O(ev,ep*2+(eo%2^32-eo%2^31)/2^31)ey=O(c4,dJ)ez=O(c5,dK)eA=O(c4,dT)eB=O(c5,dU)eC=O(c4,e2)eD=O(c5,e3)eE=O(c4,ec)eF=O(c5,ed)dJ=eA*2^3+(eB%2^32-eB%2^29)/2^29;dK=eB*2^3+(eA%2^32-eA%2^29)/2^29;dT=eE*2^18+(eF%2^32-eF%2^14)/2^14;dU=eF*2^18+(eE%2^32-eE%2^14)/2^14;e2=(ey%2^32-ey%2^28)/2^28+ez*2^4;e3=(ez%2^32-ez%2^28)/2^28+ey*2^4;ec=(eC%2^32-eC%2^23)/2^23+eD*2^9;ed=(eD%2^32-eD%2^23)/2^23+eC*2^9;dz=O(c4,dz)dA=O(c5,dA)dz,dB,dD,dF,dH=O(dz,M(-1-dB,dD)),O(dB,M(-1-dD,dF)),O(dD,M(-1-dF,dH)),O(dF,M(-1-dH,dz)),O(dH,M(-1-dz,dB))dA,dC,dE,dG,dI=O(dA,M(-1-dC,dE)),O(dC,M(-1-dE,dG)),O(dE,M(-1-dG,dI)),O(dG,M(-1-dI,dA)),O(dI,M(-1-dA,dC))dJ,dL,dN,dP,dR=O(dP,M(-1-dR,dJ)),O(dR,M(-1-dJ,dL)),O(dJ,M(-1-dL,dN)),O(dL,M(-1-dN,dP)),O(dN,M(-1-dP,dR))dK,dM,dO,dQ,dS=O(dQ,M(-1-dS,dK)),O(dS,M(-1-dK,dM)),O(dK,M(-1-dM,dO)),O(dM,M(-1-dO,dQ)),O(dO,M(-1-dQ,dS))dT,dV,dX,dZ,e0=O(dV,M(-1-dX,dZ)),O(dX,M(-1-dZ,e0)),O(dZ,M(-1-e0,dT)),O(e0,M(-1-dT,dV)),O(dT,M(-1-dV,dX))dU,dW,dY,d_,e1=O(dW,M(-1-dY,d_)),O(dY,M(-1-d_,e1)),O(d_,M(-1-e1,dU)),O(e1,M(-1-dU,dW)),O(dU,M(-1-dW,dY))e2,e4,e6,e8,ea=O(ea,M(-1-e2,e4)),O(e2,M(-1-e4,e6)),O(e4,M(-1-e6,e8)),O(e6,M(-1-e8,ea)),O(e8,M(-1-ea,e2))e3,e5,e7,e9,eb=O(eb,M(-1-e3,e5)),O(e3,M(-1-e5,e7)),O(e5,M(-1-e7,e9)),O(e7,M(-1-e9,eb)),O(e9,M(-1-eb,e3))ec,ee,eg,ei,ek=O(eg,M(-1-ei,ek)),O(ei,M(-1-ek,ec)),O(ek,M(-1-ec,ee)),O(ec,M(-1-ee,eg)),O(ee,M(-1-eg,ei))ed,ef,eh,ej,el=O(eh,M(-1-ej,el)),O(ej,M(-1-el,ed)),O(el,M(-1-ed,ef)),O(ed,M(-1-ef,eh)),O(ef,M(-1-eh,ej))dz=O(dz,c2[bo])dA=dA+c3[bo]end;c0[1]=dz;c1[1]=dA;c0[2]=dB;c1[2]=dC;c0[3]=dD;c1[3]=dE;c0[4]=dF;c1[4]=dG;c0[5]=dH;c1[5]=dI;c0[6]=dJ;c1[6]=dK;c0[7]=dL;c1[7]=dM;c0[8]=dN;c1[8]=dO;c0[9]=dP;c1[9]=dQ;c0[10]=dR;c1[10]=dS;c0[11]=dT;c1[11]=dU;c0[12]=dV;c1[12]=dW;c0[13]=dX;c1[13]=dY;c0[14]=dZ;c1[14]=d_;c0[15]=e0;c1[15]=e1;c0[16]=e2;c1[16]=e3;c0[17]=e4;c1[17]=e5;c0[18]=e6;c1[18]=e7;c0[19]=e8;c1[19]=e9;c0[20]=ea;c1[20]=eb;c0[21]=ec;c1[21]=ed;c0[22]=ee;c1[22]=ef;c0[23]=eg;c1[23]=eh;c0[24]=ei;c1[24]=ej;c0[25]=ek;c1[25]=el end end;function a4(aA,aB,aC,ax,b7,b8,b9)local aD=al;local ba,bb,bc,bd,be,bf,bg,bh=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for aF=aC,aC+ax-1,64 do if aB then for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=((aI*256+aH)*256+E)*256+aG end end;local eG,eH,eI,eJ,eK,eL,eM,eN=ba,bb,bc,bd,be,bf,bg,bh;local eO,eP,eQ,eR,eS,eT,eU,eV=aa[1],aa[2],aa[3],aa[4],aa[5],aa[6],aa[7],aa[8]b7=b7+(b8 or 64)local cO=b7%2^32;local cP=(b7-cO)/2^32;eS=O(eS,cO)eT=O(eT,cP)if b8 then eU=-1-eU end;if b9 then eV=-1-eV end;for az=1,10 do local bi=as[az]eG=eG+eK+aD[bi[1]]eS=O(eS,eG)%2^32/2^16;eS=eS%1*(2^32-1)+eS;eO=eO+eS;eK=O(eK,eO)%2^32/2^12;eK=eK%1*(2^32-1)+eK;eG=eG+eK+aD[bi[2]]eS=O(eS,eG)%2^32/2^8;eS=eS%1*(2^32-1)+eS;eO=eO+eS;eK=O(eK,eO)%2^32/2^7;eK=eK%1*(2^32-1)+eK;eH=eH+eL+aD[bi[3]]eT=O(eT,eH)%2^32/2^16;eT=eT%1*(2^32-1)+eT;eP=eP+eT;eL=O(eL,eP)%2^32/2^12;eL=eL%1*(2^32-1)+eL;eH=eH+eL+aD[bi[4]]eT=O(eT,eH)%2^32/2^8;eT=eT%1*(2^32-1)+eT;eP=eP+eT;eL=O(eL,eP)%2^32/2^7;eL=eL%1*(2^32-1)+eL;eI=eI+eM+aD[bi[5]]eU=O(eU,eI)%2^32/2^16;eU=eU%1*(2^32-1)+eU;eQ=eQ+eU;eM=O(eM,eQ)%2^32/2^12;eM=eM%1*(2^32-1)+eM;eI=eI+eM+aD[bi[6]]eU=O(eU,eI)%2^32/2^8;eU=eU%1*(2^32-1)+eU;eQ=eQ+eU;eM=O(eM,eQ)%2^32/2^7;eM=eM%1*(2^32-1)+eM;eJ=eJ+eN+aD[bi[7]]eV=O(eV,eJ)%2^32/2^16;eV=eV%1*(2^32-1)+eV;eR=eR+eV;eN=O(eN,eR)%2^32/2^12;eN=eN%1*(2^32-1)+eN;eJ=eJ+eN+aD[bi[8]]eV=O(eV,eJ)%2^32/2^8;eV=eV%1*(2^32-1)+eV;eR=eR+eV;eN=O(eN,eR)%2^32/2^7;eN=eN%1*(2^32-1)+eN;eG=eG+eL+aD[bi[9]]eV=O(eV,eG)%2^32/2^16;eV=eV%1*(2^32-1)+eV;eQ=eQ+eV;eL=O(eL,eQ)%2^32/2^12;eL=eL%1*(2^32-1)+eL;eG=eG+eL+aD[bi[10]]eV=O(eV,eG)%2^32/2^8;eV=eV%1*(2^32-1)+eV;eQ=eQ+eV;eL=O(eL,eQ)%2^32/2^7;eL=eL%1*(2^32-1)+eL;eH=eH+eM+aD[bi[11]]eS=O(eS,eH)%2^32/2^16;eS=eS%1*(2^32-1)+eS;eR=eR+eS;eM=O(eM,eR)%2^32/2^12;eM=eM%1*(2^32-1)+eM;eH=eH+eM+aD[bi[12]]eS=O(eS,eH)%2^32/2^8;eS=eS%1*(2^32-1)+eS;eR=eR+eS;eM=O(eM,eR)%2^32/2^7;eM=eM%1*(2^32-1)+eM;eI=eI+eN+aD[bi[13]]eT=O(eT,eI)%2^32/2^16;eT=eT%1*(2^32-1)+eT;eO=eO+eT;eN=O(eN,eO)%2^32/2^12;eN=eN%1*(2^32-1)+eN;eI=eI+eN+aD[bi[14]]eT=O(eT,eI)%2^32/2^8;eT=eT%1*(2^32-1)+eT;eO=eO+eT;eN=O(eN,eO)%2^32/2^7;eN=eN%1*(2^32-1)+eN;eJ=eJ+eK+aD[bi[15]]eU=O(eU,eJ)%2^32/2^16;eU=eU%1*(2^32-1)+eU;eP=eP+eU;eK=O(eK,eP)%2^32/2^12;eK=eK%1*(2^32-1)+eK;eJ=eJ+eK+aD[bi[16]]eU=O(eU,eJ)%2^32/2^8;eU=eU%1*(2^32-1)+eU;eP=eP+eU;eK=O(eK,eP)%2^32/2^7;eK=eK%1*(2^32-1)+eK end;ba=O(ba,eG,eO)bb=O(bb,eH,eP)bc=O(bc,eI,eQ)bd=O(bd,eJ,eR)be=O(be,eK,eS)bf=O(bf,eL,eT)bg=O(bg,eM,eU)bh=O(bh,eN,eV)end;aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]=ba,bb,bc,bd,be,bf,bg,bh;return b7 end;function a5(cc,cd,aB,aC,ax,b7,b8,b9)local aD=al;local cw,cx,cy,cz,cA,cB,cC,cD=cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]local cE,cF,cG,cH,cI,cJ,cK,cL=cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]for aF=aC,aC+ax-1,128 do if aB then for az=1,32 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=((aI*256+aH)*256+E)*256+aG end end;local eW,eX,eY,eZ,e_,f0,f1,f2=cw,cx,cy,cz,cA,cB,cC,cD;local f3,f4,f5,f6,f7,f8,f9,fa=cE,cF,cG,cH,cI,cJ,cK,cL;local fb,fc,fd,fe,ff,fg,fh,fi=a9[1],a9[2],a9[3],a9[4],a9[5],a9[6],a9[7],a9[8]local fj,fk,fl,fm,fn,fo,fp,fq=aa[1],aa[2],aa[3],aa[4],aa[5],aa[6],aa[7],aa[8]b7=b7+(b8 or 128)local cM=b7%2^32;local cN=(b7-cM)/2^32;ff=O(ff,cM)fn=O(fn,cN)if b8 then fh=-1-fh;fp=-1-fp end;if b9 then fi=-1-fi;fq=-1-fq end;for az=1,12 do local bi=as[az]local q=bi[1]*2;local aN=eW%2^32+e_%2^32+aD[q-1]eW=aN%2^32;f3=f3+f7+(aN-eW)/2^32+aD[q]ff,fn=O(fn,f3),O(ff,eW)aN=fb%2^32+ff%2^32;fb=aN%2^32;fj=fj+fn+(aN-fb)/2^32;e_,f7=O(e_,fb),O(f7,fj)local ck,cl=e_%2^24,f7%2^24;e_,f7=(e_-ck)/2^24%2^8+cl*2^8,(f7-cl)/2^24%2^8+ck*2^8;q=bi[2]*2;aN=eW%2^32+e_%2^32+aD[q-1]eW=aN%2^32;f3=f3+f7+(aN-eW)/2^32+aD[q]ff,fn=O(ff,eW),O(fn,f3)ck,cl=ff%2^16,fn%2^16;ff,fn=(ff-ck)/2^16%2^16+cl*2^16,(fn-cl)/2^16%2^16+ck*2^16;aN=fb%2^32+ff%2^32;fb=aN%2^32;fj=fj+fn+(aN-fb)/2^32;e_,f7=O(e_,fb),O(f7,fj)ck,cl=e_%2^31,f7%2^31;e_,f7=ck*2^1+(f7-cl)/2^31%2^1,cl*2^1+(e_-ck)/2^31%2^1;q=bi[3]*2;aN=eX%2^32+f0%2^32+aD[q-1]eX=aN%2^32;f4=f4+f8+(aN-eX)/2^32+aD[q]fg,fo=O(fo,f4),O(fg,eX)aN=fc%2^32+fg%2^32;fc=aN%2^32;fk=fk+fo+(aN-fc)/2^32;f0,f8=O(f0,fc),O(f8,fk)ck,cl=f0%2^24,f8%2^24;f0,f8=(f0-ck)/2^24%2^8+cl*2^8,(f8-cl)/2^24%2^8+ck*2^8;q=bi[4]*2;aN=eX%2^32+f0%2^32+aD[q-1]eX=aN%2^32;f4=f4+f8+(aN-eX)/2^32+aD[q]fg,fo=O(fg,eX),O(fo,f4)ck,cl=fg%2^16,fo%2^16;fg,fo=(fg-ck)/2^16%2^16+cl*2^16,(fo-cl)/2^16%2^16+ck*2^16;aN=fc%2^32+fg%2^32;fc=aN%2^32;fk=fk+fo+(aN-fc)/2^32;f0,f8=O(f0,fc),O(f8,fk)ck,cl=f0%2^31,f8%2^31;f0,f8=ck*2^1+(f8-cl)/2^31%2^1,cl*2^1+(f0-ck)/2^31%2^1;q=bi[5]*2;aN=eY%2^32+f1%2^32+aD[q-1]eY=aN%2^32;f5=f5+f9+(aN-eY)/2^32+aD[q]fh,fp=O(fp,f5),O(fh,eY)aN=fd%2^32+fh%2^32;fd=aN%2^32;fl=fl+fp+(aN-fd)/2^32;f1,f9=O(f1,fd),O(f9,fl)ck,cl=f1%2^24,f9%2^24;f1,f9=(f1-ck)/2^24%2^8+cl*2^8,(f9-cl)/2^24%2^8+ck*2^8;q=bi[6]*2;aN=eY%2^32+f1%2^32+aD[q-1]eY=aN%2^32;f5=f5+f9+(aN-eY)/2^32+aD[q]fh,fp=O(fh,eY),O(fp,f5)ck,cl=fh%2^16,fp%2^16;fh,fp=(fh-ck)/2^16%2^16+cl*2^16,(fp-cl)/2^16%2^16+ck*2^16;aN=fd%2^32+fh%2^32;fd=aN%2^32;fl=fl+fp+(aN-fd)/2^32;f1,f9=O(f1,fd),O(f9,fl)ck,cl=f1%2^31,f9%2^31;f1,f9=ck*2^1+(f9-cl)/2^31%2^1,cl*2^1+(f1-ck)/2^31%2^1;q=bi[7]*2;aN=eZ%2^32+f2%2^32+aD[q-1]eZ=aN%2^32;f6=f6+fa+(aN-eZ)/2^32+aD[q]fi,fq=O(fq,f6),O(fi,eZ)aN=fe%2^32+fi%2^32;fe=aN%2^32;fm=fm+fq+(aN-fe)/2^32;f2,fa=O(f2,fe),O(fa,fm)ck,cl=f2%2^24,fa%2^24;f2,fa=(f2-ck)/2^24%2^8+cl*2^8,(fa-cl)/2^24%2^8+ck*2^8;q=bi[8]*2;aN=eZ%2^32+f2%2^32+aD[q-1]eZ=aN%2^32;f6=f6+fa+(aN-eZ)/2^32+aD[q]fi,fq=O(fi,eZ),O(fq,f6)ck,cl=fi%2^16,fq%2^16;fi,fq=(fi-ck)/2^16%2^16+cl*2^16,(fq-cl)/2^16%2^16+ck*2^16;aN=fe%2^32+fi%2^32;fe=aN%2^32;fm=fm+fq+(aN-fe)/2^32;f2,fa=O(f2,fe),O(fa,fm)ck,cl=f2%2^31,fa%2^31;f2,fa=ck*2^1+(fa-cl)/2^31%2^1,cl*2^1+(f2-ck)/2^31%2^1;q=bi[9]*2;aN=eW%2^32+f0%2^32+aD[q-1]eW=aN%2^32;f3=f3+f8+(aN-eW)/2^32+aD[q]fi,fq=O(fq,f3),O(fi,eW)aN=fd%2^32+fi%2^32;fd=aN%2^32;fl=fl+fq+(aN-fd)/2^32;f0,f8=O(f0,fd),O(f8,fl)ck,cl=f0%2^24,f8%2^24;f0,f8=(f0-ck)/2^24%2^8+cl*2^8,(f8-cl)/2^24%2^8+ck*2^8;q=bi[10]*2;aN=eW%2^32+f0%2^32+aD[q-1]eW=aN%2^32;f3=f3+f8+(aN-eW)/2^32+aD[q]fi,fq=O(fi,eW),O(fq,f3)ck,cl=fi%2^16,fq%2^16;fi,fq=(fi-ck)/2^16%2^16+cl*2^16,(fq-cl)/2^16%2^16+ck*2^16;aN=fd%2^32+fi%2^32;fd=aN%2^32;fl=fl+fq+(aN-fd)/2^32;f0,f8=O(f0,fd),O(f8,fl)ck,cl=f0%2^31,f8%2^31;f0,f8=ck*2^1+(f8-cl)/2^31%2^1,cl*2^1+(f0-ck)/2^31%2^1;q=bi[11]*2;aN=eX%2^32+f1%2^32+aD[q-1]eX=aN%2^32;f4=f4+f9+(aN-eX)/2^32+aD[q]ff,fn=O(fn,f4),O(ff,eX)aN=fe%2^32+ff%2^32;fe=aN%2^32;fm=fm+fn+(aN-fe)/2^32;f1,f9=O(f1,fe),O(f9,fm)ck,cl=f1%2^24,f9%2^24;f1,f9=(f1-ck)/2^24%2^8+cl*2^8,(f9-cl)/2^24%2^8+ck*2^8;q=bi[12]*2;aN=eX%2^32+f1%2^32+aD[q-1]eX=aN%2^32;f4=f4+f9+(aN-eX)/2^32+aD[q]ff,fn=O(ff,eX),O(fn,f4)ck,cl=ff%2^16,fn%2^16;ff,fn=(ff-ck)/2^16%2^16+cl*2^16,(fn-cl)/2^16%2^16+ck*2^16;aN=fe%2^32+ff%2^32;fe=aN%2^32;fm=fm+fn+(aN-fe)/2^32;f1,f9=O(f1,fe),O(f9,fm)ck,cl=f1%2^31,f9%2^31;f1,f9=ck*2^1+(f9-cl)/2^31%2^1,cl*2^1+(f1-ck)/2^31%2^1;q=bi[13]*2;aN=eY%2^32+f2%2^32+aD[q-1]eY=aN%2^32;f5=f5+fa+(aN-eY)/2^32+aD[q]fg,fo=O(fo,f5),O(fg,eY)aN=fb%2^32+fg%2^32;fb=aN%2^32;fj=fj+fo+(aN-fb)/2^32;f2,fa=O(f2,fb),O(fa,fj)ck,cl=f2%2^24,fa%2^24;f2,fa=(f2-ck)/2^24%2^8+cl*2^8,(fa-cl)/2^24%2^8+ck*2^8;q=bi[14]*2;aN=eY%2^32+f2%2^32+aD[q-1]eY=aN%2^32;f5=f5+fa+(aN-eY)/2^32+aD[q]fg,fo=O(fg,eY),O(fo,f5)ck,cl=fg%2^16,fo%2^16;fg,fo=(fg-ck)/2^16%2^16+cl*2^16,(fo-cl)/2^16%2^16+ck*2^16;aN=fb%2^32+fg%2^32;fb=aN%2^32;fj=fj+fo+(aN-fb)/2^32;f2,fa=O(f2,fb),O(fa,fj)ck,cl=f2%2^31,fa%2^31;f2,fa=ck*2^1+(fa-cl)/2^31%2^1,cl*2^1+(f2-ck)/2^31%2^1;q=bi[15]*2;aN=eZ%2^32+e_%2^32+aD[q-1]eZ=aN%2^32;f6=f6+f7+(aN-eZ)/2^32+aD[q]fh,fp=O(fp,f6),O(fh,eZ)aN=fc%2^32+fh%2^32;fc=aN%2^32;fk=fk+fp+(aN-fc)/2^32;e_,f7=O(e_,fc),O(f7,fk)ck,cl=e_%2^24,f7%2^24;e_,f7=(e_-ck)/2^24%2^8+cl*2^8,(f7-cl)/2^24%2^8+ck*2^8;q=bi[16]*2;aN=eZ%2^32+e_%2^32+aD[q-1]eZ=aN%2^32;f6=f6+f7+(aN-eZ)/2^32+aD[q]fh,fp=O(fh,eZ),O(fp,f6)ck,cl=fh%2^16,fp%2^16;fh,fp=(fh-ck)/2^16%2^16+cl*2^16,(fp-cl)/2^16%2^16+ck*2^16;aN=fc%2^32+fh%2^32;fc=aN%2^32;fk=fk+fp+(aN-fc)/2^32;e_,f7=O(e_,fc),O(f7,fk)ck,cl=e_%2^31,f7%2^31;e_,f7=ck*2^1+(f7-cl)/2^31%2^1,cl*2^1+(e_-ck)/2^31%2^1 end;cw=O(cw,eW,fb)%2^32;cx=O(cx,eX,fc)%2^32;cy=O(cy,eY,fd)%2^32;cz=O(cz,eZ,fe)%2^32;cA=O(cA,e_,ff)%2^32;cB=O(cB,f0,fg)%2^32;cC=O(cC,f1,fh)%2^32;cD=O(cD,f2,fi)%2^32;cE=O(cE,f3,fj)%2^32;cF=O(cF,f4,fk)%2^32;cG=O(cG,f5,fl)%2^32;cH=O(cH,f6,fm)%2^32;cI=O(cI,f7,fn)%2^32;cJ=O(cJ,f8,fo)%2^32;cK=O(cK,f9,fp)%2^32;cL=O(cL,fa,fq)%2^32 end;cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]=cw,cx,cy,cz,cA,cB,cC,cD;cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]=cE,cF,cG,cH,cI,cJ,cK,cL;return b7 end;function a6(aB,aC,ax,cQ,cR,cS,cT,cU,cV)cV=cV or 64;local aD=al;local ba,bb,bc,bd,be,bf,bg,bh=cS[1],cS[2],cS[3],cS[4],cS[5],cS[6],cS[7],cS[8]cT=cT or cS;for aF=aC,aC+ax-1,64 do if aB then for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=((aI*256+aH)*256+E)*256+aG end end;local eG,eH,eI,eJ,eK,eL,eM,eN=ba,bb,bc,bd,be,bf,bg,bh;local eO,eP,eQ,eR=aa[1],aa[2],aa[3],aa[4]local eS=cR%2^32;local eT=(cR-eS)/2^32;local eU,eV=cV,cQ;for az=1,7 do eG=eG+eK+aD[at[az]]eS=O(eS,eG)%2^32/2^16;eS=eS%1*(2^32-1)+eS;eO=eO+eS;eK=O(eK,eO)%2^32/2^12;eK=eK%1*(2^32-1)+eK;eG=eG+eK+aD[at[az+14]]eS=O(eS,eG)%2^32/2^8;eS=eS%1*(2^32-1)+eS;eO=eO+eS;eK=O(eK,eO)%2^32/2^7;eK=eK%1*(2^32-1)+eK;eH=eH+eL+aD[at[az+1]]eT=O(eT,eH)%2^32/2^16;eT=eT%1*(2^32-1)+eT;eP=eP+eT;eL=O(eL,eP)%2^32/2^12;eL=eL%1*(2^32-1)+eL;eH=eH+eL+aD[at[az+2]]eT=O(eT,eH)%2^32/2^8;eT=eT%1*(2^32-1)+eT;eP=eP+eT;eL=O(eL,eP)%2^32/2^7;eL=eL%1*(2^32-1)+eL;eI=eI+eM+aD[at[az+16]]eU=O(eU,eI)%2^32/2^16;eU=eU%1*(2^32-1)+eU;eQ=eQ+eU;eM=O(eM,eQ)%2^32/2^12;eM=eM%1*(2^32-1)+eM;eI=eI+eM+aD[at[az+7]]eU=O(eU,eI)%2^32/2^8;eU=eU%1*(2^32-1)+eU;eQ=eQ+eU;eM=O(eM,eQ)%2^32/2^7;eM=eM%1*(2^32-1)+eM;eJ=eJ+eN+aD[at[az+15]]eV=O(eV,eJ)%2^32/2^16;eV=eV%1*(2^32-1)+eV;eR=eR+eV;eN=O(eN,eR)%2^32/2^12;eN=eN%1*(2^32-1)+eN;eJ=eJ+eN+aD[at[az+17]]eV=O(eV,eJ)%2^32/2^8;eV=eV%1*(2^32-1)+eV;eR=eR+eV;eN=O(eN,eR)%2^32/2^7;eN=eN%1*(2^32-1)+eN;eG=eG+eL+aD[at[az+21]]eV=O(eV,eG)%2^32/2^16;eV=eV%1*(2^32-1)+eV;eQ=eQ+eV;eL=O(eL,eQ)%2^32/2^12;eL=eL%1*(2^32-1)+eL;eG=eG+eL+aD[at[az+5]]eV=O(eV,eG)%2^32/2^8;eV=eV%1*(2^32-1)+eV;eQ=eQ+eV;eL=O(eL,eQ)%2^32/2^7;eL=eL%1*(2^32-1)+eL;eH=eH+eM+aD[at[az+3]]eS=O(eS,eH)%2^32/2^16;eS=eS%1*(2^32-1)+eS;eR=eR+eS;eM=O(eM,eR)%2^32/2^12;eM=eM%1*(2^32-1)+eM;eH=eH+eM+aD[at[az+6]]eS=O(eS,eH)%2^32/2^8;eS=eS%1*(2^32-1)+eS;eR=eR+eS;eM=O(eM,eR)%2^32/2^7;eM=eM%1*(2^32-1)+eM;eI=eI+eN+aD[at[az+4]]eT=O(eT,eI)%2^32/2^16;eT=eT%1*(2^32-1)+eT;eO=eO+eT;eN=O(eN,eO)%2^32/2^12;eN=eN%1*(2^32-1)+eN;eI=eI+eN+aD[at[az+18]]eT=O(eT,eI)%2^32/2^8;eT=eT%1*(2^32-1)+eT;eO=eO+eT;eN=O(eN,eO)%2^32/2^7;eN=eN%1*(2^32-1)+eN;eJ=eJ+eK+aD[at[az+19]]eU=O(eU,eJ)%2^32/2^16;eU=eU%1*(2^32-1)+eU;eP=eP+eU;eK=O(eK,eP)%2^32/2^12;eK=eK%1*(2^32-1)+eK;eJ=eJ+eK+aD[at[az+20]]eU=O(eU,eJ)%2^32/2^8;eU=eU%1*(2^32-1)+eU;eP=eP+eU;eK=O(eK,eP)%2^32/2^7;eK=eK%1*(2^32-1)+eK end;if cU then cT[9]=O(ba,eO)cT[10]=O(bb,eP)cT[11]=O(bc,eQ)cT[12]=O(bd,eR)cT[13]=O(be,eS)cT[14]=O(bf,eT)cT[15]=O(bg,eU)cT[16]=O(bh,eV)end;ba=O(eG,eO)bb=O(eH,eP)bc=O(eI,eQ)bd=O(eJ,eR)be=O(eK,eS)bf=O(eL,eT)bg=O(eM,eU)bh=O(eN,eV)end;cT[1],cT[2],cT[3],cT[4],cT[5],cT[6],cT[7],cT[8]=ba,bb,bc,bd,be,bf,bg,bh end end;do local function fr(fs,ft,fu,fv)local H,fw,fx,fy={},0.0,0.0,1.0;for az=1,fv do for q=m(1,az+1-#ft),l(az,#fs)do fw=fw+fu*fs[q]*ft[az+1-q]end;local fz=fw%2^24;H[az]=j(fz)fw=(fw-fz)/2^24;fx=fx+fz*fy;fy=fy*2^24 end;return H,fx end;local fA,fB,fC,p,fD,fE=0,{4,1,2,-2,2},4,{1},aa,a9;repeat fC=fC+fB[fC%6]local aI=1;repeat aI=aI+fB[aI%6]if aI*aI>fC then local fF=fC^(1/3)local fG=fF*2^40;fG=fr({fG-fG%1},p,1.0,2)local I,fH=fr(fG,fr(fG,fG,1.0,4),-1.0,4)local fI=fG[2]%65536*65536+j(fG[1]/256)local fJ=fG[1]%256*16777216+j(fH*2^-56/3*fF/fC)if fA<16 then fF=fC^(1/2)fG=fF*2^40;fG=fr({fG-fG%1},p,1.0,2)I,fH=fr(fG,fG,-1.0,2)local fI=fG[2]%65536*65536+j(fG[1]/256)local fJ=fG[1]%256*16777216+j(fH*2^-17/fF)local fA=fA%8+1;ad[224][fA]=fJ;fD[fA],fE[fA]=fI,fJ+fI*aq;if fA>7 then fD,fE=af[384],ae[384]end end;fA=fA+1;a8[fA],a7[fA]=fI,fJ%ap+fI*aq;break end until fC%aI==0 until fA>79 end;for fK=224,256,32 do local cc,cd={}if aj then for az=1,8 do cc[az]=X(a9[az])end else cd={}for az=1,8 do cc[az]=X(a9[az])cd[az]=X(aa[az])end end;a0(cc,cd,\"SHA-512/\"..tostring(fK)..\"\\128\"..e(\"\\0\",115)..\"\\88\",0,128)ae[fK]=cc;af[fK]=cd end;do local fL,fM,fN=math.sin,math.abs,math.modf;for fA=1,64 do local fI,fJ=fN(fM(fL(fA))*2^16)ag[fA]=fI*65536+j(fJ*2^16)end end;do local fO=29;local function fP()local fQ=fO%2;fO=W((fO-fQ)/2,142*fQ)return fQ end;for fA=1,24 do local fJ,s=0;for I=1,6 do s=s and s*s*2 or 1;fJ=fJ+fP()*s end;local fI=fP()*s;ac[fA],ab[fA]=fI,fJ+fI*ar end end;if L==\"FFI\"then a8=D.new(\"uint32_t[?]\",#a8+1,0,unpack(a8))a7=D.new(\"int64_t[?]\",#a7+1,0,unpack(a7))if ar==0 then ab=D.new(\"uint32_t[?]\",#ab+1,0,unpack(ab))ac=D.new(\"uint32_t[?]\",#ac+1,0,unpack(ac))else ab=D.new(\"int64_t[?]\",#ab+1,0,unpack(ab))end end;local function fR(fK,fS)local aA,fT,fU={unpack(ad[fK])},0.0,\"\"local function fV(fW)if fW then if fU then fT=fT+#fW;local aC=0;if fU~=\"\"and#fU+#fW>=64 then aC=64-#fU;_(aA,fU..f(fW,1,aC),0,64)fU=\"\"end;local ax=#fW-aC;local fX=ax%64;_(aA,fW,aC,ax-fX)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then local fY={fU,\"\\128\",e(\"\\0\",(-9-fT)%64+1)}fU=nil;fT=fT*8/256^7;for az=4,10 do fT=fT%1*256;fY[az]=d(j(fT))end;fY=b(fY)_(aA,fY,0,#fY)local fZ=fK/32;for az=1,fZ do aA[az]=V(aA[az])end;aA=b(aA,\"\",1,fZ)end;return aA end end;if fS then return fV(fS)()else return fV end end;local function f_(fK,fS)local fT,fU,cc,cd=0.0,\"\",{unpack(ae[fK])},not aj and{unpack(af[fK])}local function fV(fW)if fW then if fU then fT=fT+#fW;local aC=0;if fU~=\"\"and#fU+#fW>=128 then aC=128-#fU;a0(cc,cd,fU..f(fW,1,aC),0,128)fU=\"\"end;local ax=#fW-aC;local fX=ax%128;a0(cc,cd,fW,aC,ax-fX)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then local fY={fU,\"\\128\",e(\"\\0\",(-17-fT)%128+9)}fU=nil;fT=fT*8/256^7;for az=4,10 do fT=fT%1*256;fY[az]=d(j(fT))end;fY=b(fY)a0(cc,cd,fY,0,#fY)local fZ=k(fK/64)if aj then for az=1,fZ do cc[az]=aj(cc[az])end else for az=1,fZ do cc[az]=V(cd[az])..V(cc[az])end;cd=nil end;cc=f(b(cc,\"\",1,fZ),1,fK/4)end;return cc end end;if fS then return fV(fS)()else return fV end end;local function g0(fS)local aA,fT,fU={unpack(ah,1,4)},0.0,\"\"local function fV(fW)if fW then if fU then fT=fT+#fW;local aC=0;if fU~=\"\"and#fU+#fW>=64 then aC=64-#fU;a1(aA,fU..f(fW,1,aC),0,64)fU=\"\"end;local ax=#fW-aC;local fX=ax%64;a1(aA,fW,aC,ax-fX)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then local fY={fU,\"\\128\",e(\"\\0\",(-9-fT)%64)}fU=nil;fT=fT*8;for az=4,11 do local g1=fT%256;fY[az]=d(g1)fT=(fT-g1)/256 end;fY=b(fY)a1(aA,fY,0,#fY)for az=1,4 do aA[az]=V(aA[az])end;aA=g(b(aA),\"(..)(..)(..)(..)\",\"%4%3%2%1\")end;return aA end end;if fS then return fV(fS)()else return fV end end;local function g2(fS)local aA,fT,fU={unpack(ah)},0.0,\"\"local function fV(fW)if fW then if fU then fT=fT+#fW;local aC=0;if fU~=\"\"and#fU+#fW>=64 then aC=64-#fU;a2(aA,fU..f(fW,1,aC),0,64)fU=\"\"end;local ax=#fW-aC;local fX=ax%64;a2(aA,fW,aC,ax-fX)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then local fY={fU,\"\\128\",e(\"\\0\",(-9-fT)%64+1)}fU=nil;fT=fT*8/256^7;for az=4,10 do fT=fT%1*256;fY[az]=d(j(fT))end;fY=b(fY)a2(aA,fY,0,#fY)for az=1,5 do aA[az]=V(aA[az])end;aA=b(aA)end;return aA end end;if fS then return fV(fS)()else return fV end end;local function g3(bl,g4,g5,fS)if type(g4)~=\"number\"then error(\"Argument 'digest_size_in_bytes' must be a number\",2)end;local fU,c0,c1=\"\",Z(),ar==0 and Z()local H;local function fV(fW)if fW then if fU then local aC=0;if fU~=\"\"and#fU+#fW>=bl then aC=bl-#fU;a3(c0,c1,fU..f(fW,1,aC),0,bl,bl)fU=\"\"end;local ax=#fW-aC;local fX=ax%bl;a3(c0,c1,fW,aC,ax-fX,bl)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then local g6=g5 and 31 or 6;fU=fU..(#fU+1==bl and d(g6+128)or d(g6)..e(\"\\0\",(-2-#fU)%bl)..\"\\128\")a3(c0,c1,fU,0,#fU,bl)fU=nil;local g7=0;local g8=j(bl/8)local g9={}local function ga(bn)if g7>=g8 then a3(c0,c1,\"\\0\\0\\0\\0\\0\\0\\0\\0\",0,8,8)g7=0 end;bn=j(l(bn,g8-g7))if ar~=0 then for az=1,bn do g9[az]=aj(c0[g7+az-1+ak])end else for az=1,bn do g9[az]=V(c1[g7+az])..V(c0[g7+az])end end;g7=g7+bn;return g(b(g9,\"\",1,bn),\"(..)(..)(..)(..)(..)(..)(..)(..)\",\"%8%7%6%5%4%3%2%1\"),bn*8 end;local gb={}local gc,gd=\"\",0;local function ge(gf)gf=gf or 1;if gf<=gd then gd=gd-gf;local gg=gf*2;local H=f(gc,1,gg)gc=f(gc,gg+1)return H end;local gh=0;if gd>0 then gh=1;gb[gh]=gc;gf=gf-gd end;while gf>=8 do local gi,gj=ga(gf/8)gh=gh+1;gb[gh]=gi;gf=gf-gj end;if gf>0 then gc,gd=ga(1)gh=gh+1;gb[gh]=ge(gf)else gc,gd=\"\",0 end;return b(gb,\"\",1,gh)end;if g4<0 then H=ge else H=ge(g4)end end;return H end end;if fS then return fV(fS)()else return fV end end;local gk,gl,gm,gn;do function gk(go)return g(go,\"%x%x\",function(gp)return d(tonumber(gp,16))end)end;function gl(gq)return g(gq,\".\",function(aH)return i(\"%02x\",c(aH))end)end;local gr={['+']=62,['-']=62,[62]='+',['/']=63,['_']=63,[63]='/',['=']=-1,['.']=-1,[-1]='='}local gs=0;for az,gt in ipairs{'AZ','az','09'}do for gu=c(gt),c(gt,2)do local gv=d(gu)gr[gv]=gs;gr[gs]=gv;gs=gs+1 end end;function gm(gq)local H={}for aF=1,#gq,3 do local gw,gx,gy,gz=c(f(gq,aF,aF+2)..'\\0',1,-1)H[#H+1]=gr[j(gw/4)]..gr[gw%4*16+j(gx/16)]..gr[gy and gx%16*4+j(gy/64)or-1]..gr[gz and gy%64 or-1]end;return b(H)end;function gn(gA)local H,gB={},3;for aF,gv in h(g(gA,'%s+',''),'()(.)')do local gC=gr[gv]if gC<0 then gB=gB-1;gC=0 end;local fA=aF%4;if fA>0 then H[-fA]=gC else local gw=H[-1]*4+j(H[-2]/16)local gx=H[-2]%16*16+j(H[-3]/4)local gy=H[-3]%4*64+gC;H[#H+1]=f(d(gw,gx,gy),1,gB)end end;return b(H)end end;local gD;local function gE(aB,fv,gF)return g(aB,\".\",function(aH)return d(W(c(aH),gF))end)..e(d(gF),fv-#aB)end;local function gG(gH,gI,fS)local gJ=gD[gH]if not gJ then error(\"Unknown hash function\",2)end;if#gI>gJ then gI=gk(gH(gI))end;local gK=gH()(gE(gI,gJ,0x36))local H;local function fV(fW)if not fW then H=H or gH(gE(gI,gJ,0x5C)..gk(gK()))return H elseif H then error(\"Adding more chunks is not allowed after receiving the result\",2)else gK(fW)return fV end end;if fS then return fV(fS)()else return fV end end;local function gL(gM,gN,cc,cd)local gO=gN==\"s\"and 16 or 32;local gP=#gM;if gP>gO then error(i(\"For BLAKE2%s/BLAKE2%sp/BLAKE2X%s the 'salt' parameter length must not exceed %d bytes\",gN,gN,gN,gO),2)end;if cc then local gQ,gR,gS=0,gN==\"s\"and 4 or 8,gN==\"s\"and O or X;for az=5,4+k(gP/gR)do local gT,gU;for I=1,gR,4 do gQ=gQ+4;local aG,E,aH,aI=c(gM,gQ-3,gQ)local gV=(((aI or 0)*256+(aH or 0))*256+(E or 0))*256+(aG or 0)gT,gU=gU,gV end;cc[az]=gS(cc[az],gT and gU*aq+gT or gU)if cd then cd[az]=gS(cd[az],gU)end end end end;local function gW(fS,gI,gM,g4,gX,gY)g4=g4 or 32;if g4<1 or g4>32 then error(\"BLAKE2s digest length must be from 1 to 32 bytes\",2)end;gI=gI or\"\"local gZ=#gI;if gZ>32 then error(\"BLAKE2s key length must not exceed 32 bytes\",2)end;gM=gM or\"\"local b7,fU,aA=0.0,\"\",{unpack(aa)}if gY then aA[1]=O(aA[1],g4)aA[2]=O(aA[2],0x20)aA[3]=O(aA[3],gY)aA[4]=O(aA[4],0x20000000+gX)else aA[1]=O(aA[1],0x01010000+gZ*256+g4)if gX then aA[4]=O(aA[4],gX)end end;if gM~=\"\"then gL(gM,\"s\",aA)end;local function fV(fW)if fW then if fU then local aC=0;if fU~=\"\"and#fU+#fW>64 then aC=64-#fU;b7=a4(aA,fU..f(fW,1,aC),0,64,b7)fU=\"\"end;local ax=#fW-aC;local fX=ax>0 and(ax-1)%64+1 or 0;b7=a4(aA,fW,aC,ax-fX,b7)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then if gY then a4(aA,nil,0,64,0,32)else a4(aA,fU..e(\"\\0\",64-#fU),0,64,b7,#fU)end;fU=nil;if not gX or gY then local fZ=k(g4/4)for az=1,fZ do aA[az]=V(aA[az])end;aA=f(g(b(aA,\"\",1,fZ),\"(..)(..)(..)(..)\",\"%4%3%2%1\"),1,g4*2)end end;return aA end end;if gZ>0 then fV(gI..e(\"\\0\",64-gZ))end;if gY then return fV()elseif fS then return fV(fS)()else return fV end end;local function g_(fS,gI,gM,g4,gX,gY)g4=j(g4 or 64)if g4<1 or g4>64 then error(\"BLAKE2b digest length must be from 1 to 64 bytes\",2)end;gI=gI or\"\"local gZ=#gI;if gZ>64 then error(\"BLAKE2b key length must not exceed 64 bytes\",2)end;gM=gM or\"\"local b7,fU,cc,cd=0.0,\"\",{unpack(a9)},not aj and{unpack(aa)}if gY then if cd then cc[1]=X(cc[1],g4)cd[1]=X(cd[1],0x40)cc[2]=X(cc[2],gY)cd[2]=X(cd[2],gX)else cc[1]=X(cc[1],0x40*aq+g4)cc[2]=X(cc[2],gX*aq+gY)end;cc[3]=X(cc[3],0x4000)else cc[1]=X(cc[1],0x01010000+gZ*256+g4)if gX then if cd then cd[2]=X(cd[2],gX)else cc[2]=X(cc[2],gX*aq)end end end;if gM~=\"\"then gL(gM,\"b\",cc,cd)end;local function fV(fW)if fW then if fU then local aC=0;if fU~=\"\"and#fU+#fW>128 then aC=128-#fU;b7=a5(cc,cd,fU..f(fW,1,aC),0,128,b7)fU=\"\"end;local ax=#fW-aC;local fX=ax>0 and(ax-1)%128+1 or 0;b7=a5(cc,cd,fW,aC,ax-fX,b7)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then if gY then a5(cc,cd,nil,0,128,0,64)else a5(cc,cd,fU..e(\"\\0\",128-#fU),0,128,b7,#fU)end;fU=nil;if gX and not gY then if cd then for az=8,1,-1 do cc[az*2]=cd[az]cc[az*2-1]=cc[az]end;return cc,16 end else local fZ=k(g4/8)if cd then for az=1,fZ do cc[az]=V(cd[az])..V(cc[az])end else for az=1,fZ do cc[az]=aj(cc[az])end end;cc=f(g(b(cc,\"\",1,fZ),\"(..)(..)(..)(..)(..)(..)(..)(..)\",\"%8%7%6%5%4%3%2%1\"),1,g4*2)end;cd=nil end;return cc end end;if gZ>0 then fV(gI..e(\"\\0\",128-gZ))end;if gY then return fV()elseif fS then return fV(fS)()else return fV end end;local function h0(fS,gI,gM,g4)g4=g4 or 32;if g4<1 or g4>32 then error(\"BLAKE2sp digest length must be from 1 to 32 bytes\",2)end;gI=gI or\"\"local gZ=#gI;if gZ>32 then error(\"BLAKE2sp key length must not exceed 32 bytes\",2)end;gM=gM or\"\"local h1,fT,h2,H={},0.0,0x02080000+gZ*256+g4;for az=1,8 do local b7,fU,aA=0.0,\"\",{unpack(aa)}h1[az]={b7,fU,aA}aA[1]=O(aA[1],h2)aA[3]=O(aA[3],az-1)aA[4]=O(aA[4],0x20000000)if gM~=\"\"then gL(gM,\"s\",aA)end end;local function fV(fW)if fW then if h1 then local h3=0;while true do local h4=l(h3+64-fT%64,#fW)if h4>h3 then local h5=h1[j(fT/64)%8+1]local h6=f(fW,h3+1,h4)fT,h3=fT+h4-h3,h4;local b7,fU=h5[1],h5[2]if#fU<64 then fU=fU..h6 else local aA=h5[3]b7=a4(aA,fU,0,64,b7)fU=h6 end;h5[1],h5[2]=b7,fU else break end end;return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if h1 then local h7={unpack(aa)}h7[1]=O(h7[1],h2)h7[4]=O(h7[4],0x20010000)if gM~=\"\"then gL(gM,\"s\",h7)end;for az=1,8 do local h5=h1[az]local b7,fU,aA=h5[1],h5[2],h5[3]a4(aA,fU..e(\"\\0\",64-#fU),0,64,b7,#fU,az==8)if az%2==0 then local h8=0;for q=az-1,az do local h5=h1[q]local aA=h5[3]for h9=1,8 do h8=h8+1;an[h8]=aA[h9]end end;a4(h7,nil,0,64,64*(az/2-1),az==8 and 64,az==8)end end;h1=nil;local fZ=k(g4/4)for az=1,fZ do h7[az]=V(h7[az])end;H=f(g(b(h7,\"\",1,fZ),\"(..)(..)(..)(..)\",\"%4%3%2%1\"),1,g4*2)end;return H end end;if gZ>0 then gI=gI..e(\"\\0\",64-gZ)for az=1,8 do fV(gI)end end;if fS then return fV(fS)()else return fV end end;local function ha(fS,gI,gM,g4)g4=g4 or 64;if g4<1 or g4>64 then error(\"BLAKE2bp digest length must be from 1 to 64 bytes\",2)end;gI=gI or\"\"local gZ=#gI;if gZ>64 then error(\"BLAKE2bp key length must not exceed 64 bytes\",2)end;gM=gM or\"\"local h1,fT,h2,H={},0.0,0x02040000+gZ*256+g4;for az=1,4 do local b7,fU,cc,cd=0.0,\"\",{unpack(a9)},not aj and{unpack(aa)}h1[az]={b7,fU,cc,cd}cc[1]=X(cc[1],h2)cc[2]=X(cc[2],az-1)cc[3]=X(cc[3],0x4000)if gM~=\"\"then gL(gM,\"b\",cc,cd)end end;local function fV(fW)if fW then if h1 then local h3=0;while true do local h4=l(h3+128-fT%128,#fW)if h4>h3 then local h5=h1[j(fT/128)%4+1]local h6=f(fW,h3+1,h4)fT,h3=fT+h4-h3,h4;local b7,fU=h5[1],h5[2]if#fU<128 then fU=fU..h6 else local cc,cd=h5[3],h5[4]b7=a5(cc,cd,fU,0,128,b7)fU=h6 end;h5[1],h5[2]=b7,fU else break end end;return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if h1 then local hb,hc={unpack(a9)},not aj and{unpack(aa)}hb[1]=X(hb[1],h2)hb[3]=X(hb[3],0x4001)if gM~=\"\"then gL(gM,\"b\",hb,hc)end;for az=1,4 do local h5=h1[az]local b7,fU,cc,cd=h5[1],h5[2],h5[3],h5[4]a5(cc,cd,fU..e(\"\\0\",128-#fU),0,128,b7,#fU,az==4)if az%2==0 then local h8=0;for q=az-1,az do local h5=h1[q]local cc,cd=h5[3],h5[4]for h9=1,8 do h8=h8+1;am[h8]=cc[h9]if cd then h8=h8+1;am[h8]=cd[h9]end end end;a5(hb,hc,nil,0,128,128*(az/2-1),az==4 and 128,az==4)end end;h1=nil;local fZ=k(g4/8)if aj then for az=1,fZ do hb[az]=aj(hb[az])end else for az=1,fZ do hb[az]=V(hc[az])..V(hb[az])end end;H=f(g(b(hb,\"\",1,fZ),\"(..)(..)(..)(..)(..)(..)(..)(..)\",\"%8%7%6%5%4%3%2%1\"),1,g4*2)end;return H end end;if gZ>0 then gI=gI..e(\"\\0\",128-gZ)for az=1,4 do fV(gI)end end;if fS then return fV(fS)()else return fV end end;local function hd(he,hf,hg,gJ,g4,fS,gI,gM)local hh,hi,hj=2^(gJ/2)-1;if g4==-1 then g4=n;hi=j(hh)hj=true else if g4<0 then g4=-1.0*g4;hj=true end;hi=j(g4)if hi>=hh then error(\"Requested digest is too long.  BLAKE2X\"..hf..\" finite digest is limited by (2^\"..j(gJ/2)..\")-2 bytes.  Hint: you can generate infinite digest.\",2)end end;gM=gM or\"\"if gM~=\"\"then gL(gM,hf)end;local hk=he(nil,gI,gM,nil,hi)local H;local function fV(fW)if fW then if hk then hk(fW)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if hk then local hl,hm=hk()hm,hk=hm or 8;local function hn(ho)local ax=l(gJ,g4-ho*gJ)if ax<=0 then return\"\"end;for az=1,hm do hg[az]=hl[az]end;for az=hm+1,2*hm do hg[az]=0 end;return he(nil,nil,gM,ax,hi,j(ho))end;local hp={}if hj then local aF,hq,hr,hs=0,gJ*2^32;local function ge(ht,hu)if ht==\"seek\"then aF=hu%hq else local ax,h8=ht or 1,0;while ax>0 do local hv=aF%gJ;local ho=(aF-hv)/gJ;local hw=l(ax,gJ-hv)if hr~=ho then hr=ho;hs=hn(ho)end;h8=h8+1;hp[h8]=f(hs,hv*2+1,(hv+hw)*2)ax=ax-hw;aF=(aF+hw)%hq end;return b(hp,\"\",1,h8)end end;H=ge else for az=1.0,k(g4/gJ)do hp[az]=hn(az-1.0)end;H=b(hp)end end;return H end end;if fS then return fV(fS)()else return fV end end;local function hx(g4,fS,gI,gM)return hd(gW,\"s\",an,32,g4,fS,gI,gM)end;local function hy(g4,fS,gI,gM)return hd(g_,\"b\",am,64,g4,fS,gI,gM)end;local function hz(fS,gI,g4,hA,aE,hB)gI=gI or\"\"g4=g4 or 32;hA=hA or 0;if gI==\"\"then aE=aE or aa else local gZ=#gI;if gZ>32 then error(\"BLAKE3 key length must not exceed 32 bytes\",2)end;gI=gI..e(\"\\0\",32-gZ)aE={}for az=1,8 do local aG,E,aH,aI=c(gI,4*az-3,4*az)aE[az]=((aI*256+aH)*256+E)*256+aG end;hA=hA+16 end;local fU,aA,cR,hC,hD,hE=\"\",{},0,0,0,{}local hF,hG,hj,H,cU=aE;local hH=3;local function hI(aB,aC,ax)while ax>0 do local hJ,hK,cS=1,0,aA;if hC==0 then hK=1;cS,hF=aE,aA;hH=2 elseif hC==15 then hK=2;hH=3;hF=aE else hJ=l(ax/64,15-hC)end;local hw=hJ*64;a6(aB,aC,hw,hA+hK,cR,cS,aA)aC,ax=aC+hw,ax-hw;hC=(hC+hJ)%16;if hC==0 then cR=cR+1.0;local hL=2.0;while cR%hL==0 do hL=hL*2.0;hD=hD-8;for az=1,8 do an[az]=hE[hD+az]end;for az=1,8 do an[az+8]=aA[az]end;a6(nil,0,64,hA+4,0,aE,aA)end;for az=1,8 do hE[hD+az]=aA[az]end;hD=hD+8 end end end;local function hn(ho)local ax=l(64,g4-ho*64)if ho<0 or ax<=0 then return\"\"end;if hj then for az=1,16 do an[az]=hE[az+16]end end;a6(nil,0,64,hH,ho,hF,hE,cU,hG)if hB then return hE end;local fZ=k(ax/4)for az=1,fZ do hE[az]=V(hE[az])end;return f(g(b(hE,\"\",1,fZ),\"(..)(..)(..)(..)\",\"%4%3%2%1\"),1,ax*2)end;local function fV(fW)if fW then if fU then local aC=0;if fU~=\"\"and#fU+#fW>64 then aC=64-#fU;hI(fU..f(fW,1,aC),0,64)fU=\"\"end;local ax=#fW-aC;local fX=ax>0 and(ax-1)%64+1 or 0;hI(fW,aC,ax-fX)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then hG=#fU;fU=fU..e(\"\\0\",64-#fU)if an[0]then for az=1,16 do local aG,E,aH,aI=c(fU,4*az-3,4*az)an[az]=N(P(aI,24),P(aH,16),P(E,8),aG)end else for az=1,16 do local aG,E,aH,aI=c(fU,4*az-3,4*az)an[az]=((aI*256+aH)*256+E)*256+aG end end;fU=nil;for hD=hD-8,0,-8 do a6(nil,0,64,hA+hH,cR,hF,aA,nil,hG)cR,hG,hF,hH=0,64,aE,4;for az=1,8 do an[az]=hE[hD+az]end;for az=1,8 do an[az+8]=aA[az]end end;hH=hA+hH+8;if g4<0 then if g4==-1 then g4=n else g4=-1.0*g4 end;hj=true;for az=1,16 do hE[az+16]=an[az]end end;g4=l(2^53,g4)cU=g4>32;if hj then local aF,hr,hs=0.0;local function ge(ht,hu)if ht==\"seek\"then aF=hu*1.0 else local ax,h8=ht or 1,32;while ax>0 do local hv=aF%64;local ho=(aF-hv)/64;local hw=l(ax,64-hv)if hr~=ho then hr=ho;hs=hn(ho)end;h8=h8+1;hE[h8]=f(hs,hv*2+1,(hv+hw)*2)ax=ax-hw;aF=aF+hw end;return b(hE,\"\",33,h8)end end;H=ge elseif g4<=64 then H=hn(0)else local hM=k(g4/64)-1;for ho=0.0,hM do hE[33+ho]=hn(ho)end;H=b(hE,\"\",33,33+hM)end end;return H end end;if fS then return fV(fS)()else return fV end end;local function hN(hO,hP,hQ)if type(hP)~=\"string\"then error(\"'context_string' parameter must be a Lua string\",2)end;local aE=hz(hP,nil,nil,32,nil,true)return hz(hO,nil,hQ,64,aE)end;local hR={md5=g0,sha1=g2,sha224=function(fS)return fR(224,fS)end,sha256=function(fS)return fR(256,fS)end,sha512_224=function(fS)return f_(224,fS)end,sha512_256=function(fS)return f_(256,fS)end,sha384=function(fS)return f_(384,fS)end,sha512=function(fS)return f_(512,fS)end,sha3_224=function(fS)return g3((1600-2*224)/8,224/8,false,fS)end,sha3_256=function(fS)return g3((1600-2*256)/8,256/8,false,fS)end,sha3_384=function(fS)return g3((1600-2*384)/8,384/8,false,fS)end,sha3_512=function(fS)return g3((1600-2*512)/8,512/8,false,fS)end,shake128=function(g4,fS)return g3((1600-2*128)/8,g4,true,fS)end,shake256=function(g4,fS)return g3((1600-2*256)/8,g4,true,fS)end,hmac=gG,hex_to_bin=gk,bin_to_hex=gl,base64_to_bin=gn,bin_to_base64=gm,hex2bin=gk,bin2hex=gl,base642bin=gn,bin2base64=gm,blake2b=g_,blake2s=gW,blake2bp=ha,blake2sp=h0,blake2xb=hy,blake2xs=hx,blake2=g_,blake2b_160=function(fS,gI,gM)return g_(fS,gI,gM,20)end,blake2b_256=function(fS,gI,gM)return g_(fS,gI,gM,32)end,blake2b_384=function(fS,gI,gM)return g_(fS,gI,gM,48)end,blake2b_512=g_,blake2s_128=function(fS,gI,gM)return gW(fS,gI,gM,16)end,blake2s_160=function(fS,gI,gM)return gW(fS,gI,gM,20)end,blake2s_224=function(fS,gI,gM)return gW(fS,gI,gM,28)end,blake2s_256=gW,blake3=hz,blake3_derive_key=hN}gD={[hR.md5]=64,[hR.sha1]=64,[hR.sha224]=64,[hR.sha256]=64,[hR.sha512_224]=128,[hR.sha512_256]=128,[hR.sha384]=128,[hR.sha512]=128,[hR.sha3_224]=144,[hR.sha3_256]=136,[hR.sha3_384]=104,[hR.sha3_512]=72}return hR\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881293798,size=81085},["deflateans.lua"]={type="file",created=1740881291691,worldPermissions={execute=false,read=true,write=false},data="local a,b,c,d,e,f,g,h,i,j,k=bit32.band,bit32.rshift,bit32.lshift,bit32.bor,math.frexp,math.max,math.min,math.floor,table.sort,table.concat,string.char;local function l(m)local n,o=e(m)return o-1 end;local function p(m)return m==0 and 0 or 2^(m-1)end;local function q(...)end;local function r(...)end;local s,t,u={R=9},{R=5},{16,17,18}for v=0,143 do s[v+1]={v,2}end;for v=144,255 do s[v+1]={v,1}end;for v=256,279 do s[v+1]={v,4}end;for v=280,287 do s[v+1]={v,2}end;for v=0,31 do t[v+1]={v,1}end;for v=0,7 do u[#u+1],u[#u+2]=(8-v)%8,8+v end;local function w(x)local y,z,A=0,0,1;local function B(m)if not m then m=z%8 end;if m<=0 then return 0 end;while z<m do assert(A<=#x)A,z,y=A+1,z+8,c(y,8)+x:byte(A)end;local C=a(b(y,z-m),2^m-1)z=z-m;return C end;return B end;local function D(E)local F,G=E.R,2^E.R;local H,I,J,K,L=0,G<16 and 3 or 0.625*G+3,{R=F},{},{}if F<0 then return J end;for v=1,#E do local M=E[v]K[M[1]]=M[2]for n=1,M[2]do while L[H]do H=(H+1)%G end;H,L[H]=(H+I)%G,M[1]end end;for H=0,G-1 do local N=L[H]local O={s=N,n=F-l(K[N])}O.X,J[H],K[N]=c(K[N],O.n)-G,O,1+K[N]end;return J end;local function P(B,Q,J,R)local H,S,v,C=B(J.R),R and B(R.R),1,{}while v<=Q do local O=J[H]local N=O.s;if N==256 then return C elseif N>256 then local T=N-257;local U=f(h(T/4)-1,0)if U>0 then T=2+d(B(U),c(a(T,3)+4,U))else T=T+2 end;local V=R[S]local W=V.s;U=f(h(W/2)-1,0)if U>0 then W=1+d(B(U),c(a(W,1)+2,U))else W=W+1 end;for X=0,T do C[v+X]=C[v+X-W]end;v,S=v+T+1,V.X+B(V.n)elseif not R and N>15 then local Y;if N==16 then N,Y=C[v-1],3+B(2)elseif N==17 then N,Y=0,3+B(3)else N,Y=0,11+B(7)end;for X=0,Y-1 do C[v+X]=N end;v=v+Y else C[v],v=N,v+1 end;H=O.X+B(O.n)end;return C end;local function Z(_)local a0,C=w(_),\"\"repeat local a1,a2=a0(1)==1,a0(2)if a2==0 then a0()local a3=a0(16)assert(bit32.bxor(a0(16),a3)==0xFFFF,\"invalid chunk\")for n=1,a3 do C=C..k(a0(8))end elseif a2==1 or a2==2 then local E,a4;if a2==1 then E,a4=s,t else local a5,a6,a7,a8=a0(5)+257,a0(5)+1,a0(4)+4,{R=0}for v=1,a7 do local a9=p(a0(3))a8.R,a8[v]=a8.R+a9,{u[v],a9}end;a8.R=l(a8.R)i(a8,function(aa,ab)return aa[1]<ab[1]end)local ac=P(a0,a5+a6,D(a8))E,a4={R=0},{R=0}for v=1,a5 do E[v]={v-1,p(ac[v])}end;for v=1,a6 do a4[v]={v-1,p(ac[v+a5])}end;for v=1,a5 do E.R=E.R+E[v][2]end;for v=1,a6 do a4.R=a4.R+a4[v][2]end;E.R,a4.R=l(E.R),l(a4.R)end;local ad=P(a0,1e10,D(E),D(a4))for v=1,#ad do ad[v]=k(ad[v])end;C=C..j(ad)elseif a2==3 then local ae={}while true do local Y=a0(9)if Y==511 then break elseif Y>=256 then Y=Y-253;local af=a0(15)for n=1,Y do ae[#ae+1]=ae[#ae-af]end else ae[#ae+1]=string.char(Y)end end;C=C..table.concat(ae)else error(\"invalid chunk\")end until a1;return C end;local function ag()return setmetatable({data=\"\",partial=0,len=0},{__call=function(self,z,Y)if not z then z,Y=0,8-self.len end;assert(z<2^Y,debug.traceback())self.partial=bit32.bor(bit32.lshift(self.partial,Y),z)self.len=self.len+Y;while self.len>=8 do local ah=bit32.extract(self.partial,self.len-8,8)self.data=self.data..string.char(ah)self.len=self.len-8 end end})end;local function ai(E,aj)local F=E.R;if F==0 then if aj then return 0 end;while coroutine.yield(0,0)do end;return 0,0 end;local G=2^F;local ak,al,am,K,L,an={},{},{},{},{},{}local H,I=0,G<16 and 3 or 0.625*G+3;local ao=0;for n,M in ipairs(E)do local N,ap=M[1],M[2]ak[N]=F-l(ap)al[N]=c(ak[N],F+1)-c(ap,ak[N])am[N]=ao-ap;K[N]=ap;an[#an+1]=N;for n=1,ap do while L[H]~=nil do H=(H+1)%G end;L[H]=N;H=(H+I)%G end;ao=ao+ap end;local aq={}for ar=G,2*G-1 do local N=L[ar-G]aq[am[N]+K[N]]=ar;K[N]=K[N]+1 end;local ar=G;local as,at=0,0;local au;if aj then local A=#aj;function au()local N=aj[A]A=A-1;return N end else au=coroutine.yield end;local N=au()while N do local av=b(ar+al[N],F+1)local aw=au(a(ar,2^av-1),av)as=as+av;at=at+1;ar=aq[am[N]+b(ar,av)]N=aw end;if not aj then q(\"Size of block:\",as+F,at)return ar-G,F else return as+F end end;local function ax(ay,...)local az=table.pack(coroutine.resume(ay,...))if not az[1]then error(debug.traceback(ay,az[2]),2)end;return table.unpack(az,1,az.n)end;local function aA(aj,E,a4,aB)local aC={}local aD=coroutine.create(ai)ax(aD,E)local aE=coroutine.create(ai)ax(aE,a4)for v=#aj,1,-1 do local N=aj[v]if type(N)==\"table\"then aC[#aC+1]={select(2,ax(aD,N[1].code+257))}aC[#aC+1]={select(2,ax(aE,N[2].code))}aC[#aC+1]={N[2].extra,N[2].bits}aC[#aC+1]={N[1].extra,N[1].bits}else aC[#aC+1]={select(2,ax(aD,N))}end end;aC[#aC+1]={select(2,ax(aE))}aC[#aC+1]={select(2,ax(aD))}for v=#aC,2,-1 do aB(aC[v][1],aC[v][2])end end;local function aF(aj,E,a4)if not E or not a4 then return math.huge end;local aG,aH={},{}local z=0;for v,N in ipairs(aj)do if type(N)==\"table\"then aG[v]=N[1].code+257;aH[#aH+1]=N[2].code;z=z+N[1].bits+N[2].bits else aG[v]=N end end;return z+ai(E,aG)+ai(a4,aH)end;local function aI(aj,E,aB)local aC={}local aD=coroutine.create(ai)coroutine.resume(aD,E)for v=#aj,1,-1 do local N=aj[v]if type(N)==\"table\"then aC[#aC+1]={select(2,coroutine.resume(aD,N[1]))}if N[1]==16 then aC[#aC+1]={N[2],2}elseif N[1]==17 then aC[#aC+1]={N[2],3}elseif N[1]==18 then aC[#aC+1]={N[2],7}end else aC[#aC+1]={select(2,coroutine.resume(aD,N))}end end;aC[#aC+1]={select(2,coroutine.resume(aD))}for v=#aC,1,-1 do aB(aC[v][1],aC[v][2])end end;local function aJ(aj,E)if not E then return math.huge end;local aG={}local z=0;for v,N in ipairs(aj)do if type(N)==\"table\"then aG[v]=N[1]if N[1]==16 then z=z+2 elseif N[1]==17 then z=z+3 elseif N[1]==18 then z=z+7 end else aG[v]=N end end;return z+ai(E,aG)end;local function W(v)if v==0 or v==1 then return{code=v,extra=0,bits=0,raw=v}end;local U=math.max(select(2,math.frexp(v))-2,0)local aK=2^U;return{code=U*2+(bit32.btest(v,aK)and 3 or 2),extra=bit32.band(v,aK-1),bits=U,raw=v}end;local function T(v)if v>=0 and v<4 then return{code=v,extra=0,bits=0,raw=v}end;local U=math.max(select(2,math.frexp(v))-3,0)local aK=2^U;return{code=U*4+(bit32.btest(v,aK)and 5 or 4)+(bit32.btest(v,aK*2)and 2 or 0),extra=bit32.band(v,aK-1),bits=U,raw=v}end;local function aL(aM,aN)aN=g(aN or 1024,32768)local C={}local aO={}local v=1;while v<=#aM do local ap=aM[v]if aO[ap]then local aP=aO[ap]local aQ,A=0;for m=#aP,1,-1 do local aR=aP[m]if v-aR>aN then break end;for X=1,g(#aM-v,129)do local aS=(X-1)%(v-aR)+1;if aM[v+X]==aM[aR+aS]then if X>aQ then aQ,A=X,aR end else break end end end;if aQ>=2 then local Y=T(aQ-2)local af=W(v-A-1)C[#C+1]={Y,af}for X=0,aQ do ap=aM[v+X]aO[ap][#aO[ap]+1]=v+X end;v=v+aQ+1;ap=nil end end;if ap then C[#C+1]=ap;aO[ap]=aO[ap]or{}aO[ap][#aO[ap]+1]=v;v=v+1 end end;return C end;local function aT(aU)return function(aa,ab)if aa.height>aU then return true end;if ab.height>aU then return false end;return aa.weight>ab.weight end end;local function aV(aW)if aW then return function(aa,ab)if aa.bits==ab.bits then return aW[aa.symbol]<aW[ab.symbol]else return aa.bits<ab.bits end end else return function(aa,ab)if aa.bits==ab.bits then return aa.symbol<ab.symbol else return aa.bits<ab.bits end end end end;local function aX(aY,aZ,a_,y)if aY.data then y.symbol=aY.data;a_[aY.data]=y;aZ[#aZ+1]=y else aX(aY[1],aZ,a_,{bits=y.bits+1,code=y.code*2})aX(aY[2],aZ,a_,{bits=y.bits+1,code=y.code*2+1})end end;local function b0(b1,b2)b2=b2 or 15;local E={R=0}for ak,ap in pairs(b1)do E[#E+1]={ak,ap}end;i(E,function(aa,ab)return aa[1]<ab[1]end)local b3={}for v,ap in ipairs(E)do if ap[2]>0 then b3[#b3+1]={data=ap[1],weight=ap[2],height=1}end end;if#b3<2 then local C={R=0}for v,ap in ipairs(E)do if ap[1]==b3[1].data then C[v]={ap[1],1,0}end end;return C end;local b4=aT(b2-1)i(b3,b4)while#b3>1 do local aa,ab=b3[#b3-1],b3[#b3]local m={weight=aa.weight+ab.weight,height=f(aa.height+1,ab.height+1),aa,ab}b3[#b3]=nil;b3[#b3]=m;i(b3,b4)end;local aZ,a_={},{}aX(b3[1],aZ,a_,{bits=0,code=0})i(aZ,aV())aZ[1].code=0;for v=2,#aZ do aZ[v].code=bit32.lshift(aZ[v-1].code+1,aZ[v].bits-aZ[v-1].bits)end;local b5={}for v,ap in ipairs(E)do b5[v]=a_[ap[1]]and a_[ap[1]].bits or 0;E.R=f(E.R,b5[v])end;local b6={}local b7=0;for v,ap in ipairs(b5)do assert(ap>0 and ap<=b2)b6[v]={E[v][1],2^(E.R-ap),E.R-ap}b7=b7+2^(E.R-ap)end;b6.R=select(2,math.frexp(b7))-1;return b6 end;local function b8(_,b9,ba)if _==\"\"then return\"\\x80\\x00\\x00\\xFF\\xFF\"end;b9=b9 or 5;local aB=ag()for v=1,#_,65536 do q(#aB.data,aB.len)local a1=v+65536>#_;local bb={}for X=0,g(#_-v,65535)do bb[X+1]=_:byte(v+X)end;bb[#bb+1]=256;local bc=b9==0 and bb or aL(bb,2^(b9+6))local b1,bd={},{}for n,ap in ipairs(bc)do if type(ap)==\"table\"then local N=ap[1].code+257;b1[N]=(b1[N]or 0)+1;bd[ap[2].code]=(bd[ap[2].code]or 0)+1 else b1[ap]=(b1[ap]or 0)+1 end end;local be=b0(b1)local bf=b0(bd)local b5={}for X=0,285 do local bg=false;for n,ap in ipairs(be)do if ap[1]==X then bg=true;b5[X]=ap[3]+1;break end end;if not bg then b5[X]=0 end end;while#b5>256 and b5[#b5]==0 do b5[#b5]=nil end;local a5=#b5-256;for X=0,31 do local bg=false;for n,ap in ipairs(bf)do if ap[1]==X then bg=true;b5[#b5+1]=ap[3]+1;break end end;if not bg then b5[#b5+1]=0 end end;while#b5>257 and b5[#b5]==0 do b5[#b5]=nil end;local a6=#b5-a5-257;local bh={}do local X=0;while X<=#b5 do if b5[X]==b5[X+1]and b5[X+1]==b5[X+2]then if b5[X]==0 then local Y=3;while b5[X+Y]==0 and Y<138 do Y=Y+1 end;if Y>=11 then bh[#bh+1]={18,Y-11}else bh[#bh+1]={17,Y-3}end;X=X+Y elseif b5[X+2]==b5[X+3]then local Y=4;while b5[X+Y]==b5[X]and Y<7 do Y=Y+1 end;bh[#bh+1]=b5[X]bh[#bh+1]={16,Y-4}X=X+Y else bh[#bh+1]=b5[X]bh[#bh+1]=b5[X]bh[#bh+1]=b5[X]X=X+3 end else bh[#bh+1]=b5[X]X=X+1 end end end;b1={}for n,ap in ipairs(bh)do if type(ap)==\"table\"then b1[ap[1]]=(b1[ap[1]]or 0)+1 else b1[ap]=(b1[ap]or 0)+1 end end;local bi=b0(b1,7)local bj={}for X,ap in ipairs(u)do local aR=0;for n,bk in ipairs(bi)do if bk[1]==ap then aR=bk[3]+1;break end end;r(aR..\" \")bj[X]=aR end;q()while#bj>4 and bj[#bj]==0 do bj[#bj]=nil end;local bl=#bb*8+8;local bm=#bc*9;for n,ap in ipairs(bc)do if type(ap)==\"table\"then bm=bm+15 end end;local bn=aF(bc,s,t)local bo=ba and math.huge or aF(bc,be,bf)+aJ(bh,bi)+#bj*3;local bp=g(bl,bm,bn,bo)q(\"Sizes:\",bl,bm,bn,bo)aB(a1 and 1 or 0,1)if bp==bl then q(\"Writing uncompressed block\",bl)aB(0,2)aB()aB(#bb-1,16)aB(bit32.band(bit32.bnot(#bb-1),0xFFFF),16)aB.data=aB.data.._:sub(v,v+65535)elseif bp==bm then q(\"Writing LZSS block\",bm)aB(3,2)for n,N in ipairs(bc)do if type(N)==\"table\"then aB(N[1].raw+256,9)aB(N[2].raw,15)elseif N==256 then aB(511,9)else aB(N,9)end end else local E,a4;if bp==bn then q(\"Writing static block\",bn)aB(1,2)E,a4=s,t else q(\"Writing dynamic block\",bo)aB(2,2)E,a4=be,bf;aB(a5,5)aB(a6,5)aB(#bj-4,4)for n,ap in ipairs(bj)do aB(ap,3)end;aI(bh,bi,aB)end;aA(bc,E,a4,aB)end end;aB()return aB.data end;return{deflate=b8,inflate=Z}\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291690,size=10537},["LibDeflate.lua"]={type="file",created=1740881292674,worldPermissions={execute=false,read=true,write=false},data="local a;do local b=\"1.0.2-release\"local c=\"LibDeflate\"local d=3;local e=\"LibDeflate \"..b..\" Copyright (C) 2018-2021 Haoqian He.\"..\" Licensed under the zlib License\"if LibStub then local f,g=LibStub:GetLibrary(c,true)if f and g and g>=d then return f else a=LibStub:NewLibrary(c,d)end else a={}end;a._VERSION=b;a._MAJOR=c;a._MINOR=d;a._COPYRIGHT=e end;local assert=assert;local error=error;local pairs=pairs;local h=string.byte;local i=string.char;local j=string.find;local k=string.gsub;local l=string.sub;local m=table.concat;local n=table.sort;local tostring=tostring;local type=type;local o={}local p={}local q={}local r={}local s={}local t={}local u={}local v={}local w={}local x={3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258}local y={0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0}local z={[0]=1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577}local A={[0]=0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13}local B={16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15}local C;local D;local E;local F;local G;local H;local I;local J;for K=0,255 do p[K]=i(K)end;do local L=1;for K=0,32 do o[K]=L;L=L*2 end end;for K=1,9 do q[K]={}for M=0,o[K+1]-1 do local N=0;local O=M;for P=1,K do N=N-N%2+((N%2==1 or O%2==1)and 1 or 0)O=(O-O%2)/2;N=N*2 end;q[K][M]=(N-N%2)/2 end end;do local Q=18;local R=16;local S=265;local T=1;for U=3,258 do if U<=10 then r[U]=U+254;t[U]=0 elseif U==258 then r[U]=285;t[U]=0 else if U>Q then Q=Q+R;R=R*2;S=S+4;T=T+1 end;local V=U-Q-1+R/2;r[U]=(V-V%(R/8))/(R/8)+S;t[U]=T;s[U]=V%(R/8)end end end;do u[1]=0;u[2]=1;w[1]=0;w[2]=0;local Q=3;local R=4;local W=2;local T=0;for X=3,256 do if X>R then Q=Q*2;R=R*2;W=W+2;T=T+1 end;u[X]=X<=Q and W or W+1;w[X]=T<0 and 0 or T;if R>=8 then v[X]=(X-R/2-1)%(R/4)end end end;local Y,Z,_,a0,a1=bit32.band,bit32.bnot,bit32.bxor,bit32.lshift,bit32.rshift;local a2=0xEDB88320;local function a3(a4)local a5={}local V=setmetatable({},a5)function a5:__index(a6)local a7=a4(a6)V[a6]=a7;return a7 end;return V end;local a8=a3(function(K)local a9=K;for P=1,8 do local R=Y(a9,1)a9=a1(a9,1)if R==1 then a9=_(a9,a2)end end;return a9 end)local function aa(ab,a9)a9=Z(a9 or 0)local ac=a1(a9,8)local ad=a8[_(a9%256,ab)]return Z(_(ac,ad))end;local function ae(af,a9)a9=a9 or 0;for K=1,#af do a9=aa(af:byte(K),a9)end;return a9 end;function a:CRC32(af,a9)if type(af)=='string'then return ae(af,a9)else return aa(af,a9)end end;function a:Adler32(ag)if type(ag)~=\"string\"then error((\"Usage: LibDeflate:Adler32(str):\"..\" 'str' - string expected got '%s'.\"):format(type(ag)),2)end;local ah=#ag;local K=1;local Q=1;local R=0;while K<=ah-15 do local ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax=h(ag,K,K+15)R=(R+16*Q+16*ai+15*aj+14*ak+13*al+12*am+11*an+10*ao+9*ap+8*aq+7*ar+6*as+5*at+4*au+3*av+2*aw+ax)%65521;Q=(Q+ai+aj+ak+al+am+an+ao+ap+aq+ar+as+at+au+av+aw+ax)%65521;K=K+16 end;while K<=ah do local ay=h(ag,K,K)Q=(Q+ay)%65521;R=(R+Q)%65521;K=K+1 end;return(R*65536+Q)%4294967296 end;local function az(aA,aB)return aA%4294967296==aB%4294967296 end;function a:CreateDictionary(ag,ah,aC)if type(ag)~=\"string\"then error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\"..\" 'str' - string expected got '%s'.\"):format(type(ag)),2)end;if type(ah)~=\"number\"then error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\"..\" 'strlen' - number expected got '%s'.\"):format(type(ah)),2)end;if type(aC)~=\"number\"then error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\"..\" 'adler32' - number expected got '%s'.\"):format(type(aC)),2)end;if ah~=#ag then error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\"..\" 'strlen' does not match the actual length of 'str'.\"..\" 'strlen': %u, '#str': %u .\"..\" Please check if 'str' is modified unintentionally.\"):format(ah,#ag))end;if ah==0 then error(\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\"..\" 'str' - Empty string is not allowed.\",2)end;if ah>32768 then error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\"..\" 'str' - string longer than 32768 bytes is not allowed.\"..\" Got %d bytes.\"):format(ah),2)end;local aD=self:Adler32(ag)if not az(aC,aD)then error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\"..\" 'adler32' does not match the actual adler32 of 'str'.\"..\" 'adler32': %u, 'Adler32(str)': %u .\"..\" Please check if 'str' is modified unintentionally.\"):format(aC,aD))end;local aE={}aE.adler32=aC;aE.hash_tables={}aE.string_table={}aE.strlen=ah;local aF=aE.string_table;local aG=aE.hash_tables;aF[1]=h(ag,1,1)aF[2]=h(ag,2,2)if ah>=3 then local K=1;local aH=aF[1]*256+aF[2]while K<=ah-2-3 do local ai,aj,ak,al=h(ag,K+2,K+5)aF[K+2]=ai;aF[K+3]=aj;aF[K+4]=ak;aF[K+5]=al;aH=(aH*256+ai)%16777216;local V=aG[aH]if not V then V={}aG[aH]=V end;V[#V+1]=K-ah;K=K+1;aH=(aH*256+aj)%16777216;V=aG[aH]if not V then V={}aG[aH]=V end;V[#V+1]=K-ah;K=K+1;aH=(aH*256+ak)%16777216;V=aG[aH]if not V then V={}aG[aH]=V end;V[#V+1]=K-ah;K=K+1;aH=(aH*256+al)%16777216;V=aG[aH]if not V then V={}aG[aH]=V end;V[#V+1]=K-ah;K=K+1 end;while K<=ah-2 do local ay=h(ag,K+2)aF[K+2]=ay;aH=(aH*256+ay)%16777216;local V=aG[aH]if not V then V={}aG[aH]=V end;V[#V+1]=K-ah;K=K+1 end end;return aE end;local function aI(aE)if type(aE)~=\"table\"then return false,(\"'dictionary' - table expected got '%s'.\"):format(type(aE))end;if type(aE.adler32)~=\"number\"or type(aE.string_table)~=\"table\"or type(aE.strlen)~=\"number\"or aE.strlen<=0 or aE.strlen>32768 or aE.strlen~=#aE.string_table or type(aE.hash_tables)~=\"table\"then return false,(\"'dictionary' - corrupted dictionary.\"):format(type(aE))end;return true,\"\"end;local aJ={[0]={false,nil,0,0,0},[1]={false,nil,4,8,4},[2]={false,nil,5,18,8},[3]={false,nil,6,32,32},[4]={true,4,4,16,16},[5]={true,8,16,32,32},[6]={true,8,16,128,128},[7]={true,8,32,128,256},[8]={true,32,128,258,1024},[9]={true,32,258,258,4096}}local function aK(ag,aL,aE,aM,aN)if type(ag)~=\"string\"then return false,(\"'str' - string expected got '%s'.\"):format(type(ag))end;if aL then local aO,aP=aI(aE)if not aO then return false,aP end end;if aM then local aQ=type(aN)if aQ~=\"nil\"and aQ~=\"table\"then return false,(\"'configs' - nil or table expected got '%s'.\"):format(type(aN))end;if aQ==\"table\"then for a6,a7 in pairs(aN)do if a6~=\"level\"and a6~=\"strategy\"then return false,(\"'configs' - unsupported table key in the configs: '%s'.\"):format(a6)elseif a6==\"level\"and not aJ[a7]then return false,(\"'configs' - unsupported 'level': %s.\"):format(tostring(a7))elseif a6==\"strategy\"and a7~=\"fixed\"and a7~=\"huffman_only\"and a7~=\"dynamic\"then return false,(\"'configs' - unsupported 'strategy': '%s'.\"):format(tostring(a7))end end end end;return true,\"\"end;local aR=0;local aS=1;local aT=2;local aU=3;local function aV()local aW=0;local aX=0;local aY=0;local aZ=0;local a_={}local b0={}local function b1(O,T)aX=aX+O*o[aY]aY=aY+T;aZ=aZ+T;if aY>=32 then aW=aW+1;a_[aW]=p[aX%256]..p[(aX-aX%256)/256%256]..p[(aX-aX%65536)/65536%256]..p[(aX-aX%16777216)/16777216%256]local b2=o[32-aY+T]aX=(O-O%b2)/b2;aY=aY-32 end end;local function b3(ag)for P=1,aY,8 do aW=aW+1;a_[aW]=i(aX%256)aX=(aX-aX%256)/256 end;aY=0;aW=aW+1;a_[aW]=ag;aZ=aZ+#ag*8 end;local function b4(b5)if b5==aU then return aZ end;if b5==aS or b5==aT then local b6=(8-aY%8)%8;if aY>0 then aX=aX-o[aY]+o[aY+b6]for P=1,aY,8 do aW=aW+1;a_[aW]=p[aX%256]aX=(aX-aX%256)/256 end;aX=0;aY=0 end;if b5==aT then aZ=aZ+b6;return aZ end end;local b7=m(a_)a_={}aW=0;b0[#b0+1]=b7;if b5==aR then return aZ else return aZ,m(b0)end end;return b1,b3,b4 end;local function b8(b9,ba,bb)bb=bb+1;b9[bb]=ba;local O=ba[1]local bc=bb;local bd=(bc-bc%2)/2;while bd>=1 and b9[bd][1]>O do local V=b9[bd]b9[bd]=ba;b9[bc]=V;bc=bd;bd=(bd-bd%2)/2 end end;local function be(b9,bb)local bf=b9[1]local ba=b9[bb]local O=ba[1]b9[1]=ba;b9[bb]=bf;bb=bb-1;local bc=1;local bg=bc*2;local bh=bg+1;while bg<=bb do local bi=b9[bg]if bh<=bb and b9[bh][1]<bi[1]then local bj=b9[bh]if bj[1]<O then b9[bh]=ba;b9[bc]=bj;bc=bh;bg=bc*2;bh=bg+1 else break end else if bi[1]<O then b9[bg]=ba;b9[bc]=bi;bc=bg;bg=bc*2;bh=bg+1 else break end end end;return bf end;local function bk(bl,bm,bn,bo)local bp=0;local bq={}local br={}for T=1,bo do bp=(bp+(bl[T-1]or 0))*2;bq[T]=bp end;for bs=0,bn do local T=bm[bs]if T then bp=bq[T]bq[T]=bp+1;if T<=9 then br[bs]=q[T][bp]else local N=0;for P=1,T do N=N-N%2+((N%2==1 or bp%2==1)and 1 or 0)bp=(bp-bp%2)/2;N=N*2 end;br[bs]=(N-N%2)/2 end end end;return br end;local function bt(Q,R)return Q[1]<R[1]or Q[1]==R[1]and Q[2]<R[2]end;local function bu(bv,bo,bn)local bb;local bw=-1;local bx={}local b9={}local bm={}local by={}local bl={}local bz=0;for bs,bA in pairs(bv)do bz=bz+1;bx[bz]={bA,bs}end;if bz==0 then return{},{},-1 elseif bz==1 then local bs=bx[1][2]bm[bs]=1;by[bs]=0;return bm,by,bs else n(bx,bt)bb=bz;for K=1,bb do b9[K]=bx[K]end;while bb>1 do local bB=be(b9,bb)bb=bb-1;local bC=be(b9,bb)bb=bb-1;local bD={bB[1]+bC[1],-1,bB,bC}b8(b9,bD,bb)bb=bb+1 end;local bE=0;local bF={b9[1],0,0,0}local bG=1;local bH=1;b9[1][1]=0;while bH<=bG do local ba=bF[bH]local T=ba[1]local bs=ba[2]local bi=ba[3]local bj=ba[4]if bi then bG=bG+1;bF[bG]=bi;bi[1]=T+1 end;if bj then bG=bG+1;bF[bG]=bj;bj[1]=T+1 end;bH=bH+1;if T>bo then bE=bE+1;T=bo end;if bs>=0 then bm[bs]=T;bw=bs>bw and bs or bw;bl[T]=(bl[T]or 0)+1 end end;if bE>0 then repeat local T=bo-1;while(bl[T]or 0)==0 do T=T-1 end;bl[T]=bl[T]-1;bl[T+1]=(bl[T+1]or 0)+2;bl[bo]=bl[bo]-1;bE=bE-2 until bE<=0;bH=1;for T=bo,1,-1 do local bI=bl[T]or 0;while bI>0 do local bs=bx[bH][2]bm[bs]=T;bI=bI-1;bH=bH+1 end end end;by=bk(bl,bm,bn,bo)return bm,by,bw end end;local function bJ(bK,bL,bM,bN)local bO=0;local bP={}local bQ={}local bR=0;local bS={}local bT=nil;local bA=0;bN=bN<0 and 0 or bN;local bU=bL+bN+1;for W=0,bU+1 do local U=W<=bL and(bK[W]or 0)or(W<=bU and(bM[W-bL-1]or 0)or nil)if U==bT then bA=bA+1;if U~=0 and bA==6 then bO=bO+1;bP[bO]=16;bR=bR+1;bS[bR]=3;bQ[16]=(bQ[16]or 0)+1;bA=0 elseif U==0 and bA==138 then bO=bO+1;bP[bO]=18;bR=bR+1;bS[bR]=127;bQ[18]=(bQ[18]or 0)+1;bA=0 end else if bA==1 then bO=bO+1;bP[bO]=bT;bQ[bT]=(bQ[bT]or 0)+1 elseif bA==2 then bO=bO+1;bP[bO]=bT;bO=bO+1;bP[bO]=bT;bQ[bT]=(bQ[bT]or 0)+2 elseif bA>=3 then bO=bO+1;local bV=bT~=0 and 16 or(bA<=10 and 17 or 18)bP[bO]=bV;bQ[bV]=(bQ[bV]or 0)+1;bR=bR+1;bS[bR]=bA<=10 and bA-3 or bA-11 end;bT=U;if U and U~=0 then bO=bO+1;bP[bO]=U;bQ[U]=(bQ[U]or 0)+1;bA=0 else bA=1 end end end;return bP,bS,bQ end;local function bW(ag,V,bX,bY,bZ)local K=bX-bZ;while K<=bY-15-bZ do V[K],V[K+1],V[K+2],V[K+3],V[K+4],V[K+5],V[K+6],V[K+7],V[K+8],V[K+9],V[K+10],V[K+11],V[K+12],V[K+13],V[K+14],V[K+15]=h(ag,K+bZ,K+15+bZ)K=K+16 end;while K<=bY-bZ do V[K]=h(ag,K+bZ,K+bZ)K=K+1 end;return V end;local function b_(c0,aF,aG,c1,c2,bZ,aE)local c3=aJ[c0]local c4,c5,c6,c7,c8=c3[1],c3[2],c3[3],c3[4],c3[5]local c9=not c4 and c6 or 2147483646;local ca=c8-c8%4/4;local aH;local cb;local cc;local cd=0;if aE then cb=aE.hash_tables;cc=aE.string_table;cd=aE.strlen;assert(c1==1)if c2>=c1 and cd>=2 then aH=cc[cd-1]*65536+cc[cd]*256+aF[1]local V=aG[aH]if not V then V={}aG[aH]=V end;V[#V+1]=-1 end;if c2>=c1+1 and cd>=1 then aH=cc[cd]*65536+aF[1]*256+aF[2]local V=aG[aH]if not V then V={}aG[aH]=V end;V[#V+1]=0 end end;local ce=cd+3;aH=(aF[c1-bZ]or 0)*256+(aF[c1+1-bZ]or 0)local cf={}local cg=0;local ch={}local ci={}local cj=0;local ck={}local cl={}local cm=0;local cn={}local co=0;local cp=false;local cq;local cr;local cs=0;local ct=0;local bH=c1;local cu=c2+(c4 and 1 or 0)while bH<=cu do local cv=bH-bZ;local cw=bZ-3;cq=cs;cr=ct;cs=0;aH=(aH*256+(aF[cv+2]or 0))%16777216;local cx;local cy;local cz=aG[aH]local cA;if not cz then cA=0;cz={}aG[aH]=cz;if cb then cy=cb[aH]cx=cy and#cy or 0 else cx=0 end else cA=#cz;cy=cz;cx=cA end;if bH<=c2 then cz[cA+1]=bH end;if cx>0 and bH+2<=c2 and(not c4 or cq<c6)then local cB=c4 and cq>=c5 and ca or c8;local cC=c2-bH;cC=cC>=257 and 257 or cC;cC=cC+cv;local cD=cv+3;while cx>=1 and cB>0 do local bT=cy[cx]if bH-bT>32768 then break end;if bT<bH then local cE=cD;if bT>=-257 then local cF=bT-cw;while cE<=cC and aF[cF]==aF[cE]do cE=cE+1;cF=cF+1 end else local cF=ce+bT;while cE<=cC and cc[cF]==aF[cE]do cE=cE+1;cF=cF+1 end end;local M=cE-cv;if M>cs then cs=M;ct=bH-bT end;if cs>=c7 then break end end;cx=cx-1;cB=cB-1;if cx==0 and bT>0 and cb then cy=cb[aH]cx=cy and#cy or 0 end end end;if not c4 then cq,cr=cs,ct end;if(not c4 or cp)and(cq>3 or cq==3 and cr<4096)and cs<=cq then local W=r[cq]local cG=t[cq]local cH,cI,cJ;if cr<=256 then cH=u[cr]cJ=v[cr]cI=w[cr]else cH=16;cI=7;local Q=384;local R=512;while true do if cr<=Q then cJ=(cr-R/2-1)%(R/4)break elseif cr<=R then cJ=(cr-R/2-1)%(R/4)cH=cH+1;break else cH=cH+2;cI=cI+1;Q=Q*2;R=R*2 end end end;cg=cg+1;cf[cg]=W;ch[W]=(ch[W]or 0)+1;cj=cj+1;ci[cj]=cH;ck[cH]=(ck[cH]or 0)+1;if cG>0 then local cK=s[cq]cm=cm+1;cl[cm]=cK end;if cI>0 then co=co+1;cn[co]=cJ end;for K=bH+1,bH+cq-(c4 and 2 or 1)do aH=(aH*256+(aF[K-bZ+2]or 0))%16777216;if cq<=c9 then cz=aG[aH]if not cz then cz={}aG[aH]=cz end;cz[#cz+1]=K end end;bH=bH+cq-(c4 and 1 or 0)cp=false elseif not c4 or cp then local W=aF[c4 and cv-1 or cv]cg=cg+1;cf[cg]=W;ch[W]=(ch[W]or 0)+1;bH=bH+1 else cp=true;bH=bH+1 end end;cg=cg+1;cf[cg]=256;ch[256]=(ch[256]or 0)+1;return cf,cl,ch,ci,cn,ck end;local function cL(ch,ck)local cM,cN,bL=bu(ch,15,285)local cO,cP,bN=bu(ck,15,29)local cQ,bS,cR=bJ(cM,bL,cO,bN)local cS,cT=bu(cR,7,18)local cU=0;for K=1,19 do local bs=B[K]local cV=cS[bs]or 0;if cV~=0 then cU=K end end;cU=cU-4;local cW=bL+1-257;local cX=bN+1-1;if cX<0 then cX=0 end;return cW,cX,cU,cS,cT,cQ,bS,cM,cN,cO,cP end;local function cY(cf,ci,cU,cS,cQ,cM,cO)local cZ=17;cZ=cZ+(cU+4)*3;for K=1,#cQ do local W=cQ[K]cZ=cZ+cS[W]if W>=16 then cZ=cZ+(W==16 and 2 or(W==17 and 3 or 7))end end;local c_=0;for K=1,#cf do local W=cf[K]local d0=cM[W]cZ=cZ+d0;if W>256 then c_=c_+1;if W>264 and W<285 then local d1=y[W-256]cZ=cZ+d1 end;local cH=ci[c_]local d2=cO[cH]cZ=cZ+d2;if cH>3 then local cI=(cH-cH%2)/2-1;cZ=cZ+cI end end end;return cZ end;local function d3(b1,d4,cf,cl,ci,cn,cW,cX,cU,cS,cT,cQ,bS,cM,cN,cO,cP)b1(d4 and 1 or 0,1)b1(2,2)b1(cW,5)b1(cX,5)b1(cU,4)for K=1,cU+4 do local bs=B[K]local cV=cS[bs]or 0;b1(cV,3)end;local d5=1;for K=1,#cQ do local W=cQ[K]b1(cT[W],cS[W])if W>=16 then local d6=bS[d5]b1(d6,W==16 and 2 or(W==17 and 3 or 7))d5=d5+1 end end;local c_=0;local d7=0;local d8=0;for K=1,#cf do local d9=cf[K]local bp=cN[d9]local d0=cM[d9]b1(bp,d0)if d9>256 then c_=c_+1;if d9>264 and d9<285 then d7=d7+1;local da=cl[d7]local d1=y[d9-256]b1(da,d1)end;local db=ci[c_]local dc=cP[db]local d2=cO[db]b1(dc,d2)if db>3 then d8=d8+1;local cJ=cn[d8]local cI=(db-db%2)/2-1;b1(cJ,cI)end end end end;local function dd(cf,ci)local cZ=3;local c_=0;for K=1,#cf do local W=cf[K]local d0=E[W]cZ=cZ+d0;if W>256 then c_=c_+1;if W>264 and W<285 then local d1=y[W-256]cZ=cZ+d1 end;local cH=ci[c_]cZ=cZ+5;if cH>3 then local cI=(cH-cH%2)/2-1;cZ=cZ+cI end end end;return cZ end;local function de(b1,d4,cf,cl,ci,cn)b1(d4 and 1 or 0,1)b1(1,2)local c_=0;local d7=0;local d8=0;for K=1,#cf do local df=cf[K]local bp=C[df]local d0=E[df]b1(bp,d0)if df>256 then c_=c_+1;if df>264 and df<285 then d7=d7+1;local da=cl[d7]local d1=y[df-256]b1(da,d1)end;local cH=ci[c_]local dc=G[cH]b1(dc,5)if cH>3 then d8=d8+1;local cJ=cn[d8]local cI=(cH-cH%2)/2-1;b1(cJ,cI)end end end end;local function dg(c1,c2,aZ)assert(c2-c1+1<=65535)local cZ=3;aZ=aZ+3;local b6=(8-aZ%8)%8;cZ=cZ+b6;cZ=cZ+32;cZ=cZ+(c2-c1+1)*8;return cZ end;local function dh(b1,b3,d4,ag,c1,c2,aZ)assert(c2-c1+1<=65535)b1(d4 and 1 or 0,1)b1(0,2)aZ=aZ+3;local b6=(8-aZ%8)%8;if b6>0 then b1(o[b6]-1,b6)end;local di=c2-c1+1;b1(di,16)local dj=255-di%256+(255-(di-di%256)/256)*256;b1(dj,16)b3(ag:sub(c1,c2))end;local function dk(aN,b1,b3,b4,ag,aE)local aF={}local aG={}local d4=nil;local c1;local c2;local dl;local aZ=b4(aU)local ah=#ag;local bZ;local c0;local dm;if aN then if aN.level then c0=aN.level end;if aN.strategy then dm=aN.strategy end end;if not c0 then if ah<2048 then c0=7 elseif ah>65536 then c0=3 else c0=5 end end;while not d4 do if not c1 then c1=1;c2=64*1024-1;bZ=0 else c1=c2+1;c2=c2+32*1024;bZ=c1-32*1024-1 end;if c2>=ah then c2=ah;d4=true else d4=false end;local cf,cl,ch,ci,cn,ck;local cW,cX,cU,cS,cT,cQ,bS,cM,cN,cO,cP;local dn;local dp;local dq;if c0~=0 then bW(ag,aF,c1,c2+3,bZ)if c1==1 and aE then local cc=aE.string_table;local dr=aE.strlen;for K=0,-dr+1<-257 and-257 or-dr+1,-1 do aF[K]=cc[dr+K]end end;if dm==\"huffman_only\"then cf={}bW(ag,cf,c1,c2,c1-1)cl={}ch={}cf[c2-c1+2]=256;for K=1,c2-c1+2 do local W=cf[K]ch[W]=(ch[W]or 0)+1 end;ci={}cn={}ck={}else cf,cl,ch,ci,cn,ck=b_(c0,aF,aG,c1,c2,bZ,aE)end;cW,cX,cU,cS,cT,cQ,bS,cM,cN,cO,cP=cL(ch,ck)dn=cY(cf,ci,cU,cS,cQ,cM,cO)dp=dd(cf,ci)end;dq=dg(c1,c2,aZ)local ds=dq;ds=dp and dp<ds and dp or ds;ds=dn and dn<ds and dn or ds;if c0==0 or dm~=\"fixed\"and dm~=\"dynamic\"and dq==ds then dh(b1,b3,d4,ag,c1,c2,aZ)aZ=aZ+dq elseif dm~=\"dynamic\"and(dm==\"fixed\"or dp==ds)then de(b1,d4,cf,cl,ci,cn)aZ=aZ+dp elseif dm==\"dynamic\"or dn==ds then d3(b1,d4,cf,cl,ci,cn,cW,cX,cU,cS,cT,cQ,bS,cM,cN,cO,cP)aZ=aZ+dn end;if d4 then dl=b4(aU)else dl=b4(aR)end;assert(dl==aZ)if not d4 then local M;if aE and c1==1 then M=0;while aF[M]do aF[M]=nil;M=M-1 end end;aE=nil;M=1;for K=c2-32767,c2 do aF[M]=aF[K-bZ]M=M+1 end;for a6,V in pairs(aG)do local dt=#V;if dt>0 and c2+1-V[1]>32768 then if dt==1 then aG[a6]=nil else local du={}local dv=0;for K=2,dt do M=V[K]if c2+1-M<=32768 then dv=dv+1;du[dv]=M end end;aG[a6]=du end end end end end end;local function dw(ag,aE,aN)local b1,b3,b4=aV()dk(aN,b1,b3,b4,ag,aE)local aZ,dx=b4(aS)local b6=(8-aZ%8)%8;return dx,b6 end;local function dy(ag,aE,aN)local b1,b3,b4=aV()local dz=8;local dA=7;local dB=dA*16+dz;b1(dB,8)local dC=aE and 1 or 0;local dD=2;local dE=dD*64+dC*32;local dF=31-(dB*256+dE)%31;dE=dE+dF;b1(dE,8)if dC==1 then local aC=aE.adler32;local dG=aC%256;aC=(aC-dG)/256;local dH=aC%256;aC=(aC-dH)/256;local dI=aC%256;aC=(aC-dI)/256;local dJ=aC%256;b1(dJ,8)b1(dI,8)b1(dH,8)b1(dG,8)end;dk(aN,b1,b3,b4,ag,aE)b4(aT)local aC=a:Adler32(ag)local dJ=aC%256;aC=(aC-dJ)/256;local dI=aC%256;aC=(aC-dI)/256;local dH=aC%256;aC=(aC-dH)/256;local dG=aC%256;b1(dG,8)b1(dH,8)b1(dI,8)b1(dJ,8)local aZ,dx=b4(aS)local b6=(8-aZ%8)%8;return dx,b6 end;function a:CompressDeflate(ag,aN)local dK,dL=aK(ag,false,nil,true,aN)if not dK then error(\"Usage: LibDeflate:CompressDeflate(str, configs): \"..dL,2)end;return dw(ag,nil,aN)end;function a:CompressDeflateWithDict(ag,aE,aN)local dK,dL=aK(ag,true,aE,true,aN)if not dK then error(\"Usage: LibDeflate:CompressDeflateWithDict\"..\"(str, dictionary, configs): \"..dL,2)end;return dw(ag,aE,aN)end;function a:CompressZlib(ag,aN)local dK,dL=aK(ag,false,nil,true,aN)if not dK then error(\"Usage: LibDeflate:CompressZlib(str, configs): \"..dL,2)end;return dy(ag,nil,aN)end;function a:CompressZlibWithDict(ag,aE,aN)local dK,dL=aK(ag,true,aE,true,aN)if not dK then error(\"Usage: LibDeflate:CompressZlibWithDict\"..\"(str, dictionary, configs): \"..dL,2)end;return dy(ag,aE,aN)end;local function ab(dM,R)return Y(a1(dM,R*8),0xFF)end;function a:CompressGzip(ag,aN)local dK,dL=aK(ag,false,nil,true,aN)if not dK then error(\"Usage: LibDeflate:CompressGzip(str, configs): \"..dL,2)end;local dN,dO=dw(ag,nil,aN)if dN==nil then return dN,dO end;local V=os.time()local dP=0;local a9=self:CRC32(ag)local U=string.len(ag)if aN~=nil and aN.level~=nil then if aN.level==0 then dP=0x04 elseif aN.level==9 then dP=0x02 end end;return i(0x1f,0x8b,8,0,ab(V,0),ab(V,1),ab(V,2),ab(V,3),dP,0xFF)..dN..i(ab(a9,0),ab(a9,1),ab(a9,2),ab(a9,3),ab(U,0),ab(U,1),ab(U,2),ab(U,3))end;local function dQ(dR)local dS=dR;local dT=#dR;local dU=1;local aY=0;local aX=0;local function dV(T)local b2=o[T]local W;if T<=aY then W=aX%b2;aX=(aX-W)/b2;aY=aY-T else local dW=o[aY]local dH,dI,dJ,dX=h(dS,dU,dU+3)aX=aX+((dH or 0)+(dI or 0)*256+(dJ or 0)*65536+(dX or 0)*16777216)*dW;dU=dU+4;aY=aY+32-T;W=aX%b2;aX=(aX-W)/b2 end;return W end;local function dY(dZ,a_,aW)assert(aY%8==0)local d_=aY/8<dZ and aY/8 or dZ;for P=1,d_ do local ab=aX%256;aW=aW+1;a_[aW]=i(ab)aX=(aX-ab)/256 end;aY=aY-d_*8;dZ=dZ-d_;if(dT-dU-dZ+1)*8+aY<0 then return-1 end;for K=dU,dU+dZ-1 do aW=aW+1;a_[aW]=l(dS,K,K)end;dU=dU+dZ;return aW end;local function e0(e1,e2,ds)local W=0;local e3=0;local bH=0;local bA;if ds>0 then if aY<15 and dS then local dW=o[aY]local dH,dI,dJ,dX=h(dS,dU,dU+3)aX=aX+((dH or 0)+(dI or 0)*256+(dJ or 0)*65536+(dX or 0)*16777216)*dW;dU=dU+4;aY=aY+32 end;local b2=o[ds]aY=aY-ds;W=aX%b2;aX=(aX-W)/b2;W=q[ds][W]bA=e1[ds]if W<bA then return e2[W]end;bH=bA;e3=bA*2;W=W*2 end;for T=ds+1,15 do local e4;e4=aX%2;aX=(aX-e4)/2;aY=aY-1;W=e4==1 and W+1-W%2 or W;bA=e1[T]or 0;local e5=W-e3;if e5<bA then return e2[bH+e5]end;bH=bH+bA;e3=e3+bA;e3=e3*2;W=W*2 end;return-10 end;local function e6()return(dT-dU+1)*8+aY end;local function e7()local e8=aY%8;local b2=o[e8]aY=aY-e8;aX=(aX-aX%b2)/b2 end;return dV,dY,e0,e6,e7 end;local function e9(ag,aE)local dV,dY,e0,e6,e7=dQ(ag)local ea={ReadBits=dV,ReadBytes=dY,Decode=e0,ReaderBitlenLeft=e6,SkipToByteBoundary=e7,buffer_size=0,buffer={},result_buffer={},dictionary=aE}return ea end;local function eb(ec,bn,bo)local e1={}local ds=bo;for bs=0,bn do local T=ec[bs]or 0;ds=T>0 and T<ds and T or ds;e1[T]=(e1[T]or 0)+1 end;if e1[0]==bn+1 then return 0,e1,{},0 end;local ed=1;for U=1,bo do ed=ed*2;ed=ed-(e1[U]or 0)if ed<0 then return ed end end;local ee={}ee[1]=0;for U=1,bo-1 do ee[U+1]=ee[U]+(e1[U]or 0)end;local e2={}for bs=0,bn do local T=ec[bs]or 0;if T~=0 then local bZ=ee[T]e2[bZ]=bs;ee[T]=ee[T]+1 end end;return ed,e1,e2,ds end;local function ef(ea,cM,eg,eh,cO,ei,ej)local a_,aW,dV,e0,e6,b0=ea.buffer,ea.buffer_size,ea.ReadBits,ea.Decode,ea.ReaderBitlenLeft,ea.result_buffer;local aE=ea.dictionary;local cc;local dr;local ek=1;if aE and not a_[0]then cc=aE.string_table;dr=aE.strlen;ek=-dr+1;for K=0,-dr+1<-257 and-257 or-dr+1,-1 do a_[K]=p[cc[dr+K]]end end;repeat local bs=e0(cM,eg,eh)if bs<0 or bs>285 then return-10 elseif bs<256 then aW=aW+1;a_[aW]=p[bs]elseif bs>256 then bs=bs-256;local T=x[bs]T=bs>=8 and T+dV(y[bs])or T;bs=e0(cO,ei,ej)if bs<0 or bs>29 then return-10 end;local X=z[bs]X=X>4 and X+dV(A[bs])or X;local el=aW-X+1;if el<ek then return-11 end;if el>=-257 then for P=1,T do aW=aW+1;a_[aW]=a_[el]el=el+1 end else el=dr+el;for P=1,T do aW=aW+1;a_[aW]=p[cc[el]]el=el+1 end end end;if e6()<0 then return 2 end;if aW>=65536 then b0[#b0+1]=m(a_,\"\",1,32768)for K=32769,aW do a_[K-32768]=a_[K]end;aW=aW-32768;a_[aW+1]=nil end until bs==256;ea.buffer_size=aW;return 0 end;local function em(ea)local a_,aW,dV,dY,e6,e7,b0=ea.buffer,ea.buffer_size,ea.ReadBits,ea.ReadBytes,ea.ReaderBitlenLeft,ea.SkipToByteBoundary,ea.result_buffer;e7()local dZ=dV(16)if e6()<0 then return 2 end;local en=dV(16)if e6()<0 then return 2 end;if dZ%256+en%256~=255 then return-2 end;if(dZ-dZ%256)/256+(en-en%256)/256~=255 then return-2 end;aW=dY(dZ,a_,aW)if aW<0 then return 2 end;if aW>=65536 then b0[#b0+1]=m(a_,\"\",1,32768)for K=32769,aW do a_[K-32768]=a_[K]end;aW=aW-32768;a_[aW+1]=nil end;ea.buffer_size=aW;return 0 end;local function eo(ea)return ef(ea,F,D,7,J,H,5)end;local function ep(ea)local dV,e0=ea.ReadBits,ea.Decode;local eq=dV(5)+257;local er=dV(5)+1;local es=dV(4)+4;if eq>286 or er>30 then return-3 end;local cS={}for K=1,es do cS[B[K]]=dV(3)end;local et,eu,ev,ew=eb(cS,18,7)if et~=0 then return-4 end;local cM={}local cO={}local bH=0;while bH<eq+er do local bs;local T;bs=e0(eu,ev,ew)if bs<0 then return bs elseif bs<16 then if bH<eq then cM[bH]=bs else cO[bH-eq]=bs end;bH=bH+1 else T=0;if bs==16 then if bH==0 then return-5 end;if bH-1<eq then T=cM[bH-1]else T=cO[bH-eq-1]end;bs=3+dV(2)elseif bs==17 then bs=3+dV(3)else bs=11+dV(7)end;if bH+bs>eq+er then return-6 end;while bs>0 do bs=bs-1;if bH<eq then cM[bH]=T else cO[bH-eq]=T end;bH=bH+1 end end end;if(cM[256]or 0)==0 then return-9 end;local ex,ey,eg,eh=eb(cM,eq-1,15)if ex~=0 and(ex<0 or eq~=(ey[0]or 0)+(ey[1]or 0))then return-7 end;local ez,eA,ei,ej=eb(cO,er-1,15)if ez~=0 and(ez<0 or er~=(eA[0]or 0)+(eA[1]or 0))then return-8 end;return ef(ea,ey,eg,eh,eA,ei,ej)end;local function eB(ea)local dV=ea.ReadBits;local d4;while not d4 do d4=dV(1)==1;local eC=dV(2)local eD;if eC==0 then eD=em(ea)elseif eC==1 then eD=eo(ea)elseif eC==2 then eD=ep(ea)else return nil,-1 end;if eD~=0 then return nil,eD end end;ea.result_buffer[#ea.result_buffer+1]=m(ea.buffer,\"\",1,ea.buffer_size)local dx=m(ea.result_buffer)return dx end;local function eE(ag,aE)local ea=e9(ag,aE)local dx,eD=eB(ea)if not dx then return nil,eD end;local eF=ea.ReaderBitlenLeft()local eG=(eF-eF%8)/8;return dx,eG end;local function eH(ag,aE)local ea=e9(ag,aE)local dV=ea.ReadBits;local dB=dV(8)if ea.ReaderBitlenLeft()<0 then return nil,2 end;local dz=dB%16;local dA=(dB-dz)/16;if dz~=8 then return nil,-12 end;if dA>7 then return nil,-13 end;local dE=dV(8)if ea.ReaderBitlenLeft()<0 then return nil,2 end;if(dB*256+dE)%31~=0 then return nil,-14 end;local dC=(dE-dE%32)/32%2;local dD=(dE-dE%64)/64%4;if dC==1 then if not aE then return nil,-16 end;local dJ=dV(8)local dI=dV(8)local dH=dV(8)local dG=dV(8)local aD=dJ*16777216+dI*65536+dH*256+dG;if ea.ReaderBitlenLeft()<0 then return nil,2 end;if not az(aD,aE.adler32)then return nil,-17 end end;local dx,eD=eB(ea)if not dx then return nil,eD end;ea.SkipToByteBoundary()local eI=dV(8)local eJ=dV(8)local eK=dV(8)local eL=dV(8)if ea.ReaderBitlenLeft()<0 then return nil,2 end;local eM=eI*16777216+eJ*65536+eK*256+eL;local eN=a:Adler32(dx)if not az(eM,eN)then return nil,-15 end;local eF=ea.ReaderBitlenLeft()local eG=(eF-eF%8)/8;return dx,eG end;function a:DecompressDeflate(ag)local dK,dL=aK(ag)if not dK then error(\"Usage: LibDeflate:DecompressDeflate(str): \"..dL,2)end;return eE(ag)end;function a:DecompressDeflateWithDict(ag,aE)local dK,dL=aK(ag,true,aE)if not dK then error(\"Usage: LibDeflate:DecompressDeflateWithDict(str, dictionary): \"..dL,2)end;return eE(ag,aE)end;function a:DecompressZlib(ag)local dK,dL=aK(ag)if not dK then error(\"Usage: LibDeflate:DecompressZlib(str): \"..dL,2)end;return eH(ag)end;function a:DecompressZlibWithDict(ag,aE)local dK,dL=aK(ag,true,aE)if not dK then error(\"Usage: LibDeflate:DecompressZlibWithDict(str, dictionary): \"..dL,2)end;return eH(ag,aE)end;function a:DecompressGzip(ag)local dK,dL=aK(ag)if not dK then error(\"Usage: LibDeflate:DecompressGzip(str): \"..dL,2)end;if h(string.sub(ag,1,1))~=31 or h(string.sub(ag,2,2))~=139 then return nil,-1 end;if Y(h(string.sub(ag,4,4)),0xE0)~=0 then return nil,-3 end;if h(string.sub(ag,3,3))~=8 then return nil,-4 end;local bZ=10;if Y(h(string.sub(ag,4,4)),4)==4 then bZ=bZ+h(string.sub(ag,11,11))*256+h(string.sub(ag,12,12))end;if Y(h(string.sub(ag,4,4)),8)==8 then while h(string.sub(ag,bZ,bZ))~=0 do bZ=bZ+1 end end;if Y(h(string.sub(ag,4,4)),16)==16 then while h(string.sub(ag,bZ,bZ))~=0 do bZ=bZ+1 end end;if Y(h(string.sub(ag,4,4)),2)==2 then local eO=h(string.sub(ag,bZ+1,bZ+1))*256+h(string.sub(ag,bZ,bZ))local eP=Y(self:CRC32(string.sub(ag,1,bZ-1)),0xFFFF)if _(eO,eP)~=0xFFFF then return nil,-5 end;bZ=bZ+2 end;local dN,dO=eE(string.sub(ag,bZ+1,-8))if dN==nil then return dN,dO end;local eO=h(string.sub(ag,-5,-5))*0x1000000+h(string.sub(ag,-6,-6))*0x10000+h(string.sub(ag,-7,-7))*256+h(string.sub(ag,-8,-8))eO=Z(eO)local eP=self:CRC32(dN)if _(eO,eP)~=0xFFFFFFFF then return nil,-2 end;return dN end;do E={}for eQ=0,143 do E[eQ]=8 end;for eQ=144,255 do E[eQ]=9 end;for eQ=256,279 do E[eQ]=7 end;for eQ=280,287 do E[eQ]=8 end;I={}for X=0,31 do I[X]=5 end;local eD;eD,F,D=eb(E,287,9)assert(eD==0)eD,J,H=eb(I,31,5)assert(eD==0)C=bk(F,E,287,9)G=bk(J,I,31,5)end;a.internals={LoadStringToTable=bW,IsValidDictionary=aI,IsEqualAdler32=az,_byte_to_6bit_char=_byte_to_6bit_char,_6bit_to_byte=_6bit_to_byte,InternalClearCache=InternalClearCache}return a\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292671,size=27630},["muxzcat.lua"]={type="file",created=1740881292925,worldPermissions={execute=false,read=true,write=false},data="local a;if bit32~=nil then a=bit32 elseif pcall(require,\"bit32\")then a=require\"bit32\"elseif pcall(require,\"bit\")then a=require\"bit\"elseif bit~=nil then a=bit else local function b(c)if c-math.floor(c)>0 then error(\"trying to use bitwise operation on non-integer!\")end end;local function d(c)b(c)if c<0 then return d(a.bnot(math.abs(c))+1)end;local e={}local f=1;while c>0 do local g=math.mod(c,2)if g==1 then e[f]=1 else e[f]=0 end;c=(c-g)/2;f=f+1 end;return e end;local function h(e)local c=table.getn(e)local i=0;local j=1;for k=1,c do i=i+e[k]*j;j=j*2 end;return i end;local function l(m,n)local o={}local p={}if table.getn(m)>table.getn(n)then o=m;p=n else o=n;p=m end;for k=table.getn(p)+1,table.getn(o)do p[k]=0 end end;local function q(r,c)local m=d(r)local n=d(c)l(m,n)local e={}local i=math.max(table.getn(m),table.getn(n))for k=1,i do if m[k]==0 and n[k]==0 then e[k]=0 else e[k]=1 end end;return h(e)end;local function s(r,c)local m=d(r)local n=d(c)l(m,n)local e={}local i=math.max(table.getn(m),table.getn(n))for k=1,i do if m[k]==0 or n[k]==0 then e[k]=0 else e[k]=1 end end;return h(e)end;local function t(c)local e=d(c)local u=math.max(table.getn(e),32)for k=1,u do if e[k]==1 then e[k]=0 else e[k]=1 end end;return h(e)end;local function v(r,c)local m=d(r)local n=d(c)l(m,n)local e={}local i=math.max(table.getn(m),table.getn(n))for k=1,i do if m[k]~=n[k]then e[k]=1 else e[k]=0 end end;return h(e)end;local function w(c,x)b(c)local y=0;if c<0 then c=t(math.abs(c))+1;y=2147483648 end;for k=1,x do c=c/2;c=q(math.floor(c),y)end;return math.floor(c)end;local function z(c,x)b(c)if c<0 then c=t(math.abs(c))+1 end;for k=1,x do c=c/2 end;return math.floor(c)end;local function A(c,x)b(c)if c<0 then c=t(math.abs(c))+1 end;for k=1,x do c=c*2 end;return s(c,4294967295)end;a={bnot=t,band=s,bor=q,bxor=v,brshift=w,blshift=A,blogic_rshift=z}end;if a.blogic_rshift then a={arshift=a.brshift,band=a.band,bnot=a.bnot,bor=a.bor,btest=function(B,C)return a.band(B,C)~=0 end,bxor=a.bxor,lshift=a.blshift,rshift=a.blogic_rshift}end;local D={}local E={}local F={}local G={}local H={}local I={}setmetatable(D,{__sub=function(J)local K={J,__sub=function(self,C)return a.band(self[1],C)end}return setmetatable(K,K)end})setmetatable(E,{__sub=function(J)local K={J,__sub=function(self,C)return a.bor(self[1],C)end}return setmetatable(K,K)end})setmetatable(F,{__sub=function(J)local K={J,__sub=function(self,C)return a.bxor(self[1],C)end}return setmetatable(K,K)end})setmetatable(H,{__sub=function(J)local K={J,__sub=function(self,C)return a.lshift(self[1],C)end}return setmetatable(K,K)end})setmetatable(I,{__sub=function(J)local K={J,__sub=function(self,C)return a.rshift(self[1],C)end}return setmetatable(K,K)end})setmetatable(G,{__sub=function(L,M)return a.bnot(M)end})local N,O;local function P(Q,k,c,...)if c~=nil then Q[k]=c;return P(Q,k+1,...)end end;local function R(B,S,u)local T;if N then T,N=N:sub(1,u),N:sub(u+1)for k=1,#T,256 do P(B,S+k-1,T:byte(k,k+256))end;return#T else T=io.input():read(u)for k=1,#T,256 do P(B,S+k-1,T:byte(k,k+256))end;return#T end end;local function U(Q,k,V)if k==V then return Q[k]elseif k>V then return nil else return Q[k],U(Q,k+1,V)end end;local function W(B,S,u)if O then for k=S,S+u-1,256 do O=O..string.char(U(B,k,math.min(S+u-1,k+255)))end;return u else for k=1,u,256 do io.output():write(string.char(U(B,k+S-1,math.min(S+u-1,k+S+254))))end;return u end end;local X=0;local Y=0;local Z=0;local _=0;local a0=0;local a1=0;local a2=0;local a3=0;local a4=0;local a5=1;local a6=1;local a7=1;local a8=1;local a9=0;local aa=0;local ab=0;local ac=0;local ad=0;local ae=0;local af=0;local ag=0;local ah=0;local ai=0;local aj=0;local ak=0;local al=0;local am={}local an=setmetatable({},{__index=function(L,ao)return am[ao]end,__newindex=function(L,ao,ap)am[ao]=ap-D-0xFFFF end})local aq={}local ar=setmetatable({},{__index=function(L,ao)return aq[ao]end,__newindex=function(L,ao,ap)aq[ao]=ap-D-0xFF end})local as={}local at=setmetatable({},{__index=function(L,ao)return as[ao]end,__newindex=function(L,ao,ap)as[ao]=ap-D-0xFF end})local function au()X=0;Y=0;Z=0;_=0;a0=0;a1=0;a2=0;a3=0;a4=0;a5=1;a6=1;a7=1;a8=1;a9=0;aa=0;ab=0;ac=0;ad=0;ae=0;af=0;ag=0;ah=0;ai=0;aj=0;ak=0;al=0;am={}aq={}as={}end;local function av(aw)if a9~=0 and a9<274 then local ax=a9;if aw-a0<ax then ax=aw-a0 end;if a3==0 and Y-a2<=ax then a3=Y end;a2=a2+ax;a9=a9-ax;while ax~=0 do ax=ax-1;at[a0]=at[a0-a5+(a0<a5 and a1 or 0)]-D-0xFF;a0=a0+1 end end end;local function ay(az,aA)local aB=1-H-ak-1;local aC=1-H-aj-1;local aD=0;repeat local aE=a3==0 and Y-a2<az-a0 and a0+Y-a2 or az;a9=0;repeat local aF=0;local aG=0;local aH=0;local aI=0;local aJ=a2-D-aB;aF=0+a4-H-4+aJ;aH=an[aF]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then local aK=0;assert(aH<=0x7fffffff and aH<=2048)Z=aG;an[aF]=aH+a.rshift(2048-aH,5)aF=1846;if a3~=0 or a2~=0 then aF=aF+768*(a2-D-aC-H-ai+a.rshift(at[(a0==0 and a1 or a0)-1],al))end;if a4<7 then a4=a4-(a4<4 and a4 or 3)aK=1;repeat aH=an[aF+aK]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aF+aK]=aH+a.rshift(2048-aH,5)aK=aK+aK else Z=Z-aG;_=_-aG;an[aF+aK]=aH-a.rshift(aH,5)aK=aK+aK+1 end until not(aK<0x100)else local aL=at[a0-a5+(a0<a5 and a1 or 0)]local aM=0x100;a4=a4-(a4<10 and 3 or 6)aK=1;repeat local aN;local aO;assert(aM==0 or aM==0x100)aL=aL-H-1;aN=aL-D-aM;aO=aF+aM+aN+aK;aH=an[aO]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aO]=aH+a.rshift(2048-aH,5)aK=aK+aK;aM=aM-D-(G-aN)else Z=Z-aG;_=_-aG;an[aO]=aH-a.rshift(aH,5)aK=aK+aK+1;aM=aM-D-aN end until not(aK<0x100)end;at[a0]=aK-D-0xFF;a0=a0+1;a2=a2+1 else Z=Z-aG;_=_-aG;an[aF]=aH-a.rshift(aH,5)aF=192+a4;aH=an[aF]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;local aP=true;if _<aG then assert(aH<=0x7fffffff and aH<=2048)Z=aG;an[aF]=aH+a.rshift(2048-aH,5)a4=a4+12;aF=818 else Z=Z-aG;_=_-aG;an[aF]=aH-a.rshift(aH,5)if a3==0 and a2==0 then return 1 end;aF=204+a4;aH=an[aF]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then assert(aH<=0x7fffffff and aH<=2048)Z=aG;an[aF]=aH+a.rshift(2048-aH,5)aF=240+a4-H-4+aJ;aH=an[aF]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aF]=aH+a.rshift(2048-aH,5)at[a0]=at[a0-a5+(a0<a5 and a1 or 0)]-D-0xFF;a0=a0+1;a2=a2+1;a4=a4<7 and 9 or 11;aP=false end;if aP then Z=Z-aG;_=_-aG;an[aF]=aH-a.rshift(aH,5)end else Z=Z-aG;_=_-aG;an[aF]=aH-a.rshift(aH,5)aF=216+a4;aH=an[aF]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aF]=aH+a.rshift(2048-aH,5)aI=a6 else Z=Z-aG;_=_-aG;an[aF]=aH-a.rshift(aH,5)aF=228+a4;aH=an[aF]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aF]=aH+a.rshift(2048-aH,5)aI=a7 else Z=Z-aG;_=_-aG;an[aF]=aH-a.rshift(aH,5)aI=a8;a8=a7 end;a7=a6 end;a6=a5;a5=aI end;if aP then a4=a4<7 and 8 or 11;aF=1332 end end;if aP then do local aQ;local aR;local aS=aF+0;aH=an[aS]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then assert(aH<=0x7fffffff and aH<=2048)Z=aG;an[aS]=aH+a.rshift(2048-aH,5)aS=aF+2+aJ-H-3;aR=0;aQ=8 else Z=Z-aG;_=_-aG;an[aS]=aH-a.rshift(aH,5)aS=aF+1;aH=an[aS]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then assert(aH<=0x7fffffff and aH<=2048)Z=aG;an[aS]=aH+a.rshift(2048-aH,5)aS=aF+130+aJ-H-3;aR=8;aQ=8 else Z=Z-aG;_=_-aG;an[aS]=aH-a.rshift(aH,5)aS=aF+258;aR=8+8;aQ=256 end end;do a9=1;repeat aH=an[aS+a9]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aS+a9]=aH+a.rshift(2048-aH,5)a9=a9+a9 else Z=Z-aG;_=_-aG;an[aS+a9]=aH-a.rshift(aH,5)a9=a9+a9+1 end until not(a9<aQ)a9=a9-aQ end;a9=a9+aR end;if a4>=12 then aF=432+(a9<4 and a9 or 4-1)-H-6;do aI=1;repeat aH=an[aF+aI]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aF+aI]=aH+a.rshift(2048-aH,5)aI=aI+aI else Z=Z-aG;_=_-aG;an[aF+aI]=aH-a.rshift(aH,5)aI=aI+aI+1 end until not(aI<64)aI=aI-64 end;assert(aI<=0x7fffffff and aI<64)if aI>=4 then local aT=aI;local aU=a.rshift(aI,1)-1;aI=2-E-(aI-D-1)if aT<14 then aI=aI-H-aU;aF=688+aI-aT-1;do local aV=1;aD=1;repeat aH=an[aF+aD]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aF+aD]=aH+a.rshift(2048-aH,5)aD=aD+aD else Z=Z-aG;_=_-aG;an[aF+aD]=aH-a.rshift(aH,5)aD=aD+aD+1;aI=aI-E-aV end;aV=aV-H-1;aU=aU-1 until not(aU~=0)end else aU=aU-4;repeat if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;Z=a.rshift(Z,1)if _-Z-D-0x80000000~=0 then aI=aI-H-1 else _=_-Z;aI=aI-H-1+1 end;aU=aU-1 until not(aU~=0)aF=802;aI=aI-H-4;do aD=1;aH=an[aF+aD]assert(aH<=0x7fffffff and aH<=2048)if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aF+aD]=aH+a.rshift(2048-aH,5)aD=aD+aD else Z=Z-aG;_=_-aG;an[aF+aD]=aH-a.rshift(aH,5)aD=aD+aD+1;aI=aI-E-1 end;aH=an[aF+aD]assert(aH<=0x7fffffff and aH<=2048)if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aF+aD]=aH+a.rshift(2048-aH,5)aD=aD+aD else Z=Z-aG;_=_-aG;an[aF+aD]=aH-a.rshift(aH,5)aD=aD+aD+1;aI=aI-E-2 end;aH=an[aF+aD]assert(aH<=0x7fffffff and aH<=2048)if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aF+aD]=aH+a.rshift(2048-aH,5)aD=aD+aD else Z=Z-aG;_=_-aG;an[aF+aD]=aH-a.rshift(aH,5)aD=aD+aD+1;aI=aI-E-4 end;aH=an[aF+aD]assert(aH<=0x7fffffff and aH<=2048)if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aF+aD]=aH+a.rshift(2048-aH,5)aD=aD+aD else Z=Z-aG;_=_-aG;an[aF+aD]=aH-a.rshift(aH,5)aD=aD+aD+1;aI=aI-E-8 end end;if G-aI==0 then a9=a9+274;a4=a4-12;break end end end;assert(aI<=0x7fffffff and aI<=1610612736)a8=a7;a7=a6;a6=a5;a5=aI+1;if a3==0 then if aI>=a2 then return 1 end else if aI>=a3 then return 1 end end;a4=a4<12+7 and 7 or 7+3 end;a9=a9+2;if aE==a0 then return 1 end;do local aW=aE-a0;local aX=aW<a9 and aW or a9;local aY=a0-a5+(a0<a5 and a1 or 0)a2=a2+aX;a9=a9-aX;if aY+aX<=a1 then assert(a0>aY)assert(aX>0)repeat at[a0]=at[aY]-D-0xFF;a0=a0+1;aY=aY+1;aX=aX-1 until not(aX~=0)else repeat at[a0]=at[aY]-D-0xFF;a0=a0+1;aY=aY+1;if aY==a1 then aY=0 end until not(aX~=0)end end end end until not(a0<aE and X<aA)if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;if a2>=Y then a3=Y end;av(az)until not(a0<az and X<aA and a9<274)if a9>274 then a9=274 end;return 0 end;local function aZ(a_,b0)local b1=Z;local b2=_;local b3=a4;local b4;local b5;local b6;local b7;local b8=a2-D-(1-H-ak-1)b5=0+b3-H-4+b8;b7=an[b5]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then local b9=1;b1=b6;b5=1846;if a3~=0 or a2~=0 then b5=b5+768*(a2-D-(1-H-aj-1)-H-ai+a.rshift(at[(a0==0 and a1 or a0)-1],al))end;if b3<7 then repeat b7=an[b5+b9]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6;b9=b9+b9 else b1=b1-b6;b2=b2-b6;b9=b9+b9+1 end until not(b9<0x100)else local ba=at[a0-a5+(a0<a5 and a1 or 0)]local bb=0x100;repeat local bc;local bd;assert(bb==0 or bb==0x100)ba=ba-H-1;bc=ba-D-bb;bd=b5+bb+bc+b9;b7=an[bd]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6;b9=b9+b9;bb=bb-D-(G-bc)else b1=b1-b6;b2=b2-b6;b9=b9+b9+1;bb=bb-D-bc end until not(b9<0x100)end;b4=1 else local be;b1=b1-b6;b2=b2-b6;b5=192+b3;b7=an[b5]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6;b3=0;b5=818;b4=2 else b1=b1-b6;b2=b2-b6;b4=3;b5=204+b3;b7=an[b5]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6;b5=240+b3-H-4+b8;b7=an[b5]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6;if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;return 3 else b1=b1-b6;b2=b2-b6 end else b1=b1-b6;b2=b2-b6;b5=216+b3;b7=an[b5]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6 else b1=b1-b6;b2=b2-b6;b5=228+b3;b7=an[b5]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6 else b1=b1-b6;b2=b2-b6 end end end;b3=12;b5=1332 end;do local bf;local bg;local bh=b5+0;b7=an[bh]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6;bh=b5+2+b8-H-3;bg=0;bf=8 else b1=b1-b6;b2=b2-b6;bh=b5+1;b7=an[bh]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6;bh=b5+130+b8-H-3;bg=8;bf=8 else b1=b1-b6;b2=b2-b6;bh=b5+258;bg=8+8;bf=256 end end;do be=1;repeat b7=an[bh+be]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6;be=be+be else b1=b1-b6;b2=b2-b6;be=be+be+1 end until not(be<bf)be=be-bf end;be=be+bg end;if b3<4 then local bi;b5=432+(be<4 and be or 4-1)-H-6;do bi=1;repeat b7=an[b5+bi]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6;bi=bi+bi else b1=b1-b6;b2=b2-b6;bi=bi+bi+1 end until not(bi<64)bi=bi-64 end;assert(bi<=0x7fffffff and bi<64)if bi>=4 then local bj=a.rshift(bi,1)-1;if bi<14 then b5=688+2-E-(bi-D-1)-H-bj-bi-1 else bj=bj-4;repeat if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b1=a.rshift(b1,1)if b2-b1-D-0x80000000==0 then b2=b2-b1 end;bj=bj-1 until not(bj~=0)b5=802;bj=4 end;do local bk=1;repeat b7=an[b5+bk]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6;bk=bk+bk else b1=b1-b6;b2=b2-b6;bk=bk+bk+1 end;bj=bj-1 until not(bj~=0)end end end end;if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;return b4 end;local function bl(bm,bn)ad=1;a9=0;aa=0;if bm~=0 then a2=0;a3=0;ae=1 end;if bn~=0 then ae=1 end end;local function bo(bp)local bq=ab+bp;local br;local bs;av(a1)while a9~=274 do if ad~=0 then while bq>ab and aa<5 do ar[6+65536+6+aa]=ar[ab]aa=aa+1;ab=ab+1 end;if aa<5 then end;if ar[6+65536+6]~=0 then return 1 end;_=ar[6+65536+6+1]-H-24-E-(ar[6+65536+6+2]-H-16)-E-(ar[6+65536+6+3]-H-8)-E-ar[6+65536+6+4]Z=0xffffffff;ad=0;aa=0 end;br=0;if a0>=a1 then if a9==0 and _==0 then if ab~=bq then return 18 end;return 0 end;if a9~=0 then return 16 end;br=1 end;if ae~=0 then local bt=1846+768-H-(ai+aj)for bu=0,bt-1,1 do an[bu]=a.rshift(2048,1)end;a8=1;a7=a8;a6=a7;a5=a6;a4=0;ae=0 end;if aa==0 then local bv;if bq-ab<20 or br~=0 then bs=aZ(ab,bq)if bs==0 then aa=0;while ab~=bq do ar[6+65536+6+aa]=ar[ab]aa=aa+1;ab=ab+1 end;if ab~=bq then return 17 end;return 17 end;if br~=0 and bs~=2 then return 16 end;bv=ab else bv=bq-20 end;X=ab;if ay(a1,bv)~=0 then return 1 end;ab=X else local bw=aa;local bx=0;while bw<20 and bx<bq-ab do ar[6+65536+6+bw]=ar[ab+bx]bw=bw+1;bx=bx+1 end;aa=bw;if bw<20 or br~=0 then bs=aZ(6+65536+6,6+65536+6+bw)if bs==0 then ab=ab+bx;if ab~=bq then return 17 end;return 17 end;if br~=0 and bs~=2 then return 16 end end;X=6+65536+6;if ay(0,6+65536+6)~=0 then return 1 end;bx=bx-bw-(X-(6+65536+6))ab=ab+bx;aa=0 end end;if _~=0 then return 1 end;return 15 end;local function by(bz)local bA=ac-ab;local bB;assert(bz<=6+65536+6)if bA<bz then if 6+65536+6-ab<bz then ac=0;while ac<bA do ar[ac]=ar[ab+ac]ac=ac+1 end;ab=0 end;while bA<bz do bB=R(ar,ac,bz-bA)if bB+1<=1 then break end;ac=ac+bB;bA=bA+bB end end;return bA end;local function bC()while ar[ab]>=0x80 do ab=ab+1 end;ab=ab+1 end;local function bD(bE)while bE~=0 do ab=ab+1;if ar[ab-1]~=0 then return 57 end;bE=bE-1 end;return 0 end;local function bF(bG)return a.band(ar[bG],0xff)+a.blshift(a.band(ar[bG+1],0xff),8)+a.blshift(a.band(ar[bG+2],0xff),16)+bit.blshift(a.band(ar[bG+3],0xff),24)end;local function bH()a1=0;af=1;ag=1;ah=1;a0=0;bl(1,1)end;local function bI(bJ)if bJ>=9*5*5 then return 68 end;ai=bJ%9;al=8-ai;bJ=math.floor(bJ/9)ak=math.floor(bJ/5)aj=bJ%5;if ai+aj>4 then return 68 end;ah=0;return 0 end;local function bK(bL)while bL~=a0 do local bM=W(at,bL,a0-bL)if bM-D-0x80000000~=0 then return 9 end;bL=bL+bM end;return 0 end;local function bN()local bO;local bP;local bQ;if by(12+12+6)<12+12+6 then return 6 end;if ar[0]==0xfd and ar[1]==0x37 and ar[2]==0x7a and ar[3]==0x58 and ar[4]==0x5a and ar[5]==0 and ar[6]==0 then elseif ar[ab]<=225 and ar[ab+13]==0 and((function()bP=bF(ab+9)return bP end)()==0 or G-bP==0)and(function()Y=bF(ab+1)return Y end)()>=4096 and Y<a.band(1610612736+1,0x7fffffff)then local bR;local bS;local bT;bH()if(function()bQ=bI(ar[ab])return bQ end)()~=0 then return bQ end;if bP==0 then bR=bF(ab+5)a1=bR;if not(bR<a.band(1610612736+1,0x7fffffff))then return 2 end else bR=bP;a1=1610612736 end;ab=ab+13;while(function()bS=by(6+65536+6)return bS end)()~=0 do bT=a0;bQ=bo(bS)if bR<a0 then a0=bR end;if(function()bQ=bK(bT)return bQ end)()~=0 then return bQ end;if bQ==15 then break end;if bQ~=17 and bQ~=0 then return bQ end;if a0-bR==0 then break end end;return 0 else return 51 end;bO=ar[ab+7]if bO==0 then bO=1 elseif bO==1 then bO=4 elseif bO==4 then bO=8 elseif bO==10 then bO=32 else return 60 end;ab=ab+12;while true do local bU=3;local bV;local bW;local bX;local bY;assert(ac-ab>=12)bY=ab;ab=ab+1;if(function()bV=ar[ab-1]return bV end)()==0 then break end;bV=bV+1-H-2;if by(bV)<bV then return 6 end;bY=ab;bP=ar[ab]ab=ab+1;if bP-D-2~=0 then return 53 end;if bP-D-20~=0 then return 54 end;if bP-D-64~=0 then bC()end;if bP-D-128~=0 then bC()end;if ar[ab]~=0x21 then return 55 end;ab=ab+1;if ar[ab]~=1 then return 56 end;ab=ab+1;bX=ar[ab]ab=ab+1;if bX>40 then return 61 end;if bX>37 then return 62 end;Y=2-E-(bX-D-1)-H-(math.floor(bX/2)+11)assert(Y>=4096)bW=ab-bY+5;if bW>bV then return 58 end;if(function()bQ=bD(bV-bW)return bQ end)()~=0 then return bQ end;ab=ab+4;do local bZ;local b_;local c0;bH()while true do local c1;assert(a0==a1)if by(6)<6 then return 6 end;c1=ar[ab]if c1==0 then ab=ab+1;break elseif a.band(c1-3,0xff)<0x80-3 then return 59 end;bZ=ar[ab+1]-H-8+ar[ab+2]+1;if c1<3 then c0=c1==1 and 1 or 0;b_=bZ;ab=ab+3;bU=bU-3;if c0~=0 then ag=1;ah=ag;af=0 elseif af~=0 then return 1 end;bl(c0,0)else local c2=a.rshift(c1,5)-D-3;local c3=c2~=0 and 1 or 0;local c4=c1-D-64~=0 and 1 or 0;c0=c2==3 and 1 or 0;bZ=bZ+c1-D-31-H-16;b_=ar[ab+3]-H-8+ar[ab+4]+1;if c4~=0 then if(function()bQ=bI(ar[ab+5])return bQ end)()~=0 then return bQ end;ab=ab+1;bU=bU-1 else if ah~=0 then return 67 end end;ab=ab+5;bU=bU-5;if c0==0 and af~=0 or c3==0 and ag~=0 then return 1 end;bl(c0,c3)af=0;ag=0 end;assert(a0==a1)a1=a1+bZ;if a1>1610612736 then return 2 end;if by(b_+6)<b_ then return 6 end;if c1<0x80 then while a0~=a1 do at[a0]=ar[ab]-D-0xFF;a0=a0+1;ab=ab+1 end;if a3==0 and Y-a2<=bZ then a3=Y end;a2=a2+bZ else if(function()bQ=bo(b_)return bQ end)()~=0 then return bQ end end;if a0~=a1 then return 65 end;if(function()bQ=bK(a0-bZ)return bQ end)()~=0 then return bQ end;bU=bU-b_ end end;if by(7+12+6)<7+12+6 then return 6 end;if(function()bQ=bD(bU-D-3)return bQ end)()~=0 then return bQ end;ab=ab+bO end;return 0 end;local c5={UNKNOWN_ERROR=-1,OK=0,ERROR_DATA=1,ERROR_MEM=2,ERROR_CRC=3,ERROR_UNSUPPORTED=4,ERROR_PARAM=5,ERROR_INPUT_EOF=6,ERROR_OUTPUT_EOF=7,ERROR_READ=8,ERROR_WRITE=9,ERROR_FINISHED_WITH_MARK=15,ERROR_NOT_FINISHED=16,ERROR_NEEDS_MORE_INPUT=17,ERROR_CHUNK_NOT_CONSUMED=18,ERROR_NEEDS_MORE_INPUT_PARTIAL=17,ERROR_BAD_MAGIC=51,ERROR_BAD_STREAM_FLAGS=52,ERROR_UNSUPPORTED_FILTER_COUNT=53,ERROR_BAD_BLOCK_FLAGS=54,ERROR_UNSUPPORTED_FILTER_ID=55,ERROR_UNSUPPORTED_FILTER_PROPERTIES_SIZE=56,ERROR_BAD_PADDING=57,ERROR_BLOCK_HEADER_TOO_LONG=58,ERROR_BAD_CHUNK_CONTROL_BYTE=59,ERROR_BAD_CHECKSUM_TYPE=60,ERROR_BAD_DICTIONARY_SIZE=61,ERROR_UNSUPPORTED_DICTIONARY_SIZE=62,ERROR_FEED_CHUNK=63,ERROR_NOT_FINISHED_WITH_MARK=64,ERROR_BAD_DICPOS=65,ERROR_MISSING_INITPROP=67,ERROR_BAD_LCLPPB_PROP=68}return{DecompressXzOrLzmaFile=function(c6,c7)if type(c6)~=\"userdata\"and(_HOST==nil or type(c6)~=\"table\")and type(c6)~=\"string\"then error(\"bad argument #1 (expected string or file, got \"..type(c6)..\")\",2)end;if type(c7)~=\"userdata\"and(_HOST==nil or type(c7)~=\"table\")and type(c7)~=\"string\"then error(\"bad argument #2 (expected string or file, got \"..type(c7)..\")\",2)end;N=nil;O=nil;local c8=io.input()local c9=io.output()if type(c6)==\"string\"then c6=io.open(c6,\"rb\")if c6==nil then return false,-1 end end;if type(c7)==\"string\"then c7=io.open(c7,\"wb\")if c7==nil then return false,-1 end end;io.input(c6)io.output(c7)au()local ca,cb=pcall(bN)io.input(c8)io.output(c9)c6:close()c7:close()if not ca then if cb then io.stderr:write(cb..\"\\n\")end;return false,-1 else return cb==0,cb end end,DecompressXzOrLzmaString=function(c6)if type(c6)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(c6)..\")\",2)end;N=c6;O=\"\"au()local ca,cb=pcall(bN)if not ca then if cb then io.stderr:write(cb..\"\\n\")end;return-1 elseif cb==0 then return O elseif cb==53 and#O>0 then return O,cb else return nil,cb end end,GetError=function(_)for cc,cd in pairs(c5)do if cd==_ then return cc end end;return nil end,Errors=c5}\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292922,size=21375}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294445,size=0},bin={type="directory",setuser=false,created=1740881294560,worldPermissions={write=false,read=true,execute=true},contents={["useradd.lua"]={type="file",created=1740881294443,worldPermissions={execute=true,read=true,write=false},data="local a=require\"usermgr\"local b=require\"system.filesystem\"local c=require\"system.process\"local d=require\"system.util\"local e=[[\nUsage: useradd [options] LOGIN\n       useradd -D\n       useradd -D [options]\nOptions:\n  -b, --base-dir BASE_DIR  base directory for the home directory of the new account\n  -c, --comment COMMENT    full name of the new account\n  -d, --home-dir HOME_DIR  home directory of the new account\n  -D, --defaults           print or change default useradd configuration\n  -f, --inactive INACTIVE  password inactivity period of the new account\n  -h, --help               display this help message and exit\n  -k, --skel SKEL_DIR      use this alternative skeleton directory\n  -K, --key KEY=VALUE      override /etc/login.defs defaults\n  -m, --create-home        create the user's home directory\n  -M, --no-create-home     do not create the user's home directory\n  -p, --password PASSWORD  password of the new account\n  -s, --shell SHELL        login shell of the new account\n]]local f=assert(d.argparse({b=true,[\"base-dir\"]=\"@b\",c=true,comment=\"@c\",d=true,[\"home-dir\"]=\"@d\",D=false,defaults=\"@D\",f=\"number\",inactive=\"@f\",h=false,help=\"@h\",k=true,skel=\"@k\",K=\"multiple\",key=\"@K\",m=false,[\"create-home\"]=\"@m\",M=false,[\"no-create-home\"]=\"@M\",p=true,password=\"@p\",s=true,shell=\"@s\"},...))if f.h then print(e)return end;local g={HOME=\"/home\",INACTIVE=-1,SHELL=\"/bin/cash\",SKEL=\"/etc/skel\"}do local h=io.open(\"/etc/default/useradd\",\"r\")if h then for i in h:lines()do local j,k=i:gsub(\"#.*$\",\"\"):match\"^([^=]+)=(.*)$\"if j and k then g[j]=type(g[j])==\"number\"and tonumber(k)or k end end;h:close()end end;for l,i in ipairs(f.K or{})do local j,k=i:match\"^([^=]+)=(.*)$\"if j and k then g[j]=type(g[j])==\"number\"and tonumber(k)or k end end;if f.D then if f.b or f.f or f.s then if c.getuser()~=\"root\"then error(\"useradd: Permission denied.\")end;if f.b then g.HOME=f.b end;if f.f then g.INACTIVE=f.f end;if f.s then g.SHELL=f.s end;local h=assert(io.open(\"/etc/default/useradd\",\"w\"))for m,n in pairs(g)do h:write(m..\"=\"..n..\"\\n\")end;h:close()else for m,n in pairs(g)do print(m..\"=\"..n)end end;return end;if not f[1]then io.stderr:write(e..\"\\n\")return false end;if c.getuser()~=\"root\"then error(\"useradd: Permission denied.\")end;local o=f.d or b.combine(f.b or g.HOME,f[1])local p=f.f or g.INACTIVE;if p<0 then p=nil end;assert(a.addUser(f[1],f.p,{fullName=f.c,home=o,shell=f.s or g.SHELL,lockTime=p}))if f.m and not f.M then b.mkdir(o)b.chmod(o,f[1],\"rwx\")b.chmod(o,nil,\"r-x\")b.chown(o,f[1])local q=f.k or g.SKEL;if q and b.isDir(q)then local function r(s)local t=b.stat(s,true)if t.permissions[t.owner]then b.chmod(s,f[1],t.permissions[t.owner])end;b.chown(s,f[1])if t.type==\"directory\"then for l,n in ipairs(b.list(s))do r(b.combine(s,n))end end end;for l,n in ipairs(b.list(q))do b.copy(b.combine(q,n),b.combine(o,n),true)r(b.combine(o,n))end end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294388,size=2857},["add-apt-repository.lua"]={type="file",created=1740881291211,worldPermissions={write=false,read=true,execute=true},data="local a=require\"system.network\"local b=require\"system.serialization\"local c=require\"system.util\"local d=require\"pgp\"local e=assert(c.argparse({h=false,help=\"@h\",d=false,debug=\"@d\",r=false,remove=\"@r\",s=false,[\"enable-source\"]=\"@s\",c=\"multiple\",component=\"@c\",p=true,pocket=\"@p\",y=false,yes=\"@y\",l=false,login=\"@l\",[\"dry-run\"]=false,L=false,list=\"@L\",P=true,ppa=\"@P\",C=true,cloud=\"@C\",U=true,uri=\"@U\",S=false,sourceslist=\"@S\"},...))local f,g,h=nil,e.p or\"release\",e.c and table.concat(e.c,\" \")or\"main\"if e.P then local i,j=e.P:match\"^ppa:(%w+)/(%w+)$\"if not i then i,j=e.P:match\"^(%w+)/(%w+)$\"if not i then i,j=e.P:match\"^%w+$\",\"ppa\"if not i then error(\"Invalid PPA specification\")end end end;f=\"https://ppa.launchpadcontent.net/\"..i..\"/\"..j..\"/ubuntu/\"print(\"Querying Launchpad for PPA information...\")local k=assert(a.getData(\"https://api.launchpad.net/1.0/~\"..i..\"/+archive/\"..j,{Accept=\"application/json\"}))local l=assert(b.json.decode(k))print(l.displayname..\": \"..l.description)io.write(\"Continue adding PPA? (Y/n) \")if e.y then print(\"y\")else local m=io.read()if not m:lower():find(\"y\")then print(\"Abort.\")return end end;local n=assert(l.signing_key_fingerprint)print(\"Adding key ID \"..n..\" to trusted.gpg.d...\")local o=assert(a.getData(\"https://keyserver.ubuntu.com/pks/lookup?op=get&search=0x\"..n))local p=d.decodeASC(o)local q=assert(io.open(\"/etc/apt/trusted.gpg.d/ppa-\"..i..\"-\"..j..\".gpg\",\"wb\"))q.write(p)q.close()elseif e.C then elseif e.U then elseif e.S then else end\n",setuser=false,permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881291197,size=1482},["dhclient.lua"]={type="file",created=1740881293042,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.hardware\"local b=require\"system.network\"local c=require\"system.util\"local d=...if not d then error(\"Usage: dhclient <interface>\")end;local e=a.wrap(d)if not e or not a.hasType(e,\"modem\")then error(\"Device does not exist or is not a modem\")end;e:open(68)a.listen(e,true)local f=math.random(0,2^31-1)local g=a.info(\"/\").metadata.id;e:transmit(67,68,{dhcp=true,type=\"discover\",from=g,messageID=f,options={netmask=true}})local h=c.timer(2)local i={}while true do local j,k=coroutine.yield()if j==\"modem_message\"and k.channel==68 and k.replyChannel==67 and type(k.message)==\"table\"and k.message.dhcp==true and k.message.to==g and k.message.messageID==f and k.message.type==\"offer\"then i[k.message.from]={ip=k.message.offeredIP,netmask=k.message.options.netmask,up=true}elseif j==\"timer\"and k.id==h then break end end;if#i==0 then a.listen(e,false)e:close(68)error(\"Could not get IP address: Timed out\")end;for l,m in pairs(i)do b.control(m.ip,\"ping\")c.sleep(2)if not b.arp.list(d)[m.ip]then e:transmit(67,68,{dhcp=true,type=\"request\",from=g,to=l,messageID=f,options={netmask=true}})h=c.timer(2)while true do local j,k=coroutine.yield()if j==\"modem_message\"and k.channel==68 and k.replyChannel==67 and type(k.message)==\"table\"and k.message.dhcp==true and k.message.to==g and k.message.messageID==f and k.message.type==\"acknowledgement\"then b.ipconfig(d,m)a.listen(e,false)e:close(68)c.cancel(h)return elseif j==\"timer\"and k.id==h then a.listen(e,false)e:close(68)error(\"Could not get IP address: No response from server\")end end end end;a.listen(e,false)e:close(68)error(\"Could not get IP address: No usable offers\")\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293037,size=1634},["apt-config.lua"]={type="file",created=1740881291213,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.util\"local b=require\"apt.config\"local c=assert(a.argparse({empty=false,[\"no-empty\"]=false,format=true,h=false,help=\"@h\",v=false,version=\"@v\",c=true,[\"config-file\"]=\"@c\",o=\"multiple\",option=\"@o\"},...))if c.v then print(\"apt-config 1.0\")return end;if not c[1]or c.h then print[[\nUsage: apt-config [options] command\n\napt-config is an interface to the configuration settings used by\nall APT tools, mainly intended for debugging and shell scripting.\n\nMost used commands:\n  shell - get configuration values via shell evaluation\n  dump - show the active configuration setting\n\nSee apt-config(8) for more information about the available commands.\nConfiguration options and syntax is detailed in apt.conf(5).\nInformation about how to configure sources can be found in sources.list(5).\nPackage and version choices can be expressed via apt_preferences(5).\nSecurity details are available in apt-secure(8).\n]]return end;b:load()if c.c then local d=assert(io.open(c.c,\"r\"))local e=d:read(\"*a\")d:close()b:append(e)end;if c.o then for f,g in ipairs(c.o)do local h,i=g:match(\"^([A-Za-z0-9/%-:%._+])=(.*)$\")if not h then error(\"Invalid option: \"..g)end;local j={}for k in h:match(\"[^:]+\")do j[#j+1]=k end;local l=b;for m=1,#j-1 do local k=j[m]:lower()if not l[k]then l[k]={}end;l=l[k]end;l[j[#j]]=i end end;if c[1]==\"dump\"then local n=c.f or'%f \"%v\";%n'local function o(p,h,i)return{[\"%f\"]=p..h,[\"%t\"]=h,[\"%v\"]=i,[\"%n\"]=\"\\n\",[\"%%\"]=\"%\"}end;local function q(p,r)for k,g in pairs(r)do if type(g)==\"table\"then local s=g._ or\"\"if not c[\"no-empty\"]or s~=\"\"then local t=n:gsub(\"%%%a\",o(p,k,s))io.write(t)end;q(p..k..\"::\",g)elseif type(g)==\"string\"and(not c[\"no-empty\"]or g~=\"\")then local t=n:gsub(\"%%%a\",o(p,k,g))io.write(t)end end end;q(\"\",b)else error(\"Unknown command '\"..c[1]..\"'\")end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291198,size=1788},["login.lua"]={type="file",created=1740881294441,worldPermissions={write=false,read=true,execute=true},data="local a=require\"usermgr\"local b=require\"system.ipc\"local c=require\"system.process\"local d=require\"system.terminal\"local e=require\"system.util\"print()while b.lookup(\"usermgr\")==nil do e.sleep(0.1)end;if c.getuser()~=\"root\"then error(\"This program must be run as root. Make sure the setuser bit is set.\")end;for f,g in pairs(b.signal)do b.sigaction(g,nil)end;b.sigaction(b.signal.SIGHUP,function()return c.exit(-1)end)while true do print(\"Phoenix \"..e.syscall.version()..\"\\n\")io.stdout:write(\"login: \")local h=io.stdin:read()for i=1,3 do io.stdout:write(\"Password: \")d.termctl({echo=false})local j=io.stdin:read()d.termctl({echo=true})print()local k,l=a.authenticate(h,j)if l then print(l)end;if not k and(l==\"No password set\"or l==\"Password expired\")then repeat until c.run(\"/usr/bin/passwd.lua\",h)end;if k then local m=io.open(\"/etc/motd\",\"r\")if m then print(m:read(\"*a\"))m:close()end;local n=a.getUserInfo(h)local o=c.fork(function()c.setuser(h)if n and n.home then c.getenv().HOME=n.home;c.chdir(n.home)end;if n and n.shell then c.exec(n.shell)else c.exec(\"/bin/sh\")end end)for f,g in pairs(b.signal)do b.sigaction(g,function()b.kill(o,g)end)end;b.sigaction(b.signal.SIGHUP,function()b.kill(o,b.signal.SIGHUP)return c.exit(-1)end)repeat local p,q=coroutine.yield()until p==\"process_complete\"and q.id==o;for f,g in pairs(b.signal)do b.sigaction(g,nil)end;b.sigaction(b.signal.SIGHUP,function()return c.exit(-1)end)break else if i==3 then print(\"login: 3 incorrect password attempts\\n\")e.sleep(2)end end end end\n",setuser=true,permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294386,size=1512},["md5sum.lua"]={type="file",created=1740881293801,worldPermissions={execute=true,read=true,write=false},data="local a=require\"sha2\"local b=require\"system.util\"local c=assert(b.argparse({b=false,binary=\"@b\",c=false,check=\"@c\",tag=false,t=false,text=\"@t\",z=false,zero=\"@z\",[\"ignore-missing\"]=false,quiet=false,status=false,strict=false,w=false,warn=\"@w\",h=false,help=\"@h\",v=false,version=\"@v\"},...))if c.h then print[[\nUsage: md5sum [OPTION]... [FILE]...\nPrint or check MD5 (128-bit) checksums.\n\nWith no FILE, or when FILE is -, read standard input.\n  -b, --binary          read in binary mode\n  -c, --check           read checksums from the FILEs and check them\n      --tag             create a BSD-style checksum\n  -t, --text            read in text mode (default)\n  -z, --zero            end each output line with NUL, not newline,\n                          and disable file name escaping\n\nThe following five options are useful only when verifying checksums:\n      --ignore-missing  don't fail or report status for missing files\n      --quiet           don't print OK for each successfully verified file\n      --status          don't output anything, status code shows success\n      --strict          exit non-zero for improperly formatted checksum lines\n  -w, --warn            warn about improperly formatted checksum lines\n\n      --help        display this help and exit\n      --version     output version information and exit\n\nThe sums are computed as described in RFC 1321.\nWhen checking, the input should be a former output of this program.\nThe default mode is to print a line with: checksum, a space,\na character indicating input mode ('*' for binary, ' ' for text\nor where binary is insignificant), and name for each FILE.\n]]return elseif c.v then print(\"1.0\")return end;c[1]=c[1]or\"-\"for d,e in ipairs(c)do local f=e==\"-\"and io.stdin or assert(io.open(e,c.b and not c.t and\"rb\"or\"r\"))local g=a.md5()local h;repeat local i=f:read(\"*L\")h=g(i)until not i;if f~=io.stdin then f:close()end;local j;if c.tag then j=\"MD5 (\"..e..\") = \"..h else j=h..\"  \"..e end;if c.z then io.stdout:write(j..\"\\0\")else print(j)end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293794,size=2010},["sha384sum.lua"]={type="file",created=1740881293803,worldPermissions={execute=true,read=true,write=false},data="return coroutine.yield(\"syscall\",\"exec\",\"/usr/bin/shasum\",\"-a\",\"384\",...)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293796,size=74},["pdb.lua"]={type="file",created=1740881293100,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.ipc\"local c=require\"system.pretty\"local d=require\"system.process\"local e=require\"system.terminal\"local f=require\"system.util\"local g,h,i,j,k,l,m;local n={[\"nil\"]=function()return\"nil\"end,[\"boolean\"]=function(o)return o and\"true\"or\"false\"end,[\"number\"]=tostring,[\"string\"]=function(p)return(\"%q\"):format(p)end,[\"table\"]=function(q)return\"<\"..tostring(q)..\">\"end,[\"function\"]=function(q)return\"<\"..tostring(q)..\">\"end,[\"thread\"]=function(q)return\"<\"..tostring(q)..\">\"end,[\"userdata\"]=function(q)return\"<\"..tostring(q)..\">\"end}local function r()local s=d.debug.getinfo(g,h,i)if s then local t={}for u=1,s.nparams do local v,w=d.debug.getlocal(g,h,i,u)t[u]=(\"\\x1b[36m%s\\x1b[0m=%s\"):format(v,n[type(w)](w))end;print((\"\\x1b[94m0x%s\\x1b[0m in \\x1b[93m%s\\x1b[0m (%s) at \\x1b[32m%s\\x1b[0m:%d\"):format(tostring(s.func):gsub(\"^function: \",\"\"),s.name or s.what==\"main\"and\"<main chunk>\"or\"???\",table.concat(t,\", \"),s.short_src,s.currentline))if s.source and s.source:match(\"^@\")then local x=a.open(s.source:sub(2),\"r\")if x then local y;for z=1,s.currentline do y=x.readLine()end;x.close()if y then print(s.currentline,y)end end end end end;local function A()local B,C;repeat B,C=coroutine.yield()until B==\"debug_break\"and C.process==g or B==\"process_complete\"and C.id==g;if B==\"process_complete\"then print(\"Process exited: \"..g)g,h,j=nil,nil,false;return end;d.debug.brk(g)local s=d.getpinfo(g)if s.threads[C.thread].name==\"<user mode callback>\"or s.threads[C.thread].name==\"<signal handler:2>\"then C.thread=0;while not s.threads[C.thread]do C.thread=C.thread+1 end end;h=C.thread;i=1;if C.breakpoint then if C.breakpoint~=m then print(\"\\x1b[93mThread \"..h..\": Breakpoint \"..C.breakpoint..\"\\x1b[0m\")end elseif C.error then print(\"\\x1b[93mThread \"..h..\": Error: \"..n[type(C.error)](C.error)..\"\\x1b[0m\")else print(\"\\x1b[93mThread \"..h..\": Break\\x1b[0m\")end;if m then d.debug.unsetbreakpoint(g,m)m=nil end;r()end;local D={}function D.run(...)if j then print(\"Target is already running\")end;print(\"Starting process: \"..g)k=table.pack(...)j=true;d.debug.continue(g)A()end;D.r=D.run;D[\"break\"]=function(E)local F,y=E:match\"^(.+):(%d+)$\"if F then F=F:match\"^/.*$\"or a.combine(d.getcwd(),F)local G=d.debug.setbreakpoint(g,nil,\"call\",{source=\"@\"..F,currentline=tonumber(y)})print(\"Breakpoint \"..G..\": File \"..F..\", line \"..y)else local G=d.debug.setbreakpoint(g,nil,\"call\",{name=E})print(\"Breakpoint \"..G..\": Function \"..E)end end;D.brea=D[\"break\"]D.bre=D.brea;D.br=D.brea;D.b=D.brea;function D.delete(G)G=assert(tonumber(G),\"Invalid ID\")d.debug.unsetbreakpoint(g,G)end;D.del=D.delete;D.d=D.delete;function D.continue()print(\"Continuing.\")d.debug.continue(g)A()end;D.c=D.continue;function D.step()local s=d.debug.getinfo(g,h,i)m=d.debug.setbreakpoint(g,h,\"line\",{func=s.func})d.debug.continue(g)A()end;D.s=D.step;function D.next()m=d.debug.setbreakpoint(g,h,\"line\",nil)d.debug.continue(g)A()end;D.n=D.next;function D.stepi()local s=d.debug.getinfo(g,h,i)m=d.debug.setbreakpoint(g,h,1,{func=s.func})d.debug.continue(g)A()end;D.si=D.stepi;function D.nexti()m=d.debug.setbreakpoint(g,h,1,nil)d.debug.continue(g)A()end;D.ni=D.nexti;function D.backtrace()for H=1,math.huge do local s=d.debug.getinfo(g,h,H)if not s then break end;local t={}for u=1,s.nparams do local v,w=d.debug.getlocal(g,h,H,u)t[u]=(\"%s=%s\"):format(v,n[type(w)](w))end;print((\"#%-2d \\x1b[94m0x%s\\x1b[0m in \\x1b[93m%s\\x1b[0m (%s) at \\x1b[32m%s\\x1b[0m:%d\"):format(H,tostring(s.func):gsub(\"^function: \",\"\"),s.name or s.what==\"main\"and\"<main chunk>\"or\"???\",table.concat(t,\", \"),s.short_src,s.currentline))end end;D.bt=D.backtrace;D.where=D.backtrace;function D.catch(type,C)if type==\"catch\"or type==\"error\"then elseif type==\"exec\"then elseif type==\"fork\"then elseif type==\"load\"then elseif type==\"syscall\"then elseif type==\"throw\"then end end;function D.skip()end;function D.print(...)local I=table.concat({...},\" \")local J={}for H=1,math.huge do local K,q=d.debug.getupvalue(g,h,i,H)if not K then break end;J[K]=q end;for H=1,math.huge do local K,q=d.debug.getlocal(g,h,i,H)if not K then break end;J[K]=q end;local L,M=d.debug.exec(g,h,function()local N,O=load(\"return \"..I,\"=expr\",\"t\",setmetatable(J,{__index=_ENV,__newindex=function(z,K,q)_ENV[K]=q end}))if not N then return false,O end;return pcall(N)end)if L then c.pretty_print(M)else io.stderr:write(M..\"\\n\")end end;D.p=D.print;D.inspect=D.print;function D.advance(P)end;function D.detach()end;function D.finish()m=d.debug.setbreakpoint(g,h,\"return\",nil)d.debug.continue(g)A()end;D.fin=D.finish;function D.interrupt()d.debug.brk(g)A()end;function D.attach(G)if g then d.debug.enable(g,false)end;g=assert(tonumber(G),\"Invalid process ID\")j=true;l=true end;function D.thread(Q)Q=assert(tonumber(Q),\"Invalid thread ID\")local s=d.getpinfo(g)if not s.threads[Q]then error(\"Invalid thread\")end;h=Q;i=1;r()end;D.t=D.thread;function D.frame(Q)Q=assert(tonumber(Q),\"Invalid frame ID\")local s=d.debug.getinfo(g,h,Q)if not s then error(\"Invalid frame\")end;i=Q;r()end;D.f=D.frame;function D.down(Q)local s=d.debug.getinfo(g,h,i-1)if not s then error(\"Invalid frame\")end;i=i-1;r()end;function D.up(Q)local s=d.debug.getinfo(g,h,i+1)if not s then error(\"Invalid frame\")end;i=i+1;r()end;D[\"return\"]=function()local s=d.debug.getinfo(g,h,i)m=d.debug.setbreakpoint(g,h,\"return\",{func=s.func})d.debug.continue(g)A()end;function D.info(type,C)if type==\"args\"then print(table.concat(k,\" \"))elseif type==\"breakpoints\"or type==\"b\"then elseif type==\"display\"then elseif type==\"files\"then elseif type==\"frame\"then c.pretty_print(d.debug.getinfo(g,h,i))elseif type==\"functions\"then elseif type==\"line\"then elseif type==\"locals\"then for H=1,math.huge do local K,q=d.debug.getlocal(g,h,i,H)if not K then break end;print(K..\" = \"..n[_G.type(q)](q))end elseif type==\"modules\"then elseif type==\"proc\"then elseif type==\"program\"then elseif type==\"registers\"then elseif type==\"scope\"then elseif type==\"source\"then elseif type==\"stack\"then elseif type==\"target\"then elseif type==\"threads\"then local R=d.getpinfo(g)for G,S in pairs(R.threads)do local s=d.debug.getinfo(g,G,1)print((\"%s %-2d %q - %s at %s:%d\"):format(G==h and\"*\"or\" \",G,S.name,s.name or(s.what==\"main\"and\"<main chunk>\"or\"???\"),s.source or\"???\",s.currentline or\"???\"))end elseif type==\"variables\"then end end;D.i=D.info;D.inf=D.info;local function T(F)local U=false;g=d.fork(function()b.sigaction(b.signal.SIGINT,function()d.debug.brk()end)repeat d.debug.brk()until U;d.exec(F,table.unpack(k or{}))end,F)d.debug.enable(g,true)repeat local B,C=coroutine.yield()until B==\"debug_break\"and C.process==g;U=true;j=false;l=false end;print(\"Phoenix Debugger\")local F=...if F then T(F)end;local V={}while true do io.write(\"\\x1b[93m(pdb) \\x1b[0m\")local y=e.readline2(V)if y~=V[1]then table.insert(V,1,y)end;local W=f.split(y)if W[1]==\"quit\"or W[1]==\"q\"or W[1]==\"exit\"then if not j then return end;d.debug.enable(g,false)if not l then b.kill(g,b.signal.SIGTERM)end;return elseif W[1]then local X=D[W[1]]if X then local L,O=pcall(X,table.unpack(W,2,W.n))if not L then io.stderr:write(tostring(O)..\"\\n\")end end end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293098,size=7090},["update-initrd.lua"]={type="file",created=1740881292396,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=assert(io.open(\"/etc/initrd/initrd.conf\",\"r\"))local d=c:read(\"*a\"):gsub(\"#\",\"--\")c:close()config={}assert(load(d,\"@/etc/initrd/initrd.conf\",\"t\",config))()if a.isDir(\"/etc/initrd/initrd.conf.d\")then for e,f in ipairs(a.list(\"/etc/initrd/initrd.conf.d\"))do c=assert(io.open(\"/etc/initrd/initrd.conf.d/\"..f,\"r\"))d=c:read(\"*a\"):gsub(\"#\",\"--\")c:close()assert(load(d,\"@/etc/initrd/initrd.conf.d/\"..f,\"t\",config))()end end;rootDirectory=os.tmpname()a.mkdir(rootDirectory)for e,f in ipairs(a.list(\"/etc/initrd/hooks.d\"))do print(\"--> Running hook \"..f)dofile(\"/etc/initrd/hooks.d/\"..f)end;print(\"--> Creating initrd\")b.run(\"/usr/bin/mktablefs.lua\",rootDirectory,config.output_path or\"/boot/initrd.img\")print(\"=>  Finished creating initrd at \"..(config.output_path or\"/boot/initrd.img\"))\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292384,size=852},["b2sum.lua"]={type="file",created=1740881293801,worldPermissions={execute=true,read=true,write=false},data="local a=require\"sha2\"local b=require\"system.util\"local c=assert(b.argparse({b=false,binary=\"@b\",c=false,check=\"@c\",l=\"number\",length=\"@l\",tag=false,t=false,text=\"@t\",z=false,zero=\"@z\",[\"ignore-missing\"]=false,quiet=false,status=false,strict=false,w=false,warn=\"@w\",h=false,help=\"@h\",v=false,version=\"@v\"},...))if c.h then print[[\nUsage: b2sum [OPTION]... [FILE]...\nPrint or check BLAKE2b (512-bit) checksums.\n\nWith no FILE, or when FILE is -, read standard input.\n  -b, --binary          read in binary mode\n  -c, --check           read checksums from the FILEs and check them\n  -l, --length=BITS     digest length in bits; must not exceed the max for\n                          the blake2 algorithm and must be a multiple of 8\n      --tag             create a BSD-style checksum\n  -t, --text            read in text mode (default)\n  -z, --zero            end each output line with NUL, not newline,\n                          and disable file name escaping\n\nThe following five options are useful only when verifying checksums:\n      --ignore-missing  don't fail or report status for missing files\n      --quiet           don't print OK for each successfully verified file\n      --status          don't output anything, status code shows success\n      --strict          exit non-zero for improperly formatted checksum lines\n  -w, --warn            warn about improperly formatted checksum lines\n\n      --help        display this help and exit\n      --version     output version information and exit\n\nThe sums are computed as described in RFC 7693.\nWhen checking, the input should be a former output of this program.\nThe default mode is to print a line with: checksum, a space,\na character indicating input mode ('*' for binary, ' ' for text\nor where binary is insignificant), and name for each FILE.\n]]return elseif c.v then print(\"1.0\")return end;c[1]=c[1]or\"-\"for d,e in ipairs(c)do local f=e==\"-\"and io.stdin or assert(io.open(e,c.b and not c.t and\"rb\"or\"r\"))local g=a.blake2b(nil,nil,nil,c.l and c.l/8)local h;repeat local i=f:read(\"*L\")h=g(i)until not i;if f~=io.stdin then f:close()end;local j;if c.tag then j=\"BLAKE2b\"..(c.l and\"-\"..c.l or\"\")..\" (\"..e..\") = \"..h else j=h..\"  \"..e end;if c.z then io.stdout:write(j..\"\\0\")else print(j)end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293793,size=2247},["shasum.lua"]={type="file",created=1740881293804,worldPermissions={execute=true,read=true,write=false},data="local a=require\"sha2\"local b=require\"system.util\"local c=assert(b.argparse({a=true,algorithm=\"@a\",b=false,binary=\"@b\",c=false,check=\"@c\",tag=false,t=false,text=\"@t\",U=false,UNIVERSAL=\"@U\",[\"0\"]=false,[\"01\"]=\"@0\",[\"ignore-missing\"]=false,q=false,quiet=\"@q\",s=false,status=\"@s\",strict=false,w=false,warn=\"@w\",h=false,help=\"@h\",v=false,version=\"@v\"},...))if c.h then print[[\nUsage: shasum [OPTION]... [FILE]...\nPrint or check SHA checksums.\nWith no FILE, or when FILE is -, read standard input.\n\n    -a, --algorithm   1 (default), 224, 256, 384, 512, 512224, 512256\n    -b, --binary      read in binary mode\n    -c, --check       read SHA sums from the FILEs and check them\n        --tag         create a BSD-style checksum\n    -t, --text        read in text mode (default)\n    -U, --UNIVERSAL   read in Universal Newlines mode\n                        produces same digest on Windows/Unix/Mac\n    -0, --01          read in BITS mode\n                        ASCII '0' interpreted as 0-bit,\n                        ASCII '1' interpreted as 1-bit,\n                        all other characters ignored\n\nThe following five options are useful only when verifying checksums:\n        --ignore-missing  don't fail or report status for missing files\n    -q, --quiet           don't print OK for each successfully verified file\n    -s, --status          don't output anything, status code shows success\n        --strict          exit non-zero for improperly formatted checksum lines\n    -w, --warn            warn about improperly formatted checksum lines\n\n    -h, --help        display this help and exit\n    -v, --version     output version information and exit\n\nWhen verifying SHA-512/224 or SHA-512/256 checksums, indicate the\nalgorithm explicitly using the -a option, e.g.\n\n    shasum -a 512224 -c checksumfile\n\nThe sums are computed as described in FIPS PUB 180-4.  When checking,\nthe input should be a former output of this program.  The default\nmode is to print a line with checksum, a character indicating type\n(`*' for binary, ` ' for text, `U' for UNIVERSAL, `^' for BITS),\nand name for each FILE.  The line starts with a `\\' character if the\nFILE name contains either newlines or backslashes, which are then\nreplaced by the two-character sequences `\\n' and `\\\\' respectively.\n]]return elseif c.v then print(\"1.0\")return end;c[1]=c[1]or\"-\"for d,e in ipairs(c)do local f=e==\"-\"and io.stdin or assert(io.open(e,c.b and not c.t and\"rb\"or\"r\"))local g;if c.a==\"1\"or not c.a then g=a.sha1()elseif c.a==\"224\"then g=a.sha224()elseif c.a==\"256\"then g=a.sha256()elseif c.a==\"384\"then g=a.sha384()elseif c.a==\"512\"then g=a.sha512()elseif c.a==\"512224\"then g=a.sha512_224()elseif c.a==\"512256\"then g=a.sha512_256()else error(\"shasum: invalid algorithm \"..c.a)end;local h;repeat local i=f:read(\"*L\")if i and c[\"0\"]then i=i:gsub(\"[^01]\",\"\"):gsub(\"........\",function(j)return string.char(tonumber(j,2))end)end;h=g(i)until not i;if f~=io.stdin then f:close()end;if c.tag then print(\"SHA\"..(c.a or\"1\"):gsub(\"(...)(...)\",\"%1/%2\")..\" (\"..e..\") = \"..h)else print(h..\"  \"..e)end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293797,size=3059},["mktablefs.lua"]={type="file",created=1740881292395,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.serialization\"local function c(d)local e=a.stat(d)if not e then return nil end;e.freeSpace,e.capacity,e.special,e.mountpoint=nil;if e.type==\"file\"then local f=assert(io.open(d,\"rb\"))e.data=f:read(\"*a\")f:close()elseif e.type==\"directory\"then e.contents={}for g,h in ipairs(a.list(d))do e.contents[h]=c(a.combine(d,h))end end;return e end;local i,j=...if not j then error(\"Usage: mktablefs <input directory> <output file>\")end;local e=c(i)b.lua.save(e,j,{minified=true})\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292383,size=526},["passwd.lua"]={type="file",created=1740881294442,worldPermissions={write=false,read=true,execute=true},data="local a=require\"usermgr\"local b=require\"system.process\"local c=require\"system.terminal\"local d=require\"system.util\"local e,f=b.getuser()f=f or e;if e~=\"root\"then error(\"This program must be run as root. Make sure the setuser bit is set.\")end;local g=assert(d.argparse({a=false,all=\"@a\",d=false,delete=\"@d\",e=false,expire=\"@e\",h=false,help=\"@h\",i=\"number\",inactive=\"@i\",k=false,[\"keep-tokens\"]=\"@k\",l=false,lock=\"@l\",n=\"number\",mindays=\"@n\",q=false,quiet=\"@q\",S=false,status=\"@S\",u=false,unlock=\"@u\",w=\"number\",warndays=\"@w\",x=\"number\",maxdays=\"@x\"},...))if g.h then print[[\nUsage: passwd [options] [LOGIN]\nOptions:\n  -a, --all                 report password status on all accounts\n  -d, --delete              delete the password for the named account\n  -e, --expire              force expire the password for the named account\n  -h, --help                display this help message and exit\n  -k, --keep-tokens         change password only if expired\n  -i, --inactive INACTIVE   set password inactive after expiration to INACTIVE\n  -l, --lock                lock the password of the named account\n  -n, --mindays MIN_DAYS    set minimum number of days before password change to MIN_DAYS\n  -q, --quiet               quiet mode\n  -S, --status              report password status on the named account\n  -u, --unlock              unlock the password of the named account\n  -w, --warndays WARN_DAYS  set expiration warning days to WARN_DAYS\n  -x, --maxdays MAX_DAYS    set maximum number of days before password change to MAX_DAYS \n]]return elseif g.S then local function h(i)local j=a.getUserInfo(i)if not j then print(\"passwd: could not find user\")return end;print(i,j.hasPassword and(j.isLocked and\"L\"or\"P\")or\"NP\",os.date(\"%F\",j.lastChange),j.nextChange and(j.nextChange-j.lastChange)/86400 or 0,j.expirationTime and(j.expirationTime-j.lastChange)/86400 or 0,j.expirationWarning and(j.expirationTime-j.expirationWarning)/86400 or 0,-1)end;if g.a then if f~=\"root\"then error(\"passwd: Permission denied.\")end;for k in io.lines(\"/etc/passwd\")do h(k:match(\"^[^:]+\"))end else h(f)end;return end;local i=g[1]or f;if g.d then assert(f==\"root\",\"passwd: Permission denied.\")return a.setPassword(i,nil)elseif g.e then assert(f==\"root\",\"passwd: Permission denied.\")return a.setPassword(i,nil,{expirationTime=0})elseif g.l then assert(f==\"root\",\"passwd: Permission denied.\")return a.setPassword(i,nil,{isLocked=true})elseif g.u then assert(f==\"root\",\"passwd: Permission denied.\")return a.setPassword(i,nil,{isLocked=false})else local j=a.getUserInfo(i)if not j then io.stderr:write(\"passwd: User not found.\\n\")return false end;if j.isLocked then io.stderr:write(\"passwd: User is locked.\\n\")return false end;if not g.q then print(\"Changing password for \"..i..\".\")end;local l;if f~=\"root\"then if not g.q then io.stdout:write(\"Old password: \")end;c.termctl({echo=false})l=io.stdin:read()c.termctl({echo=true})print()end;if not g.q then io.stdout:write(\"New password: \")end;c.termctl({echo=false})local m=io.stdin:read()c.termctl({echo=true})print()if not g.q then io.stdout:write(\"Confirm password: \")end;c.termctl({echo=false})local n=io.stdin:read()c.termctl({echo=true})print()if l and not a.authenticate(i,l)then if not g.q then io.stderr:write(\"passwd: Incorrect old password.\\n\")end;return false elseif m==n then return a.setPassword(i,m,{nextChange=g.n,expirationTime=g.x,expirationWarning=g.w,lockTime=g.i})else if not g.q then io.stderr:write(\"passwd: Passwords do not match.\\n\")end;return false end end\n",setuser=true,permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294387,size=3496},["dpkg-trigger.lua"]={type="file",created=1740881291977,worldPermissions={execute=true,read=true,write=false},data="local a=require\"dpkg.query\"local b=require\"dpkg.trigger\"local c={}local d=_ENV.DPKG_MAINTSCRIPT_PACKAGE;local e=true;local f=true;local g;for h,i in ipairs({...})do if g then if g==0 then b.admindir=i;a.admindir=i elseif g==1 then d=i end;g=nil elseif i==\"--check-supported\"then return 0 elseif i==\"-?\"or i==\"--help\"then print([[Usage: dpkg-trigger [<options> ...] <trigger-name>\n       dpkg-trigger [<options> ...] <command>\n\nCommands:\n  --check-supported                Check if the running dpkg supports triggers.\n\n  -?, --help                       Show this help message.\n      --version                    Show the version.\n\nOptions:\n  --admindir=<directory>           Use <directory> instead of /var/lib/dpkg.\n  --by-package=<package>           Override trigger awaiter (normally set\n                                   by dpkg).\n  --await                          Package needs to await the processing.\n  --no-await                       No package needs to await the processing.\n  --no-act                         Just test - don't actually change anything.\n ]])return 0 elseif i==\"--version\"then print([[Debian dpkg-trigger package trigger utility version 1.19.0.5 (Phoenix).]])return 0 elseif i==\"--admindir\"then g=0 elseif string.match(i,\"^--admindir=\")then b.admindir=string.sub(i,12)a.admindir=string.sub(i,12)elseif i==\"--by-package\"then g=1 elseif string.match(i,\"^--by-package=\")then d=string.sub(i,14)elseif i==\"--await\"then e=true elseif i==\"--no-await\"then e=false elseif i==\"--no-act\"then f=false else table.insert(c,i)end end;if c[1]==nil then error([[error: takes one argument, the trigger name\n\nType dpkg-trigger --help for help about this utility.]])end;if d==nil then error([[error: must be called from a maintainer script (or with a --by-package option)\n\nType dpkg-trigger --help for help about this utility.]])end;b.log=function(j)print(\"\\x1b[31m\"..j..\"\\x1b[0m\")end;if f then b.activate(c[1],d,e)end;return 0\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291951,size=1936},["gzip.lua"]={type="file",created=1740881292673,worldPermissions={execute=true,read=true,write=false},data="local a=require\"LibDeflate\"local b={...}local c=0;local d;local e;local f=false;local g=false;local h;local i=false;for j,k in pairs(b)do if k==\"-c\"or k==\"--stdout\"then e=\"stdout\"elseif k==\"-d\"or k==\"--decompress\"then c=1 elseif k==\"-f\"or k==\"--force\"then g=true elseif k==\"-h\"or k==\"--help\"then print([[Usage: gzip [OPTION]... [FILE]\nCompress or uncompress FILEs (by default, compress FILES in-place).\n\n    -c, --stdout      write on standard output, keep original files unchanged\n    -d, --decompress  decompress\n    -f, --force       force overwrite of output file\n    -h, --help        give this help\n    -k, --keep        keep (don't delete) input files\n    -l, --list        list compressed file contents\n    -t, --test        test compressed file integrity\n    -v, --verbose     verbose mode\n    -V, --version     display version number\n    -1, --fast        compress faster\n    -9, --best        compress better\n\nWith no FILE, or when FILE is -, read standard input.]])return elseif k==\"-k\"or k==\"--keep\"then f=true elseif k==\"-l\"or k==\"--list\"then c=2 elseif k==\"-t\"or k==\"--test\"then c=3 elseif k==\"-v\"or k==\"--verbose\"then i=true elseif k==\"-V\"or k==\"--version\"then print(\"gzip v1.0\")return elseif k==\"-1\"or k==\"--fast\"then h=1 elseif k==\"-9\"or k==\"--best\"then h=9 elseif d==nil then if k==\"-\"then d=\"stdin\"e=\"stdout\"else d=k end end end;if d==nil then d=\"stdin\"end;if e==nil then if c==0 and d~=\"stdin\"then e=d..\".gz\"elseif c==1 and d~=\"stdin\"then e=string.gsub(d,\".gz\",\"\")else e=\"stdout\"end end;local function l()if d==\"stdin\"then return io.stdin:read(\"*a\")else local m=assert(io.open(d,\"rb\"))local n=m:read(\"*a\")m:close()return n end end;local function o(p)if p==nil then error(d..\": not in gzip format\",2)end;if e==\"stdout\"then io.stdout:write(p)else local m=assert(io.open(e,\"wb\"))m:write(p)m:close()end;if i and e~=\"stdout\"then print(\"Wrote \"..string.len(p)..\" bytes\")end end;if e~=\"stdout\"and not g then local m=io.open(e,\"r\")if m then m:close()error(e..\": File exists\")end end;if c==0 then o(a:CompressGzip(l(),{level=h}))elseif c==1 then o(a:DecompressGzip(l()))elseif c==2 then local q=a.internal.GetGzipInfo(l())if q==nil then error(d..\": not in gzip format\")end;for j,k in pairs(q)do print(j,k)end elseif c==3 then local r,s=a:DecompressGzip(l())if r==nil then if s==-2 then error(d..\": invalid compressed data--crc error\")elseif s==-1 then error(d..\": not in gzip format\")elseif s==-3 then error(d..\" has unsupported flags\")elseif s==-4 then error(d..\": unknown method -- not supported\")else error(d..\": unknown error\")end end;if i then print(d..\":    OK\")end else error(\"This should never happen.\")end;if not f and d~=\"stdin\"and e~=\"stdout\"then os.remove(d)end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292670,size=2686},["apt-mark.lua"]={type="file",created=1740881291215,worldPermissions={execute=true,read=true,write=false},data="\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291200,size=1},["dpkg.lua"]={type="file",created=1740881291978,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=require\"dpkg\"local d=require\"dpkg.divert\"local e=require\"dpkg.query\"local f=require\"dpkg.trigger\"local function g(h)return a.combine(c.admindir,h)end;local function i(j,k)local l=a.open(j,\"w\")l.write(k)l.close()end;local function m(n,o)return({string.match(n.Status,\"(%S+) (%S+) (%S+)\")})[o]end;local function p(n,o,q)local r={string.match(n.Status,\"(%S+) (%S+) (%S+)\")}r[o]=q;n.Status=table.concat(r,\" \")return n.Status end;local function s(t)local b=io.popen(\"/bin/less\",\"w\")b:write(t)b:close()end;local u=[[Usage: dpkg [<option> ...] <command>\n\nCommands:\n    -i|--install       <.deb file name> ... | -R|--recursive <directory> ...\n    --unpack           <.deb file name> ... | -R|--recursive <directory> ...\n    -A|--record-avail  <.deb file name> ... | -R|--recursive <directory> ...\n    --configure        <package> ... | -a|--pending\n    --triggers-only    <package> ... | -a|--pending\n    -r|--remove        <package> ... | -a|--pending\n    -P|--purge         <package> ... | -a|--pending\n    -V|--verify <package> ...        Verify the integrity of package(s).\n    --get-selections [<pattern> ...] Get list of selections to stdout.\n    --set-selections                 Set package selections from stdin.\n    --clear-selections               Deselect every non-essential package.\n    --update-avail [<Packages-file>] Replace available packages info.\n    --merge-avail [<Packages-file>]  Merge with info from file.\n    --clear-avail                    Erase existing available info.\n    --forget-old-unavail             Forget uninstalled unavailable pkgs.\n    -s|--status <package> ...        Display package status details.\n    -p|--print-avail <package> ...   Display available version details.\n    -L|--listfiles <package> ...     List files 'owned' by package(s).\n    -l|--list [<pattern> ...]        List packages concisely.\n    -S|--search <pattern> ...        Find package(s) owning file(s).\n    -C|--audit [<package> ...]       Check for broken package(s).\n    --yet-to-unpack                  Print packages selected for installation.\n    --predep-package                 Print pre-dependencies to unpack.\n    --add-architecture <arch>        Add <arch> to the list of architectures.\n    --remove-architecture <arch>     Remove <arch> from the list of architectures.\n    --print-architecture             Print dpkg architecture.\n    --print-foreign-architectures    Print allowed foreign architectures.\n    --assert-<feature>               Assert support for the specified feature.\n    --validate-<thing> <string>      Validate a <thing>'s <string>.\n    --compare-versions <a> <op> <b>  Compare version numbers - see below.\n    --force-help                     Show help on forcing.\n    -Dh|--debug=help                 Show help on debugging.\n\n    -?, --help                       Show this help message.\n        --version                    Show the version.\n\nAssertable features: support-predepends, working-epoch, long-filenames,\n    multi-conrep, multi-arch, versioned-provides.\n\nValidatable things: pkgname, archname, trigname, version.\n\nUse dpkg with -b, --build, -c, --contents, -e, --control, -I, --info,\n    -f, --field, -x, --extract, -X, --vextract, --ctrl-tarfile, --fsys-tarfile\non archives (type dpkg-deb --help).\n\nOptions:\n    --admindir=<directory>     Use <directory> instead of /var/lib/dpkg.\n    --root=<directory>         Install on a different root directory.\n    --instdir=<directory>      Change installation dir without changing admin dir.\n    --path-exclude=<pattern>   Do not install paths which match a shell pattern.\n    --path-include=<pattern>   Re-include a pattern after a previous exclusion.\n    -O|--selected-only         Skip packages not selected for install/upgrade.\n    -E|--skip-same-version     Skip packages whose same version is installed.\n    -G|--refuse-downgrade      Skip packages with earlier version than installed.\n    -B|--auto-deconfigure      Install even if it would break some other package.\n    --[no-]triggers            Skip or force consequential trigger processing.\n    --verify-format=<format>   Verify output format (supported: 'rpm').\n    --no-debsig                Do not try to verify package signatures.\n    --no-act|--dry-run|--simulate\n                               Just say what we would do - don't do it.\n    -D|--debug=<octal>         Enable debugging (see -Dhelp or --debug=help).\n    --status-fd <n>            Send status change updates to file descriptor <n>.\n    --status-logger=<command>  Send status change updates to <command>'s stdin.\n    --log=<filename>           Log status changes and actions to <filename>.\n    --ignore-depends=<package>,...\n                               Ignore dependencies involving <package>.\n    --force-...                Override problems (see --force-help).\n    --no-force-...|--refuse-...\n                               Stop when problems encountered.\n    --abort-after <n>          Abort after encountering <n> errors.\n\nComparison operators for --compare-versions are:\n    lt le eq ne ge gt       (treat empty version as earlier than any version);\n    lt-nl le-nl ge-nl gt-nl (treat empty version as later than any version);\n    < << <= = >= >> >       (only for compatibility with control file syntax).\n\nUse 'apt' or 'aptitude' for user-friendly package management.]]local v={}local w=nil;local x=false;local y=false;local z=nil;local A,B;local C,D;for E,F in ipairs({...})do if w~=nil then table.insert(v,F)elseif string.match(F,\"^%-[^-]\")then local G=string.sub(F,2,2)if G=='i'then w=0 elseif G=='r'then w=4 elseif G=='P'then w=5 elseif G=='V'then w=6 elseif G=='C'then w=7 elseif G=='?'then if c.options.pager then s(u)else print(u)end;return elseif G=='D'then elseif G=='b'or G=='c'or G=='e'or G=='x'or G=='X'or G=='f'or G=='I'then w=13 elseif G=='l'or G=='s'or G=='L'or G=='S'or G=='p'then w=14 elseif G=='B'then c.options.auto_deconfigure=true elseif G=='R'then x=true elseif G=='G'then c.force.downgrade=false elseif G=='O'then y=true elseif G=='E'then c.options.skip_same_version=true end else local H;if string.find(F,\"=\")then F,H=string.match(F,\"^(.+)=(.+)$\")end;if F==\"--install\"then w=0 elseif F==\"--unpack\"then w=1 elseif F==\"--configure\"then w=2 elseif F==\"--triggers-only\"then w=3 elseif F==\"--remove\"then w=4 elseif F==\"--purge\"then w=5 elseif F==\"--verify\"then w=6 elseif F==\"--audit\"then w=7 elseif F==\"--get-selections\"then w=8 elseif F==\"--set-selections\"then w=9 elseif F==\"--clear-selections\"then w=10 elseif F==\"--print-architecture\"then print(\"phoenix\")return elseif string.match(F,\"^%-%-assert%-\")then if F==\"--assert-support-predepends\"then return 0 elseif F==\"--assert-working-epoch\"then return 0 elseif F==\"--assert-long-filenames\"then return 0 elseif F==\"--assert-multi-conrep\"then return 1 elseif F==\"--assert-multi-arch\"then return 1 elseif F==\"--assert-versioned-provides\"then return 0 else return 2 end elseif string.match(F,\"^%-%-validate%-\")then w=11;z=string.match(F,\"^%-%-validate%-(.+)\")elseif F==\"--compare-verisons\"then w=12 elseif F==\"--help\"then if c.options.pager then s(u)else print(u)end;return elseif F==\"--force-help\"then(c.options.pager and s or print)([[dpkg forcing options - control behaviour when problems found:\nwarn but continue:  --force-<thing>,<thing>,...\nstop with error:    --refuse-<thing>,<thing>,... | --no-force-<thing>,...\nForcing things:\n[!] all                Set all force options\n[*] downgrade          Replace a package with a lower version\n    configure-any      Configure any package which may help this one\n    hold               Process incidental packages even when on hold\n    bad-verify         Install a package even if it fails authenticity check\n    bad-version        Process even packages with wrong versions\n    overwrite          Overwrite a file from one package with another\n    overwrite-diverted Overwrite a diverted file with an undiverted version\n[!] overwrite-dir      Overwrite one package's directory with another's file\n[!] confnew            Always use the new config files, don't prompt\n[!] confold            Always use the old config files, don't prompt\n[!] confdef            Use the default option for new config files if one\n                        is available, don't prompt. If no default can be found,\n                        you will be prompted unless one of the confold or\n                        confnew options is also given\n[!] confmiss           Always install missing config files\n[!] confask            Offer to replace config files with no new versions\n[!] architecture       Process even packages with wrong or no architecture\n[!] breaks             Install even if it would break another package\n[!] conflicts          Allow installation of conflicting packages\n[!] depends            Turn all dependency problems into warnings\n[!] depends-version    Turn dependency version problems into warnings\n[!] remove-reinstreq   Remove packages which require installation\n[!] remove-essential   Remove an essential package\n\nWARNING - use of options marked [!] can seriously damage your installation.\nForcing options marked [*] are enabled by default.]])return elseif F==\"--build\"or F==\"--contents\"or F==\"--control\"or F==\"--extract\"or F==\"--vextract\"or F==\"--field\"or F==\"--ctrl-tarfile\"or F==\"--fsys-tarfile\"or F==\"--info\"then w=13 elseif F==\"--list\"or F==\"--status\"or F==\"--listfiles\"or F==\"--search\"or F==\"--print-avail\"then w=14 elseif F==\"--auto-deconfigure\"then c.options.auto_deconfigure=true elseif F==\"--debug\"then elseif string.match(F,\"^%-%-force%-\")or string.match(F,\"^%-%-no%-force%-\")or string.match(F,\"^%-%-refuse%-\")then local I=string.match(F,\"^%-%-force%-\")~=nil;local J=F:gsub(\"^%-%-force%-\",\"\"):gsub(\"^%-%-no%-force%-\",\"\"):gsub(\"^%-%-refuse%-\",\"\")if J==\"downgrade\"then c.force.downgrade=I elseif J==\"configure-any\"then c.force.configure_any=I elseif J==\"hold\"then c.force.hold=I elseif J==\"remove-reinstreq\"then c.force.remove_reinstreq=I elseif J==\"remove-essential\"then c.force.remove_essential=I elseif J==\"depends\"then c.force.depends=I elseif J==\"depends-version\"then c.force.depends_version=I elseif J==\"breaks\"then c.force.breaks=I elseif J==\"conflicts\"then c.force.conflicts=I elseif J==\"confmiss\"then c.force.confmiss=I elseif J==\"confnew\"and c.force.confmode~=2 then c.force.confmode=0 elseif J==\"confold\"and c.force.confmode~=2 then c.force.confmode=1 elseif J==\"confdef\"then c.force.confmode=2 elseif J==\"confask\"and c.force.confmode==nil then c.force.confmode=nil elseif J==\"overwrite\"then c.force.overwrite=I elseif J==\"overwrite-dir\"then c.force.overwrite_dir=I elseif J==\"overwrite-diverted\"then c.force.overwrite_diverted=I elseif J==\"architecture\"then c.force.architecture=I elseif J==\"bad-version\"then c.force.bad_version=I elseif J==\"bad-verify\"then c.force.bad_verify=I end elseif F==\"--ignore-depends\"then for E,F in ipairs(split(H,\",\"))do c.options.ignore_depends[F]=true end elseif F==\"--no-act\"or F==\"--dry-run\"or F==\"--simulate\"then c.options.dry_run=true elseif F==\"--recursive\"then x=true elseif F==\"--admindir\"then c.admindir,d.admindir,e.admindir,f.admindir=H,H,H,H elseif F==\"--root\"then c.rootdir=H elseif F==\"--selected-only\"then y=true elseif F==\"--skip-same-verison\"then c.options.skip_same_version=true elseif F==\"--pre-invoke\"then A=H elseif F==\"--post-invoke\"then B=H elseif F==\"--path-exclude\"then C=H elseif F==\"--path-include\"then D=H elseif F==\"--no-pager\"then c.options.pager=false elseif F==\"--no-triggers\"then c.options.triggers=false elseif F==\"--triggers\"then c.options.triggers=true end end end;local function K(t)c.error(t)print([[\n\nType dpkg --help for help about installing and deinstalling packages [*];\nUse 'apt' or 'aptitude' for user-friendly package management;\nType dpkg -Dhelp for a list of dpkg debug flag values;\nType dpkg --force-help for a list of forcing options;\nType dpkg-deb --help for help about manipulating *.deb files;\n\nOptions marked [*] produce a lot of output !]])return 2 end;if w==nil then K(\"need an action option\")end;if not a.exists(g(\"\"))then a.mkdir(g(\"info\"))a.mkdir(g(\"triggers\"))i(g(\"status\"),\"\")i(g(\"triggers/Unincorp\"),\"\")i(g(\"triggers/File\"),\"\")end;if w==0 or w==1 then if#v==0 then K((w==0 and\"--install\"or\"--unpack\")..\" needs at least one package archive file argument\")end;local L={}for E,F in ipairs(v)do if not a.exists(F)then c.error(\"cannot access archive '\"..F..\"': No such file or directory\")return 2 end;if x then if not a.isDir(F)then c.error(\"cannot access directory '\"..F..\"': Not a directory\")return 2 end;local function M(g)for E,N in ipairs(a.list(g))do if a.isDir(a.combine(g,N))then M(a.combine(g,N))elseif N:match(\"^.*%.deb$\")then c.print(\"Loading \"..F..\" (this may take a while) ...\")local O,P=pcall(c.package,N)if not O then c.error(\"cannot access archive '\"..a.combine(g,N)..\"': \"..P)return 2 end;table.insert(L,P)end end end;M(F)else c.print(\"Loading \"..F..\" (this may take a while) ...\")local O,P=pcall(c.package,F)if not O then c.error(\"cannot access archive '\"..F..\"': \"..P)return 2 end;table.insert(L,P)end end;if#L==0 then c.error(\"searched, but found no packages (files matching *.deb)\")return 2 end;local Q={}for E,F in ipairs(L)do c.print(\"Selecting previously unselected package \"..F.name..\".\")if c.package.packagedb==nil then c.readDatabase()end;c.package.packagedb[F.name]=c.package.packagedb[F.name]or{Status=\"unknown ok not-installed\"}p(c.package.packagedb[F.name],1,\"install\")if not F.unpack()or w==0 and not F.configure()then table.insert(Q,F.name)end end;if c.options.triggers then for R,F in pairs(c.package.packagedb)do if F[\"Triggers-Pending\"]then c.print(\"Processing triggers for \"..R..\" (\"..F.Version..\") ...\")f.commit(R,c.package.triggerdb,c.package.packagedb)end end end;e.writeDatabase(c.package.packagedb)if#Q>0 then c.print(\"dpkg: error processing \"..table.concat(Q,\", \"))return 2 else return 0 end elseif w==2 then if x then c.warn(\"--recursive specified, but this flag is ineffective with --configure\")end;if#v==0 then K(\"--configure needs at least one package name argument\")end;c.readDatabase()local Q={}if v[1]==\"--pending\"or v[1]==\"-a\"then for R,F in pairs(c.package.packagedb)do if e.status.needs_configure(m(F,3))then local O,P=pcall(c.package,R)if not O or not P.configure()then table.insert(Q,R)end end end else for E,R in ipairs(v)do if e.status.needs_configure(m(c.package.packagedb[R],3))then local O,P=pcall(c.package,R)if not O or not P.configure()then table.insert(Q,R)end end end end;e.writeDatabase(c.package.packagedb)if#Q>0 then c.print(\"dpkg: error processing \"..table.concat(Q,\", \"))return 2 else return 0 end elseif w==3 then if x then c.warn(\"--recursive specified, but this flag is ineffective with --triggers-only\")end;if#v==0 then K(\"--triggers-only needs at least one package name argument\")end;c.readDatabase()local Q={}if v[1]==\"--pending\"or v[1]==\"-a\"then if c.options.triggers then for R,F in pairs(c.package.packagedb)do if F[\"Triggers-Pending\"]then c.print(\"Processing triggers for \"..R..\" (\"..F.Version..\") ...\")f.commit(R,c.package.triggerdb,c.package.packagedb)end end end else if c.options.triggers then for E,R in ipairs(v)do if c.package.packagedb[R][\"Triggers-Pending\"]then c.print(\"Processing triggers for \"..R..\" (\"..c.package.packagedb[R].Version..\") ...\")f.commit(R,c.package.triggerdb,c.package.packagedb)end end end end;e.writeDatabase(c.package.packagedb)if#Q>0 then c.print(\"dpkg: error processing \"..table.concat(Q,\", \"))return 2 else return 0 end elseif w==4 then if x then c.warn(\"--recursive specified, but this flag is ineffective with --remove\")end;if#v==0 then K(\"--remove needs at least one package name argument\")end;c.readDatabase()local Q={}for E,R in ipairs(v)do local O,P=pcall(c.package,R)if O then p(c.package.packagedb[R],1,\"deinstall\")end;if not O or not P.remove(false)then table.insert(Q,R)end end;e.writeDatabase(c.package.packagedb)if#Q>0 then c.print(\"dpkg: error processing \"..table.concat(Q,\", \"))return 2 else return 0 end elseif w==5 then if x then c.warn(\"--recursive specified, but this flag is ineffective with --purge\")end;if#v==0 then K(\"--purge needs at least one package name argument\")end;c.readDatabase()local Q={}for E,R in ipairs(v)do local O,P=pcall(c.package,R)if O then p(c.package.packagedb[R],1,\"purge\")end;if not O or not P.remove(true)then table.insert(Q,R)end end;e.writeDatabase(c.package.packagedb)if#Q>0 then c.print(\"dpkg: error processing \"..table.concat(Q,\", \"))return 2 else return 0 end elseif w==6 then if x then c.warn(\"--recursive specified, but this flag is ineffective with --verify\")end;c.readDatabase()local Q={}if#v==0 then for R in pairs(c.package.packagedb)do local O,P=pcall(c.package,R)if not O or not P.verify()then table.insert(Q,R)end end else for E,R in ipairs(v)do local O,P=pcall(c.package,R)if not O or not P.verify()then table.insert(Q,R)end end end;e.writeDatabase(c.package.packagedb)if#Q>0 then c.print(\"dpkg: error verifying \"..table.concat(Q,\", \"))return 2 else return 0 end elseif w==7 then c.readDatabase()if#v==0 then for R,F in pairs(c.package.packagedb)do if not a.exists(g(\"info/\"..R..\".list\"))then c.warn(\"package \"..R..\" is missing a file list\\nTo fix this issue: reinstall the package\")end;if not a.exists(g(\"info/\"..R..\".md5sums\"))then c.warn(\"package \"..R..\" is missing an md5sum list\\nTo fix this issue: reinstall the package\")end;if m(F,1)==\"install\"then if m(F,3)==\"half-installed\"or m(F,2)==\"reinstreq\"then c.warn(\"package \"..R..\" is not installed properly\\nTo fix this issue: reinstall the package\")elseif m(F,3)==\"not-installed\"or m(F,3)==\"config-files\"then c.warn(\"package \"..R..\" is marked for installation, but it is not installed\\nTo fix this issue: install the package\")elseif m(F,3)~=\"installed\"then c.warn(\"package \"..R..\" is not configured\\nTo fix this issue: configure the package\")end elseif m(F,1)==\"deinstall\"then if m(F,3)==\"not-installed\"then c.warn(\"package \"..R..\" is marked for removal of non-config files, but config files are not installed\\nTo fix this issue: reinstall package then remove properly\")elseif m(F,3)==\"installed\"or m(F,3)==\"triggers-pending\"or m(F,3)==\"triggers-awaited\"then c.warn(\"package \"..R..\" is marked for removal, but the package hasn't been removed\\nTo fix this issue: remove the package\")elseif m(F,3)~=\"config-files\"then c.warn(\"package \"..R..\" was not removed properly\\nTo fix this issue: remove the package\")end elseif m(F,1)==\"purge\"then if m(F,3)==\"config-files\"then c.warn(\"package \"..R..\" is marked for purge, but config files are still installed\\nTo fix this issue: purge the package\")elseif m(F,3)==\"installed\"or m(F,3)==\"triggers-pending\"or m(F,3)==\"triggers-awaited\"then c.warn(\"package \"..R..\" is marked for purge, but the package hasn't been removed\\nTo fix this issue: remove the package\")elseif m(F,3)~=\"config-files\"then c.warn(\"package \"..R..\" was not purged properly\\nTo fix this issue: remove the package\")end elseif m(F,1)==\"unknown\"then c.warn(\"package \"..R..\" is in an unknown status\\nTo fix this issue: (re)install the package\")end end else for E,R in ipairs(v)do local F=c.package.packagedb[R]if not F then c.warn(\"package \"..R..\" not found\")else if not a.exists(g(\"info/\"..R..\".list\"))then c.warn(\"package \"..R..\" is missing a file list\\nTo fix this issue: reinstall the package\")end;if not a.exists(g(\"info/\"..R..\".md5sums\"))then c.warn(\"package \"..R..\" is missing an md5sum list\\nTo fix this issue: reinstall the package\")end;if m(F,1)==\"install\"then if m(F,3)==\"half-installed\"or m(F,2)==\"reinstreq\"then c.warn(\"package \"..R..\" is not installed properly\\nTo fix this issue: reinstall the package\")elseif m(F,3)==\"not-installed\"or m(F,3)==\"config-files\"then c.warn(\"package \"..R..\" is marked for installation, but it is not installed\\nTo fix this issue: install the package\")elseif m(F,3)~=\"installed\"then c.warn(\"package \"..R..\" is not configured\\nTo fix this issue: configure the package\")end elseif m(F,1)==\"deinstall\"then if m(F,3)==\"not-installed\"then c.warn(\"package \"..R..\" is marked for removal of non-config files, but config files are not installed\\nTo fix this issue: reinstall package then remove properly\")elseif m(F,3)==\"installed\"or m(F,3)==\"triggers-pending\"or m(F,3)==\"triggers-awaited\"then c.warn(\"package \"..R..\" is marked for removal, but the package hasn't been removed\\nTo fix this issue: remove the package\")elseif m(F,3)~=\"config-files\"then c.warn(\"package \"..R..\" was not removed properly\\nTo fix this issue: remove the package\")end elseif m(F,1)==\"purge\"then if m(F,3)==\"config-files\"then c.warn(\"package \"..R..\" is marked for purge, but config files are still installed\\nTo fix this issue: purge the package\")elseif m(F,3)==\"installed\"or m(F,3)==\"triggers-pending\"or m(F,3)==\"triggers-awaited\"then c.warn(\"package \"..R..\" is marked for purge, but the package hasn't been removed\\nTo fix this issue: remove the package\")elseif m(F,3)~=\"config-files\"then c.warn(\"package \"..R..\" was not purged properly\\nTo fix this issue: remove the package\")end elseif m(F,1)==\"unknown\"then c.warn(\"package \"..R..\" is in an unknown status\\nTo fix this issue: (re)install the package\")end end end end elseif w==8 then c.readDatabase()local S={}if#v==0 then for R,F in pairs(c.package.packagedb)do if m(F,3)~=\"not-installed\"then table.insert(S,{R,m(F,1)})end end else for E,R in ipairs(v)do table.insert(S,{R,m(c.package.packagedb[R],1)})end end;textutils.tabulate(table.unpack(S))elseif w==9 then elseif w==10 then c.readDatabase()for R,F in pairs(c.package.packagedb)do if F.Priority~=\"essential\"and F.Priority~=\"required\"then p(F,1,\"deinstall\")end end;e.writeDatabase(c.package.packagedb)return 0 elseif w==11 then if z==\"pkgname\"then return string.match(v[1],\"^%w[%w+-.]+$\")and 0 or 2 elseif z==\"trigname\"then return string.match(v[1],\"^%w[%w+-.]+$\")and 0 or 2 elseif z==\"archname\"then return(v[1]==\"all\"or v[1]==\"any\"or v[1]==\"phoenix\"or v[1]==\"source\")and 0 or((v[1]==\"i386\"or v[1]==\"amd64\"or v[1]==\"powerpc\"or v[1]==\"armv7h\"or v[1]==\"aarch64\"or v[1]==\"ppc64el\"or v[1]==\"ia64\"or v[1]==\"s390x\"or v[1]==\"mips\"or v[1]==\"mipsel\"or v[1]==\"mips64el\"or v[1]==\"armv7el\")and 1 or 2)elseif z==\"version\"then return c.compareVersions(v[1],\"1\")and 0 or 2 else K(\"unknown option --validate-\"..z)end elseif w==12 then if#v<3 then K(\"--compare-versions takes three arguments: <version> <relation> <version>\")end;local T=c.findRelationship(\"a\",v[1],\"a (\"..v[2]..\" \"..v[3]..\")\")if T==nil then return 2 elseif T==true then return 0 else return 1 end elseif w==13 then return b.run(\"/usr/bin/dpkg-deb\",...)elseif w==14 then return b.run(\"/usr/bin/dpkg-query\",...)end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291952,size=22540},["apt-get.lua"]={type="file",created=1740881291214,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=require\"apt.config\"local d=require\"apt.cache\"local e=require\"apt.get\"local f=require\"dpkg\"local g=assert(b.argparse({},...))c:load()local function h(i,j,k,l,m,n)if not l then error(\"Some packages could not be installed. This may mean that you have requested an impossible situation.\")end;local o,p,q,r=0,0,0,0;for s,t in pairs(m)do if t then if f.package.packagedb[s]then q=q+1 else o=o+1 end else p=p+1 end end;for s,t in pairs(f.package.packagedb)do local u=d:get(s)if u and f.compareVersions(u.version,t.Version)>0 and m[s]==nil then r=r+1 end end;if k and next(k)then print(\"The following packages have been kept back:\")io.write(\"  \")for s in pairs(k)do io.write(s..\" \")end;print(\"\")end;if q>0 then print(\"The following packages will be upgraded:\")io.write(\"  \")for s,t in pairs(m)do if t and f.package.packagedb[s]then io.write(s..\" \")end end;print(\"\")end;if o>#g-1 then print(\"The following additional packages will be installed:\")io.write(\"  \")for s,t in pairs(m)do if t and not j[s]then io.write(s..\" \")end end;print(\"\")end;if o>0 then print(\"The following packages will be installed:\")io.write(\"  \")for s,t in pairs(m)do if t then io.write(s..\" \")end end;print(\"\")end;if p>0 then print(\"The following packages will be REMOVED:\")io.write(\"  \")for s,t in pairs(m)do if not t then io.write(s..\" \")end end;print(\"\")end;print((\"%d upgraded, %d newly installed, %d to remove and %d not upgraded.\"):format(q,o,p,r))if#l==0 then return end;io.write(\"Do you want to continue? [Y/n] \")local v=io.read()if not v or v:lower()~=\"y\"then print(\"Abort.\")return end;local w={}for x,t in ipairs(n)do w[t]=e.download(t)end;e.execute(l,w,i)end;if g[1]==\"update\"then e.update()e.showStats()d:generate()elseif g[1]==\"download\"then d:load()for y=2,#g do local z=e.download(g[y])if z then a.copy(z,a.basename(z))end end;e.showStats()elseif g[1]==\"install\"then local j={}for y=2,#g do j[g[y]]=true end;io.write(\"Reading state information... \")f.package.setPackageDB()f.package.setTriggerDB()f.package.setFileDB()d:load()print(\"Done.\")h(false,j,nil,e.plan(f.package.packagedb,j,{}))elseif g[1]==\"remove\"or g[1]==\"purge\"then local j={}for y=2,#g do j[g[y]]=false end;io.write(\"Reading state information... \")f.package.setPackageDB()f.package.setTriggerDB()f.package.setFileDB()d:load()print(\"Done.\")h(g[1]==\"purge\",j,nil,e.plan(f.package.packagedb,j,{}))elseif g[1]==\"upgrade\"or g[1]==\"dist-upgrade\"or g[1]==\"full-upgrade\"then io.write(\"Reading state information... \")f.package.setPackageDB()f.package.setTriggerDB()f.package.setFileDB()d:load()print(\"Done.\")h(false,e.planUpgrade(f.package.packagedb,g[1]==\"dist-upgrade\"or g[1]==\"full-upgrade\",{}))else error(\"Unknown command '\"..g[1]..\"'\")end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291199,size=2747},["yahtcc.lua"]={type="file",created=1740881294560,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.util\"local b=require\"system.keys\"local c=require\"system.terminal\"local d=require\"system.hardware\"local e,f=c.openterm()if not e then error(\"Could not open terminal: \"..f)end;local g={[0]={0xA0,0xA0,0xA0,0xA0,0xA0,0xA0},{0x20,0x10,0x95,0x8f,0x8f,0x85},{0x08,0x20,0x95,0x8f,0x8d,0x85},{0x08,0x10,0x95,0x8f,0x8d,0x85},{0x08,0x08,0x95,0x8d,0x8d,0x85},{0x08,0x18,0x95,0x8d,0x8d,0x85},{0x97,0x97,0x95,0x8d,0x8d,0x85}}local h={{0x2F,0x34,0x00,0x38,0x1F,0x00,0x00,0x28,0x14,0x00,0x00,0x3C,0x00,0x00,0x38,0x3C,0x14,0x20,0x3C,0x3C},{0x00,0x0B,0x3F,0x07,0x00,0x00,0x00,0x2A,0x15,0x00,0x0F,0x3F,0x0F,0x2A,0x17,0x00,0x00,0x3F,0x01,0x00},{0x00,0x00,0x3F,0x00,0x38,0x0F,0x3E,0x2A,0x1F,0x2F,0x14,0x3F,0x00,0x2A,0x15,0x00,0x00,0x3F,0x00,0x00},{0x00,0x00,0x3F,0x00,0x0B,0x3C,0x2F,0x2A,0x15,0x2A,0x15,0x3F,0x00,0x02,0x2F,0x3C,0x14,0x0B,0x3D,0x3C}}local i={{0x00,0x3C,0x30,0x30,0x38,0x14,0x00},{0x00,0x15,0x17,0x17,0x15,0x15,0x00},{0x00,0x15,0x15,0x15,0x15,0x15,0x00},{0x00,0x35,0x15,0x15,0x35,0x15,0x00},{0x00,0x03,0x0F,0x0F,0x07,0x01,0x00}}local j={{{name=\"\"},{name=\"Ones\",score=function(k)local l=0;for m,n in ipairs(k)do if n.value==1 then l=l+n.value end end;return l end},{name=\"Twos\",score=function(k)local l=0;for m,n in ipairs(k)do if n.value==2 then l=l+n.value end end;return l end},{name=\"Threes\",score=function(k)local l=0;for m,n in ipairs(k)do if n.value==3 then l=l+n.value end end;return l end},{name=\"Fours\",score=function(k)local l=0;for m,n in ipairs(k)do if n.value==4 then l=l+n.value end end;return l end},{name=\"Fives\",score=function(k)local l=0;for m,n in ipairs(k)do if n.value==5 then l=l+n.value end end;return l end},{name=\"Sixes\",score=function(k)local l=0;for m,n in ipairs(k)do if n.value==6 then l=l+n.value end end;return l end},{name=\"Bonus\"}},{{name=\"Three of a Kind\",score=function(k)local o={0,0,0,0,0,0}local p=false;local q=0;for m,n in ipairs(k)do o[n.value]=o[n.value]+1;q=q+n.value;if o[n.value]>=3 then p=true end end;return p and q or 0 end},{name=\"Four of a Kind\",score=function(k)local o={0,0,0,0,0,0}local p=false;local q=0;for m,n in ipairs(k)do o[n.value]=o[n.value]+1;q=q+n.value;if o[n.value]>=4 then p=true end end;return p and q or 0 end},{name=\"Full House\",score=function(k,r)local o={0,0,0,0,0,0}for m,n in ipairs(k)do o[n.value]=o[n.value]+1 end;local s,t,u=false,false,nil;for n=1,6 do if o[n]==3 then s=true elseif o[n]==2 then t=true elseif o[n]==5 then u=n end end;if u and r[2][6].locked and not r[1][u+1].locked then return 25 end;return s and t and 25 or 0 end},{name=\"Small Straight\",score=function(k,r)local o={0,0,0,0,0,0}local u=nil;for m,n in ipairs(k)do o[n.value]=o[n.value]+1;if o[n.value]==5 then u=n.value end end;if u and r[2][6].locked and not r[1][u+1].locked then return 30 end;if o[3]==0 or o[4]==0 then return 0 elseif o[1]~=0 and o[2]~=0 or o[2]~=0 and o[5]~=0 or o[5]~=0 and o[6]~=0 then return 30 end;return 0 end},{name=\"Large Straight\",score=function(k,r)local o={0,0,0,0,0,0}local u=nil;for m,n in ipairs(k)do o[n.value]=o[n.value]+1;if o[n.value]==5 then u=n.value end end;if u and r[2][6].locked and not r[1][u+1].locked then return 40 end;if o[2]==0 or o[3]==0 or o[4]==0 or o[5]==0 then return 0 end;return(o[1]~=0 or o[6]~=0)and 40 or 0 end},{name=\"Yahtzee\",score=function(k)local v=k[1].value;for m,n in ipairs(k)do if v~=n.value then return 0 end end;return 50 end},{name=\"Chance\",score=function(k)local q=0;for m,n in ipairs(k)do q=q+n.value end;return q end},{name=\"Yahtzee Bonus\"}}}local function w(x,y,z,A)A=A or'0'local B='f'local C=g[z]e.setCursorPos(x,y)for n=1,3 do local v=C[n]if v==0x20 then e.blit(' ',B,A)elseif v<0x80 then e.blit(string.char(v+0x80),B,A)else e.blit(string.char(v),A,B)end end;e.setCursorPos(x,y+1)for n=4,6 do local v=C[n]if v==0x20 then e.blit(' ',B,A)elseif v<0x80 then e.blit(string.char(v+0x80),B,A)else e.blit(string.char(v),A,B)end end;e.setBackgroundColor(c.colors.black)e.setTextColor(c.colors.white)end;local function D(x,y,k)for z,n in ipairs(k)do w(x+(z-1)*3,y,n.value,n.locked and'4'or'0')end end;local function E(F,G,H)H=H or'0'for y=1,4 do e.setCursorPos(F,G+y-1)for m,v in ipairs(h[y])do local B,A=H,'f'if bit32.btest(v,0x20)then B,A=A,B;v=bit32.band(bit32.bnot(v),0x1F)end;v=bit32.bor(v,0x80)if v==0x80 then v=0x20 end;e.blit(string.char(v),B,A)end end;e.setBackgroundColor(c.colors.black)e.setTextColor(c.colors.white)end;local function I(F,G,J,K)J=J or'b'for y=1,5 do e.setCursorPos(F-1,G+y-1)for x,v in ipairs(i[y])do local B,A;if y>1 and y<5 and x>1 and x<6 then B,A=J,'8'else B,A=J,'f'end;if bit32.btest(v,0x20)then B,A=A,B;v=bit32.band(bit32.bnot(v),0x1F)end;v=bit32.bor(v,0x80)if v==0x80 then v=0x20 end;e.blit(string.char(v),B,A)end end;e.setCursorPos(F-6,G+2)e.setBackgroundColor(c.colors.black)e.setTextColor(c.colors.white)e.write(K and\"      \"or\" Roll \")end;local function L(x,y,r,M,N)e.setBackgroundColor(c.colors.black)e.setCursorBlink(false)for O=1,2 do for n,P in ipairs(j[O])do local Q=O==M and n==N;e.setBackgroundColor(Q and c.colors.white or(n%2==1 and c.colors.black or c.colors.gray))e.setTextColor(Q and c.colors.black or c.colors.white)e.setCursorPos(x+(O-1)*20,y+n-1)e.write(P.name..(' '):rep(16-#P.name))if not r[O][n].locked and not P.bonus then if r[O][n].value==0 then e.setTextColor(c.colors.lightGray)else e.setTextColor(c.colors.lightBlue)end else e.setTextColor(Q and c.colors.black or c.colors.white)end;if r[O][n].value==nil then e.write(\"   \")elseif r[O][n].value<10 then e.write(\"  \"..r[O][n].value)else e.write(\" \"..r[O][n].value)end end end;e.setBackgroundColor(c.colors.black)e.setTextColor(c.colors.white)end;local function R(x,y,r,S)e.setCursorPos(x,y)e.write(\"Score: \")local q=0;for O=1,2 do for n,P in ipairs(r[O])do if P.value and P.locked then q=q+P.value end end end;e.write(q)e.setCursorPos(x,y+1)e.write(\"Rolls remaining: \"..S)e.setBackgroundColor(c.colors.black)e.setTextColor(c.colors.white)end;local function T(r,k)for O=1,2 do for n,P in ipairs(j[O])do if not r[O][n].locked and P.score then r[O][n].value=P.score(k,r)end end end;if r[2][6].locked and r[2][6].value==50 then local v=k[1].value;for m,n in ipairs(k)do if v~=n.value then return r end end;r[2][8].value=100;r[2][8].locked=true end;return r end;local function U(r,V,W)if V then r[V][W].locked=true end;for O=1,2 do for n,P in ipairs(r[O])do if not P.locked then P.value=nil end end end;if(r[1][2].locked and r[1][2].value or 0)+(r[1][3].locked and r[1][3].value or 0)+(r[1][4].locked and r[1][4].value or 0)+(r[1][5].locked and r[1][5].value or 0)+(r[1][6].locked and r[1][6].value or 0)+(r[1][7].locked and r[1][7].value or 0)>=63 then r[1][8].value=35;r[1][8].locked=true end;return r end;local X=d.find(\"speaker\")local function Y(k,Z,_,a0,a1,J,a2)for m,P in ipairs(k)do if not P.locked then P.value=0 end end;D(Z,_,k)for n=1,4 do I(a0,a1,J,true)if X then X:playNote(\"hat\",2,12)X:playNote(\"hat\",2,7)end;a.sleep(0.1)I(a0+1,a1,J,true)if X then X:playNote(\"hat\",2,11)X:playNote(\"hat\",2,6)end;a.sleep(0.1)I(a0,a1,J,true)if X then X:playNote(\"hat\",2,12)X:playNote(\"hat\",2,7)end;a.sleep(0.1)I(a0-1,a1,J,true)if X then X:playNote(\"hat\",2,11)X:playNote(\"hat\",2,6)end;a.sleep(0.1)end;if X then X:playNote(\"hat\",2,3)X:playNote(\"hat\",2,6)end;for m,P in ipairs(k)do if not P.locked then P.value=math.random(1,6)end end;I(a0,a1,J,a2)D(Z,_,k)return k end;local a3={dice={x=2,y=17},rollCup={x=36,y=15},logo={x=2,y=2},status={x=23,y=3},scores={x=2,y=7}}local k={{value=0},{value=0},{value=0},{value=0},{value=0}}local r={{{},{},{},{},{},{},{},{}},{{},{},{},{},{},{},{},{}}}local a4=3;local a5,a6=false,0;local a7=0;local a8=0xb;math.randomseed(os.time())e.clear()E(a3.logo.x,a3.logo.y)R(a3.status.x,a3.status.y,r,a4)L(a3.scores.x,a3.scores.y,r)D(a3.dice.x,a3.dice.y,k)I(a3.rollCup.x,a3.rollCup.y,('%x'):format(a8))while a7<13 do local a9,aa=coroutine.yield()if a9==\"key\"then if aa.keycode==b.r and a4>0 and not(k[1].locked and k[2].locked and k[3].locked and k[4].locked and k[5].locked)then a4=a4-1;U(r)L(a3.scores.x,a3.scores.y,r)R(a3.status.x,a3.status.y,r,a4)Y(k,a3.dice.x,a3.dice.y,a3.rollCup.x,a3.rollCup.y,('%x'):format(a8),a4<1)T(r,k)if a4==0 then a5=false;a6=2;while a6<=7 and r[1][a6].locked do a6=a6+1 end;if a6>7 then a5=true;a6=1;while a6<=7 and r[2][a6].locked do a6=a6+1 end;if a6>7 then a6=0 end end;L(a3.scores.x,a3.scores.y,r,a5 and 2 or 1,a6)else a5,a6=false,0;L(a3.scores.x,a3.scores.y,r)end elseif aa.keycode==b.one and a4<3 and a4>0 then k[1].locked=not k[1].locked;D(a3.dice.x,a3.dice.y,k)elseif aa.keycode==b.two and a4<3 and a4>0 then k[2].locked=not k[2].locked;D(a3.dice.x,a3.dice.y,k)elseif aa.keycode==b.three and a4<3 and a4>0 then k[3].locked=not k[3].locked;D(a3.dice.x,a3.dice.y,k)elseif aa.keycode==b.four and a4<3 and a4>0 then k[4].locked=not k[4].locked;D(a3.dice.x,a3.dice.y,k)elseif aa.keycode==b.five and a4<3 and a4>0 then k[5].locked=not k[5].locked;D(a3.dice.x,a3.dice.y,k)elseif aa.keycode==b.q then break elseif aa.keycode==b.up and a4<3 then if a6==0 then a5=false;a6=2;while a6<=7 and r[1][a6].locked do a6=a6+1 end;if a6>7 then a5=true;a6=1;while a6<=7 and r[2][a6].locked do a6=a6+1 end;if a6>7 then a6=0 end end end;if a6>(a5 and 1 or 2)then local ab=a6;repeat a6=a6-1 until a6<(a5 and 1 or 2)or not r[a5 and 2 or 1][a6].locked;if a6<(a5 and 1 or 2)then a6=ab end end;L(a3.scores.x,a3.scores.y,r,a5 and 2 or 1,a6)elseif aa.keycode==b.down and a4<3 then if a6==0 then a5=false;a6=7;while a6>=2 and r[1][a6].locked do a6=a6-1 end;if a6<2 then a5=true;a6=7;while a6>=1 and r[2][a6].locked do a6=a6-1 end;if a6<1 then a6=0 end end end;if a6>0 and a6<7 then local ab=a6;repeat a6=a6+1 until a6>7 or not r[a5 and 2 or 1][a6].locked;if a6>7 then a6=ab end end;L(a3.scores.x,a3.scores.y,r,a5 and 2 or 1,a6)elseif(aa.keycode==b.left or aa.keycode==b.right)and a4<3 and a6~=1 and(a6==0 or not r[a5 and 1 or 2][a6].locked)then if a6==0 then a5=aa.keycode==b.right;a6=a5 and 1 or 2;while a6<=7 and r[a5 and 2 or 1][a6].locked do a6=a6+1 end;if a6>7 then a5=not a5;a6=a5 and 1 or 2;while a6<=7 and r[a5 and 2 or 1][a6].locked do a6=a6+1 end;if a6>7 then a6=0 end end else a5=not a5 end;L(a3.scores.x,a3.scores.y,r,a5 and 2 or 1,a6)elseif aa.keycode==b.enter and a6~=0 and a4<3 and not r[a5 and 2 or 1][a6].locked then U(r,a5 and 2 or 1,a6)k={{value=0},{value=0},{value=0},{value=0},{value=0}}a4=3;R(a3.status.x,a3.status.y,r,a4)L(a3.scores.x,a3.scores.y,r)D(a3.dice.x,a3.dice.y,k)I(a3.rollCup.x,a3.rollCup.y,('%x'):format(a8))a7=a7+1 elseif aa.keycode==b.c then a8=a8+1;if a8>0xf then a8=0x0 end;I(a3.rollCup.x,a3.rollCup.y,('%x'):format(a8))end elseif a9==\"mouse_click\"and aa.button==1 then if(aa.x>=a3.rollCup.x and aa.x<a3.rollCup.x+5 and aa.y>=a3.rollCup.y and aa.y<a3.rollCup.y+5 or aa.x>=a3.rollCup.x-5 and aa.x<a3.rollCup.x-1 and aa.y==a3.rollCup.y+2)and a4>0 and not(k[1].locked and k[2].locked and k[3].locked and k[4].locked and k[5].locked)then a4=a4-1;U(r)L(a3.scores.x,a3.scores.y,r)R(a3.status.x,a3.status.y,r,a4)Y(k,a3.dice.x,a3.dice.y,a3.rollCup.x,a3.rollCup.y,('%x'):format(a8),a4<1)T(r,k)if a4==0 then a5=false;a6=2;while a6<=7 and r[1][a6].locked do a6=a6+1 end;if a6>7 then a5=true;a6=1;while a6<=7 and r[2][a6].locked do a6=a6+1 end;if a6>7 then a6=0 end end;L(a3.scores.x,a3.scores.y,r,a5 and 2 or 1,a6)else a5,a6=false,0;L(a3.scores.x,a3.scores.y,r)end elseif aa.x>=a3.dice.x and aa.x<a3.dice.x+15 and aa.y>=a3.dice.y and aa.y<a3.dice.y+2 and a4<3 and a4>0 then k[math.floor((aa.x-a3.dice.x)/3)+1].locked=not k[math.floor((aa.x-a3.dice.x)/3)+1].locked;D(a3.dice.x,a3.dice.y,k)elseif aa.x>=a3.scores.x and aa.x<a3.scores.x+40 and aa.y>=a3.scores.y and aa.y<a3.scores.y+7 and a4<3 then local V,W=aa.x-a3.scores.x>=20,aa.y-a3.scores.y+1;if a5==V and a6==W and not r[V and 2 or 1][W].locked then U(r,a5 and 2 or 1,a6)k={{value=0},{value=0},{value=0},{value=0},{value=0}}a4=3;R(a3.status.x,a3.status.y,r,a4)L(a3.scores.x,a3.scores.y,r)D(a3.dice.x,a3.dice.y,k)I(a3.rollCup.x,a3.rollCup.y,('%x'):format(a8))a7=a7+1 elseif(V or W>1)and not r[V and 2 or 1][W].locked then a5=V;a6=W;L(a3.scores.x,a3.scores.y,r,a5 and 2 or 1,a6)end end end end;if a7==13 then for n=1,3 do E(a3.logo.x,a3.logo.y,'5')a.sleep(0.5)E(a3.logo.x,a3.logo.y,'0')a.sleep(0.5)end;E(a3.logo.x,a3.logo.y,'5')a.sleep(1)end;e.close()local q=0;for O=1,2 do for n,P in ipairs(r[O])do if P.value and P.locked then q=q+P.value end end end;print(\"Final score: \"..q)print(\"Thanks for playing YahtCC!\")\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294551,size=12358},["nc.lua"]={type="file",created=1740881293043,worldPermissions={execute=true,read=true,write=false},data="\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293039,size=1},["arp.lua"]={type="file",created=1740881293041,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.hardware\"local b=require\"system.network\"local c=require\"system.util\"local d=assert(c.argparse({s=false,set=\"@s\",d=false,delete=\"@d\",f=true,file=\"@f\",i=true,device=\"@i\"},...))local e;if d.i then e={a.get(d.i)}else e={a.find(\"modem\")}end;if d.s then local f,g=d[1],tonumber(d[2])if not g or not f or not f:match\"^%d+%.%d+%.%d+%.%d+$\"then error(\"Usage: arp [options] -s <ip> <id>\")end;for h,i in ipairs(e)do local j=a.path(i)b.arp.set(j,f,g)end elseif d.d then local f=d[1]if not f or not f:match\"^%d+%.%d+%.%d+%.%d+$\"then error(\"Usage: arp [options] -d <ip>\")end;for h,i in ipairs(e)do local j=a.path(i)b.arp.set(j,f,nil)end elseif d.f then for k in io.lines(d.f)do local f,g=k:match(\"^(%S+)%s+(%d+)\")if f and g then for h,i in ipairs(e)do local j=a.path(i)b.arp.set(j,f,tonumber(g))end end end else print(\"Address\\t\\tID\\tDevice\")for h,i in ipairs(e)do local j=a.path(i)local l=b.arp.list(j)for m,n in pairs(l)do print(m,n,j)end end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293036,size=958},["sha512sum.lua"]={type="file",created=1740881293804,worldPermissions={execute=true,read=true,write=false},data="return coroutine.yield(\"syscall\",\"exec\",\"/usr/bin/shasum\",\"-a\",\"512\",...)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293797,size=74},["dpkg-query.lua"]={type="file",created=1740881291976,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"dpkg.query\"local function c(d)return string.match(d,'^()[%s%z]*$')and''or string.match(d,'^[%s%z]*(.*[^%s%z])')end;local function e(f,g,h)return string.len(f)<g and string.sub(f,1,g)..string.rep(h or\" \",g-string.len(f))or string.sub(f,1,g)end;local function i()local j=io.open(a.combine(b.admindir,\"available\"),\"r\")if j==nil then error(\"Couldn't find status file\")end;local k={{}}local l=nil;local d=1;for m in j:lines()do if m==\"\"then d=d+1;k[d]={}l=nil else if string.sub(m,1,1)==\" \"and l~=nil then if l==\"Description\"then if type(k[d][l])==\"string\"then k[d][l]={Short=k[d][l],Long=\"\"}end;k[d][l].Long=k[d][l].Long..(string.sub(m,2)==\".\"and\"\\n\\n\"or string.sub(m,2))else k[d][l]=k[d][l]..(string.sub(m,2)==\".\"and\"\\n\\n\"or string.sub(m,2))end else l=string.sub(m,1,(string.find(m,\":\")or 0)-1)k[d][l]=c(string.sub(m,(string.find(m,\":\")or-1)+1))end end end;j:close()local n={}for o,p in pairs(k)do if p.Package then n[p.Package]=p end end;return n end;local q={}local r=nil;local s=\"${Package}\\t${Version}\\n\"local t=false;local u;for o,p in pairs({...})do if u then if u==0 then s=p elseif u==1 then b.admindir=p elseif u==2 then s=p end;u=nil elseif p==\"-l\"or p==\"--list\"then r=0 elseif p==\"-W\"or p==\"--show\"then r=1 elseif p==\"-s\"or p==\"--status\"then r=2 elseif p==\"-L\"or p==\"--listfiles\"then r=3 elseif p==\"--control-list\"then r=4 elseif p==\"--control-show\"then r=5 elseif p==\"-c\"or p==\"--control-path\"then r=6 elseif p==\"-S\"or p==\"--search\"then r=7 elseif p==\"-p\"or p==\"--print-avail\"then r=8 elseif p==\"-?\"or p==\"--help\"then print([[Usage: dpkg-query [<option> ...] <command>\nCommands:\n  -s|--status <package> ...        Display package status details.\n  -p|--print-avail <package> ...   Display available version details.\n  -L|--listfiles <package> ...     List files 'owned' by package(s).\n  -l|--list [<pattern> ...]        List packages concisely.\n  -W|--show [<pattern> ...]        Show information on package(s).\n  -S|--search <pattern> ...        Find package(s) owning file(s).\n      --control-list <package>     Print the package control file list.\n      --control-show <package> <file>\n                                   Show the package control file.\n  -c|--control-path <package> [<file>]\n                                   Print path for package control file.\n  -?, --help                       Show this help message.\n      --version                    Show the version.]])return 2 elseif p==\"--version\"then print(\"dpkg-query v1.0\\nPart of apt-lua for Phoenix\\nCopyright (c) 2019-2022 JackMacWindows.\")return 2 elseif string.find(p,\"--admindir=\")==1 then b.admindir=string.sub(p,12)elseif p==\"--admindir\"then u=1 elseif p==\"--load-avail\"then t=true elseif string.find(p,\"--showformat=\")==1 then s=string.sub(p,14)elseif p==\"--showformat\"then u=2 elseif p==\"-f\"then u=0 else table.insert(q,p)end end;s=string.gsub(string.gsub(s,\"\\\\n\",\"\\n\"),\"\\\\t\",\"\\t\")if r==0 then local v=nil;if q[1]~=nil then v=string.gsub(q[1],\"%*\",\".+\")end;local w=b.readDatabase()local function x(p)local y=\"\"if string.find(p.Status,\"^install \")then y=\"i\"elseif string.find(p.Status,\" hold\")then y=\"h\"elseif string.find(p.Status,\" deinstall\")then y=\"r\"elseif string.find(p.Status,\" purge\")then y=\"p\"else y=\"u\"end;if string.find(p.Status,\" not-installed\")then y=y..\"n\"elseif string.find(p.Status,\" config-files\")then y=y..\"c\"elseif string.find(p.Status,\" half-installed\")then y=y..\"H\"elseif string.find(p.Status,\" unpacked\")then y=y..\"U\"elseif string.find(p.Status,\" half-configured\")then y=y..\"F\"elseif string.find(p.Status,\" triggers-awaited\")then y=y..\"W\"elseif string.find(p.Status,\" triggers-pending\")then y=y..\"t\"elseif string.find(p.Status,\" installed\")then y=y..\"i\"else y=y..\"u\"end;if string.find(p.Status,\" reinst-required\")then y=y..\"R\"else y=y..\" \"end;local z=select(2,coroutine.yield(\"syscall\",\"termsize\"))-4;io.write(string.format(\"%3s %s %s %s\",y,e(p.Package,z/4),e(p.Version,z/4),e(p.Description.Short,z/2)))end;if v then for o,p in pairs(w)do if string.match(p.Package,v)then x(p)end end else for o,p in pairs(w)do if string.find(p.Status,\" config-files\")==nil and string.find(p.Status,\" not-installed\")==nil then x(p)end end end elseif r==1 then local v=nil;if q[1]~=nil then v=string.gsub(q[1],\"%*\",\".+\")end;local w=b.readDatabase()local function x(p)local y=\"\"if string.find(p.Status,\"^install \")then y=\"i\"elseif string.find(p.Status,\"hold\")then y=\"h\"elseif string.find(p.Status,\"deinstall\")then y=\"r\"elseif string.find(p.Status,\"purge\")then y=\"p\"else y=\"u\"end;if string.find(p.Status,\"not-installed\")then y=y..\"n\"elseif string.find(p.Status,\"config-files\")then y=y..\"c\"elseif string.find(p.Status,\"half-installed\")then y=y..\"H\"elseif string.find(p.Status,\"unpacked\")then y=y..\"U\"elseif string.find(p.Status,\"half-configured\")then y=y..\"F\"elseif string.find(p.Status,\"triggers-awaited\")then y=y..\"W\"elseif string.find(p.Status,\"triggers-pending\")then y=y..\"t\"elseif string.find(p.Status,\" installed\")then y=y..\"i\"else y=y..\"u\"end;if string.find(p.Status,\" reinst-required\")then y=y..\"R\"else y=y..\" \"end;local function A(B,C)return C~=\"\"and e(p[B],tonumber(string.sub(C,2)))or p[B]end;io.write(string.gsub(s,\"%${(.-)(;?%d*)}\",A))end;if v then for o,p in pairs(w)do if string.match(p.Package,v)then x(p)end end else for o,p in pairs(w)do if string.find(p.Status,\" config-files\")==nil and string.find(p.Status,\" not-installed\")==nil then x(p)end end end elseif r==2 then if#q<1 then error(\"Usage: dpkg-query [options...] --status <package-name...>\")end;local w=b.readDatabase()local function D(p)if type(p)==\"table\"then return p.Short..\"\\n\"..string.gsub(p.Long,\"\\n\\n\",\"\\n .\\n\")else return p end end;for E,F in pairs(q)do for o,p in pairs(w)do if o==F then for G,z in pairs(p)do print(G..\": \"..D(z))end;break end end;print(\"\")end elseif r==3 then if#q<1 then error(\"Usage: dpkg-query [options...] --listfiles <package-name...>\")end;local w=b.readDatabase()for E,F in pairs(q)do local H;if a.exists(a.combine(b.admindir,\"info/\"..F..\".list\"))then H=a.combine(b.admindir,\"info/\"..F..\".list\")else for o,p in pairs(w)do if o==F then if not a.exists(a.combine(b.admindir,\"info/\"..F..\"!\"..p.Architecture..\".list\"))then error(\"Could not find list of files for \"..F)end;H=a.combine(b.admindir,\"info/\"..F..\"!\"..p.Architecture..\".list\")break end end end;local j=a.open(H,\"r\")print(j.readAll())j.close()end elseif r==4 then if#q<1 then error(\"Usage: dpkg-query [options...] --control-list <package-name>\")end;local I={}for o,p in pairs(a.list(a.combine(b.admindir,\"info\")))do if string.match(p,\"^\"..string.gsub(q[1],\"%-\",\"%%-\")..\"%..+\")then table.insert(I,a.combine(b.admindir,\"info/\"..p))end;if o%1000==0 then os.queueEvent(\"nosleep\")os.pullEvent()end end;if#I==0 then local w=b.readDatabase()for o,p in pairs(w)do if o==q[1]then local J=\"^\"..string.gsub(q[1],\"%-\",\"%%-\")..\"!\"..p.Architecture..\"%.(.+)\"for G,z in pairs(a.list(a.combine(b.admindir,\"info\")))do if string.match(z,J)then table.insert(I,string.match(z,J))end;if G%1000==0 then os.queueEvent(\"nosleep\")os.pullEvent()end end;break end end end;for o,p in pairs(I)do if p~=\"list\"then print(p)end end elseif r==5 then if#q<2 then error(\"Usage: dpkg-query [options...] --control-show <package-name> <control-file>\")end;if a.exists(a.combine(b.admindir,\"info/\"..q[1]..\".\"..q[2]))then local j=a.open(a.combine(b.admindir,\"info/\"..q[1]..\".\"..q[2]),\"r\")print(j.readAll())j.close()else local w=b.readDatabase()for o,p in pairs(w)do if o==q[1]then if a.exists(a.combine(b.admindir,\"info/\"..q[1]..\"!\"..p.Architecture..\".\"..q[2]))then local j=a.open(a.combine(b.admindir,\"info/\"..q[1]..\"!\"..p.Architecture..\".\"..q[2]),\"r\")print(j.readAll())j.close()end;break end end end elseif r==6 then error(\"This command is deprecated upstream, therefore it will remain unimplemented here.\")elseif r==7 then if#q<1 then error(\"Usage: dpkg-query [options...] --search <pattern>\")end;local K=false;local L=false;local v=string.gsub(string.gsub(q[1],\"([^\\\\])%*\",\"%1%.%*\"),\"([^\\\\])%?\",\"%1%.%-\")if string.find(q[1],\"[%*%[%?/]\")~=1 then v=\".*\"..v..\".*\"elseif string.find(q[1],\"[%*%[%?/]\")==nil then K=true else v=\"^\"..v..\"$\"end;local I=a.find(a.combine(b.admindir,\"info/*.list\"))print(\"Searching...\")for o,p in pairs(I)do local j=assert(io.open(p,\"r\"))for m in j:lines()do if string.find(m,v,1,K)then print(string.sub(a.basename(p),1,string.find(a.basename(p),\"[!.]\")-1)..\": \"..m)L=true end end;j:close()os.queueEvent(\"nosleep\")os.pullEvent()end;if not L then error(\"no pattern matching \"..q[1])end elseif r==8 then if#q<1 then error(\"Usage: dpkg-query [options...] --print-avail <package-name...>\")end;local w=i()local function D(p)if type(p)==\"table\"then return p.Short..\"\\n\"..string.gsub(p.Long,\"\\n\\n\",\"\\n .\\n\")else return p end end;for E,F in pairs(q)do for o,p in pairs(w)do if o==F then for G,z in pairs(p)do print(G..\": \"..D(z))end;break end end;print(\"\")end else error(\"Usage: dpkg-query [options...] <command>\")end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291950,size=8892},["usermod.lua"]={type="file",created=1740881294444,worldPermissions={execute=true,read=true,write=false},data="local a=require\"usermgr\"local b=require\"system.filesystem\"local c=require\"system.process\"local d=require\"system.util\"local e=[[\nUsage: useradd [options] LOGIN\n       useradd -D\n       useradd -D [options]\nOptions:\n  -c, --comment COMMENT    new full name of the account\n  -d, --home HOME_DIR      new home directory of the account\n  -h, --help               display this help message and exit\n  -m, --move-home          move the user's home directory\n  -s, --shell SHELL        new login shell of the account\n]]local f=assert(d.argparse({c=true,comment=\"@c\",d=true,home=\"@d\",h=false,help=\"@h\",m=false,[\"move-home\"]=\"@m\",s=true,shell=\"@s\"},...))if f.h then print(e)return end;if not f[1]then io.stderr:write(e..\"\\n\")return false end;local g=c.getuser()if g~=\"root\"and g~=f[1]then error(\"usermod: Permission denied.\")end;local h=a.getUserInfo(f[1])if not h then error(\"usermod: User does not exist.\")end;if f.s==\"\"then f.s=\"/bin/cash\"end;assert(a.editUser(f[1],{fullName=f.c,home=f.d,shell=f.s}),\"usermod: Could not modify user.\")if f.m and f.d and h.home~=f.d then b.move(h.home,f.d)end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294389,size=1086},["userdel.lua"]={type="file",created=1740881294444,worldPermissions={execute=true,read=true,write=false},data="local a=require\"usermgr\"local b=require\"system.filesystem\"local c=require\"system.process\"local d=require\"system.util\"local e=[[\nUsage: userdel [options] LOGIN\nOptions:\n  -f, --force   force some actions that would fail otherwise\n                e.g. removal of user still logged in\n                or files, even if not owned by the user\n  -h, --help    display this help message and exit\n  -r, --remove  remove home directory\n]]local f=assert(d.argparse({f=false,force=\"@f\",h=false,help=\"@h\",r=false,remove=\"@r\"},...))if f.h then print(e)return end;if not f[1]then io.stdout:write(e..\"\\n\")return false end;if c.getuser()~=\"root\"then error(\"userdel: Permission denied.\")end;local g=a.getUserInfo(f[1])if not g then error(\"userdel: User does not exist.\")end;if not f.f then local h=c.getplist()for i,j in ipairs(h)do if c.getpinfo(j).user==f[1]then error(\"userdel: User is currently logged in.\")end end end;assert(a.removeUser(f[1]),\"userdel: Could not delete user.\")if f.r and g.home then b.remove(g.home)end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294389,size=1009},["update.lua"]={type="file",created=1740881291978,worldPermissions={execute=true,read=true,write=false},data="local a=\"https://phoenix.madefor.cc/packages/\"local b=require\"system.filesystem\"local c=require\"system.network\"local d=require\"system.process\"local e=require\"dpkg.control\"local f=require\"dpkg.query\"if d.getuser()~=\"root\"then error(\"This program must be run as root.\")end;print(\"Checking for updates...\")local g,h=c.get(a..\"Packages\")if not g then error(\"Could not download package list: \"..h)elseif g:responseCode()~=200 then local i=g:responseCode()g:close()error(\"Could not download package list: HTTP \"..i)end;local j=e.parseControlList(g:read(\"*a\"))g:close()local k={}for l,m in ipairs(j)do k[m.Package]=m end;local n=f.readDatabase()local o={}for p,m in pairs(n)do if not m.Status:match\"^deinstall \"and k[p]and k[p].Version~=m.Version then o[#o+1]=p end end;if#o==0 then print(\"No updates available.\")return true end;table.sort(o,function(q,r)if q==\"dpkg\"then return true elseif r==\"dpkg\"then return false else return q<r end end)print(\"The following package updates are available:\")for l,m in ipairs(o)do print(\"  \"..m..\": \"..n[m].Version..\" -> \"..k[m].Version)end;io.write(\"Install these updates? (y/N) \")local s=io.read()if not s or s:lower()~=\"y\"then return false end;b.mkdir(\"/tmp/pkgcache\")b.mount(\"tmpfs\",\"tmpfs\",\"/tmp/pkgcache\",{})for l,m in ipairs(o)do print(\"Downloading \"..m..\" (\"..math.floor(k[m].Size/1024)..\" kiB)\")g,h=c.get{url=a..m..\".deb\",encoding=\"binary\"}if not g then b.unmount(\"/tmp/pkgcache\")error(\"Failed to download package: \"..h)elseif g:responseCode()~=200 then b.unmount(\"/tmp/pkgcache\")local i=g:responseCode()g:close()error(\"Failed to download package: HTTP \"..i)end;local t,h=b.open(\"/tmp/pkgcache/\"..m..\".deb\",\"wb\")if not t then g:close()b.unmount(\"/tmp/pkgcache\")error(\"Failed to write package: \"..h)end;t.write(g:read(\"*a\"))t.close()g:close()end;local u=true;for l,m in ipairs(o)do u=d.run(\"/usr/bin/dpkg\",\"-i\",\"/tmp/pkgcache/\"..m..\".deb\")and u end;b.unmount(\"/tmp/pkgcache\")print(\"Update complete. It may be necessary to reboot your computer to use the new software.\")return u\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291953,size=2016},["su.lua"]={type="file",created=1740881294442,worldPermissions={write=false,read=true,execute=true},data="local a=require\"usermgr\"local b=require\"system.ipc\"local c=require\"system.process\"local d=require\"system.terminal\"local e=require\"system.util\"local f=assert(e.argparse({[\"\"]={stopProcessingOnPositionalArgument=true},s=true,shell=\"@s\"},...))local g=f.s or f.shell;local h=f[1]or\"root\"io.stdout:write(\"Password: \")d.termctl({echo=false})local i=io.stdin:read()d.termctl({echo=true})print()local j,k=a.authenticate(h,i)if k then print(k)end;if j then local l=a.getUserInfo(h)local m=c.fork(function()c.setuser(h)if l and l.home then c.getenv().HOME=l.home;c.chdir(l.home)end;if g then c.exec(g,table.unpack(f,2))elseif l and l.shell then c.exec(l.shell,table.unpack(f,2))else c.exec(\"/bin/sh\",table.unpack(f,2))end end)for n,o in pairs(b.signal)do b.sigaction(o,function()b.kill(m,o)end)end;repeat local p,q=coroutine.yield()until p==\"process_complete\"and q.id==m else print(\"su: Sorry\")end\n",setuser=true,permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294387,size=888},["dpkg-divert.lua"]={type="file",created=1740881291976,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"dpkg.divert\"local c={}local d=0;local e=\"/\"local f=nil;local g=\":\"local h=false;local i=nil;local j=false;local k=nil;for l,m in pairs({...})do if k then if k==0 then b.admindir=m elseif k==1 then e=m elseif k==2 then e=m;b.admindir=a.combine(m,\"var/lib/dpkg\")elseif k==3 then f=m elseif k==4 then g=m end;k=nil elseif m==\"--add\"then d=0 elseif m==\"--remove\"then d=1 elseif m==\"--list\"then d=2 elseif m==\"--listpackage\"then d=3 elseif m==\"--truename\"then d=4 elseif m==\"--admindir\"then k=0 elseif m==\"--instdir\"then k=1 elseif m==\"--root\"then k=2 elseif m==\"--divert\"then k=3 elseif m==\"--local\"then g=\":\"elseif m==\"--package\"then k=4 elseif m==\"--quiet\"then h=true elseif m==\"--rename\"then i=true elseif m==\"--no-rename\"then i=false elseif m==\"--test\"then j=true elseif m==\"-?\"or m==\"--help\"then print([[Usage: dpkg-divert [<option> ...] <command>\nCommands:\n  [--add] <file>           add a diversion.\n  --remove <file>          remove the diversion.\n  --list [<glob-pattern>]  show file diversions.\n  --listpackage <file>     show what package diverts the file.\n  --truename <file>        return the diverted file.]])return 2 elseif m==\"--version\"then print(\"dpkg-divert v1.0\\nPart of apt-lua for Phoenix\\nCopyright (c) 2019-2022 JackMacWindows.\")return 2 else table.insert(c,m)end end;if d==0 then if#c<1 then error(\"Usage: dpkg-divert [options...] [--add] <file>\")end;f=f or c[1]..\".distrib\"if g==\":\"and not h then print(\"Adding 'local diversion of \"..c[1]..\" to \"..f..\"'\")elseif not h then print(\"Adding 'diversion of \"..c[1]..\" to \"..f..\" by \"..g..\"'\")end;if not j then b.add(c[1],f,g)end;if i then a.move(c[1],f)end elseif d==1 then if#c<1 then error(\"Usage: dpkg-divert [options...] --remove <file>\")end;local n=b.parse()if n[c[1]]==nil then return end;if g==\":\"and not h then print(\"Removing 'local diversion of \"..c[1]..\" to \"..n[c[1]].name..\"'\")elseif not h then print(\"Removing 'diversion of \"..c[1]..\" to \"..n[c[1]].name..\" by \"..n[c[1]].package..\"'\")end;if not j then b.remove(c[1])end;if i then a.move(n[c[1]].name,c[1])end elseif d==2 then if h then return end;if#c<1 then error(\"Usage: dpkg-divert [options...] --list <glob>\")end;c[1]=string.gsub(c[1],\"%*\",\"%.%*\")for l,m in pairs(b.parse())do if string.match(l,c[1])then if m.package==\":\"then print(\"local diversion of \"..l..\" to \"..m.name)else print(\"diversion of \"..l..\" to \"..m.name..\" by \"..m.package)end end end elseif d==3 then if h then return end;if#c<1 then error(\"Usage: dpkg-divert [options...] --listpackage <file>\")end;local o=b.parse()[c[1]]if o~=nil then if o.package==\":\"then print(\"LOCAL\")else print(o.package)end end elseif d==4 then if h then return end;if#c<1 then error(\"Usage: dpkg-divert [options...] --truename <file>\")end;local o=b.parse()[c[1]]if o==nil then print(c[1])else print(o.name)end end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291950,size=2840},["tracc.lua"]={type="file",created=1740881294228,worldPermissions={execute=true,read=true,write=false},data="\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881294225,size=1},["apt-key.lua"]={type="file",created=1740881291215,worldPermissions={execute=true,read=true,write=false},data="\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291199,size=1},["unxz.lua"]={type="file",created=1740881292924,worldPermissions={execute=true,read=true,write=false},data="local a=require\"muxzcat\"local b=setmetatable({},{__index=function(self,c)return function(...)local d=table.pack(coroutine.yield(\"syscall\",c,...))if d[1]then return table.unpack(d,2,d.n)else error(d[2],2)end end end,__newindex=function()end})local function e()print([[Usage: unxz [OPTION]... [FILE]...\nDecompress FILEs in the .xz format.\n\n  -k, --keep         keep (don't delete) input files\n  -f, --force        force overwrite of output file\n  -c, --stdout       write to standard output and don't delete input files\n  -h, --help         display this help and exit\n  -V, --version      display the version number and exit\n\nReport bugs to https://github.com/MCJack123/CC-Archive/issues.\nUses JackMacWindows's Lua port of muxzcat. Licensed under GPL v2.0.]])end;local f={}local g=false;local h=false;local i=false;local j=false;for k,l in ipairs({...})do if#l==2 then if l==\"-z\"or l==\"-t\"or l==\"-l\"then error(\"unxz: This program only supports decompression.\")elseif l==\"-k\"then g=true elseif l==\"-f\"then h=true elseif l==\"-c\"then i=true;g=true elseif l==\"-h\"then return e()elseif l==\"-V\"then print(\"unxz 0.9 for Phoenix\")return end elseif l:sub(1,2)==\"--\"then if l==\"--compress\"or l==\"--test\"or l==\"--list\"then error(\"unxz: This program only supports decompression.\")elseif l==\"--keep\"then g=true elseif l==\"--force\"then h=true elseif l==\"--stdout\"or l==\"--to-stdout\"then i=true elseif l==\"--ignore-check\"then j=true elseif l==\"--help\"then return e()elseif l==\"--version\"then print(\"unxz 0.9 for Phoenix\")return end else table.insert(f,l)end end;local m=true;if#f==0 then error(\"unxz: Missing input. Type --help for help.\")end;for k,l in ipairs(f)do if not b.stat(l)then io.stderr:write(\"unxz: Could not open \"..l..\": File not found\\n\")elseif b.stat(l).type==\"directory\"then io.stderr:write(\"unxz: Could not open \"..l..\": Is a directory\\n\")elseif l:sub(-3)~=\".xz\"then io.stderr:write(\"unxz: \"..l..\": Filename has an unknown suffix, skipping\\n\")elseif not h and b.stat(l:sub(1,-4))then io.stderr:write(\"unxz: \"..l:sub(1,-4)..\": File exists\\n\")elseif i then local n=assert(io.open(l,\"rb\"))local o=n:read(\"*a\")n:close()local p,q=a.DecompressXzOrLzmaString(o)if p==nil then io.stderr:write(\"unxz: \"..l..\": Could not decompress: \"..a.GetError(q)..\"\\n\")m=false else io.stdout:write(p)end else local r,q=a.DecompressXzOrLzmaFile(l,l:sub(1,-4))if not r then io.stderr:write(\"unxz: \"..l..\": Could not decompress: \"..a.GetError(q)..\"\\n\")m=false elseif not g then os.remove(l)end end end;return m\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292922,size=2485},["signtool.lua"]={type="file",created=1740881292486,worldPermissions={execute=true,read=true,write=false},data="\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292479,size=1},["sha256sum.lua"]={type="file",created=1740881293803,worldPermissions={execute=true,read=true,write=false},data="return coroutine.yield(\"syscall\",\"exec\",\"/usr/bin/shasum\",\"-a\",\"256\",...)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293796,size=74},["apt-cache.lua"]={type="file",created=1740881291212,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.util\"local b=require\"apt.config\"local c=require\"apt.cache\"local d=assert(a.argparse({p=true,[\"pkg-cache\"]=\"@p\",s=true,[\"src-cache\"]=\"@s\",q=false,quiet=\"@q\",i=false,important=\"@i\",[\"no-pre-depends\"]=false,[\"no-depends\"]=false,[\"no-recommends\"]=false,[\"no-suggests\"]=false,[\"no-conflictss\"]=false,[\"no-breaks\"]=false,[\"no-replaces\"]=false,[\"no-enhances\"]=false,implicit=false,f=false,full=\"@f\",a=false,[\"all-versions\"]=\"@a\",g=false,generate=\"@g\",[\"no-generate\"]=false,n=false,[\"names-only\"]=\"@n\",[\"all-names\"]=false,recurse=false,installed=false,[\"with-source\"]=true,h=false,help=\"@h\",v=false,version=\"@v\",c=true,[\"config-file\"]=\"@c\",o=\"multiple\",option=\"@o\"},...))if d.v then print(\"apt-cache 1.0\")return end;if not d[1]or d.h then print[[\nUsage: apt-cache [options] command\n       apt-cache [options] show pkg1 [pkg2 ...]\n\napt-cache queries and displays available information about installed\nand installable packages. It works exclusively on the data acquired\ninto the local cache via the 'update' command of e.g. apt-get. The\ndisplayed information may therefore be outdated if the last update was\ntoo long ago, but in exchange apt-cache works independently of the\navailability of the configured sources (e.g. offline).\n\nMost used commands:\n  showsrc - Show source records\n  search - Search the package list for a regex pattern\n  depends - Show raw dependency information for a package\n  rdepends - Show reverse dependency information for a package\n  show - Show a readable record for the package\n  pkgnames - List the names of all packages in the system\n  policy - Show policy settings\n\nSee apt-cache(8) for more information about the available commands.\nConfiguration options and syntax is detailed in apt.conf(5).\nInformation about how to configure sources can be found in sources.list(5).\nPackage and version choices can be expressed via apt_preferences(5).\nSecurity details are available in apt-secure(8).\n]]return end;b:load()if d.c then local e=assert(io.open(d.c,\"r\"))local f=e:read(\"*a\")e:close()b:append(f)end;if d.o then for g,h in ipairs(d.o)do local i,j=h:match(\"^([A-Za-z0-9/%-:%._+])=(.*)$\")if not i then error(\"Invalid option: \"..h)end;local k={}for l in i:match(\"[^:]+\")do k[#k+1]=l end;local m=b;for n=1,#k-1 do local l=k[n]:lower()if not m[l]then m[l]={}end;m=m[l]end;m[k[#k]]=j end end;if d[1]==\"gencaches\"then c:generate()elseif d[1]==\"showpkg\"then if not d[\"no-generate\"]then c:generate()end;c:load()for n=2,#d do local o=c:get(d[n])if o then print(\"Package: \"..o.name)print(\"Versions:\")print(o.version)print(\"Reverse Depends:\")for g,h in ipairs(o.depended)do print(\"  \"..h.package..\",\"..o.name..\" \"..(h.version or\"\"))end;print(\"Dependencies:\")io.write(o.version..\" - \")for g,h in ipairs(o.depends)do io.write(h.package..\" (\"..(h.relation or\"0\")..\" \"..(h.version or\"(null)\")..\") \")end;print()print(\"Provides:\")io.write(o.version..\" - \")for g,h in ipairs(o.provides)do io.write(h.package..\"(= \"..(h.version or\"(null)\")..\") \")end;print()end end elseif d[1]==\"stats\"then elseif d[1]==\"showsrc\"then elseif d[1]==\"dump\"then elseif d[1]==\"dumpavail\"then elseif d[1]==\"unmet\"then elseif d[1]==\"show\"then elseif d[1]==\"search\"then elseif d[1]==\"depends\"then elseif d[1]==\"rdepends\"then elseif d[1]==\"pkgnames\"then else error(\"Unknown command '\"..d[1]..\"'\")end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291198,size=3297},["sha224sum.lua"]={type="file",created=1740881293802,worldPermissions={execute=true,read=true,write=false},data="return coroutine.yield(\"syscall\",\"exec\",\"/usr/bin/shasum\",\"-a\",\"224\",...)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293795,size=74},["sha1sum.lua"]={type="file",created=1740881293802,worldPermissions={execute=true,read=true,write=false},data="return coroutine.yield(\"syscall\",\"exec\",\"/usr/bin/shasum\",\"-a\",\"1\",...)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293794,size=72},["route.lua"]={type="file",created=1740881293044,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.hardware\"local b=require\"system.network\"local function c(d)if d:match\"^%d+$\"then return tonumber(d)elseif d:match\"^%d+%.%d+$\"then return tonumber(d:match\"^%d+\")*0x1000000+tonumber(d:match\"^%d+%.(%d+)\")elseif d:match\"^%d+%.%d+%.%d+$\"then return tonumber(d:match\"^(%d+)\")*0x1000000+tonumber(d:match\"^%d+%.(%d+)\")*0x10000+tonumber(d:match\"^%d+%.%d+%.(%d+)\")elseif d:match\"^%d+%.%d+%.%d+%.%d+$\"then return tonumber(d:match\"^(%d+)\")*0x1000000+tonumber(d:match\"^%d+%.(%d+)\")*0x10000+tonumber(d:match\"^%d+%.%d+%.(%d+)\")*0x100+tonumber(d:match\"^%d+%.%d+%.%d+%.(%d+)\")else error(\"Invalid IP address\",2)end end;local function e(f)if not f then return nil end;return(\"%d.%d.%d.%d\"):format(bit32.band(bit32.rshift(f,24),0xFF),bit32.band(bit32.rshift(f,16),0xFF),bit32.band(bit32.rshift(f,8),0xFF),bit32.band(f,0xFF))end;local function g(f)return bit32.bnot(2^(32-f)-1)end;local function h(i)local j=0;while bit32.btest(i,0x80000000)do i,j=bit32.lshift(i,1),j+1 end;return j end;local function k(f)return e(g(f))end;local l={...}if l[1]==\"add\"then local m={}local n=2;while n<=#l do if l[n]==\"netmask\"then m.sourceNetmask=l[n+1]n=n+2 elseif l[n]==\"gw\"then m.action=\"unicast\"m.destination=l[n+1]n=n+2 elseif l[n]==\"dev\"then m.device=l[n+1]n=n+2 elseif l[n]==\"table\"then m.table=tonumber(l[n+1])n=n+2 elseif l[n]==\"reject\"then m.action=\"prohibit\"n=n+1 elseif l[n]==\"default\"then m.source=\"0.0.0.0\"m.sourceNetmask=0;n=n+1 elseif l[n]==\"-host\"then m.action=\"local\"m.sourceNetmask=32;n=n+1 elseif l[n]==\"-net\"then m.action=\"local\"n=n+1 else m.source=l[n]if m.source:match\"^[%d%.]+/%d+$\"then m.source,m.sourceNetmask=m.source:match\"^([%d%.]+)/(%d+)$\"m.sourceNetmask=tonumber(m.sourceNetmask)end;n=n+1 end end;if not m.device then if m.action==\"local\"then for o,p in ipairs{a.find(\"modem\")}do local q=a.path(p)local d=b.ipconfig(q)if d then local r=c(d.ip)local s=g(d.netmask)local t=c(m.source)if bit32.band(t,s)==bit32.band(r,s)then m.device=q;break end end end;if not m.device then error(\"Could not find suitable device; please specify 'dev <device>'\")end elseif m.action==\"unicast\"then for o,p in ipairs{a.find(\"modem\")}do local q=a.path(p)local d=b.ipconfig(q)if d then local r=c(d.ip)local s=g(d.netmask)local t=c(m.destination)if bit32.band(t,s)==bit32.band(r,s)then m.device=q;break end end end;if not m.device then error(\"Could not find suitable device; please specify 'dev <device>'\")end end end;b.route.add(m)elseif l[1]==\"del\"then local u,i,f;local n=2;while n<=#l do if l[n]==\"netmask\"then i=l[n+1]n=n+2 elseif l[n]==\"table\"then f=tonumber(l[n+1])n=n+2 elseif l[n]==\"default\"then u=\"0.0.0.0\"i=0;n=n+1 elseif l[n]==\"-host\"then i=32;n=n+1 elseif l[n]==\"-net\"or l[n]==\"reject\"then n=n+1 elseif l[n]==\"gw\"or l[n]==\"table\"then n=n+2 else u=l[n]if u:match\"^[%d%.]+/%d+$\"then u,i=u:match\"^([%d%.]+)/(%d+)$\"i=tonumber(i)end;n=n+1 end end;b.route.remove(u,i,f)elseif l[1]==nil then print(\"Destination\\tGateway \\tNetmask \\tFlags\\tTable\\tDevice\")for n=0,1024 do local v=b.route.list(n)if not v then break end;for o,w in ipairs(v)do local x=\"U\"if w.sourceNetmask==32 then x=x..\"H\"end;if w.action==\"unicast\"then x=x..\"G\"end;if w.action==\"unreachable\"or w.action==\"prohibit\"then x=x..\"!\"end;print(w.source,w.destination or\"0.0.0.0 \",k(w.sourceNetmask),x,n,w.device or\"*\")end end else error(\"Usage: route [add|del] [options...]\")end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293040,size=3334},["apt.lua"]={type="file",created=1740881291215,worldPermissions={execute=true,read=true,write=false},data="\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291201,size=1},["ifconfig.lua"]={type="file",created=1740881293042,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.hardware\"local b=require\"system.network\"local c={...}local d=table.remove(c,1)if not d then for e,f in ipairs{a.find(\"modem\")}do local g=a.path(f)local h=b.ipconfig(g)if h then print(g..\": \"..(h.up and\"up\"or\"down\")..\", ip \"..h.ip..\", netmask \"..h.netmask)else print(g..\": down, no ip\")end end;return end;local f=a.wrap(d)if not f then error(\"No such device\")end;if not a.hasType(f,\"modem\")then error(\"Interface is not a modem\")end;local i=1;local j={}while i<=#c do if c[i]==\"up\"then j.up=true;i=i+1 elseif c[i]==\"down\"then j.up=false;i=i+1 elseif c[i]==\"netmask\"then j.netmask=tonumber(c[i+1])or c[i+1]i=i+2 else if c[i]:match(\"([^/]+)/%d+$\")then j.ip,j.netmask=c[i]:match(\"([^/]+)/(%d+)$\")j.netmask=tonumber(j.netmask)else j.ip=c[i]end;i=i+1 end end;b.ipconfig(d,j)\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293038,size=791},["sudo.lua"]={type="file",created=1740881294443,worldPermissions={write=false,read=true,execute=true},data="local a=require\"usermgr\"local b=require\"system.ipc\"local c=require\"system.process\"local d=require\"system.terminal\"local e=require\"system.util\"local f=assert(e.argparse({[\"\"]={stopProcessingOnPositionalArgument=true},D=true,chdir=\"@D\",E=false,[\"preserve-env\"]=\"@E\",H=false,[\"set-home\"]=\"@H\",i=false,login=\"@i\",K=false,[\"remove-timestamp\"]=\"@K\",k=false,[\"reset-timestamp\"]=\"@k\",l=false,list=\"@l\",n=false,[\"non-interactive\"]=\"@n\",p=true,prompt=\"@p\",R=true,chroot=\"@R\",s=false,shell=\"@s\",U=true,[\"other-user\"]=\"@U\",T=\"number\",[\"command-timeout\"]=\"@T\",u=true,user=\"@u\",v=false,validate=\"@v\",V=false,version=\"@V\",h=false,help=\"@h\"},...))local g,h=c.getuser()if g~=\"root\"then error(\"This program must be run as root. Make sure the setuser bit is set.\")end;if not f[1]or f.h then print(\":help\")return end;local i=f.u or f.user or\"root\"io.stdout:write(\"Password: \")d.termctl({echo=false})local j=io.stdin:read()d.termctl({echo=true})print()local k,l=a.authenticate(h,j)if l then print(l)end;if k then local m=a.getUserInfo(i)local n=c.fork(function()c.setuser(i)if m and m.home then c.getenv().HOME=m.home;c.chdir(m.home)end;c.execp(table.unpack(f))end)for o,p in pairs(b.signal)do b.sigaction(p,function()b.kill(n,p)end)end;repeat local q,r=coroutine.yield()until q==\"process_complete\"and r.id==n else print(\"sudo: Sorry\")end\n",setuser=true,permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294388,size=1318},["apt-add-repository.lua"]={type="file",created=1740881291211,worldPermissions={write=false,read=true,execute=true},data="local a=require\"system.network\"local b=require\"system.serialization\"local c=require\"system.util\"local d=require\"pgp\"local e=assert(c.argparse({h=false,help=\"@h\",d=false,debug=\"@d\",r=false,remove=\"@r\",s=false,[\"enable-source\"]=\"@s\",c=\"multiple\",component=\"@c\",p=true,pocket=\"@p\",y=false,yes=\"@y\",l=false,login=\"@l\",[\"dry-run\"]=false,L=false,list=\"@L\",P=true,ppa=\"@P\",C=true,cloud=\"@C\",U=true,uri=\"@U\",S=false,sourceslist=\"@S\"},...))local f,g,h=nil,e.p or\"release\",e.c and table.concat(e.c,\" \")or\"main\"if e.P then local i,j=e.P:match\"^ppa:(%w+)/(%w+)$\"if not i then i,j=e.P:match\"^(%w+)/(%w+)$\"if not i then i,j=e.P:match\"^%w+$\",\"ppa\"if not i then error(\"Invalid PPA specification\")end end end;f=\"https://ppa.launchpadcontent.net/\"..i..\"/\"..j..\"/ubuntu/\"print(\"Querying Launchpad for PPA information...\")local k=assert(a.getData(\"https://api.launchpad.net/1.0/~\"..i..\"/+archive/\"..j,{Accept=\"application/json\"}))local l=assert(b.json.decode(k))print(l.displayname..\": \"..l.description)io.write(\"Continue adding PPA? (Y/n) \")if e.y then print(\"y\")else local m=io.read()if not m:lower():find(\"y\")then print(\"Abort.\")return end end;local n=assert(l.signing_key_fingerprint)print(\"Adding key ID \"..n..\" to trusted.gpg.d...\")local o=assert(a.getData(\"https://keyserver.ubuntu.com/pks/lookup?op=get&search=0x\"..n))local p=d.decodeASC(o)local q=assert(io.open(\"/etc/apt/trusted.gpg.d/ppa-\"..i..\"-\"..j..\".gpg\",\"wb\"))q.write(p)q.close()elseif e.C then elseif e.U then elseif e.S then else end\n",setuser=false,permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881291197,size=1482},["pgp.lua"]={type="file",created=1740881293154,worldPermissions={execute=true,read=true,write=false},data="\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293151,size=1},["dpkg-deb.lua"]={type="file",created=1740881291975,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=require\"ar\"local d=require\"dpkg.deb\"local e=require\"tar\"local function f(g)return string.match(g,'^()[%s%z]*$')and''or string.match(g,'^[%s%z]*(.*[^%s%z])')end;local function h(i,j,k)return string.len(i)<j and string.sub(i,1,j)..string.rep(k or\" \",j-string.len(i))or i end;local function l(i,j,k)return string.len(i)<j and string.rep(k or\" \",j-string.len(i))..string.sub(i,1,j)or i end;local function m(n,o,p)a.mkdir(o)local q={}for r,s in pairs(n)do if r~=\"//\"and type(r)==\"string\"then local t=a.combine(o,r)if s[\"//\"]~=nil then local u=m(s,t,true)for v,w in pairs(u)do table.insert(q,w)end elseif s.type==1 or s.type==2 then table.insert(q,s)elseif s.type==0 or s.type==7 then local x=a.open(t,\"wb\")for g in string.gmatch(s.data,\".\")do x.write(string.byte(g))end;x.close()if s.owner~=nil then a.chmod(t,nil,bit32.band(s.mode,7))if s.ownerName~=nil and s.ownerName~=\"\"then a.chmod(t,s.ownerName,bit32.band(bit32.rshift(s.mode,3),7))a.chown(t,s.ownerName)elseif s.owner==0 then a.chmod(t,\"root\",bit32.band(bit32.rshift(s.mode,3),7))a.chown(t,\"root\")end end elseif s.type~=nil then print(\"Unimplemented type \"..s.type)end;if d.verbose then print((s[\"//\"]and s[\"//\"].name or s.name or\"?\")..\" => \"..(t or\"?\"))end end end;if p then return q else for r,s in pairs(q)do end end end;local function y(z,i,k)local A=\"\"for B=1,string.len(i)do A=A..(bit32.band(z,bit32.lshift(1,string.len(i)-B))==0 and k or string.sub(i,B,B))end;return A end;local C=nil;local D=false;local E=5;local F=\"${Package}\\t${Version}\\n\"local G=true;local H=true;local I={}for r,s in pairs({...})do if s==\"-b\"or s==\"--build\"then C=0 elseif s==\"-I\"or s==\"--info\"then C=1 elseif s==\"-W\"or s==\"--show\"then C=2 elseif s==\"-f\"or s==\"--field\"then C=3 elseif s==\"-c\"or s==\"--contents\"then C=4 elseif s==\"-x\"or s==\"--extract\"then C=5 elseif s==\"-X\"or s==\"--vextract\"then C=5;d.verbose=true elseif s=='-R'or s==\"--raw-extract\"then C=7 elseif s==\"--ctrl-tarfile\"then C=5;D=true elseif s==\"--fsys-tarfile\"then C=6;D=true elseif s==\"-e\"or s==\"--control\"then C=6 elseif s==\"-?\"or s==\"--help\"then print([[Usage: dpkg-deb [<option> ...] <command>\nCommands:\n  -b|--build <directory> [<deb>]     Build an archive.\n  -c|--contents <deb>                List contents.\n  -I|--info <deb> [<cfile> ...]      Show info to stdout.\n  -W|--show <deb>                    Show information on package(s)\n  -f|--field <deb> [<cfield> ...]    Show field(s) to stdout.\n  -e|--control <deb> [<directory>]   Extract control info.\n  -x|--extract <deb> <directory>     Extract files.\n  -X|--vextract <deb> <directory>    Extract & list files.\n  -R|--raw-extract <deb> <directory> Extract control info and files.\n  --ctrl-tarfile <deb>               Output control tarfile.\n  --fsys-tarfile <deb>               Output filesystem tarfile.\n  -?, --help                         Show this help message.\n      --version                      Show the version.]])return 2 elseif s==\"--version\"then print(\"dpkg-deb v1.0\\nPart of apt-lua for Phoenix\\nCopyright (c) 2019-2022 JackMacWindows.\")return 2 elseif string.find(s,\"--showformat=\")==1 then F=string.sub(s,14)elseif string.sub(s,1,2)==\"-z\"then E=tonumber(string.sub(s,3))elseif s==\"--no-uniform-compression\"then G=false elseif s==\"--uniform-compression\"then G=true elseif s==\"--nocheck\"then H=false elseif s==\"-v\"or s==\"--verbose\"then d.verbose=true else table.insert(I,s)end end;F=string.gsub(string.gsub(F,\"\\\\n\",\"\\n\"),\"\\\\t\",\"\\t\")if C==0 then if#I<1 then error(\"Usage: dpkg-deb [options...] --build <binary-directory> [archive|directory]\")end;local J=I[1]local K=I[2]or J..\".deb\"if not a.isDir(J)then error(J..\" is not a directory\")elseif not a.isDir(a.combine(J,\"DEBIAN\"))then error(\"A subdirectory named DEBIAN is required.\")end;if d.verbose and a.isDir(K)then print(\"Output is a directory, forcing check\")end;if H or a.isDir(K)then local x=a.open(a.combine(J,\"DEBIAN/control\"),\"r\")if not x then error(\"Control file not found.\")end;local A={}local L=nil;local M=x.readLine()local B=1;while M~=nil do if string.sub(M,1,1)==\" \"and L~=nil then if L==\"Description\"then if type(A[L])==\"string\"then A[L]={Short=A[L],Long=\"\"}end;A[L].Long=A[L].Long..(string.sub(M,2)==\".\"and\"\\n\\n\"or string.sub(M,2))else A[L]=A[L]..(string.sub(M,2)==\".\"and\"\\n\"or string.sub(M,2))end else if string.find(M,\":\")==nil then x.close()error(\"Error while checking control (line \"..B..\"): Missing separator\\n    \"..M)end;L=string.sub(M,1,string.find(M,\":\")-1)A[L]=f(string.sub(M,string.find(M,\":\")+1))end;M=x.readLine()B=B+1 end;x.close()if A.Package==nil then error(\"Error while checking control: Missing \\\"Package\\\" field\")end;if A.Version==nil then error(\"Error while checking control: Missing \\\"Version\\\" field\")end;if A.Architecture==nil then error(\"Error while checking control: Missing \\\"Architecture\\\" field\")end;if A.Maintainer==nil then error(\"Error while checking control: Missing \\\"Maintainer\\\" field\")end;if A.Description==nil then error(\"Error while checking control: Missing \\\"Description\\\" field\")end;if a.isDir(K)then K=a.combine(K,A.Package..\"_\"..A.Version..\"_\"..A.Architecture..\".deb\")end;print(\"Successfully checked package \\\"\"..A.Package..\"\\\".\")end;if d.verbose then print(\"Creating control archive...\")end;local N=e.save(e.pack(a.combine(J,\"DEBIAN\")))if d.verbose then print(\"Creating data archive...\")end;local n=e.pack(J)n.DEBIAN=nil;local O=e.save(n)if d.verbose then print(\"Compressing archives...\")end;local P=LibDeflate:CompressGzip(N,{level=G and E or 5})local Q=LibDeflate:CompressGzip(O,{level=E})if d.verbose then print(\"Writing package...\")end;c.save({{name=\"debian-binary\",timestamp=os.time(),owner=0,group=0,mode=0x1FF,data=\"2.0\\n\"},{name=\"control.tar.gz\",timestamp=os.time(),owner=0,group=0,mode=0x1FF,data=P},{name=\"data.tar.gz\",timestamp=os.time(),owner=0,group=0,mode=0x1FF,data=Q}},K)elseif C==1 then if#I<1 then error(\"Usage: dpkg-deb [options...] --info <archive> [control-file-name...]\")end;local R=d.load(I[1])print(\"new Debian package, version 2.0.\")print(\"size \"..R.data_size..\" bytes: control archive=\"..R.control_size..\" bytes.\")local S={}local T={0,0,0}for r,s in pairs(R.control_archive)do if r~=\"//\"then local U=0;for u in string.gmatch(s.data or\"\",\"[^\\n]+\")do U=U+1 end;local t={tostring(string.len(s.data or\"\")),tostring(U),r}for u,w in pairs(t)do if string.len(w)+2>T[u]then T[u]=string.len(w)+2 end end;table.insert(S,t)end end;for r,s in pairs(S)do print(l(s[1],T[1])..\" bytes,\"..l(s[2],T[2])..\" lines   \"..h(s[3],T[3]))end;print(R.control_archive.control.data)elseif C==2 then if#I<1 then error(\"Usage: dpkg-deb [options...] --show <archive>\")end;local R=d.load(I[1])io.write(({string.gsub(F,\"%${(.-)}\",R.control)})[1])elseif C==3 then if#I<1 then error(\"Usage: dpkg-deb [options...] --field <archive> [control-field-name...]\")end;local R=d.load(I[1])local function H(s)if type(s)==\"table\"then return s.Short..\"\\n\"..s.Long else return s end end;for r,s in pairs(R.control)do if#I>1 then for u,w in pairs(I)do if r==w then print(r..\": \"..H(s))break end end else print(r..\": \"..H(s))end end elseif C==4 then if#I<1 then error(\"Usage: dpkg-deb [options...] --contents <archive>\")end;local R=d.load(I[1],true)local V={}local T={0,0,0,0,0}for r,s in pairs(R.data)do local W=os.date(\"%F %R\",s.timestamp or 0)local t={y(s.mode+(s.type==5 and 0x200 or 0),\"drwxrwxrwx\",\"-\"),(s.ownerName or s.owner or 0)..\"/\"..(s.groupName or s.group or 0),string.len(s.data or\"\"),W,s.name..(s.link and s.link~=\"\"and\" -> \"..s.link or\"\")}for u,w in pairs(t)do if string.len(w)+1>T[u]then T[u]=string.len(w)+1 end end;table.insert(V,t)end;for r,s in pairs(V)do for u,w in pairs(s)do io.write((u==3 and l or h)(w,T[u])..(u==3 and\" \"or\"\"))end;print(\"\")end elseif C~=nil and C>=5 and C<=7 then if#I<1 or not D and C~=6 and#I<2 then error(\"Usage: dpkg-deb [options...] --extract <archive> <directory>\")end;local R=d.load(I[1],false,D)local X=I[2]or(C==6 and\"DEBIAN\"or b.getcwd())if not D then a.mkdir(X)end;if C~=6 then if D then print(R[2])else m(R.data,X)end end;if C~=5 then if D then print(R[1])else m(R.control_archive,C==7 and a.combine(X,\"DEBIAN\")or X)end end else error(\"Usage: dpkg-deb [options...] <command>\")end\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291949,size=8167},["certutil.lua"]={type="file",created=1740881292485,worldPermissions={execute=true,read=true,write=false},data="\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881292478,size=1},["ping.lua"]={type="file",created=1740881293043,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.util\"local b=require\"system.process\"local c=assert(...)print(\"Pinging \"..c..\"...\")a.syscall.netevent(true)local d={}b.newthread(function()while true do local e,f=coroutine.yield()if e==\"network_event\"and f.type==\"control\"and f.sender==c then if f.messageType==\"pong\"then local g=tonumber(f.payload.payload.error)local h=(os.time()-d[g][1])*1000;print(\"Response from \"..c..\": seq=\"..g..\" time=\"..(h>=1000 and\"%d\"or\"%.3g\"):format(h)..\" ms\")d[g]=nil elseif f.messageType==\"unreachable\"then print(f.error or\"Destination unreachable\")end elseif e==\"timer\"then for i,j in pairs(d)do if j[2]==f.id then print(\"Host is down\")d[i]=nil end end end end end)local i=1;while true do d[i]={os.time(),a.syscall.timer(2)}a.syscall.netcontrol(c,\"ping\",tostring(i))i=i+1;a.sleep(1)end\n",setuser=true,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881293039,size=790},["components.lua"]={type="file",created=1740881291974,worldPermissions={execute=true,read=true,write=false},data="local a=require\"system.filesystem\"local b=require\"system.framebuffer\"local c=require\"system.ipc\"local d=require\"system.keys\"local e=require\"system.log\"local f=require\"system.network\"local g=require\"system.process\"local h=require\"system.terminal\"local i=require\"system.util\"local j=require\"dpkg.query\"if g.getuser()~=\"root\"then error(\"This program must be run as root.\")end;local k=\"https://phoenix.madefor.cc/packages/\"local l=h.openterm()local m=h.colors;l.setPaletteColor(m.orange,0xD06018)l.setPaletteColor(m.white,0xD8D8D8)local n,o=l.getSize()local p;local q={}local r;local s=true;local t={}local function u(v,w)local x={}local y=\"\"for z in v:gmatch\"%w*%W*\"do while z:find\"\\n\"do local A;A,z=z:match\"([^\\n]*)\\n(.*)\"if#y+#A<w then x[#x+1],y=y..A,\"\"else x[#x+1],y=y,A end end;if#y+#z<w then y=y..z else x[#x+1],y=y,z end end;x[#x+1]=y;return x end;local function B(C)l.setCursorPos(3,o)l.setBackgroundColor(m.white)l.setTextColor(m.black)l.clearLine()l.write(C)end;local function D(C)l.setBackgroundColor(m.orange)l.setTextColor(m.white)l.clear()l.setCursorBlink(false)l.setCursorPos(2,2)l.write(\"Phoenix Setup\")l.setCursorPos(1,3)l.write((\"\\x8C\"):rep(15))B(C)p=5;q={}r=nil end;local function E(v)local F=b.window(l,3,p,n-4,o-p)F.setBackgroundColor(m.orange)F.setTextColor(m.white)F.clear()local G=0;for H,I in ipairs(u(v:gsub(\"* \",\"\\7 \"),n-4))do F.setCursorPos(1,H)F.write(I)G=H end;F.reposition(3,p,n-4,G)p=p+G+1 end;local function J(K,L,M,N)K=K or o-p-3;local O=0;for P in pairs(L)do O=O+1 end;l.setBackgroundColor(m.orange)l.setTextColor(m.white)l.setCursorPos(3,p)l.write(\"\\x9C\"..(\"\\x8C\"):rep(n-6))l.setBackgroundColor(m.white)l.setTextColor(m.orange)l.write(\"\\x93\")for Q=1,K do l.setCursorPos(l.getCursorPos()-1,p+Q)l.write(\"\\x95\")end;l.setBackgroundColor(m.orange)l.setTextColor(m.white)for Q=1,K do l.setCursorPos(3,p+Q)l.write(\"\\x95\")end;l.setCursorPos(3,p+K+1)l.write(\"\\x8D\"..(\"\\x8C\"):rep(n-6)..\"\\x8E\")local H,w=p+1,n-7;local R=b.window(l,4,H,w,K)R.setBackgroundColor(m.orange)R.clear()local S=b.framebuffer(R,1,1,w,O)S.setBackgroundColor(m.orange)S.setTextColor(m.white)S.clear()local x={}local T,U=1,1;for V,W in pairs(L)do S.setCursorPos(1,T)S.write((W and(W==\"R\"and\"[-] \"or\"[\\xD7] \")or\"[ ] \")..V)x[T]={V,not not W}T=T+1 end;l.setCursorPos(w+4,H+K-1)l.blit(1<O-K+1 and\"\\31\"or\" \",\"0\",\"1\")S.setCursorPos(2,U)S.setCursorBlink(true)r=S.restoreCursor;q[#q+1]=coroutine.create(function()local X=1;while true do local Y,Z=coroutine.yield()local _;if Y==\"key\"then if Z.keycode==d.up then _=-1 elseif Z.keycode==d.down then _=1 elseif Z.keycode==d.space and L[x[U][1]]~=\"R\"then x[U][2]=not x[U][2]S.setCursorPos(2,U)S.write(x[U][2]and\"\\xD7\"or\" \")if N and N(x[U][1],x[U][2])then for Q,W in ipairs(x)do local a0=L[W[1]]==\"R\"and\"R\"or W[2]S.setCursorPos(2,Q)S.write(a0 and(a0==\"R\"and\"-\"or\"\\xD7\")or\" \")end end;S.setCursorPos(2,U)elseif Z.keycode==d.enter then local a1={}for P,W in ipairs(x)do a1[W[1]]=L[W[1]]==\"R\"or W[2]end;M(a1)end elseif Y==\"mouse_scroll\"and Z.x>=4 and Z.x<4+w and Z.y>=H and Z.y<H+K then _=Z.direction end;if _ and(U+_>=1 and U+_<=O)then U=U+_;if U-X<0 or U-X>=K then X=X+_;S.reposition(1,2-X)end;S.setCursorPos(2,U)end;l.setCursorPos(w+4,H)l.blit(X>1 and\"\\30\"or\" \",\"0\",\"1\")l.setCursorPos(w+4,H+K-1)l.blit(X<O-K+1 and\"\\31\"or\" \",\"0\",\"1\")S.restoreCursor()end end)p=p+K+2 end;local function a2()l.setBackgroundColor(m.orange)l.setTextColor(m.white)l.setCursorPos(3,p)l.write(\"\\x9C\"..(\"\\x8C\"):rep(n-6))l.setBackgroundColor(m.white)l.setTextColor(m.orange)l.write(\"\\x93\")l.setCursorPos(l.getCursorPos()-1,p+1)l.write(\"\\x95\")l.setBackgroundColor(m.orange)l.setTextColor(m.white)l.setCursorPos(3,p+1)l.write(\"\\x95\")l.setCursorPos(3,p+2)l.write(\"\\x8D\"..(\"\\x8C\"):rep(n-6)..\"\\x8E\")local F=b.window(l,4,p+1,n-6,1)F.setBackgroundColor(m.orange)F.setTextColor(m.white)F.clear()p=p+4;return function(a3)F.setCursorPos(1,1)F.setBackgroundColor(m.orange)F.clearLine()F.setBackgroundColor(m.white)F.write((\" \"):rep(a3*(n-6)))end end;local function a4(a5)q[#q+1]=coroutine.create(function()while true do local Y,Z=coroutine.yield()if Y==\"key\"and a5[Z.keycode]then a5[Z.keycode](Z.keycode)end end end)end;local function a6()s=true;for P,W in ipairs(q)do coroutine.resume(W)end;while s do if r then r()end;local Y,Z=coroutine.yield()for P,W in ipairs(q)do local a7=table.pack(coroutine.resume(W,Y,Z))while a7[1]and a7[2]~=nil do a7=table.pack(coroutine.resume(W,coroutine.yield(table.unpack(a7,1,a7.n))))end end end end;local a8={}function a8.message(a9,aa,ab)D(\"ENTER=Back\")E(aa)a4{[d.enter]=function()s=false end}a6()return ab(a9)end;function a8.loading(a9)D(\"Downloading package list...\")E(\"Please wait while Setup initializes.\")local ac,ad=f.get(k..\"Packages\")if not ac or ac:status()==\"error\"or ac:responseCode()~=200 then return a8.message(a9,\"An error occurred while initializing Setup: Could not download package list: \"..(ad or select(2,ac:status())or ac:responseCode())..\"\\n\\nSetup cannot continue. Press ENTER to exit.\",function()end)end;local ae;for I in function()return ac:read(\"*l\")end do local V,W=I:match(\"^([%w%-]+):%s*(.+)$\")if V then if V==\"Package\"then ae=W;t[ae]={}elseif V==\"Size\"then t[ae].pkgsize=tonumber(W)elseif V==\"Installed-Size\"then t[ae].filesize=tonumber(W)*1024 elseif V==\"Priority\"then t[ae].priority=W elseif V==\"Essential\"then t[ae].essential=true elseif V==\"Depends\"then local af={}for A in W:gmatch\"[^,]+\"do af[A:match\"[%w%-]+\"]=true end;t[ae].depends=af end end end;ac:close()B(\"Checking installed packages...\")a9.installed=j.readDatabase()return a8.components(a9)end;function a8.components(a9)local ab;D(\"ENTER=Continue  SPACE=Toggle  TAB=Quit\")E(\"Select the components to install from the list below.\\n[-] = required, [\\xD7] = selected\")local L={}for V,W in pairs(t)do if V~=\"stage2-tarball\"then if V==\"phoenix\"or V==\"phoenix-luz\"then if a9.installed[\"phoenix-luz\"]and V==\"phoenix-luz\"or a9.installed[\"phoenix\"]and V==\"phoenix\"then L[V]=\"R\"end elseif W.essential or W.priority==\"required\"or a9.spanfs_disks and(V==\"initrd-utils\"or V==\"spanfs\")then L[V]=\"R\"elseif W.priority==\"optional\"then L[V]=false else L[V]=true end end end;local function ag()local function ah(ae)if L[ae]and t[ae].depends then for V in pairs(t[ae].depends)do L[V]=\"R\"ah(V)end end end;for V,W in pairs(L)do L[V]=(t[V].essential or t[V].priority==\"required\")and\"R\"or not not W end;for V in pairs(L)do ah(V)end end;ag()J(nil,L,function(ai)a9.components={}local a1,aj={},{}for V,W in pairs(ai)do if W then local af={}for ak,w in pairs(t[V].depends or{})do af[ak]=w end;aj[V]=af;if not _G.next(af)then a1[#a1+1]=V end end end;while#a1>0 do local al=table.remove(a1)a9.components[#a9.components+1]=al;for V,W in pairs(aj)do if W[al]then W[al]=nil;if not _G.next(W)then a1[#a1+1]=V end end end end;ab,s=true,false end,function(V,W)L[V]=W;ag()return true end)a4{[d.tab]=function()s=false end}a6()if ab then return a8.confirm(a9)else return false end end;function a8.confirm(a9)D(\"Calculating packages to install...\")a9.install,a9.remove={},{}local ai={}local am={}for P,W in ipairs(a9.components)do am[W]=true;if not a9.installed[W]or a9.installed[W].Status:match\"^deinstall \"then a9.install[#a9.install+1]=W end end;for V,W in pairs(t)do if not am[V]and(a9.installed[V]and not a9.installed[V].Status:match\"^deinstall \")then ai[V]=true end end;local a1,aj={},{}for V in pairs(ai)do local af={}for ak,w in pairs(t[V].depends or{})do af[ak]=w end;aj[V]=af;if not _G.next(af)then a1[#a1+1]=V end end;while#a1>0 do local al=table.remove(a1)a9.remove[#a9.remove+1]=al;for V,W in pairs(aj)do if W[al]then W[al]=nil;if not _G.next(W)then a1[#a1+1]=V end end end end;local ab;B(\"ENTER=Install  TAB=Back  Q=Quit\")E(\"The following changes will be made:\\nTo install: \"..table.concat(a9.install,\", \")..\"\\nTo remove: \"..table.concat(a9.remove,\", \")..\"\\n\\nPress ENTER to install.\")a4{[d.enter]=function()ab,s=true,false end,[d.tab]=function()ab,s=false,false end,[d.q]=function()s=false end}a6()if ab then return a8.download(a9)elseif ab==false then return a8.components(a9)else return false end end;function a8.download(a9)pcall(e.create,\"install\",false,\"/var/log/install.log\")if#a9.install==0 then return a8.remove(a9)end;D(\"\")E\"Downloading components...\"local a3=a2()local an=0;for P in pairs(a9.install)do an=an+1 end;local al=0;a.mkdir(\"/tmp/pkg\")a.mount(\"tmpfs\",\"tmpfs\",\"/tmp/pkg\",{})for P,V in ipairs(a9.install)do B(\"Downloading: \"..V)local ac,ad=f.get{url=k..V..\".deb\",encoding=\"binary\"}if not ac then return a8.message(a9,\"An error occurred while downloading the \"..V..\" component. Installation cannot continue.\\n\\nPress ENTER to exit.\\n\\nError message: \"..ad,function()return false end)end;local ao,ad=io.open(\"/tmp/pkg/\"..V..\".deb\",\"wb\")if not ao then ac:close()return a8.message(a9,\"An error occurred while saving the \"..V..\" component. Installation cannot continue.\\n\\nPress ENTER to exit.\\n\\nError message: \"..ad,function()return false end)end;ao:write(ac:read(\"*a\"))ac:close()ao:close()al=al+1;a3(al/an)end;return a8.install(a9)end;function a8.install(a9)D(\"\")E\"Please wait while Phoenix installs the requested components.\"l.setCursorPos(3,p)l.write(\"\\x9C\"..(\"\\x8C\"):rep(n-6))l.setBackgroundColor(m.white)l.setTextColor(m.orange)l.write(\"\\x93\")for Q=p+1,o-2 do l.setCursorPos(l.getCursorPos()-1,Q)l.write(\"\\x95\")end;l.setBackgroundColor(m.orange)l.setTextColor(m.white)for Q=p+1,o-2 do l.setCursorPos(3,Q)l.write(\"\\x95\")end;l.setCursorPos(3,o-1)l.write(\"\\x8D\"..(\"\\x8C\"):rep(n-6)..\"\\x8E\")local ap=h.mktty(n-6,o-9)local aq=g.fork(function()h.stdout(ap)while true do local Y,Z=coroutine.yield()if Y==\"remote_event\"then if Z.type==\"write\"then e.install.log(Z.data.data)io.stdout:write(Z.data.data)elseif Z.type==\"exit\"then break end end end end,\"tty helper\")g.newthread(function()while s do for H=1,ap.size.height do l.setCursorPos(4,H+7)l.blit(table.unpack(ap[H]))end;i.sleep(0.2)end end)local function ar(...)local as=g.fork(function(...)h.stdout({write=function(at)c.sendEvent(aq,\"write\",{data=at})end})g.exec(...)end,\"\",...)while true do local Y,Z=coroutine.yield()if Y==\"process_complete\"and Z.id==as then if Z.error or Z.traceback then s=false;c.sendEvent(aq,\"exit\",{})D(\"ENTER=Exit\")E[[\nAn error occurred while installing the specified components.\n\nPress ENTER to exit.]]B(\"ENTER=Reboot\")repeat local Y,Z=coroutine.yield()until Y==\"key\"and Z.keycode==10;return false end;break end end end;for P,V in ipairs(a9.install)do B(\"Installing: \"..V)e.install.log(\"Installing:\",V)ar(\"/usr/bin/dpkg.lua\",\"-i\",\"/tmp/pkg/\"..V..\".deb\")end;pcall(c.kill,aq,c.signal.SIGTERM)a.unmount(\"/tmp/pkg\")a.remove(\"/tmp/pkg\")return a8.remove(a9)end;function a8.remove(a9)if#a9.remove==0 then return a8.complete(a9)end;D(\"\")E\"Please wait while Phoenix removes the requested components.\"l.setCursorPos(3,p)l.write(\"\\x9C\"..(\"\\x8C\"):rep(n-6))l.setBackgroundColor(m.white)l.setTextColor(m.orange)l.write(\"\\x93\")for Q=p+1,o-2 do l.setCursorPos(l.getCursorPos()-1,Q)l.write(\"\\x95\")end;l.setBackgroundColor(m.orange)l.setTextColor(m.white)for Q=p+1,o-2 do l.setCursorPos(3,Q)l.write(\"\\x95\")end;l.setCursorPos(3,o-1)l.write(\"\\x8D\"..(\"\\x8C\"):rep(n-6)..\"\\x8E\")local ap=h.mktty(n-6,o-9)local aq=g.fork(function()h.stdout(ap)while true do local Y,Z=coroutine.yield()if Y==\"remote_event\"then if Z.type==\"write\"then e.install.log(Z.data.data)io.stdout:write(Z.data.data)elseif Z.type==\"exit\"then break end end end end,\"tty helper\")g.newthread(function()while s do for H=1,ap.size.height do l.setCursorPos(4,H+7)l.blit(table.unpack(ap[H]))end;i.sleep(0.2)end end)local function ar(...)local as=g.fork(function(...)h.stdout({write=function(at)c.sendEvent(aq,\"write\",{data=at})end})g.exec(...)end,\"\",...)while true do local Y,Z=coroutine.yield()if Y==\"process_complete\"and Z.id==as then if Z.error or Z.traceback then s=false;c.sendEvent(aq,\"exit\",{})D(\"ENTER=Exit\")E[[\nAn error occurred while removing the specified components.\n\nPress ENTER to exit.]]B(\"ENTER=Reboot\")repeat local Y,Z=coroutine.yield()until Y==\"key\"and Z.keycode==10;return false end;break end end end;for Q=#a9.remove,1,-1 do local V=a9.remove[Q]B(\"Removing: \"..V)e.install.log(\"Removing:\",V)ar(\"/usr/bin/dpkg.lua\",\"-r\",V)end;pcall(c.kill,aq,c.signal.SIGTERM)return a8.complete(a9)end;function a8.complete(a9)local ab;D(\"ENTER=Exit  R=Reboot\")E[[\nThe selected components have successfully been installed or removed. It is recommended to reboot your system to ensure all components were installed properly.\n\n* Press R to reboot your system now.\n* Press ENTER to exit without rebooting.]]a4{[d.enter]=function()ab,s=false,false end,[d.r]=function()ab,s=true,false end}a6()e.remove(\"install\")if ab then local as=c.lookup(\"ServiceManager\")if as then c.sendEvent(as,\"startmgr.request\",{func=\"reboot\"})else i.syscall.devcall(\"/\",\"reboot\")end else return true end end;return a8.loading{}\n",setuser=false,permissions={root={execute=true,read=true,write=true}},owner="root",modified=1740881291949,size=12722}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294560,size=0}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881291738,size=0},etc={type="directory",created=1740881294437,worldPermissions={write=false,read=true,execute=true},contents={["dhcpmgr.conf"]={type="file",created=1740881291740,worldPermissions={execute=false,read=true,write=false},data="## dhcpmgr configuration file\n#:schema https://phoenix.madefor.cc/schema/dhcpmgr.schema.json\n\n## The network interface to host on. Leaving it undefined will host on a random\n## interface - this is not recommended for most uses, so make sure to set it.\n#interface = \"/back\"\n\n## The first address to assign to clients.\nfirstaddr = \"10.0.1.2\"\n\n## The last address to assign to clients.\nlastaddr = \"10.0.1.254\"\n\n## The network mask for assigned addresses. If not set, the mask will be\n## inferred from the first and last addresses.\n#netmask = \"255.255.255.0\"\n\n## The gateway address to report to clients. Leave unset to not report a gateway.\ngateway = \"10.0.1.1\"\n\n## The DNS server addresses to report to clients. Leave unset to not report DNS.\ndns = [\"10.0.1.1\"]\n\n## The length of a DHCP lease, in seconds. Unset means the lease never expires.\nleasetime = 86400\n\n## Whether to allow clients to request static addresses.\nallowrequests = true\n\n## Whether to store address assignments for clients permanently.\n## If this is enabled, the server will store the first address assigned to a\n## client, and will prefer to use that address if available.\nstoreassignments = false\n\n## Whether to force re-assigning addresses if a client requests an IP before its\n## lease expires.\nforcereassign = false\n\n## Static address assignments. This maps computer IDs to IP addresses.\n[static]\n#    25 = \"10.0.1.15\"\n#    28 = \"10.0.1.132\"\n\n## Other options to provide to clients.\n[options]\n#    domain = \"subnet.cc\"\n#    bootServers = [\"10.0.1.1\"]\n#    bootFile = \"/boot.lua\"\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291737,size=1552},fstab={type="file",created=1740881294723,worldPermissions={execute=false,read=true,write=false},data="tmpfs /tmp tmpfs defaults,auto 0 0\ntmpfs /var/log tmpfs defaults,auto 0 0\n/rom /rom craftos defaults,auto 0 0\n/ /root craftos defaults,auto 0 0\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881294723,size=144},["network.conf"]={type="file",created=1740881292982,worldPermissions={execute=false,read=true,write=false},data="## netmgr network configuration file\n## WORK-IN-PROGRESS - not all features implemented\n#:schema https://phoenix.madefor.cc/schema/netmgr.schema.json\n\n## Defines a set of rules for a specific network interface.\n## `[auto]` will be used for any device that doesn't have its own config.\n## Otherwise, use `[\"<device>\"]` to select a device.\n\n[auto]\n    ## Sets the way to acquire a network address. Valid options:\n    ## none - Do not configure this device\n    ## dhcp - Use DHCP to automatically acquire an address from a server/router\n    ## dhcp-static - Use DHCP with a manual requested address\n    ## static - Use a static address\n    acquire = \"dhcp\"\n\n    ## If using a static IP address, define its parameters here.\n    ## dhcp-static only needs `address`.\n    ## static needs `address`, `netmask` (if not in the address), and `gateway`.\n    # address = \"10.0.1.2/24\"   # sets the netmask in the address\n    # address = \"10.0.1.2\"      # sets the netmask separately\n    # netmask = \"255.255.255.0\"\n    # gateway = \"10.0.1.1\"\n\n    ## DNS servers to use when resolving domain names. Optional if using DHCP.\n    # dns = [\n    #     \"10.0.1.1\",\n    #     \"10.0.1.4\"\n    # ]\n\n## Sets the IP for the loopback device.\n[\"/lo\"]\n    acquire = \"static\"\n    address = \"127.0.0.1/24\"\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292978,size=1275},passwd={type="file",created=1740881294723,worldPermissions={execute=false,read=true,write=false},data="phoenix:x::::/home/phoenix:/bin/cash\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881294723,size=37},skel={type="directory",created=1740881294438,worldPermissions={write=false,read=true,execute=true},contents={[".cashrc"]={type="file",created=1740881294438,worldPermissions={execute=false,read=true,write=false},data="PS1=\"\\033[1;32m\\u@\\h\\033[39m:\\033[34m\\W\\033[0m\\$ \"",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881294383,size=50}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294438,size=0},shadow={type="file",created=1740881294723,worldPermissions={execute=false,read=true,write=false},data="phoenix:$5$atf2kZPrcjWCESpuOohJXA==$OTIxYmM2NTYwMWM5Y2M5MWZmMzhmNzc2OTRkNjQ4YTA1M2EzNzc0NmIxYjU4YzJkZGYyYjhkMWMwYjllNGJjYQ==:19540::::::\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881294723,size=137},motd={type="file",created=1740881294436,worldPermissions={execute=false,read=true,write=false},data="\nWelcome to Phoenix, the next generation operating system for ComputerCraft.\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881294381,size=77},startmgr={type="directory",created=1740881291494,worldPermissions={write=false,read=true,execute=true},contents={system={type="directory",created=1740881294686,worldPermissions={write=false,read=true,execute=true},contents={["automount.service"]={type="file",created=1740881291531,worldPermissions={execute=false,read=true,write=false},data="local process = require \"system.process\"\n\nunit.description = \"Automatically mount filesystems\"\nservice.restart = \"no\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.startbg(\"/bin/mount\", \"-a\")\n    return true\nend",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291494,size=265},["startup.service"]={type="file",created=1740881294011,worldPermissions={execute=false,read=true,write=false},data="unit.description = \"Startup Tasks\"\nunit.requires = {}\n\nfunction start() return true end\nfunction stop() return true end",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881293993,size=119},["dhcpmgr.service"]={type="file",created=1740881291740,worldPermissions={execute=false,read=true,write=false},data="local process = require \"system.process\"\n\nunit.description = \"DHCP Manager\"\nservice.restart = \"always\"\nservice.restartTime = 0\nservice.wants = {\"netmgr\"}\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.startbg(\"/usr/libexec/dhcpmgr\")\n    return true\nend\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291737,size=282},["login.service"]={type="file",created=1740881294439,worldPermissions={execute=false,read=true,write=false},data="local process = require \"system.process\"\n\nunit.description = \"Login Prompt\"\nunit.requires = {\"usermgr\"}\nunit.after = {\"usermgr\"}\nservice.restart = \"always\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.start(\"/usr/bin/login\")\n    return true\nend\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881294384,size=300},["yellowbox.service"]={type="file",created=1740881294686,worldPermissions={execute=false,read=true,write=false},data="local filesystem = require \"system.filesystem\"\nlocal process = require \"system.process\"\nlocal yellowbox = require \"yellowbox\"\n\nunit.description = \"Virtual CraftOS container\"\nservice.restart = \"always\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    \nend\n\nfunction stop()\n\nend\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881294670,size=303},["ftpmgr.service"]={type="file",created=1740881292188,worldPermissions={execute=false,read=true,write=false},data="local process = require \"system.process\"\n\nunit.description = \"FTP server\"\nservice.restart = \"always\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.startbg(\"/usr/libexec/ftpmgr\")\n    return true\nend\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292166,size=252},["startup.service.wants"]={type="directory",created=1740881294456,worldPermissions={write=false,read=true,execute=true},contents={["login.service"]={type="file",created=1740881294439,worldPermissions={execute=false,read=true,write=false},data="local process = require \"system.process\"\n\nunit.description = \"Login Prompt\"\nunit.requires = {\"usermgr\"}\nunit.after = {\"usermgr\"}\nservice.restart = \"always\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.start(\"/usr/bin/login\")\n    return true\nend\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881294384,size=300},["diskmgr.service"]={type="file",created=1740881291829,worldPermissions={execute=false,read=true,write=false},data="local process = require \"system.process\"\n\nunit.description = \"Disk Manager\"\nservice.restart = \"always\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.startbg(\"/usr/libexec/diskmgr\")\n    return true\nend\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291826,size=255},["automount.service"]={type="file",created=1740881291531,worldPermissions={execute=false,read=true,write=false},data="local process = require \"system.process\"\n\nunit.description = \"Automatically mount filesystems\"\nservice.restart = \"no\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.startbg(\"/bin/mount\", \"-a\")\n    return true\nend",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291494,size=265}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294456,size=0},["usermgr.service"]={type="file",created=1740881294440,worldPermissions={execute=false,read=true,write=false},data="local process = require \"system.process\"\n\nunit.description = \"User Manager\"\nservice.restart = \"always\"\nservice.restartTime = 0\n\nfunction start()\n    service.pid[1] = process.startbg(\"/usr/libexec/usermgr\")\n    return true\nend\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881294385,size=226},["diskmgr.service"]={type="file",created=1740881291829,worldPermissions={execute=false,read=true,write=false},data="local process = require \"system.process\"\n\nunit.description = \"Disk Manager\"\nservice.restart = \"always\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.startbg(\"/usr/libexec/diskmgr\")\n    return true\nend\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291826,size=255},["netmgr.service"]={type="file",created=1740881292982,worldPermissions={execute=false,read=true,write=false},data="local process = require \"system.process\"\n\nunit.description = \"Networking Manager\"\nservice.restart = \"always\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.startbg(\"/usr/libexec/netmgr\")\n    return true\nend\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292979,size=260}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294686,size=0}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881291494,size=0},["ftpmgr.conf"]={type="file",created=1740881292187,worldPermissions={execute=false,read=true,write=false},data="## ftpmgr configuration file\n#:schema https://phoenix.madefor.cc/schema/ftpmgr.schema.json\n\n## The IP address to serve on. \"0.0.0.0\" indicates any IP/interface.\nip = \"0.0.0.0\"\n\n## The port to serve the command stream on. FTP standard is 21.\nport = 21\n\n## The range of ports to reserve for passive connections.\npassivePortRange = [65000, 65535]\n\n## Uncomment this to allow any user registered on the system to log in.\n#allUsers = true\n\n## The users allowed to connect. A special \"anonymous\" user is used for\n## connections without a login - if not present, clients will be required to log\n## in before accessing files.\n\n## The default root login, which authenticates via usermgr, and allows access to\n## the entire filesystem with root permissions.\n\n[users.root]\n\n## An example of an anonymous login, which runs as a virtual user and does not\n## require a password.\n\n#[users.anonymous]\n#    systemUser = \"ftp-user\"   # The Phoenix username to run the server as\n#    allowWrite = false        # Whether to allow the user to write files\n#    useSystemLogin = false    # Whether to use usermgr to authenticate logins\n#    root = \"/var/ftp\"         # The filesystem root visible to the user\n\n## An example of a virtual user with a password. This user runs as root, but\n## does not have write permissions.\n\n#[users.virtual]\n#    password = \"virtual-user-password!\"    # The password for the user (plaintext!)\n#    allowWrite = false                     # Whether to allow the user to write files\n#    root = \"/\"                             # The filesystem root visible to the user\n\n## An example of a virtual user with a more securely stored password. This user\n## runs as a user named \"virtual\", but does not check usermgr, and thus does not\n## need to be a registered user on the system.\n\n#[users.virtual-secure]\n#    systemUser = \"virtual\"     # The Phoenix username to run the server as\n#    # The hash of the password in SHA-256\n#    passwordHash = \"05bb25e9186d1014c5eb723edb0bf17987e6fe1b9eaeae5c88f217d1b3024b23\"\n#    passwordSalt = \"12345678\"  # The salt applied to the end of the password\n#    allowWrite = true          # Whether to allow the user to write files\n#    root = \"/\"                 # The filesystem root visible to the user\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292166,size=2243},initrd={type="directory",created=1740881292394,worldPermissions={write=false,read=true,execute=true},contents={scripts={type="directory",created=1740881292049,worldPermissions={write=false,read=true,execute=true},contents={["encryptfs.lua"]={type="file",created=1740881292049,worldPermissions={execute=false,read=true,write=false},data="io.write(\"Enter encryption password: \")coroutine.yield(\"syscall\",\"termctl\",{echo=false})options.encryptfs_password=io.read()io.write(\"\\n\")coroutine.yield(\"syscall\",\"termctl\",{echo=true})\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292046,size=187}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881292049,size=0},["initrd.conf"]={type="file",created=1740881292394,worldPermissions={execute=false,read=true,write=false},data="# initrd configuration file\n\n# Uncomment this line to add a rescue shell and utilites to the initrd.\n# rescue_shell = true\n\n# A list of kernel modules to include in the initrd.\n# Example:\n# modules = {\"spanfs\", \"gfxterm\"}\nmodules = {}\n\n# A list of files to copy to the initrd.\n# These should be absolute paths to files on the main filesystem, with an\n# optional \"=<path>\" to move the file to a different location.\n# Example:\n# files = {\"/bin/nano.lua\", \"/lib/libsystem.a\", \"/etc/initrd/myhook.lua=/myhook.lua\"}\nfiles = {}\n\n# A list of files to execute in the init program before mounting the root filesystem.\n# These are executed using dofile, and thus must be full Lua file names, with\n# extensions if needed.\n# Example:\n# hook_preflight = {\"/myhook.lua\"}\nhook_preflight = {}\n\n# A list of files to execute in the init program after root is mounted but before\n# the real init is executed. The initrd is no longer mounted at this point.\n# These are executed using dofile, and thus must be full Lua file names, with\n# extensions if needed.\n# Example:\n# hook_postflight = {\"/bin/myhook.lua\"}\nhook_postflight = {}\n\n# Where to save the initrd file to.\noutput_path = \"/boot/initrd.img\"",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292382,size=1179},["hooks.d"]={type="directory",created=1740881292394,worldPermissions={write=false,read=true,execute=true},contents={["00-modules.lua"]={type="file",created=1740881292392,worldPermissions={execute=false,read=true,write=false},data="if not config.modules then return end;local a=require\"system.filesystem\"a.mkdir(a.combine(rootDirectory,\"lib/modules\"))for b,c in ipairs(config.modules)do local d=a.combine(rootDirectory,\"lib/modules\",c..\".lua\")a.copy(\"/lib/modules/\"..c..\".lua\",d)a.chmod(d,\"root\",\"rwx\")a.chmod(d,nil,\"r-x\")a.chown(d,\"root\")end\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292380,size=311},["05-shell.lua"]={type="file",created=1740881292393,worldPermissions={execute=false,read=true,write=false},data="if not config.rescue_shell then return end;local a=require\"system.filesystem\"a.copy(\"/bin/cash.lua\",a.combine(rootDirectory,\"bin/cash.lua\"),true)a.copy(\"/bin/chmod.lua\",a.combine(rootDirectory,\"bin/chmod.lua\"),true)a.copy(\"/bin/chown.lua\",a.combine(rootDirectory,\"bin/chown.lua\"),true)a.copy(\"/bin/chroot\",a.combine(rootDirectory,\"bin/chroot.lua\"),true)a.copy(\"/bin/cp.lua\",a.combine(rootDirectory,\"bin/cp.lua\"),true)a.copy(\"/bin/kill.lua\",a.combine(rootDirectory,\"bin/kill.lua\"),true)a.copy(\"/bin/less.lua\",a.combine(rootDirectory,\"bin/less.lua\"),true)a.copy(\"/bin/link.lua\",a.combine(rootDirectory,\"bin/link.lua\"),true)a.copy(\"/bin/ls.lua\",a.combine(rootDirectory,\"bin/ls.lua\"),true)a.copy(\"/bin/lua.lua\",a.combine(rootDirectory,\"bin/lua.lua\"),true)a.copy(\"/bin/mkdir.lua\",a.combine(rootDirectory,\"bin/mkdir.lua\"),true)a.copy(\"/bin/mount.lua\",a.combine(rootDirectory,\"bin/mount.lua\"),true)a.copy(\"/bin/nano.lua\",a.combine(rootDirectory,\"bin/nano.lua\"),true)a.copy(\"/bin/ps.lua\",a.combine(rootDirectory,\"bin/ps.lua\"),true)a.copy(\"/bin/rm.lua\",a.combine(rootDirectory,\"bin/rm.lua\"),true)a.copy(\"/bin/sh.lua\",a.combine(rootDirectory,\"bin/sh.lua\"),true)a.copy(\"/bin/unmount.lua\",a.combine(rootDirectory,\"bin/unmount.lua\"),true)a.copy(\"/lib/libsystem.a\",a.combine(rootDirectory,\"lib/libsystem.a\"),true)\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292381,size=1300},["01-files.lua"]={type="file",created=1740881292393,worldPermissions={execute=false,read=true,write=false},data="if not config.modules then return end;local a=require\"system.filesystem\"for b,c in ipairs(config.files)do local d,e=c:match(\"^([^=]+)=(.+)$\")if not e then d,e=c,c end;e=a.combine(rootDirectory,e)a.copy(d,e,true)end\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292381,size=215},["10-init.lua"]={type="file",created=1740881292394,worldPermissions={execute=false,read=true,write=false},data="local a=[==[\nprint(\"initrd: init running\")\noptions = {}\n]==]if config.hook_preflight then for b,c in ipairs(config.hook_preflight)do a=a..'print(\"initrd: running hook '..c..'\")\\ndofile(\"'..c..'\")\\n'end end;a=a..[==[\nprint(\"initrd: mounting root filesystem\")\nlocal _, args = coroutine.yield(\"syscall\", \"kernargs\")\nif args.rootflags then\n    for m in args.rootflags:gmatch \"[^,]+\" do\n        local k, v = m:match(\"^([^=]+)=(.*)$\")\n        if k and v then\n            if v == \"true\" then options[k] = true\n            elseif v == \"false\" then options[k] = false\n            else options[k] = tonumber(v) or v end\n        else options[m] = true end\n    end\nend\ncoroutine.yield(\"syscall\", \"unmount\", \"/\")\nlocal ok, err = coroutine.yield(\"syscall\", \"mount\", args.rootfstype or \"craftos\", args.root, \"/\", options)\nif not ok then\n    coroutine.yield(\"syscall\", \"syslog\", {module = \"initrd\", level = 6}, \"initrd: could not mount root device: \" .. err .. \"\\n\")\n    while true do coroutine.yield() end\n    return false\nend\n-- TODO: reopen log file\n]==]if config.hook_postflight then for b,c in ipairs(config.hook_postflight)do a=a..'print(\"initrd: running hook '..c..'\")\\ndofile(\"'..c..'\")\\n'end end;a=a..[==[\nprint(\"initrd: starting real init\")\nif args.init then coroutine.yield(\"syscall\", \"exec\", args.init) end\nprint(\"Could not find provided init, trying default locations\")\ncoroutine.yield(\"syscall\", \"exec\", \"/sbin/init\")\ncoroutine.yield(\"syscall\", \"exec\", \"/etc/init\")\ncoroutine.yield(\"syscall\", \"exec\", \"/bin/init\")\ncoroutine.yield(\"syscall\", \"exec\", \"/bin/sh\")\nio.stderr:write(\"initrd: no working init found\")\nreturn false\n]==]local d=assert(io.open(rootDirectory..\"/init.lua\",\"w\"))d:write(a)d:close()\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292382,size=1699}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881292394,size=0},["initrd.conf.template"]={type="directory",created=1740881292049,worldPermissions={write=false,read=true,execute=true},contents={["encryptfs.conf"]={type="file",created=1740881292049,worldPermissions={execute=false,read=true,write=false},data="## Copy this file to /etc/initrd/initrd.conf.d to use encryptfs as a root filesystem.\n\nmodules[#modules+1] = \"encryptfs\"\n\nfiles[#files+1] = \"/etc/initrd/scripts/encryptfs.lua=/encryptfs.lua\"\nfiles[#files+1] = \"/usr/lib/libccryptolib.a\"\nfiles[#files+1] = \"/lib/libsystem.a\"\n\nhook_preflight[#hook_preflight+1] = \"/encryptfs.lua\"\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292044,size=327},["compressfs.conf"]={type="file",created=1740881291644,worldPermissions={execute=false,read=true,write=false},data="## Copy this file to /etc/initrd/initrd.conf.d to use compressfs as a root filesystem.\n\nmodules[#modules+1] = \"compressfs\"\n\nfiles[#files+1] = \"/usr/lib/libdeflate.lua\"\nfiles[#files+1] = \"/lib/libsystem.a\"\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291641,size=205}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881292049,size=0}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881292394,size=0},apt={type="directory",created=1740881291210,worldPermissions={write=false,read=true,execute=true},contents={["sources.list"]={type="file",created=1740881291210,worldPermissions={execute=false,read=true,write=false},data="deb https://phoenix.madefor.cc/packages/ latest main\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291196,size=53},["trusted.gpg.d"]={type="directory",created=1740881291211,worldPermissions={write=false,read=true,execute=true},contents={["phoenix.gpg"]={type="file",created=1740881291211,worldPermissions={execute=false,read=true,write=false},data="\1523\004f\178\254i\022\009+\006\001\004\001\218G\015\001\001\007@\1563[E4\188\183\236D\245B\157mb\030\128\241\233k\024:\001\178\212\190\136\150\014\214{-\230\180;Phoenix APT Signing <jackmacwindowslinux+phoenix@gmail.com>\136\153\004\019\022\n\000A\022!\004\n\003\211 k S\r\129\028\141\253\165Y\213\249\001Nr\132\005\002f\178\254i\002\027\003\005\009\005\1646\023\005\011\009\008\007\002\002\"\002\006\021\n\009\008\011\002\004\022\002\003\001\002\030\007\002\023\128\000\n\009\016\165Y\213\249\001Nr\132\031\245\000\254*\215P\142\154?D\165\"\024\215V$=C\222\172\1270\008\216\009sc\207$\180\241\178\224\134\n\000\255_\1638~\248\002Z\022mC\027\254W\242j\173\253\139\184\163\018\190\028\175\151G\029bw\031\231\002\137\001\179\004\016\001\008\000\029\022!\004X_\136&](?\163\129@(]\190\145\144\247$5\164%\005\002f\178\254\170\000\n\009\016\190\145\144\247$5\164%\238\166\011\2542\019\238\192,\180h>l\141%\254\2207\254\255yK\002\145\000\241_\206V>\238\213\028\230F\022X{|\133\145\251/\016{\178J\180\147\189\000i\0176_\148\171k\n\213\207m\206'\253D\225\249\225\201K\164\222bF$\163\n\210:\134\152\235\r\169\"Q\140\008\020\003\187\174\128)\022\212n\169\158m\009)\161Y\153|\018\008\230\187\224d\023w\144No]S\175wE\171R)\254\144\000:\150\248Us\018Z\181#$\200\178\241\141\017,\173\172\191\176\002T\255\167\181\244\237\142\210\225<\218b\197\146\197\247\157\026:\205u\241\027\233\186\167j!\140\165p\2214\014]\217\143q\198\145\181S\245\144~[\185\177\233\221\148Fq\127@PQ\020\212f\014\174G\250\254\207\147\213#V\190C\"!\204\197d2\018\210!\148j\154\015\243\001\0287\235\230\132-\221\000\182:\172n\142\008P~\210\187u\159V)\150T\012G`\214ti\196\022%6C\196\169\149\134x\208O\1994k\252\184YB{]\027\235\168\\092/\171\246\n\135_39r\006\197\006\223/Mzu\171\221\210\222\142uX\197\021\188\031U\148W3\170\215x\207A\\092\2221\134\131\210\023\182>c\137\183\182\133\254e\197\024_\222^7Z3\026I9\140T\021b\234k\015\228\192n+;+\142X*\2263\246'\191SL\\}`\178\158\207\234\1848\004f\178\254i\018\n+\006\001\004\001\151U\001\005\001\001\007@\213\\092\141\016Uc\136\1342\1402\001\006\226\170\178\020j\236\215\228\206\006\238\131\225\148\255*\184)\003\001\008\007\136~\004\024\022\n\000&\022!\004\n\003\211 k S\r\129\028\141\253\165Y\213\249\001Nr\132\005\002f\178\254i\002\027\012\005\009\005\1646\023\000\n\009\016\165Y\213\249\001Nr\132(\168\001\000\130\253\024^8$I\1901\\092\031\154@R\255\026\030\146\004\127\210^\235\207\154\210\002m\227\239\150\001\000\150\130Y\236\\092\157\149\252\129\140\247\150\228\014P\005\239r^\157\170a\180P\019\201\0197\162\025\014",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291196,size=893}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881291211,size=0}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881291210,size=0}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294437,size=0},lib={type="directory",setuser=false,created=1740881294723,worldPermissions={write=false,read=true,execute=true},contents={["yellowbox.lua"]={type="file",created=1740881294688,worldPermissions={execute=false,read=true,write=false},data="\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881294671,size=1},["libcc.a"]={type="file",created=1740881292594,worldPermissions={execute=false,read=true,write=false},data="!<arch>\naudio.dfpwm.lua/0           0     0     644     1285      `\nlocal a=require\"expect\".expect;local b,c,d,e,f=string.char,string.byte,math.floor,bit32.band,bit32.arshift;local g=10;local h=2^g;local i=2^(g-1)local j=2^(g-8+1)local function k()local l,m,n=0,0,false;return function(o)local p=o and 127 or-128;local q=l+d((m*(p-l)+i)/h)if q==l and q~=p then q=q+(o and 1 or-1)end;local r=o==n and h-1 or 0;local s=m;if s~=r then s=s+(o==n and 1 or-1)end;if s<j then s=j end;l,m,n=q,s,o;return l end end;local function t()local u=k()local v=0;return function(w)a(1,w,\"table\")local x,y={},0;for z=1,#w,8 do local A=0;for B=0,7 do local C=d(w[z+B]or 0)if C>127 or C<-128 then error((\"Amplitude at position %d was %d, but should be between -128 and 127\"):format(z+B,C),2)end;local o=C>v or C==v and C==127;A=d(A/2)+(o and 128 or 0)v=u(o)end;y=y+1;x[y]=b(A)end;return table.concat(x,\"\",1,y)end end;local function D()local u=k()local E=0;local v,n=0,false;return function(w,x)a(1,w,\"string\")local x,y={},0;for z=1,#w do local F=c(w,z)for G=1,8 do local o=e(F,1)~=0;local l=u(o)local H=l;if o~=n then H=d((l+v+1)/2)end;v,n=l,o;E=E+d(((H-E)*140+0x80)/256)y=y+1;x[y]=E;F=f(F,1)end end;return x end end;local function I(w)a(1,w,\"string\")return D()(w)end;local function J(w)a(1,w,\"table\")return t()(w)end;return{make_encoder=t,encode=J,make_decoder=D,decode=I}\n\nexpect.lua/     0           0     0     644     1273      `\nlocal a={}local b={[\"nil\"]=true,boolean=true,number=true,string=true,table=true,[\"function\"]=true,userdata=true,thread=true}local function c(d,e,...)local f=type(e)local g;if f==\"table\"then local h=getmetatable(e)if h then g=h.__name end end;local i=table.pack(...)for j,k in ipairs(i)do if b[k]then if f==k then return e end elseif g==k then return e end end;local l=debug.getinfo(2,\"n\")if l and l.name and l.name~=\"\"then d=d..\" to '\"..l.name..\"'\"end;local m;if i.n==1 then m=i[1]elseif i.n==2 then m=i[1]..\" or \"..i[2]else m=table.concat(i,\", \",1,i.n-1)..\", or \"..i[i.n]end;error(d..\" (expected \"..m..\", got \"..f..\")\",3)end;function a.expect(n,e,...)return c(\"bad argument #\"..n,e,...)end;function a.field(o,p,...)local q,r=pcall(string.format,\"%q\",p)if not q then r=tostring(p)end;return c(\"bad field \"..r,o[p],...)end;function a.range(s,t,u)a.expect(1,s,\"number\")a.expect(2,t,\"number\",\"nil\")a.expect(3,u,\"number\",\"nil\")if u and t and u<t then error(\"bad argument #3 (min must be less than or equal to max)\",2)end;if s~=s or s<(t or-math.huge)or s>(u or math.huge)then error((\"number outside of range (expected %s to be within %s and %s)\"):format(s,t or-math.huge,u or math.huge),3)end;return s end;return setmetatable(a,{__call=function(j,...)return a.expect(...)end})\n\nimage.nft.lua/  0           0     0     644     943       `\nlocal a=require\"expect\".expect;local function b(c)a(1,c,\"string\")local d={}local e=1;local f=\"0\"local g=\"f\"local h,i=1,#c;while h<=i do local j=c:sub(h,h)if j==\"\\31\"and h<i then h=h+1;f=c:sub(h,h)elseif j==\"\\30\"and h<i then h=h+1;g=c:sub(h,h)elseif j==\"\\n\"then if d[e]==nil then d[e]={text=\"\",foreground=\"\",background=\"\"}end;e=e+1;f,g=\"0\",\"f\"else local k=c:find(\"[\\n\\30\\31]\",h)or#c+1;local l=k-h;local m=d[e]if m==nil then m={foreground=\"\",background=\"\",text=\"\"}d[e]=m end;m.text=m.text..c:sub(h,k-1)m.foreground=m.foreground..f:rep(l)m.background=m.background..g:rep(l)h=k-1 end;h=h+1 end;return d end;local function n(o)a(1,o,\"string\")local p,q=io.open(o,\"r\")if not p then return nil,q end;local d=p:read(\"*a\")p:close()return b(d)end;local function r(c,s,t,u)a(1,c,\"table\")a(2,s,\"number\")a(3,t,\"number\")a(4,u,\"table\")for v,e in ipairs(c)do u.setCursorPos(s,t+v-1)u.blit(e.text,e.foreground,e.background)end end;return{parse=b,load=n,draw=r}\n\npretty.lua/     0           0     0     644     6449      `\nlocal term=term or require\"craftos.term\"local a=require\"expect\"local a,b=a.expect,a.field;local type,getmetatable,setmetatable,colours,c,tostring=type,getmetatable,setmetatable,colours,write,tostring;local d,e=debug.getinfo,debug.getlocal;local function f(g,h)local i=g.n+1;g[i],g.n=h,i end;local j={}local function k(l)return setmetatable(l,j)end;local m=k({tag=\"nil\"})local n=k({tag=\"text\",text=\" \"})local o=k({tag=\"line\",flat=m})local p=k({tag=\"line\",flat=n})local q={[\"\"]=m,[\" \"]=n,[\"\\n\"]=p}local function r(s,t)return q[s]or setmetatable({tag=\"text\",text=s,colour=t},j)end;local function s(s,t)a(1,s,\"string\")a(2,t,\"number\",\"nil\")local u=q[s]if u then return u end;local v=s:find(\"\\n\",1)if not v then return r(s,t)end;local w=setmetatable({tag=\"concat\",n=0},j)if v~=1 then f(w,r(s:sub(1,v-1),t))end;v=v+1;while true do local x=s:find(\"\\n\",v)f(w,p)if not x then if v<=#s then f(w,r(s:sub(v),t))end;return w else if v<=x-1 then f(w,r(s:sub(v,x-1),t))end;v=x+1 end end end;local function y(...)local z=table.pack(...)for A=1,z.n do if type(z[A])==\"string\"then z[A]=s(z[A])end;if getmetatable(z[A])~=j then a(A,z[A],\"document\")end end;if z.n==0 then return m end;if z.n==1 then return z[1]end;z.tag=\"concat\"return setmetatable(z,j)end;j.__concat=y;local function B(C,w)a(1,C,\"number\")if getmetatable(w)~=j then a(2,w,\"document\")end;if C<=0 then error(\"depth must be a positive number\",2)end;return setmetatable({tag=\"nest\",depth=C,w},j)end;local function D(w)if w.flat then return w.flat end;local E=w.tag;if E==\"nil\"or E==\"text\"then return w elseif E==\"concat\"then local g=setmetatable({tag=\"concat\",n=w.n},j)for A=1,w.n do g[A]=D(w[A])end;w.flat,g.flat=g,g;return g elseif E==\"nest\"then return D(w[1])elseif E==\"group\"then return w[1]else error(\"Unknown doc \"..E)end end;local function F(w)if getmetatable(w)~=j then a(1,w,\"document\")end;if w.tag==\"group\"then return w end;local G=D(w)if G==w then return w end;return setmetatable({tag=\"group\",G,w},j)end;local function H(w,I)local E=w.tag;if E==\"nil\"or E==\"line\"then return I elseif E==\"text\"then return I-#w.text elseif E==\"concat\"then for A=1,w.n do I=H(w[A],I)if I<0 then break end end;return I elseif E==\"group\"or E==\"nest\"then return H(E[1])else error(\"Unknown doc \"..E)end end;local function write(w,J)if getmetatable(w)~=j then a(1,w,\"document\")end;a(2,J,\"number\",\"nil\")local term=term;local I,K=term.getSize()local L=(J or 0.6)*I;if L<0 then L=0 end;if L>I then L=I end;local M=term.getTextColour()local N=M;local function O(w,P,Q)local E=w.tag;if E==\"nil\"then return Q elseif E==\"text\"then local R=w.colour or M;if R~=N then term.setTextColour(R)N=R end;c(w.text)return Q+#w.text elseif E==\"line\"then local S,T=term.getCursorPos()if T<K then term.setCursorPos(P+1,T+1)else term.scroll(1)term.setCursorPos(P+1,K)end;return P elseif E==\"concat\"then for A=1,w.n do Q=O(w[A],P,Q)end;return Q elseif E==\"nest\"then return O(w[1],P+w.depth,Q)elseif E==\"group\"then if H(w[1],math.min(I,L+P)-Q)>=0 then return O(w[1],P,Q)else return O(w[2],P,Q)end else error(\"Unknown doc \"..E)end end;local Q=math.max(term.getCursorPos()-1,0)O(w,0,Q)if N~=M then term.setTextColour(M)end end;local function U(w,J)if getmetatable(w)~=j then a(1,w,\"document\")end;a(2,J,\"number\",\"nil\")write(w,J)c(\"\\n\")end;local function V(w,I,J)if getmetatable(w)~=j then a(1,w,\"document\")end;a(2,I,\"number\",\"nil\")a(3,J,\"number\",\"nil\")local L;if I then L=(J or 0.6)*I;if L<0 then L=0 end;if L>I then L=I end end;local g={n=0}local function O(w,P,Q)local E=w.tag;if E==\"nil\"then return Q elseif E==\"text\"then f(g,w.text)return Q+#w.text elseif E==\"line\"then f(g,\"\\n\"..(\" \"):rep(P))return P elseif E==\"concat\"then for A=1,w.n do Q=O(w[A],P,Q)end;return Q elseif E==\"nest\"then return O(w[1],P+w.depth,Q)elseif E==\"group\"then if not I or H(w[1],math.min(I,L+P)-Q)>=0 then return O(w[1],P,Q)else return O(w[2],P,Q)end else error(\"Unknown doc \"..E)end end;O(w,0,0)return table.concat(g,\"\",1,g.n)end;j.__tostring=V;local W={[\"and\"]=true,[\"break\"]=true,[\"do\"]=true,[\"else\"]=true,[\"elseif\"]=true,[\"end\"]=true,[\"false\"]=true,[\"for\"]=true,[\"function\"]=true,[\"if\"]=true,[\"in\"]=true,[\"local\"]=true,[\"nil\"]=true,[\"not\"]=true,[\"or\"]=true,[\"repeat\"]=true,[\"return\"]=true,[\"then\"]=true,[\"true\"]=true,[\"until\"]=true,[\"while\"]=true}local X=s(\",\")local Y=s(\"{}\")local Z,_=s(\"{\"),s(\"}\")local a0,a1=s(\"[\"),s(\"] = \")local function a2(a3,a4)local a5,a6=type(a3),type(a4)if a5==\"string\"then return a6~=\"string\"or a3<a4 elseif a6==\"string\"then return false end;if a5==\"number\"then return a6~=\"number\"or a3<a4 end;return false end;local function a7(a8,a9)local aa=d and d(a8,\"Su\")local ab;if a9.function_source and aa and aa.short_src and aa.linedefined and aa.linedefined>=1 then ab=\"function<\"..aa.short_src..\":\"..aa.linedefined..\">\"else ab=tostring(a8)end;if a9.function_args and aa and aa.what==\"Lua\"and aa.nparams and e then local z={}for A=1,aa.nparams do z[A]=e(a8,A)or\"?\"end;if aa.isvararg then z[#z+1]=\"...\"end;ab=ab..\"(\"..table.concat(z,\", \")..\")\"end;return ab end;local function ac(ad,a9,ae)local af=type(ad)if af==\"string\"then local ag=(\"%q\"):format(ad):gsub(\"\\\\\\n\",\"\\\\n\")return s(ag,colours.red)elseif af==\"number\"then return s(tostring(ad),colours.magenta)elseif af==\"function\"then return s(a7(ad,a9),colours.lightGrey)elseif af~=\"table\"or ae[ad]then return s(tostring(ad),colours.lightGrey)elseif getmetatable(ad)~=nil and getmetatable(ad).__tostring then return s(tostring(ad))elseif next(ad)==nil then return Y else ae[ad]=true;local w=setmetatable({tag=\"concat\",n=1,p},j)local ah,ai,aj=#ad,{},1;for ak in pairs(ad)do if type(ak)~=\"number\"or ak%1~=0 or ak<1 or ak>ah then ai[aj],aj=ak,aj+1 end end;table.sort(ai,a2)for A=1,ah do if A>1 then f(w,X)f(w,p)end;f(w,ac(ad[A],a9,ae))end;for A=1,aj-1 do if A>1 or ah>=1 then f(w,X)f(w,p)end;local ak=ai[A]local al=ad[ak]if type(ak)==\"string\"and not W[ak]and ak:match(\"^[%a_][%a%d_]*$\")then f(w,s(ak..\" = \"))f(w,ac(al,a9,ae))else f(w,a0)f(w,ac(ak,a9,ae))f(w,a1)f(w,ac(al,a9,ae))end end;ae[ad]=nil;return F(y(Z,B(2,y(table.unpack(w,1,w.n))),p,_))end end;local function am(ad,a9)a(2,a9,\"table\",\"nil\")a9=a9 or{}local an={function_source=b(a9,\"function_source\",\"boolean\",\"nil\")or false,function_args=b(a9,\"function_args\",\"boolean\",\"nil\")or false}return ac(ad,an,{})end;local function ao(ad,a9,J)a(2,a9,\"table\",\"nil\")a9=a9 or{}a(3,J,\"number\",\"nil\")return U(am(ad,a9),J)end;return{empty=m,space=n,line=o,space_line=p,text=s,concat=y,nest=B,group=F,write=write,print=U,render=V,pretty=am,pretty_print=ao}\n\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292582,size=10202},["typescript.lua"]={type="file",created=1740881294304,worldPermissions={execute=false,read=true,write=false},data="local a=require('system.expect')local function b(c,...)return a.expect(...)end;local function d(c,...)return a.field(...)end;local function e(self,f)local g=f<0 and#self+f or f;if g>=0 and g<#self then return self[g+1]end;return nil end;local function h(i)return type(i)==\"table\"and(i[1]~=nil or next(i)==nil)end;local function j(self,...)local k={...}local l={}local m=0;for n=1,#self do m=m+1;l[m]=self[n]end;for n=1,#k do local o=k[n]if h(o)then for p=1,#o do m=m+1;l[m]=o[p]end else m=m+1;l[m]=o end end;return l end;local q,r;do local s={__tostring=function(self)return(\"Symbol(\"..(self.description or\"\"))..\")\"end}function q(t)return setmetatable({description=t},s)end;r={asyncDispose=q(\"Symbol.asyncDispose\"),dispose=q(\"Symbol.dispose\"),iterator=q(\"Symbol.iterator\"),hasInstance=q(\"Symbol.hasInstance\"),species=q(\"Symbol.species\"),toStringTag=q(\"Symbol.toStringTag\")}end;local function u(v)local w=0;return{[r.iterator]=function(self)return self end,next=function(self)local l={done=v[w+1]==nil,value={w,v[w+1]}}w=w+1;return l end}end;local function x(self,y,z)for n=1,#self do if not y(z,self[n],n-1,self)then return false end end;return true end;local function A(self,i,B,C)local D=B or 0;local E=C or#self;if D<0 then D=D+#self end;if E<0 then E=E+#self end;do local n=D;while n<E do self[n+1]=i;n=n+1 end end;return self end;local function F(self,y,z)local l={}local m=0;for n=1,#self do if y(z,self[n],n-1,self)then m=m+1;l[m]=self[n]end end;return l end;local function G(self,H,z)for n=1,#self do H(z,self[n],n-1,self)end end;local function I(self,J,z)for n=1,#self do local K=self[n]if J(z,K,n-1,self)then return K end end;return nil end;local function L(self,H,z)for n=1,#self do if H(z,self[n],n-1,self)then return n-1 end end;return-1 end;local M;do local function N(self)local O=self.____coroutine;local P,i=coroutine.resume(O)if not P then error(i,0)end;if coroutine.status(O)==\"dead\"then return end;return true,i end;local function Q(self)local l=self:next()if l.done then return end;return true,l.value end;local function R(self,S)S=S+1;if S>#self then return end;return S,string.sub(self,S,S)end;function M(T)if type(T)==\"string\"then return R,T,0 elseif T.____coroutine~=nil then return N,T elseif T[r.iterator]then local U=T[r.iterator](T)return Q,U else return ipairs(T)end end end;local V;do local function W(self,S)S=S+1;if S>self.length then return end;return S,self[S]end;local function X(Y)if type(Y.length)==\"number\"then return W,Y,0 end;return M(Y)end;function V(Z,_,z)local l={}if _==nil then for a0,a1 in X(Z)do l[#l+1]=a1 end else local n=0;for a0,a1 in X(Z)do local a2=_;local a3=z;local a4=a1;local a5=n;n=a5+1;l[#l+1]=a2(a3,a4,a5)end end;return l end end;local function a6(self,a7,a8)if a8==nil then a8=0 end;local m=#self;local a9=a8;if a8<0 then a9=m+a8 end;if a9<0 then a9=0 end;for n=a9+1,m do if self[n]==a7 then return true end end;return false end;local function aa(self,a7,a8)if a8==nil then a8=0 end;local m=#self;if m==0 then return-1 end;if a8>=m then return-1 end;if a8<0 then a8=m+a8;if a8<0 then a8=0 end end;for n=a8+1,m do if self[n]==a7 then return n-1 end end;return-1 end;local function ab(self,ac)if ac==nil then ac=\",\"end;local ad={}for n=1,#self do ad[n]=tostring(self[n])end;return table.concat(ad,ac)end;local function ae(self,y,z)local l={}for n=1,#self do l[n]=y(z,self[n],n-1,self)end;return l end;local function af(self,...)local k={...}local m=#self;for n=1,#k do m=m+1;self[m]=k[n]end;return m end;local function ag(self,k)local m=#self;for n=1,#k do m=m+1;self[m]=k[n]end;return m end;local function ah(...)return select(\"#\",...)end;local function ai(self,H,...)local m=#self;local a9=0;local aj=nil;if ah(...)~=0 then aj=...elseif m>0 then aj=self[1]a9=1 else error(\"Reduce of empty array with no initial value\",0)end;for n=a9+1,m do aj=H(nil,aj,self[n],n-1,self)end;return aj end;local function ak(self,H,...)local m=#self;local a9=m-1;local aj=nil;if ah(...)~=0 then aj=...elseif m>0 then aj=self[a9+1]a9=a9-1 else error(\"Reduce of empty array with no initial value\",0)end;for n=a9+1,1,-1 do aj=H(nil,aj,self[n],n-1,self)end;return aj end;local function al(self)local n=1;local p=#self;while n<p do local am=self[p]self[p]=self[n]self[n]=am;n=n+1;p=p-1 end;return self end;local function an(self,...)local k={...}local ao=#k;if ao==0 then return#self end;for n=#self,1,-1 do self[n+ao]=self[n]end;for n=1,ao do self[n]=k[n]end;return#self end;local function ap(self,aq)if aq~=nil then table.sort(self,function(ar,as)return aq(nil,ar,as)<0 end)else table.sort(self)end;return self end;local function at(self,au,av)local m=#self;au=au or 0;if au<0 then au=m+au;if au<0 then au=0 end else if au>m then au=m end end;av=av or m;if av<0 then av=m+av;if av<0 then av=0 end else if av>m then av=m end end;local aw={}au=au+1;av=av+1;local ax=1;while au<av do aw[ax]=self[au]au=au+1;ax=ax+1 end;return aw end;local function ay(self,y,z)for n=1,#self do if y(z,self[n],n-1,self)then return true end end;return false end;local function az(self,...)local aA={...}local m=#self;local aB=ah(...)local B=aA[1]local aC=aA[2]if B<0 then B=m+B;if B<0 then B=0 end elseif B>m then B=m end;local aD=aB-2;if aD<0 then aD=0 end;local aE;if aB==0 then aE=0 elseif aB==1 then aE=m-B else aE=aC or 0;if aE<0 then aE=0 end;if aE>m-B then aE=m-B end end;local aw={}for a9=1,aE do local aF=B+a9;if self[aF]~=nil then aw[a9]=self[aF]end end;if aD<aE then for a9=B+1,m-aE do local aF=a9+aE;local aG=a9+aD;if self[aF]then self[aG]=self[aF]else self[aG]=nil end end;for a9=m-aE+aD+1,m do self[a9]=nil end elseif aD>aE then for a9=m-aE,B+1,-1 do local aF=a9+aE;local aG=a9+aD;if self[aF]then self[aG]=self[aF]else self[aG]=nil end end end;local p=B+1;for n=3,aB do self[p]=aA[n]p=p+1 end;for a9=#self,m-aE+aD+1,-1 do self[a9]=nil end;return aw end;local function aH(self)local aI={}for n=1,#self do aI[n-1]=self[n]end;return aI end;local function aJ(self,aK)if aK==nil then aK=1 end;local l={}local m=0;for n=1,#self do local i=self[n]if aK>0 and h(i)then local aL;if aK==1 then aL=i else aL=aJ(i,aK-1)end;for p=1,#aL do local aM=aL[p]m=m+1;l[m]=aM end else m=m+1;l[m]=i end end;return l end;local function aN(self,aO,z)local l={}local m=0;for n=1,#self do local i=aO(z,self[n],n-1,self)if h(i)then for p=1,#i do m=m+1;l[m]=i[p]end else m=m+1;l[m]=i end end;return l end;local function aP(self,aQ)if aQ<0 or aQ~=aQ or aQ==math.huge or math.floor(aQ)~=aQ then error(\"invalid array length: \"..tostring(aQ),0)end;for n=aQ+1,#self do self[n]=nil end;return aQ end;local aR=table.unpack or unpack;local function aS(self)local aT={aR(self)}al(aT)return aT end;local function aU(self,aq)local aT={aR(self)}ap(aT,aq)return aT end;local function aV(self,B,aC,...)local aT={aR(self)}az(aT,B,aC,...)return aT end;local function aW(self,S,i)local aT={aR(self)}aT[S+1]=i;return aT end;local function aX(aY,...)local aZ=setmetatable({},aY.prototype)aZ:____constructor(...)return aZ end;local function a_(b0,b1)if type(b1)~=\"table\"then error(\"Right-hand side of 'instanceof' is not an object\",0)end;if b1[r.hasInstance]~=nil then return not not b1[r.hasInstance](b1,b0)end;if type(b0)==\"table\"then local b2=b0.constructor;while b2~=nil do if b2==b1 then return true end;b2=b2.____super end end;return false end;local function b3(self)local b4={prototype={}}b4.prototype.__index=b4.prototype;b4.prototype.constructor=b4;return b4 end;local b5;do local function b6()local b7;local b8;local function b9(a0,ba,bb)b7=ba;b8=bb end;return function()local bc=aX(b5,b9)return bc,b7,b8 end end;local bd=b6()local function be(i)return a_(i,b5)end;local function bf(self)end;local bg=_G.pcall;b5=b3()b5.name=\"__TS__Promise\"function b5.prototype.____constructor(self,b9)self.state=0;self.fulfilledCallbacks={}self.rejectedCallbacks={}self.finallyCallbacks={}local bh,bi=bg(b9,nil,function(a0,a1)return self:resolve(a1)end,function(a0,bj)return self:reject(bj)end)if not bh then self:reject(bi)end end;function b5.resolve(i)if a_(i,b5)then return i end;local bc=aX(b5,bf)bc.state=1;bc.value=i;return bc end;function b5.reject(bk)local bc=aX(b5,bf)bc.state=2;bc.rejectionReason=bk;return bc end;b5.prototype[\"then\"]=function(self,bl,bm)local bc,b7,b8=bd()self:addCallbacks(bl and self:createPromiseResolvingCallback(bl,b7,b8)or b7,bm and self:createPromiseResolvingCallback(bm,b7,b8)or b8)return bc end;function b5.prototype.addCallbacks(self,bn,bo)if self.state==1 then return bn(nil,self.value)end;if self.state==2 then return bo(nil,self.rejectionReason)end;local bp=self.fulfilledCallbacks;bp[#bp+1]=bn;local bq=self.rejectedCallbacks;bq[#bq+1]=bo end;function b5.prototype.catch(self,bm)return self[\"then\"](self,nil,bm)end;function b5.prototype.finally(self,br)if br then local bs=self.finallyCallbacks;bs[#bs+1]=br;if self.state~=0 then br(nil)end end;return self end;function b5.prototype.resolve(self,i)if be(i)then return i:addCallbacks(function(a0,a1)return self:resolve(a1)end,function(a0,bj)return self:reject(bj)end)end;if self.state==0 then self.state=1;self.value=i;return self:invokeCallbacks(self.fulfilledCallbacks,i)end end;function b5.prototype.reject(self,bk)if self.state==0 then self.state=2;self.rejectionReason=bk;return self:invokeCallbacks(self.rejectedCallbacks,bk)end end;function b5.prototype.invokeCallbacks(self,bt,i)local bu=#bt;local bv=self.finallyCallbacks;local bw=#bv;if bu~=0 then for n=1,bu-1 do bt[n](bt,i)end;if bw==0 then return bt[bu](bt,i)end;bt[bu](bt,i)end;if bw~=0 then for n=1,bw-1 do bv[n](bv)end;return bv[bw](bv)end end;function b5.prototype.createPromiseResolvingCallback(self,bx,b7,b8)return function(a0,i)local bh,by=bg(bx,nil,i)if not bh then return b8(nil,by)end;return self:handleCallbackValue(by,b7,b8)end end;function b5.prototype.handleCallbackValue(self,i,b7,b8)if be(i)then local bz=i;if bz.state==1 then return b7(nil,bz.value)elseif bz.state==2 then return b8(nil,bz.rejectionReason)else return bz:addCallbacks(b7,b8)end else return b7(nil,i)end end end;local bA,bB;do local bC=_G.coroutine or{}local bD=bC.create;local bE=bC.resume;local bF=bC.status;local bG=bC.yield;function bA(bH)return aX(b5,function(a0,b7,b8)local bI,bJ,bK,bL;function bI(self,i)local bh,by=bE(bL,i)if bh then return bJ(by)end;return b8(nil,by)end;function bJ(l)if bK then return end;if bF(bL)==\"dead\"then return b7(nil,l)end;return b5.resolve(l):addCallbacks(bI,b8)end;bK=false;bL=bD(bH)local bh,by=bE(bL,function(a0,a1)bK=true;return b5.resolve(a1):addCallbacks(b7,b8)end)if bh then return bJ(by)else return b8(nil,by)end end)end;function bB(bM)return bG(bM)end end;local function bN(aY,bO)aY.____super=bO;local bP=setmetatable({__index=bO},bO)setmetatable(aY,bP)local bQ=getmetatable(bO)if bQ then if type(bQ.__index)==\"function\"then bP.__index=bQ.__index end;if type(bQ.__newindex)==\"function\"then bP.__newindex=bQ.__newindex end end;setmetatable(aY.prototype,bO.prototype)if type(bO.prototype.__index)==\"function\"then aY.prototype.__index=bO.prototype.__index end;if type(bO.prototype.__newindex)==\"function\"then aY.prototype.__newindex=bO.prototype.__newindex end;if type(bO.prototype.__tostring)==\"function\"then aY.prototype.__tostring=bO.prototype.__tostring end end;local function bR(bS)local i;local bT;local bU;local bV;local bW;local bX;bX=bS.enumerable;bW=bS.configurable;bV=bS.get;bU=bS.set;bT=bS.writable;i=bS.value;local bY={enumerable=bX==true,configurable=bW==true}local bZ=bV~=nil or bU~=nil;local b_=bT~=nil or i~=nil;if bZ and b_ then error(\"Invalid property descriptor. Cannot both specify accessors and a value or writable attribute.\",0)end;if bV or bU then bY.get=bV;bY.set=bU else bY.value=i;bY.writable=bT==true end;return bY end;local function c0(self,c1,c2,c3)local l=c1;do local n=#c2;while n>=0 do local c4=c2[n+1]if c4~=nil then local c5=c4(self,l,c3)if c5==nil then c5=l end;l=c5 end;n=n-1 end end;return l end;local function c6(aY,...)local c7={...}for n=1,#c7 do local c8=c7[n]for w in pairs(c8)do aY[w]=c8[w]end end;return aY end;local function c9(aI,w)local ca=getmetatable(aI)if not ca then return end;if not rawget(ca,\"_descriptors\")then return end;return rawget(ca,\"_descriptors\")[w]end;local cb;do local getmetatable=_G.getmetatable;local cc=_G.rawget;function cb(self,ca,w)while ca do local cd=cc(ca,w)if cd~=nil then return cd end;local ce=cc(ca,\"_descriptors\")if ce then local bY=ce[w]if bY~=nil then if bY.get then return bY.get(self)end;return bY.value end end;ca=getmetatable(ca)end end end;local cf;do local getmetatable=_G.getmetatable;local cc=_G.rawget;local rawset=_G.rawset;function cf(self,ca,w,i)while ca do local ce=cc(ca,\"_descriptors\")if ce then local bY=ce[w]if bY~=nil then if bY.set then bY.set(self,i)else if bY.writable==false then error((((\"Cannot assign to read only property '\"..w)..\"' of object '\")..tostring(self))..\"'\",0)end;bY.value=i end;return end end;ca=getmetatable(ca)end;rawset(self,w,i)end end;local cg;do local getmetatable=_G.getmetatable;local function ch(self,w)return cb(self,getmetatable(self),w)end;local function ci(self,w,i)return cf(self,getmetatable(self),w,i)end;function cg(aY,w,cj,ck)if ck==nil then ck=false end;local cl;if ck then cl=aY else cl=getmetatable(aY)end;local ca=cl;if not ca then ca={}setmetatable(aY,ca)end;local i=rawget(aY,w)if i~=nil then rawset(aY,w,nil)end;if not rawget(ca,\"_descriptors\")then ca._descriptors={}end;ca._descriptors[w]=bR(cj)ca.__index=ch;ca.__newindex=ci end end;local function cm(c2,aY,w,cj)local l=aY;do local n=#c2;while n>=0 do local c4=c2[n+1]if c4~=nil then local cn=l;if w==nil then l=c4(nil,l)elseif cj==true then local i=rawget(aY,w)local bY=c9(aY,w)or{configurable=true,writable=true,value=i}local cj=c4(nil,aY,w,bY)or bY;local co=cj.configurable==true and cj.writable==true and not cj.get and not cj.set;if co then rawset(aY,w,cj.value)else cg(aY,w,c6({},bY,cj))end elseif cj==false then l=c4(nil,aY,w,cj)else l=c4(nil,aY,w)end;l=l or cn end;n=n-1 end end;return l end;local function cp(cq,c4)return function(a0,aY,w)return c4(nil,aY,w,cq)end end;local function cr(self,cs,ct)if not ct then ct=1 else ct=ct+1 end;local S=string.find(self,cs,ct,true)return S~=nil end;local cu,cv,cw,cx,cy,cz;do local function cA(self,cB)if debug==nil then return nil end;local cC=1;while true do local cD=debug.getinfo(cC,\"f\")cC=cC+1;if not cD then cC=1;break elseif cD.func==cB then break end end;if cr(_VERSION,\"Lua 5.0\")then return debug.traceback((\"[Level \"..tostring(cC))..\"]\")else return debug.traceback(nil,cC)end end;local function cE(self,cF)return function(self)local t=cF(self)local cG=debug.getinfo(3,\"f\")local cH=cr(_VERSION,\"Lua 5.0\")or _VERSION==\"Lua 5.1\"if cH or cG and cG.func~=error then return t else return(t..\"\\n\")..tostring(self.stack)end end end;local function cI(self,cJ,cK)cJ.name=cK;return setmetatable(cJ,{__call=function(a0,cL,cM)return aX(cJ,cM)end})end;local cN=cI;local cO=b3()cO.name=\"\"function cO.prototype.____constructor(self,cM)if cM==nil then cM=\"\"end;self.message=cM;self.name=\"Error\"self.stack=cA(nil,self.constructor.new)local ca=getmetatable(self)if ca and not ca.__errorToStringPatched then ca.__errorToStringPatched=true;ca.__tostring=cE(nil,ca.__tostring)end end;function cO.prototype.__tostring(self)return self.message~=\"\"and(self.name..\": \")..self.message or self.name end;cu=cN(nil,cO,\"Error\")local function cP(self,cK)local cQ=cI;local cR=b3()cR.name=cR.name;bN(cR,cu)function cR.prototype.____constructor(self,...)cR.____super.prototype.____constructor(self,...)self.name=cK end;return cQ(nil,cR,cK)end;cv=cP(nil,\"RangeError\")cw=cP(nil,\"ReferenceError\")cx=cP(nil,\"SyntaxError\")cy=cP(nil,\"TypeError\")cz=cP(nil,\"URIError\")end;local function cS(aI)local ca=getmetatable(aI)if not ca then return{}end;return rawget(ca,\"_descriptors\")or{}end;local function cT(aY,w)local ce=cS(aY)local bY=ce[w]if bY then if not bY.configurable then error(aX(cy,(((\"Cannot delete property \"..tostring(w))..\" of \")..tostring(aY))..\".\"),0)end;ce[w]=nil;return true end;aY[w]=nil;return true end;local function cU(self,S)if S>=0 and S<#self then return string.sub(self,S+1,S+1)end end;local function cV(T)if type(T)==\"string\"then for S=0,#T-1 do coroutine.yield(cU(T,S))end elseif T.____coroutine~=nil then local O=T.____coroutine;while true do local P,i=coroutine.resume(O)if not P then error(i,0)end;if coroutine.status(O)==\"dead\"then return i else coroutine.yield(i)end end elseif T[r.iterator]then local U=T[r.iterator](T)while true do local l=U:next()if l.done then return l.value else coroutine.yield(l.value)end end else for a0,i in ipairs(T)do coroutine.yield(i)end end end;local function cW(cX,...)local cY={...}return function(a0,...)local aA={...}an(aA,aR(cY))return cX(aR(aA))end end;local cZ;do local function c_(self)return self end;local function d0(self,...)local O=self.____coroutine;if coroutine.status(O)==\"dead\"then return{done=true}end;local P,i=coroutine.resume(O,...)if not P then error(i,0)end;return{value=i,done=coroutine.status(O)==\"dead\"}end;function cZ(cX)return function(...)local aA={...}local d1=ah(...)return{____coroutine=coroutine.create(function()return cX(aR(aA,1,d1))end),[r.iterator]=c_,next=d0}end end end;local function d2(i)local d3=type(i)return d3==\"table\"or d3==\"function\"end;local function d4(self,d5,d6)local d7={}local w,i=self(d5,d6)while w do d7[#d7+1]={w,i}w,i=self(d5,w)end;return aR(d7)end;local d8;do d8=b3()d8.name=\"Map\"function d8.prototype.____constructor(self,d9)self[r.toStringTag]=\"Map\"self.items={}self.size=0;self.nextKey={}self.previousKey={}if d9==nil then return end;local T=d9;if T[r.iterator]then local U=T[r.iterator](T)while true do local l=U:next()if l.done then break end;local i=l.value;self:set(i[1],i[2])end else local v=d9;for a0,da in ipairs(v)do self:set(da[1],da[2])end end end;function d8.prototype.clear(self)self.items={}self.nextKey={}self.previousKey={}self.firstKey=nil;self.lastKey=nil;self.size=0 end;function d8.prototype.delete(self,w)local db=self:has(w)if db then self.size=self.size-1;local next=self.nextKey[w]local dc=self.previousKey[w]if next~=nil and dc~=nil then self.nextKey[dc]=next;self.previousKey[next]=dc elseif next~=nil then self.firstKey=next;self.previousKey[next]=nil elseif dc~=nil then self.lastKey=dc;self.nextKey[dc]=nil else self.firstKey=nil;self.lastKey=nil end;self.nextKey[w]=nil;self.previousKey[w]=nil end;self.items[w]=nil;return db end;function d8.prototype.forEach(self,aO)for a0,w in M(self:keys())do aO(nil,self.items[w],w,self)end end;function d8.prototype.get(self,w)return self.items[w]end;function d8.prototype.has(self,w)return self.nextKey[w]~=nil or self.lastKey==w end;function d8.prototype.set(self,w,i)local dd=not self:has(w)if dd then self.size=self.size+1 end;self.items[w]=i;if self.firstKey==nil then self.firstKey=w;self.lastKey=w elseif dd then self.nextKey[self.lastKey]=w;self.previousKey[w]=self.lastKey;self.lastKey=w end;return self end;d8.prototype[r.iterator]=function(self)return self:entries()end;function d8.prototype.entries(self)local k=self.items;local de=self.nextKey;local w=self.firstKey;return{[r.iterator]=function(self)return self end,next=function(self)local l={done=not w,value={w,k[w]}}w=de[w]return l end}end;function d8.prototype.keys(self)local de=self.nextKey;local w=self.firstKey;return{[r.iterator]=function(self)return self end,next=function(self)local l={done=not w,value=w}w=de[w]return l end}end;function d8.prototype.values(self)local k=self.items;local de=self.nextKey;local w=self.firstKey;return{[r.iterator]=function(self)return self end,next=function(self)local l={done=not w,value=k[w]}w=de[w]return l end}end;d8[r.species]=d8 end;local function df(k,dg)local l=aX(d8)local n=0;for a0,o in M(k)do local w=dg(nil,o,n)if l:has(w)then local dh=l:get(w)dh[#dh+1]=o else l:set(w,{o})end;n=n+1 end;return l end;local di=string.match;local dj=math.atan2 or math.atan;local dk=math.modf;local function dl(i)return i~=i end;local function dm(aM)if dl(aM)or aM==0 then return aM end;if aM<0 then return-1 end;return 1 end;local function dn(i)return type(i)==\"number\"and i==i and i~=math.huge and i~=-math.huge end;local function dp(aM)if not dn(aM)or aM==0 then return aM end;return aM>0 and math.floor(aM)or math.ceil(aM)end;local function dq(i)local d3=type(i)if d3==\"number\"then return i elseif d3==\"string\"then local dr=tonumber(i)if dr then return dr end;if i==\"Infinity\"then return math.huge end;if i==\"-Infinity\"then return-math.huge end;local ds=string.gsub(i,\"%s\",\"\")if ds==\"\"then return 0 end;return 0/0 elseif d3==\"boolean\"then return i and 1 or 0 else return 0/0 end end;local function dt(i)return dn(i)and math.floor(i)==i end;local function du(self,B,C)if C~=C then C=0 end;if C~=nil and B>C then B,C=C,B end;if B>=0 then B=B+1 else B=1 end;if C~=nil and C<0 then C=0 end;return string.sub(self,B,C)end;local dv;do local dw=\"0123456789aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTvVwWxXyYzZ\"function dv(dx,bO)if bO==nil then bO=10;local dy=di(dx,\"^%s*-?0[xX]\")if dy~=nil then bO=16;dx=di(dy,\"-\")and\"-\"..du(dx,#dy)or du(dx,#dy)end end;if bO<2 or bO>36 then return 0/0 end;local dz=bO<=10 and du(dw,0,bO)or du(dw,0,10+2*(bO-10))local dA=(\"^%s*(-?[\"..dz)..\"]*)\"local dB=tonumber(di(dx,dA),bO)if dB==nil then return 0/0 end;if dB>=0 then return math.floor(dB)else return math.ceil(dB)end end end;local function dC(dx)local dD=di(dx,\"^%s*(-?Infinity)\")if dD~=nil then return cU(dD,0)==\"-\"and-math.huge or math.huge end;local dB=tonumber(di(dx,\"^%s*(-?%d+%.?%d*)\"))return dB or 0/0 end;local dE;do local dF=\"0123456789abcdefghijklmnopqrstuvwxyz\"function dE(self,dG)if dG==nil or dG==10 or self==math.huge or self==-math.huge or self~=self then return tostring(self)end;dG=math.floor(dG)if dG<2 or dG>36 then error(\"toString() radix argument must be between 2 and 36\",0)end;local dH,dI=dk(math.abs(self))local l=\"\"if dG==8 then l=string.format(\"%o\",dH)elseif dG==16 then l=string.format(\"%x\",dH)else repeat do l=cU(dF,dH%dG)..l;dH=math.floor(dH/dG)end until not(dH~=0)end;if dI~=0 then l=l..\".\"local dJ=1e-16;repeat do dI=dI*dG;dJ=dJ*dG;local dK=math.floor(dI)l=l..cU(dF,dK)dI=dI-dK end until not(dI>=dJ)end;if self<0 then l=\"-\"..l end;return l end end;local function dL(self,dM)if math.abs(self)>=1e+21 or self~=self then return tostring(self)end;local bx=math.floor(dM or 0)if bx<0 or bx>99 then error(\"toFixed() digits argument must be between 0 and 99\",0)end;return string.format((\"%.\"..tostring(bx))..\"f\",self)end;local function dN(aY,w,cj)local dO=type(w)==\"number\"and w+1 or w;local i=rawget(aY,dO)local bZ=cj.get~=nil or cj.set~=nil;local bY;if bZ then if i~=nil then error(\"Cannot redefine property: \"..tostring(w),0)end;bY=cj else local dP=i~=nil;local dQ=cj.set;local dR=cj.get;local dS=cj.configurable;if dS==nil then dS=dP end;local dT=cj.enumerable;if dT==nil then dT=dP end;local dU=cj.writable;if dU==nil then dU=dP end;local dV;if cj.value~=nil then dV=cj.value else dV=i end;bY={set=dQ,get=dR,configurable=dS,enumerable=dT,writable=dU,value=dV}end;cg(aY,dO,bY)return aY end;local function dW(b0)local l={}local m=0;for w in pairs(b0)do m=m+1;l[m]={w,b0[w]}end;return l end;local function dX(d9)local b0={}local T=d9;if T[r.iterator]then local U=T[r.iterator](T)while true do local l=U:next()if l.done then break end;local i=l.value;b0[i[1]]=i[2]end else for a0,dY in ipairs(d9)do b0[dY[1]]=dY[2]end end;return b0 end;local function dZ(k,dg)local l={}local n=0;for a0,o in M(k)do local w=dg(nil,o,n)if l[w]~=nil then local d_=l[w]d_[#d_+1]=o else l[w]={o}end;n=n+1 end;return l end;local function e0(b0)local l={}local m=0;for w in pairs(b0)do m=m+1;l[m]=w end;return l end;local function e1(aY,e2)local l={}for e3 in pairs(aY)do if not e2[e3]then l[e3]=aY[e3]end end;return l end;local function e4(b0)local l={}local m=0;for w in pairs(b0)do m=m+1;l[m]=b0[w]end;return l end;local function e5(T)local d7={}local e6={}local e7=0;local n=0;for a0,o in M(T)do if a_(o,b5)then if o.state==1 then d7[n+1]=o.value elseif o.state==2 then return b5.reject(o.rejectionReason)else e7=e7+1;e6[n]=o end else d7[n+1]=o end;n=n+1 end;if e7==0 then return b5.resolve(d7)end;return aX(b5,function(a0,b7,b8)for S,bc in pairs(e6)do bc[\"then\"](bc,function(a0,e8)d7[S+1]=e8;e7=e7-1;if e7==0 then b7(nil,d7)end end,function(a0,bk)b8(nil,bk)end)end end)end;local function e9(T)local d7={}local e6={}local e7=0;local n=0;for a0,o in M(T)do if a_(o,b5)then if o.state==1 then d7[n+1]={status=\"fulfilled\",value=o.value}elseif o.state==2 then d7[n+1]={status=\"rejected\",reason=o.rejectionReason}else e7=e7+1;e6[n]=o end else d7[n+1]={status=\"fulfilled\",value=o}end;n=n+1 end;if e7==0 then return b5.resolve(d7)end;return aX(b5,function(a0,b7)for S,bc in pairs(e6)do bc[\"then\"](bc,function(a0,e8)d7[S+1]={status=\"fulfilled\",value=e8}e7=e7-1;if e7==0 then b7(nil,d7)end end,function(a0,bk)d7[S+1]={status=\"rejected\",reason=bk}e7=e7-1;if e7==0 then b7(nil,d7)end end)end end)end;local function ea(T)local eb={}local ec={}for a0,o in M(T)do if a_(o,b5)then if o.state==1 then return b5.resolve(o.value)elseif o.state==2 then eb[#eb+1]=o.rejectionReason else ec[#ec+1]=o end else return b5.resolve(o)end end;if#ec==0 then return b5.reject(\"No promises to resolve with .any()\")end;local ed=0;return aX(b5,function(a0,b7,b8)for a0,bc in ipairs(ec)do bc[\"then\"](bc,function(a0,e8)b7(nil,e8)end,function(a0,bk)eb[#eb+1]=bk;ed=ed+1;if ed==#ec then b8(nil,{name=\"AggregateError\",message=\"All Promises rejected\",errors=eb})end end)end end)end;local function ee(T)local ec={}for a0,o in M(T)do if a_(o,b5)then if o.state==1 then return b5.resolve(o.value)elseif o.state==2 then return b5.reject(o.rejectionReason)else ec[#ec+1]=o end else return b5.resolve(o)end end;return aX(b5,function(a0,b7,b8)for a0,bc in ipairs(ec)do bc[\"then\"](bc,function(a0,i)return b7(nil,i)end,function(a0,bk)return b8(nil,bk)end)end end)end;local ef;do ef=b3()ef.name=\"Set\"function ef.prototype.____constructor(self,eg)self[r.toStringTag]=\"Set\"self.size=0;self.nextKey={}self.previousKey={}if eg==nil then return end;local T=eg;if T[r.iterator]then local U=T[r.iterator](T)while true do local l=U:next()if l.done then break end;self:add(l.value)end else local v=eg;for a0,i in ipairs(v)do self:add(i)end end end;function ef.prototype.add(self,i)local dd=not self:has(i)if dd then self.size=self.size+1 end;if self.firstKey==nil then self.firstKey=i;self.lastKey=i elseif dd then self.nextKey[self.lastKey]=i;self.previousKey[i]=self.lastKey;self.lastKey=i end;return self end;function ef.prototype.clear(self)self.nextKey={}self.previousKey={}self.firstKey=nil;self.lastKey=nil;self.size=0 end;function ef.prototype.delete(self,i)local db=self:has(i)if db then self.size=self.size-1;local next=self.nextKey[i]local dc=self.previousKey[i]if next~=nil and dc~=nil then self.nextKey[dc]=next;self.previousKey[next]=dc elseif next~=nil then self.firstKey=next;self.previousKey[next]=nil elseif dc~=nil then self.lastKey=dc;self.nextKey[dc]=nil else self.firstKey=nil;self.lastKey=nil end;self.nextKey[i]=nil;self.previousKey[i]=nil end;return db end;function ef.prototype.forEach(self,aO)for a0,w in M(self:keys())do aO(nil,w,w,self)end end;function ef.prototype.has(self,i)return self.nextKey[i]~=nil or self.lastKey==i end;ef.prototype[r.iterator]=function(self)return self:values()end;function ef.prototype.entries(self)local de=self.nextKey;local w=self.firstKey;return{[r.iterator]=function(self)return self end,next=function(self)local l={done=not w,value={w,w}}w=de[w]return l end}end;function ef.prototype.keys(self)local de=self.nextKey;local w=self.firstKey;return{[r.iterator]=function(self)return self end,next=function(self)local l={done=not w,value=w}w=de[w]return l end}end;function ef.prototype.values(self)local de=self.nextKey;local w=self.firstKey;return{[r.iterator]=function(self)return self end,next=function(self)local l={done=not w,value=w}w=de[w]return l end}end;function ef.prototype.union(self,eh)local l=aX(ef,self)for a0,o in M(eh)do l:add(o)end;return l end;function ef.prototype.intersection(self,eh)local l=aX(ef)for a0,o in M(self)do if eh:has(o)then l:add(o)end end;return l end;function ef.prototype.difference(self,eh)local l=aX(ef,self)for a0,o in M(eh)do l:delete(o)end;return l end;function ef.prototype.symmetricDifference(self,eh)local l=aX(ef,self)for a0,o in M(eh)do if self:has(o)then l:delete(o)else l:add(o)end end;return l end;function ef.prototype.isSubsetOf(self,eh)for a0,o in M(self)do if not eh:has(o)then return false end end;return true end;function ef.prototype.isSupersetOf(self,eh)for a0,o in M(eh)do if not self:has(o)then return false end end;return true end;function ef.prototype.isDisjointFrom(self,eh)for a0,o in M(self)do if eh:has(o)then return false end end;return true end;ef[r.species]=ef end;local function ei(...)local ej={...}ej.sparseLength=ah(...)return ej end;local function ek(ej,...)local aA={...}local el=ah(...)local em=ej.sparseLength;for n=1,el do ej[em+n]=aA[n]end;ej.sparseLength=em+el end;local function en(ej)local eo=unpack or table.unpack;return eo(ej,1,ej.sparseLength)end;local ep;do ep=b3()ep.name=\"WeakMap\"function ep.prototype.____constructor(self,d9)self[r.toStringTag]=\"WeakMap\"self.items={}setmetatable(self.items,{__mode=\"k\"})if d9==nil then return end;local T=d9;if T[r.iterator]then local U=T[r.iterator](T)while true do local l=U:next()if l.done then break end;local i=l.value;self.items[i[1]]=i[2]end else for a0,da in ipairs(d9)do self.items[da[1]]=da[2]end end end;function ep.prototype.delete(self,w)local db=self:has(w)self.items[w]=nil;return db end;function ep.prototype.get(self,w)return self.items[w]end;function ep.prototype.has(self,w)return self.items[w]~=nil end;function ep.prototype.set(self,w,i)self.items[w]=i;return self end;ep[r.species]=ep end;local eq;do eq=b3()eq.name=\"WeakSet\"function eq.prototype.____constructor(self,eg)self[r.toStringTag]=\"WeakSet\"self.items={}setmetatable(self.items,{__mode=\"k\"})if eg==nil then return end;local T=eg;if T[r.iterator]then local U=T[r.iterator](T)while true do local l=U:next()if l.done then break end;self.items[l.value]=true end else for a0,i in ipairs(eg)do self.items[i]=true end end end;function eq.prototype.add(self,i)self.items[i]=true;return self end;function eq.prototype.delete(self,i)local db=self:has(i)self.items[i]=nil;return db end;function eq.prototype.has(self,i)return self.items[i]==true end;eq[r.species]=eq end;local function er(es,et)_G.__TS__sourcemap=_G.__TS__sourcemap or{}_G.__TS__sourcemap[es]=et;if _G.__TS__originalTraceback==nil then local eu=debug.traceback;_G.__TS__originalTraceback=eu;debug.traceback=function(ev,cM,cC)local ew;if ev==nil and cM==nil and cC==nil then ew=eu()elseif cr(_VERSION,\"Lua 5.0\")then ew=eu(((\"[Level \"..tostring(cC))..\"] \")..tostring(cM))else ew=eu(ev,cM,cC)end;if type(ew)~=\"string\"then return ew end;local function ex(a0,ey,ez,eA)local eB=_G.__TS__sourcemap[ey]if eB~=nil and eB[eA]~=nil then local e8=eB[eA]if type(e8)==\"number\"then return(ez..\":\")..tostring(e8)end;return(e8.file..\":\")..tostring(e8.line)end;return(ey..\":\")..eA end;local l=string.gsub(ew,\"(%S+)%.lua:(%d+)\",function(ey,eA)return ex(nil,ey..\".lua\",ey..\".ts\",eA)end)local function eC(a0,ey,eA)local eB=_G.__TS__sourcemap[ey]if eB~=nil and eB[eA]~=nil then local eD=di(ey,\"%[string \\\"([^\\\"]+)\\\"%]\")local eE=string.gsub(eD,\".lua$\",\".ts\")local e8=eB[eA]if type(e8)==\"number\"then return(eE..\":\")..tostring(e8)end;return(e8.file..\":\")..tostring(e8.line)end;return(ey..\":\")..eA end;l=string.gsub(l,\"(%[string \\\"[^\\\"]+\\\"%]):(%d+)\",function(ey,eA)return eC(nil,ey,eA)end)return l end end end;local function eF(T)local Y={}if type(T)==\"string\"then for n=0,#T-1 do Y[n+1]=cU(T,n)end else local m=0;for a0,o in M(T)do m=m+1;Y[m]=o end end;return aR(Y)end;local function eG(self,eH)if eH~=eH then eH=0 end;if eH<0 then return\"\"end;return string.sub(self,eH+1,eH+1)end;local function eI(self,S)if S~=S then S=0 end;if S<0 then return 0/0 end;return string.byte(self,S+1)or 0/0 end;local function eJ(self,cs,eK)if eK==nil or eK>#self then eK=#self end;return string.sub(self,eK-#cs+1,eK)==cs end;local function eL(self,eM,eN)if eN==nil then eN=\" \"end;if eM~=eM then eM=0 end;if eM==-math.huge or eM==math.huge then error(\"Invalid string length\",0)end;if#self>=eM or#eN==0 then return self end;eM=eM-#self;if eM>#eN then eN=eN..string.rep(eN,math.floor(eM/#eN))end;return self..string.sub(eN,1,math.floor(eM))end;local function eO(self,eM,eN)if eN==nil then eN=\" \"end;if eM~=eM then eM=0 end;if eM==-math.huge or eM==math.huge then error(\"Invalid string length\",0)end;if#self>=eM or#eN==0 then return self end;eM=eM-#self;if eM>#eN then eN=eN..string.rep(eN,math.floor(eM/#eN))end;return string.sub(eN,1,math.floor(eM))..self end;local eP;do local eQ=string.sub;function eP(c8,eR,eS)local eT,eU=string.find(c8,eR,nil,true)if not eT then return c8 end;local eV=eQ(c8,1,eT-1)local eW=type(eS)==\"string\"and eS or eS(nil,eR,eT-1,c8)local eX=eQ(c8,eU+1)return(eV..eW)..eX end end;local eY;do local eQ=string.sub;local eZ=string.find;function eY(c8,ac,e_)if e_==nil then e_=4294967295 end;if e_==0 then return{}end;local l={}local f0=1;if ac==nil or ac==\"\"then for n=1,#c8 do l[f0]=eQ(c8,n,n)f0=f0+1 end else local f1=1;while f0<=e_ do local eT,eU=eZ(c8,ac,f1,true)if not eT then break end;l[f0]=eQ(c8,f1,eT-1)f0=f0+1;f1=eU+1 end;if f0<=e_ then l[f0]=eQ(c8,f1)end end;return l end end;local f2;do local eQ=string.sub;local eZ=string.find;function f2(c8,eR,eS)if type(eS)==\"string\"then local f3=table.concat(eY(c8,eR),eS)if#eR==0 then return(eS..f3)..eS end;return f3 end;local ad={}local f4=1;if#eR==0 then ad[1]=eS(nil,\"\",0,c8)f4=2;for n=1,#c8 do ad[f4]=eQ(c8,n,n)ad[f4+1]=eS(nil,\"\",n,c8)f4=f4+2 end else local f1=1;while true do local eT,eU=eZ(c8,eR,f1,true)if not eT then break end;ad[f4]=eQ(c8,f1,eT-1)ad[f4+1]=eS(nil,eR,eT-1,c8)f4=f4+2;f1=eU+1 end;ad[f4]=eQ(c8,f1)end;return table.concat(ad)end end;local function f5(self,B,C)if B==nil or B~=B then B=0 end;if C~=C then C=0 end;if B>=0 then B=B+1 end;if C~=nil and C<0 then C=C-1 end;return string.sub(self,B,C)end;local function f6(self,cs,ct)if ct==nil or ct<0 then ct=0 end;return string.sub(self,ct+1,#cs+ct)==cs end;local function f7(self,aF,aQ)if aF~=aF then aF=0 end;if aQ~=nil then if aQ~=aQ or aQ<=0 then return\"\"end;aQ=aQ+aF end;if aF>=0 then aF=aF+1 end;return string.sub(self,aF,aQ)end;local function f8(self)local l=string.gsub(self,\"^[%s\194\160\239\187\191]*(.-)[%s\194\160\239\187\191]*$\",\"%1\")return l end;local function f9(self)local l=string.gsub(self,\"[%s\194\160\239\187\191]*$\",\"\")return l end;local function fa(self)local l=string.gsub(self,\"^[%s\194\160\239\187\191]*\",\"\")return l end;local fb,fc;do local fd={}function fb(w)if not fd[w]then fd[w]=q(w)end;return fd[w]end;function fc(fe)for w in pairs(fd)do if fd[w]==fe then return w end end;return nil end end;local function ff(i)local fg=type(i)if fg==\"table\"then return\"object\"elseif fg==\"nil\"then return\"undefined\"else return fg end end;local function fh(self,fi,...)local aA={...}local fj;local fk,l=xpcall(function()return fi(aR(aA))end,function(bj)fj=bj;return fj end)local fl={aR(aA)}do local n=#fl-1;while n>=0 do local fm=fl[n+1]fm[r.dispose](fm)n=n-1 end end;if not fk then error(fj,0)end;return l end;local function fn(self,fi,...)local aA={...}return bA(function(fo)local fj;local fk,l=xpcall(function()return fi(nil,aR(aA))end,function(bj)fj=bj;return fj end)local fl={aR(aA)}do local n=#fl-1;while n>=0 do if fl[n+1][r.dispose]~=nil then local fm=fl[n+1]fm[r.dispose](fm)end;if fl[n+1][r.asyncDispose]~=nil then local fp=fl[n+1]bB(fp[r.asyncDispose](fp))end;n=n-1 end end;if not fk then error(fj,0)end;return fo(nil,l)end)end;return{__TS__ArrayAt=e,__TS__ArrayConcat=j,__TS__ArrayEntries=u,__TS__ArrayEvery=x,__TS__ArrayFill=A,__TS__ArrayFilter=F,__TS__ArrayForEach=G,__TS__ArrayFind=I,__TS__ArrayFindIndex=L,__TS__ArrayFrom=V,__TS__ArrayIncludes=a6,__TS__ArrayIndexOf=aa,__TS__ArrayIsArray=h,__TS__ArrayJoin=ab,__TS__ArrayMap=ae,__TS__ArrayPush=af,__TS__ArrayPushArray=ag,__TS__ArrayReduce=ai,__TS__ArrayReduceRight=ak,__TS__ArrayReverse=al,__TS__ArrayUnshift=an,__TS__ArraySort=ap,__TS__ArraySlice=at,__TS__ArraySome=ay,__TS__ArraySplice=az,__TS__ArrayToObject=aH,__TS__ArrayFlat=aJ,__TS__ArrayFlatMap=aN,__TS__ArraySetLength=aP,__TS__ArrayToReversed=aS,__TS__ArrayToSorted=aU,__TS__ArrayToSpliced=aV,__TS__ArrayWith=aW,__TS__AsyncAwaiter=bA,__TS__Await=bB,__TS__Class=b3,__TS__ClassExtends=bN,__TS__CloneDescriptor=bR,__TS__CountVarargs=ah,__TS__Decorate=c0,__TS__DecorateLegacy=cm,__TS__DecorateParam=cp,__TS__Delete=cT,__TS__DelegatedYield=cV,__TS__DescriptorGet=cb,__TS__DescriptorSet=cf,Error=cu,RangeError=cv,ReferenceError=cw,SyntaxError=cx,TypeError=cy,URIError=cz,__TS__FunctionBind=cW,__TS__Generator=cZ,__TS__InstanceOf=a_,__TS__InstanceOfObject=d2,__TS__Iterator=M,__TS__LuaIteratorSpread=d4,Map=d8,__TS__MapGroupBy=df,__TS__Match=di,__TS__MathAtan2=dj,__TS__MathModf=dk,__TS__MathSign=dm,__TS__MathTrunc=dp,__TS__New=aX,__TS__Number=dq,__TS__NumberIsFinite=dn,__TS__NumberIsInteger=dt,__TS__NumberIsNaN=dl,__TS__ParseInt=dv,__TS__ParseFloat=dC,__TS__NumberToString=dE,__TS__NumberToFixed=dL,__TS__ObjectAssign=c6,__TS__ObjectDefineProperty=dN,__TS__ObjectEntries=dW,__TS__ObjectFromEntries=dX,__TS__ObjectGetOwnPropertyDescriptor=c9,__TS__ObjectGetOwnPropertyDescriptors=cS,__TS__ObjectGroupBy=dZ,__TS__ObjectKeys=e0,__TS__ObjectRest=e1,__TS__ObjectValues=e4,__TS__ParseFloat=dC,__TS__ParseInt=dv,__TS__Promise=b5,__TS__PromiseAll=e5,__TS__PromiseAllSettled=e9,__TS__PromiseAny=ea,__TS__PromiseRace=ee,Set=ef,__TS__SetDescriptor=cg,__TS__SparseArrayNew=ei,__TS__SparseArrayPush=ek,__TS__SparseArraySpread=en,WeakMap=ep,WeakSet=eq,__TS__SourceMapTraceBack=er,__TS__Spread=eF,__TS__StringAccess=cU,__TS__StringCharAt=eG,__TS__StringCharCodeAt=eI,__TS__StringEndsWith=eJ,__TS__StringIncludes=cr,__TS__StringPadEnd=eL,__TS__StringPadStart=eO,__TS__StringReplace=eP,__TS__StringReplaceAll=f2,__TS__StringSlice=f5,__TS__StringSplit=eY,__TS__StringStartsWith=f6,__TS__StringSubstr=f7,__TS__StringSubstring=du,__TS__StringTrim=f8,__TS__StringTrimEnd=f9,__TS__StringTrimStart=fa,__TS__Symbol=q,Symbol=r,__TS__SymbolRegistryFor=fb,__TS__SymbolRegistryKeyFor=fc,__TS__TypeOf=ff,__TS__Unpack=aR,__TS__Using=fh,__TS__UsingAsync=fn}\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881294302,size=38003},["libsystem.a"]={type="file",created=1740881292781,worldPermissions={execute=false,read=true,write=false},data="!<arch>\n//                                              20        `\nserialization.lua/\n\nexpect.lua/     0           0     0     644     3967      `\nlocal a={}local b={[\"nil\"]=true,boolean=true,number=true,string=true,table=true,[\"function\"]=true,userdata=true,thread=true}local function c(d)return type(d)==\"table\"and(getmetatable(d)or{}).__call or type(d)==\"function\"end;local function e(f,g,...)local h=type(g)local i;if h==\"table\"then local j=getmetatable(g)if j then i=j.__name end end;local k=table.pack(...)for l,m in ipairs(k)do if b[m]then if h==m then return g end elseif i==m then return g elseif c(m)and m(g)then return g end end;local n=debug.getinfo(2,\"n\")if n and n.name and n.name~=\"\"then f=f..\" to '\"..n.name..\"'\"end;local o;if#k==1 and c(k[1])then local l,p=k[1](g)error(f..\" (\"..p..\")\",3)else for q,d in ipairs(k)do k[q]=tostring(d)end;if k.n==1 then o=k[1]elseif k.n==2 then o=k[1]..\" or \"..k[2]else o=table.concat(k,\", \",1,k.n-1)..\", or \"..k[k.n]end;error(f..\" (expected \"..o..\", got \"..h..\")\",3)end end;function a.expect(r,g,...)return e(\"bad argument #\"..r,g,...)end;function a.field(s,t,...)local u,v=pcall(string.format,\"%q\",t)if not u then v=tostring(t)end;return e(\"bad field \"..v,s[t],...)end;function a.range(w,x,y)a.expect(1,w,\"number\")a.expect(2,x,\"number\",\"nil\")a.expect(3,y,\"number\",\"nil\")if y and x and y<x then error(\"bad argument #3 (min must be less than or equal to max)\",2)end;if w~=w or w<(x or-math.huge)or w>(y or math.huge)then error((\"number outside of range (expected %s to be within %s and %s)\"):format(w,x or-math.huge,y or math.huge),3)end;return w end;local z={__tostring=function()return\"table\"end,__call=function(self,A)if type(A)~=\"table\"then return false,\"field '' not a table\"end;for B,o in pairs(self.struct)do if type(o)==\"string\"or c(o)then o={o}end;local g=A[B]local h=type(g)local i;if h==\"table\"then local j=getmetatable(g)if j then i=j.__name end end;local u=false;for l,m in ipairs(o)do if b[m]then if h==m then u=true;break end elseif i==m then u=true;break elseif c(m)and m(g)then u=true;break end end;if not u then if#o==1 and c(o[1])then local l,p=o[1](g)if p then p=p:gsub(\"'([^']*)'\",\"'\"..B..\".%1'\")return false,p end end;return false,\"bad field '\"..B..\"'\"end end;return true end}function a.struct(C)a.expect(1,C,\"table\")return setmetatable({struct=C},z)end;local D={__tostring=function()return\"table\"end,__call=function(self,E)if type(E)~=\"table\"then return false,\"field '' not a table\"end;for q,g in ipairs(E)do local h=type(g)local i;if h==\"table\"then local j=getmetatable(g)if j then i=j.__name end end;local u=false;for l,m in ipairs(self.types)do if b[m]then if h==m then u=true;break end elseif i==m then u=true;break elseif c(m)and m(g)then u=true;break end end;if not u then if#self.types==1 and c(self.types[1])then local l,p=self.types[1](g)if p then p=p:gsub(\"'([^*]+)'\",\"'\"..q..\".%1'\")return false,p end end;return false,\"bad entry '\"..q..\"'\"end end;return true end}function a.array(o)a.expect(1,o,\"string\",\"table\")if type(o)==\"string\"or c(o)then o={o}end;return setmetatable({types=o},D)end;local F={__tostring=function()return\"table\"end,__call=function(self,E)if type(E)~=\"table\"then return false,\"field '' not a table\"end;for B,g in pairs(E)do local h=type(g)local i;if h==\"table\"then local j=getmetatable(g)if j then i=j.__name end end;local u=false;for l,m in ipairs(self.types)do if b[m]then if h==m then u=true;break end elseif i==m then u=true;break elseif c(m)and m(g)then u=true;break end end;if not u then if#self.types==1 and c(self.types[1])then local l,p=self.types[1](g)if p then p=p:gsub(\"'([^']*)'\",\"'\"..B..\".%1'\")return false,p end end;return false,\"bad field '\"..B..\"'\"end end;return true end}function a.table(o)a.expect(1,o,\"string\",\"table\")if type(o)==\"string\"then o={o}end;return setmetatable({types=o},F)end;local G={__tostring=function()return\"string\"end,__call=function(self,g)return type(g)==\"string\"and g:match(self.pattern)~=nil,\"pattern does not match\"end}function a.match(H)a.expect(1,H,\"string\")return setmetatable({pattern=H},G)end;return setmetatable(a,{__call=function(l,...)return a.expect(...)end})\n\nfilesystem.lua/ 0           0     0     644     4714      `\nlocal a=require\"util\"local b=require\"expect\"local c={}function c.open(d,e)b(1,d,\"string\")b(2,e,\"string\")return a.syscall.open(d,e)end;function c.list(d)b(1,d,\"string\")return a.syscall.list(d)end;function c.stat(d,f)b(1,d,\"string\")b(2,f,\"nil\",\"boolean\")return a.syscall.stat(d,f)end;function c.remove(d)b(1,d,\"string\")return a.syscall.remove(d)end;function c.rename(g,h)b(1,g,\"string\")b(2,h,\"string\")return a.syscall.rename(g,h)end;function c.mkdir(d)b(1,d,\"string\")return a.syscall.mkdir(d)end;function c.link(d,i)b(1,d,\"string\")b(2,i,\"string\")return a.syscall.link(d,i)end;function c.mkfifo(d)b(1,d,\"string\")return a.syscall.mkfifo(d)end;function c.chmod(d,j,e)b(1,d,\"string\")b(2,j,\"string\",\"nil\")b(3,e,\"number\",\"string\",\"table\")if type(e)==\"string\"and not e:match\"^[%+%-=][rwxs]+$\"and not e:match\"^[r%-][w%-][xs%-]$\"then error(\"bad argument #3 (invalid mode)\",2)elseif type(e)==\"table\"then b.field(e,\"read\",\"boolean\",\"nil\")b.field(e,\"write\",\"boolean\",\"nil\")b.field(e,\"execute\",\"boolean\",\"nil\")end;return a.syscall.chmod(d,j,e)end;function c.chown(d,j)b(1,d,\"string\")b(2,j,\"string\")return a.syscall.chown(d,j)end;function c.chroot(d)b(1,d,\"string\")return a.syscall.chroot(d)end;function c.mount(type,k,l,m)b(1,type,\"string\")b(2,k,\"string\")b(3,l,\"string\")b(4,m,\"table\",\"nil\")return a.syscall.mount(type,k,l,m)end;function c.unmount(d)b(1,d,\"string\")return a.syscall.unmount(d)end;function c.mountlist()return a.syscall.mountlist()end;function c.fsevent(d,n)b(1,d,\"string\")b(2,n,\"boolean\",\"nil\")return a.syscall.fsevent(d,n)end;function c.combine(...)return a.syscall.combine(...)end;function c.absolute(d)b(1,d,\"string\")d=c.combine(d)if d:sub(1,1)==\"/\"then return d end;return c.combine(a.syscall.getcwd(),d)end;function c.copy(g,h,o)b(1,g,\"string\")b(2,h,\"string\")local p=assert(c.stat(g),g..\": No such file or directory\")if p.type==\"directory\"then local q=c.list(g)c.mkdir(h)for r,s in ipairs(q)do c.copy(c.combine(g,s),c.combine(h,s))end else local t,u=c.open(g,\"rb\")if not t then error(u,2)end;local v,u=c.open(h,\"wb\")if not v then t.close()error(u,2)end;repeat local w=t.read(512)if w then v.write(w)end until not w;v.close()t.close()end;if o then c.chmod(h,nil,p.worldPermissions)for x,s in pairs(p.permissions)do c.chmod(h,x,s)end;if p.owner then c.chown(h,p.owner)end;if p.setuser then pcall(c.chmod,h,p.owner,\"+s\")end end end;function c.move(g,h)b(1,g,\"string\")b(2,h,\"string\")local y=assert(c.stat(g,true),\"File not found\")local z=c.stat(h)if z then error(\"File already exists\",2)end;local d=c.dirname(h)repeat z,d=c.stat(d),c.dirname(d)until z;if y.type==\"directory\"then local q=c.list(g)c.mkdir(h)for r,s in ipairs(q)do c.move(c.combine(g,s),c.combine(h,s))end elseif y.mountpoint==z.mountpoint then c.rename(g,h)else local t,u=c.open(g,\"rb\")if not t then error(u,2)end;local A=t.readAll()t.close()local v,u=c.open(h,\"wb\")if not v then error(u,2)end;c.remove(g)if A then v.write(A)end;v.close()end;c.chmod(h,nil,y.worldPermissions)for x,s in pairs(y.permissions)do c.chmod(h,x,s)end;if y.owner then c.chown(h,y.owner)end;if y.setuser then pcall(c.chmod,h,y.owner,\"+s\")end end;function c.basename(d)b(1,d,\"string\")return c.combine(d):match\"[^/]+$\"end;function c.dirname(d)b(1,d,\"string\")local B=c.combine(d):match\"^(.*)/[^/]*$\"if B==\"\"or B==nil then if d:sub(1,1)==\"/\"then return\"/\"else return\".\"end else return B end end;local function C(m,D,E)if E>#D then return{}end;local F=\"^\"..D[E]:gsub(\"[%^%$%(%)%%%.%+%-]\",\"%%%1\"):gsub(\"%*\",\".*\"):gsub(\"%?\",\".\"):gsub(\"%[!\",\"[^\")..\"$\"local G={}for r,H in ipairs(m)do local I,J=pcall(c.list,H)if I then for r,d in ipairs(J)do if d:match(F)then G[#G+1]=c.combine(H,d)end end end end;if E+1>#D then return G end;return C(G,D,E+1)end;function c.find(K)b(1,K,\"string\")local L={}for B in K:gmatch(\"[^/]+\")do L[#L+1]=B end;local M=C({K:sub(1,1)==\"/\"and\"/\"or\".\"},L,1)table.sort(M)return M end;function c.exists(d)b(1,d,\"string\")return c.stat(d)~=nil end;function c.isFile(d)b(1,d,\"string\")local N=c.stat(d)if not N then return false end;return N.type==\"file\"end;function c.isDir(d)b(1,d,\"string\")local N=c.stat(d)if not N then return false end;return N.type==\"directory\"end;function c.isLink(d)b(1,d,\"string\")local N=c.stat(d)if not N then return false end;return N.type==\"link\"end;function c.effectivePermissions(O,j)b(1,O,\"string\",\"table\")j=b(2,j,\"number\",\"nil\")or a.syscall.getpid()if type(O)==\"string\"then O=a.syscall.stat(O)if not O then return nil end end;b.field(O,\"permissions\",\"table\")b.field(O,\"worldPermissions\",\"table\")return O.permissions[j]or O.worldPermissions end;local P={}P.type=\"\"P.size=0;P.created=0;P.modified=0;P.owner=\"\"P.permissions={read=false,write=false,execute=false}P.worldPermissions={read=false,write=false,execute=false}P.special={}return c\nframebuffer.lua/0           0     0     644     18227     `\nlocal a=require\"expect\"local b=require\"util\"local c={}c.empty={text={},graphics={}}function c.window(d,e,f,g,h)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,e,\"number\")a(3,f,\"number\")a(4,g,\"number\")a(5,h,\"number\")local i=b.type(d)local j={}function j.close()end;function j.getSize()return g,h end;function j.getPosition()return e,f end;function j.getParent()return d end;function j.getPaletteColor(k)return d.getPaletteColor(k)end;function j.setPaletteColor(k,l,m,n)return d.setPaletteColor(k,l,m,n)end;j.getPaletteColour=j.getPaletteColor;j.setPaletteColour=j.setPaletteColor;function j.reposition(o,p,q,r,s)a(1,o,\"number\",\"nil\")a(2,p,\"number\",\"nil\")a(3,q,\"number\",\"nil\")a(4,r,\"number\",\"nil\")a(5,s,\"nil\",i)e=o or e;f=p or f;g=q or g;h=r or h;d=s or d end;function j.resize(q,r)a(1,q,\"number\",\"nil\")a(2,r,\"number\",\"nil\")g=q or g;h=r or h end;function j.reparent(s)a(1,s,\"nil\",i)d=s or d end;if i==\"Terminal\"then setmetatable(j,{__name=\"Terminal\"})local t,u,v=1,1,d.getCursorBlink()local w,x=d.getTextColor(),d.getBackgroundColor()function j.write(y)a(1,y,\"string\")if u<1 or u>h or t>g or#y==0 then return end;if t<1 then local z=math.min(1-t,#y)t=t+z;if z==#y then return end;y=y:sub(z)end;local z=math.min(g-t+1,#y)d.setCursorPos(e+t-1,f+u-1)d.setTextColor(w)d.setBackgroundColor(x)d.write(y:sub(1,z))t=t+z end;function j.blit(y,A,B)a(1,y,\"string\")a(2,A,\"string\")a(3,B,\"string\")if#y~=#A or#A~=#B then error(\"Arguments must be the same length\",2)end;if u<1 or u>h or t>g or#y==0 then return end;if t<1 then local z=math.min(1-t,#y)t=t+z;if z==#y then return end;y,A,B=y:sub(z),A:sub(z),B:sub(z)end;local z=math.min(g-t+1,#y)d.setCursorPos(e+t-1,f+u-1)d.blit(y:sub(1,z),A:sub(1,z),B:sub(1,z))w,x=d.getTextColor(),d.getBackgroundColor()t=t+z end;function j.clear()d.setTextColor(w)d.setBackgroundColor(x)for C=1,h do d.setCursorPos(e,f+C-1)d.write((\" \"):rep(g))end end;function j.clearLine()d.setTextColor(w)d.setBackgroundColor(x)d.setCursorPos(e,f+u-1)d.write((\" \"):rep(g))end;function j.getCursorPos()return t,u end;function j.setCursorPos(o,p)a(1,o,\"number\")a(2,p,\"number\")t,u=o,p;d.setCursorPos(e+t-1,f+u-1)end;function j.getCursorBlink()return v end;function j.setCursorBlink(D)a(1,D,\"boolean\")v=D;d.setCursorBlink(D)end;function j.isColor()return d.isColor()end;function j.scroll(E)a(1,E,\"number\")if math.abs(E)>=g then return j.clear()elseif E>0 then for F=E+1,h do d.setCursorPos(e,f+F-E-1)d.blit(j.getLine(F))end;for F=h-E+1,h do d.setCursorPos(e,f+F-1)d.setTextColor(w)d.setBackgroundColor(x)d.write((' '):rep(g))end elseif E<0 then for F=1,h+E do d.setCursorPos(e,f+F-E-1)d.blit(j.getLine(F))end;for F=1,-E do d.setCursorPos(e,f+F-1)d.setTextColor(w)d.setBackgroundColor(x)d.write((' '):rep(g))end else return end end;function j.getTextColor()return w end;function j.setTextColor(k)a(1,k,\"number\")w=k;d.setTextColor(k)end;function j.getBackgroundColor()return x end;function j.setBackgroundColor(k)a(1,k,\"number\")x=k;d.setBackgroundColor(k)end;function j.getLine(p)a(1,p,\"number\")local G,H,I=d.getLine(f+p-1)if not G then return nil end;return G:sub(e,e+g-1),H:sub(e,e+g-1),I:sub(e,e+g-1)end;function j.restoreCursor()d.setCursorPos(e+t-1,f+u-1)d.setCursorBlink(v)d.setTextColor(w)end;j.isColour=j.isColor;j.getTextColour=j.getTextColor;j.setTextColour=j.setTextColor;j.getBackgroundColour=j.getBackgroundColor;j.setBackgroundColour=j.setBackgroundColor else setmetatable(j,{__name=\"GFXTerminal\"})function j.clear()d.drawPixels(e,f,15,g,h)end;function j.getPixel(o,p)return d.getPixel(e+o,f+p)end;function j.setPixel(o,p,k)return d.setPixel(e+o,f+p,k)end;function j.getPixels(o,p,J,K,L)return d.getPixels(e+o,f+p,J,K,L)end;function j.drawPixels(o,p,M,J,K)return d.drawPixels(e+o,f+p,M,J,K)end;function j.getFrozen()return d.getFrozen()end;function j.setFrozen(N)return d.setFrozen(N)end end;return j end;function c.framebuffer(d,O,P,q,r,Q,R)local S;if d==c.empty.text or d==c.empty.graphics then O=a(2,O,\"number\",\"nil\")or 1;P=a(3,P,\"number\",\"nil\")or 1;S=d==c.empty.graphics;d=nil else a(1,d,\"Terminal\",\"GFXTerminal\")a(2,O,\"number\")a(3,P,\"number\")S=b.type(d)==\"GFXTerminal\"end;a(4,q,\"number\")a(5,r,\"number\")a(6,Q,\"boolean\",\"nil\")a(6,R,\"boolean\",\"nil\")if Q==nil then Q=true end;local T={width=q,height=r}if S then local U={palette={},dirtyRects={},dirtyPalette={},frozen=false}for f=1,T.height*9 do U[f]=('\\15'):rep(T.width*6)end;if d then for F=0,15 do U.palette[F]={d.getPaletteColor(F)}U.dirtyPalette[F]=true end else U.palette={[0]={0.94117647058824,0.94117647058824,0.94117647058824},{0.94901960784314,0.69803921568627,0.2},{0.89803921568627,0.49803921568627,0.84705882352941},{0.6,0.69803921568627,0.94901960784314},{0.87058823529412,0.87058823529412,0.42352941176471},{0.49803921568627,0.8,0.098039215686275},{0.94901960784314,0.69803921568627,0.8},{0.29803921568627,0.29803921568627,0.29803921568627},{0.6,0.6,0.6},{0.29803921568627,0.6,0.69803921568627},{0.69803921568627,0.4,0.89803921568627},{0.2,0.4,0.8},{0.49803921568627,0.4,0.29803921568627},{0.34117647058824,0.65098039215686,0.30588235294118},{0.8,0.29803921568627,0.29803921568627},{0.066666666666667,0.066666666666667,0.066666666666667}}for F=0,15 do U.dirtyPalette[F]=true end end;for F=16,255 do U.palette[F]={0,0,0}U.dirtyPalette[F]=true end;local j=setmetatable({},{__name=\"GFXTerminal\"})function j.close()end;function j.getSize()return T.width*6,T.height*9 end;function j.clear()for f=1,T.height*9 do U[f]=('\\15'):rep(T.width*6)end;j.redraw(true)end;function j.getPixel(e,f)a(1,e,\"number\")a(2,f,\"number\")a.range(e,0,T.width*6-1)a.range(f,0,T.height*9-1)e,f=math.floor(e),math.floor(f)return U[f+1]:byte(e+1)end;function j.setPixel(e,f,k)a(1,e,\"number\")a(2,f,\"number\")a(3,k,\"number\")a.range(e,0,T.width*6-1)a.range(f,0,T.height*9-1)a.range(k,0,255)e,f=math.floor(e),math.floor(f)U[f+1]=U[f+1]:sub(1,e)..string.char(k)..U[f+1]:sub(e+2)U.dirtyRects[#U.dirtyRects+1]={x=e,y=f,color=k}j.redraw()end;function j.getPixels(e,f,g,h,L)a(1,e,\"number\")a(2,f,\"number\")a(3,g,\"number\")a(4,h,\"number\")a(5,L,\"boolean\",\"nil\")a.range(g,0)a.range(h,0)e,f=math.floor(e),math.floor(f)local V={}for W=1,h do if L then V[W]=U[f+W]:sub(e+1,e+g)else V[W]={U[f+W]:sub(e+1,e+g):byte(1,-1)}end end;return V end;function j.drawPixels(e,f,M,g,h)a(1,e,\"number\")a(2,f,\"number\")a(3,M,\"table\",\"number\")local X=type(M)==\"number\"a(4,g,\"number\",not X and\"nil\"or nil)a(5,h,\"number\",not X and\"nil\"or nil)a.range(e,0,T.width*6-1)a.range(f,0,T.height*9-1)if g then a.range(g,0)end;if h then a.range(h,0)end;if X then a.range(M,0,255)end;if g==0 or h==0 then return end;e,f=math.floor(e),math.floor(f)if g and e+g>=T.width*6 then g=T.width*6-e end;h=h or#M;local Y={x=e,y=f,width=g,height=h}for W=1,h do if f+W>T.height*9 then break end;if X then local Z=string.char(M):rep(g)U[f+W]=U[f+W]:sub(1,e)..Z..U[f+W]:sub(e+g+1)Y[W]=Z elseif M[W]~=nil then if type(M[W])~=\"table\"and type(M[W])~=\"string\"then error(\"bad argument #3 to 'drawPixels' (invalid row \"..W..\")\",2)end;local g=g or#M[W]if e+g>=T.width*6 then g=T.width*6-e end;local Z;if type(M[W])==\"string\"then Z=M[W]if#Z<g then Z=Z..('\\15'):rep(g-#Z)elseif#Z>g then Z=Z:sub(1,g)end else Z=\"\"for _=1,g do Z=Z..string.char(M[W][_]or U[f+W]:byte(e+_))end end;U[f+W]=U[f+W]:sub(1,e)..Z..U[f+W]:sub(e+g+1)Y[W]=Z end end;U.dirtyRects[#U.dirtyRects+1]=Y;j.redraw()end;function j.getFrozen()return U.frozen end;function j.setFrozen(a0)a(1,a0,\"boolean\")U.frozen=a0;j.redraw()end;function j.getPaletteColor(k)a(1,k,\"number\")a.range(k,0,255)return table.unpack(U.palette[k])end;function j.setPaletteColor(k,l,m,n)a(1,k,\"number\")a(2,l,\"number\")if m==nil and n==nil then l,m,n=bit32.band(bit32.rshift(l,16),0xFF)/255,bit32.band(bit32.rshift(l,8),0xFF)/255,bit32.band(l,0xFF)/255 end;a(3,m,\"number\")a(4,n,\"number\")a.range(l,0,1)a.range(m,0,1)a.range(n,0,1)a.range(k,0,255)U.palette[k]={l,m,n}U.dirtyPalette[k]=true;j.redraw()end;function j.getPosition()return O,P end;function j.getParent()return d end;function j.reposition(e,f,q,r,s)a(1,e,\"number\",\"nil\")a(2,f,\"number\",\"nil\")O=e or O;P=f or P;if s then j.reparent(s)end;if q or r then return j.resize(q,r)end end;function j.resize(g,h)a(1,g,\"number\",\"nil\")a(2,h,\"number\",\"nil\")if g>T.width then for f=1,T.height*9 do U[f]=U[f]..('\\15'):rep((g-T.width)*6)end;U.dirtyRects[#U.dirtyRects+1]={x=T.width*6+1,y=1,width=(g-T.width)*6,height=T.height*9}elseif g<T.width then for f=1,T.height*9 do U[f]=U[f]:sub(1,g*6)end end;T.width=g;if h>T.height then for f=T.height*9+1,h*9 do U[f]=('\\15'):rep(g*6)end;U.dirtyRects[#U.dirtyRects+1]={x=1,y=T.height*9+1,width=T.width*6,height=(h-T.height)*9}elseif h<T.height then for f=h*9+1,T.height*9 do U[f]=nil end end;T.height=h end;function j.reparent(s)a(1,s,\"GFXTerminal\",\"nil\")d=s;j.redraw()end;function j.redraw(a1)if not d or not Q then return end;if d.setFrozen then d.setFrozen(true)end;if a1 then d.clear()d.drawPixels(0,0,U)for F=0,255 do d.setPaletteColor(F,U.palette[F][1],U.palette[F][2],U.palette[F][3])end else if U.frozen then if d.setFrozen then d.setFrozen(false)end;return end;for a2,a3 in ipairs(U.dirtyRects)do if a3.color then d.setPixel(a3.x,a3.y,a3.color,a3.width,a3.height)else d.drawPixels(a3.x,a3.y,a3)end end;for F in pairs(U.dirtyPalette)do d.setPaletteColor(F,U.palette[F][1],U.palette[F][2],U.palette[F][3])end end;if d.setFrozen then d.setFrozen(false)end;U.dirtyRects,U.dirtyPalette={},{}end;function j.isVisible()return Q end;function j.setVisible(a3)a(1,a3,\"boolean\")Q=a3;j.redraw()end;j.getPaletteColour=j.getPaletteColor;j.setPaletteColour=j.setPaletteColor;j.redraw()return j else local U={cursor={x=1,y=1},cursorBlink=false,colors={fg='0',bg='f'},palette={},dirtyLines={},dirtyPalette={}}for f=1,T.height do U[f]={(' '):rep(T.width),('0'):rep(T.width),('f'):rep(T.width)}U.dirtyLines[f]=true end;if d then for F=0,15 do U.palette[F]={d.getPaletteColor(F)}U.dirtyPalette[F]=true end else U.palette={[0]={0.94117647058824,0.94117647058824,0.94117647058824},{0.94901960784314,0.69803921568627,0.2},{0.89803921568627,0.49803921568627,0.84705882352941},{0.6,0.69803921568627,0.94901960784314},{0.87058823529412,0.87058823529412,0.42352941176471},{0.49803921568627,0.8,0.098039215686275},{0.94901960784314,0.69803921568627,0.8},{0.29803921568627,0.29803921568627,0.29803921568627},{0.6,0.6,0.6},{0.29803921568627,0.6,0.69803921568627},{0.69803921568627,0.4,0.89803921568627},{0.2,0.4,0.8},{0.49803921568627,0.4,0.29803921568627},{0.34117647058824,0.65098039215686,0.30588235294118},{0.8,0.29803921568627,0.29803921568627},{0.066666666666667,0.066666666666667,0.066666666666667}}for F=0,15 do U.dirtyPalette[F]=true end end;local j=setmetatable({},{__name=\"Terminal\"})function j.close()end;function j.write(y)y=tostring(y)a(1,y,\"string\")if U.cursor.y<1 or U.cursor.y>T.height then return elseif U.cursor.x>T.width or U.cursor.x+#y<1 then U.cursor.x=U.cursor.x+#y;return elseif U.cursor.x<1 then y=y:sub(-U.cursor.x+2)U.cursor.x=1 end;local a4=#y;if U.cursor.x+#y>T.width then y=y:sub(1,T.width-U.cursor.x+1)end;U[U.cursor.y][1]=U[U.cursor.y][1]:sub(1,U.cursor.x-1)..y..U[U.cursor.y][1]:sub(U.cursor.x+#y)U[U.cursor.y][2]=U[U.cursor.y][2]:sub(1,U.cursor.x-1)..U.colors.fg:rep(#y)..U[U.cursor.y][2]:sub(U.cursor.x+#y)U[U.cursor.y][3]=U[U.cursor.y][3]:sub(1,U.cursor.x-1)..U.colors.bg:rep(#y)..U[U.cursor.y][3]:sub(U.cursor.x+#y)U.cursor.x=U.cursor.x+a4;U.dirtyLines[U.cursor.y]=true;j.redraw()end;function j.blit(y,w,x)y=tostring(y)a(1,y,\"string\")a(2,w,\"string\")a(3,x,\"string\")if#y~=#w or#w~=#x then error(\"Arguments must be the same length\",2)end;if U.cursor.y<1 or U.cursor.y>T.height then return elseif U.cursor.x>T.width or U.cursor.x<1-#y then U.cursor.x=U.cursor.x+#y;j.redraw()return elseif U.cursor.x<1 then y,w,x=y:sub(-U.cursor.x+2),w:sub(-U.cursor.x+2),x:sub(-U.cursor.x+2)U.cursor.x=1 end;local a4=#y;if U.cursor.x+#y>T.width then y,w,x=y:sub(1,T.width-U.cursor.x+1),w:sub(1,T.width-U.cursor.x+1),x:sub(1,T.width-U.cursor.x+1)end;U[U.cursor.y][1]=U[U.cursor.y][1]:sub(1,U.cursor.x-1)..y..U[U.cursor.y][1]:sub(U.cursor.x+#y)U[U.cursor.y][2]=U[U.cursor.y][2]:sub(1,U.cursor.x-1)..w..U[U.cursor.y][2]:sub(U.cursor.x+#w)U[U.cursor.y][3]=U[U.cursor.y][3]:sub(1,U.cursor.x-1)..x..U[U.cursor.y][3]:sub(U.cursor.x+#x)U.cursor.x=U.cursor.x+a4;U.dirtyLines[U.cursor.y]=true;j.redraw()end;function j.clear()for f=1,T.height do U[f]={(' '):rep(T.width),U.colors.fg:rep(T.width),U.colors.bg:rep(T.width)}U.dirtyLines[f]=true end;j.redraw()end;function j.clearLine()if U.cursor.y>=1 and U.cursor.y<=T.height then U[U.cursor.y]={(' '):rep(T.width),U.colors.fg:rep(T.width),U.colors.bg:rep(T.width)}U.dirtyLines[U.cursor.y]=true;j.redraw()end end;function j.getCursorPos()return U.cursor.x,U.cursor.y end;function j.setCursorPos(t,u)a(1,t,\"number\")a(2,u,\"number\")if t==U.cursor.x and u==U.cursor.y then return end;U.cursor.x,U.cursor.y=math.floor(t),math.floor(u)j.redraw()end;function j.getCursorBlink()return U.cursorBlink end;function j.setCursorBlink(n)a(1,n,\"boolean\")U.cursorBlink=n;j.redraw()end;function j.isColor()return true end;function j.getSize()return T.width,T.height end;function j.scroll(E)a(1,E,\"number\")if math.abs(E)>=T.width then for f=1,T.height do U[f]={(' '):rep(T.width),U.colors.fg:rep(T.width),U.colors.bg:rep(T.width)}end elseif E>0 then for F=E+1,T.height do U[F-E]=U[F]end;for F=T.height-E+1,T.height do U[F]={(' '):rep(T.width),U.colors.fg:rep(T.width),U.colors.bg:rep(T.width)}end elseif E<0 then for F=1,T.height+E do U[F-E]=U[F]end;for F=1,-E do U[F]={(' '):rep(T.width),U.colors.fg:rep(T.width),U.colors.bg:rep(T.width)}end else return end;for F=1,T.height do U.dirtyLines[F]=true end;j.redraw()end;function j.getTextColor()return tonumber(U.colors.fg,16)end;function j.setTextColor(k)a(1,k,\"number\")a.range(k,0,15)U.colors.fg=(\"%x\"):format(math.floor(k))end;function j.getBackgroundColor()return tonumber(U.colors.bg,16)end;function j.setBackgroundColor(k)a(1,k,\"number\")a.range(k,0,15)U.colors.bg=(\"%x\"):format(math.floor(k))end;function j.getPaletteColor(k)a(1,k,\"number\")a.range(k,0,15)return table.unpack(U.palette[math.floor(k)])end;function j.setPaletteColor(k,l,m,n)a(1,k,\"number\")a(2,l,\"number\")if m==nil and n==nil then l,m,n=bit32.band(bit32.rshift(l,16),0xFF)/255,bit32.band(bit32.rshift(l,8),0xFF)/255,bit32.band(l,0xFF)/255 end;a(3,m,\"number\")a(4,n,\"number\")a.range(k,0,15)if l<0 or l>1 then error(\"bad argument #2 (value out of range)\",2)end;if m<0 or m>1 then error(\"bad argument #3 (value out of range)\",2)end;if n<0 or n>1 then error(\"bad argument #4 (value out of range)\",2)end;U.palette[math.floor(k)]={l,m,n}U.dirtyPalette[math.floor(k)]=true;j.redraw()end;function j.getLine(f)a(1,f,\"number\")local a5=U[f]if a5 then return table.unpack(a5,1,3)end end;function j.getPosition()return O,P end;function j.getParent()return d end;function j.reposition(e,f,q,r,s)a(1,e,\"number\",\"nil\")a(2,f,\"number\",\"nil\")O=e or O;P=f or P;if s then j.reparent(s)end;if e or f then j.redraw(true)end;if q or r then return j.resize(q,r)end end;function j.resize(g,h)a(1,g,\"number\",\"nil\")a(2,h,\"number\",\"nil\")if g>T.width then for f=1,T.height do U[f][1]=U[f][1]..(' '):rep(g-T.width)U[f][2]=U[f][2]..U.colors.fg:rep(g-T.width)U[f][3]=U[f][3]..U.colors.bg:rep(g-T.width)U.dirtyLines[f]=true end elseif g<T.width then for f=1,T.height do U[f][1]=U[f][1]:sub(1,g)U[f][2]=U[f][2]:sub(1,g)U[f][3]=U[f][3]:sub(1,g)end end;T.width=g;if h>T.height then for f=T.height+1,h do U[f]={(' '):rep(g),U.colors.fg:rep(g),U.colors.bg:rep(g)}U.dirtyLines[f]=true end elseif h<T.height then for f=h+1,T.height do U[f]=nil end end;T.height=h end;function j.reparent(s)a(1,s,\"Terminal\",\"nil\")d=s;j.redraw()end;function j.redraw(a1)if not d or not Q then return end;d.setCursorBlink(false)if a1 then for f=1,T.height do d.setCursorPos(O,P+f-1)if R and(U[f][2]:find(\"[! ]\")or U[f][3]:find(\"[! ]\"))then local a6,a7,a8=d.getLine(P+f-1)if a6 then a6,a7,a8=a6:sub(math.max(O,1),math.max(O+T.width-1,1)),a7:sub(math.max(O,1),math.max(O+T.width-1,1)),a8:sub(math.max(O,1),math.max(O+T.width-1,1))if O<1 then local a9=(\" \"):rep(1-O)a6,a7,a8=a9 ..a6,a9 ..a7,a9 ..a8 end;if#a6<#U[f][1]then local a9=(\" \"):rep(#U[f][1]-#a6)a6,a7,a8=a6 ..a9,a7 ..a9,a8 ..a9 end;local y=U[f][1]:gsub(\"()\\0\",function(aa)return a6:sub(aa,aa)end)local w=U[f][2]:gsub(\"() \",function(aa)return a7:sub(aa,aa)end):gsub(\"()!\",function(aa)return a8:sub(aa,aa)end)local x=U[f][3]:gsub(\"() \",function(aa)return a8:sub(aa,aa)end):gsub(\"()!\",function(aa)return a7:sub(aa,aa)end)d.blit(y,w,x)end else d.blit(U[f][1],U[f][2],U[f][3])end end;for F=0,15 do d.setPaletteColor(F,U.palette[F][1],U.palette[F][2],U.palette[F][3])end else for f in pairs(U.dirtyLines)do d.setCursorPos(O,P+f-1)if#U[f][1]~=#U[f][2]or#U[f][2]~=#U[f][3]then error(debug.traceback(\"Internal error: Invalid lengths\"),2)end;if R and(U[f][2]:find(\"[! ]\")or U[f][3]:find(\"[! ]\"))then local a6,a7,a8=d.getLine(P+f-1)if a6 then a6,a7,a8=a6:sub(math.max(O,1),math.max(O+T.width-1,1)),a7:sub(math.max(O,1),math.max(O+T.width-1,1)),a8:sub(math.max(O,1),math.max(O+T.width-1,1))if O<1 then local a9=(\" \"):rep(1-O)a6,a7,a8=a9 ..a6,a9 ..a7,a9 ..a8 end;if#a6<#U[f][1]then local a9=(\" \"):rep(#U[f][1]-#a6)a6,a7,a8=a6 ..a9,a7 ..a9,a8 ..a9 end;local y=U[f][1]:gsub(\"()\\0\",function(aa)return a6:sub(aa,aa)or\"\\0\"end)local w=U[f][2]:gsub(\"() \",function(aa)return a7:sub(aa,aa)end):gsub(\"()!\",function(aa)return a8:sub(aa,aa)end)local x=U[f][3]:gsub(\"() \",function(aa)return a8:sub(aa,aa)end):gsub(\"()!\",function(aa)return a7:sub(aa,aa)end)d.blit(y,w,x)end else d.blit(U[f][1],U[f][2],U[f][3])end end;for F in pairs(U.dirtyPalette)do d.setPaletteColor(F,U.palette[F][1],U.palette[F][2],U.palette[F][3])end end;d.setCursorPos(O+U.cursor.x-1,P+U.cursor.y-1)d.setCursorBlink(U.cursorBlink)d.setTextColor(j.getTextColor())U.dirtyLines,U.dirtyPalette={},{}end;function j.restoreCursor()if not d or not Q then return end;d.setCursorPos(O+U.cursor.x-1,P+U.cursor.y-1)d.setCursorBlink(U.cursorBlink)d.setTextColor(j.getTextColor())end;function j.isVisible()return Q end;function j.setVisible(a3,l)a(1,a3,\"boolean\")Q=a3;if a3 and l~=false then j.redraw()end end;j.isColour=j.isColor;j.getTextColour=j.getTextColor;j.setTextColour=j.setTextColor;j.getBackgroundColour=j.getBackgroundColor;j.setBackgroundColour=j.setBackgroundColor;j.getPaletteColour=j.getPaletteColor;j.setPaletteColour=j.setPaletteColor;j.redraw()return j end end;return c\n\ngraphics.lua/   0           0     0     644     6669      `\nlocal a=require\"expect\"local b=require\"util\"local c={}function c.drawPixel(d,e,f,g)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,e,\"number\")a(3,f,\"number\")a(4,g,\"number\")if b.type(d)==\"Terminal\"then local h,i=d.getCursorPos()local j=d.getBackgroundColor()d.setCursorPos(e,f)d.setBackgroundColor(g)d.write(\" \")d.setCursorPos(h,i)d.setBackgroundColor(j)else d.setPixel(e-1,f-1,g)end end;local function k(l,m,n,o,p)if math.abs(p-n)<math.abs(o-m)then if m>o then m,n,o,p=o,p,m,n end;local q,r,s=o-m,p-n,1;if r<0 then s,r=-1,-r end;local t,f=2*r-q,n;if s<0 then f=p;for e=o,m,-1 do l(e,f)if t>0 then f=f+1;t=t+2*(r-q)else t=t+2*r end end else for e=m,o do l(e,f)if t>0 then f=f+1;t=t+2*(r-q)else t=t+2*r end end end else if n>p then m,n,o,p=o,p,m,n end;local q,r,u=o-m,p-n,1;if q<0 then u,q=-1,-q end;local t,e=2*q-r,m;for f=n,p do l(e,f)if t>0 then e=e+u;t=t+2*(q-r)else t=t+2*q end end end end;function c.drawLine(d,m,n,o,p,g)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,m,\"number\")a(3,n,\"number\")a(4,o,\"number\")a(5,p,\"number\")a(6,g,\"number\")if n==p then local v=math.abs(o-m)+1;if b.type(d)==\"Terminal\"then local w,x=d.getBackgroundColor(),d.getTextColor()local h,i=d.getCursorPos()local y,z=(\"%x\"):format(x),(\"%x\"):format(g)d.setCursorPos(m,n)d.blit((\" \"):rep(v),y:rep(v),z:rep(v))d.setCursorPos(h,i)d.setBackgroundColor(w)else d.drawPixels(m-1,n-1,g,v,1)end;return elseif m==o and b.type(d)==\"GFXTerminal\"then d.drawPixels(m-1,n-1,g,1,math.abs(p-n)+1)end;local l,A;if b.type(d)==\"Terminal\"then local j=d.getBackgroundColor()local h,i=d.getCursorPos()d.setBackgroundColor(g)l,A=function(e,f)d.setCursorPos(e,f)d.write(\" \")end,function()d.setBackgroundColor(j)d.setCursorPos(h,i)end else l,A=function(e,f)d.setPixel(e-1,f-1,g)end,function()end end;k(l,m,n,o,p)A()end;function c.drawBox(d,e,f,v,B,g)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,e,\"number\")a(3,f,\"number\")a(4,v,\"number\")a(5,B,\"number\")a(6,g,\"number\")if b.type(d)==\"Terminal\"then local w,x=d.getBackgroundColor(),d.getTextColor()local h,i=d.getCursorPos()local y,z=(\"%x\"):format(x),(\"%x\"):format(g)d.setCursorPos(e,f)d.blit((\" \"):rep(v),y:rep(v),z:rep(v))d.setCursorPos(e,f+B-1)d.blit((\" \"):rep(v),y:rep(v),z:rep(v))for C=f+1,f+B-2 do d.setCursorPos(e,C)d.blit(\" \",y,z)d.setCursorPos(e+v-1,C)d.blit(\" \",y,z)end;d.setBackgroundColor(w)d.setCursorPos(h,i)else d.drawPixels(e-1,f-1,g,v,1)d.drawPixels(e-1,f-1,g,1,B)d.drawPixels(e-1,f+B-1,g,v,1)d.drawPixels(e+v-1,f-1,g,1,B)end end;function c.drawFilledBox(d,e,f,v,B,g)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,e,\"number\")a(3,f,\"number\")a(4,v,\"number\")a(5,B,\"number\")a(6,g,\"number\")if b.type(d)==\"Terminal\"then a.range(g,0,15)local w,x=d.getBackgroundColor(),d.getTextColor()local h,i=d.getCursorPos()local D,y,z=(\" \"):rep(v),(\"%x\"):format(x):rep(v),(\"%x\"):format(g):rep(v)for C=f,f+B-1 do d.setCursorPos(e,C)d.blit(D,y,z)end;d.setBackgroundColor(w)d.setCursorPos(h,i)else a.range(g,0,255)d.drawPixels(e-1,f-1,g,v,B)end end;function c.drawCircle(d,e,f,v,B,g,E,F)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,e,\"number\")a(3,f,\"number\")a(4,v,\"number\")a(5,B,\"number\")a(6,g,\"number\")E=(a(7,E,\"number\",\"nil\")or 0)%(2*math.pi)F=(a(8,F,\"number\",\"nil\")or 0)%(2*math.pi)if F==0 then F=2*math.pi end;local l,A;if b.type(d)==\"Terminal\"then local j=d.getBackgroundColor()local h,i=d.getCursorPos()d.setBackgroundColor(g)l,A=function(G,C)d.setCursorPos(G,C)d.write(\" \")end,function()d.setBackgroundColor(j)d.setCursorPos(h,i)end else l,A=function(G,C)d.setPixel(G-1,C-1,g)end,function()end end;local H=math.pi/(v+B)v,B=v/2,B/2;for I=E,E+F,H do local G,C=v*math.cos(I)+v,B*math.sin(I)+B;l(e+G,f+C)end;A()end;function c.drawFilledTriangle(d,m,n,o,p,J,K,g)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,m,\"number\")a(3,n,\"number\")a(4,o,\"number\")a(5,p,\"number\")a(6,J,\"number\")a(7,K,\"number\")a(8,g,\"number\")local L,A;if b.type(d)==\"Terminal\"then local w,x=d.getBackgroundColor(),d.getTextColor()local h,i=d.getCursorPos()local z,y=(\"%x\"):format(g),(\"%x\"):format(x)L,A=function(G,C,M)d.setCursorPos(G,C)d.blit((\" \"):rep(M),y:rep(M),z:rep(M))end,function()d.setBackgroundColor(w)d.setTextColor(x)d.setCursorPos(h,i)end else L,A=function(G,C,M)d.drawPixels(G-1,C-1,g,M,1)end,function()end end;local N={{x=m,y=n},{x=o,y=p},{x=J,y=K}}table.sort(N,function(O,w)return O.y<w.y end)if N[1].y==N[2].y then if N[2].y==N[3].y then local q=math.min(N[1].x,N[2].x,N[3].x)L(q,N[1].y,math.max(N[1].x,N[2].x,N[3].x)-q)A()return end;if N[1].x>N[2].x then N[1],N[2]=N[2],N[1]end;local P,Q=coroutine.create(k),coroutine.create(k)local R,S,T=coroutine.resume(P,coroutine.yield,N[1].x,N[1].y,N[3].x,N[3].y)local R,U,V=coroutine.resume(Q,coroutine.yield,N[2].x,N[2].y,N[3].x,N[3].y)local W,X=S,U;while V do repeat W=math.min(W,S)R,S,T=coroutine.resume(P)until T~=V;repeat X=math.max(X,U)R,U,T=coroutine.resume(Q)until T~=V;L(W,V,X-W+1)W,X,V=S,U,T end elseif N[2].y==N[3].y then if N[2].x>N[3].x then N[2],N[3]=N[3],N[2]end;local P,Q=coroutine.create(k),coroutine.create(k)local R,S,T=coroutine.resume(P,coroutine.yield,N[1].x,N[1].y,N[2].x,N[2].y)local R,U,V=coroutine.resume(Q,coroutine.yield,N[1].x,N[1].y,N[3].x,N[3].y)local W,X=S,U;while V do repeat W=math.min(W,S)R,S,T=coroutine.resume(P)until T~=V;repeat X=math.max(X,U)R,U,T=coroutine.resume(Q)until T~=V;L(W,V,X-W+1)W,X,V=S,U,T end else local P,Q=coroutine.create(k),coroutine.create(k)local R,S,T=coroutine.resume(P,coroutine.yield,N[1].x,N[1].y,N[3].x,N[3].y)local R,U,V=coroutine.resume(Q,coroutine.yield,N[1].x,N[1].y,N[2].x,N[2].y)local W,X=S,U;while S and U and V do repeat W=math.min(W,S)X=math.max(X,S)R,S,T=coroutine.resume(P)until T~=V;if V==N[2].y then Q=coroutine.create(k)R,U,T=coroutine.resume(Q,coroutine.yield,N[2].x,N[2].y,N[3].x,N[3].y)end;repeat W=math.min(W,U)X=math.max(X,U)R,U,T=coroutine.resume(Q)until T~=V;L(W,V,X-W+1)W,X,V=math.min(S or 0,U or 0),math.max(S or 0,U or 0),T end end;A()end;function c.drawImage(d,e,f,Y)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,e,\"number\")a(3,f,\"number\")a(4,Y,\"table\")if b.type(d)==\"Terminal\"then local w,x=d.getBackgroundColor(),d.getTextColor()local h,i=d.getCursorPos()local y=(\"%x\"):format(x)for C=1,#Y do a.field(Y,C,\"string\",\"table\")d.setCursorPos(e,f+C-1)local L=Y[C]if type(L)==\"string\"then local z=L:gsub(\"[\\16-\\255]\",\" \"):gsub(\"[%z-\\15]\",function(j)return(\"%x\"):format(j:byte())end)d.blit((\" \"):rep(#z),y:rep(#z),z)elseif#L==3 and type(L[1]==\"string\")then d.blit(L[1],L[2],L[3])else local z=\"\"for Z=1,#L do a(L,Z,\"number\")z=z..(\"%x\"):format(L[Z])end;d.blit((\" \"):rep(#z),y:rep(#z),z)end end;d.setBackgroundColor(w)d.setTextColor(x)d.setCursorPos(h,i)else if type(Y[1])==\"table\"and type(Y[1][1])==\"string\"then error(\"bad argument #4 to 'drawImage' (image type not supported on this terminal)\",2)end;return d.drawPixels(e-1,f-1,Y)end end;return c\n\nhardware.lua/   0           0     0     644     3104      `\nlocal a=require\"expect\"local b=require\"util\"local c={}function c.wrap(d)a(1,d,\"string\",\"device\",\"devicetree\")if type(d)~=\"string\"then d=getmetatable(d).uuid end;local e=b.syscall.devinfo(d)if not e then return nil end;local f,g=b.syscall.devmethods(d),b.syscall.devproperties(d)for h,i in ipairs(g)do g[i]=true end;local j={}for h,i in ipairs(f)do j[i]=function(self,...)return b.syscall.devcall(d,i,...)end end;return setmetatable(j,{__name=\"device\",uuid=e.uuid,__index=function(self,k)if type(k)==\"string\"and g[k]then return b.syscall.devcall(d,\"get\"..k:gsub(\"^.\",string.upper))end end,__newindex=function(self,k,l)if type(k)==\"string\"and g[k]and self[\"set\"..k:gsub(\"^.\",string.upper)]then return b.syscall.devcall(d,\"set\"..k:gsub(\"^.\",string.upper),l)end end,__tostring=function(self)return\"wrapped device: \"..(e.displayName or e.uuid)end})end;function c.find(type)a(1,type,\"string\")local j={}for m,i in ipairs{b.syscall.devfind(type)}do j[m]=c.wrap(i)end;return table.unpack(j)end;function c.path(d)a(1,d,\"string\",\"device\",\"devicetree\")if type(d)==\"string\"then return b.syscall.devlookup(d)else return b.syscall.devlookup(getmetatable(d).uuid)end end;function c.hasType(d,n)a(1,d,\"string\",\"device\",\"devicetree\")a(2,n,\"string\")local e;if type(d)==\"string\"then e=b.syscall.devinfo(d)else e=b.syscall.devinfo(getmetatable(d).uuid)end;if not e then error(\"No such device\",2)end;return e.types[n]~=nil end;function c.info(d)a(1,d,\"string\",\"device\",\"devicetree\")if type(d)==\"string\"then return b.syscall.devinfo(d)else return b.syscall.devinfo(getmetatable(d).uuid)end end;function c.methods(d)a(1,d,\"string\",\"device\",\"devicetree\")if type(d)==\"string\"then return b.syscall.devmethods(d)else return b.syscall.devmethods(getmetatable(d).uuid)end end;function c.properties(d)a(1,d,\"string\",\"device\",\"devicetree\")if type(d)==\"string\"then return b.syscall.devproperties(d)else return b.syscall.devproperties(getmetatable(d).uuid)end end;function c.children(d)a(1,d,\"string\",\"device\",\"devicetree\")if type(d)==\"string\"then return b.syscall.devchildren(d)else return b.syscall.devchildren(getmetatable(d).uuid)end end;function c.call(d,o,...)a(1,d,\"string\",\"device\",\"devicetree\")a(2,o,\"string\")if type(d)==\"string\"then return b.syscall.devcall(d,o,...)else return b.syscall.devcall(getmetatable(d).uuid,o,...)end end;function c.listen(d,p)a(1,d,\"string\",\"device\",\"devicetree\")a(2,p,\"boolean\",\"nil\")if type(d)==\"string\"then return b.syscall.devlisten(d,p)else return b.syscall.devlisten(getmetatable(d).uuid,p)end end;function c.lock(d,q)a(1,d,\"string\",\"device\",\"devicetree\")a(2,q,\"boolean\",\"nil\")if type(d)==\"string\"then return b.syscall.devlock(d,q)else return b.syscall.devlock(getmetatable(d).uuid,q)end end;function c.unlock(d)a(1,d,\"string\",\"device\",\"devicetree\")if type(d)==\"string\"then return b.syscall.devunlock(d)else return b.syscall.devunlock(getmetatable(d).uuid)end end;local function r(s)local e=c.info(s or\"/\")if not e then return nil end;s=s or\"\"return setmetatable({},{__name=\"devicetree\",uuid=e.uuid,__index=function(self,k)return r(s..\"/\"..k)end,__newindex=function()end})end;c.tree=r()return c\ninit.lua/       0           0     0     644     341       `\nreturn{expect=require\"expect\",filesystem=require\"filesystem\",framebuffer=require\"framebuffer\",graphics=require\"graphics\",hardware=require\"hardware\",keys=require\"keys\",log=require\"log\",network=require\"network\",pretty=require\"pretty\",process=require\"process\",serialization=require\"serialization\",terminal=require\"terminal\",util=require\"util\"}\n\nipc.lua/        0           0     0     644     1133      `\nlocal a=require\"expect\"local b=require\"util\"local c={}c.signal={SIGHUP=1,SIGINT=2,SIGQUIT=3,SIGTRAP=5,SIGABRT=6,SIGKILL=9,SIGPIPE=13,SIGTERM=15,SIGCONT=18,SIGSTOP=19,SIGTTIN=21,SIGTTOU=22}function c.kill(d,e)a(1,d,\"number\")a(2,e,\"number\")return b.syscall.kill(d,e)end;function c.sigaction(e,f)a(1,e,\"number\")a(2,f,\"function\",\"nil\")return b.syscall.signal(e,f)end;function c.sendEvent(d,g,h)a(1,d,\"number\")a(2,g,\"string\")a(3,h,\"table\")return b.syscall.sendEvent(d,g,h)end;function c.register(i)a(1,i,\"string\")return b.syscall.register(i)end;function c.lookup(i)a(1,i,\"string\")return b.syscall.lookup(i)end;function c.sendServiceEvent(i,g,h)a(1,i,\"string\")a(2,g,\"string\")a(3,h,\"table\")local d=b.syscall.lookup(i)if not d then return false end;return b.syscall.sendEvent(d,g,h)end;function c.receiveEvent(d,g,j)a(1,d,\"number\",\"nil\")a(2,g,\"string\",\"nil\")a(3,j,\"number\",\"nil\")local k;if j then k=b.timer(j)end;while true do local l,h=coroutine.yield()if l==\"timer\"and h.id==k then return nil elseif l==\"remote_event\"and(d==nil or d==h.sender)and(g==nil or g==h.type)then if k then b.cancel(k)end;return h.type,h.data end end end;return c\n\nkeys.lua/       0           0     0     644     1542      `\nlocal a={}for b=0x61,0x7A do a[string.char(b)]=b end;for b=0x81,0x99 do a[\"f\"..bit32.band(b,31)]=b end;for b=0xA0,0xA9 do a[\"numPad\"..bit32.band(b,15)]=b end;a.backspace=0x08;a.tab=0x09;a.enter=0x0A;a.space=0x20;a.apostrophe=0x27;a.comma=0x2C;a.minus=0x2D;a.period=0x2E;a.slash=0x2F;a.zero=0x30;a.one=0x31;a.two=0x32;a.three=0x33;a.four=0x34;a.five=0x35;a.six=0x36;a.seven=0x37;a.eight=0x38;a.nine=0x39;a.semicolon=0x3B;a.equals=0x3D;a.leftBracket=0x5B;a.backslash=0x5C;a.rightBracket=0x5D;a.grave=0x60;a.delete=0x7F;a.insert=0x80;a.convert=0x9A;a.noconvert=0x9B;a.kana=0x9C;a.kanji=0x9D;a.yen=0x9E;a.numPadDecimal=0x9F;a.numPadAdd=0xAA;a.numPadSubtract=0xAB;a.numPadMultiply=0xAC;a.numPadDivide=0xAD;a.numPadEqual=0xAE;a.numPadEnter=0xAF;a.leftCtrl=0xB0;a.rightCtrl=0xB1;a.leftAlt=0xB2;a.rightAlt=0xB3;a.leftShift=0xB4;a.rightShift=0xB5;a.leftSuper=0xB6;a.rightSuper=0xB7;a.capsLock=0xB8;a.numLock=0xB9;a.scrollLock=0xBA;a.printScreen=0xBB;a.pause=0xBC;a.menu=0xBD;a.stop=0xBE;a.ax=0xBF;a.up=0xC0;a.down=0xC1;a.left=0xC2;a.right=0xC3;a.pageUp=0xC4;a.pageDown=0xC5;a.home=0xC6;a[\"end\"]=0xC7;a.circumflex=0xC8;a.at=0xC9;a.colon=0xCA;a.underscore=0xCB;local c={}for d,e in pairs(a)do c[e]=d end;function a.getName(f)if type(f)~=\"number\"then error(\"bad argument #1 (expected number, got \"..type(f)..\")\",2)end;return c[f]end;function a.getCharacter(f)if type(f)~=\"number\"then error(\"bad argument #1 (expected number, got \"..type(f)..\")\",2)end;if f>=0x20 and f<0x7F or f==0x0A or f==0x09 then return string.char(f)else return nil end end;return a\nlog.lua/        0           0     0     644     2163      `\nlocal a=require\"expect\"local b=require\"util\"local function c(self,...)return self.log(...)end;local d={debug=0,info=1,notice=2,warning=3,error=4,critical=5}local function e(f)local g={}function g.log(h,...)if type(h)==\"table\"then h.name=f;return b.syscall.syslog(h,...)else return b.syscall.syslog({name=f},h,...)end end;function g.debug(h,...)if type(h)==\"table\"then h.name=f;h.level=d.debug;return b.syscall.syslog(h,...)else return b.syscall.syslog({name=f,level=d.debug},h,...)end end;function g.info(h,...)if type(h)==\"table\"then h.name=f;h.level=d.info;return b.syscall.syslog(h,...)else return b.syscall.syslog({name=f,level=d.info},h,...)end end;function g.notice(h,...)if type(h)==\"table\"then h.name=f;h.level=d.notice;return b.syscall.syslog(h,...)else return b.syscall.syslog({name=f,level=d.notice},h,...)end end;function g.warning(h,...)if type(h)==\"table\"then h.name=f;h.level=d.warning;return b.syscall.syslog(h,...)else return b.syscall.syslog({name=f,level=d.warning},h,...)end end;g.warn=g.warning;function g.error(h,...)if type(h)==\"table\"then h.name=f;h.level=d.error;return b.syscall.syslog(h,...)else return b.syscall.syslog({name=f,level=d.error},h,...)end end;function g.critical(h,...)if type(h)==\"table\"then h.name=f;h.level=d.critical;return b.syscall.syslog(h,...)else return b.syscall.syslog({name=f,level=d.critical},h,...)end end;function g.traceback(i)a(1,i,\"string\",\"nil\")return b.syscall.syslog({name=f,level=d.error,traceback=true},debug.traceback(i,2))end;return setmetatable(g,{__call=c})end;local g=e()g.levels={debug=0,info=1,notice=2,warning=3,error=4,critical=5}function g.create(f,j,k)a(1,f,\"string\")a(2,j,\"boolean\",\"nil\")a(3,k,\"string\",\"nil\")b.syscall.mklog(f,j,k)return e(f)end;function g.remove(f)a(1,f,\"string\")return b.syscall.rmlog(f)end;function g.open(f,l)a(1,f,\"string\")a(2,l,\"string\",\"nil\")return b.syscall.openlog(f,l)end;function g.close(f)a(1,f,\"string\",\"number\")return b.syscall.closelog(f)end;function g.setTTY(f,m,n)a(1,f,\"string\")a(2,m,\"table\",\"nil\")a(3,n,\"number\",\"nil\")return b.syscall.logtty(f,m,n)end;return setmetatable(g,{__call=c,__index=function(o,p)if type(p)==\"string\"then return e(p)end end})\n\nnetwork.lua/    0           0     0     644     6370      `\nlocal a=require\"util\"local b=require\"expect\"local c={route={},arp={}}function c.parseURI(d)local e={scheme=\"\"}for f in d:gmatch\".\"do if e.fragment then if f:match\"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/?]\"then e.fragment=e.fragment..f else error(\"Invalid URI\",3)end elseif e.query then if f==\"#\"then e.fragment=\"\"elseif f:match\"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/?]\"then e.query=e.query..f else error(\"Invalid URI\",3)end elseif e.path then if f==\"/\"and e.path==\"/\"and not e.host then e.path,e.host=nil,\"\"elseif f==\"?\"then e.query=\"\"elseif f==\"#\"then e.fragment=\"\"elseif f:match\"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/]\"then e.path=e.path..f else error(\"Invalid URI\",3)end elseif e.port then if tonumber(f)then e.port=e.port..f elseif f==\"/\"then e.path=\"/\"else error(\"Invalid URI\",3)end elseif e.host then if f==\"@\"and not e.user then e.user,e.host=e.host,\"\"elseif f==\":\"then e.port=\"\"elseif f==\"/\"then e.path=\"/\"elseif f:match\"[%w%-%._~%%/!%$&'%(%)%*%+,;=]\"then e.host=e.host..f else error(\"Invalid URI\",3)end else if f==\":\"then e.path=\"\"elseif f:match(e.scheme==\"\"and\"[%a%+%-%.]\"or\"[%w%+%-%.]\")then e.scheme=e.scheme..f else error(\"Invalid URI\",3)end end end;if e.port then e.port=tonumber(e.port)end;return e end;function c.connect(g)b(1,g,\"table\",\"string\")if type(g)==\"table\"then b.field(g,\"url\",\"string\")end;return a.syscall.connect(g)end;function c.get(g)b(1,g,\"table\",\"string\")if type(g)==\"table\"then b.field(g,\"url\",\"string\")if not g.url:match(\"^https?://\")then error(\"Invalid scheme\",2)end elseif not g:match(\"^https?://\")then error(\"Invalid scheme\",2)end;local h=a.syscall.connect(g)h:write()while true do local i,j=coroutine.yield()if i==\"handle_status_change\"and j.id==h.id then if j.status==\"open\"then return h elseif j.status==\"error\"then return nil,select(2,h:status())end end end end;function c.getData(k,l)b(1,k,\"string\")b(2,l,\"table\",\"nil\")if not k:match(\"^https?://\")then error(\"Invalid scheme\",2)end;local h=a.syscall.connect{url=k,encoding=\"binary\",headers=l}h:write()while true do local i,j=coroutine.yield()if i==\"handle_status_change\"and j.id==h.id then if j.status==\"open\"then local m=h:read(\"*a\")local n=h:responseCode()h:close()return m,n elseif j.status==\"error\"then return nil,select(2,h:status())end end end end;function c.head(g)b(1,g,\"table\",\"string\")if type(g)==\"table\"then b.field(g,\"url\",\"string\")if not g.url:match(\"^https?://\")then error(\"Invalid scheme\",2)end else if not g:match(\"^https?://\")then error(\"Invalid scheme\",2)end;g={url=g}end;g.method=\"HEAD\"local h=a.syscall.connect(g)h:write()while true do local i,j=coroutine.yield()if i==\"handle_status_change\"and j.id==h.id then if j.status==\"open\"then return h elseif j.status==\"error\"then return nil,select(2,h:status())end end end end;function c.options(g)b(1,g,\"table\",\"string\")if type(g)==\"table\"then b.field(g,\"url\",\"string\")if not g.url:match(\"^https?://\")then error(\"Invalid scheme\",2)end else if not g:match(\"^https?://\")then error(\"Invalid scheme\",2)end;g={url=g}end;g.method=\"OPTIONS\"local h=a.syscall.connect(g)h:write()while true do local i,j=coroutine.yield()if i==\"handle_status_change\"and j.id==h.id then if j.status==\"open\"then return h elseif j.status==\"error\"then return nil,select(2,h:status())end end end end;function c.post(g,m)b(1,g,\"table\",\"string\")b(2,m,\"string\")if type(g)==\"table\"then b.field(g,\"url\",\"string\")if not g.url:match(\"^https?://\")then error(\"Invalid scheme\",2)end else if not g:match(\"^https?://\")then error(\"Invalid scheme\",2)end;g={url=g}end;g.method=\"POST\"local h=a.syscall.connect(g)h:write(m)while true do local i,j=coroutine.yield()if i==\"handle_status_change\"and j.id==h.id then if j.status==\"open\"then return h elseif j.status==\"error\"then return nil,select(2,h:status())end end end end;function c.put(g,m)b(1,g,\"table\",\"string\")b(2,m,\"string\")if type(g)==\"table\"then b.field(g,\"url\",\"string\")if not g.url:match(\"^https?://\")then error(\"Invalid scheme\",2)end else if not g:match(\"^https?://\")then error(\"Invalid scheme\",2)end;g={url=g}end;g.method=\"PUT\"local h=a.syscall.connect(g)h:write(m)while true do local i,j=coroutine.yield()if i==\"handle_status_change\"and j.id==h.id then if j.status==\"open\"then return h elseif j.status==\"error\"then return nil,select(2,h:status())end end end end;function c.delete(g,m)b(1,g,\"table\",\"string\")b(2,m,\"string\",\"nil\")if type(g)==\"table\"then b.field(g,\"url\",\"string\")if not g.url:match(\"^https?://\")then error(\"Invalid scheme\",2)end else if not g:match(\"^https?://\")then error(\"Invalid scheme\",2)end;g={url=g}end;g.method=\"DELETE\"local h=a.syscall.connect(g)h:write(m)while true do local i,j=coroutine.yield()if i==\"handle_status_change\"and j.id==h.id then if j.status==\"open\"then return h elseif j.status==\"error\"then return nil,select(2,h:status())end end end end;function c.listen(d)b(1,d,\"string\")return a.syscall.listen(d)end;function c.unlisten(d)b(1,d,\"string\")return a.syscall.unlisten(d)end;function c.ipconfig(o,e)b(1,o,\"string\",\"table\")b(2,e,\"table\",\"nil\")if e then b.field(e,\"ip\",\"string\",\"number\",\"nil\")b.field(e,\"netmask\",\"string\",\"number\",\"nil\")b.field(e,\"up\",\"boolean\",\"nil\")end;return a.syscall.ipconfig(o,e)end;function c.route.list(p)b(1,p,\"number\",\"nil\")return a.syscall.routelist(p)end;function c.route.add(g)b(1,g,\"table\")b.field(g,\"table\",\"number\",\"nil\")b.field(g,\"source\",\"string\")b.field(g,\"sourceNetmask\",\"number\")b.field(g,\"action\",\"string\")b.field(g,\"device\",\"string\",not(g.action==\"local\"or g.action==\"unicast\"or g.action==\"broadcast\")and\"nil\"or nil)b.field(g,\"destination\",\"string\",g.action~=\"unicast\"and\"nil\"or nil)return a.syscall.routeadd(g)end;function c.route.remove(q,r,p)b(1,q,\"string\")b(2,r,\"number\")b(3,p,\"number\",\"nil\")return a.syscall.routedel(q,r,p)end;function c.arp.list(o)b(1,o,\"string\")return a.syscall.arplist(o)end;function c.arp.set(o,s,t)b(1,o,\"string\")b(2,s,\"string\")b(3,t,\"number\",\"nil\")return a.syscall.arpset(o,s,t)end;function c.control(s,type,u)b(1,s,\"string\")b(2,type,\"string\")b(3,u,\"string\",\"nil\")return a.syscall.netcontrol(s,type,u)end;function c.events(v)b(1,v,\"boolean\",\"nil\")return a.syscall.netevent(v)end;function c.checkURI(d)b(1,d,\"string\")return a.syscall.checkuri(d)end;function c.urlEncode(w)b(1,w,\"string\")return w:gsub(\"\\n\",\"\\r\\n\"):gsub(\"([^A-Za-z0-9 %-%_%.])\",function(f)local x=f:byte()if x<128 then return(\"%%%02X\"):format(x)else return(\"%%%02X%%%02X\"):format(bit32.rshift(x,6)+0xC0,bit32.band(x,0x3F)+0x80)end end):gsub(\" \",\"+\")end;return c\npretty.lua/     0           0     0     644     6055      `\nlocal a=require\"terminal\"local b=require\"expect\"local c=b.field;local type,getmetatable,setmetatable,d,tostring=type,getmetatable,setmetatable,a.colours,tostring;local e,f=debug.getinfo,debug.getlocal;local function g(h,i)local j=h.n+1;h[j],h.n=i,j end;local k={__name=\"document\"}local function l(m)return setmetatable(m,k)end;local n=l({tag=\"nil\"})local o=l({tag=\"text\",text=\" \"})local p=l({tag=\"line\",flat=n})local q=l({tag=\"line\",flat=o})local r={[\"\"]=n,[\" \"]=o,[\"\\n\"]=q}local function s(t,u)return r[t]or setmetatable({tag=\"text\",text=t,colour=u},k)end;local function t(t,u)b(1,t,\"string\")b(2,u,\"number\",\"nil\")local v=r[t]if v then return v end;local w=t:find(\"\\n\",1)if not w then return s(t,u)end;local x=setmetatable({tag=\"concat\",n=0},k)if w~=1 then g(x,s(t:sub(1,w-1),u))end;w=w+1;while true do local y=t:find(\"\\n\",w)g(x,q)if not y then if w<=#t then g(x,s(t:sub(w),u))end;return x else if w<=y-1 then g(x,s(t:sub(w,y-1),u))end;w=y+1 end end end;local function z(...)local A=table.pack(...)for B=1,A.n do if type(A[B])==\"string\"then A[B]=t(A[B])end;b(B,A[B],\"document\")end;if A.n==0 then return n end;if A.n==1 then return A[1]end;A.tag=\"concat\"return setmetatable(A,k)end;k.__concat=z;local function C(D,x)b(1,D,\"number\")b(2,x,\"document\")if D<=0 then error(\"depth must be a positive number\",2)end;return setmetatable({tag=\"nest\",depth=D,x},k)end;local function E(x)if x.flat then return x.flat end;local F=x.tag;if F==\"nil\"or F==\"text\"then return x elseif F==\"concat\"then local h=setmetatable({tag=\"concat\",n=x.n},k)for B=1,x.n do h[B]=E(x[B])end;x.flat,h.flat=h,h;return h elseif F==\"nest\"then return E(x[1])elseif F==\"group\"then return x[1]else error(\"Unknown doc \"..F)end end;local function G(x)b(1,x,\"document\")if x.tag==\"group\"then return x end;local H=E(x)if H==x then return x end;return setmetatable({tag=\"group\",H,x},k)end;local function I(x,J)local F=x.tag;if F==\"nil\"or F==\"line\"then return J elseif F==\"text\"then return J-#x.text elseif F==\"concat\"then for B=1,x.n do J=I(x[B],J)if J<0 then break end end;return J elseif F==\"group\"or F==\"nest\"then return I(F[1])else error(\"Unknown doc \"..F)end end;local function K(x,L)b(1,x,\"document\")b(2,L,\"number\",\"nil\")local J,M=a.termsize()local N=(L or 0.6)*J;if N<0 then N=0 end;if N>J then N=J end;local O=d.white;local P=O;local function Q(x,R,S)local F=x.tag;if F==\"nil\"then return S elseif F==\"text\"then local T=x.colour or O;if T~=P then io.write(a.toEscape(T))P=T end;io.write(x.text)return S+#x.text elseif F==\"line\"then io.write(\"\\n\\x1b[\"..R..\"C\")return R elseif F==\"concat\"then for B=1,x.n do S=Q(x[B],R,S)end;return S elseif F==\"nest\"then return Q(x[1],R+x.depth,S)elseif F==\"group\"then if I(x[1],math.min(J,N+R)-S)>=0 then return Q(x[1],R,S)else return Q(x[2],R,S)end else error(\"Unknown doc \"..F)end end;Q(x,0,0)if P~=O then io.write(\"\\x1b[0m\")end end;local function U(x,L)b(1,x,\"document\")b(2,L,\"number\",\"nil\")K(x,L)_G.print()end;local function V(x,J,L)b(1,x,\"document\")b(2,J,\"number\",\"nil\")b(3,L,\"number\",\"nil\")local N;if J then N=(L or 0.6)*J;if N<0 then N=0 end;if N>J then N=J end end;local h={n=0}local function Q(x,R,S)local F=x.tag;if F==\"nil\"then return S elseif F==\"text\"then g(h,x.text)return S+#x.text elseif F==\"line\"then g(h,\"\\n\"..(\" \"):rep(R))return R elseif F==\"concat\"then for B=1,x.n do S=Q(x[B],R,S)end;return S elseif F==\"nest\"then return Q(x[1],R+x.depth,S)elseif F==\"group\"then if not J or I(x[1],math.min(J,N+R)-S)>=0 then return Q(x[1],R,S)else return Q(x[2],R,S)end else error(\"Unknown doc \"..F)end end;Q(x,0,0)return table.concat(h,\"\",1,h.n)end;k.__tostring=V;local W={[\"and\"]=true,[\"break\"]=true,[\"do\"]=true,[\"else\"]=true,[\"elseif\"]=true,[\"end\"]=true,[\"false\"]=true,[\"for\"]=true,[\"function\"]=true,[\"if\"]=true,[\"in\"]=true,[\"local\"]=true,[\"nil\"]=true,[\"not\"]=true,[\"or\"]=true,[\"repeat\"]=true,[\"return\"]=true,[\"then\"]=true,[\"true\"]=true,[\"until\"]=true,[\"while\"]=true}local X=t(\",\")local Y=t(\"{}\")local Z,_=t(\"{\"),t(\"}\")local a0,a1=t(\"[\"),t(\"] = \")local function a2(a3,a4)local a5,a6=type(a3),type(a4)if a5==\"string\"then return a6~=\"string\"or a3<a4 elseif a6==\"string\"then return false end;if a5==\"number\"then return a6~=\"number\"or a3<a4 end;return false end;local function a7(a8,a9)local aa=e and e(a8,\"Su\")local ab;if a9.function_source and aa and aa.short_src and aa.linedefined and aa.linedefined>=1 then ab=\"function<\"..aa.short_src..\":\"..aa.linedefined..\">\"else ab=tostring(a8)end;if a9.function_args and aa and aa.what==\"Lua\"and aa.nparams and f then local A={}for B=1,aa.nparams do A[B]=f(a8,B)or\"?\"end;if aa.isvararg then A[#A+1]=\"...\"end;ab=ab..\"(\"..table.concat(A,\", \")..\")\"end;return ab end;local function ac(ad,a9,ae)local af=type(ad)if af==\"string\"then local ag=(\"%q\"):format(ad):gsub(\"\\\\\\n\",\"\\\\n\")return t(ag,d.red)elseif af==\"number\"then return t(tostring(ad),d.magenta)elseif af==\"function\"then return t(a7(ad,a9),d.lightGrey)elseif af~=\"table\"or ae[ad]then return t(tostring(ad),d.lightGrey)elseif getmetatable(ad)~=nil and getmetatable(ad).__tostring then return t(tostring(ad))elseif next(ad)==nil then return Y else ae[ad]=true;local x=setmetatable({tag=\"concat\",n=1,q},k)local ah,ai,aj=#ad,{},1;for ak in pairs(ad)do if type(ak)~=\"number\"or ak%1~=0 or ak<1 or ak>ah then ai[aj],aj=ak,aj+1 end end;table.sort(ai,a2)for B=1,ah do if B>1 then g(x,X)g(x,q)end;g(x,ac(ad[B],a9,ae))end;for B=1,aj-1 do if B>1 or ah>=1 then g(x,X)g(x,q)end;local ak=ai[B]local al=ad[ak]if type(ak)==\"string\"and not W[ak]and ak:match(\"^[%a_][%a%d_]*$\")then g(x,t(ak..\" = \"))g(x,ac(al,a9,ae))else g(x,a0)g(x,ac(ak,a9,ae))g(x,a1)g(x,ac(al,a9,ae))end end;ae[ad]=nil;return G(z(Z,C(2,z(table.unpack(x,1,x.n))),q,_))end end;local function am(ad,a9)b(2,a9,\"table\",\"nil\")a9=a9 or{}local an={function_source=c(a9,\"function_source\",\"boolean\",\"nil\")or false,function_args=c(a9,\"function_args\",\"boolean\",\"nil\")or false}return ac(ad,an,{})end;local function ao(ad,a9,L)b(2,a9,\"table\",\"nil\")a9=a9 or{}b(3,L,\"number\",\"nil\")return U(am(ad,a9),L)end;return{empty=n,space=o,line=p,space_line=q,text=t,concat=z,nest=C,group=G,write=K,print=U,render=V,pretty=am,pretty_print=ao}\n\nprocess.lua/    0           0     0     644     4173      `\nlocal a=require\"expect\"local b=require\"util\"local c={}function c.getpid()return b.syscall.getpid()end;function c.getppid()return b.syscall.getppid()end;function c.getuser()return b.syscall.getuser()end;function c.setuser(d)a(1,d,\"string\")return b.syscall.setuser(d)end;function c.clock()return b.syscall.clock()end;function c.getenv()return b.syscall.getenv()end;function c.getfenv()return b.syscall.getfenv()end;function c.getname()return b.syscall.getname()end;function c.getcwd()return b.syscall.getcwd()end;function c.chdir(e)a(1,e,\"string\")return b.syscall.chdir(e)end;function c.fork(f,g,...)a(1,f,\"function\")a(2,g,\"string\",\"nil\")return b.syscall.fork(f,g,...)end;function c.forkbg(f,g,...)a(1,f,\"function\")a(2,g,\"string\",\"nil\")return b.syscall.fork(function(...)b.syscall.stdin()b.syscall.stdout()b.syscall.stderr()setfenv(f,_ENV)return f(...)end,g,...)end;function c.exec(h,...)a(1,h,\"string\")return b.syscall.exec(h,...)end;function c.execp(i,...)a(1,i,\"string\")local h=b.syscall.getenv().PATH;if i:find\"/\"or type(h)~=\"string\"then return b.syscall.exec(i,...)end;for e in h:gmatch\"[^:]+\"do local j=b.syscall.combine(e,i)local k=b.syscall.stat(j)if not k then j=b.syscall.combine(e,i..\".lua\")k=b.syscall.stat(j)end;if k and k.type~=\"directory\"then return b.syscall.exec(j,...)end end;error(i..\": No such file\",2)end;function c.start(h,...)a(1,h,\"string\")return b.syscall.fork(function(...)return coroutine.yield(\"syscall\",\"exec\",...)end,h,h,...)end;function c.startbg(h,...)a(1,h,\"string\")return b.syscall.fork(function(...)b.syscall.stdin()b.syscall.stdout()b.syscall.stderr()return coroutine.yield(\"syscall\",\"exec\",...)end,h,h,...)end;function c.run(i,...)a(1,i,\"string\")local l=b.syscall.getenv().PATH;local h;if i:find\"/\"or type(l)~=\"string\"then h=i else for e in l:gmatch\"[^:]+\"do local j=b.syscall.combine(e,i)local k=b.syscall.stat(j)if not k then j=b.syscall.combine(e,i..\".lua\")k=b.syscall.stat(j)end;if k and k.type~=\"directory\"then h=j;break end end;error(i..\": No such file\",2)end;local m=b.syscall.fork(function(...)return coroutine.yield(\"syscall\",\"exec\",...)end,h,h,...)local n,o;repeat n,o=coroutine.yield()until n==\"process_complete\"and o.id==m;return o.error==nil,o.error or o.value end;function c.newthread(f,...)a(1,f,\"function\")return b.syscall.newthread(f,...)end;function c.exit(p)return b.syscall.exit(p)end;function c.atexit(q)a(1,q,\"function\")return b.syscall.atexit(q)end;function c.getplist()return b.syscall.getplist()end;function c.getpinfo(m)a(1,m,\"number\")return b.syscall.getpinfo(m)end;function c.nice(r,m)a(1,r,\"number\")a.range(r,-20,20)a(2,m,\"number\",\"nil\")return b.syscall.nice(r,m)end;c.debug={}function c.debug.enable(m,s)a(1,m,\"number\",\"nil\")a(2,s,\"boolean\")return b.syscall.debug_enable(m,s)end;function c.debug.brk(m,t)a(1,m,\"number\",\"nil\")a(2,t,\"number\",\"nil\")return b.syscall.debug_break(m,t)end;function c.debug.continue(m,t)a(1,m,\"number\")a(2,t,\"number\",\"nil\")return b.syscall.debug_continue(m,t)end;function c.debug.setbreakpoint(m,t,type,u)a(1,m,\"number\")a(2,t,\"number\",\"nil\")a(3,type,\"string\",\"number\")a(4,u,\"table\",\"nil\")return b.syscall.debug_setbreakpoint(m,t,type,u)end;function c.debug.unsetbreakpoint(m,v)a(1,m,\"number\")a(2,v,\"number\")return b.syscall.debug_unsetbreakpoint(m,v)end;function c.debug.listbreakpoints(m)a(1,m,\"number\")return b.syscall.debug_listbreakpoints(m)end;function c.debug.getinfo(m,t,r,w)a(1,m,\"number\")a(2,t,\"number\")a(3,r,\"number\")a(4,w,\"string\",\"nil\")return b.syscall.debug_getinfo(m,t,r,w)end;function c.debug.getlocal(m,t,r,x)a(1,m,\"number\")a(2,t,\"number\")a(3,r,\"number\")a(4,x,\"number\")return b.syscall.debug_getlocal(m,t,r,x)end;function c.debug.getupvalue(m,t,r,x)a(1,m,\"number\")a(2,t,\"number\")a(3,r,\"number\")a(4,x,\"number\")return b.syscall.debug_getupvalue(m,t,r,x)end;function c.debug.exec(m,t,q)a(1,m,\"number\")a(2,t,\"number\")a(3,q,\"function\")b.syscall.debug_exec(m,t,q)while true do local n,o=coroutine.yield()if n==\"debug_exec_result\"and o.process==m and o.thread==t then if o.ok then return table.unpack(o,1,o.n)else error(o.error,0)end end end end;function c.debug.execAsync(m,t,q)a(1,m,\"number\")a(2,t,\"number\")a(3,q,\"function\")return b.syscall.debug_exec(m,t,q)end;return c\n\n/0              0           0     0     644     17469     `\nlocal a=require\"expect\"local b={base64={},json={},lua={},toml={}}local c=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"function b.base64.encode(d)a(1,d,\"string\")local e=\"\"for f in d:gmatch\"...\"do local g=f:byte(1)*65536+f:byte(2)*256+f:byte(3)local h,i,j,k=bit32.extract(g,18,6),bit32.extract(g,12,6),bit32.extract(g,6,6),bit32.extract(g,0,6)e=e..c:sub(h+1,h+1)..c:sub(i+1,i+1)..c:sub(j+1,j+1)..c:sub(k+1,k+1)end;if#d%3==1 then local g=d:byte(-1)local h,i=bit32.rshift(g,2),bit32.lshift(bit32.band(g,3),4)e=e..c:sub(h+1,h+1)..c:sub(i+1,i+1)..\"==\"elseif#d%3==2 then local g=d:byte(-2)*256+d:byte(-1)local h,i,j=bit32.extract(g,10,6),bit32.extract(g,4,6),bit32.lshift(bit32.extract(g,0,4),2)e=e..c:sub(h+1,h+1)..c:sub(i+1,i+1)..c:sub(j+1,j+1)..\"=\"end;return e end;function b.base64.decode(d)a(1,d,\"string\")local e=\"\"for f in d:gmatch\"....\"do if f:sub(3,4)=='=='then e=e..string.char(bit32.bor(bit32.lshift(c:find(f:sub(1,1))-1,2),bit32.rshift(c:find(f:sub(2,2))-1,4)))elseif f:sub(4,4)=='='then local g=(c:find(f:sub(1,1))-1)*4096+(c:find(f:sub(2,2))-1)*64+c:find(f:sub(3,3))-1;e=e..string.char(bit32.extract(g,10,8))..string.char(bit32.extract(g,2,8))else local g=(c:find(f:sub(1,1))-1)*262144+(c:find(f:sub(2,2))-1)*4096+(c:find(f:sub(3,3))-1)*64+c:find(f:sub(4,4))-1;e=e..string.char(bit32.extract(g,16,8))..string.char(bit32.extract(g,8,8))..string.char(bit32.extract(g,0,8))end end;return e end;local function l(d)return setmetatable({},{__newindex=function()error(\"attempt to modify read-only table\")end,__tostring=function()return d end})end;b.json.null=l\"null\"b.json.emptyArray=l\"[]\"local m;local n={[\"\\\\\"]=\"\\\\\",[\"\\\"\"]=\"\\\"\",[\"\\b\"]=\"b\",[\"\\f\"]=\"f\",[\"\\n\"]=\"n\",[\"\\r\"]=\"r\",[\"\\t\"]=\"t\"}local o={[\"/\"]=\"/\"}for p,q in pairs(n)do o[q]=p end;local function r(j)return\"\\\\\"..(n[j]or string.format(\"u%04x\",j:byte()))end;local function s(t)return\"null\"end;local function u(t,v)local w={}v=v or{}if t==b.json.null then return\"null\"elseif t==b.json.emptyArray then return\"[]\"end;if v[t]then error(\"circular reference\")end;v[t]=true;if rawget(t,1)~=nil or next(t)==nil then local g=0;for p in pairs(t)do if type(p)~=\"number\"then error(\"invalid table: mixed or invalid key types\")end;g=g+1 end;if g~=#t then error(\"invalid table: sparse array\")end;for x,q in ipairs(t)do table.insert(w,m(q,v))end;v[t]=nil;return\"[\"..table.concat(w,\",\")..\"]\"else for p,q in pairs(t)do if type(p)~=\"string\"then error(\"invalid table: mixed or invalid key types\")end;table.insert(w,m(p,v)..\":\"..m(q,v))end;v[t]=nil;return\"{\"..table.concat(w,\",\")..\"}\"end end;local function y(t)return'\"'..t:gsub('[%z\\1-\\31\\\\\"]',r)..'\"'end;local function z(t)if t~=t or t<=-math.huge or t>=math.huge then error(\"unexpected number value '\"..tostring(t)..\"'\")end;return string.format(\"%.14g\",t)end;local A={[\"nil\"]=s,[\"table\"]=u,[\"string\"]=y,[\"number\"]=z,[\"boolean\"]=tostring}m=function(t,v)local B=type(t)local C=A[B]if C then return C(t,v)end;error(\"unexpected type '\"..B..\"'\")end;function b.json.encode(t)return m(t)end;local D;local function E(...)local w={}for x=1,select(\"#\",...)do w[select(x,...)]=true end;return w end;local F=E(\" \",\"\\t\",\"\\r\",\"\\n\")local G=E(\" \",\"\\t\",\"\\r\",\"\\n\",\"]\",\"}\",\",\")local H=E(\"\\\\\",\"/\",'\"',\"b\",\"f\",\"n\",\"r\",\"t\",\"u\")local I=E(\"true\",\"false\",\"null\")local J={[\"true\"]=true,[\"false\"]=false,[\"null\"]=nil}local function K(d,L,M,N)for x=L,#d do if M[d:sub(x,x)]~=N then return x end end;return#d+1 end;local function O(d,L,P)local Q=1;local R=1;for x=1,L-1 do R=R+1;if d:sub(x,x)==\"\\n\"then Q=Q+1;R=1 end end;error(string.format(\"%s at line %d col %d\",P,Q,R))end;local function S(g)local C=math.floor;if g<=0x7f then return string.char(g)elseif g<=0x7ff then return string.char(C(g/64)+192,g%64+128)elseif g<=0xffff then return string.char(C(g/4096)+224,C(g%4096/64)+128,g%64+128)elseif g<=0x10ffff then return string.char(C(g/262144)+240,C(g%262144/4096)+128,C(g%4096/64)+128,g%64+128)end;error(string.format(\"invalid unicode codepoint '%x'\",g))end;local function T(f)local U=tonumber(f:sub(1,4),16)local V=tonumber(f:sub(7,10),16)if V then return S((U-0xd800)*0x400+V-0xdc00+0x10000)else return S(U)end end;local function W(d,x)local w=\"\"local X=x+1;local p=X;while X<=#d do local Y=d:byte(X)if Y<32 then O(d,X,\"control character in string\")elseif Y==92 then w=w..d:sub(p,X-1)X=X+1;local j=d:sub(X,X)if j==\"u\"then local Z=d:match(\"^[dD][89aAbB]%x%x\\\\u%x%x%x%x\",X+1)or d:match(\"^%x%x%x%x\",X+1)or O(d,X-1,\"invalid unicode escape in string\")w=w..T(Z)X=X+#Z else if not H[j]then O(d,X-1,\"invalid escape char '\"..j..\"' in string\")end;w=w..o[j]end;p=X+1 elseif Y==34 then w=w..d:sub(p,X-1)return w,X+1 end;X=X+1 end;O(d,x,\"expected closing quote for string\")end;local function _(d,x)local Y=K(d,x,G)local f=d:sub(x,Y-1)local g=tonumber(f)if not g then O(d,x,\"invalid number '\"..f..\"'\")end;return g,Y end;local function a0(d,x)local Y=K(d,x,G)local a1=d:sub(x,Y-1)if not I[a1]then O(d,x,\"invalid literal '\"..a1 ..\"'\")end;return J[a1],Y end;local function a2(d,x)local w={}local g=1;x=x+1;while 1 do local Y;x=K(d,x,F,true)if d:sub(x,x)==\"]\"then x=x+1;break end;Y,x=D(d,x)w[g]=Y;g=g+1;x=K(d,x,F,true)local a3=d:sub(x,x)x=x+1;if a3==\"]\"then break end;if a3~=\",\"then O(d,x,\"expected ']' or ','\")end end;return w,x end;local function a4(d,x)local w={}x=x+1;while 1 do local a5,t;x=K(d,x,F,true)if d:sub(x,x)==\"}\"then x=x+1;break end;if d:sub(x,x)~='\"'then O(d,x,\"expected string for key\")end;a5,x=D(d,x)x=K(d,x,F,true)if d:sub(x,x)~=\":\"then O(d,x,\"expected ':' after key\")end;x=K(d,x+1,F,true)t,x=D(d,x)w[a5]=t;x=K(d,x,F,true)local a3=d:sub(x,x)x=x+1;if a3==\"}\"then break end;if a3~=\",\"then O(d,x,\"expected '}' or ','\")end end;return w,x end;local a6={['\"']=W,[\"0\"]=_,[\"1\"]=_,[\"2\"]=_,[\"3\"]=_,[\"4\"]=_,[\"5\"]=_,[\"6\"]=_,[\"7\"]=_,[\"8\"]=_,[\"9\"]=_,[\"-\"]=_,[\"t\"]=a0,[\"f\"]=a0,[\"n\"]=a0,[\"[\"]=a2,[\"{\"]=a4}D=function(d,L)local a3=d:sub(L,L)local C=a6[a3]if C then return C(d,L)end;O(d,L,\"unexpected character '\"..a3 ..\"'\")end;function b.json.decode(d)a(1,d,\"string\")local w,L=D(d,K(d,1,F,true))L=K(d,L,F,true)if L<=#d then O(d,L,\"trailing garbage\")end;return w end;function b.json.save(t,a7)a(2,a7,\"string\")local a8=assert(io.open(a7,\"w\"))a8:write(b.json.encode(t))a8:close()end;function b.json.load(a7)a(1,a7,\"string\")local a8=assert(io.open(a7,\"r\"))local a9=a8:read(\"*a\")a8:close()return b.json.decode(a9)end;local aa={[\"and\"]=true,[\"break\"]=true,[\"do\"]=true,[\"else\"]=true,[\"elseif\"]=true,[\"end\"]=true,[\"false\"]=true,[\"for\"]=true,[\"function\"]=true,[\"goto\"]=true,[\"if\"]=true,[\"in\"]=true,[\"local\"]=true,[\"nil\"]=true,[\"not\"]=true,[\"or\"]=true,[\"repeat\"]=true,[\"return\"]=true,[\"then\"]=true,[\"true\"]=true,[\"until\"]=true,[\"while\"]=true}local function ab(t,v,ac,ad)if v[t]then error(\"Cannot serialize recursive value\",0)end;local ae=type(t)if ae==\"table\"then if not next(t)then return\"{}\"end;v[t]=true;local w=ac.minified and\"{\"or\"{\\n\"local af={}for x,q in ipairs(t)do if not ac.minified then w=w..(\"    \"):rep(ad)end;af[x]=true;w=w..ab(q,v,ac,ad+1)..(ac.minified and\",\"or\",\\n\")end;for p,q in pairs(t)do if not af[p]then if not ac.minified then w=w..(\"    \"):rep(ad)end;if type(p)==\"string\"and p:match\"^[A-Za-z_][A-Za-z0-9_]*$\"and not aa[p]then w=w..p else w=w..\"[\"..ab(p,v,ac,ad+1)..\"]\"end;w=w..(ac.minified and\"=\"or\" = \")..ab(q,v,ac,ad+1)..(ac.minified and\",\"or\",\\n\")end end;if ac.minified then w=w:gsub(\",$\",\"\")else w=w..(\"    \"):rep(ad-1)end;v[t]=nil;return w..\"}\"elseif ae==\"function\"and ac.allow_functions then local ag,ah=pcall(string.dump,t)if not ag then error(\"Cannot serialize C function\",0)end;ah=(\"%q\"):format(ah):gsub(\"\\\\[%z\\1-\\31\\127-\\255]\",function(j)return(\"\\\\%03d\"):format(string.byte(j))end)local ai={n=0}v[t]=true;for x=1,math.huge do local ag,aj,ak=pcall(debug.getupvalue,t,x)if not ag or not aj then break end;ai[x]=ak;ai.n=x end;local aj=\"=(serialized function)\"local ag,al=pcall(debug.getinfo,t,\"S\")if ag then aj=al.source or aj end;local q=(\"__function(%s,%q,%s)\"):format(ah,aj,ab(ai,v,ac,ad+1))v[t]=nil;return q elseif ae==\"nil\"or ae==\"number\"or ae==\"boolean\"or ae==\"string\"then return(\"%q\"):format(t):gsub(\"\\\\\\n\",\"\\\\n\"):gsub(\"\\\\?[%z\\1-\\31\\127-\\255]\",function(j)return(\"\\\\%03d\"):format(string.byte(j))end)else error(\"Cannot serialize type \"..ae,0)end end;function b.lua.encode(t,ac)a(2,ac,\"table\",\"nil\")return ab(t,{},ac or{},1)end;function b.lua.decode(d,ac)ac=a(2,ac,\"table\",\"nil\")or{}local am={}local an={}if ac.allow_functions then function am.__function(ao,aj,ai)a(1,ao,\"string\")a(3,ai,\"table\")a.field(ai,\"n\",\"number\")local ap=assert(load(ao,aj,\"b\",{}))for x=1,ai.n do debug.setupvalue(ap,x,ai[x])end;an[#an+1]=ap;return ap end end;local w=assert(load(\"return \"..d,\"=unserialize\",\"t\",am))()for aq,q in ipairs(an)do setfenv(q,_G)end;return w end;function b.lua.save(t,a7,ac)a(2,a7,\"string\")local a8=assert(io.open(a7,\"w\"))a8:write(b.lua.encode(t,ac))a8:close()end;function b.lua.load(a7,ac)a(1,a7,\"string\")local a8=assert(io.open(a7,\"r\"))local a9=a8:read(\"*a\")a8:close()return b.lua.decode(a9,ac)end;local function ar(as,ac,at)local au,d=false,false;for av in pairs(as)do if type(av)==\"number\"then au=true elseif type(av)==\"string\"then d=true else error(\"key \"..table.concat(at,\".\")..\".\"..tostring(av)..\" is not a string\")end end;local aw=#at+1;if not au and not d then return\"[]\"elseif au and d then error(\"invalid entry \"..table.concat(at,\".\")..\" (contains both array and dictionary values)\")elseif au then local e=\"[\"for x,q in ipairs(as)do if type(q)==\"table\"then at[aw]=tostring(x)e=e..(e==\"[\"and\"\"or\", \")..ar(q,ac,at)at[aw]=nil else e=e..(e==\"[\"and\"\"or\", \")..ab(q,{},{},#at)end end;return e..\"]\"else local w=\"{\"for p,q in pairs(as)do if w~=\"{\"then w=w..\", \"end;if type(p)==\"string\"and p:match\"^[A-Za-z0-9_%-]+$\"then w=w..p else w=w..ab(p,{},{},#at)end;if type(q)==\"table\"then at[aw]=p;w=w..\" = \"..ar(q,ac,at)at[aw]=nil else w=w..\" = \"..ab(q,{},{},#at)end end;return w..\"}\"end end;local function ax(ay,ac,at)local e=\"\"local az=ac.indent==false and\"\"or(\"    \"):rep(#at)if#at>0 then e=(\"%s[%s]\\n\"):format((\"    \"):rep(#at-1),table.concat(at,\".\"))end;local aA,aB={},{}local aw=#at+1;for p,q in pairs(ay)do assert(type(p)==\"string\",\"key \"..table.concat(at,\".\")..\".\"..tostring(p)..\" is not a string\")local a5=p:match(\"^[A-Za-z0-9_%-]+$\")and p or ab(p,{},{},1)local B=type(q)if B==\"table\"then local au,d,aC=false,false,true;for av,aD in pairs(q)do if type(av)==\"number\"then au=true elseif type(av)==\"string\"then d=true else error(\"key \"..table.concat(at,\".\")..\".\"..tostring(p)..\".\"..tostring(av)..\" is not a string\")end;if type(aD)~=\"table\"then aC=false else for aE in pairs(aD)do if type(aE)~=\"string\"then aC=false;break end end end end;if not au and not d then e=e..az..a5 ..\" = []\\n\"elseif au and d then error(\"invalid entry \"..table.concat(at,\".\")..\".\"..tostring(p)..\" (contains both array and dictionary values)\")elseif au then if aC then aB[p]=q else at[aw]=p;e=e..az..a5 ..\" = \"..ar(q,ac,at)at[aw]=nil end else aA[p]=q end else e=e..az..a5 ..\" = \"..ab(q,{},{},#at)..\"\\n\"end end;for p,as in pairs(aB)do at[aw]=p;for aq,q in ipairs(as)do e=e..(\"%s[[%s]]\\n\"):format(az,table.concat(at,\".\"))..ax(q,ac,at)..\"\\n\"end end;for p,q in pairs(aA)do at[aw]=p;e=e..(\"%s[%s]\\n\"):format(az,table.concat(at,\".\"))..ax(q,ac,at)..\"\\n\"end;at[aw]=nil;return e end;function b.toml.encode(ay,ac)a(1,ay,\"table\")a(2,ac,\"table\",\"nil\")return ax(ay,ac or{},{})end;local function aF(aC,aj,aG,aH,aI)local aJ,aK;while aG<#aj do if aG>1 then aG=aj:match(\"^%s*()\",aG)if aI and aj:sub(aG,aG)==\"=\"then return aJ,aK,aG+1 end;if aj:sub(aG,aG)~=\".\"then error(\"Expected . on line \"..aH,3)end;aG=aj:match(\"^%s*()\",aG+1)end;local a5;if aj:match('^\"',aG)then a5,aG=W(aj,aG+1)elseif aj:match(\"^'\",aG)then a5,aG=aj:match(\"'([^']*)'()\",aG)else a5,aG=aj:match(\"^([A-Za-z0-9_%-]+)()\",aG)end;if not a5 then error(\"Invalid key name on line \"..aH,3)end;aJ,aK=aC,a5;if not aC[a5]then aC[a5]={}end;aC=aC[a5]end;if aI then error(\"Expected = on line \"..aH,3)end;return aC end;local function aL(aM,aG,aH)aG=aM:match(\"^%s*()\",aG)while aG>#aM or aM:sub(aG,aG)==\"#\"do aM=coroutine.yield()aH=aH+1;aG=aM:match\"^%s*()\"end;return aM,aG,aH end;local function aN(aC,a5,aM,aG,aH)local aO=aM:sub(aG,aG)while aO==\"#\"do aM=coroutine.yield()aH=aH+1;aG=aM:match\"^%s*()\"aO=aM:sub(aG,aG)end;if aO==\"[\"then local e={}local x=1;aM,aG,aH=aL(aM,aG+1,aH)while true do aO=aM:sub(aG,aG)if aO==\"]\"then break end;aM,aG,aH=aN(e,x,aM,aG,aH)aM,aG,aH=aL(aM,aG,aH)aO=aM:sub(aG,aG)if aO==\"]\"then break end;if aO~=\",\"then error(\"Expected , on line \"..aH,0)end;aM,aG,aH=aL(aM,aG+1,aH)x=x+1 end;aC[a5]=e;return aM,aG+1,aH elseif aO==\"{\"then local e={}aM,aG,aH=aL(aM,aG+1,aH)while true do aO=aM:sub(aG,aG)if aO==\"}\"then break end;local B,p;B,p,aG=aF(e,aM,aG,aH,true)aM,aG,aH=aL(aM,aG,aH)aM,aG,aH=aN(B,p,aM,aG,aH)aM,aG,aH=aL(aM,aG,aH)aO=aM:sub(aG,aG)if aO==\"}\"then break end;if aO~=\",\"then error(\"Expected , on line \"..aH,0)end;aM,aG,aH=aL(aM,aG+1,aH)end;aC[a5]=e;return aM,aG+1,aH elseif aO==\"'\"then if aM:match(\"^'''\",aG)then aG=aG+3;local d=\"\"while not aM:find(\"'''\",aG)do if not(d==\"\"and aG==#aM)then d=d..aM:sub(aG)..\"\\n\"end;aM=coroutine.yield()aH,aG=aH+1,1 end;d=d..aM:sub(aG,aM:find(\"'''\",aG)-1)aG=aM:match(\"'''()\",aG)aC[a5]=d;return aM,aG,aH else local d,aG=aM:match(\"^'([^']*)'()\",aG)if not d then error(\"Invalid literal string on line \"..aH,0)end;aC[a5]=d;return aM,aG,aH end elseif aO=='\"'then if aM:match('^\"\"\"',aG)then local f=\"\"while not aM:find('\"\"\"',aG)do if not(f==\"\"and aG==#aM)then f=f..aM:sub(aG)..\"\\n\"end;aM=coroutine.yield()aH,aG=aH+1,1 end;f=f..aM:sub(aG,aM:find('\"\"\"',aG)-1)f=f:gsub(\"\\\\\\r?\\n\",\"\"):gsub('\"','\\\\\"')..'\"'aC[a5]=W(f,1)aG=aM:match('\"\"\"()',aG)return aM,aG,aH else local d,aG=W(aM,aG)if not d then error(\"Invalid string on line \"..aH,0)end;aC[a5]=d;return aM,aG,aH end elseif aM:match(\"^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d\",aG)then local aP,aQ,k,aR,aE,f,aG=aM:match(\"^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()\",aG)local aS={year=tonumber(aP),month=tonumber(aQ),day=tonumber(k),hour=tonumber(aR),min=tonumber(aE),sec=tonumber(f)}local aT=os.time(aS)if aM:match(\"^%.%d+\",aG)then local aU;aU,aG=aM:match(\"(%.%d+)()\",aG)aT=aT+tonumber(\"0\"..aU)end;local j=aM:sub(aG,aG)if j==\"+\"or j==\"-\"then local aV,aW;aV,aW,aG=aM:match(\"^[%+%-](%d%d):(%d%d)()\",aG)if not aV then error(\"Invalid date format on line \"..aH,0)end;local aX=tonumber(aV)*3600+tonumber(aW)*60;if j==\"-\"then aX=-aX end;aT=aT+aX elseif j==\"Z\"then aG=aG+1 end;aC[a5]=aT;return aM,aG,aH elseif aM:match(\"^%d%d%d%d%-%d%d%-%d%d\",aG)then local aP,aQ,k,aG=aM:match(\"^(%d%d%d%d)%-(%d%d)%-(%d%d)()\",aG)local aS={year=tonumber(aP),month=tonumber(aQ),day=tonumber(k),hour=0,min=0,sec=0}local aT=os.time(aS)aC[a5]=aT;return aM,aG,aH elseif aM:match(\"^%d%d%:%d%d:%d%d\",aG)then local aR,aE,f,aG=aM:match(\"^(%d%d):(%d%d):(%d%d)()\",aG)local aT=aR*3600+aE*60*f;if aM:match(\"^%.%d+\",aG)then local aU;aU,aG=aM:match(\"(%.%d+)()\",aG)aT=aT+tonumber(\"0\"..aU)end;aC[a5]=aT;return aM,aG,aH elseif aO:match\"%d\"or aO==\"+\"or aO==\"-\"then if aM:match(\"^%+inf\",aG)then aC[a5]=math.huge;return aM,aG+4,aH elseif aM:match(\"^%-inf\",aG)then aC[a5]=-math.huge;return aM,aG+4,aH elseif aM:match(\"^%+nan\",aG)then aC[a5]=-(0/0)return aM,aG+4,aH elseif aM:match(\"^%-nan\",aG)then aC[a5]=0/0;return aM,aG+4,aH elseif aM:match(\"^[%+%-]?0o\",aG)then local aY,af,aG=aM:match(\"^([%+%-]?)0o([0-7_]+)()\",aG):gsub(\"_\",\"\")if not af then error(\"Invalid number on line \"..aH,0)end;af=tonumber(af,8)if not af then error(\"Invalid number on line \"..aH,0)end;if aY==\"-\"then af=-af end;aC[a5]=af;return aM,aG,aH elseif aM:match(\"^[%+%-]?0b\",aG)then local aY,af,aG=aM:match(\"^([%+%-]?)0b([01_]+)()\",aG):gsub(\"_\",\"\")if not af then error(\"Invalid number on line \"..aH,0)end;af=tonumber(af,2)if not af then error(\"Invalid number on line \"..aH,0)end;if aY==\"-\"then af=-af end;aC[a5]=af;return aM,aG,aH else local af,aG=aM:match(\"^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()\",aG)af=af:gsub(\"_\",\"\")af=tonumber(af)if not af then error(\"Invalid number on line \"..aH,0)end;aC[a5]=af;return aM,aG,aH end elseif aM:match(\"^true\",aG)then aC[a5]=true;return aM,aG+4,aH elseif aM:match(\"^false\",aG)then aC[a5]=false;return aM,aG+5,aH elseif aM:match(\"^nil\",aG)then aC[a5]=nil;return aM,aG+3,aH elseif aM:match(\"^inf\",aG)then aC[a5]=math.huge;return aM,aG+3,aH elseif aM:match(\"^nan\",aG)then aC[a5]=-(0/0)return aM,aG+3,aH else error(\"Unexpected \"..aO..\" on line \"..aH,0)end end;function b.toml.decode(d,ac)a(1,d,\"string\")ac=a(2,ac,\"table\",\"nil\")or{}local e={}local aZ=e;local aH=1;local a_;for aM in d:gmatch\"([^\\r\\n]*)\\r?\\n\"do if a_ then local ag,b0=a_:resume(aM)if not ag then error(b0,3)end;if a_:status()==\"dead\"then a_=nil end else aM=aM:gsub(\"^%s+\",\"\")if aM:match\"^#\"or aM==\"\"then elseif aM:match\"^%[%[\"then local b1=aM:match\"^%[(%b[])%]\"if not b1 then error(\"Expected ]] on line \"..aH,2)end;aZ=aF(e,b1:sub(2,-2),1,aH)aZ[#aZ+1]={}aZ=aZ[#aZ]elseif aM:match\"^%[\"then local b1=aM:match\"^%b[]\"if not b1 then error(\"Expected ] on line \"..aH,2)end;aZ=aF(e,b1:sub(2,-2),1,aH)else local aJ,a5,aG=aF(aZ,aM,1,aH,true)aG=aM:match(\"^%s*()\",aG)if not aG then error(\"Expected value on line \"..aH,2)end;a_=coroutine.create(aN)local ag,b0=a_:resume(aJ,a5,aM,aG,aH)if not ag then error(b0,3)end;if a_:status()==\"dead\"then a_=nil end end end;aH=aH+1 end;if a_ then error(\"Unfinished value at end of file\",2)end;return e end;function b.toml.save(t,a7,ac)a(1,t,\"table\")a(2,a7,\"string\")a(3,ac,\"table\",\"nil\")local a8=assert(io.open(a7,\"w\"))a8:write(b.toml.encode(t,ac))a8:close()end;function b.toml.load(a7,ac)a(1,a7,\"string\")a(2,ac,\"table\",\"nil\")local a8=assert(io.open(a7,\"r\"))local a9=a8:read(\"*a\")a8:close()return b.toml.decode(a9,ac)end;return b\n\nsync.lua/       0           0     0     644     3341      `\nlocal a=require\"expect\"local b=require\"util\"local c={mutex={},semaphore={},conditionVariable={},atomic={},barrier={},rwLock={}}function c.mutex.new(d)a(1,d,\"boolean\",\"nil\")return setmetatable({recursive=d and 0},{__name=\"mutex\",__index=c.mutex})end;function c.mutex:lock()a(1,self,\"mutex\")return b.syscall.lockmutex(self)end;function c.mutex:unlock()a(1,self,\"mutex\")return b.syscall.unlockmutex(self)end;function c.mutex:tryLock()a(1,self,\"mutex\")return b.syscall.trylockmutex(self)end;function c.mutex:tryLockFor(e)a(1,self,\"mutex\")a(2,e,\"number\")return b.syscall.timelockmutex(self,e)end;function c.semaphore.new(f)a(1,f,\"number\",\"nil\")if f then a.range(f,0)end;return setmetatable({count=f or 1},{__name=\"semaphore\",__index=c.semaphore})end;function c.semaphore:acquire()a(1,self,\"semaphore\")return b.syscall.acquiresemaphore(self)end;function c.semaphore:tryAcquireFor(e)a(1,self,\"semaphore\")a(2,e,\"number\")return b.syscall.timeacquiresemaphore(self,e)end;function c.semaphore:release()a(1,self,\"semaphore\")return b.syscall.releasesemaphore(self)end;function c.conditionVariable.new()return setmetatable({lock=c.mutex.new(),sem=c.semaphore.new(0),waiting=0},{__name=\"condition variable\",__index=c.conditionVariable})end;function c.conditionVariable:wait()a(1,self,\"condition variable\")self.lock:lock()self.waiting=self.waiting+1;self.lock:unlock()self.sem:acquire()self.lock:lock()self.waiting=self.waiting-1;self.lock:unlock()end;function c.conditionVariable:waitFor(e)a(1,self,\"condition variable\")a(2,e,\"number\")self.lock:lock()self.waiting=self.waiting+1;self.lock:unlock()local g=self.sem:tryAcquireFor(e)self.lock:lock()self.waiting=self.waiting-1;self.lock:unlock()return g end;function c.conditionVariable:notifyOne()a(1,self,\"condition variable\")self.sem:release()end;function c.conditionVariable:notifyAll()a(1,self,\"condition variable\")self.lock:lock()self.sem.count=self.sem.count+self.waiting-1;self.sem:release()self.lock:unlock()end;function c.barrier.new(h)a(1,h,\"number\")a.range(h,1)return setmetatable({cvar=c.conditionVariable.new(),lock=c.mutex.new(),left=h,count=h,cycles=0},{__name=\"barrier\",__index=c.barrier})end;function c.barrier:wait()a(1,self,\"barrier\")self.lock:lock()self.left=self.left-1;if self.left==0 then self.left=self.count;self.cycles=self.cycles+1;self.lock:unlock()self.cvar:notifyAll()return true else self.lock:unlock()self.cvar:wait()return false end end;function c.rwLock.new()return setmetatable({count=0,readLock=c.mutex.new(),globalLock=c.semaphore.new(1)},{__name=\"rwlock\",__index=c.rwLock})end;function c.rwLock:lockRead()a(1,self,\"rwlock\")self.readLock:lock()self.count=self.count+1;if self.count==1 then self.globalLock:acquire()end;self.readLock:unlock()end;function c.rwLock:unlockRead()a(1,self,\"rwlock\")self.readLock:lock()self.count=self.count-1;if self.count==0 then self.globalLock:release()end;self.readLock:unlock()end;function c.rwLock:lockWrite()a(1,self,\"rwlock\")self.globalLock:acquire()end;function c.rwLock:unlockWrite()a(1,self,\"rwlock\")self.globalLock:release()end;function c.lockGuard(i,j,...)a(1,i,\"mutex\")a(2,j,\"function\")i:lock()local k=table.pack(pcall(j,...))i:unlock()if not k[1]then error(k[2],0)end;return table.unpack(k,2,k.n)end;function c.synctab()local l={}local m=c.mutex.new()return function(j)a(1,j,\"function\")return c.lockGuard(m,j,l)end end;return c\n\nterminal.lua/   0           0     0     644     4285      `\nlocal a=require\"expect\"local b=require\"keys\"local c=require\"util\"local d={}d.colors={white=0,orange=1,magenta=2,lightBlue=3,yellow=4,lime=5,pink=6,gray=7,grey=7,lightGray=8,lightGrey=8,cyan=9,purple=10,blue=11,brown=12,green=13,red=14,black=15}d.colours=d.colors;function d.toEscape(e,f)a(1,e,\"number\")a(2,f,\"boolean\",\"nil\")a.range(e,0,15)local g=37-e%8;if e<8 then g=g+60 end;if f then g=g+10 end;return\"\\x1b[\"..g..\"m\"end;function d.write(...)return c.syscall.write(...)end;function d.writeerr(...)return c.syscall.writeerr(...)end;function d.read(g)a(1,g,\"number\")return c.syscall.read(g)end;function d.readline()return c.syscall.readline()end;function d.readline2(h,i)a(1,h,\"table\",\"nil\")a(2,i,\"function\",\"nil\")local j=\"\"local k=1;local l=0;local m;local n,o;d.capture()d.termctl{echo=false}while true do local p,q=coroutine.yield()if p==\"char\"then if n and n[o]and q.character==n[o]:sub(-1)then n=nil else n=nil;if k<=#j then d.write(\"\\x1b[@\"..q.character)j=j:sub(1,k-1)..q.character..j:sub(k)else d.write(q.character)j=j..q.character end;k=k+1 end elseif p==\"key\"then if q.keycode==b.enter then d.termctl{echo=true}if k<=#j then d.write(\"\\x1b[\"..#j-k+1 ..\"C\")end;d.write(\"\\n\")d.readline()d.release()return j elseif q.keycode==b.d and q.ctrlHeld and not q.altHeld and not q.shiftHeld then d.termctl{echo=true}d.release()return d.readline()elseif q.keycode==b.backspace and k>1 then n=nil;d.write(\"\\x1b[D\\x1b[P\")j=j:sub(1,k-2)..j:sub(k)k=k-1 elseif q.keycode==b.delete and k<=#j then n=nil;d.write(\"\\x1b[P\")j=j:sub(1,k-1)..j:sub(k+1)elseif q.keycode==b.left and k>1 then n=nil;d.write(\"\\x1b[D\")k=k-1 elseif q.keycode==b.right and k<=#j then n=nil;d.write(\"\\x1b[C\")k=k+1 elseif q.keycode==b.up and h and l<#h then n=nil;if k>1 then d.write(\"\\x1b[\"..k-1 ..\"D\")end;d.write(\"\\x1b[\"..#j..\"P\")if l==0 then m=j end;l=l+1;j=h[l]d.write(j)k=#j+1 elseif q.keycode==b.down and h and l>0 then n=nil;if k>1 then d.write(\"\\x1b[\"..k-1 ..\"D\")end;d.write(\"\\x1b[\"..#j..\"P\")l=l-1;if l==0 then j=m else j=h[l]end;d.write(j)k=#j+1 elseif q.keycode==b.tab and i then if n and#n>0 then d.write(\"\\x1b[\"..#n[o]..\"D\\x1b[\"..#n[o]..\"P\")j=j:sub(1,k-#n[o]-1)..j:sub(k)k=k-#n[o]o=o%#n+1 else n=i(j:sub(1,k-1))o=1 end;if n[o]then d.write(\"\\x1b[\"..#n[o]..\"@\"..n[o])j=j:sub(1,k-1)..n[o]..j:sub(k)k=k+#n[o]end end elseif p==\"paste\"then n=nil;if k<=#j then d.write(\"\\x1b[\"..#q.text..\"@\"..q.text)j=j:sub(1,k-1)..q.text..j:sub(k)k=k+#q.text else d.write(q.text)j=j..q.text end;k=k+#q.text end end end;function d.termctl(r)a(1,r,\"table\",\"nil\")if r then a.field(r,\"cbreak\",\"boolean\",\"nil\")a.field(r,\"delay\",\"boolean\",\"nil\")a.field(r,\"echo\",\"boolean\",\"nil\")a.field(r,\"keypad\",\"boolean\",\"nil\")a.field(r,\"nlcr\",\"boolean\",\"nil\")a.field(r,\"raw\",\"boolean\",\"nil\")end;return c.syscall.termctl(r)end;function d.openterm()return c.syscall.openterm()end;function d.opengfx()return c.syscall.opengfx()end;function d.mktty(s,t)a(1,s,\"number\")a(2,t,\"number\")return c.syscall.mktty(s,t)end;function d.capture()return c.syscall.capture()end;function d.release()return c.syscall.release()end;function d.stdin(u)a(1,u,\"number\",\"table\",\"nil\")return c.syscall.stdin(u)end;function d.stdout(u)a(1,u,\"number\",\"table\",\"nil\")return c.syscall.stdout(u)end;function d.stderr(u)a(1,u,\"number\",\"table\",\"nil\")return c.syscall.stderr(u)end;function d.istty()return c.syscall.istty()end;function d.termsize()return c.syscall.termsize()end;d.getSize=d.termsize;local v={}function v.close()end;function v.write(w)end;function v.blit(w,x,y)end;function v.clear()end;function v.clearLine()end;function v.getCursorPos()end;function v.setCursorPos(z,A)end;function v.getCursorBlink()end;function v.setCursorBlink(B)end;function v.isColor()end;function v.getSize()end;function v.scroll(C)end;function v.getTextColor()end;function v.setTextColor(e)end;function v.getBackgroundColor()end;function v.setBackgroundColor(e)end;function v.getPaletteColor(e)end;function v.setPaletteColor(e,D,E,F)end;function v.getLine(A)end;local G={}function G.close()end;function G.getSize()end;function G.clear()end;function G.getPaletteColor(e)end;function G.setPaletteColor(e,D,E,F)end;function G.getPixel(z,A)end;function G.setPixel(z,A,e)end;function G.getPixels(z,A,s,t,H)end;function G.drawPixels(z,A,I,s,t)end;function G.getFrozen()end;function G.setFrozen(J)end;return d\n\nutil.lua/       0           0     0     644     6670      `\nlocal a=require\"expect\"local b={}b.syscall=setmetatable({},{__index=function(self,c)return function(...)local d=table.pack(coroutine.yield(\"syscall\",c,...))if d[1]then return table.unpack(d,2,d.n)else error(d[2],2)end end end,__newindex=function()end})function b.argparse(e,...)a(1,e,\"table\")a.field(e,\"\",\"table\",\"nil\")local d={}local f;local g=e[\"\"]or{}for h,i in ipairs{...}do if f then if e[f]==\"number\"then d[f]=tonumber(i)if not d[f]then return nil,\"parameter passed to argument '\"..f..\"' is not a number\"end elseif e[f]==\"multiple\"then d[f]=d[f]or{}d[f][#d[f]+1]=i elseif e[f]==\"multiple number\"then i=tonumber(i)if not i then return nil,\"parameter passed to argument '\"..f..\"' is not a number\"end;d[f]=d[f]or{}d[f][#d[f]+1]=i else d[f]=i end;f=nil elseif i:match\"^%-+$\"then local j=table.pack(...)local k=i==\"-\"and#d+1 or#d;for l=i==\"-\"and 0 or 1,j.n-h do d[k+l]=j[h+l]end;break elseif i:sub(1,2)==\"--\"then local m=i:sub(3)while type(e[m])==\"string\"and e[m]:match\"^@\"do m=e[m]:sub(2)end;if e[m]then f=m elseif e[m]==false then d[m]=true else return nil,\"unrecognized argument '--\"..m..\"'\"end elseif i:sub(1,1)==\"-\"then for m in i:sub(2):gmatch\".\"do while type(e[m])==\"string\"and e[m]:match\"^@\"do m=e[m]:sub(2)end;if e[m]then if f then return nil,\"no parameter passed to argument '\"..f..\"'\"end;f=m elseif e[m]==false then d[m]=true else return nil,\"unrecognized argument '-\"..m..\"'\"end end else if g.stopProcessingOnPositionalArgument then local j=table.pack(...)local k=#d+1;for l=0,j.n-h do d[k+l]=j[h+l]end;break else d[#d+1]=i end end end;if f then return nil,\"no parameter passed to argument '\"..f..\"'\"end;return d end;function b.timer(n)a(1,n,\"number\")return b.syscall.timer(n)end;function b.alarm(n)a(1,n,\"number\")return b.syscall.alarm(n)end;function b.cancel(o)a(1,o,\"number\")return b.syscall.cancel(o)end;function b.sleep(n)a(1,n,\"number\")local p=b.syscall.timer(n)repeat local q,r=coroutine.yield()until q==\"timer\"and r.id==p end;function b.pullEvent()return coroutine.yield()end;function b.filterEvent(...)local s={...}for h,t in ipairs(s)do a(h,t,\"string\")end;while true do local u,r=coroutine.yield()for v,t in ipairs(s)do if u==t then return u,r end end end end;function b.queueEvent(u,r)a(1,u,\"string\")a(2,r,\"table\")return b.syscall.queueEvent(u,r)end;function b.split(w,x,y)a(1,w,\"string\")a(2,x,\"string\",\"nil\")local z={}if y then local k,m=1,w:find(\"[\"..x..\"]\")while k do z[#z+1]=w:sub(k,m and m-1)k=m and m+1;m=w:find(\"[\"..x..\"]\",k)end else for A in w:gmatch(\"[^\"..(x or\"%s\")..\"]+\")do z[#z+1]=A end end;return z end;function b.copy(B)if type(B)==\"table\"then local d=setmetatable({},b.copy(getmetatable(B)))for C,t in pairs(B)do d[b.copy(C)]=b.copy(t)end;return d else return B end end;local D={}function b.addEventListener(u,E)a(1,u,\"string\")a(2,E,\"function\")D[u]=D[u]or{}D[u][#D[u]+1]=E end;function b.removeEventListener(u,E)a(1,u,\"string\")a(2,E,\"function\")if D[u]then for C,t in ipairs(D[u])do if t==E then table.remove(D[u],C)return end end end end;function b.runEvents()while true do local u,r=coroutine.yield()if D[u]then for v,t in ipairs(D[u])do local F,G=pcall(t,u,r)if not F then return G end;if G then break end end end end end;function b.startEvents()return b.syscall.newthread(b.runEvents)end;function b.type(B)local z=type(B)if z==\"table\"then local H=getmetatable(B)if H and H.__name then return H.__name end end;return z end;local I={[0xEDB88320]={[0]=0x00000000,0x77073096,0xee0e612c,0x990951ba,0x076dc419,0x706af48f,0xe963a535,0x9e6495a3,0x0edb8832,0x79dcb8a4,0xe0d5e91e,0x97d2d988,0x09b64c2b,0x7eb17cbd,0xe7b82d07,0x90bf1d91,0x1db71064,0x6ab020f2,0xf3b97148,0x84be41de,0x1adad47d,0x6ddde4eb,0xf4d4b551,0x83d385c7,0x136c9856,0x646ba8c0,0xfd62f97a,0x8a65c9ec,0x14015c4f,0x63066cd9,0xfa0f3d63,0x8d080df5,0x3b6e20c8,0x4c69105e,0xd56041e4,0xa2677172,0x3c03e4d1,0x4b04d447,0xd20d85fd,0xa50ab56b,0x35b5a8fa,0x42b2986c,0xdbbbc9d6,0xacbcf940,0x32d86ce3,0x45df5c75,0xdcd60dcf,0xabd13d59,0x26d930ac,0x51de003a,0xc8d75180,0xbfd06116,0x21b4f4b5,0x56b3c423,0xcfba9599,0xb8bda50f,0x2802b89e,0x5f058808,0xc60cd9b2,0xb10be924,0x2f6f7c87,0x58684c11,0xc1611dab,0xb6662d3d,0x76dc4190,0x01db7106,0x98d220bc,0xefd5102a,0x71b18589,0x06b6b51f,0x9fbfe4a5,0xe8b8d433,0x7807c9a2,0x0f00f934,0x9609a88e,0xe10e9818,0x7f6a0dbb,0x086d3d2d,0x91646c97,0xe6635c01,0x6b6b51f4,0x1c6c6162,0x856530d8,0xf262004e,0x6c0695ed,0x1b01a57b,0x8208f4c1,0xf50fc457,0x65b0d9c6,0x12b7e950,0x8bbeb8ea,0xfcb9887c,0x62dd1ddf,0x15da2d49,0x8cd37cf3,0xfbd44c65,0x4db26158,0x3ab551ce,0xa3bc0074,0xd4bb30e2,0x4adfa541,0x3dd895d7,0xa4d1c46d,0xd3d6f4fb,0x4369e96a,0x346ed9fc,0xad678846,0xda60b8d0,0x44042d73,0x33031de5,0xaa0a4c5f,0xdd0d7cc9,0x5005713c,0x270241aa,0xbe0b1010,0xc90c2086,0x5768b525,0x206f85b3,0xb966d409,0xce61e49f,0x5edef90e,0x29d9c998,0xb0d09822,0xc7d7a8b4,0x59b33d17,0x2eb40d81,0xb7bd5c3b,0xc0ba6cad,0xedb88320,0x9abfb3b6,0x03b6e20c,0x74b1d29a,0xead54739,0x9dd277af,0x04db2615,0x73dc1683,0xe3630b12,0x94643b84,0x0d6d6a3e,0x7a6a5aa8,0xe40ecf0b,0x9309ff9d,0x0a00ae27,0x7d079eb1,0xf00f9344,0x8708a3d2,0x1e01f268,0x6906c2fe,0xf762575d,0x806567cb,0x196c3671,0x6e6b06e7,0xfed41b76,0x89d32be0,0x10da7a5a,0x67dd4acc,0xf9b9df6f,0x8ebeeff9,0x17b7be43,0x60b08ed5,0xd6d6a3e8,0xa1d1937e,0x38d8c2c4,0x4fdff252,0xd1bb67f1,0xa6bc5767,0x3fb506dd,0x48b2364b,0xd80d2bda,0xaf0a1b4c,0x36034af6,0x41047a60,0xdf60efc3,0xa867df55,0x316e8eef,0x4669be79,0xcb61b38c,0xbc66831a,0x256fd2a0,0x5268e236,0xcc0c7795,0xbb0b4703,0x220216b9,0x5505262f,0xc5ba3bbe,0xb2bd0b28,0x2bb45a92,0x5cb36a04,0xc2d7ffa7,0xb5d0cf31,0x2cd99e8b,0x5bdeae1d,0x9b64c2b0,0xec63f226,0x756aa39c,0x026d930a,0x9c0906a9,0xeb0e363f,0x72076785,0x05005713,0x95bf4a82,0xe2b87a14,0x7bb12bae,0x0cb61b38,0x92d28e9b,0xe5d5be0d,0x7cdcefb7,0x0bdbdf21,0x86d3d2d4,0xf1d4e242,0x68ddb3f8,0x1fda836e,0x81be16cd,0xf6b9265b,0x6fb077e1,0x18b74777,0x88085ae6,0xff0f6a70,0x66063bca,0x11010b5c,0x8f659eff,0xf862ae69,0x616bffd3,0x166ccf45,0xa00ae278,0xd70dd2ee,0x4e048354,0x3903b3c2,0xa7672661,0xd06016f7,0x4969474d,0x3e6e77db,0xaed16a4a,0xd9d65adc,0x40df0b66,0x37d83bf0,0xa9bcae53,0xdebb9ec5,0x47b2cf7f,0x30b5ffe9,0xbdbdf21c,0xcabac28a,0x53b39330,0x24b4a3a6,0xbad03605,0xcdd70693,0x54de5729,0x23d967bf,0xb3667a2e,0xc4614ab8,0x5d681b02,0x2a6f2b94,0xb40bbe37,0xc30c8ea1,0x5a05df1b,0x2d02ef8d}}function b.crc32(w,J,K)a(1,w,\"string\")J=a(2,J,\"table\",\"number\",\"nil\")or 0xEDB88320;K=a(3,K,\"number\",\"nil\")or 0xFFFFFFFF;local L=type(J)==\"table\"and J or I[J]if not L then L={}for h=0,255 do local M=h;for v=1,8 do if bit32.btest(M,1)then M=bit32.bxor(bit32.rshift(M,1),J)else M=bit32.rshift(M,1)end end;L[h]=M end;I[J]=L end;for h=1,#w do K=bit32.bxor(L[bit32.band(bit32.bxor(w:byte(h),bit32.band(K,0xFF)))],bit32.rshift(K,8))end;return bit32.bnot(K)end;return b\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292780,size=91282},["tar.lua"]={type="file",created=1740881294120,worldPermissions={execute=false,read=true,write=false},data="local a=require\"system.filesystem\"local function b(c)return string.match(c,'^()[%s%z]*$')and''or string.match(c,'^[%s%z]*(.*[^%s%z])')end;local function d(e,f,g)return string.len(e)<f and string.sub(e,1,f)..string.rep(g or\" \",f-string.len(e))or e end;local function h(i,j,...)if j and i[j]==nil then i[j]={}end;return j~=nil and h(i[j],...)or i end;local function k(e,l)local i={}for c in string.gmatch(e,\"([^\"..(l or\"%s\")..\"]+)\")do table.insert(i,c)end;return i end;local function m(n)return 0x38+(n.worldPermissions.read and 4 or 0)+(n.worldPermissions.write and 2 or 0)+(n.worldPermissions.execute and 1 or 0)+(n.permissions[n.owner].read and 256 or 0)+(n.permissions[n.owner].write and 128 or 0)+(n.permissions[n.owner].execute and 64 or 0)end;local o={verbosity=0,ignore_zero=false}function o.unserialize(p)local q={}local r={}for s,t in pairs(p)do local u=k(t.name,\"/\")local v=table.remove(u,table.maxn(u))local w=h(q,table.unpack(u))if t.type==0 or t.type==7 then w[v]=t elseif t.type==1 or t.type==2 then table.insert(r,t)elseif t.type==5 then w[v]={[\"//\"]=t}end end;for s,t in pairs(r)do local u=k(t.name,\"/\")local v=table.remove(u,table.maxn(u))h(q,table.unpack(u))[v]=h(q,table.unpack(k(t.link,\"/\")))end;return q end;function o.serialize(p)local q=p[\"//\"]~=nil and#p[\"//\"]>0 and{p[\"//\"]}or{}for s,t in pairs(p)do if s~=\"//\"then if t[\"//\"]~=nil or t.name==nil then local i=table.maxn(q)for x,y in ipairs(o.serialize(t))do q[i+x]=y end else table.insert(q,t)end end end;return q end;function o.load(z,A,B)if not B and not a.exists(z)then error(\"Path does not exist\",2)end;local C;if B then local c=1;C={read=function(D)if D then c=c+D;return string.sub(z,c-D,c-1)end;c=c+1;return string.byte(string.sub(z,c-1,c-1))end,close=function()end,seek=true}else C=a.open(z,\"rb\")end;local E=C.read;local F=0;local G=0;C.read=function(g)g=g or 1;if g<1 then return end;local q=nil;q=E(g)for H in q:gmatch(\".\")do F=F+H:byte()end;G=G+g;return q end;local q={}local I=0;while true do local p={}F=0;p.name=C.read(100)assert(G%512==100)if p.name==nil then break elseif p.name==string.rep(\"\\0\",100)then C.read(412)assert(G%512==0)I=I+1;if I==2 and not o.ignore_zero then break end else p.name=b(p.name)p.mode=tonumber(b(C.read(8)),8)p.owner=tonumber(b(C.read(8)),8)p.group=tonumber(b(C.read(8)),8)local J=tonumber(b(C.read(12)),8)p.timestamp=tonumber(b(C.read(12)),8)local K=F;local L=tonumber(b(C.read(8)),8)F=K+256;local i=C.read()p.type=tonumber(i==\"\\0\"and\"0\"or i)or i;p.link=b(C.read(100))if b(C.read(6))==\"ustar\"then C.read(2)p.ownerName=b(C.read(32))p.groupName=b(C.read(32))p.deviceNumber={tonumber(b(C.read(8))),tonumber(b(C.read(8)))}if p.deviceNumber[1]==nil and p.deviceNumber[2]==nil then p.deviceNumber=nil end;p.name=b(C.read(155))..p.name end;C.read(512-G%512)assert(G%512==0)if F~=L then print(\"Warning: checksum mismatch for \"..p.name)end;if J~=nil then if J==0 then p.data=\"\"else p.data=C.read(J)or\"\"if J%512~=0 then C.read(512-G%512)end end end;assert(G%512==0)table.insert(q,p)end end;C.close()return A and q or o.unserialize(q)end;function o.extract(p,z,M)a.mkdir(z)local r={}for s,t in pairs(p)do if s~=\"//\"then local N=a.combine(z,s)if t[\"//\"]~=nil then local x=o.extract(t,N,true)for O,y in pairs(x)do table.insert(r,y)end elseif t.type==1 or t.type==2 then table.insert(r,t)elseif t.type==0 or t.type==7 then local C=a.open(N,\"wb\")C.write(t.data)C.close()if t.owner~=nil then a.chmod(N,nil,bit32.band(t.mode,7))if t.ownerName~=nil and t.ownerName~=\"\"then a.chmod(N,t.ownerName,bit32.band(bit32.rshift(t.mode,3),7))a.chown(N,t.ownerName)elseif t.owner==0 then a.chmod(N,\"root\",bit32.band(bit32.rshift(t.mode,3),7))a.chown(N,\"root\")end end elseif t.type~=nil then print(\"Unimplemented type \"..t.type)end;if o.verbosity>0 then print((t[\"//\"]and t[\"//\"].name or t.name or\"?\")..\" => \"..(N or\"?\"))end end end;if M then return r else for s,t in pairs(r)do end end end;function o.read(P,N)local z=a.combine(P,N)local n=a.stat(z)if not n then return nil end;local C=a.open(z,\"rb\")local q={name=N,mode=m(n),owner=0,group=0,timestamp=n.modified,type=0,link=\"\",ownerName=n.owner,groupName=\"\",deviceNumber=nil,data=C.readAll()}C.close()return q end;function o.pack(P,z)local n=a.stat(a.combine(P,z))if n.type~=\"directory\"then return o.read(P,z)end;local q={[\"//\"]={name=z..\"/\",mode=m(n),owner=0,group=0,timestamp=n.modified,type=5,link=\"\",ownerName=n.owner,groupName=\"\",deviceNumber=nil,data=nil}}if string.sub(P,-1)==\"/\"then P=string.sub(P,1,-1)end;if z and string.sub(z,1,1)==\"/\"then z=string.sub(z,2)end;if z and string.sub(z,-1)==\"/\"then z=string.sub(z,1,-1)end;local N=z and P..\"/\"..z or P;for s,t in pairs(a.list(N))do if a.isDir(a.combine(N,t))then q[t]=o.pack(P,z and z..\"/\"..t or t)else q[t]=o.read(P,z and z..\"/\"..t or t)end;if o.verbosity>0 then print(a.combine(N,t)..\" => \"..(z and z..\"/\"..t or t))end end;return q end;function o.save(p,z,A)if not A then p=o.serialize(p)end;local Q=z==nil;local C;local G=0;if not Q then C=a.open(z,\"wb\")local R=C.write;C.write=function(e)for g in string.gmatch(e,\".\")do R(string.byte(g))end;G=G+string.len(e)end else C=\"\"end;for s,t in pairs(p)do local S=\"\"S=S..d(string.sub(t.name,-100),100,\"\\0\")S=S..(t.mode and string.format(\"%07o\\0\",t.mode)or string.rep(\"\\0\",8))S=S..(t.owner and string.format(\"%07o\\0\",t.owner)or string.rep(\"\\0\",8))S=S..(t.group and string.format(\"%07o\\0\",t.group)or string.rep(\"\\0\",8))S=S..(t.data and string.format(\"%011o\\0\",string.len(t.data))or string.rep(\"0\",11)..\"\\0\")S=S..(t.timestamp and string.format(\"%011o\\0\",t.timestamp)or string.rep(\"\\0\",12))S=S..t.type;S=S..(t.link and d(t.link,100,\"\\0\")or string.rep(\"\\0\",100))S=S..\"ustar  \\0\"S=S..(t.ownerName and d(t.ownerName,32,\"\\0\")or string.rep(\"\\0\",32))S=S..(t.groupName and d(t.groupName,32,\"\\0\")or string.rep(\"\\0\",32))S=S..(t.deviceNumber and t.deviceNumber[1]and string.format(\"%07o\\0\",t.deviceNumber[1])or string.rep(\"\\0\",8))S=S..(t.deviceNumber and t.deviceNumber[2]and string.format(\"%07o\\0\",t.deviceNumber[2])or string.rep(\"\\0\",8))S=S..(string.len(t.name)>100 and d(string.sub(t.name,1,-101),155,\"\\0\")or string.rep(\"\\0\",155))if string.len(S)<504 then S=S..string.rep(\"\\0\",504-string.len(S))end;local F=256;for g in string.gmatch(S,\".\")do F=F+string.byte(g)end;S=string.sub(S,1,148)..string.format(\"%06o\\0 \",F)..string.sub(S,149)if Q then C=C..S else C.write(S)end;if t.data~=nil and t.data~=\"\"then if Q then C=C..d(t.data,math.ceil(string.len(t.data)/512)*512,\"\\0\")else C.write(d(t.data,math.ceil(string.len(t.data)/512)*512,\"\\0\"))end end end;if Q then C=C..string.rep(\"\\0\",1024)else C.write(string.rep(\"\\0\",1024))end;if Q then C=C..string.rep(\"\\0\",10240-string.len(C)%10240)else C.write(string.rep(\"\\0\",10240-G%10240))end;if not Q then C.close()end;if Q then return C end end;return o\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881294110,size=6722},["startmgr.lua"]={type="file",created=1740881294012,worldPermissions={execute=false,read=true,write=false},data="local a=require\"system.expect\"local b=require\"system.ipc\"local c=require\"system.process\"local d={}local function e(f,g,h)h=h or c.getuser()local i=b.lookup(h==\"root\"and\"ServiceManager\"or\"ServiceManager.\"..h)if not i then error(\"Could not connect to service manager\",2)end;b.sendEvent(i,\"startmgr.request\",{func=f,param=g})while true do local j,k=b.receiveEvent(i,\"startmgr.response\",5)if not k then error(\"Timed out waiting for service manager\",2)end;if k.func==f then if k.ok then return table.unpack(k.result)else error(k.error,3)end end end end;function d.start(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"start\",l,h)end;function d.stop(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"stop\",l,h)end;function d.kill(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"kill\",l,h)end;function d.restart(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"restart\",l,h)end;function d.reload(l,h)a(1,l,\"string\",\"nil\")a(2,h,\"string\",\"nil\")return e(\"reload\",l,h)end;function d.add(m,h)a(1,m,\"string\")a(2,h,\"string\",\"nil\")return e(\"add\",m,h)end;function d.remove(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"remove\",l,h)end;function d.list(h)a(1,h,\"string\",\"nil\")return e(\"list\",nil,h)end;function d.status(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"status\",l,h)end;function d.install(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"install\",l,h)end;function d.uninstall(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"uninstall\",l,h)end;function d.shutdown()if c.getuser()~=\"root\"then error(\"Permission denied\")end;return e(\"shutdown\",{},\"root\")end;function d.reboot()if c.getuser()~=\"root\"then error(\"Permission denied\")end;return e(\"reboot\",{},\"root\")end;return d\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881293993,size=1682},["libcraftos.a"]={type="file",created=1740881292595,worldPermissions={execute=false,read=true,write=false},data="!<arch>\ncolors.lua/     0           0     0     644     669       `\nlocal a=require\"cc.expect\"local b={white=0,orange=1,magenta=2,lightBlue=3,yellow=4,lime=5,pink=6,gray=7,lightGray=8,cyan=9,purple=10,blue=11,brown=12,green=13,red=14,black=15}function b.combine(...)return math.max(...)end;function b.subtract(...)return math.min(...)end;function b.test(c,d)return c==d end;function b.packRGB(e,f,d)a(1,e,\"number\")a(2,f,\"number\")a(3,d,\"number\")return bit32.bor(bit32.lshift(e*255,16),bit32.lshift(f*255,8),d*255)end;function b.unpackRGB(g)a(1,g,\"number\")return bit32.band(bit32.rshift(g,16),0xFF)/255,bit32.band(bit32.rshift(g,8),0xFF)/255,bit32.band(g,0xFF)/255 end;function b.toBlit(h)a(1,h,\"number\")return(\"%x\"):format(h)end;return b\n\ncolours.lua/    0           0     0     644     669       `\nlocal a=require\"cc.expect\"local b={white=0,orange=1,magenta=2,lightBlue=3,yellow=4,lime=5,ping=6,grey=7,lightGrey=8,cyan=9,purple=10,blue=11,brown=12,green=13,red=14,black=15}function b.combine(...)return math.max(...)end;function b.subtract(...)return math.min(...)end;function b.test(c,d)return c==d end;function b.packRGB(e,f,d)a(1,e,\"number\")a(2,f,\"number\")a(3,d,\"number\")return bit32.bor(bit32.lshift(e*255,16),bit32.lshift(f*255,8),d*255)end;function b.unpackRGB(g)a(1,g,\"number\")return bit32.band(bit32.rshift(g,16),0xFF)/255,bit32.band(bit32.rshift(g,8),0xFF)/255,bit32.band(g,0xFF)/255 end;function b.toBlit(h)a(1,h,\"number\")return(\"%x\"):format(h)end;return b\n\ndisk.lua/       0           0     0     644     1517      `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"local function c(d)local e=b.devinfo(d)return e and e.types.drive end;local f={}function f.isPresent(d)a(1,d,\"string\")return b.devlookup(d)~=nil and b.devinfo(d).types.drive and b.devcall(d,\"getState\")~=nil end;function f.getLabel(d)a(1,d,\"string\")if not c(d)then return nil end;local g=b.devcall(d,\"getState\")return g and g.label end;function f.setLabel(d,h)a(1,d,\"string\")a(2,h,\"string\",\"nil\")if not c(d)then return end;b.devcall(d,\"setLabel\",h)end;function f.hasData(d)a(1,d,\"string\")if not c(d)then return false end;local g=b.devcall(d,\"getState\")return g and not g.isAudio end;function f.getMountPath(d)a(1,d,\"string\")local e=b.devinfo(d)if not e or not e.types.drive then return nil end;local i=b.mountlist()for j,k in ipairs(i)do if k.type==\"drivefs\"and k.uuid==e.uuid then return k.path end end;return nil end;function f.hasAudio(d)a(1,d,\"string\")if not c(d)then return false end;local g=b.devcall(d,\"getState\")return g and g.audio~=nil end;function f.getAudioTitle(d)a(1,d,\"string\")if not c(d)then return nil end;local g=b.devcall(d,\"getState\")return g and g.audio end;function f.playAudio(d)a(1,d,\"string\")if not c(d)then return end;b.devcall(d,\"play\")end;function f.stopAudio(d)a(1,d,\"string\")if not c(d)then return end;b.devcall(d,\"stop\")end;function f.eject(d)a(1,d,\"string\")if not c(d)then return end;b.devcall(d,\"eject\")end;function f.getID(d)a(1,d,\"string\")if not c(d)then return nil end;local g=b.devcall(d,\"getState\")return g and g.id end;return f\n\nfs.lua/         0           0     0     644     3003      `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"local c={}function c.list(d)a(1,d,\"string\")return b.list(d)end;function c.exists(d)a(1,d,\"string\")return b.stat(d)~=nil end;function c.isDir(d)a(1,d,\"string\")local e=b.stat(d)return e~=nil and e.type==\"directory\"end;function c.isReadOnly(d)a(1,d,\"string\")local e=b.stat(d)while e==nil do d=c.getDir(d)e=b.stat(d)end;local f=b.getuser()if e.permissions[f]then return not e.permissions[f].write else return not e.worldPermissions.write end end;function c.getName(d)a(1,d,\"string\")return b.combine(d):match\"[^/]+$\"end;function c.getDrive(d)a(1,d,\"string\")local e=b.stat(d)return e and(e.mountpoint==\"/\"and\"hdd\"or e.mountpoint:gsub(\"^/\",\"\"))end;function c.getSize(d)a(1,d,\"string\")local e=b.stat(d)return e and e.size end;function c.getFreeSpace(d)a(1,d,\"string\")local e=b.stat(d)while e==nil do d=c.getDir(d)e=b.stat(d)end;return e and e.freeSpace end;function c.makeDir(d)a(1,d,\"string\")return b.mkdir(d)end;function c.move(g,h)a(1,g,\"string\")a(2,h,\"string\")local i=assert(b.stat(g),\"No such file or directory\")local d=h;local j=b.stat(d)if j then error(\"File exists\",2)end;while j==nil do d=c.getDir(d)j=b.stat(d)end;if i.mountpoint==j.mountpoint then return b.rename(g,h)end;c.copy(g,h)b.remove(g)end;function c.copy(g,h)a(1,g,\"string\")a(2,h,\"string\")local e=b.stat(g)if e.type==\"directory\"then local k=b.list(g)b.mkdir(h)for l,m in ipairs(k)do c.copy(b.combine(g,m),b.combine(h,m))end else local n,o=b.open(g,\"rb\")if not n then error(o,2)end;local p,o=b.open(h,\"wb\")if not p then n.close()error(o,2)end;repeat local q=n.read(512)if q then p.write(q)end until not q;p.close()n.close()end end;function c.delete(d)a(1,d,\"string\")return b.remove(d)end;function c.combine(...)return b.combine(...)end;function c.open(d,r)a(1,d,\"string\")a(2,r,\"string\")return b.open(d,r)end;local function s(t,u,v)if v>#u then return{}end;local w=u[v]:gsub(\"[%^%$%(%)%%%.%+%-]\",\"%%%1\"):gsub(\"%*\",\".*\"):gsub(\"%?\",\".\"):gsub(\"%[!\",\"[^\")local x={}for l,y in ipairs(t)do local z,A=pcall(b.list,y)if z then for l,d in ipairs(A)do if d:match(w)then x[#x+1]=b.combine(y,d)end end end end;if v+1>#u then return x end;return s(x,u,v+1)end;function c.find(B)a(1,B,\"string\")local C={}for D in B:gmatch(\"[^/]+\")do C[#C+1]=D end;local E=s({B:sub(1,1)==\"/\"and\"/\"or\".\"},C,1)table.sort(E)return E end;function c.getDir(d)a(1,d,\"string\")local D=b.combine(d):match\"^(.*)/[^/]*$\"or\"\"if D==\"\"then if d:sub(1,1)==\"/\"then return\"/\"else return\".\"end else return D end end;function c.complete(F,d,G,H)end;function c.attributes(d)a(1,d,\"string\")local e=b.stat(d)if not e then return nil end;e.isDir=e.type==\"directory\"local f=b.getuser()if e.permissions[f]then e.isReadOnly=not e.permissions[f].write else e.isReadOnly=not e.worldPermissions.write end end;function c.getCapacity(d)a(1,d,\"string\")local e=b.stat(d)while e==nil do d=c.getDir(d)e=b.stat(d)end;return e and e.capacity end;function c.isDriveRoot(d)a(1,d,\"string\")local e=b.stat(d)return e~=nil and b.combine(d)==e.mountpoint end;return c\n\ngps.lua/        0           0     0     644     53        `\nlocal a={}function a.locate()return nil end;return a\n\n_handles.lua/   0           0     0     644     39        `\nreturn{http={},websocket={},rednet={}}\n\nhelp.lua/       0           0     0     644     698       `\nlocal a=require\"cc.expect\"local b=require\"fs\"local c={}local d=\"/usr/share/man/*:/usr/local/share/man/*\"function c.path()return d end;function c.setPath(e)a(1,e,\"string\")d=e end;function c.lookup(f)a(1,f,\"string\")for g in d:gmatch\"[^:]+\"do local h=b.find(b.combine(g,f..\".*\"))if#h>0 then return table.unpack(h)end end;return nil end;function c.topics()local i={}for g in d:gmatch\"[^:]+\"do for j in ipairs(b.find(g))do for k,l in ipairs(b.list(j))do i[#i+1]=l:gsub(\"%..*$\",\"\")end end end;return i end;function c.completeTopic(f)a(1,f,\"string\")local i={}for g in d:gmatch\"[^:]+\"do for k,l in ipairs(b.find(b.combine(g,f..\"*\")))do i[#i+1]=l:match(f..\"([^/%.]+)%.?[^/]*$\")end end;return i end;return c\nhttp.lua/       0           0     0     644     3221      `\nlocal a=require\"cc.expect\"local b=require\"_handles\"local c=require\"_syscall\"local d=require\"craftos.os\"local e={}local function f(g)local h={}function h.read(i)return g:read(i or 1)end;function h.readLine(j)return g:read(j and\"*L\"or\"*l\")end;function h.readAll()return g:read(\"*a\")end;function h.getResponseCode()return g:responseCode()end;function h.getResponseHeaders()return g:responseHeaders()end;function h.close()return g:close()end;return h end;local function k(g,l)local h={}function h.send(m,n)return g:write(m)end;function h.receive(o)local p;if o then p=d.startTimer(o)end;while true do if g.status==\"closed\"then error('attempt to use a closed file',2)end;local q,r,s=d.pullEvent()if q=='websocket_message'and r==l then return s elseif q=='websocket_closed'and r==l and g.status==\"closed\"then return nil elseif q=='timer'and r==p then return nil end end end;function h.close()return g:close()end;return h end;function e.get(r,t,n)a(1,r,\"string\",\"table\")if type(r)==\"string\"then r={url=r,headers=t,binary=n}end;a.field(r,\"url\",\"string\")a.field(r,\"headers\",\"table\",\"nil\")a.field(r,\"binary\",\"boolean\",\"nil\")a.field(r,\"method\",\"string\",\"nil\")a.field(r,\"redirect\",\"boolean\",\"nil\")r.method=\"GET\"return e.post(r)end;function e.post(r,u,t,n)a(1,r,\"string\",\"table\")if type(r)==\"string\"then r={url=r,body=u,headers=t,binary=n}end;a.field(r,\"url\",\"string\")a.field(r,\"body\",\"string\",\"nil\")a.field(r,\"headers\",\"table\",\"nil\")a.field(r,\"binary\",\"boolean\",\"nil\")a.field(r,\"method\",\"string\",\"nil\")a.field(r,\"redirect\",\"boolean\",\"nil\")r.encoding=r.binary and\"binary\"or\"utf8\"local g,v=c.connect(r)if not g then return nil,v end;local w=f(g)b.http[g.id]={url=r.url,handle=g,craftos=w}if r.body then g:write(r.body)else g:write()end;while true do local x,y=d.pullEvent()if x==\"http_success\"and y==r.url then return w elseif x==\"http_failure\"and y==r.url then return nil,g.error,w end end end;function e.request(r,u,t,n)a(1,r,\"string\",\"table\")if type(r)==\"string\"then r={url=r,body=u,headers=t,binary=n}end;a.field(r,\"url\",\"string\")a.field(r,\"body\",\"string\",\"nil\")a.field(r,\"headers\",\"table\",\"nil\")a.field(r,\"binary\",\"boolean\",\"nil\")a.field(r,\"method\",\"string\",\"nil\")a.field(r,\"redirect\",\"boolean\",\"nil\")r.encoding=r.binary and\"binary\"or\"utf8\"local g,v=c.connect(r)if not g then d.queueEvent(\"http_failure\",r.url,v)return false,v end;local w=f(g)b.http[g.id]={url=r.url,handle=g,craftos=w}if r.body then g:write(r.body)else g:write()end;return true end;function e.checkURLAsync(r)a(1,r,\"string\")local z=c.checkuri(r)d.queueEvent(\"http_check\",r,z)end;function e.checkURL(r)a(1,r,\"string\")return c.checkuri(r)end;function e.websocketAsync(r,t)a(1,r,\"string\")a(2,t,\"table\",\"nil\")local g,v=c.connect({url=r,headers=t})if not g then d.queueEvent(\"websocket_failure\",r.url,v)return false,v end;local w=k(g,r)b.websocket[g.id]={url=r.url,handle=g,craftos=w}return true end;function e.websocket(r,t)a(1,r,\"string\")a(2,t,\"table\",\"nil\")local g,v=c.connect({url=r,headers=t})if not g then return nil,v end;local w=k(g,r)b.websocket[g.id]={url=r.url,handle=g,craftos=w}while true do local x,y=d.pullEvent()if x==\"websocket_success\"and y==r.url then return w elseif x==\"websocket_failure\"and y==r.url then return nil,g.error end end end;return e\n\ninit.lua/       0           0     0     644     3570      `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"package.loaded.os=nil;local c=setmetatable({colors=require\"colors\",colours=require\"colours\",disk=require\"disk\",fs=require\"fs\",gps=require\"gps\",help=require\"help\",http=require\"http\",keys=require\"keys\",os=require\"os\",paintutils=require\"paintutils\",parallel=require\"parallel\",peripheral=require\"peripheral\",rednet=require\"rednet\",redstone=require\"redstone\",settings=require\"settings\",shell=require\"shell\",term=require\"term\",textutils=require\"textutils\",vector=require\"vector\",window=require\"window\"},{__index=_G})c.rs=c.redstone;c._HOST=b.cchost()c._CC_DEFAULT_SETTINGS=\"\"c.sleep=c.os.sleep;function c.write(d)a(1,d,\"string\")local e=0;local f,g=c.term.getSize()local function h(i)e=e+1;if i>g-1 then c.term.scroll(1)return i else return i+1 end end;while#d>0 do local j=d:find(\"\\n\")or#d;local k=d:sub(1,j)d=d:sub(#k+1)local l=k:sub(-1)==\"\\n\"if l then k=k:sub(1,-2)end;local m,i=c.term.getCursorPos()while#k>0 do if m>f then c.term.setCursorPos(1,h(i))m,i=c.term.getCursorPos()end;local n=k:sub(1,f-m+1)c.term.write(n)k=k:sub(#n+1)m,i=c.term.getCursorPos()end;if l then c.term.setCursorPos(1,h(i))end end;return e end;function c.print(...)local o=table.pack(...)for p=1,o.n,1 do o[p]=tostring(o[p])end;return c.write(table.concat(o,\"  \")..\"\\n\")end;function c.printError(...)local q=c.term.getTextColor()c.term.setTextColor(c.colors.red)print(...)c.term.setTextColor(q)end;local r={}function c.read(s,t,u,v)a(1,s,\"string\",\"nil\")a(2,t,\"table\",\"nil\")a(3,u,\"function\",\"nil\")a(4,v,\"string\",\"nil\")if s then s=s:sub(1,1)end;local w=t or{}t={}for p=1,#w,1 do t[p]=w[p]end;local x=v or\"\"local y=x;t[#t+1]=x;local z=#t;local A=0;local B,C=c.term.getCursorPos()local f,g=c.term.getSize()local D=false;local E={}local F=0;local function G()if E[F]then c.write((\" \"):rep(#E[F]))end end;local function H(I)if I or D then if u and x~=y then E=u(x)or r;F=math.min(1,#E)end;y=x;c.term.setCursorPos(B,C)local d=x;if s then d=s:rep(#d)end;local J=c.write(d)if E[F]then local K=c.term.getTextColor()local L=c.term.getBackgroundColor()c.term.setTextColor(c.colors.white)c.term.setBackgroundColor(c.colors.gray)J=J+c.write(E[F])c.term.setTextColor(K)c.term.setBackgroundColor(L)else J=J+c.write(\" \")end;if C+J>g then C=C-(C+J-g)end end;local m,i=B,C;m=m+#x-A;while m>f do m=m-f;i=i+1 end;c.term.setCursorPos(m,i)end;c.term.setCursorBlink(true)while true do H()local M,N=c.os.pullEvent()if M==\"char\"then D=true;G()if A==0 then x=x..N elseif A==#x then x=N..x else x=x:sub(0,-A-1)..N..x:sub(-A)end elseif M==\"paste\"then D=true;G()if A==0 then x=x..N elseif A==#x then x=N..x else x=x:sub(0,-A-1)..N..x:sub(-A+#id-1)end elseif M==\"key\"then local id=c.keys.getName(N)if id==\"backspace\"and#x>0 then D=true;if A==0 then x=x:sub(1,-2)G()elseif A<#x then x=x:sub(0,-A-2)..x:sub(-A)end elseif id==\"delete\"and A>0 then D=true;if A==#x then x=x:sub(2)elseif A==1 then x=x:sub(1,-2)else x=x:sub(0,-A-1)..x:sub(-A+1)end;A=A-1 elseif id==\"up\"then if#E>1 then D=true;G()if F>1 then F=F-1 else F=#E end elseif z>1 then A=0;t[z]=x;z=z-1;x=(\" \"):rep(#x)H(true)x=t[z]D=true end elseif id==\"down\"then if#E>1 then D=true;G()if F<#E then F=F+1 else F=1 end elseif z<#t then A=0;t[z]=x;z=z+1;x=(\" \"):rep(#x)H(true)x=t[z]D=true end elseif id==\"left\"then if A<#x then G()A=A+1 end elseif id==\"right\"then if A>0 then A=A-1 elseif F>0 then D=true;x=x..E[F]end elseif id==\"tab\"then if F>0 then D=true;x=x..E[F]end elseif id==\"home\"then A=#x elseif id==\"end\"then A=0 elseif id==\"enter\"then G()c.write(\"\\n\")break end end end;c.term.setCursorBlink(false)return x end;return c\nkeys.lua/       0           0     0     644     1330      `\nlocal a={}for b=0x61,0x7A do a[string.char(b)]=b end;for b=0x81,0x99 do a[\"f\"..bit32.band(b,31)]=b end;for b=0xA0,0xA9 do a[\"numPad\"..bit32.band(b,15)]=b end;a.backspace=0x08;a.tab=0x09;a.enter=0x0A;a.space=0x20;a.apostrophe=0x27;a.comma=0x2C;a.minus=0x2D;a.period=0x2E;a.slash=0x2F;a.zero=0x30;a.one=0x31;a.two=0x32;a.three=0x33;a.four=0x34;a.five=0x35;a.six=0x36;a.seven=0x37;a.eight=0x38;a.nine=0x39;a.semicolon=0x3B;a.equals=0x3D;a.leftBracket=0x5B;a.backslash=0x5C;a.rightBracket=0x5D;a.grave=0x60;a.delete=0x7F;a.insert=0x80;a.convert=0x9A;a.noconvert=0x9B;a.kana=0x9C;a.kanji=0x9D;a.yen=0x9E;a.numPadDecimal=0x9F;a.numPadAdd=0xAA;a.numPadSubtract=0xAB;a.numPadMultiply=0xAC;a.numPadDivide=0xAD;a.numPadEqual=0xAE;a.numPadEnter=0xAF;a.leftCtrl=0xB0;a.rightCtrl=0xB1;a.leftAlt=0xB2;a.rightAlt=0xB3;a.leftShift=0xB4;a.rightShift=0xB5;a.leftSuper=0xB6;a.rightSuper=0xB7;a.capsLock=0xB8;a.numLock=0xB9;a.scrollLock=0xBA;a.printScreen=0xBB;a.pause=0xBC;a.menu=0xBD;a.stop=0xBE;a.ax=0xBF;a.up=0xC0;a.down=0xC1;a.left=0xC2;a.right=0xC3;a.pageUp=0xC4;a.pageDown=0xC5;a.home=0xC6;a[\"end\"]=0xC7;a.circumflex=0xC8;a.at=0xC9;a.colon=0xCA;a.underscore=0xCB;local c={}for d,e in pairs(a)do c[e]=d end;function a.getName(f)if type(f)~=\"number\"then error(\"bad argument #1 (expected number, got \"..type(f)..\")\",2)end;return c[f]end;return a\nos.lua/         0           0     0     644     4668      `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"local c=require\"_handles\"local d=os;local os={date=d.date}function os.loadAPI(e)a(1,e,\"string\")local f=setmetatable({},{__index=_G})local g=loadfile(e,nil,f)if not g then return false end;if not pcall(g)then return false end;setmetatable(f,nil)_G[e:match(\"([^/]+)%.lua$\")or e:match(\"[^/]+\")]=f;return true end;function os.unloadAPI(h)_G[h]=nil end;function os.pullEvent(i)local j=table.pack(os.pullEventRaw(i))if j[1]==\"terminate\"then error(\"Terminated\",2)end;return table.unpack(j,1,j.n)end;function os._convertEvent(k,l)local j;if k==\"alarm\"or k==\"timer\"then j={k,l.id,n=2}elseif k==\"char\"then j={\"char\",l.character,n=2}elseif k==\"disk\"or k==\"disk_eject\"or k==\"speaker_audio_empty\"or k==\"monitor_resize\"or k==\"device_added\"or k==\"device_removed\"then j={k,l.device,n=2}elseif k==\"key\"then j={\"key\",l.keycode,l.isRepeat,n=3}elseif k==\"key_up\"then j={\"key_up\",l.keycode,n=2}elseif k==\"modem_message\"then j={\"modem_message\",l.device,l.channel,l.replyChannel,l.message,l.distance,n=6}elseif k==\"mouse_click\"or k==\"mouse_drag\"or k==\"mouse_up\"or k==\"mouse_move\"then j={k,l.button,l.x,l.y,n=4}elseif k==\"mouse_scroll\"then j={\"mouse_scroll\",l.direction,l.x,l.y,n=4}elseif k==\"paste\"then j={\"paste\",l.text,n=2}elseif k==\"redstone\"or k==\"term_resize\"or k==\"turtle_inventory\"or k==\"terminate\"then j={k,n=1}elseif k==\"craftos_event\"then j=l elseif k==\"handle_status_change\"then if c.http[l.id]then if l.status==\"open\"then if math.floor(c.http[l.id].handle:responseCode()/100)~=2 then j={\"http_failure\",c.http[l.id].url,c.http[l.id].handle.error,c.http[l.id].craftos,n=4}else j={\"http_success\",c.http[l.id].url,c.http[l.id].craftos,n=3}end;c.http[l.id]=nil elseif l.status==\"error\"then j={\"http_failure\",c.http[l.id].url,c.http[l.id].handle.error,c.http[l.id].craftos,n=4}c.http[l.id]=nil end elseif c.websocket[l.id]then if l.status==\"open\"then j={\"websocket_success\",c.websocket[l.id].url,c.websocket[l.id].craftos,n=3}elseif l.status==\"error\"then j={\"websocket_failure\",c.websocket[l.id].url,c.websocket[l.id].error,n=3}elseif l.status==\"closed\"then j={\"websocket_closed\",c.websocket[l.id].url,n=2}c.websocket[l.id]=nil end end elseif k==\"handle_data_ready\"then if c.websocket[l.id]then j={\"websocket_message\",c.websocket[l.id].url,c.websocket[l.id].handle:read(\"*a\"),true,n=4}elseif c.rednet[l.id]then j={\"rednet_message\",c.rednet[l.id].id,c.rednet[l.id].handle:read(\"*a\"),n=3}end else j={\"phoenix_event\",k,l,n=3}end;return j end;function os.pullEventRaw(i)local j;repeat j=table.pack(coroutine.yield())if j.n==2 and type(j[1])==\"string\"and type(j[2])==\"table\"then local k,l=j[1],j[2]j=os._convertEvent(k,l)end until i==nil or j[1]==i or j[1]==\"terminate\"return table.unpack(j,1,j.n)end;function os.sleep(m)a(1,m,\"number\")local n=b.timer(m)repeat local j,l=os.pullEvent()until j==\"timer\"and l==n end;function os.version()return\"Phoenix \"..b.version()end;function os.run(f,e,...)a(1,f,\"table\")a(2,e,\"string\")setmetatable(f,{__index=_ENV})local g,o=loadfile(e,nil,f)if not g then return false end;local p,q=pcall(g,...)return p end;function os.queueEvent(h,...)a(1,h,\"string\")b.queueEvent(\"craftos_event\",table.pack(h,...))end;function os.startTimer(m)a(1,m,\"number\")return b.timer(m)end;function os.cancelTimer(r)a(1,r,\"number\")return b.cancel(r)end;os.cancelAlarm=os.cancelTimer;function os.setAlarm(m)a(1,m,\"number\")return b.alarm(m)end;function os.shutdown()b.devcall(\"/\",\"shutdown\")end;function os.reboot()b.devcall(\"/\",\"reboot\")end;function os.getComputerID()return b.devinfo(\"/\").metadata.id end;os.computerID=os.getComputerID;function os.getComputerLabel()return b.devcall(\"/\",\"getLabel\")end;os.computerLabel=os.getComputerLabel;function os.setComputerLabel(s)a(1,s,\"string\")return b.devcall(\"/\",\"setLabel\",s)end;function os.clock()return b.uptime()end;function os.time(t)a(1,t,\"string\",\"table\",\"nil\")if type(t)==\"table\"then return d.time(t)end;local u;if t==\"utc\"then u=os.date(\"!*t\")elseif t==\"local\"then u=os.date(\"*t\")elseif t==\"ingame\"or u==nil then u=os.date(\"?*t\")else error(\"Unsupported operation\",2)end;return u.hour+u.min/60+u.sec/3600 end;function os.day(t)a(1,t,\"string\",\"nil\")local u;if t==\"utc\"then u=os.date(\"!*t\")elseif t==\"local\"then u=os.date(\"*t\")elseif t==\"ingame\"or u==nil then u=os.date(\"?*t\")else error(\"Unsupported operation\",2)end;return math.floor((u.year-1970)*365.24)+u.yday end;function os.epoch(t)a(1,t,\"string\",\"nil\")if t==\"utc\"then return d.time()*1000 elseif t==\"local\"then return(d.time()+d.time(os.date(\"*t\"))-d.time(os.date(\"!*t\")))*1000 elseif t==\"ingame\"then return d.time\"ingame\"*1000 elseif t==\"nano\"then return d.time\"nano\"else error(\"Unsupported operation\",2)end end;return os\npaintutils.lua/ 0           0     0     644     2739      `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"local c=require\"term\"local d={}function d.drawPixel(e,f,g)a(1,e,\"number\")a(2,f,\"number\")local h,i=c.getCursorPos()local j=c.getBackgroundColor()c.setCursorPos(e,f)if g then c.setBackgroundColor(g)end;c.write(\" \")c.setCursorPos(h,i)c.setBackgroundColor(j)end;local function k(l,m,n,o,p)if math.abs(p-n)<math.abs(o-m)then if m>o then m,n,o,p=o,p,m,n end;local q,r,s=o-m,p-n,1;if r<0 then s,r=-1,-r end;local t,f=2*r-q,n;if s<0 then f=p;for e=o,m,-1 do l(e,f)if t>0 then f=f+1;t=t+2*(r-q)else t=t+2*r end end else for e=m,o do l(e,f)if t>0 then f=f+1;t=t+2*(r-q)else t=t+2*r end end end else if n>p then m,n,o,p=o,p,m,n end;local q,r,u=o-m,p-n,1;if q<0 then u,q=-1,-q end;local t,e=2*q-r,m;for f=n,p do l(e,f)if t>0 then e=e+u;t=t+2*(q-r)else t=t+2*q end end end end;function d.drawLine(m,n,o,p,g)a(1,m,\"number\")a(2,n,\"number\")a(3,o,\"number\")a(4,p,\"number\")a(5,g,\"number\")if n==p then local v=math.abs(o-m)+1;local w,x=c.getBackgroundColor(),c.getTextColor()local h,i=c.getCursorPos()local y,z=(\"%x\"):format(x),(\"%x\"):format(g)c.setCursorPos(m,n)c.blit((\" \"):rep(v),y:rep(v),z:rep(v))c.setCursorPos(h,i)c.setBackgroundColor(w)return end;local l,A;local j=c.getBackgroundColor()local h,i=c.getCursorPos()c.setBackgroundColor(g)l,A=function(e,f)c.setCursorPos(e,f)c.write(\" \")end,function()c.setBackgroundColor(j)c.setCursorPos(h,i)end;k(l,m,n,o,p)A()end;function d.drawBox(e,f,v,B,g)a(1,e,\"number\")a(2,f,\"number\")a(3,v,\"number\")a(4,B,\"number\")a(5,g,\"number\")local w,x=c.getBackgroundColor(),c.getTextColor()local h,i=c.getCursorPos()local y,z=(\"%x\"):format(x),(\"%x\"):format(g)c.setCursorPos(e,f)c.blit((\" \"):rep(v),y:rep(v),z:rep(v))c.setCursorPos(e,f+B-1)c.blit((\" \"):rep(v),y:rep(v),z:rep(v))for C=f+1,f+B-2 do c.setCursorPos(e,C)c.blit(\" \",y,z)c.setCursorPos(e+v-1,C)c.blit(\" \",y,z)end;c.setBackgroundColor(w)c.setCursorPos(h,i)end;function d.drawFilledBox(e,f,v,B,g)a(1,e,\"number\")a(2,f,\"number\")a(3,v,\"number\")a(4,B,\"number\")a(5,g,\"number\")local w,x=c.getBackgroundColor(),c.getTextColor()local h,i=c.getCursorPos()local D,y,z=(\" \"):rep(v),(\"%x\"):format(x):rep(v),(\"%x\"):format(g):rep(v)for C=f,f+B-1 do c.setCursorPos(e,C)c.blit(D,y,z)end;c.setBackgroundColor(w)c.setCursorPos(h,i)end;function d.drawImage(e,f,E)a(1,e,\"number\")a(2,f,\"number\")a(3,E,\"table\")for F,G in ipairs(E)do c.setCursorPos(e,f+F-1)for H,j in ipairs(G)do c.setBackgroundColor(j)c.write(\" \")end end end;function d.parseImage(E)a(1,E,\"string\")local I={}for G in E:gmatch\"[^\\n]+\"do local J={}for j in G:gmatch\".\"do J[#J+1]=tonumber(j,16)end;I[#I+1]=J end;return I end;function d.loadImage(K)a(1,K,\"string\")local L=b.open(K,\"r\")if not L then return nil end;local M=L.readAll()L.close()return d.parseImage(M)end;return d\n\nparallel.lua/   0           0     0     644     837       `\nlocal a=require\"craftos.os\"local b={}local function c(d,e)local f={}for g,h in ipairs(d)do if type(h)~=\"function\"then error(\"bad argument #\"..g..\" (expected function, got \"..type(h)..\")\",2)end;f[g]={coro=coroutine.create(h),filter=nil,pos=g}end;local i={n=0}while#f>=e do local g=1;while g<#f do if f[g].filter==nil or f[g].filter==i[1]then local j=i;repeat local k=table.pack(f[g].coro(table.unpack(j,1,j.n)))if not k[1]then error(k[2],0)end;if k[2]==\"syscall\"then j=table.pack(coroutine.yield(table.unpack(k,1,k.n)))else f[g].filter=k[2]end until k[2]~=\"syscall\"if f[g]:status()==\"dead\"then local l=f[g].pos;table.remove(f,g)if#f<e then return l end;g=g-1 end end;g=g+1 end;i=table.pack(a.pullEvent())end;return 1 end;function b.waitForAny(...)return c({...},select(\"#\",...))end;function b.waitForAll(...)return c({...},1)end;return b\n\nperipheral.lua/ 0           0     0     644     2243      `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"local c={}function c.getNames()return b.devchildren(\"/\")end;function c.isPresent(d)a(1,d,\"string\")return b.devinfo(d)~=nil end;function c.getType(e)a(1,e,\"string\",\"table\")if type(e)==\"string\"then local f=b.devinfo(e)if not f then return nil end;local g={}for h in pairs(f.types)do g[#g+1]=h end;return table.unpack(g)else local i=getmetatable(e)if not i or i.__name~=\"peripheral\"or type(i.types)~=\"table\"then error(\"bad argument #1 (table is not a peripheral)\",2)end;return table.unpack(i.types)end end;function c.hasType(e,j)a(1,e,\"string\",\"table\")a(2,j,\"string\")if type(e)==\"string\"then local f=b.devinfo(e)if not f then return nil end;return f.types[j]~=nil else local i=getmetatable(e)if not i or i.__name~=\"peripheral\"or type(i.types)~=\"table\"then error(\"bad argument #1 (table is not a peripheral)\",2)end;return i.types[j]~=nil end end;function c.getMethods(d)a(1,d,\"string\")local k,g=pcall(b.devmethods,d)return k and g or nil end;function c.getName(e)a(1,e,\"table\")local i=getmetatable(e)if not i or i.__name~=\"peripheral\"or type(i.name)~=\"string\"then error(\"bad argument #1 (table is not a peripheral)\",2)end;return i.name end;function c.call(d,l,...)a(1,d,\"string\")a(2,l,\"string\")return b.devcall(d,l,...)end;function c.wrap(d)a(1,d,\"string\")local f=b.devinfo(d)if not f then return nil end;local m,n=b.devmethods(d),b.devproperties(d)for o,p in ipairs(n)do n[p]=true end;for h in pairs(f.types)do if type(h)==\"string\"then f.types[#f.types+1]=h end end;local g={}for o,p in ipairs(m)do g[p]=function(self,...)return b.devcall(d,p,...)end end;return setmetatable(g,{__name=\"peripheral\",name=d,type=f.types[1],types=f.types,__index=function(self,q)if type(q)==\"string\"and n[q]then return b.devcall(d,\"get\"..q:gsub(\"^.\",string.upper))end end,__newindex=function(self,q,r)if type(q)==\"string\"and n[q]and m[\"set\"..q:gsub(\"^.\",string.upper)]then return b.devcall(d,\"set\"..q:gsub(\"^.\",string.upper),r)end end,__tostring=function(self)return\"wrapped device: \"..(f.displayName or f.uuid)end})end;function c.find(j,s)a(1,j,\"string\")a(2,s,\"function\",\"nil\")local g={}for o,p in ipairs{b.devfind(j)}do local t=c.wrap(p)if not s or s(p,t)then g[#g+1]=t end end;return table.unpack(g)end;return c\n\nrednet.lua/     0           0     0     644     19        `\nlocal a={}return a\n\nredstone.lua/   0           0     0     644     1339      `\nlocal a=require\"_syscall\"local b=require\"cc.expect\"local c={}function c.getSides()return a.devchildren(\"/redstone\")end;function c.getInput(d)b(1,d,\"string\")return a.devcall(\"/redstone/\"..d,\"getInput\")>0 end;function c.getOutput(d)b(1,d,\"string\")return a.devcall(\"/redstone/\"..d,\"getOutput\")>0 end;function c.setOutput(d,e)b(1,d,\"string\")b(2,e,\"boolean\")return a.devcall(\"/redstone/\"..d,\"setOutput\",e and 15 or 0)end;function c.getAnalogInput(d)b(1,d,\"string\")return a.devcall(\"/redstone/\"..d,\"getInput\")end;function c.getAnalogOutput(d)b(1,d,\"string\")return a.devcall(\"/redstone/\"..d,\"getOutput\")end;function c.setAnalogOutput(d,e)b(1,d,\"string\")b(2,e,\"number\")b.range(e,0,15)return a.devcall(\"/redstone/\"..d,\"setOutput\",e)end;function c.getBundledInput(d)b(1,d,\"string\")return a.devcall(\"/redstone/\"..d,\"getBundledInput\")end;function c.getBundledOutput(d)b(1,d,\"string\")return a.devcall(\"/redstone/\"..d,\"getBundledOutput\")end;function c.setBundledOutput(d,e)b(1,d,\"string\")b(2,e,\"number\")b.range(e,0,65535)return a.devcall(\"/redstone/\"..d,\"setBundledOutput\",e)end;function c.testBundledInput(d,f)b(1,d,\"string\")b(2,f,\"number\")b.range(f,0,65535)return bit32.band(a.devcall(\"/redstone/\"..d,\"getBundledInput\"),f)==f end;c.getAnalogueInput=c.getAnalogInput;c.getAnalogueOutput=c.getAnalogOutput;c.setAnalogueOutput=c.setAnalogOutput;return c\n\nsettings.lua/   0           0     0     644     3872      `\nlocal a=require\"cc.expect\"local b=require\"fs\"local c=require\"textutils\"local d={}local e={}local f={}function d.get(g,h)a(1,g,\"string\")if e[g]~=nil then return e[g]elseif h~=nil then return h else return f[g]and f[g].default end end;function d.set(g,i)a(1,g,\"string\")if i==nil then error(\"bad argument #2 (expected value, got nil)\",2)end;if f[g]and f[g].type then a(2,i,f[g].value)end;e[g]=i end;function d.unset(g)a(1,g,\"string\")e[g]=nil end;function d.define(g,j)a(1,g,\"string\")if j~=nil then a(2,j,\"table\")a.field(j,\"description\",\"string\",\"nil\")a.field(j,\"type\",\"string\",\"nil\")if j.type then a.field(j,\"default\",j.type,\"nil\")end end;f[g]=j or{}end;function d.undefine(g)a(1,g,\"string\")f[g]=nil end;function d.getDetails(g)a(1,g,\"string\")local k=f[g]if k then return{description=k.description,default=k.default,type=k.type,value=e[g]}else return{value=e[g]}end end;function d.clear()e={}end;function d.getNames()local l={}for m in pairs(f)do l[#l+1]=m end;table.sort(l)return l end;function d.load(n)n=a(1,n,\"string\",\"nil\")or\"/etc/settings\"if not b.exists(n)then return false end;local o=b.open(n,\"r\")if not o then return false end;local p,q=pcall(c.unserialize,o.readAll())o.close()if not p or type(q)~=\"table\"then return false end;for m,r in pairs(q)do e[m]=r end;return true end;function d.save(n)n=a(1,n,\"string\",\"nil\")or\"/etc/settings\"local o=b.open(n,\"r\")if not o then return false end;o.write(c.serialize(e))o.close()return true end;d.define(\"shell.allow_startup\",{default=true,description=\"Run startup files when the computer turns on.\",type=\"boolean\"})d.define(\"shell.allow_disk_startup\",{default=true,description=\"Run startup files from disk drives when the computer turns on.\",type=\"boolean\"})d.define(\"shell.autocomplete\",{default=false,description=\"Autocomplete program and arguments in the shell.\",type=\"boolean\"})d.define(\"edit.autocomplete\",{default=false,description=\"Autocomplete API and function names in the editor.\",type=\"boolean\"})d.define(\"lua.autocomplete\",{default=false,description=\"Autocomplete API and function names in the Lua REPL.\",type=\"boolean\"})d.define(\"edit.default_extension\",{default=\"lua\",description=[[The file extension the editor will use if none is given. Set to \"\" to disable.]],type=\"string\"})d.define(\"paint.default_extension\",{default=\"nfp\",description=[[The file extension the paint program will use if none is given. Set to \"\" to disable.]],type=\"string\"})d.define(\"list.show_hidden\",{default=false,description=[[Show hidden files (those starting with \".\" in the Lua REPL).]],type=\"boolean\"})d.define(\"motd.enable\",{default=true,description=\"Display a random message when the computer starts up.\",type=\"boolean\"})d.define(\"motd.path\",{default=\"/rom/motd.txt:/motd.txt\",description=[[The path to load random messages from. Should be a colon (\":\") separated string of file paths.]],type=\"string\"})d.define(\"lua.warn_against_use_of_local\",{default=true,description=[[Print a message when input in the Lua REPL starts with the word 'local'. Local variables defined in the Lua REPL are be inaccessable on the next input.]],type=\"boolean\"})d.define(\"lua.function_args\",{default=true,description=\"Show function arguments when printing functions.\",type=\"boolean\"})d.define(\"lua.function_source\",{default=false,description=\"Show where a function was defined when printing functions.\",type=\"boolean\"})d.define(\"bios.strict_globals\",{default=false,description=\"Prevents assigning variables into a program's environment. Make sure you use the local keyword or assign to _G explicitly.\",type=\"boolean\"})d.define(\"shell.autocomplete_hidden\",{default=false,description=[[Autocomplete hidden files and folders (those starting with \".\").]],type=\"boolean\"})d.define(\"bios.use_multishell\",{default=true,description=[[Allow running multiple programs at once, through the use of the \"fg\" and \"bg\" programs.]],type=\"boolean\"})d.load()return d\nshell.lua/      0           0     0     644     1632      `\nlocal a=require\"_syscall\"local b=require\"cc.expect\"local c=require\"craftos.os\"local d={}local e=a.getenv().PATH or\"/bin:/sbin:/usr/bin\"local f={}local g={}function d.dir()return a.getcwd()end;function d.setDir(h)b(1,h,\"string\")return a.chdir(h)end;function d.path()return e end;function d.setPath(i)b(1,i,\"string\")e=i end;function d.getRunningProgram()return a.getname()end;function d.resolve(e)b(1,e,\"string\")if e:sub(1,1)==\"/\"then return e end;return a.combine(a.getcwd(),e)end;function d.run(...)local j=\"\"for k,l in ipairs{...}do j=j..(j==\"\"and\"\"or\" \")..l end;local m={}for n in j:gmatch\"%S+\"do m[#m+1]=n end;return d.execute(table.unpack(m))end;function d.execute(...)local o=setmetatable({shell=d},{__index=_ENV})local p,q=loadfile(e,nil,o)if not p then return false end;local r,s=pcall(p,...)return r end;function d.aliases()local t={}for u,l in pairs(f)do t[u]=l end;return t end;function d.setAlias(v,w)b(1,v,\"string\")b(2,w,\"string\")f[v]=w end;function d.clearAlias(v)b(1,v,\"string\")f[v]=nil end;function d.getCompletionInfo()return g end;function d.setCompletionFunction(w,p)end;function d.complete(x)return{}end;function d.completeProgram(w)return{}end;function d.resolveProgram(v)for y in e:gmatch\"[^:]+\"do local r,z=pcall(a.list,y)if r then for A in ipairs(z)do if v==A or v..\".lua\"==A then return a.combine(y,A)end end end end;return nil end;function d.programs(B)b(1,B,\"boolean\",\"nil\")local t={}for y in e:gmatch\"[^:]+\"do local r,z=pcall(a.list,y)if r then for A in ipairs(z)do if a.stat(a.combine(y,A)).type~=\"directory\"and(B or not A:match\"^%.\")then t[#t+1]=A:gsub(\"%.lua$\",\"\")end end end end;return t end;return d\n_syscall.lua/   0           0     0     644     217       `\nreturn setmetatable({},{__index=function(self,a)return function(...)local b=table.pack(coroutine.yield(\"syscall\",a,...))if b[1]then return table.unpack(b,2,b.n)else error(b[2],2)end end end,__newindex=function()end})\n\nterm.lua/       0           0     0     644     544       `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"local c={}local d=assert(b.openterm())local e={}local f=e;for g,h in pairs(d)do e[g]=h;c[g]=function(...)return f[g](...)end end;function c.redirect(i)a(1,i,\"table\")if i==c then error(\"term is not a recommended redirect target, try term.current() instead\",2)end;for g in pairs(e)do if type(i[g])~=\"function\"then i[g]=function()error(\"Redirect object is missing method \"..g..\".\",2)end end end;local j=f;f=i;return j end;function c.current()return f end;function c.native()return e end;return c\ntextutils.lua/  0           0     0     644     9020      `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"local c=require\"craftos.os\"local d=require\"term\"local e={}function e.slowWrite(f,g)a(1,f,\"string\")g=a(2,g,\"number\",\"nil\")or 20;local h,i=d.getCursorPos()local j,k=d.getSize()for l in f:gmatch\".\"do d.write(l)h=h+1;if l=='\\n'or h>j then h,i=1,i+1;if i>k then d.scroll(1)i=i-1 end;d.setCursorPos(h,i)end;local m=b.timer(1/g)repeat local n,o=c.pullEvent()until n==\"timer\"and o==m end end;function e.slowPrint(f,g)return e.slowWrite(f..\"\\n\",g)end;function e.formatTime(p,q)a(1,p,\"number\")a(2,q,\"boolean\",\"nil\")local r,s=math.floor(p),math.floor(p%1*60)return c.date(q and\"%H:%M\"or\"%I:%M %p\",c.time{year=1970,month=1,day=1,hour=r,min=s})end;function e.pagedPrint(f,t)error(\"Not implemented\")end;local function u(v,...)local t={}local w=0;local x={}for y,z in ipairs{...}do local A=type(z)if A==\"number\"then x[#t+1]=z elseif A==\"table\"then if#z>0 then t[#t+1]=z;for B=1,#z do z[B]=tostring(z[B])w=math.max(w,#z[B]+1)end end else error((\"bad argument #%d (expected table or number, got %s)\"):format(y,A),3)end end;local h,i=d.getCursorPos()local j,k=d.getSize()local function C()h,i=1,i+1;if i>k then d.scroll(1)i=i-1;if v then d.setCursorPos(h,i)d.write(\"Press any key to continue\")c.pullEvent(\"key\")d.clearLine()end end;d.setCursorPos(h,i)end;for y,z in ipairs(t)do if x[y]then d.setTextColor(x[y])end;for D,E in ipairs(z)do if h+w>j then C()end;d.write(E..(\" \"):rep(w-#E))h=h+w end;C()end end;function e.tabulate(...)return u(false,...)end;function e.pagedTabulate(...)return u(true,...)end;local function F(G)return setmetatable({},{__newindex=function()error(\"attempt to modify read-only table\")end,__tostring=function()return G end})end;e.json_null=F\"null\"e.empty_json_array=F\"[]\"local H;local I={[\"\\\\\"]=\"\\\\\",[\"\\\"\"]=\"\\\"\",[\"\\b\"]=\"b\",[\"\\f\"]=\"f\",[\"\\n\"]=\"n\",[\"\\r\"]=\"r\",[\"\\t\"]=\"t\"}local J={[\"/\"]=\"/\"}for B,z in pairs(I)do J[z]=B end;local function K(l)return\"\\\\\"..(I[l]or string.format(\"u%04x\",l:byte()))end;local function L(M)return\"null\"end;local function N(M,O)local P={}O=O or{}if M==e.json_null then return\"null\"elseif M==e.empty_json_array then return\"[]\"end;if O[M]then error(\"circular reference\")end;O[M]=true;if rawget(M,1)~=nil or next(M)==nil then local Q=0;for B in pairs(M)do if type(B)~=\"number\"then error(\"invalid table: mixed or invalid key types\")end;Q=Q+1 end;if Q~=#M then error(\"invalid table: sparse array\")end;for y,z in ipairs(M)do table.insert(P,H(z,O))end;O[M]=nil;return\"[\"..table.concat(P,\",\")..\"]\"else for B,z in pairs(M)do if type(B)~=\"string\"then error(\"invalid table: mixed or invalid key types\")end;table.insert(P,H(B,O)..\":\"..H(z,O))end;O[M]=nil;return\"{\"..table.concat(P,\",\")..\"}\"end end;local function R(M)return'\"'..M:gsub('[%z\\1-\\31\\\\\"]',K)..'\"'end;local function S(M)if M~=M or M<=-math.huge or M>=math.huge then error(\"unexpected number value '\"..tostring(M)..\"'\")end;return string.format(\"%.14g\",M)end;local T={[\"nil\"]=L,[\"table\"]=N,[\"string\"]=R,[\"number\"]=S,[\"boolean\"]=tostring}H=function(M,O)local U=type(M)local V=T[U]if V then return V(M,O)end;error(\"unexpected type '\"..U..\"'\")end;function e.serializeJSON(M,W)a(2,W,\"boolean\",\"nil\")return H(M)end;local X;local function Y(...)local P={}for y=1,select(\"#\",...)do P[select(y,...)]=true end;return P end;local Z=Y(\" \",\"\\t\",\"\\r\",\"\\n\")local _=Y(\" \",\"\\t\",\"\\r\",\"\\n\",\"]\",\"}\",\",\")local a0=Y(\"\\\\\",\"/\",'\"',\"b\",\"f\",\"n\",\"r\",\"t\",\"u\")local a1=Y(\"true\",\"false\",\"null\")local a2={[\"true\"]=true,[\"false\"]=false,[\"null\"]=nil}local function a3(G,a4,a5,a6)for y=a4,#G do if a5[G:sub(y,y)]~=a6 then return y end end;return#G+1 end;local function a7(G,a4,a8)local a9=1;local aa=1;for y=1,a4-1 do aa=aa+1;if G:sub(y,y)==\"\\n\"then a9=a9+1;aa=1 end end;error(string.format(\"%s at line %d col %d\",a8,a9,aa))end;local function ab(Q)local V=math.floor;if Q<=0x7f then return string.char(Q)elseif Q<=0x7ff then return string.char(V(Q/64)+192,Q%64+128)elseif Q<=0xffff then return string.char(V(Q/4096)+224,V(Q%4096/64)+128,Q%64+128)elseif Q<=0x10ffff then return string.char(V(Q/262144)+240,V(Q%262144/4096)+128,V(Q%4096/64)+128,Q%64+128)end;error(string.format(\"invalid unicode codepoint '%x'\",Q))end;local function ac(E)local ad=tonumber(E:sub(1,4),16)local ae=tonumber(E:sub(7,10),16)if ae then return ab((ad-0xd800)*0x400+ae-0xdc00+0x10000)else return ab(ad)end end;local function af(G,y)local P=\"\"local ag=y+1;local B=ag;while ag<=#G do local ah=G:byte(ag)if ah<32 then a7(G,ag,\"control character in string\")elseif ah==92 then P=P..G:sub(B,ag-1)ag=ag+1;local l=G:sub(ag,ag)if l==\"u\"then local ai=G:match(\"^[dD][89aAbB]%x%x\\\\u%x%x%x%x\",ag+1)or G:match(\"^%x%x%x%x\",ag+1)or a7(G,ag-1,\"invalid unicode escape in string\")P=P..ac(ai)ag=ag+#ai else if not a0[l]then a7(G,ag-1,\"invalid escape char '\"..l..\"' in string\")end;P=P..J[l]end;B=ag+1 elseif ah==34 then P=P..G:sub(B,ag-1)return P,ag+1 end;ag=ag+1 end;a7(G,y,\"expected closing quote for string\")end;local function aj(G,y,ak)local ah=a3(G,y,_)local E=G:sub(y,ah-1)if ak.nbt_style then E=E:gsub(\"[bBsSlLfFdD]%s*$\",\"\")end;local Q=tonumber(E)if not Q then a7(G,y,\"invalid number '\"..E..\"'\")end;return Q,ah end;local function al(G,y,ak)local ah=a3(G,y,_)local am=G:sub(y,ah-1)if not a1[am]then a7(G,y,\"invalid literal '\"..am..\"'\")end;if am==\"null\"and ak.parse_null then return e.json_null,ah end;return a2[am],ah end;local function an(G,y,ak)local P={}local Q=1;y=y+1;while 1 do local ah;y=a3(G,y,Z,true)if G:sub(y,y)==\"]\"then y=y+1;break elseif Q==1 and ak.nbt_style and G:sub(y,y):match(\"[BIL]\")then local ao=y;y=a3(G,y,Z,true)if G:sub(y,y)==\";\"then y=a3(G,y,Z,true)if G:sub(y,y)==\"]\"then y=y+1;break end else y=ao end end;ah,y=X(G,y,ak)P[Q]=ah;Q=Q+1;y=a3(G,y,Z,true)local ap=G:sub(y,y)y=y+1;if ap==\"]\"then break end;if ap~=\",\"then a7(G,y,\"expected ']' or ','\")end end;if#P==0 and ak.parse_empty_array~=false then return e.empty_json_array,y end;return P,y end;local function aq(G,y,ak)local P={}y=y+1;while 1 do local ar,M;y=a3(G,y,Z,true)if G:sub(y,y)==\"}\"then y=y+1;break end;if G:sub(y,y)=='\"'then ar,y=X(G,y,ak)elseif ak.nbt_style then local ao=y;ar,y=G:match(\"([A-Za-z0-9_%-%.%+]+)()\",y)if not ar then a7(G,ao,\"expected key\")end else a7(G,y,\"expected string for key\")end;y=a3(G,y,Z,true)if G:sub(y,y)~=\":\"then a7(G,y,\"expected ':' after key\")end;y=a3(G,y+1,Z,true)M,y=X(G,y,ak)P[ar]=M;y=a3(G,y,Z,true)local ap=G:sub(y,y)y=y+1;if ap==\"}\"then break end;if ap~=\",\"then a7(G,y,\"expected '}' or ','\")end end;return P,y end;local as={['\"']=af,[\"0\"]=aj,[\"1\"]=aj,[\"2\"]=aj,[\"3\"]=aj,[\"4\"]=aj,[\"5\"]=aj,[\"6\"]=aj,[\"7\"]=aj,[\"8\"]=aj,[\"9\"]=aj,[\"-\"]=aj,[\"t\"]=al,[\"f\"]=al,[\"n\"]=al,[\"[\"]=an,[\"{\"]=aq}X=function(G,a4,ak)local ap=G:sub(a4,a4)local V=as[ap]if V then return V(G,a4,ak)end;a7(G,a4,\"unexpected character '\"..ap..\"'\")end;function e.unserializeJSON(G,ak)a(1,G,\"string\")ak=a(2,ak,\"table\",\"nil\")or{}a.field(ak,\"nbt_style\",\"boolean\",\"nil\")a.field(ak,\"parse_null\",\"boolean\",\"nil\")a.field(ak,\"parse_empty_array\",\"boolean\",\"nil\")local P,a4=X(G,a3(G,1,Z,true),ak)a4=a3(G,a4,Z,true)if a4<=#G then a7(G,a4,\"trailing garbage\")end;return P end;local at={[\"and\"]=true,[\"break\"]=true,[\"do\"]=true,[\"else\"]=true,[\"elseif\"]=true,[\"end\"]=true,[\"false\"]=true,[\"for\"]=true,[\"function\"]=true,[\"goto\"]=true,[\"if\"]=true,[\"in\"]=true,[\"local\"]=true,[\"nil\"]=true,[\"not\"]=true,[\"or\"]=true,[\"repeat\"]=true,[\"return\"]=true,[\"then\"]=true,[\"true\"]=true,[\"until\"]=true,[\"while\"]=true}local function au(M,O,ak,av)if O[M]then error(\"Cannot serialize recursive value\",0)end;local A=type(M)if A==\"table\"then if not next(M)then return\"{}\"end;O[M]=true;local P=ak.compact and\"{\"or\"{\\n\"local aw={}for y,z in ipairs(M)do if not ak.compact then P=P..(\"    \"):rep(av)end;aw[y]=true;P=P..au(z,O,ak,av+1)..(ak.compact and\",\"or\",\\n\")end;for B,z in pairs(M)do if not aw[B]then if not ak.compact then P=P..(\"    \"):rep(av)end;if type(B)==\"string\"and B:match\"^[A-Za-z_][A-Za-z0-9_]*$\"and not at[B]then P=P..B else P=P..\"[\"..au(B,O,ak,av+1)..\"]\"end;P=P..(ak.compact and\"=\"or\" = \")..au(z,O,ak,av+1)..(ak.compact and\",\"or\",\\n\")end end;if ak.compact then P=P:gsub(\",$\",\"\")else P=P..(\"    \"):rep(av-1)end;if not ak.allow_repetitons then O[M]=nil end;return P..\"}\"elseif A==\"nil\"or A==\"number\"or A==\"boolean\"or A==\"string\"then return(\"%q\"):format(M):gsub(\"\\\\\\n\",\"\\\\n\"):gsub(\"\\\\?[%z\\1-\\31\\127-\\255]\",function(l)return(\"\\\\%03d\"):format(string.byte(l))end)else error(\"Cannot serialize type \"..A,0)end end;function e.serialize(M,ak)ak=a(2,ak,\"table\",\"nil\")or{}a.field(ak,\"compact\",\"boolean\",\"nil\")a.field(ak,\"allow_repetitions\",\"boolean\",\"nil\")return au(M,{},ak,1)end;function e.unserialize(E)a(1,E,\"string\")return assert(load(\"return \"..E,\"=unserialize\",\"t\",{}))()end;function e.urlEncode(G)a(1,G,\"string\")return G:gsub(\"\\n\",\"\\r\\n\"):gsub(\"([^A-Za-z0-9 %-%_%.])\",function(l)local Q=l:byte()if Q<128 then return(\"%%%02X\"):format(Q)else return(\"%%%02X%%%02X\"):format(bit32.rshift(Q,6)+0xC0,bit32.band(Q,0x3F)+0x80)end end):gsub(\" \",\"+\")end;function e.complete(ax,ay)error(\"Not implemented\")end;e.serialise=e.serialize;e.unserialise=e.unserialize;e.serialiseJSON=e.serializeJSON;e.unserialiseJSON=e.unserializeJSON;return e\nvector.lua/     0           0     0     644     1002      `\nlocal a={}local b={__name=\"vector\",__index=a}local function c(d,e,f)return setmetatable({x=tonumber(d)or 0,y=tonumber(e)or 0,z=tonumber(f)or 0},b)end;function a:add(g)return c(self.x+g.x,self.y+g.y,self.z+g.z)end;b.__add=a.add;function a:sub(g)return c(self.x-g.x,self.y-g.y,self.z-g.z)end;b.__sub=a.sub;function a:mul(h)return c(self.x*h,self.y*h,self.z*h)end;b.__mul=a.mul;function a:div(h)return c(self.x/h,self.y/h,self.z/h)end;b.__div=a.div;function a:unm()return c(-self.x,-self.y,-self.z)end;b.__unm=a.unm;function a:dot(g)return self.x*g.x+self.y*g.y+self.z*g.z end;function a:cross(g)return c(self.y*g.z-self.z*g.y,self.z*g.x-self.x*g.z,self.x*g.y-self.y*g.x)end;function a:length()return math.sqrt(self.x*self.x+self.y*self.y+self.z*self.z)end;function a:normalize()return self:mul(1/self:length())end;function a:tostring()return self.x..\",\"..self.y..\",\"..self.z end;b.__tostring=a.tostring;function a:equals(g)return self.x==g.x and self.y==g.y and self.z==g.z end;b.__eq=a.eq;return{new=c}\nwindow.lua/     0           0     0     644     7320      `\nlocal a=require\"cc.expect\"return{new=function(b,c,d,e,f,g)a(1,b,\"table\")a(2,c,\"number\")a(3,d,\"number\")a(4,e,\"number\")a(5,f,\"number\")a(6,g,\"boolean\",\"nil\")if g==nil then g=true end;local h={width=e,height=f}local i={cursor={x=1,y=1},cursorBlink=false,colors={fg='0',bg='f'},palette={},dirtyLines={},dirtyPalette={}}for j=1,h.height do i[j]={(' '):rep(h.width),('0'):rep(h.width),('f'):rep(h.width)}i.dirtyLines[j]=true end;if b then for k=0,15 do i.palette[k]={b.getPaletteColor(k)}i.dirtyPalette[k]=true end else i.palette={[0]={0.94117647058824,0.94117647058824,0.94117647058824},{0.94901960784314,0.69803921568627,0.2},{0.89803921568627,0.49803921568627,0.84705882352941},{0.6,0.69803921568627,0.94901960784314},{0.87058823529412,0.87058823529412,0.42352941176471},{0.49803921568627,0.8,0.098039215686275},{0.94901960784314,0.69803921568627,0.8},{0.29803921568627,0.29803921568627,0.29803921568627},{0.6,0.6,0.6},{0.29803921568627,0.6,0.69803921568627},{0.69803921568627,0.4,0.89803921568627},{0.2,0.4,0.8},{0.49803921568627,0.4,0.29803921568627},{0.34117647058824,0.65098039215686,0.30588235294118},{0.8,0.29803921568627,0.29803921568627},{0.066666666666667,0.066666666666667,0.066666666666667}}for k=0,15 do i.dirtyPalette[k]=true end end;local l=setmetatable({},{__name=\"Terminal\"})function l.close()end;function l.write(m)m=tostring(m)a(1,m,\"string\")if i.cursor.y<1 or i.cursor.y>h.height then return elseif i.cursor.x>h.width or i.cursor.x+#m<1 then i.cursor.x=i.cursor.x+#m;return elseif i.cursor.x<1 then m=m:sub(-i.cursor.x+2)i.cursor.x=1 end;local n=#m;if i.cursor.x+#m>h.width then m=m:sub(1,h.width-i.cursor.x+1)end;i[i.cursor.y][1]=i[i.cursor.y][1]:sub(1,i.cursor.x-1)..m..i[i.cursor.y][1]:sub(i.cursor.x+#m)i[i.cursor.y][2]=i[i.cursor.y][2]:sub(1,i.cursor.x-1)..i.colors.fg:rep(#m)..i[i.cursor.y][2]:sub(i.cursor.x+#m)i[i.cursor.y][3]=i[i.cursor.y][3]:sub(1,i.cursor.x-1)..i.colors.bg:rep(#m)..i[i.cursor.y][3]:sub(i.cursor.x+#m)i.cursor.x=i.cursor.x+n;i.dirtyLines[i.cursor.y]=true;l.redraw()end;function l.blit(m,o,p)m=tostring(m)a(1,m,\"string\")a(2,o,\"string\")a(3,p,\"string\")if#m~=#o or#o~=#p then error(\"Arguments must be the same length\",2)end;if i.cursor.y<1 or i.cursor.y>h.height then return elseif i.cursor.x>h.width or i.cursor.x<1-#m then i.cursor.x=i.cursor.x+#m;l.redraw()return elseif i.cursor.x<1 then m,o,p=m:sub(-i.cursor.x+2),o:sub(-i.cursor.x+2),p:sub(-i.cursor.x+2)i.cursor.x=1 end;local n=#m;if i.cursor.x+#m>h.width then m,o,p=m:sub(1,h.width-i.cursor.x+1),o:sub(1,h.width-i.cursor.x+1),p:sub(1,h.width-i.cursor.x+1)end;i[i.cursor.y][1]=i[i.cursor.y][1]:sub(1,i.cursor.x-1)..m..i[i.cursor.y][1]:sub(i.cursor.x+#m)i[i.cursor.y][2]=i[i.cursor.y][2]:sub(1,i.cursor.x-1)..o..i[i.cursor.y][2]:sub(i.cursor.x+#o)i[i.cursor.y][3]=i[i.cursor.y][3]:sub(1,i.cursor.x-1)..p..i[i.cursor.y][3]:sub(i.cursor.x+#p)i.cursor.x=i.cursor.x+n;i.dirtyLines[i.cursor.y]=true;l.redraw()end;function l.clear()for j=1,h.height do i[j]={(' '):rep(h.width),i.colors.fg:rep(h.width),i.colors.bg:rep(h.width)}i.dirtyLines[j]=true end;l.redraw()end;function l.clearLine()if i.cursor.y>=1 and i.cursor.y<=h.height then i[i.cursor.y]={(' '):rep(h.width),i.colors.fg:rep(h.width),i.colors.bg:rep(h.width)}i.dirtyLines[i.cursor.y]=true;l.redraw()end end;function l.getCursorPos()return i.cursor.x,i.cursor.y end;function l.setCursorPos(q,r)a(1,q,\"number\")a(2,r,\"number\")if q==i.cursor.x and r==i.cursor.y then return end;i.cursor.x,i.cursor.y=math.floor(q),math.floor(r)l.redraw()end;function l.getCursorBlink()return i.cursorBlink end;function l.setCursorBlink(s)a(1,s,\"boolean\")i.cursorBlink=s;l.redraw()end;function l.isColor()return true end;function l.getSize()return h.width,h.height end;function l.scroll(t)a(1,t,\"number\")if math.abs(t)>=h.width then for j=1,h.height do i[j]={(' '):rep(h.width),i.colors.fg:rep(h.width),i.colors.bg:rep(h.width)}end elseif t>0 then for k=t+1,h.height do i[k-t]=i[k]end;for k=h.height-t+1,h.height do i[k]={(' '):rep(h.width),i.colors.fg:rep(h.width),i.colors.bg:rep(h.width)}end elseif t<0 then for k=1,h.height+t do i[k-t]=i[k]end;for k=1,-t do i[k]={(' '):rep(h.width),i.colors.fg:rep(h.width),i.colors.bg:rep(h.width)}end else return end;for k=1,h.height do i.dirtyLines[k]=true end;l.redraw()end;function l.getTextColor()return tonumber(i.colors.fg)end;function l.setTextColor(u)a(1,u,\"number\")a.range(u,0,15)i.colors.fg=(\"%x\"):format(u)end;function l.getBackgroundColor()return tonumber(i.colors.bg)end;function l.setBackgroundColor(u)a(1,u,\"number\")a.range(u,0,15)i.colors.bg=(\"%x\"):format(u)end;function l.getPaletteColor(u)a(1,u,\"number\")a.range(u,0,15)return table.unpack(i.palette[math.floor(u)])end;function l.setPaletteColor(u,v,w,s)a(1,u,\"number\")a(2,v,\"number\")if w==nil and s==nil then v,w,s=bit32.band(bit32.rshift(v,16),0xFF)/255,bit32.band(bit32.rshift(v,8),0xFF)/255,bit32.band(v,0xFF)/255 end;a(3,w,\"number\")a(4,s,\"number\")a.range(u,0,15)if v<0 or v>1 then error(\"bad argument #2 (value out of range)\",2)end;if w<0 or w>1 then error(\"bad argument #3 (value out of range)\",2)end;if s<0 or s>1 then error(\"bad argument #4 (value out of range)\",2)end;i.palette[math.floor(u)]={v,w,s}i.dirtyPalette[math.floor(u)]=true;l.redraw()end;function l.getLine(j)a(1,j,\"number\")local x=i[j]return x and table.unpack(x,1,3)end;function l.getPosition()return c,d end;function l.reposition(y,j,e,f,z)a(1,y,\"number\",\"nil\")a(2,j,\"number\",\"nil\")c=y or c;d=j or d;if z then l.reparent(z)end;if y or j then l.redraw(true)end;if e or f then return l.resize(e,f)end end;function l.resize(A,B)a(1,A,\"number\",\"nil\")a(2,B,\"number\",\"nil\")if A>h.width then for j=1,h.height do i[j][1]=i[j][1]..(' '):rep(A-h.width)i[j][2]=i[j][2]..i.colors.fg:rep(A-h.width)i[j][3]=i[j][3]..i.colors.bg:rep(A-h.width)i.dirtyLines[j]=true end elseif A<h.width then for j=1,h.height do i[j][1]=i[j][1]:sub(1,A)i[j][2]=i[j][2]:sub(1,A)i[j][3]=i[j][3]:sub(1,A)end end;h.width=A;if B>h.height then for j=h.height+1,B do i[j]={(' '):rep(A),i.colors.fg:rep(A),i.colors.bg:rep(A)}i.dirtyLines[j]=true end elseif B<h.height then for j=B+1,h.height do i[j]=nil end end;h.height=B end;function l.reparent(z)a(1,z,\"Terminal\",\"nil\")b=z;l.redraw()end;function l.redraw(C)if not b or not g then return end;b.setCursorBlink(false)if C then b.clear()for j=1,h.height do b.setCursorPos(c,d+j-1)b.blit(i[j][1],i[j][2],i[j][3])end;for k=0,15 do b.setPaletteColor(k,i.palette[k][1],i.palette[k][2],i.palette[k][3])end else for j in pairs(i.dirtyLines)do b.setCursorPos(c,d+j-1)if#i[j][1]~=#i[j][2]or#i[j][2]~=#i[j][3]then error(\"Internal error: Invalid lengths\")end;b.blit(i[j][1],i[j][2],i[j][3])end;for k in pairs(i.dirtyPalette)do b.setPaletteColor(k,i.palette[k][1],i.palette[k][2],i.palette[k][3])end end;b.setCursorPos(c+i.cursor.x-1,d+i.cursor.y-1)b.setCursorBlink(i.cursorBlink)i.dirtyLines,i.dirtyPalette={},{}end;function l.restoreCursor()if not b or not g then return end;b.setCursorPos(c+i.cursor.x-1,d+i.cursor.y-1)b.setCursorBlink(i.cursorBlink)end;function l.isVisible()return g end;function l.setVisible(D)a(1,D,\"boolean\")g=D;l.redraw()end;l.isColour=l.isColor;l.getTextColour=l.getTextColor;l.setTextColour=l.setTextColor;l.getBackgroundColour=l.getBackgroundColor;l.setBackgroundColour=l.setBackgroundColor;l.getPaletteColour=l.getPaletteColor;l.setPaletteColour=l.setPaletteColor;l.redraw()return l end}\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292583,size=51622},modules={type="directory",setuser=false,created=1740881294687,worldPermissions={write=false,read=true,execute=true},contents={["advanced-peripherals.lua"]={type="file",created=1740881291059,worldPermissions={write=false,read=true,execute=false},data="if not PHOENIX_VERSION then error(\"This must be loaded as a kernel module.\")end;local function a(b)return function(self)return self.internalState.peripheral.call(self.id,b)end end;local function c(b)return function(self,d)if d.user~=\"root\"then error(\"Permission denied\",0)end;return self.internalState.peripheral.call(self.id,b)end end;local function e(b)return function(...)local f={...}return function(self,d,g)expect(1,g,table.unpack(f))return self.internalState.peripheral.call(self.id,b,g)end end end;local function h(b)return function(...)local f={...}return function(self,d,g)expect(1,g,table.unpack(f))if d.user~=\"root\"then error(\"Permission denied\",0)end;return self.internalState.peripheral.call(self.id,b,g)end end end;local i={name=\"peripheral_ap_chatBox\",type=\"chatBox\",properties={},methods={}}function i.methods:send(d,j,k)expect(1,j,\"string\")if expect(2,k,\"table\",\"nil\")then expect.field(k,\"username\",\"string\",\"nil\")expect.field(k,\"formatted\",\"boolean\",\"nil\")expect.field(k,\"toast\",\"boolean\",\"nil\")expect.field(k,\"prefix\",\"string\",\"nil\")expect.field(k,\"brackets\",\"string\",\"nil\")expect.field(k,\"bracketColor\",\"string\",\"nil\")expect.field(k,\"range\",\"number\",\"nil\")if k.brackets then if#k.brackets~=2 then error(\"Brackets not matched\",2)end end;if k.bracketColor then if not k.bracketColor:match\"^&%x$\"then error(\"Invalid bracket color\",2)end end else k={}end;if k.toast then expect.field(k,\"username\",\"string\")expect.field(k,\"title\",\"string\")if k.formatted then return self.internalState.peripheral.call(self.id,\"sendFormattedToastToPlayer\",j,k.username,k.prefix,k.brackets,k.bracketColor,k.range)else return self.internalState.peripheral.call(self.id,\"sendToastToPlayer\",j,k.title,k.username,k.prefix,k.brackets,k.bracketColor,k.range)end elseif k.formatted then if k.username then return self.internalState.peripheral.call(self.id,\"sendFormattedMessageToPlayer\",j,k.username,k.prefix,k.brackets,k.bracketColor,k.range)else return self.internalState.peripheral.call(self.id,\"sendFormattedMessage\",j,k.prefix,k.brackets,k.bracketColor,k.range)end elseif k.username then return self.internalState.peripheral.call(self.id,\"sendMessageToPlayer\",j,k.username,k.prefix,k.brackets,k.bracketColor,k.range)else return self.internalState.peripheral.call(self.id,\"sendMessage\",j,k.prefix,k.brackets,k.bracketColor,k.range)end end;function i:init()self.displayName=\"Chat Box on \"..self.id end;registerDriver(i)eventHooks.chat=eventHooks.chat or{}eventHooks.chat[#eventHooks.chat+1]=function(l)for m,n in ipairs{hardware.find(\"chatBox\")}do hardware.broadcast(n,\"chat\",{username=l[2],message=l[3],uuid=l[4],isHidden=l[5]})end end;local o={name=\"peripheral_ap_energyDetector\",type=\"energyDetector\",properties={\"transferRate\",\"transferRateLimit\"},methods={}}o.methods.getTransferRate=a\"getTransferRate\"o.methods.getTransferRateLimit=a\"getTransferRateLimit\"o.methods.setTransferRateLimit=e\"setTransferRateLimit\"\"number\"registerDriver(o)local p={name=\"peripheral_ap_environmentDetector\",type=\"environmentDetector\",properties={\"lightLevel\",\"moonPhase\",\"time\",\"radiation\",\"weather\",\"biome\",\"dimension\",\"dimensions\",\"isSlimeChunk\"},methods={}}function p.methods:getLightLevel()return{block=self.internalState.peripheral.call(self.id,\"getBlockLightLevel\"),day=self.internalState.peripheral.call(self.id,\"getDayLightLevel\"),sky=self.internalState.peripheral.call(self.id,\"getSkyLightLevel\")}end;function p.methods:getMoonPhase()return{name=self.internalState.peripheral.call(self.id,\"getMoonName\"),id=self.internalState.peripheral.call(self.id,\"getMoonId\")}end;p.methods.getTime=a\"getTime\"function p.methods:getRadiation()local q=self.internalState.peripheral.call(self.id,\"getRadiation\")if not q then return nil end;q.raw=self.internalState.peripheral.call(self.id,\"getRadiationRaw\")return q end;function p.methods:getWeather()return{raining=self.internalState.peripheral.call(self.id,\"isRaining\"),sunny=self.internalState.peripheral.call(self.id,\"isSunny\"),thunder=self.internalState.peripheral.call(self.id,\"isThunder\")}end;p.methods.isDimension=e\"isDimension\"\"string\"p.methods.isMoon=e\"isMoon\"\"number\"p.methods.scan=e\"scanEntities\"\"number\"p.methods.getDimensions=a\"listDimensions\"p.methods.getIsSlimeChunk=a\"isSlimeChunk\"p.methods.getBiome=a\"getBiome\"function p.methods:getDimension()return{name=self.internalState.peripheral.call(self.id,\"getDimensionName\"),provider=self.internalState.peripheral.call(self.id,\"getDimensionProvider\"),id=self.internalState.peripheral.call(self.id,\"getDimensionPaN\")}end;registerDriver(p)local r={name=\"peripheral_ap_nbtStorage\",type=\"nbtStorage\",properties={\"data\"},methods={}}r.methods.getData=a\"read\"function r.methods:setData(d,g)expect(1,g,\"table\",\"string\")if type(g)==\"table\"then assert(self.internalState.peripheral.call(self.id,\"writeTable\",g))else assert(self.internalState.peripheral.call(self.id,\"writeJson\",g))end end;registerDriver(r)local s={name=\"peripheral_ap_blockReader\",type=\"blockReader\",properties={\"block\"},methods={}}function s.methods:getBlock()return{name=self.internalState.peripheral.call(self.id,\"getBlockName\"),data=self.internalState.peripheral.call(self.id,\"getBlockData\"),states=self.internalState.peripheral.call(self.id,\"getBlockStates\"),isTileEntity=self.internalState.peripheral.call(self.id,\"isTileEntity\")}end;registerDriver(s)local t={name=\"peripheral_ap_geoScanner\",type=\"geoScanner\",properties={\"fuel\",\"cooldown\"},methods={}}t.methods.getFuel=a\"getFuelLevel\"t.methods.getCooldown=a\"getScanCooldown\"t.methods.cost=e\"cost\"\"number\"t.methods.scan=e\"scan\"\"number\"t.methods.analyze=a\"chunkAnalyze\"function t:init()self.metadata.maxFuel=self.internalState.peripheral.call(self.id,\"getMaxFuelLevel\")end;registerDriver(t)local u={name=\"peripheral_ap_redstoneIntegrator_side\",type=\"redstone\",properties={\"input\",\"output\",\"bundledInput\",\"bundledOutput\"},methods={}}local function v(w)if w==0 then return nil else return w end end;function u.methods:getInput()return v(self.internalState.peripheral.call(self.id,\"getAnalogInput\",self.internalState.redstone.side))end;function u.methods:getOutput()return v(self.internalState.peripheral.call(self.id,\"getAnalogOutput\",self.internalState.redstone.side))end;function u.methods:setOutput(d,w)w=expect(1,w,\"number\",\"boolean\",\"nil\")or 0;if w==false then w=0 elseif w==true then w=15 end;expect.range(w,0,15)self.internalState.peripheral.call(self.id,\"setAnalogOutput\",self.internalState.redstone.side,w)end;function u.methods:getBundledInput()return 0 end;function u.methods:getBundledOutput()return 0 end;function u.methods:setBundledOutput(d,w)expect(1,w,\"number\")expect.range(w,0,65535)error(\"Not supported on this device\")end;function u:init()if not self.internalState.redstone or not self.internalState.redstone.side then error(\"No assigned side on redstone device!\",2)end;self.displayName=\"Redstone Integrator '\"..self.id..\"' on side \"..self.internalState.redstone.side end;local x={name=\"peripheral_ap_redstoneIntegrator\",type=\"redstoneIntegrator\",properties={},methods={}}function x:init()for m,y in ipairs{\"top\",\"bottom\",\"left\",\"right\",\"front\",\"back\"}do local z=hardware.add(self,y)z.internalState.redstone={side=y}hardware.register(z,u)end end;registerDriver(x)syslog.log({module=\"advanced-peripherals\"},\"Loaded drivers for Advanced Peripherals\")return{unload=function()deregisterDriver(i)deregisterDriver(o)deregisterDriver(p)deregisterDriver(r)deregisterDriver(s)deregisterDriver(t)deregisterDriver(x)end}\n",setuser=false,permissions={root={write=true,read=true,execute=false}},owner="root",modified=1740881291056,size=7419},["encryptfs.lua"]={type="file",created=1740881292050,worldPermissions={execute=false,read=true,write=false},data="local a={}local b=require\"ccryptolib.aead\"local c=require\"ccryptolib.random\"local d=require\"ccryptolib.sha256\"if not c.isInit()then syslog.log({module=\"encryptfs\"},\"Initializing secure randomizer, this will take a second...\")c.initWithTiming()end;function a:getpath(e,f,g)local h=self.meta;if f==\"/\"or f==\"\"then return h end;local i=split(f,\"/\\\\\")for j,k in ipairs(i)do if not h then return nil elseif h.type~=\"directory\"then return nil,\"Not a directory\"elseif h.permissions[e]then if not h.permissions[e].execute then return nil,\"Permission denied\"end elseif not h.worldPermissions.execute then return nil,\"Permission denied\"end;h=h.contents[k]if h and h.type==\"link\"and not(g and j==#i)then error{link=true,path=filesystem.combine(h.link,table.unpack(i,j+1)),orig=f}end end;return h end;function a:setpath(l,f,m,g)local e=l.user;local h=self.meta;local n=split(f,\"/\\\\\")local o=n[#n]n[#n]=nil;for j,k in ipairs(n)do if h.type~=\"directory\"then error(\"Not a directory\",2)elseif h.permissions[e]then if not h.permissions[e].execute then error(\"Permission denied\",2)end elseif not h.worldPermissions.execute then error(\"Permission denied\",2)end;if not h.contents[k]then h.contents[k]={type=\"directory\",owner=h.owner,permissions=deepcopy(h.permissions),worldPermissions=deepcopy(h.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\",contents={}}end;h=h.contents[k]if h and h.type==\"link\"then error{link=true,path=filesystem.combine(h.link,table.unpack(n,j+1)),orig=f}end end;if h.type~=\"directory\"then error(\"Not a directory\",2)elseif e~=\"root\"then if h.permissions[e]then if not h.permissions[e].execute then error(\"Permission denied\",2)end elseif not h.worldPermissions.execute then error(\"Permission denied\",2)end end;if not g and h.contents[o]and h.contents[o].type==\"link\"then error{link=true,path=h.contents[o].link,orig=f}end;h.contents[o]=m;self:write_meta(l)end;function a:write_meta(l)if os.epoch\"utc\"-self.lastDispatch>1000 then self:write_encrypted(l,self.metapath,serialize(self.meta,{compact=true}))self.lastDispatch=os.epoch\"utc\"end end;function a:read_encrypted(l,p)local q,r=self.fs:open(l,p,\"rb\")if not q then return nil,r end;if q.read(4)~=\"Efs\\x01\"then q.close()return nil,\"Invalid file\"end;local s=q.read(12)local t=q.read(16)local u=q.readAll()q.close()local m=b.decrypt(self.key,s,t,u,s)if not m then return nil,\"Failed to decrypt\"end;return m end;function a:write_encrypted(l,p,m)local s=c.random(12)local u,t=b.encrypt(self.key,s,m,s)syslog.debug(p,#m)local q=assert(self.fs:open(l,p,\"wb\"))q.write(\"Efs\\x01\")q.write(s)q.write(t)q.write(u)q.close()end;function a:new(l,f,v)if type(v.encryptfs_password)~=\"string\"then error(\"Missing password (encryptfs_password option)\")end;if not filesystems[v.encryptfs_basefs or\"craftos\"]then error(\"Unknown base filesystem type '\"..v.encryptfs_basefs..\"'\")end;local w={}for x,y in pairs(v)do if not string.match(x,\"^encryptfs_\")then w[x]=y end end;local z=setmetatable({fs=filesystems[v.encryptfs_basefs or\"craftos\"]:new(l,f,w),lastDispatch=0},{__index=self})local q,r=z.fs:open(l,d.digest(v.encryptfs_password..\" encryptfs salt file \\x12\\x34\\x56\\x78\\x9A\\xBC\\xDE\\xF0\"):gsub(\".\",function(A)return(\"%02x\"):format(A:byte())end),\"rb\")if not q then if z.fs.unmount then z.fs:unmount(l)end;error(\"Could not open salt file: \"..r..\" - make sure the filesystem is properly formatted\")end;if q.read(4)~=\"Efs\\x00\"then q.close()if z.fs.unmount then z.fs:unmount(l)end;error(\"Invalid filesystem structure - make sure the filesystem is properly formatted\")end;local B=q.read(28)z.metapath=q.read(32):gsub(\".\",function(A)return(\"%02x\"):format(A:byte())end)q.close()syslog.log({module=\"encryptfs\"},\"Generating key, this will hang the system for a few seconds...\")z.key=d.pbkdf2(v.encryptfs_password,B,v.encryptfs_iter or 5000)z.meta,r=z:read_encrypted(l,z.metapath)if not z.meta then if z.fs.unmount then z.fs:unmount(l)end;error(\"Could not read meta file: \"..r..\" - make sure the filesystem is properly formatted\")end;z.meta=unserialize(z.meta)return z end;local C=setmetatable({},{__mode=\"k\"})local function D(l,E,F,G,H)local I=C[F]if not I then error(\"Invalid file handle\")end;if H then I.buf=G else I.buf=I.buf..G end;I.self:write_encrypted(l,I.key,I.buf)end;function a:_open_internal(l,f,J)local do_syscall=do_syscall;local K=self:getpath(l.user,f)if not K then return nil,\"No such file\"end;if J==\"r\"or J==\"rb\"then local m,r=self:read_encrypted(l,K.key)if not m then return nil,r end;return filesystem.readhandle(l,m,J==\"rb\")elseif J==\"w\"or J==\"wb\"then local q;q=filesystem.writehandle(l,function(G,H)do_syscall(\"callmodule\",\"encryptfs\",\"_writefile\",q,G,H)end,J==\"wb\")C[q]={self=self,key=K.key,buf=\"\"}return q elseif J==\"a\"or J==\"ab\"then local q;q=filesystem.writehandle(l,function(G,H)do_syscall(\"callmodule\",\"encryptfs\",\"_writefile\",q,G,H)end,J==\"ab\")C[q]={self=self,key=K.key,buf=self:read_encrypted(l,K.key)}return q else return nil,\"Invalid mode\"end end;function a:open(l,f,J)local L,M=pcall(self.stat,self,l,f)if not L then if type(M)==\"table\"then error(M)end;return nil,M elseif not M then if J:sub(1,1)==\"w\"or J:sub(1,1)==\"a\"then local N,O=pcall(self.stat,self,l,fs.getDir(f))if not N or not O then if type(O)==\"table\"then error(O)end;local P,r=pcall(self.mkdir,self,l,fs.getDir(f))if not P then if type(r)==\"table\"then error(r)end;return nil,r:gsub(\"kernel:%d: \",\"\")end;O=self:stat(l,fs.getDir(f))end;if l.user~=\"root\"then local Q=O.permissions[l.user]or O.worldPermissions;if not Q.write then return nil,\"Permission denied\"end end;local R={type=\"file\",owner=l.user,permissions=deepcopy(O.permissions),worldPermissions=deepcopy(O.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\",key=c.random(32):gsub(\".\",function(A)return(\"%02x\"):format(A:byte())end)}local h=R.permissions[O.owner]R.permissions[O.owner]=nil;R.permissions[l.user]=h;self:setpath(l,f,R)return self:_open_internal(l,f,J)else return nil,\"File not found\"end elseif M.type==\"directory\"then return nil,\"Is a directory\"end;if l.user~=\"root\"then local Q=M.permissions[l.user]or M.worldPermissions;if J:sub(1,1)==\"r\"and not Q.read or(J:sub(1,1)==\"w\"or J:sub(1,1)==\"a\")and not Q.write then return nil,\"Permission denied\"end end;if M.type==\"fifo\"then local R=self:getpath(l.user,f)local S=fifos[R]if not S then S={data=\"\"}fifos[R]=S end;return filesystem.fifohandle(l,S,J)end;return self:_open_internal(l,f,J)end;function a:list(l,f)local m=self:getpath(l.user,f)if not m or m.type~=\"directory\"then error(f..\": Not a directory\",2)end;if l.user~=\"root\"then local Q=m.permissions[l.user]or m.worldPermissions;if not Q.read then error(f..\": Permission denied\",2)end end;local T={}for x in pairs(m.contents)do T[#T+1]=x end;table.sort(T)return T end;function a:stat(l,f,g)local m,r=self:getpath(l.user,f,g)if not m then return nil,r or\"No such file\"end;if m.type==\"file\"then return self.fs:stat(l,m.key,g)end;local U=self.fs:stat(l,\"\")return{size=m.type==\"directory\"and#m.contents or 0,type=m.type,created=m.created,modified=m.modified,owner=m.owner,permissions=deepcopy(m.permissions),worldPermissions=deepcopy(m.worldPermissions),setuser=m.setuser,capacity=U.capacity,freeSpace=U.freeSpace,link=m.link,special={}}end;function a:remove(l,f)if self.readOnly then error(\"Read-only filesystem\",2)end;local V=self:getpath(l.user,fs.getDir(f))local p=fs.getName(f)if not V or V.type~=\"directory\"or not V.contents[p]then return end;if l.user~=\"root\"and not(V.permissions[l.user]or V.worldPermissions).write then error(f..\": Permission denied\",2)end;local m=V.contents[p]if l.user~=\"root\"and not(m.permissions[l.user]or m.worldPermissions).write then error(f..\": Permission denied\",2)end;local function W(X)local Q=X.permissions[l.user]or X.worldPermissions;if l.user~=\"root\"and not Q.write then error(f..\": Permission denied\",3)end;if X.type==\"directory\"then if l.user~=\"root\"and not Q.read then error(f..\": Permission denied\",3)end;for Y,y in pairs(X.contents)do W(y)end end end;W(m)local function Z(k,_)local a0=k.contents[_]if a0.type==\"file\"then self.fs:remove(l,a0.key)elseif a0.type==\"directory\"then for Y,y in ipairs(a0.contents)do Z(a0,y)end end;k.contents[_]=nil;k.modified=os.epoch\"utc\"end;Z(V,p)self:write_meta(l)end;function a:rename(l,a1,a2)if self.readOnly then error(\"Read-only filesystem\",2)end;local a3=self:getpath(l.user,fs.getDir(a1))local a4=fs.getName(a1)if not a3 or a3.type~=\"directory\"or not a3.contents[a4]then error(a1 ..\": No such file or directory\",2)end;if l.user~=\"root\"and not(a3.permissions[l.user]or a3.worldPermissions).write then error(a1 ..\": Permission denied\",2)end;local a5=a3.contents[a4]if l.user~=\"root\"and not(a5.permissions[l.user]or a5.worldPermissions).write then error(a1 ..\": Permission denied\",2)end;local a6=self:getpath(l.user,fs.getDir(a2))local a7=fs.getName(a2)if not a6 or a6.type~=\"directory\"then error(a2 ..\": No such file or directory\",2)end;if l.user~=\"root\"and not(a6.permissions[l.user]or a6.worldPermissions).write then error(a2 ..\": Permission denied\",2)end;local a8=a6.contents[a7]if a8 then error(a2 ..\": File already exists\",2)end;a6.contents[a7],a3.contents[a4]=a5,nil;local a9=os.epoch\"utc\"a3.modified,a6.modified=a9,a9;self:write_meta(l)end;function a:mkdir(l,f)local h=self.meta;for Y,k in ipairs(split(f,\"/\\\\\"))do local Q=h.permissions[l.user]or h.worldPermissions;if h.type~=\"directory\"then error(f..\": File exists\",2)elseif l.user~=\"root\"and not Q.execute then error(f..\": Permission denied\",2)end;if not h.contents[k]then if l.user~=\"root\"and not Q.write then error(f..\": Permission denied\",2)end;h.contents[k]={type=\"directory\",owner=h.owner,permissions=deepcopy(h.permissions),worldPermissions=deepcopy(h.worldPermissions),created=os.epoch\"utc\",modified=os.epoch\"utc\",contents={}}h.modified=os.epoch\"utc\"end;h=h.contents[k]end;self:write_meta(l)end;function a:link(l,f,aa)local M=self:stat(l,f)if M then error(f..\": File exists\",2)end;local N,O=pcall(self.stat,self,l,fs.getDir(f))if not N or not O then if type(O)==\"table\"then error(O)end;local P,r=pcall(self.mkdir,self,l,fs.getDir(f))if not P then if type(r)==\"table\"then error(r)end;return nil,type(r)==\"string\"and r:gsub(\"kernel:%d: \",\"\")or r end;O=self:stat(l,fs.getDir(f))end;self:setpath(l,f,{type=\"link\",owner=l.user,permissions=deepcopy(O.permissions),worldPermissions=deepcopy(O.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\",path=aa},true)end;function a:mkfifo(l,f)local M=self:stat(l,f)if M then error(f..\": File exists\",2)end;local N,O=pcall(self.stat,self,l,fs.getDir(f))if not N or not O then if type(O)==\"table\"then error(O)end;local P,r=pcall(self.mkdir,self,l,fs.getDir(f))if not P then if type(r)==\"table\"then error(r)end;return nil,type(r)==\"string\"and r:gsub(\"kernel:%d: \",\"\")or r end;O=self:stat(l,fs.getDir(f))end;self:setpath(l,f,{type=\"fifo\",owner=l.user,permissions=deepcopy(O.permissions),worldPermissions=deepcopy(O.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\"},true)end;function a:chmod(l,f,e,J)local M=self:getpath(l.user,f,true)if not M then error(f..\": No such file or directory\",2)end;if not M.owner or l.user~=\"root\"and l.user~=M.owner then error(f..\": Permission denied\",2)end;if M.type==\"file\"then self.fs:chmod(l,M.key,e,J)end;local Q;if e==nil then Q=M.worldPermissions else Q=M.permissions[e]if not Q then Q=deepcopy(M.worldPermissions)M.permissions[e]=Q end end;if type(J)==\"string\"then if J:match\"^[%+%-=][rwxs]+$\"then local ab=J:sub(1,1)local h={}for A in J:gmatch(\"[rwxs]\")do if A==\"r\"then h.read=true elseif A==\"w\"then h.write=true elseif A==\"s\"then h.setuser=true else h.execute=true end end;if ab==\"+\"then if h.read then Q.read=true end;if h.write then Q.write=true end;if h.execute then Q.execute=true end;if h.setuser then M.setuser=true end elseif ab==\"-\"then if h.read then Q.read=false end;if h.write then Q.write=false end;if h.execute then Q.execute=false end;if h.setuser then M.setuser=false end else Q.read=h.read or false;Q.write=h.write or false;Q.execute=h.execute or false;M.setuser=h.setuser or false end else Q.read=J:sub(1,1)~=\"-\"Q.write=J:sub(2,2)~=\"-\"Q.execute=J:sub(3,3)~=\"-\"M.setuser=J:sub(3,3)==\"s\"end elseif type(J)==\"number\"then M.setuser=bit32.btest(J,8)Q.read=bit32.btest(J,4)Q.write=bit32.btest(J,2)Q.execute=bit32.btest(J,1)else if J.read~=nil then Q.read=J.read end;if J.write~=nil then Q.write=J.write end;if J.execute~=nil then Q.execute=J.execute end;if J.setuser~=nil then M.setuser=J.setuser end end;self:write_meta(l)end;function a:chown(l,f,ac)if self.readOnly then error(\"Read-only filesystem\",2)end;local M=self:getpath(l.user,f,true)if not M then error(f..\": No such file or directory\",2)end;if not M.owner or l.user~=\"root\"and l.user~=M.owner then error(f..\": Permission denied\",2)end;if M.type==\"file\"then self.fs:chown(l,M.key,ac)end;M.owner=ac;M.setuser=false;self:write_meta(l)end;function a:info()local ad,ae,w=self.fs:info()return ad..\":encryptfs\",ae,w end;function a:unmount(l)self:write_encrypted(l,self.metapath,serialize(self.meta,{compact=true}))if self.fs.unmount then self.fs:unmount(l)end end;filesystems.encryptfs=a;syslog.log({module=\"encryptfs\"},\"encryptfs is now loaded\")return{unload=function()filesystems.encryptfs=nil end,_writefile=D}\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292046,size=13188},["yellowbox.lua"]={type="file",created=1740881294687,worldPermissions={execute=false,read=true,write=false},data="if not processes then error(\"This must be loaded as a kernel module.\")end;local a={}local b={}local c={}local d={}local e={}local function f()local g,h=coroutine.yield(\"syscall\",\"getpid\")local i=a[h]coroutine.yield(\"syscall\",\"callmodule\",\"yellowbox\",\"__tick\")local function j(k)for l,m in pairs(i.peripherals)do if m.uuid==k then return l else local g,n=coroutine.yield(\"syscall\",\"devinfo\",k)if m.uuid==n.uuid then return l end end end end;while i.running do local o,p=coroutine.yield()coroutine.yield(\"syscall\",\"syslog\",{module=\"yellowbox\",level=\"debug\"},\"Got event \"..o)if o==\"remote_event\"and type(p.data)==\"table\"then table.insert(p.data,1,p.type)if p.data.n then p.data.n=p.data.n+1 else p.data.n=#p.data end;i.eventQueue[#i.eventQueue+1]=p.data elseif o==\"timer\"then i.eventQueue[#i.eventQueue+1]={\"timer\",p.id,n=2}elseif o==\"alarm\"then i.eventQueue[#i.eventQueue+1]={\"alarm\",p.id,n=2}elseif o==\"disk\"or o==\"disk_eject\"or o==\"monitor_resize\"or o==\"speaker_audio_empty\"then local l=j(p.device)if l then i.eventQueue[#i.eventQueue+1]={o,l}end elseif o==\"mouse_click\"and p.device then local l=j(p.device)if l then i.eventQueue[#i.eventQueue+1]={\"monitor_touch\",l,p.x,p.y}end elseif o==\"modem_message\"then local l=j(p.device)if l then i.eventQueue[#i.eventQueue+1]={o,l,p.channel,p.replyChannel,p.message,p.distance}end end;while#i.eventQueue>0 do coroutine.yield(\"syscall\",\"callmodule\",\"yellowbox\",\"__tick\")end end end;function e.create(q,r,s)expect(1,s,\"table\")expect.field(s,\"bios\",\"string\")expect.field(s,\"root\",\"string\",\"nil\")expect.field(s,\"user\",\"string\",\"nil\")expect.field(s,\"peripherals\",\"table\",\"nil\")expect.field(s,\"http\",\"boolean\",\"nil\")if q.user~=\"root\"then error(\"This function requires root.\",0)end;local i={eventQueue={},peripherals={},redstone={top={input=0,output=0,bundledInput=0,bundledOutput=0},bottom={input=0,output=0,bundledInput=0,bundledOutput=0},left={input=0,output=0,bundledInput=0,bundledOutput=0},right={input=0,output=0,bundledInput=0,bundledOutput=0},front={input=0,output=0,bundledInput=0,bundledOutput=0},back={input=0,output=0,bundledInput=0,bundledOutput=0}},coro=false,running=true,bios=s.bios}local h=syscalls.fork(q,r,f,\"[yellowbox]\")i.pid=h;a[h]=i;local t=processes[h]local u=t.threads[0]t.dependents[#t.dependents+1]={type=\"yellowbox\",gc=function()a[h]=nil end}syscalls.chdir(t,u,\"/\")if s.root then syscalls.chroot(t,u,s.root)end;if s.user then syscalls.setuser(t,u,s.user)end;if s.peripherals then for l,v in pairs(s.peripherals)do local m=hardware.get(v)if not m then i.running=false;error(\"Device '\"..v..\"' does not exist\",0)end;if m.process then i.running=false;error(\"Could not lock device '\"..v..\"'\",0)end;m.process=t.id;m.listeners[t]=true;t.dependents[#t.dependents+1]={type=\"hardware lock\",node=m,gc=function()m.process=nil end}t.dependents[#t.dependents+1]={type=\"hardware listen\",node=m,gc=function()m.listeners[t]=nil end}i.peripherals[l]=m end end;i.tty=terminal.makeTTY(term,51,19)i.tty.id=math.random(0,0x7FFFFFFF)i.tty.process=t;terminal.userTTYs[i.tty]=i.tty;syscalls.stdin(t,u,i.tty)syscalls.stdout(t,u,i.tty)syscalls.stderr(t,u,i.tty)i.env=createLuaLib(t)i.env._G=i.env;i.env._HOST=_HOST:match(\"^[^%(]+\")..\"(YellowBox 1.0 under Phoenix \"..PHOENIX_VERSION..\")\"i.env._CC_DEFAULT_SETTINGS=\"\"i.env.os=nil;i.env.io=nil;i.env.dofile=nil;i.env.loadfile=nil;i.env.load=function(w,l,x,y)return load(w,l,x,y or i.env)end;i.env.loadstring=i.env.load;i.env.getfenv,i.env.setfenv=getfenv,setfenv;i.env.unpack=table.unpack;i.env.require=nil;i.env.package=nil;i.env.print=nil;local function z(A,...)local B=coroutine.create(A)local C=table.pack(B:resume(...))while B:status()==\"suspended\"do C=table.pack(B:resume(coroutine.yield(\"preempt\",...)))end;if not C[1]then error(debug.traceback(B,C[2]),3)end;return table.unpack(C,2,C.n)end;local expect=expect;local filesystem=filesystem;local hardware=hardware;local syscalls=syscalls;local D=terminal.redraw;i.env.fs={}function i.env.fs.list(v)expect(1,v,\"string\")return z(filesystem.list,t,v)end;i.env.fs.combine=fs.combine;i.env.fs.getName=fs.getName;i.env.fs.getDir=fs.getDir;function i.env.fs.getSize(v)expect(1,v,\"string\")local E=z(filesystem.stat,t,v)if not E then return 0 end;return E.size end;function i.env.fs.exists(v)expect(1,v,\"string\")return z(filesystem.stat,t,v)~=nil end;function i.env.fs.isDir(v)expect(1,v,\"string\")local E=z(filesystem.stat,t,v)return E and E.type==\"directory\"end;function i.env.fs.isReadOnly(v)expect(1,v,\"string\")local E=z(filesystem.stat,t,v)if not E then return fs.isReadOnly(fs.getDir(v))end;if E.permissions[t.user]then return not E.permissions[t.user].write else return not E.worldPermissions.write end end;function i.env.fs.makeDir(v)expect(1,v,\"string\")return z(filesystem.mkdir,t,v)end;function i.env.fs.move(F,G)expect(1,F,\"string\")expect(2,G,\"string\")local H=assert(z(filesystem.stat,t,F,true),\"File not found\")local I=z(filesystem.stat,t,G)if I then error(\"File already exists\",2)end;local v=fs.getDir(G)repeat I,v=z(filesystem.stat,t,v),fs.getDir(v)until I;if H.type==\"directory\"then local J=z(filesystem.list,t,F)z(filesystem.mkdir,t,G)for g,K in ipairs(J)do fs.move(fs.combine(F,K),fs.combine(G,K))end elseif H.mountpoint==I.mountpoint then z(filesystem.rename,t,F,G)else local L,M=z(filesystem.open,t,F,\"rb\")if not L then error(M,2)end;local N=L.readAll()L.close()local O,M=z(filesystem.open,t,G,\"wb\")if not O then error(M,2)end;z(filesystem.remove,t,F)if N then O.write(N)end;O.close()end;z(filesystem.chmod,t,G,nil,H.worldPermissions)for P,K in pairs(H.permissions)do z(filesystem.chmod,t,G,P,K)end;if H.owner then z(filesystem.chown,t,G,H.owner)end;if H.setuser then pcall(z,filesystem.chmod,G,H.owner,\"+s\")end end;function i.env.fs.copy(F,G)expect(1,F,\"string\")expect(2,G,\"string\")local E=assert(z(filesystem.stat,t,F),F..\": No such file or directory\")if E.type==\"directory\"then local J=z(filesystem.list,t,F)z(filesystem.mkdir,t,G)for g,K in ipairs(J)do fs.copy(fs.combine(F,K),fs.combine(G,K))end else local L,M=z(filesystem.open,t,F,\"rb\")if not L then error(M,2)end;local O,M=z(filesystem.open,t,G,\"wb\")if not O then L.close()error(M,2)end;repeat local Q=L.read(512)if Q then O.write(Q)end until not Q;O.close()L.close()end end;function i.env.fs.delete(v)expect(1,v,\"string\")return z(filesystem.remove,t,v)end;function i.env.fs.open(v,x)expect(1,v,\"string\")expect(2,x,\"string\")return z(filesystem.open,t,v,x)end;function i.env.fs.getDrive(v)expect(1,v,\"string\")local E=z(filesystem.stat,t,v)if not E then return fs.getFreeSpace(fs.getDir(v))end;return E.mountpoint end;function i.env.fs.getFreeSpace(v)expect(1,v,\"string\")local E=z(filesystem.stat,t,v)if not E then return fs.getFreeSpace(fs.getDir(v))end;return E.freeSpace end;function i.env.fs.getCapacity(v)expect(1,v,\"string\")local E=z(filesystem.stat,t,v)if not E then return fs.getFreeSpace(fs.getDir(v))end;return E.capacity end;function i.env.fs.attributes(v)expect(1,v,\"string\")local E=z(filesystem.stat,t,v)if not E then return nil end;local R;if E.permissions[t.user]then R=not E.permissions[t.user].write else R=not E.worldPermissions.write end;return{size=E.size,isDir=E.type==\"directory\",isReadOnly=R,created=E.created,modified=E.modified}end;i.env.os={}function i.env.os.startTimer(S)return syscalls.timer(t,u,S)end;function i.env.os.cancelTimer(T)return syscalls.cancel(t,u,T)end;function i.env.os.setAlarm(S)return syscalls.alarm(t,u,S)end;i.env.os.cancelAlarm=i.env.os.cancelTimer;function i.env.os.shutdown()i.coro=nil end;function i.env.os.reboot()i.coro=false end;function i.env.os.queueEvent(o,...)expect(1,o,\"string\")i.eventQueue[#i.eventQueue+1]={o,...,n=select(\"#\",...)+1}end;i.env.os.getComputerID=os.getComputerID;i.env.os.computerID=i.env.os.getComputerID;function i.env.os.getComputerLabel()return i.label end;i.env.os.computerLabel=i.env.os.getComputerLabel;function i.env.os.setComputerLabel(U)expect(1,U,\"string\",\"nil\")i.label=U end;function i.env.os.clock()return(os.epoch\"utc\"-i.start)/1000 end;i.env.os.time=os.time;i.env.os.day=os.day;i.env.os.epoch=os.epoch;i.env.os.date=os.date;i.env.peripheral={}function i.env.peripheral.isPresent(l)expect(1,l,\"string\")return i.peripherals[l]~=nil end;function i.env.peripheral.getType(l)expect(1,l,\"string\")local m=i.peripherals[l]if not m then return nil end;local V={}for g,K in ipairs(m.drivers)do V[#V+1]=K.type end;return table.unpack(V)end;function i.env.peripheral.hasType(l,type)expect(1,l,\"string\")expect(2,type,\"string\")local m=i.peripherals[l]if not m then error(\"No such peripheral\",2)end;for g,K in ipairs(m.drivers)do if K.type==type then return true end end;return false end;function i.env.peripheral.getMethods(l)expect(1,l,\"string\")local m=i.peripherals[l]if not m then error(\"No such peripheral\",2)end;if m.internalState.peripheral then return m.internalState.peripheral.getMethods(m.id)else local W={}for g,K in ipairs(m.drivers)do for P in pairs(K.methods)do W[#W+1]=P end end;return W end end;function i.env.peripheral.call(l,X,...)expect(1,l,\"string\")expect(2,X,\"string\")local m=i.peripherals[l]if not m then error(\"No such peripheral\",2)end;if m.internalState.peripheral then return m.internalState.peripheral.call(m.id,X,...)else return hardware.call(t,m,X,...)end end;i.env.redstone={}i.env.rs=i.env.redstone;function i.env.rs.getSides()return{\"top\",\"bottom\",\"left\",\"right\",\"front\",\"back\"}end;function i.env.rs.getInput(Y)expect(1,Y,\"string\")if not i.redstone[Y]then error(\"Invalid side\",2)end;return i.redstone[Y].input~=0 end;function i.env.rs.getOutput(Y)expect(1,Y,\"string\")if not i.redstone[Y]then error(\"Invalid side\",2)end;return i.redstone[Y].output~=0 end;function i.env.rs.setOutput(Y,Z)expect(1,Y,\"string\")expect(2,Z,\"boolean\")if not i.redstone[Y]then error(\"Invalid side\",2)end;i.redstone[Y].output=Z and 15 or 0 end;function i.env.rs.getAnalogInput(Y)expect(1,Y,\"string\")if not i.redstone[Y]then error(\"Invalid side\",2)end;return i.redstone[Y].input end;function i.env.rs.getAnalogOutput(Y)expect(1,Y,\"string\")if not i.redstone[Y]then error(\"Invalid side\",2)end;return i.redstone[Y].output end;function i.env.rs.setAnalogOutput(Y,Z)expect(1,Y,\"string\")expect(2,Z,\"number\")Z=math.floor(Z)expect.range(Z,0,15)if not i.redstone[Y]then error(\"Invalid side\",2)end;i.redstone[Y].output=Z end;i.env.rs.getAnalogueInput=i.env.rs.getAnalogInput;i.env.rs.getAnalogueOutput=i.env.rs.getAnalogOutput;i.env.rs.setAnalogueOutput=i.env.rs.setAnalogOutput;function i.env.rs.getBundledInput(Y)expect(1,Y,\"string\")if not i.redstone[Y]then error(\"Invalid side\",2)end;return i.redstone[Y].bundledInput end;function i.env.rs.getBundledOutput(Y)expect(1,Y,\"string\")if not i.redstone[Y]then error(\"Invalid side\",2)end;return i.redstone[Y].bundledOutput end;function i.env.rs.setBundledOutput(Y,Z)expect(1,Y,\"string\")expect(2,Z,\"number\")Z=math.floor(Z)expect.range(Z,0,65535)if not i.redstone[Y]then error(\"Invalid side\",2)end;i.redstone[Y].bundledOutput=Z end;function i.env.rs.testBundledInput(Y,_)expect(1,Y,\"string\")expect(2,_,\"number\")if not i.redstone[Y]then error(\"Invalid side\",2)end;return bit32.btest(i.redstone[Y].bundledInput,_)end;local a0=terminal.openterm(i.tty,t)i.env.term={}i.env.term.nativePaletteColor=term.nativePaletteColor;i.env.term.nativePaletteColour=term.nativePaletteColour;i.env.term.write=function(...)a0.write(...)D(i.tty)end;i.env.term.scroll=function(...)a0.scroll(...)D(i.tty)end;i.env.term.getCursorPos=a0.getCursorPos;i.env.term.setCursorPos=function(...)a0.setCursorPos(...)D(i.tty)end;i.env.term.getCursorBlink=a0.getCursorBlink;i.env.term.setCursorBlink=function(...)a0.setCursorBlink(...)D(i.tty)end;i.env.term.getSize=a0.getSize;i.env.term.clear=function(...)a0.clear(...)D(i.tty)end;i.env.term.clearLine=function(...)a0.clearLine(...)D(i.tty)end;i.env.term.isColor=a0.isColor;i.env.term.isColour=a0.isColour;i.env.term.blit=function(...)a0.blit(...)D(i.tty)end;function i.env.term.getBackgroundColor()return 2^a0.getBackgroundColor()end;function i.env.term.getTextColor()return 2^a0.getTextColor()end;function i.env.term.setBackgroundColor(a1)expect(1,a1,\"number\")a1=math.floor(a1)expect.range(a1,1,65535)return a0.setBackgroundColor(select(2,math.frexp(a1))-1)end;function i.env.term.setTextColor(a1)expect(1,a1,\"number\")a1=math.floor(a1)expect.range(a1,1,65535)return a0.setTextColor(select(2,math.frexp(a1))-1)end;function i.env.term.getPaletteColor(a1)expect(1,a1,\"number\")a1=math.floor(a1)expect.range(a1,1,65535)return a0.getPaletteColor(select(2,math.frexp(a1))-1)end;function i.env.term.setPaletteColor(a1,a2,a3,a4)expect(1,a1,\"number\")a1=math.floor(a1)expect.range(a1,1,65535)a0.setPaletteColor(select(2,math.frexp(a1))-1,a2,a3,a4)D(i.tty)end;i.env.term.getBackgroundColour=i.env.term.getBackgroundColor;i.env.term.setBackgroundColour=i.env.term.setBackgroundColor;i.env.term.getTextColour=i.env.term.getTextColor;i.env.term.setTextColour=i.env.term.setTextColor;i.env.term.setPaletteColour=i.env.term.setPaletteColor;i.env.term.getPaletteColour=i.env.term.getPaletteColor;for g,K in pairs(i.env.fs)do pcall(function()setfenv(K,i.env)debug.protect(K)end)end;for g,K in pairs(i.env.os)do pcall(function()setfenv(K,i.env)debug.protect(K)end)end;for g,K in pairs(i.env.peripheral)do pcall(function()setfenv(K,i.env)debug.protect(K)end)end;for g,K in pairs(i.env.rs)do pcall(function()setfenv(K,i.env)debug.protect(K)end)end;for g,K in pairs(i.env.term)do pcall(function()setfenv(K,i.env)debug.protect(K)end)end;if s.http~=false and http~=nil then i.env.http={}local a5,a6,a7=http.request,http.checkURL,http.websocket;function i.env.http.request(s,N,a8,a9)expect(1,s,\"table\",\"string\")if type(s)==\"string\"then s={url=s,body=N,headers=a8,binary=a9}end;local aa=a5(s)if aa then b[s.url]=i end;return aa end;function i.env.http.checkURL(ab)expect(1,ab,\"string\")local aa=a6(ab)if aa then c[ab]=i end;return aa end;function i.env.http.websocket(s,a8)expect(1,s,\"table\",\"string\")if type(s)==\"string\"then local aa=a7(s,a8)if aa then d[s]=i end;return aa else local aa=a7(s)if aa then d[s.url]=i end;return aa end end end;return h end;function e.getTTY(t,u,h)expect(1,h,\"number\")local i=a[h]if not i then return nil end;i.tty.process=t;local ac=setmetatable({},{__index=i.tty,__metatable={}})terminal.userTTYs[ac]=i.tty;return ac end;function e.shutdown(t,u,h)expect(1,h,\"number\")local i=a[h]if not i then error(\"Invalid PID\")end;i.coro=nil end;function e.reboot(t,u,h)expect(1,h,\"number\")local i=a[h]if not i then error(\"Invalid PID\")end;i.coro=false end;function e.stop(t,u,h)expect(1,h,\"number\")if t.user~=\"root\"then error(\"This function requires root.\",0)end;local i=a[h]if not i then error(\"Invalid PID\")end;i.running=false end;function e.__tick(t,u)local i=a[t.id]if not i then return end;if not i.coro then if i.coro==nil then i.eventQueue={}i.env.term.setBackgroundColor(32768)i.env.term.setTextColor(1)i.env.term.clear()i.env.term.setCursorPos(1,1)i.env.term.setCursorBlink(false)return end;local A,M=load(i.bios,\"@bios.lua\",\"t\",i.env)if not A then syslog.log({module=\"yellowbox\",process=t.id,level=\"error\"},\"Could not load BIOS:\",M)i.coro=nil;return end;i.coro=coroutine.create(A)i.start=os.epoch\"utc\"local C={n=0}while true do C=table.pack(i.coro:resume(table.unpack(C,1,C.n)))if not C[1]then syslog.log({module=\"yellowbox\",process=t.id,level=\"error\"},\"Error running BIOS:\",C[2])i.coro=nil;return end;if i.coro:status()~=\"suspended\"then syslog.log({module=\"yellowbox\",process=t.id,level=\"error\"},\"BIOS exited\")i.coro=nil;return end;if C[2]==\"preempt\"then C=table.pack(coroutine.yield(table.unpack(C,3,C.n)))else i.filter=C[2]break end end;return end;if#i.eventQueue==0 then return end;local ad=table.remove(i.eventQueue,1)syslog.debug(\"Sending event to box\",table.unpack(ad,1,ad.n))if i.filter==nil or i.filter==ad[1]or ad[1]==\"terminate\"then while true do ad=table.pack(i.coro:resume(table.unpack(ad,1,ad.n)))if not ad[1]then syslog.log({module=\"yellowbox\",process=t.id,level=\"error\"},\"Computer threw an error:\",ad[1])i.coro=nil;return end;if i.coro:status()~=\"suspended\"then syslog.log({module=\"yellowbox\",process=t.id,level=\"error\"},\"Computer exited\")i.coro=nil;return end;if ad[2]==\"preempt\"then ad=table.pack(coroutine.yield(table.unpack(ad,3,ad.n)))else i.filter=ad[2]break end end else syslog.debug(\"Event filtered\")end end;local function ae(ad)if b[ad[2]]then b[ad[2]].eventQueue[#b[ad[2]].eventQueue+1]=ad;processes[b[ad[2]].pid].eventQueue[#processes[b[ad[2]].pid].eventQueue+1]={\"resume\",{}}b[ad[2]]=nil;return true end end;local function af(ad)if d[ad[2]]then d[ad[2]].eventQueue[#d[ad[2]].eventQueue+1]=ad;processes[d[ad[2]].pid].eventQueue[#processes[d[ad[2]].pid].eventQueue+1]={\"resume\",{}}if ad[1]==\"websocket_closed\"or ad[1]==\"websocket_failure\"then d[ad[2]]=nil end;return true end end;eventHooks.http_failure=eventHooks.http_failure or{}eventHooks.http_success=eventHooks.http_success or{}eventHooks.http_check=eventHooks.http_check or{}eventHooks.websocket_closed=eventHooks.websocket_closed or{}eventHooks.websocket_failure=eventHooks.websocket_failure or{}eventHooks.websocket_message=eventHooks.websocket_message or{}eventHooks.websocket_success=eventHooks.websocket_success or{}local ag={http_failure=#eventHooks.http_failure+1,http_success=#eventHooks.http_success+1,http_check=#eventHooks.http_check+1,websocket_closed=#eventHooks.websocket_closed+1,websocket_failure=#eventHooks.websocket_failure+1,websocket_message=#eventHooks.websocket_message+1,websocket_success=#eventHooks.websocket_success+1}eventHooks.http_failure[ag.http_failure]=ae;eventHooks.http_success[ag.http_success]=ae;eventHooks.websocket_closed[ag.websocket_closed]=af;eventHooks.websocket_failure[ag.websocket_failure]=af;eventHooks.websocket_message[ag.websocket_message]=af;eventHooks.websocket_success[ag.websocket_success]=af;eventHooks.http_check[ag.http_check]=function(ad)if c[ad[2]]then c[ad[2]].eventQueue[#c[ad[2]].eventQueue+1]=ad;processes[c[ad[2]].pid].eventQueue[#processes[c[ad[2]].pid].eventQueue+1]={\"resume\",{}}c[ad[2]]=nil;return true end end;function e.unload()for h,i in pairs(a)do i.running=false end;table.remove(eventHooks.http_failure,ag.http_failure)table.remove(eventHooks.http_success,ag.http_success)table.remove(eventHooks.websocket_closed,ag.websocket_closed)table.remove(eventHooks.websocket_failure,ag.websocket_failure)table.remove(eventHooks.websocket_message,ag.websocket_message)table.remove(eventHooks.websocket_success,ag.websocket_success)end;syslog.log({module=\"yellowbox\"},\"YellowBox is now loaded\")return e\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881294670,size=18392},["spanfs.lua"]={type="file",created=1740881293902,worldPermissions={execute=false,read=true,write=false},data="if not PHOENIX_VERSION then error(\"This file must be loaded as a kernel module.\")end;if not filesystem.readhandle then error(\"This module requires Phoenix 0.0.4 or later.\")end;do local _={disks={[0]=\"/disk\",\"/disk2\",\"/disk1\",\"/disk3\"},uuid=\"7f747493-a515-4dbd-bc63-b74070882b24\",name=\"Test span\",index={meta={size=0,created=0,modified=0,type=\"directory\",owner=\"root\",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={[\"test.txt\"]={meta={size=13,created=0,modified=0,type=\"file\",owner=\"root\",permissions={root={read=true,write=true,execute=false}},worldPermissions={read=true,write=false,execute=false},setuser=false},uuid=\"0de93ec6-2cf9-491c-bc59-04a9977606f9\",ids={2,1},checksum=\"6b72b48f\"}}}}end;local a={[0]=0x00000000,0x77073096,0xee0e612c,0x990951ba,0x076dc419,0x706af48f,0xe963a535,0x9e6495a3,0x0edb8832,0x79dcb8a4,0xe0d5e91e,0x97d2d988,0x09b64c2b,0x7eb17cbd,0xe7b82d07,0x90bf1d91,0x1db71064,0x6ab020f2,0xf3b97148,0x84be41de,0x1adad47d,0x6ddde4eb,0xf4d4b551,0x83d385c7,0x136c9856,0x646ba8c0,0xfd62f97a,0x8a65c9ec,0x14015c4f,0x63066cd9,0xfa0f3d63,0x8d080df5,0x3b6e20c8,0x4c69105e,0xd56041e4,0xa2677172,0x3c03e4d1,0x4b04d447,0xd20d85fd,0xa50ab56b,0x35b5a8fa,0x42b2986c,0xdbbbc9d6,0xacbcf940,0x32d86ce3,0x45df5c75,0xdcd60dcf,0xabd13d59,0x26d930ac,0x51de003a,0xc8d75180,0xbfd06116,0x21b4f4b5,0x56b3c423,0xcfba9599,0xb8bda50f,0x2802b89e,0x5f058808,0xc60cd9b2,0xb10be924,0x2f6f7c87,0x58684c11,0xc1611dab,0xb6662d3d,0x76dc4190,0x01db7106,0x98d220bc,0xefd5102a,0x71b18589,0x06b6b51f,0x9fbfe4a5,0xe8b8d433,0x7807c9a2,0x0f00f934,0x9609a88e,0xe10e9818,0x7f6a0dbb,0x086d3d2d,0x91646c97,0xe6635c01,0x6b6b51f4,0x1c6c6162,0x856530d8,0xf262004e,0x6c0695ed,0x1b01a57b,0x8208f4c1,0xf50fc457,0x65b0d9c6,0x12b7e950,0x8bbeb8ea,0xfcb9887c,0x62dd1ddf,0x15da2d49,0x8cd37cf3,0xfbd44c65,0x4db26158,0x3ab551ce,0xa3bc0074,0xd4bb30e2,0x4adfa541,0x3dd895d7,0xa4d1c46d,0xd3d6f4fb,0x4369e96a,0x346ed9fc,0xad678846,0xda60b8d0,0x44042d73,0x33031de5,0xaa0a4c5f,0xdd0d7cc9,0x5005713c,0x270241aa,0xbe0b1010,0xc90c2086,0x5768b525,0x206f85b3,0xb966d409,0xce61e49f,0x5edef90e,0x29d9c998,0xb0d09822,0xc7d7a8b4,0x59b33d17,0x2eb40d81,0xb7bd5c3b,0xc0ba6cad,0xedb88320,0x9abfb3b6,0x03b6e20c,0x74b1d29a,0xead54739,0x9dd277af,0x04db2615,0x73dc1683,0xe3630b12,0x94643b84,0x0d6d6a3e,0x7a6a5aa8,0xe40ecf0b,0x9309ff9d,0x0a00ae27,0x7d079eb1,0xf00f9344,0x8708a3d2,0x1e01f268,0x6906c2fe,0xf762575d,0x806567cb,0x196c3671,0x6e6b06e7,0xfed41b76,0x89d32be0,0x10da7a5a,0x67dd4acc,0xf9b9df6f,0x8ebeeff9,0x17b7be43,0x60b08ed5,0xd6d6a3e8,0xa1d1937e,0x38d8c2c4,0x4fdff252,0xd1bb67f1,0xa6bc5767,0x3fb506dd,0x48b2364b,0xd80d2bda,0xaf0a1b4c,0x36034af6,0x41047a60,0xdf60efc3,0xa867df55,0x316e8eef,0x4669be79,0xcb61b38c,0xbc66831a,0x256fd2a0,0x5268e236,0xcc0c7795,0xbb0b4703,0x220216b9,0x5505262f,0xc5ba3bbe,0xb2bd0b28,0x2bb45a92,0x5cb36a04,0xc2d7ffa7,0xb5d0cf31,0x2cd99e8b,0x5bdeae1d,0x9b64c2b0,0xec63f226,0x756aa39c,0x026d930a,0x9c0906a9,0xeb0e363f,0x72076785,0x05005713,0x95bf4a82,0xe2b87a14,0x7bb12bae,0x0cb61b38,0x92d28e9b,0xe5d5be0d,0x7cdcefb7,0x0bdbdf21,0x86d3d2d4,0xf1d4e242,0x68ddb3f8,0x1fda836e,0x81be16cd,0xf6b9265b,0x6fb077e1,0x18b74777,0x88085ae6,0xff0f6a70,0x66063bca,0x11010b5c,0x8f659eff,0xf862ae69,0x616bffd3,0x166ccf45,0xa00ae278,0xd70dd2ee,0x4e048354,0x3903b3c2,0xa7672661,0xd06016f7,0x4969474d,0x3e6e77db,0xaed16a4a,0xd9d65adc,0x40df0b66,0x37d83bf0,0xa9bcae53,0xdebb9ec5,0x47b2cf7f,0x30b5ffe9,0xbdbdf21c,0xcabac28a,0x53b39330,0x24b4a3a6,0xbad03605,0xcdd70693,0x54de5729,0x23d967bf,0xb3667a2e,0xc4614ab8,0x5d681b02,0x2a6f2b94,0xb40bbe37,0xc30c8ea1,0x5a05df1b,0x2d02ef8d}local function b(c,d)d=d and bit32.bnot(d)or 0xFFFFFFFF;for e=1,#c do d=bit32.bxor(a[bit32.band(bit32.bxor(c:byte(e),bit32.band(d,0xFF)))],bit32.rshift(d,8))end;return bit32.bnot(d)end;local function f()return('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'):gsub('[xy]',function(g)local h=g=='x'and math.random(0,0xf)or math.random(8,0xb)return('%x'):format(h)end)end;local function i(j,k)local l=fs.combine(j.root,k:sub(1,1)==\"/\"and\"\"or j.dir,k)if\"/\"..l..\"/\"~=j.root and l:find(j.root:sub(2),1,true)~=1 then error(k..\": No such file or directory\",4)end;return l end;local m={}local n={file=0,link=2,directory=5,fifo=6,[0]=\"file\",[2]=\"link\",[5]=\"directory\",[6]=\"fifo\"}local function o(p)local q=(\"<I\"):unpack(p.read(4))local r=p.read(q)local s={meta={permissions={}}}local type,t,u,v,w;s.meta.size,s.meta.created,s.meta.modified,type,t,u,s.meta.owner,v,w=(\"<II8I8BBs2s2B\"):unpack(r)s.meta.type=n[type]s.meta.setuser=bit32.btest(t,0x80)s.meta.worldPermissions={read=bit32.btest(t,4),write=bit32.btest(t,2),execute=bit32.btest(t,1)}for _=1,v do local x,y;x,y,w=(\"<s2B\"):unpack(r,w)s.meta.permissions[x]={read=bit32.btest(y,4),write=bit32.btest(y,2),execute=bit32.btest(y,1)}end;if type==0 then local z=p.read(16)s.uuid=z:gsub(\".\",function(g)return(\"%02x\"):format(g:byte())end):gsub(\"(%x%x%x%x%x%x%x%x)(%x%x%x%x)(%x%x%x%x)(%x%x%x%x)(%x%x%x%x%x%x%x%x%x%x%x%x)\",\"%1-%2-%3-%4-%5\")local A=(\"<H\"):unpack(p.read(2))s.ids={(\"<\"..(\"H\"):rep(A)):unpack(p.read(A*2))}s.ids[#s.ids]=nil;s.checksum=(\"<I\"):unpack(p.read(4))elseif type==2 then local B=(\"<H\"):unpack(p.read(2))s.link=p.read(B)elseif type==5 then local C=(\"<I\"):unpack(p.read(4))s.contents={}for _=1,C do local D,E=o(p)s.contents[D]=E end end;return u,s end;local function F(p,s,u)local G=\"\"local v=0;for H,h in pairs(s.meta.permissions)do v=v+1;G=G..(\"<s2B\"):pack(H,(h.read and 4 or 0)+(h.write and 2 or 0)+(h.execute and 1 or 0))end;local I=(\"<II8I8BBs2s2B\"):pack(s.meta.size,s.meta.created,s.meta.modified,n[s.meta.type],(s.meta.setuser and 128 or 0)+(s.meta.worldPermissions.read and 4 or 0)+(s.meta.worldPermissions.write and 2 or 0)+(s.meta.worldPermissions.execute and 1 or 0),u or\"\",s.meta.owner,v)..G;p.write((\"<I\"):pack(#I)..I)if s.meta.type==\"file\"then p.write(s.uuid:gsub(\"%-\",\"\"):gsub(\"%x%x\",function(J)return string.char(tonumber(J,16))end)..(\"<\"..(\"H\"):rep(#s.ids+1)):pack(#s.ids,table.unpack(s.ids))..(\"<I\"):pack(s.checksum))elseif s.meta.type==\"link\"then p.write((\"<s2\"):pack(s.link))elseif s.meta.type==\"directory\"then local D=0;for _ in pairs(s.contents)do D=D+1 end;p.write((\"<I4\"):pack(D))for H,h in pairs(s.contents)do F(p,h,H)end end end;local function K(q,L,M)q=math.max(q,500)local N,O={},{}for _,h in ipairs(M)do O[h]=true end;for _,h in ipairs(L)do if not O[h]and h.space>=500 then N[#N+1]=h end end;table.sort(N,function(P,Q)if P.space==Q.space then return P.id>Q.id else return P.space>Q.space end end)local R={}while q>N[1].space do R[N[1].id]=N[1].space;q=q-N[1].space;table.remove(N,1)if#N==0 then return nil end end;if q==0 then return R end;table.sort(N,function(P,Q)if P.space==Q.space then return P.id>Q.id else return P.space>Q.space end end)for e=#N,1,-1 do if q<N[e].space then R[N[e].id]=q;return R end end;return nil end;function m:_write_meta()local p=assert(fs.open(fs.combine(self.disks[0],\"index\"),\"wb\"))F(p,self.index,self.name)p.close()end;function m:getpath(x,k,S)local T=self.index;local U=split(fs.combine(k),\"/\\\\\")for e,l in ipairs(U)do if not T then return nil elseif T.meta.type~=\"directory\"then error(\"Not a directory\",2)elseif T.meta.permissions[x]then if not T.meta.permissions[x].execute then error(\"Permission denied\",2)end elseif not T.meta.worldPermissions.execute then error(\"Permission denied\",2)end;T=T.contents[l]if T and T.meta.type==\"link\"and not(S and e==#U)then error{link=true,path=filesystem.combine(T.link,table.unpack(U,e+1)),orig=k}end end;return T end;function m:setpath(x,k,r,S)local T=self.index;local E=split(k,\"/\\\\\")local V=E[#E]E[#E]=nil;for e,l in ipairs(E)do if T.meta.type~=\"directory\"then error(\"Not a directory\",2)elseif T.meta.permissions[x]then if not T.meta.permissions[x].execute then error(\"Permission denied\",2)end elseif not T.meta.worldPermissions.execute then error(\"Permission denied\",2)end;if not T.contents[l]then T.contents[l]={meta={type=\"directory\",owner=T.meta.owner,permissions=deepcopy(T.meta.permissions),worldPermissions=deepcopy(T.meta.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\"},contents={}}end;T=T.contents[l]if T and T.meta.type==\"link\"then error{link=true,path=filesystem.combine(T.link,table.unpack(E,e+1)),orig=k}end end;if T.meta.type~=\"directory\"then error(\"Not a directory\",2)elseif x~=\"root\"then if T.meta.permissions[x]then if not T.meta.permissions[x].execute then error(\"Permission denied\",2)end elseif not T.meta.worldPermissions.execute then error(\"Permission denied\",2)end end;if not S and T.contents[V]and T.contents[V].type==\"link\"then error{link=true,path=T.contents[V].link,orig=k}end;T.contents[V]=r;self:_write_meta()end;function m:new(j,k,W)if k:match\"^/\"then k=k:gsub(\"/%.spanfs$\",\"\"):gsub(\"/index$\",\"\")local p=assert(fs.open(fs.combine(k,\".spanfs\"),\"r\"))p.readLine()k=p.readLine()p.close()end;local X=setmetatable({disks={},index={},id={}},{__index=self})local z,u=false,false;if k:match\"^%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x$\"then z=k else u=k end;for _,Y in ipairs{hardware.find(\"drive\")}do local Z=hardware.call(j,Y,\"getMountPath\")if Z then local p=fs.open(fs.combine(Z,\".spanfs\"),\"r\")if p then local D,a0,a1=p.readLine(),p.readLine(),p.readLine()if D==u or a0==z then X.name,X.uuid,X.disks[tonumber(a1)]=D,a0,Z end;p.close()end end end;if#X.disks==0 then error(\"Could not find span '\"..(u or z)..\"'\",2)end;if not X.disks[0]then error(\"Could not find index disk for span '\"..(u or z)..\"'\",2)end;local p,a2=fs.open(fs.combine(X.disks[0],\"index\"),\"rb\")if p then _,X.index=o(p)else syslog.log({level=\"warning\",module=\"spanfs\"},\"Could not open index file for reading on span '\"..(u or z)..\"':\",a2,\". Initializing empty span.\")X.index={meta={size=0,created=os.epoch\"utc\",modified=os.epoch\"utc\",type=\"directory\",owner=j.user,permissions={[j.user]={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}}end;return X end;function m:_open_internal(j,k,a3)local a4,fs,do_syscall,ipairs,assert,pairs,a5=os.epoch,fs,do_syscall,ipairs,assert,pairs,string.sub;local s=self:getpath(j.user,k)if not s then return nil,\"No such file\"end;if a3==\"r\"or a3==\"rb\"then local r=\"\"for _,h in ipairs(s.ids)do if not self.disks[h]then return nil,\"Disk ID \"..h..\" is required by file but not available\"end;local p,a2=fs.open(fs.combine(self.disks[h],s.uuid),\"rb\")if not p then return nil,\"Could not open part on disk ID \"..h..\" (\"..self.disks[h]..\"): \"..a2 end;r=r..(p.readAll()or\"\")p.close()end;local a6=b(r)if a6~=s.checksum then return nil,\"Checksum failed\"end;return filesystem.readhandle(j,r,a3==\"rb\")elseif a3==\"w\"or a3==\"wb\"or#s.ids==0 and(a3==\"a\"or a3==\"ab\")then for _,h in ipairs(s.ids)do fs.delete(fs.combine(self.disks[h],s.uuid))end;s.uuid=f()s.ids={}s.checksum=0;s.meta.modified=a4\"utc\"local a7={}local a8,a9=self.id,self.disks;return filesystem.writehandle(j,function(aa,ab)local a6=b(aa,ab and 0 or s.checksum)if#aa==0 then if ab then s.meta.size=0 end;s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)return end;if#a7~=0 then if ab then for _,h in ipairs(a7)do local a1=a5(aa,1,#h.data)if a1~=h.data then local p=assert(fs.open(fs.combine(a9[h.id],s.uuid),\"wb\"))p.write(a1)p.close()h.data=a1 end;aa=a5(aa,#h.data+1)end;if#aa==0 then if ab then s.meta.size=#aa else s.meta.size=s.meta.size+#aa end;s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)return end end;local ac=fs.getFreeSpace(a9[s.ids[#s.ids]])if ac>0 then local a1=a5(aa,1,ac)local p=assert(fs.open(fs.combine(a9[s.ids[#s.ids]],s.uuid),\"ab\"))p.write(a1)p.close()a7[#a7].data=a7[#a7].data..a1;if ac>#aa then if ab then s.meta.size=#aa else s.meta.size=s.meta.size+#aa end;s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)return end;aa=a5(aa,ac+1)end end;local N={}for e,h in pairs(a9)do if e~=0 then N[#N+1]={id=e,space=fs.getFreeSpace(h)}end end;local ad=K(#aa,N,s.ids)if not ad then if not ab then ab=true;local I=\"\"for _,h in ipairs(a7)do I=I..h.data;for _,ae in ipairs(N)do if ae==h.id then ae.space=ae.space-#h.data end end end;aa=I..aa end;ad=K(#aa,N,{})if not ad then error(\"Out of space\",2)end;for _,h in ipairs(s.ids)do fs.delete(fs.combine(a9[h],s.uuid))end;a7={}s.ids={}end;for e,h in pairs(ad)do local a1=a5(aa,1,h)local p=assert(fs.open(fs.combine(a9[e],s.uuid),\"wb\"))p.write(a1)p.close()a7[#a7+1]={data=a1,id=e}s.ids[#s.ids+1]=e;aa=a5(aa,h+1)end;if ab then s.meta.size=#aa else s.meta.size=s.meta.size+#aa end;s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)end,a3==\"wb\")elseif a3==\"a\"or a3==\"ab\"then local af;do local p=fs.open(fs.combine(self.disks[s.ids[#s.ids]],s.uuid),\"rb\")if p then af=p.readAll()or\"\"p.close()else af=\"\"end end;local a7={{id=s.ids[#s.ids],data=af,offset=#af}}local ag=s.checksum;local ah=s.meta.size;local a8,a9=self.id,self.disks;return filesystem.writehandle(j,function(aa,ab)local a6=b(aa,ab and ag or s.checksum)if#aa==0 then s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)return end;if ab then for _,h in ipairs(a7)do local a1=h.offset and h.data:sub(1,h.offset)..a5(aa,1,#h.data-h.offset)or a5(aa,1,#h.data)if a1~=h.data then local p=assert(fs.open(fs.combine(a9[h.id],s.uuid),\"wb\"))p.write(a1)p.close()h.data=a1 end;aa=a5(aa,#h.data-(h.offset or 0)+1)end;if#aa==0 then if ab then s.meta.size=ah+#aa else s.meta.size=s.meta.size+#aa end;s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)return end end;local ac=fs.getFreeSpace(a9[s.ids[#s.ids]])if ac>0 then local a1=a5(aa,1,ac)local p=assert(fs.open(fs.combine(a9[s.ids[#s.ids]],s.uuid),\"ab\"))p.write(a1)p.close()a7[#a7].data=a7[#a7].data..a1;if ac>#aa then if ab then s.meta.size=ah+#aa else s.meta.size=s.meta.size+#aa end;s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)return end;aa=a5(aa,ac+1)end;local N={}for e,h in pairs(a9)do if e~=0 then N[#N+1]={id=e,space=fs.getFreeSpace(h)}end end;local ad=K(#aa,N,s.ids)if not ad then local ai=\"\"for _,h in ipairs(s.ids)do local aj=false;for _,ae in ipairs(a7)do if ae.id==h then aj=true;break end end;if aj then break end;local p=assert(fs.open(fs.combine(a9[h],s.uuid),\"rb\"))ai=ai..(p.readAll()or\"\")p.close()end;if ab then aa=ai..a5(a7[1].data,1,a7[1].offset)..aa else ab=true;local I=\"\"for _,h in ipairs(a7)do I=I..h.data;for _,ae in ipairs(N)do if ae==h.id then ae.space=ae.space-#h.data end end end;aa=ai..I..aa end;ad=K(#aa,N,{})if not ad then error(\"Out of space\",2)end;for _,h in ipairs(s.ids)do fs.delete(fs.combine(a9[h],s.uuid))end;a7={}s.ids={}ah=0 end;for e,h in pairs(ad)do local a1=a5(aa,1,h)local p=assert(fs.open(fs.combine(a9[e],s.uuid),\"wb\"))p.write(a1)p.close()a7[#a7+1]={data=a1,id=e}aa=a5(aa,h+1)end;if ab then s.meta.size=ah+#aa else s.meta.size=s.meta.size+#aa end;s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)end,a3==\"ab\")else return nil,\"Invalid mode\"end end;function m:open(j,k,a3)local ak,al=pcall(self.stat,self,j,k)if not ak then if type(al)==\"table\"then error(al)end;return nil,al elseif not al then if a3:sub(1,1)==\"w\"or a3:sub(1,1)==\"a\"then local am,an=pcall(self.stat,self,j,fs.getDir(k))if not am or not an then if type(an)==\"table\"then error(an)end;local ao,a2=pcall(self.mkdir,self,j,fs.getDir(k))if not ao then if type(a2)==\"table\"then error(a2)end;return nil,a2:gsub(\"kernel:%d: \",\"\")end;an=self:stat(j,fs.getDir(k))end;if j.user~=\"root\"then local G=an.permissions[j.user]or an.worldPermissions;if not G.write then return nil,\"Permission denied\"end end;local ap={type=\"file\",size=0,owner=j.user,permissions=deepcopy(an.permissions),worldPermissions=deepcopy(an.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\"}local T=ap.permissions[an.owner]ap.permissions[an.owner]=nil;ap.permissions[j.user]=T;self:setpath(j.user,k,{meta=ap,uuid=f(),ids={},checksum=0})return self:_open_internal(j,k,a3)else return nil,\"File not found\"end elseif al.type==\"directory\"then return nil,\"Is a directory\"end;if j.user~=\"root\"then local G=al.permissions[j.user]or al.worldPermissions;if a3:sub(1,1)==\"r\"and not G.read or(a3:sub(1,1)==\"w\"or a3:sub(1,1)==\"a\")and not G.write then return nil,\"Permission denied\"end end;if al.type==\"fifo\"then local ap=self:getpath(j.user,k)local aq=fifos[ap]if not aq then aq={data=\"\"}fifos[ap]=aq end;return filesystem.fifohandle(j,aq,a3)end;return self:_open_internal(j,k,a3)end;function m:list(j,k)local r=self:getpath(j.user,k)if not r or r.meta.type~=\"directory\"then error(k..\": Not a directory\",2)end;if j.user~=\"root\"then local G=r.meta.permissions[j.user]or r.meta.worldPermissions;if not G.read then error(k..\": Permission denied\",2)end end;local R={}for H in pairs(r.contents)do R[#R+1]=H end;table.sort(R)return R end;function m:stat(j,k,S)local r=self:getpath(j.user,k,S)if not r then return nil,\"No such file or directory\"end;local ar,as=0,0;for e,h in pairs(self.disks)do if e~=0 then ar,as=ar+fs.getCapacity(h),as+fs.getFreeSpace(h)end end;return{size=r.meta.size,type=r.meta.type,created=r.meta.created,modified=r.meta.modified,owner=r.meta.owner,permissions=deepcopy(r.meta.permissions),worldPermissions=deepcopy(r.meta.worldPermissions),setuser=r.meta.setuser,capacity=ar,freeSpace=as,link=r.link,special={}}end;function m:remove(j,k)local at=self:getpath(j.user,fs.getDir(k))local u=fs.getName(k)if not at or at.meta.type~=\"directory\"or not at.contents[u]then return end;if j.user~=\"root\"and not(at.meta.permissions[j.user]or at.meta.worldPermissions).write then error(k..\": Permission denied\",2)end;local r=at.contents[u]if j.user~=\"root\"and not(r.meta.permissions[j.user]or r.meta.worldPermissions).write then error(k..\": Permission denied\",2)end;local function au(I)local G=I.meta.permissions[j.user]or I.meta.worldPermissions;if j.user~=\"root\"and not G.write then error(k..\": Permission denied\",3)end;if I.meta.type==\"directory\"then if j.user~=\"root\"and not G.read then error(k..\": Permission denied\",3)end;for _,h in pairs(I.contents)do au(h)end end end;au(r)local function av(s)if s.meta.type==\"directory\"then for _,h in pairs(s.contents)do av(h)end elseif s.meta.type==\"file\"then for _,h in pairs(self.disks)do fs.delete(fs.combine(h,s.uuid))end end end;av(r)at.contents[u]=nil;at.meta.modified=os.epoch\"utc\"self:_write_meta()end;function m:rename(j,aw,ax)local ay=self:getpath(j.user,fs.getDir(aw))local az=fs.getName(aw)if not ay or ay.meta.type~=\"directory\"or not ay.contents[az]then error(aw..\": No such file or directory\",2)end;if j.user~=\"root\"and not(fparen.metat.permissions[j.user]or ay.meta.worldPermissions).write then error(aw..\": Permission denied\",2)end;local aA=ay.contents[az]if j.user~=\"root\"and not(aA.permissions[j.user]or aA.worldPermissions).write then error(aw..\": Permission denied\",2)end;local aB=self:getpath(j.user,fs.getDir(ax))local aC=fs.getName(ax)if not aB or aB.meta.type~=\"directory\"then error(ax..\": No such file or directory\",2)end;if j.user~=\"root\"and not(aB.meta.permissions[j.user]or aB.meta.worldPermissions).write then error(ax..\": Permission denied\",2)end;local aD=aB.contents[aC]if aD then error(ax..\": File already exists\",2)end;aB.contents[aC],ay.contents[az]=aA,nil;local aE=os.epoch\"utc\"ay.meta.modified,aB.meta.modified=aE,aE end;function m:mkdir(j,k)local T=self.index;for _,l in ipairs(split(k,\"/\\\\\"))do local G=T.meta.permissions[j.user]or T.meta.worldPermissions;if T.meta.type~=\"directory\"then error(k..\": File exists\",2)elseif j.user~=\"root\"and not G.execute then error(k..\": Permission denied\",2)end;if not T.contents[l]then if j.user~=\"root\"and not G.write then error(k..\": Permission denied\",2)end;T.contents[l]={meta={type=\"directory\",size=0,owner=T.meta.owner,permissions=deepcopy(T.meta.permissions),worldPermissions=deepcopy(T.meta.worldPermissions),created=os.epoch\"utc\",modified=os.epoch\"utc\"},contents={}}T.meta.modified=os.epoch\"utc\"end;T=T.contents[l]end;self:_write_meta()end;function m:link(j,k,aF)local al=self:stat(j,k)if al then error(k..\": File exists\",2)end;local am,an=pcall(self.stat,self,j,fs.getDir(k))if not am or not an then if type(an)==\"table\"then error(an)end;local ao,a2=pcall(self.mkdir,self,j,fs.getDir(k))if not ao then if type(a2)==\"table\"then error(a2)end;return nil,type(a2)==\"string\"and a2:gsub(\"kernel:%d: \",\"\")or a2 end;an=self:stat(j,fs.getDir(k))end;self:setpath(j.user,k,{meta={type=\"link\",size=0,owner=j.user,permissions=deepcopy(an.permissions),worldPermissions=deepcopy(an.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\"},link=aF},true)end;function m:mkfifo(j,k)local al=self:stat(j,k)if al then error(k..\": File exists\",2)end;local am,an=pcall(self.stat,self,j,fs.getDir(k))if not am or not an then if type(an)==\"table\"then error(an)end;local ao,a2=pcall(self.mkdir,self,j,fs.getDir(k))if not ao then if type(a2)==\"table\"then error(a2)end;return nil,type(a2)==\"string\"and a2:gsub(\"kernel:%d: \",\"\")or a2 end;an=self:stat(j,fs.getDir(k))end;self:setpath(j.user,k,{meta={type=\"fifo\",size=0,owner=j.user,permissions=deepcopy(an.permissions),worldPermissions=deepcopy(an.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\"}},true)end;function m:chmod(j,k,x,a3)local al=self:getpath(j.user,k,true)if not al then error(k..\": No such file or directory\",2)end;if not al.meta.owner or j.user~=\"root\"and j.user~=al.meta.owner then error(k..\": Permission denied\",2)end;local G;if x==nil then G=al.meta.worldPermissions else G=al.meta.permissions[x]if not G then G=deepcopy(al.meta.worldPermissions)al.meta.permissions[x]=G end end;if type(a3)==\"string\"then if a3:match\"^[%+%-=][rwxs]+$\"then local aG=a3:sub(1,1)local T={}for g in a3:gmatch(\"[rwxs]\")do if g==\"r\"then T.read=true elseif g==\"w\"then T.write=true elseif g==\"s\"then T.setuser=true else T.execute=true end end;if aG==\"+\"then if T.read then G.read=true end;if T.write then G.write=true end;if T.execute then G.execute=true end;if T.setuser then al.meta.setuser=true end elseif aG==\"-\"then if T.read then G.read=false end;if T.write then G.write=false end;if T.execute then G.execute=false end;if T.setuser then al.meta.setuser=false end else G.read=T.read or false;G.write=T.write or false;G.execute=T.execute or false;al.meta.setuser=T.setuser or false end else G.read=a3:sub(1,1)~=\"-\"G.write=a3:sub(2,2)~=\"-\"G.execute=a3:sub(3,3)~=\"-\"al.meta.setuser=a3:sub(3,3)==\"s\"end elseif type(a3)==\"number\"then al.meta.setuser=bit32.btest(a3,8)G.read=bit32.btest(a3,4)G.write=bit32.btest(a3,2)G.execute=bit32.btest(a3,1)else if a3.read~=nil then G.read=a3.read end;if a3.write~=nil then G.write=a3.write end;if a3.execute~=nil then G.execute=a3.execute end;if a3.setuser~=nil then al.meta.setuser=a3.setuser end end;self:_write_meta()end;function m:chown(j,k,aH)local al=self:getpath(j.user,k,true)if not al then error(k..\": No such file or directory\",2)end;if not al.meta.owner or j.user~=\"root\"and j.user~=al.meta.owner then error(k..\": Permission denied\",2)end;al.meta.owner=aH;al.meta.setuser=false;self:_write_meta()end;function m:info()return\"spanfs\",self.uuid,{}end;filesystems.spanfs=m;syslog.log({module=\"spanfs\"},\"spanfs is now loaded\")return{_write_meta=function(j,aI,a8)for _,h in pairs(mounts)do if h.id==a8 then return m._write_meta(h)end end;error(\"Invalid mount handle\")end,info=function(j,aI,k)expect(1,k,\"string\")k=i(j,k)local aG=mounts[k]if not aG then error(k..\": No such mount\",2)end;if aG:info()~=\"spanfs\"then error(k..\": Not a spanfs filesystem\",2)end;local aJ={}for _,Y in ipairs{hardware.find(\"drive\")}do local l=hardware.call(j,Y,\"getMountPath\")if l then aJ[l]=Y.uuid end end;local R={disks={},name=aG.name,uuid=aG.uuid}R.freeindex=fs.getFreeSpace(aG.disks[0])for e,h in pairs(aG.disks)do if e~=0 then R.disks[e]={device=aJ[h],space=fs.getFreeSpace(h)}end end;return R end,unload=function()filesystems.spanfs=nil end}\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881293881,size=23852},["luz.lua"]={type="file",created=1740881292861,worldPermissions={execute=false,read=true,write=false},data="if not PHOENIX_VERSION and not entries then error(\"This must be loaded as a kernel module.\")end;if entries then local a,b=...local c=dofile(fs.combine(fs.getDir(b),\"../luz/decompress.lua\"))function cmds.kernel(d)bootcfg.fn=unbios;bootcfg.args={d.path}local e=fs.open(d.path,\"rb\")if e then if e.read(5)==\"\\27LuzQ\"then local f=\"\\27LuzQ\"..e.readAll()e.close()print(\"Loading \"..d.path..\"...\")bootcfg.args={assert(load(c(f),\"@\"..d.path,\"t\",_G))}else e.close()end end end else local g=filesystem.stat(KERNEL,\"/lib/luz/decompress.lua\")if not g then error(\"Could not find Luz modules\")end;if g.worldPermissions.write then error(\"Unsafe permissions on /lib/luz/decompress.lua (must not be world-writable)\")end;for h,i in pairs(g.permissions)do if h~=\"root\"and i.write then error(\"Unsafe permissions on /lib/luz/decompress.lua (writable by non-root user)\")end end;local c=dofile(\"/lib/luz/decompress.lua\")local function j(f,k,l,m)if f:sub(1,5)~=\"\\27LuzQ\"then return nil end;return load(c(f),k,\"t\",m)end;addProcessLoader(j)syslog.log({module=\"luz\"},\"Registered Luz files as executable\")return{unload=function()removeProcessLoader(j)end}end\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292854,size=1129},["fuse.lua"]={type="file",created=1740881292258,worldPermissions={execute=false,read=true,write=false},data="local a={}function a:new(b,c,d)if type(d.fs)~=\"string\"then error(\"Missing filesystem type (fs option)\")end;local e;if d.fs:find\"/\"then e=d.fs else e=\"/lib/fuse/\"..d.fs..\".lua\"end;d.fs=nil;local f,g=userModeCallback(b,function()return assert(loadfile(e))(c,d)end)if not f then error(\"Could not create filesystem: \"..g)end;if type(g)~=\"table\"then error(\"Error creating filesystem\")end;local h={}local i=debug.getmetatable(g)if i and type(i.__index)==\"table\"then h={open=rawget(i.__index,\"open\"),list=rawget(i.__index,\"list\"),stat=rawget(i.__index,\"stat\"),remove=rawget(i.__index,\"remove\"),rename=rawget(i.__index,\"rename\"),mkdir=rawget(i.__index,\"mkdir\"),link=rawget(i.__index,\"link\"),mkfifo=rawget(i.__index,\"mkfifo\"),chmod=rawget(i.__index,\"chmod\"),chown=rawget(i.__index,\"chown\"),unmount=rawget(i.__index,\"unmount\"),init=rawget(i.__index,\"init\")}end;h.open=rawget(g,\"open\")or h.open;h.list=rawget(g,\"list\")or h.list;h.stat=rawget(g,\"stat\")or h.stat;h.remove=rawget(g,\"remove\")or h.remove;h.rename=rawget(g,\"rename\")or h.rename;h.mkdir=rawget(g,\"mkdir\")or h.mkdir;h.link=rawget(g,\"link\")or h.link;h.mkfifo=rawget(g,\"mkfifo\")or h.mkfifo;h.chmod=rawget(g,\"chmod\")or h.chmod;h.chown=rawget(g,\"chown\")or h.chown;h.unmount=rawget(g,\"unmount\")or h.unmount;h.init=rawget(g,\"init\")or h.init;local j=setmetatable({origin=e,path=c,fs=g,methods=h,options=d,running=true},{__index=self})j.process=processes[syscalls.fork(b,nil,function()while j.running do coroutine.yield()end end,\"[fuse \"..e..\"]\")]j.process.threads[0].status=\"paused\"syscalls.stdin(j.process,nil,nil)syscalls.stdout(j.process,nil,nil)syscalls.stderr(j.process,nil,nil)if h.init then userModeCallback(j.process,h.init,g,syscalls.getpinfo(j.process,nil,b.id))end;return j end;function a:open(b,c,k)if not self.methods.open then error(\"Filesystem is missing method 'open'\")end;local l,m;assert(userModeCallback(self.process,function(n)l,m=self.methods.open(self.fs,n,c,k)end,syscalls.getpinfo(self.process,nil,b.id)))if type(l)==\"string\"then return filesystem.readhandle(b,l,m)elseif type(l)==\"function\"then return filesystem.writehandle(b,l,m)else return l,m end end;function a:list(b,c)if not self.methods.list then error(\"Filesystem is missing method 'list'\")end;return select(2,assert(userModeCallback(self.process,self.methods.list,self.fs,syscalls.getpinfo(self.process,nil,b.id),c)))end;function a:stat(b,c,o)if not self.methods.stat then error(\"Filesystem is missing method 'stat'\")end;return select(2,assert(userModeCallback(self.process,self.methods.stat,self.fs,syscalls.getpinfo(self.process,nil,b.id),c,o)))end;function a:remove(b,c)if not self.methods.remove then error(\"Filesystem is missing method 'remove'\")end;assert(userModeCallback(self.process,self.methods.remove,self.fs,syscalls.getpinfo(self.process,nil,b.id),c))end;function a:rename(b,c,p)if not self.methods.rename then error(\"Filesystem is missing method 'rename'\")end;assert(userModeCallback(self.process,self.methods.rename,self.fs,syscalls.getpinfo(self.process,nil,b.id),c,p))end;function a:mkdir(b,c)if not self.methods.mkdir then error(\"Filesystem is missing method 'mkdir'\")end;assert(userModeCallback(self.process,self.methods.mkdir,self.fs,syscalls.getpinfo(self.process,nil,b.id),c))end;function a:link(b,c,q)if not self.methods.link then error(\"Filesystem is missing method 'link'\")end;assert(userModeCallback(self.process,self.methods.link,self.fs,syscalls.getpinfo(self.process,nil,b.id),c,q))end;function a:mkfifo(b,c)if not self.methods.mkfifo then error(\"Filesystem is missing method 'mkfifo'\")end;assert(userModeCallback(self.process,self.methods.mkfifo,self.fs,syscalls.getpinfo(self.process,nil,b.id),c))end;function a:chmod(b,c,r,k)if not self.methods.chmod then error(\"Filesystem is missing method 'chmod'\")end;assert(userModeCallback(self.process,self.methods.chmod,self.fs,syscalls.getpinfo(self.process,nil,b.id),c,r,k))end;function a:chown(b,c,s)if not self.methods.chown then error(\"Filesystem is missing method 'chown'\")end;assert(userModeCallback(self.process,self.methods.chown,self.fs,syscalls.getpinfo(self.process,nil,b.id),c,s))end;function a:info()return self.origin:match\"[^/]*$\":gsub(\"%.lua$\",\"\"),self.path,self.options end;function a:unmount(b)if self.methods.unmount then userModeCallback(self.process,self.methods.unmount,syscalls.getpinfo(self.process,nil,b.id))end;self.running=false;self.process.threads[0].status=\"suspended\"self.process.eventQueue[#self.process.eventQueue+1]={\"resume\",{}}end;filesystems.fuse=a;syslog.log({module=\"fuse\"},\"FUSE is now loaded\")return{unload=function()filesystems.fuse=nil end}\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292249,size=4584},["fatfs.lua"]={type="file",created=1740881292096,worldPermissions={execute=false,read=true,write=false},data="\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292094,size=1},["compressfs.lua"]={type="file",created=1740881291645,worldPermissions={execute=false,read=true,write=false},data="local a,b=pcall(require,\"LibDeflate\")if not a then syslog.log({module=\"compressfs\",level=\"debug\"},\"Could not load libdeflate:\",b)end;local c,d=pcall(require,\"deflateans\")if not c then syslog.log({module=\"compressfs\",level=\"debug\"},\"Could not load deflateans:\",d)end;local e,f=pcall(require,\"luz\")if not e then syslog.log({module=\"compressfs\",level=\"debug\"},\"Could not load luz:\",f)end;local g={}if a then g[#g+1]=\"deflate\"end;if c then g[#g+1]=\"deflateans\"end;if e then g[#g+1]=\"luz\"end;syslog.log({module=\"compressfs\"},\"Supported compression types:\",table.concat(g,\", \"))local h={}function h:new(i,j,k)if not filesystems[k.compressfs_basefs or\"craftos\"]then error(\"Unknown base filesystem type '\"..k.compressfs_basefs..\"'\")end;local l=tonumber(k.compressfs_level)or 5;local m={}for n in(k.compressfs_type or\"deflate\"):gmatch\"[^;,:]+\"do m[n]=true end;local o={}for p,q in pairs(k)do if not string.match(p,\"^compressfs_\")then o[p]=q end end;return setmetatable({fs=filesystems[k.compressfs_basefs or\"craftos\"]:new(i,j,o),types=m,level=l},{__index=self})end;function h:readfile(r)if r.read(3)==\"Cfs\"then local s=r.read()if s==0 then if not a then r.close()return nil,\"Missing required library for compression type (libdeflate)\"end;r.read(4)local t=r.readAll()r.close()return b:DecompressDeflate(t)elseif s==1 then if not c then r.close()return nil,\"Missing required library for compression type (deflateans)\"end;r.read(4)local t=r.readAll()r.close()return d.inflate(t)elseif s==2 then if not e then r.close()return nil,\"Missing required library for compression type (luz)\"end;r.read(4)local t=r.readAll()r.close()return f.decompress(t)elseif s and s<32 then r.close()return nil,\"Unknown compression type\"end end;return nil end;function h:writefile(i,j,u)if#u<512 and not u:match\"^Cfs[\\0-\\31]\"then local r=assert(self.fs:open(i,j,\"wb\"))r.write(u)r.close()return end;local n,t;if self.types.luz and e and(function()local v;v,t=pcall(f.compress,u,self.level,false)return v end)()then n=2 elseif self.types.deflateans and c then t,n=d.deflate(u,self.level),1 elseif self.types.deflate and a then t,n=b:CompressDeflate(u,{level=self.level}),0 else error(\"No selected compression algorithms available\")end;local r=assert(self.fs:open(i,j,\"wb\"))r.write(\"Cfs\")r.write(n)r.write((\"<I\"):pack(#u))r.write(t)r.close()end;local w=setmetatable({},{__mode=\"k\"})local function x(i,y,z,A,B)local C=w[z]if not C then error(\"Invalid file handle\")end;if B then C.buf=A else C.buf=C.buf..A end;C.self:writefile(i,C.path,C.buf)end;function h:open(i,j,D)if D:sub(1,1)==\"r\"then local r,E=self.fs:open(i,j,\"rb\")if not r then return r,E end;local u,E=self:readfile(r)if u then return filesystem.readhandle(i,u,D:find\"b\")elseif E then return nil,E end;r.seek(\"set\",0)return r elseif D:sub(1,1)==\"w\"then local do_syscall=do_syscall;local C;C=filesystem.writehandle(i,function(A,B)do_syscall(\"callmodule\",\"compressfs\",\"_writefile\",C,A,B)end,D==\"wb\")w[C]={self=self,path=j,buf=\"\"}return C elseif D:sub(1,1)==\"a\"then local r,E=self.fs:open(i,j,\"rb\")if not r then return r,E end;local u,E=self:readfile(r)if u then return filesystem.readhandle(i,u,D:find\"b\")elseif E then return nil,E else r.seek(\"set\",0)u=r.readAll()r.close()end;local do_syscall=do_syscall;local C;C=filesystem.writehandle(i,function(A,B)do_syscall(\"callmodule\",\"compressfs\",\"_writefile\",C,A,B)end,D==\"ab\")w[C]={self=self,path=j,buf=u}return C else return nil,\"Unknown mode\"end end;function h:list(i,j)return self.fs:list(i,j)end;function h:stat(i,j,F)local G=self.fs:stat(i,j,F)if G and G.type==\"file\"then local r=self.fs:open(i,j,\"rb\")if r then if r.read(3)==\"Cfs\"then r.read()G.size=(\"<I\"):unpack(r.read(4))end;r.close()end end;return G end;function h:remove(i,j)return self.fs:remove(i,j)end;function h:rename(i,j,H)return self.fs:rename(i,j,H)end;function h:mkdir(i,j)return self.fs:mkdir(i,j)end;function h:link(i,j,I)return self.fs:link(i,j,I)end;function h:mkfifo(i,j)return self.fs:mkfifo(i,j)end;function h:chmod(i,j,J,D)return self.fs:chmod(i,j,J,D)end;function h:chown(i,j,K)return self.fs:chown(i,j,K)end;function h:info()local L,j,M=self.fs:info()local m={}for p in pairs(self.types)do m[#m+1]=p end;M.compressfs_type=table.concat(m,\",\")return L..\":compressfs\",j,M end;function h:unmount(i)if self.fs.unmount then self.fs:unmount(i)end end;filesystems.compressfs=h;syslog.log({module=\"compressfs\"},\"compressfs is now loaded\")return{unload=function()filesystems.compressfs=nil end,_writefile=x}\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291642,size=4443}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294687,size=0},fuse={type="directory",created=1740881292320,worldPermissions={write=false,read=true,execute=true},contents={["githubfs.lua"]={type="file",created=1740881292320,worldPermissions={execute=false,read=true,write=false},data="local a,b=...local c=require\"system.network\"local d=require\"system.serialization\"local e,f,g=a:match\"^https?://([^@]+)@github.com/([^/]+)/([^/]+).git$\"if not e then e,f,g=a:match\"^https?://([^@]+)@github.com/([^/]+)/([^/]+)/?$\"if not e then f,g=a:match\"^https?://github.com/([^/]+)/([^/]+).git$\"if not f then f,g=a:match\"^https?://github.com/([^/]+)/([^/]+)/?$\"if not f then error(\"Malformed URL\")end end end end;e=e or b.token;local h={}local i={}local function j(k)if i[k]~=nil then return i[k]or nil end;local l=\"https://api.github.com/repos/\"..f..\"/\"..g..\"/contents/\"..c.urlEncode(k)if b.branch then l=l..\"?ref=\"..b.branch end;local m,n=c.getData(l,{Accept=\"application/vnd.github.object+json\",Authorization=e and\"Bearer \"..e,[\"X-GitHub-Api-Version\"]=\"2022-11-28\"})if not m or n<200 or n>=300 then i[k]=false;return nil,n end;m=d.json.decode(m)i[k]=m or false;return m end;function h:open(o,k,p)if k==\".githubfs-flush-cache\"and(p==\"w\"or p==\"wb\")then i={}return{write=function()end,writeLine=function()end,flush=function()end,close=function()end,seek=function()end}end;if p~=\"r\"and p~=\"rb\"then return nil,\"Read-only filesystem\"end;local q,n=j(k)if not q then return nil,n end;if q.type~=\"file\"then return nil,\"Not a file\"end;return c.getData(q.download_url,{Accept=\"application/vnd.github.object+json\",Authorization=e and\"Bearer \"..e,[\"X-GitHub-Api-Version\"]=\"2022-11-28\"})end;function h:list(o,k)local q=assert(j(k))if q.type~=\"dir\"then error(\"Not a directory\",2)end;local r={}for s,t in ipairs(q.entries)do r[s]=t.name end;return r end;function h:stat(o,k)local q,n=j(k)if not q then return q,n end;local u={type=q.type,size=q.size,created=0,modified=0,owner=f,capacity=0,freeSpace=0,permissions={},worldPermissions={read=true,write=false,execute=true},setuser=false}if q.type==\"dir\"then u.type=\"directory\"end;return u end;function h:remove(o,k)error(\"Read-only filesystem\",2)end;function h:rename(o,k,v)error(\"Read-only filesystem\",2)end;function h:mkdir(o,k)error(\"Read-only filesystem\",2)end;function h:unmount(o)end;function h:init(o)end;return h\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292311,size=2056},["ftp.lua"]={type="file",created=1740881292188,worldPermissions={execute=false,read=true,write=false},data="local a,b=...local c=require\"ftp\"local d,e,f,g=a:match\"ftp://([^:]+):([^@]+)@([^:]+):(%d+)\"if not d then d,e,f=a:match\"ftp://([^:]+):([^@]+)@([^:/]+)\"if not d then d,f,g=a:match\"ftp://([^:]+)@([^:]+):(%d+)\"if not d then d,f=a:match\"ftp://([^:]+)@([^:/]+)\"if not d then f,g=a:match\"ftp://([^:]+):(%d+)\"if not f then f=a:match\"ftp://([^:/]+)\"if not f then error(\"Malformed URL\")end end end end end end;local h=c.client(f,g,b.pasv,tonumber(b.timeout))if d then h:login(d,e)end;local i={}function i:open(j,k,l)return h:open(\"/\"..k,l)end;function i:list(j,k)return h:list(\"/\"..k)end;function i:stat(j,k)return h:stat(\"/\"..k)end;function i:remove(j,k)return h:remove(\"/\"..k)end;function i:rename(j,k,m)return h:rename(\"/\"..k,\"/\"..m)end;function i:mkdir(j,k)return h:mkdir(\"/\"..k)end;function i:unmount(j)return h:close()end;function i:init(j)h.connection:transfer()end;return i\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292167,size=872}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881292320,size=0},luz={type="directory",created=1740881292860,worldPermissions={write=false,read=true,execute=true},contents={["compress.lua"]={type="file",created=1740881292856,worldPermissions={execute=false,read=true,write=false},data="local a=require\"LibDeflate\"local b=require\"maketree\"local c=require\"lz77\"local d=require\"token_encode_map\"local e=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_\"local f={}for g,h in e:gmatch\"()(.)\"do f[h]=g-1 end;local function i(j)if j%1>=0.5 then return math.ceil(j)else return math.floor(j)end end;local function k(g)if g==0 or g==1 then return{code=g,extra=0,bits=0}end;local l=math.max(select(2,math.frexp(g))-2,0)local m=2^l;return{code=l*2+(bit32.btest(g,m)and 3 or 2),extra=bit32.band(g,m-1),bits=l}end;local function n()return setmetatable({data=\"\",partial=0,len=0},{__call=function(self,o,p)if not o then o,p=0,8-self.len end;if p==0 then return end;assert(o<2^p)self.partial=bit32.bor(bit32.lshift(self.partial,p),o)self.len=self.len+p;while self.len>=8 do local q=bit32.extract(self.partial,self.len-8,8)self.data=self.data..string.char(q)self.len=self.len-8 end end})end;local function r(s,t)local u={}while t>127 do u[#u+1],t=t%128,math.floor(t/128)end;u[#u+1]=t%128;if s then for g=#u,1,-1 do s(u[g]+(g==1 and 0 or 128),8)end end;return#u*8 end;local function v(s,t)if t%1==0 then if s then s(t<0 and 1 or 0,2)end;return r(s,math.abs(t))else local w,x=math.frexp(t)w=i((math.abs(w)-0.5)*0x20000000000000)if w>0xFFFFFFFFFFFFF then x=x+1 end;if s then s((t<0 and 6 or 4)+(x<0 and 1 or 0),3)end;x=math.abs(x)local y={}while x>7 do y[#y+1],x=x%8,math.floor(x/8)end;y[#y+1]=x%8;if s then for g=#y,1,-1 do s(y[g]+(g==1 and 0 or 8),4)end end;return r(s,w)+#y*4+3 end end;local function z(s,A)if not A or next(A)==nil then if s then s(0,5)end;return 5 elseif A.idx then if s then s(0,4)s(1,1)end;return r(s,A.idx-1)+5 end;local B=A.lengths;local C=select(2,math.frexp(A.maxlen))if s then s(C,4)end;local o=4;local h,j=B[1],0;local t,D=1,0;for E,F in ipairs(B)do if F~=h or j==85 then if j>21 then if s then s(3,2)s(j-22,6)end;o=o+8+C elseif j>5 then if s then s(2,2)s(j-6,4)end;o=o+6+C elseif j>1 then if s then s(1,2)s(j-2,2)end;o=o+4+C else if s then s(0,2)end;o=o+2+C end;if s then s(h,C)end;h,j=F,0;t=t+1;if h>1 then D=D+1 end end;j=j+1 end;if j>21 then if s then s(3,2)s(j-22,6)end;o=o+8+C elseif j>5 then if s then s(2,2)s(j-6,4)end;o=o+6+C elseif j>1 then if s then s(1,2)s(j-2,2)end;o=o+4+C else if s then s(0,2)end;o=o+2+C end;if s then s(h,C)end;if h>1 then D=D+1 end;return o end;local function G(H,I)local A={list={}}for g,J in pairs(I)do A.list[g]={J[1],H[J[1]]or 0}end;A.map,A.lengths=b(A.list)if not A.map then if A.map==nil then return nil elseif A.map==false then return{idx=A.lengths,map={[I[A.lengths][1]]={code=0,bits=0,extra=0}}}end end;A.maxlen=0;for E,J in pairs(A.lengths)do A.maxlen=math.max(A.maxlen,J)end;return A end;local function K(L,M)local N=M and(M==0 and 0 or 2^(M+6))local O,I,P,Q={},{},\"\",{}L=c(L,N)local R={}for E,F in ipairs(L)do if F.type:find\"^repeat\"then R[F.dist.code]=(R[F.dist.code]or 0)+1 end end;local S={}for g=0,29 do S[g+1]={g,R[g]or 0}end;local T={}T.map,T.lengths=b(S)if T.map then T.maxlen=0;for E,J in ipairs(T.lengths)do T.maxlen=math.max(T.maxlen,J)end elseif T.map==false then T={idx=T.lengths}end;for g,F in ipairs(L)do if F.type==\"name\"and not d[F.text]then local U;for V,J in ipairs(I)do if J==F.text then U=V;break end end;if U then F.code=k(U)O[F.code.code]=(O[F.code.code]or 0)+1;table.insert(I,1,table.remove(I,U))else F.code=k(0)O[0]=(O[0]or 0)+1;Q[#Q+1]=F.text;table.insert(I,1,F.text)end elseif F.type==\"string\"and not d[F.text]then F.str=load(\"return \"..F.text,\"=string\",\"t\",{})()P=P..F.str end end;local W={}for g=0,29 do W[#W+1]={g,O[g]or 0}end;local X=G(O,W)local H={[\":end\"]=1}for E,F in ipairs(L)do if d[F.text]then H[F.text]=(H[F.text]or 0)+1 else H[\":\"..F.type]=(H[\":\"..F.type]or 0)+1 end end;local Y={}for g=0,29 do if not d[\":repeat\"..g]then Y[#Y+1]={\":repeat\"..g,H[\":repeat\"..g]or 0}end end;for Z in pairs(d)do Y[#Y+1]={Z,H[Z]or 0}end;table.sort(Y,function(_,a0)return _[1]<a0[1]end)local a1=G(H,Y)local a2,a3=z(nil,a1),0;for E,F in ipairs(L)do if d[F.text]then a3=a3+d[F.text].bits;a2=a2+a1.map[F.text].bits elseif F.type==\"name\"then a3=a3+d[\":name\"].bits+X.map[F.code.code].bits+F.code.bits;a2=a2+a1.map[\":name\"].bits+X.map[F.code.code].bits+F.code.bits elseif F.type==\"string\"then a3=a3+d[\":string\"].bits+r(nil,#F.str)a2=a2+a1.map[\":string\"].bits+r(nil,#F.str)elseif F.type==\"number\"then a3=a3+d[\":number\"].bits+v(nil,tonumber(F.text))a2=a2+a1.map[\":number\"].bits+v(nil,tonumber(F.text))elseif F.type:find\"^repeat\"then a3=a3+d[\":\"..F.type].bits+F.len.bits+T.map[F.dist.code].bits+F.dist.bits;a2=a2+a1.map[\":\"..F.type].bits+F.len.bits+T.map[F.dist.code].bits+F.dist.bits else error(\"Could not find encoding for token \"..F.type..\"(\"..F.text..\")!\")end end;print(a3,a2)local s=n()s.data=\"\\27LuzQ\"..a:CompressDeflate(P,{level=M})local a4=#s.data-5;local a5=\"\"for E,F in ipairs(Q)do for h in F:gmatch\".\"do a5=a5 ..string.char(f[h])end;a5=a5 ..\"\\63\"end;local a6=a:CompressDeflate(a5,{level=M})s.data=s.data..a6;local a7=#s.data-a4-5;z(s,T)z(s,X)local a8;if a2<a3 then s(1,1)z(s,a1)a8=a1.map else s(0,1)a8=d end;print(a4,a7,#s.data-a7-a4-5,#I)local a9,aa,ab,ac,ad,ae,af=0,0,0,0,0,0,0;for E,F in ipairs(L)do if d[F.text]then s(a8[F.text].code,a8[F.text].bits)a9=a9+a8[F.text].bits elseif F.type==\"name\"then s(a8[\":name\"].code,a8[\":name\"].bits)a9=a9+a8[\":name\"].bits;s(X.map[F.code.code].code,X.map[F.code.code].bits)s(F.code.extra,F.code.bits)aa=aa+X.map[F.code.code].bits+F.code.bits elseif F.type==\"string\"then s(a8[\":string\"].code,a8[\":string\"].bits)a9=a9+a8[\":string\"].bits;ab=ab+r(s,#F.str)elseif F.type==\"number\"then s(a8[\":number\"].code,a8[\":number\"].bits)a9=a9+a8[\":number\"].bits;ac=ac+v(s,tonumber(F.text))elseif F.type:find\"^repeat\"then s(a8[\":\"..F.type].code,a8[\":\"..F.type].bits)a9=a9+a8[\":\"..F.type].bits;s(F.len.extra,F.len.bits)s(T.map[F.dist.code].code,T.map[F.dist.code].bits)s(F.dist.extra,F.dist.bits)ad=ad+F.len.bits+T.map[F.dist.code].bits+F.dist.bits;af=af+1 else error(\"Could not find encoding for token \"..F.type..\"(\"..F.text..\")!\")end end;s(a8[\":end\"].code,a8[\":end\"].bits)s()a9=a9+d[\":end\"].bits;print(a9/8,aa/8,ab/8,ac/8,ad/8,ae/8,af)return s.data end;return K\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292849,size=6084},["lex.lua"]={type="file",created=1740881292858,worldPermissions={execute=false,read=true,write=false},data="local a={}function a.__tostring(self)return(self.src or\"unknown\")..\":\"..self.line..\": \"..self.text end;local function b(c,d,e)error(setmetatable({line=c,col=d,text=e},a),0)end;local f={operator=\"^([;:=%.,%[%]%(%)%{%}%+%-%*/%^%%<>~#&|][=%.]?%.?)()\",name=\"^([%a_][%w_]*)()\",number=\"^(%d+%.?%d*)()\",scinumber=\"^(%d+%.?%d*[eE][%+%-]?%d+)()\",hexnumber=\"^(0[xX]%x+%.?%x*)()\",scihexnumber=\"^(0[xX]%x+%.?%x*[pP][%+%-]?%x+)()\",linecomment=\"^(%-%-[^\\n]*)()\",blockcomment=\"^(%-%-%[(=*)%[.-%]%2%])()\",emptyblockcomment=\"^(%-%-%[(=*)%[%]%2%])()\",blockquote=\"^(%[(=*)%[.-%]%2%])()\",emptyblockquote=\"^(%[(=*)%[%]%2%])()\",dquote='^(\"[^\"]*\")()',squote=\"^('[^']*')()\",whitespace=\"^(%s+)()\",invalid=\"^([^%w%s_;:=%.,%[%]%(%)%{%}%+%-%*/%^%%<>~#&|]+)()\"}local g={\"name\",\"scihexnumber\",\"hexnumber\",\"scinumber\",\"number\",\"blockcomment\",\"emptyblockcomment\",\"linecomment\",\"blockquote\",\"emptyblockquote\",\"operator\",\"dquote\",\"squote\",\"whitespace\",\"invalid\"}local h={[\"break\"]=true,[\"do\"]=true,[\"else\"]=true,[\"elseif\"]=true,[\"end\"]=true,[\"for\"]=true,[\"function\"]=true,[\"if\"]=true,[\"in\"]=true,[\"local\"]=true,[\"repeat\"]=true,[\"return\"]=true,[\"then\"]=true,[\"until\"]=true,[\"while\"]=true}local i={[\"and\"]=true,[\"not\"]=true,[\"or\"]=true,[\"+\"]=true,[\"-\"]=true,[\"*\"]=true,[\"/\"]=true,[\"%\"]=true,[\"^\"]=true,[\"#\"]=true,[\"==\"]=true,[\"~=\"]=true,[\"<=\"]=true,[\">=\"]=true,[\"<\"]=true,[\">\"]=true,[\"=\"]=true,[\"(\"]=true,[\")\"]=true,[\"{\"]=true,[\"}\"]=true,[\"[\"]=true,[\"]\"]=true,[\"::\"]=true,[\";\"]=true,[\":\"]=true,[\",\"]=true,[\".\"]=true,[\"..\"]=true}local j={[\"&\"]=true,[\"~\"]=true,[\"|\"]=true,[\"<<\"]=true,[\">>\"]=true,[\"//\"]=true}local k={[\"true\"]=true,[\"false\"]=true,[\"nil\"]=true,[\"...\"]=true}local function l(m,e)local n=1;e=m.pending..e;m.pending=\"\"while true do local o=false;for p,q in ipairs(g)do local r,s,t=e:match(f[q],n)if r then if q==\"dquote\"or q==\"squote\"then local u=true;while not r:gsub(\"\\\\.\",\"\"):match(f[q])do local v;v,s=e:match(f[q],s-1)if not v then u=false;break end;r=r..v:sub(2)end;if not u then break end elseif q==\"operator\"and#r>1 then while not(i[r]or r==\"...\")and#r>1 do r,s=r:sub(1,-2),s-1 end end;if t then s=t end;o=true;m[#m+1]={type=q,text=r,line=m.line,col=m.col}n=s;local w=select(2,r:gsub(\"\\n\",\"\\n\"))if w==0 then m.col=m.col+#r else m.line=m.line+w;m.col=#r:match(\"[^\\n]*$\")end;break end end;if not o then m.pending=e:sub(n)break end end end;local function x(m,y,z)for A,q in ipairs(m)do if q.type==\"operator\"then if q.text==\"...\"then q.type=\"constant\"elseif not i[q.text]and(y<3 or not j[q.text])then b(q.line,q.col,\"invalid operator '\"..q.text..\"'\")end elseif q.type==\"name\"then if h[q.text]then q.type=\"keyword\"elseif i[q.text]then q.type=\"operator\"elseif k[q.text]then q.type=\"constant\"end elseif q.type==\"dquote\"or q.type==\"squote\"or q.type==\"blockquote\"or q.type==\"emptyblockquote\"then q.type=\"string\"elseif q.type==\"linecomment\"or q.type==\"blockcomment\"or q.type==\"emptyblockcomment\"then q.type=\"comment\"elseif q.type==\"hexnumber\"or q.type==\"scinumber\"or q.type==\"scihexnumber\"then q.type=\"number\"elseif q.type==\"invalid\"then b(q.line,q.col,\"invalid characters\")end end;if z then local B={}for A,q in ipairs(m)do if q.type==\"number\"and B[#B].type==\"operator\"and B[#B].text==\"-\"then local C=B[#B-1]if C.type==\"operator\"and C.text~=\"}\"and C.text~=\"]\"and C.text~=\")\"or C.type==\"keyword\"and C.text~=\"end\"then q.text=\"-\"..q.text;B[#B]=nil end end;if q.type~=\"whitespace\"and(z~=2 or q.type~=\"comment\")then B[#B+1]=q end end;return B end;m.pending,m.line,m.col=nil;return m end;local function D(E,y,z)if type(E)==\"string\"then local F=E;function E()local G=F;F=nil;return G end end;local m={pending=\"\",line=1,col=1}while true do local F=E()if not F then break end;l(m,F)end;if m.pending~=\"\"then b(m.line,m.col,\"unfinished string\")end;return x(m,y,z)end;return D\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292851,size=3737},["minify.lua"]={type="file",created=1740881292860,worldPermissions={execute=false,read=true,write=false},data="local a=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"local function b(c)local d=\"\"while c>=52 do d,c=d..a:sub(c%52+1,c%52+1),math.floor(c/52)end;return a:sub(c%52+1,c%52+1)..d:reverse()end;local function e(f,g,h,i)error(\"Not implemented yet\")return i,h end;local function j(f,g,h,k)h=h or 1;k=k or 0;local l=setmetatable({},{__index=g or{}})local m=1;local i={}while h<=#f do local n=f[h]if m==1 then if n.type==\"keyword\"then i[h]=n;if n.text==\"do\"or n.text==\"then\"then local o,d=j(f,l,h+1,k)for p=h+1,d do i[p]=o[p]end;h=d elseif n.text==\"until\"then return e(f,l,h+1,i)elseif n.text==\"function\"then local q=k;if f[h+1].type==\"name\"then h=h+1;if l[f[h].text]then i[h]={col=n.col,line=n.line,type=\"name\",text=l[f[h].text]}else i[h]=f[h]end end;h=h+1;i[h]=f[h]h=h+1;n=f[h]local r=setmetatable({},{__index=l})while n.type~=\"operator\"or n.text~=\")\"do if n.type==\"name\"then r[n.text]=b(k)k=k+1;i[h]={col=n.col,line=n.line,type=\"name\",text=r[n.text]}else i[h]=n end;h=h+1;n=f[h]end;i[h]=n;local o,d=j(f,r,h+1,k)for p=h+1,d do i[p]=o[p]end;h=d;k=q elseif n.text==\"local\"or n.text==\"for\"then m=3 elseif n.text==\"end\"then return i,h end elseif n.type==\"name\"then if l[n.text]then i[h]={col=n.col,line=n.line,type=\"name\",text=l[n.text]}else i[h]=n end elseif n.type==\"operator\"then i[h]=n;if n.text==\".\"or n.text==\":\"then m=2 end else i[h]=n end elseif m==2 then i[h]=n;if not(n.type==\"operator\"and(n.text==\".\"or n.text==\":\")or n.type==\"name\")then m=1 end elseif m==3 then if n.type==\"keyword\"and n.text==\"function\"then n=i[h+1]l[n.text]=b(k)k=k+1;i[h]={col=n.col,line=n.line,type=\"name\",text=l[n.text]}local q=k;h=h+2;i[h]=f[h]h=h+1;n=f[h]local r=setmetatable({},{__index=l})while n.type~=\"operator\"or n.text~=\")\"do if n.type==\"name\"then r[n.text]=b(k)k=k+1;i[h]={col=n.col,line=n.line,type=\"name\",text=r[n.text]}else i[h]=n end;h=h+1;n=f[h]end;i[h]=n;local o,d=j(f,r,h+1,k)for p=h+1,d do i[p]=o[p]end;h=d;k=q elseif n.type==\"name\"then l[n.text]=b(k)k=k+1;i[h]={col=n.col,line=n.line,type=\"name\",text=l[n.text]}m=4 else error(\"invalid local statement\")end elseif m==4 then if n.type==\"operator\"and n.text==\",\"then m=3;i[h]=n else m=1;h=h-1 end end;h=h+1 end;return i,#f end;return j\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292853,size=2183},["lz77.lua"]={type="file",created=1740881292859,worldPermissions={execute=false,read=true,write=false},data="local function a(b)if b==0 or b==1 then return{code=b,extra=0,bits=0}end;local c=math.max(select(2,math.frexp(b))-2,0)local d=2^c;return{code=c*2+(bit32.btest(b,d)and 3 or 2),extra=bit32.band(b,d-1),bits=c}end;local function e(f,g)g=math.min(g or 1024,32768)local h={}local i={}local b=1;while b<=#f do local j=f[b]if not j.names and i[j.type]and i[j.type][j.text]then local k=i[j.type][j.text]local l,m=0;for n=#k,1,-1 do local o=k[n]if b-o>g then break end;for p=1,math.min(#f-b,129)do local q=(p-1)%(b-o)+1;if f[b+p].type==f[o+q].type and f[b+p].text==f[o+q].text then if p>l then l,m=p,o end;if f[o+q].names then break end else break end end end;if l>=2 then local r=a(l-2)local s=a(b-m-1)h[#h+1]={type=\"repeat\"..r.code,text=\"\",dist=s,len=r}for p=0,l do j=f[b+p]i[j.type][j.text][#i[j.type][j.text]+1]=b+p end;if f[b+l].names then h[#h].names=f[b+l].names end;b=b+l+1;j=nil end end;if j then h[#h+1]=j;i[j.type]=i[j.type]or{}i[j.type][j.text]=i[j.type][j.text]or{}i[j.type][j.text][#i[j.type][j.text]+1]=b;b=b+1 end end;return h end;return e\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292851,size=1046},["maketree.lua"]={type="file",created=1740881292859,worldPermissions={execute=false,read=true,write=false},data="local function a(b,c)return b.weight>c.weight end;local function d(b,c)if b.bits==c.bits then return b.symbol<c.symbol else return b.bits<c.bits end end;local function e(f,g,h,i)if f.data then i.symbol=f.data;h[f.data]=i;g[#g+1]=i else e(f[1],g,h,{bits=i.bits+1,code=i.code*2})e(f[2],g,h,{bits=i.bits+1,code=i.code*2+1})end end;local function j(k)local l={}for m,n in ipairs(k)do if n[2]>0 then l[#l+1]={data=n[1],weight=n[2]}end end;if#l==0 then return nil elseif#l==1 then for m,n in ipairs(k)do if n[1]==l[1].data then return false,m end end;return nil end;table.sort(l,a)while#l>1 do local b,c=l[#l-1],l[#l]local o={weight=b.weight+c.weight,b,c}l[#l]=nil;l[#l]=o;table.sort(l,a)end;local g,h={},{}e(l[1],g,h,{bits=0,code=0})table.sort(g,d)g[1].code=0;for m=2,#g do g[m].code=bit32.lshift(g[m-1].code+1,g[m].bits-g[m-1].bits)end;local p={}for m,n in ipairs(k)do p[m]=h[n[1]]and h[n[1]].bits or 0 end;local q={}for r,n in ipairs(g)do if n.bits==1 then q[n.code+1]=n.symbol else local f=q;for o=n.bits-1,1,-1 do local s=bit32.extract(n.code,o)+1;f[s]=f[s]or{}f=f[s]end;local s=bit32.extract(n.code,0)+1;f[s]=n.symbol end;n.symbol=nil end;return h,p,q end;return j\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292852,size=1165},["token_encode_map.lua"]={type="file",created=1740881292860,worldPermissions={execute=false,read=true,write=false},data="return{string={code=494,bits=9},[\"-\"]={code=101,bits=7},table={code=1006,bits=10},[\"*\"]={code=229,bits=8},print={code=1004,bits=10},pairs={code=2031,bits=11},ipairs={code=2028,bits=11},getmetatable={code=4086,bits=12},setmetatable={code=2034,bits=11},[\";\"]={code=488,bits=9},os={code=1003,bits=10},unpack={code=2037,bits=11},select={code=4092,bits=12},tonumber={code=2035,bits=11},[\"..\"]={code=230,bits=8},_={code=2021,bits=11},pcall={code=4090,bits=12},open={code=2030,bits=11},load={code=8190,bits=13},[\"[\"]={code=107,bits=7},[\"%\"]={code=994,bits=10},[\"^\"]={code=4082,bits=12},[\"==\"]={code=106,bits=7},[\":repeat1\"]={code=18,bits=5},[\":repeat0\"]={code=5,bits=4},[\":repeat3\"]={code=46,bits=6},require={code=2033,bits=11},[\":repeat4\"]={code=47,bits=6},[\":repeat8\"]={code=234,bits=8},[\":repeat7\"]={code=233,bits=8},[\"\\\"table\\\"\"]={code=2018,bits=11},[\"{\"]={code=112,bits=7},sub={code=1005,bits=10},[\"/\"]={code=485,bits=9},[\"...\"]={code=996,bits=10},[\"and\"]={code=235,bits=8},type={code=496,bits=9},[\":repeat11\"]={code=997,bits=10},find={code=2027,bits=11},match={code=2029,bits=11},[\"or\"]={code=239,bits=8},gsub={code=4087,bits=12},[\"end\"]={code=21,bits=5},_G={code=2022,bits=11},math={code=1002,bits=10},[\".\"]={code=16,bits=5},[\"function\"]={code=110,bits=7},tostring={code=2036,bits=11},[\"}\"]={code=113,bits=7},[\"0\"]={code=102,bits=7},[\"<\"]={code=489,bits=9},close={code=2025,bits=11},[\"\\\"nil\\\"\"]={code=4079,bits=12},read={code=2032,bits=11},[\":name\"]={code=0,bits=2},[\"=\"]={code=6,bits=4},[\",\"]={code=4,bits=4},[\">=\"]={code=999,bits=10},[\":repeat2\"]={code=19,bits=5},[\"<=\"]={code=998,bits=10},[\"#\"]={code=228,bits=8},write={code=2038,bits=11},[\"~=\"]={code=241,bits=8},error={code=1000,bits=10},__index={code=4084,bits=12},[\":repeat13\"]={code=2020,bits=11},coroutine={code=2026,bits=11},[\">\"]={code=490,bits=9},_ENV={code=4083,bits=12},[\"\\\"\\\"\"]={code=484,bits=9},[\":repeat9\"]={code=487,bits=9},[\"\\\"r\\\"\"]={code=4080,bits=12},[\"\\\"w\\\"\"]={code=4081,bits=12},__call={code=16383,bits=14},[\"1\"]={code=103,bits=7},debug={code=4085,bits=12},[\"\\\"number\\\"\"]={code=2016,bits=11},[\"\\\"boolean\\\"\"]={code=8188,bits=13},[\"2\"]={code=231,bits=8},[\"\\\"function\\\"\"]={code=4078,bits=12},[\":string\"]={code=20,bits=5},[\"-1\"]={code=995,bits=10},self={code=240,bits=8},[\":number\"]={code=17,bits=5},[\":repeat5\"]={code=104,bits=7},[\":end\"]={code=16382,bits=14},[\":repeat12\"]={code=2019,bits=11},[\"break\"]={code=2024,bits=11},[\"do\"]={code=109,bits=7},[\"else\"]={code=236,bits=8},[\"elseif\"]={code=491,bits=9},[\":repeat10\"]={code=486,bits=9},[\"false\"]={code=492,bits=9},[\"for\"]={code=237,bits=8},bit32={code=2023,bits=11},[\"\\\"string\\\"\"]={code=2017,bits=11},[\"if\"]={code=48,bits=6},[\"in\"]={code=1001,bits=10},[\"local\"]={code=22,bits=5},[\"nil\"]={code=238,bits=8},[\"not\"]={code=493,bits=9},[\")\"]={code=15,bits=5},[\"repeat\"]={code=4091,bits=12},[\"return\"]={code=111,bits=7},[\"then\"]={code=49,bits=6},[\"true\"]={code=495,bits=9},[\"until\"]={code=4093,bits=12},[\"while\"]={code=1007,bits=10},[\"(\"]={code=14,bits=5},[\":repeat6\"]={code=105,bits=7},[\":\"]={code=232,bits=8},[\"]\"]={code=108,bits=7},package={code=4089,bits=12},io={code=4088,bits=12},__newindex={code=8189,bits=13},[\"+\"]={code=100,bits=7}}\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292853,size=3157},["decompress.lua"]={type="file",created=1740881292857,worldPermissions={execute=false,read=true,write=false},data="local a={{\":name\",{{\",\",\":repeat0\"},{\"=\",{\"(\",\")\"}}}},{{{{\".\",\":number\"},{\":repeat1\",\":repeat2\"}},{{\":string\",\"end\"},{\"local\",{\":repeat3\",\":repeat4\"}}}},{{{{\"if\",\"then\"},{{\"+\",\"-\"},{\"0\",\"1\"}}},{{{\":repeat5\",\":repeat6\"},{\"==\",\"[\"}},{{\"]\",\"do\"},{\"function\",\"return\"}}}},{{{{\"{\",\"}\"},{{\"#\",\"*\"},{\"..\",\"2\"}}},{{{\":\",\":repeat7\"},{\":repeat8\",\"and\"}},{{\"else\",\"for\"},{\"nil\",\"or\"}}}},{{{{\"self\",\"~=\"},{{\"\\\"\\\"\",\"/\"},{\":repeat10\",\":repeat9\"}}},{{{\";\",\"<\"},{\">\",\"elseif\"}},{{\"false\",\"not\"},{\"string\",\"true\"}}}},{{{{\"type\",{\"%\",\"-1\"}},{{\"...\",\":repeat11\"},{\"<=\",\">=\"}}},{{{\"error\",\"in\"},{\"math\",\"os\"}},{{\"print\",\"sub\"},{\"table\",\"while\"}}}},{{{{{\"\\\"number\\\"\",\"\\\"string\\\"\"},{\"\\\"table\\\"\",\":repeat12\"}},{{\":repeat13\",\"_\"},{\"_G\",\"bit32\"}}},{{{\"break\",\"close\"},{\"coroutine\",\"find\"}},{{\"ipairs\",\"match\"},{\"open\",\"pairs\"}}}},{{{{\"read\",\"require\"},{\"setmetatable\",\"tonumber\"}},{{\"tostring\",\"unpack\"},{\"write\",{\"\\\"function\\\"\",\"\\\"nil\\\"\"}}}},{{{{\"\\\"r\\\"\",\"\\\"w\\\"\"},{\"^\",\"_ENV\"}},{{\"__index\",\"debug\"},{\"getmetatable\",\"gsub\"}}},{{{\"io\",\"package\"},{\"pcall\",\"repeat\"}},{{\"select\",\"until\"},{{\"\\\"boolean\\\"\",\"__newindex\"},{\"load\",{\":end\",\"__call\"}}}}}}}}}}}}}}local b,c,d=bit32.rshift,bit32.lshift,bit32.band;local e,f=string.byte,string.char;local g,unpack=table.concat,unpack or table.unpack;local h=math.min;local i={17,18,19,1,9,8,10,7,11,6,12,5,13,4,14,3,15,2,16}local j={2,3,7}local k={144,112,24,8}local l={8,9,7,8}local m={[0]=5,261,133,389,69,325,197,453,37,293,165,421,101,357,229,485,21,277,149,405,85,341,213,469,53,309,181,437,117,373,245,501}local n=5;local o=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_\"local p={}for q=1,#o do p[string.char(q-1)]=o:sub(q,q)end;local function r(s,t)s.bits=b(s.bits,t)s.count=s.count-t end;local function u(s,t)local v,w,x,y=s.buffer,s.bits,s.count,s.position;while x<t do if y>#v then return nil end;w=w+c(e(v,y),x)y=y+1;x=x+8 end;s.bits=w;s.position=y;s.count=x;return d(w,c(1,t)-1)end;local function z(s,t)local A=u(s,t)s.bits=b(s.bits,t)s.count=s.count-t;return A end;local function B(s,t)local v,w,x,y=s.buffer,s.bits,s.count,s.position;while x<t do if y>#v then return nil end;w=c(w,8)+e(v,y)y=y+1;x=x+8 end;s.bits=w;s.position=y;s.count=x;return d(b(w,x-t),c(1,t)-1)end;local function C(s,t)local A=B(s,t)s.count=s.count-t;return A end;local function D(s,E,t)local F=E[u(s,t)]if not F then return nil end;local G=d(F,15)local A=b(F,4)s.bits=b(s.bits,G)s.count=s.count-G;return A end;local function H(I)local J=#I;local K,L,E={[0]=0},{},{}local w,M=1,0;for q=1,J do local N=I[q]if N>w then w=N end;K[N]=(K[N]or 0)+1 end;for q=1,w do M=(M+(K[q-1]or 0))*2;L[q]=M end;for q=1,J do local N=I[q]if N>0 then local F=(q-1)*16+N;local O=0;for P=1,N do O=O+c(d(1,b(L[N],P-1)),N-P)end;for P=0,2^w-1,2^N do E[P+O]=F end;L[N]=L[N]+1 end end;return E,w end;local function Q(R,s,S,T,U,V)local W=#R+1;local X;repeat X=D(s,S,T)if not X then return nil end;if X<256 then R[W]=X;W=W+1 elseif X>256 then local w,J,Y=0,3,1;if X<265 then J=J+X-257 elseif X<285 then w=b(X-261,2)J=J+c(d(X-261,3)+4,w)else J=258 end;if w>0 then J=J+z(s,w)end;local F=D(s,U,V)if F<4 then Y=Y+F else w=b(F-2,1)Y=Y+c(d(F,1)+2,w)+z(s,w)end;local y=W-Y;repeat R[W]=R[y]or 0;W=W+1;y=y+1;J=J-1 until J==0 end until X==256 end;local function Z(R,s)local _=z(s,5)if not _ then return nil end;local X,Y,G=257+_,1+z(s,5),4+z(s,4)local I={}for q=1,G do I[i[q]]=z(s,3)end;for q=G+1,19 do I[i[q]]=0 end;local a0,a1=H(I)local q=1;local a2=X+Y+1;repeat local F=D(s,a0,a1)if F<16 then I[q]=F;q=q+1 elseif F<19 then local t=j[F-15]local x=0;local a3=3+z(s,t)if F==16 then x=I[q-1]elseif F==18 then a3=a3+8 end;for a4=1,a3 do I[q]=x;q=q+1 end end until q==a2;local a5,a6={},{}for P=1,X do a5[P]=I[P]end;for P=X+1,#I do a6[#a6+1]=I[P]end;local S,T=H(a5)local U,V=H(a6)Q(R,s,S,T,U,V)end;local function a7(R,s)local I={}for q=1,4 do local N=l[q]for a4=1,k[q]do I[#I+1]=N end end;local S,T=H(I)Q(R,s,S,T,m,n)end;local function a8(R,s)r(s,d(s.count,7))local G=z(s,16)z(s,16)if not G then return nil end;local v,y=s.buffer,s.position;for q=y,y+G-1 do R[#R+1]=e(v,q,q)end;s.position=y+G end;local function a9(s)local a3=0;repeat local _=C(s,8)a3=a3*128+_%128 until _<128;return a3 end;local function aa(s)local type=C(s,2)if type>=2 then local ab=C(s,1)local ac=0;repeat local _=C(s,4)ac=c(ac,3)+d(_,7)until _<8;if ab==1 then ac=-ac end;local ad=a9(s)/0x20000000000000+0.5;return math.ldexp(ad,ac)*(type==2 and 1 or-1)else return a9(s)*(type==0 and 1 or-1)end end;local ae={2,6,22}local function af(s,ag)local w=C(s,2)if w==0 then return 1,C(s,ag)end;local ah=C(s,w*2)+ae[w]return ah,C(s,ag)end;local function ai(s,aj)local ak=C(s,4)if ak==0 then if C(s,1)==0 then return nil else return a9(s)end end;local al={}local _,am=0;for q=1,#aj do if _==0 then _,am=af(s,ak)end;if am>0 then al[#al+1]={s=aj[q],l=am}end;_=_-1 end;assert(_==0,_)table.sort(al,function(an,ao)if an.l==ao.l then return an.s<ao.s else return an.l<ao.l end end)al[1].c=0;for P=2,#al do al[P].c=bit32.lshift(al[P-1].c+1,al[P].l-al[P-1].l)end;local ap={}for P=1,#al do local am=al[P].c;local aq=ap;for ar=al[P].l-1,1,-1 do local _=bit32.extract(am,ar,1)if not aq[_+1]then aq[_+1]={}end;aq=aq[_+1]end;local _=bit32.extract(am,0,1)aq[_+1]=al[P].s end;return ap end;local function as(at)if at:sub(1,5)~=\"\\27LuzQ\"then error(\"invalid format\",2)end;local self={buffer=at,position=6,bits=0,count=0}local au,av;do local R,v={},{}local aw,ax;repeat aw,ax=z(self,1),z(self,2)if not aw or not ax then break end;ax=ax==0 and a8(R,self)or ax==1 and a7(R,self)or ax==2 and Z(R,self)until aw==1;local J=#R;for q=1,J,4096 do v[#v+1]=f(unpack(R,q,h(q+4095,J)))end;au=g(v)if self.count%8>0 then r(self,self.count%8)end end;do local R,v={},{}local aw,ax;repeat aw,ax=z(self,1),z(self,2)if not aw or not ax then break end;ax=ax==0 and a8(R,self)or ax==1 and a7(R,self)or ax==2 and Z(R,self)until aw==1;local J=#R;for q=1,J,4096 do v[#v+1]=f(unpack(R,q,h(q+4095,J)))end;av=g(v)if self.count%8>0 then r(self,self.count%8)end end;local ay={}for az in av:gmatch\"([%z\\1-\\62]+)\\63\"do ay[#ay+1]=az:gsub(\".\",p)end;local aA=ai(self,{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29})local ap=ai(self,{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29})local aB;if C(self,1)==1 then local aC,ad={},{}local function aD(aq)if type(aq)==\"string\"then aC[#aC+1],ad[aq]=aq,true else aD(aq[1])aD(aq[2])end end;aD(a)for q=0,29 do if not ad[\":repeat\"..q]then aC[#aC+1]=\":repeat\"..q end end;table.sort(aC)aB=ai(self,aC)else aB=a end;local aE,aF=1,1;local aG={}local aH={}while true do local aq=aB;while type(aq)==\"table\"do aq=aq[C(self,1)+1]end;if aq==\":end\"then break elseif aq==\":name\"then aq=ap;while type(aq)==\"table\"do aq=aq[C(self,1)+1]end;local aI,aJ=math.max(math.floor(aq/2)-1,0)if aI>0 then local aK=C(self,aI)aJ=bit32.bor(aK,bit32.lshift(bit32.band(aq,1)+2,aI))else aJ=aq end;if aJ==0 then aG[#aG+1]=ay[aF]table.insert(aH,1,ay[aF])aF=aF+1 else local aL=table.remove(aH,aJ)aG[#aG+1]=aL;table.insert(aH,1,aL)end elseif aq==\":string\"then local ag=a9(self)aG[#aG+1]=(\"%q\"):format(au:sub(aE,aE+ag-1)):gsub(\"\\\\?\\n\",\"\\\\n\"):gsub(\"\\t\",\"\\\\t\"):gsub(\"[%z\\1-\\31\\127-\\255]\",function(_)return(\"\\\\%03d\"):format(_:byte())end)aE=aE+ag elseif aq==\":number\"then aG[#aG+1]=tostring(aa(self))elseif aq:find\"^:repeat\"then local aM=tonumber(aq:match\"^:repeat(%d+)\")local aI=math.max(math.floor(aM/2)-1,0)if aI>0 then local aK=C(self,aI)aM=bit32.bor(aK,bit32.lshift(bit32.band(aM,1)+2,aI))+3 else aM=aM+3 end;aq=aA;while type(aq)==\"table\"do aq=aq[C(self,1)+1]end;local aJ;aI=math.max(math.floor(aq/2)-1,0)if aI>0 then local aK=C(self,aI)aJ=bit32.bor(aK,bit32.lshift(bit32.band(aq,1)+2,aI))+1 else aJ=aq+1 end;for a4=1,aM do aG[#aG+1]=aG[#aG-aJ+1]end else aG[#aG+1]=aq end end;local aN=\"\"local aO,aP=false,false;for a4,aQ in ipairs(aG)do if aO and aQ:match\"^[A-Za-z0-9_]\"or aP and aQ:match\"^%.\"then aN=aN..\" \"end;aN=aN..aQ;aO,aP=aQ:match\"[A-Za-z0-9_]$\",aQ:match\"%.$\"end;return aN end;return as\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292850,size=7942},["init.lua"]={type="file",created=1740881292857,worldPermissions={execute=false,read=true,write=false},data="local a={compress_codes=require\"compress\",decompress=require\"decompress\",lex=require\"lex\",lz77=require\"lz77\",minify=require\"minify\"}function a.compress(b,c,d)assert(load(b))local e=a.lex(b,1,2)if d then e=a.minify(e)end;return a.compress_codes(e,c)end;return a\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881292850,size=261}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881292860,size=0},["ar.lua"]={type="file",created=1740881291266,worldPermissions={execute=false,read=true,write=false},data="local a=require\"system.filesystem\"local function b(c)return c:match('^()[%s%z]*$')and''or c:match('^[%s%z]*(.*[^%s%z])')end;local function d(e,f,g)return#e<f and e:sub(1,f)..(g or\" \"):rep(f-#e)or e end;local function h(i)return 0x38+(i.worldPermissions.read and 4 or 0)+(i.worldPermissions.write and 2 or 0)+(i.worldPermissions.execute and 1 or 0)+(i.permissions[i.owner].read and 256 or 0)+(i.permissions[i.owner].write and 128 or 0)+(i.permissions[i.owner].execute and 64 or 0)end;local j={verbosity=0}function j.load(k)if not a.exists(k)then return nil end;local l=a.open(k,\"rb\")if l.read(8)~=\"!<arch>\\n\"then l.close()error(\"Not an ar archive\",2)end;local m={}local n=nil;local o={}while true do local p={}local q=l.read(1)while q==\"\\n\"do q=l.read(1)end;if q==nil then break end;local r=l.read(15)if r==nil then break end;r=q..r;if r:find(\"/\")and r:find(\"/\")>1 then r=r:sub(1,r:find(\"/\")-1)else r=b(r)end;p.timestamp=tonumber(b(l.read(12)))p.owner=tonumber(b(l.read(6)))p.group=tonumber(b(l.read(6)))p.mode=tonumber(b(l.read(8)),8)local s=tonumber(b(l.read(10)))if l.read(2)~=\"`\\n\"then error(\"Invalid header for file \"..r,2)end;if r:match(\"^#1/%d+$\")then r=l.read(tonumber(r:match(\"#1/(%d+)\")))elseif r:match(\"^/%d+$\")then if n then local t=tonumber(r:match(\"/(%d+)\"))r=n:sub(t+1,n:find(\"\\n\",t+1)-1)else o[#o+1]=r end end;p.name=r;p.data=l.read(s)if r==\"//\"then n=p.data elseif r~=\"/\"and r~=\"/SYM64/\"then m[#m+1]=p end end;l.close()if n then for u,v in ipairs(o)do local t=tonumber(v:match(\"/(%d+)\"))for u,w in ipairs(m)do if w.name==v then w.name=n:sub(t,n:find(\"/\",t)-1)break end end end end;return m end;function j.write(v,x)local l=a.open(x,\"wb\")l.write(v.data)l.close()if j.verbosity>0 then print(\"Extracted to \"..x)end end;function j.extract(p,k)if type(p)==\"string\"then p=j.load(p)end;if not a.exists(k)then a.mkdir(k)end;for u,v in ipairs(p)do local x=a.combine(k,v.name)j.write(v,x)end end;function j.read(x)local i=a.stat(x)if not i then return nil end;local l=assert(a.open(x,\"rb\"))local m={name=a.basename(x),timestamp=math.floor(i.modified/1000),owner=(i.owner==\"root\"or i.owner==nil)and 0 or 501,group=0,mode=h(i),data=l.readAll()}l.close()return m end;function j.pack(k)local m={}for u,v in ipairs(a.list(k))do local x=a.combine(k,v)if not a.isDir(x)then m[v]=j.read(x)end end;return m end;function j.save(p,k)local l=a.open(k,\"wb\")l.write(\"!<arch>\\n\")local n={}local y=nil;for u,v in ipairs(p)do if#v.name>15 then n[v.name]=#(y or\"\")y=(y or\"\")..v.name..\"/\\n\"end end;if y then l.write(\"//              0           0     0     666     \"..d(tostring(#y),10)..\"`\\n\"..y)if l.seek()%2==1 then l.write(\"\\n\")end end;for u,v in ipairs(p)do local r=n[v.name]and\"/\"..n[v.name]or v.name..(y and\"/\"or\"\")l.write(d(r,16)..d(tostring(v.timestamp),12)..d(tostring(v.owner),6)..d(tostring(v.group),6))l.write(d((\"%o\"):format(v.mode),8)..d(tostring(#v.data),10)..\"`\\n\"..v.data)if l.seek()%2==1 then l.write(\"\\n\")end end;l.close()end;return j\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291263,size=2942},["diff.lua"]={type="file",created=1740881291785,worldPermissions={execute=false,read=true,write=false},data="local a={}SKIP_SEPARATOR=true;IN=\"in\"OUT=\"out\"SAME=\"same\"local function b(c,d,e)d=d or\"%s+\"local f={}local g=1;local h,i=c:find(d,g)while h do table.insert(f,c:sub(g,h-1))if not e then table.insert(f,c:sub(h,i))end;g=i+1;h,i=c:find(d,g)end;if c:sub(g)~=\"\"then table.insert(f,c:sub(g))end;return f end;function a.quick_LCS(j,k)local l=#j;local m=#k;local n={}local setmetatable=setmetatable;local o={__index=function(p,q)p[q]=0;return 0 end}local r={__index=function(p,q)local s={}setmetatable(s,o)p[q]=s;return s end}setmetatable(n,r)local t=math.max;for u=1,l+1 do local v=n[u+1]local w=n[u]for x=1,m+1 do if j[u-1]==k[x-1]then v[x+1]=w[x]+1 else v[x+1]=t(v[x],w[x+1])end end end;return n end;local function y(c)c=c:gsub(\"&\",\"&amp;\"):gsub(\">\",\"&gt;\"):gsub(\"<\",\"&lt;\")c=c:gsub(\"\\\"\",\"&quot;\")return c end;function a.format_as_html(z)local A=\"\"local B,C;for u,D in ipairs(z)do B=y(D[1])C=D[2]if C==\"in\"then A=A..\"<ins>\"..B..\"</ins>\"elseif C==\"out\"then A=A..\"<del>\"..B..\"</del>\"else A=A..B end end;return A end;function a.diff(E,F,d)assert(E)assert(F)F=b(F,d)E=b(E,d)local G=\"\"local H=\"\"while E[1]and E[1]==F[1]do local B=table.remove(E,1)table.remove(F,1)G=G..B end;while E[#E]and E[#E]==F[#F]do local B=table.remove(E)table.remove(F)H=B..H end;local I={put=function(self,B,J)table.insert(self,{B,J})end,ins=function(self,B)self:put(B,IN)end,del=function(self,B)self:put(B,OUT)end,same=function(self,B)if B then self:put(B,SAME)end end}I:same(H)local function K(n,E,F,u,x)local L=E[u]local M=F[x]if u>=1 and x>=1 and L==M then I:same(L)return K(n,E,F,u-1,x-1)else local N=n[u][x-1]local O=n[u-1][x]if x>=1 and(u==0 or N>=O)then I:ins(M)return K(n,E,F,u,x-1)elseif u>=1 and(x==0 or N<O)then I:del(L)return K(n,E,F,u-1,x)end end end;K(a.quick_LCS(E,F),E,F,#E+1,#F+1)I:same(G)local a={}for u=#I,1,-1 do table.insert(a,I[u])end;a.to_html=a.format_as_html;return a end;return a\n",setuser=false,permissions={root={execute=false,read=true,write=true}},owner="root",modified=1740881291783,size=1871}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294723,size=0}},permissions={root={write=true,read=true,execute=true}},owner="root",modified=1740881294724,size=0}