{permissions={root={write=true,read=true,execute=true}},created=1757997043457,contents={boot={permissions={root={write=true,read=true,execute=true}},created=1757997043456,contents={["pxboot.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997042345,data="if not(fs or term or os.pullEvent)then error(\"This program must be run from CraftOS.\")end;local a=require\"cc.expect\"if not getmetatable(a)then setmetatable(a,{__call=function(self,...)return self.expect(...)end})elseif not getmetatable(a).__call then getmetatable(a).__call=function(self,...)return self.expect(...)end end;local b={}local c={}local d={}local e={}local f={}local g;local function h(i,...)local j=_G.dofile;local k=table.pack(...)local l={bit32=true,bit=true,ccemux=true,config=true,coroutine=true,debug=true,ffi=true,fs=true,http=true,io=true,jit=true,mounter=true,os=true,periphemu=true,peripheral=true,redstone=true,rs=true,term=true,utf8=true,_HOST=true,_CC_DEFAULT_SETTINGS=true,_CC_DISABLE_LUA51_FEATURES=true,_VERSION=true,assert=true,collectgarbage=true,error=true,gcinfo=true,getfenv=true,getmetatable=true,ipairs=true,load=true,loadstring=true,math=true,newproxy=true,next=true,pairs=true,pcall=true,rawequal=true,rawget=true,rawlen=true,rawset=true,select=true,setfenv=true,setmetatable=true,string=true,table=true,tonumber=true,tostring=true,type=true,unpack=true,xpcall=true,turtle=true,pocket=true,commands=true,_G=true,sound=true}local m={}for n in pairs(_G)do if not l[n]and not f[n]then table.insert(m,n)end end;for o,n in ipairs(m)do _G[n]=nil end;local p=g or _G.term.native()for o,q in ipairs{\"nativePaletteColor\",\"nativePaletteColour\",\"screenshot\"}do p[q]=_G.term[q]end;_G.term=p;_G.http.checkURL=_G.http.checkURLAsync;_G.http.websocket=_G.http.websocketAsync;if _G.commands then _G.commands=_G.commands.native end;if _G.turtle then _G.turtle.native,_G.turtle.craft=nil end;local r={os={\"version\",\"pullEventRaw\",\"pullEvent\",\"run\",\"loadAPI\",\"unloadAPI\",\"sleep\"},http={\"get\",\"post\",\"put\",\"delete\",\"patch\",\"options\",\"head\",\"trace\",\"listen\",\"checkURLAsync\",\"websocketAsync\"},fs={\"complete\",\"isDriveRoot\"}}for n,s in pairs(r)do for o,t in ipairs(s)do _G[n][t]=nil end end;local u=error;_G.error=function()end;_G.term.redirect=function()end;function _G.term.native()_G.term.native=nil;_G.term.redirect=nil;_G.error=u;term.setBackgroundColor(32768)term.setTextColor(1)term.setCursorPos(1,1)term.setCursorBlink(true)term.clear()local v;if type(i)==\"function\"then v=i else local w=fs.open(i,\"r\")if w==nil then term.setCursorBlink(false)term.setTextColor(16384)term.write(\"Could not find kernel. pxboot cannot continue.\")term.setCursorPos(1,2)term.write(\"Press any key to continue\")coroutine.yield(\"key\")os.shutdown()end;local x;v,x=loadstring(w.readAll(),\"=kernel\")w.close()if v==nil then term.setCursorBlink(false)term.setTextColor(16384)term.write(\"Could not load kernel. pxboot cannot continue.\")term.setCursorPos(1,2)term.write(x)term.setCursorPos(1,3)term.write(\"Press any key to continue\")coroutine.yield(\"key\")os.shutdown()end end;setfenv(v,_G)local y=os.shutdown;os.shutdown=function()os.shutdown=y;return v(table.unpack(k,1,k.n))end end;if debug then local function z(A,B,C,D)local E,F,G=1,debug.getupvalue(A[B],D)while F~=C and not(F==nil and E>1)do F,G=debug.getupvalue(A[B],E)E=E+1 end;A[B]=G or A[B]end;z(_G,\"loadstring\",\"nativeloadstring\",1)z(_G,\"load\",\"nativeload\",5)z(http,\"request\",\"nativeHTTPRequest\",3)z(os,\"shutdown\",\"nativeShutdown\",1)z(os,\"reboot\",\"nativeReboot\",1)if turtle then z(turtle,\"equipLeft\",\"v\",1)z(turtle,\"equipRight\",\"v\",1)end;do local E,F,G=1,debug.getupvalue(peripheral.isPresent,2)while F~=\"native\"and F~=nil do F,G=debug.getupvalue(peripheral.isPresent,E)E=E+1 end;_G.peripheral=G or peripheral end;if debug.getupvalue(j,2)==\"status\"then local o,H=debug.getupvalue(j,2)o,_G.discord=debug.getupvalue(H,4)end end;coroutine.yield()end;function e.kernel(m)d.fn=h;d.args={m.path}end;function e.chainloader(m)d.fn=shell and shell.run or function(i,...)os.run({},i,...)end;d.args={m.path}end;function e.craftos(m)d.fn=function()term.setTextColor(colors.yellow)print(os.version())term.setTextColor(colors.white)if settings.get(\"motd.enable\")then if shell then shell.run(\"motd\")else os.run({},\"/rom/programs/motd.lua\")end end end;d.args={}end;function e.args(m)if not d.args then error(\"config.lua:\"..m.line..\": args command must come after boot type\",0)end;for E=1,#m.args do d.args[#d.args+1]=m.args[E]end end;function e.global(m)_G[m.key]=m.value;f[m.key]=true end;function e.monitor(m)if peripheral.hasType then assert(peripheral.hasType(m.name,\"monitor\"),\"peripheral '\"..m.name..\"' does not exist or is not a monitor\")else assert(peripheral.getType(m.name)==\"monitor\",\"peripheral '\"..m.name..\"' does not exist or is not a monitor\")end;g=peripheral.wrap(m.name)term.redirect(g)end;function e.insmod(m)local i;if m.name:match\"^/\"then i=m.name elseif m.name:find\"[/%.]\"then i=fs.combine(shell and fs.getDir(shell.getRunningProgram())or\"pxboot\",m.name)else i=fs.combine(shell and fs.getDir(shell.getRunningProgram())or\"pxboot\",\"modules/\"..m.name..\".lua\")end;assert(loadfile(i,nil,setmetatable({entries=b,bootcfg=d,cmds=e,userGlobals=f,unbios=h},{__index=_ENV})))(m.args,i)end;local function I(J)term.setBackgroundColor(colors.black)term.setTextColor(colors.white)term.clear()term.setCursorPos(1,1)for E=0,15 do term.setPaletteColor(2^E,term.nativePaletteColor(2^E))end;for o,s in ipairs(J.commands)do local K,x;if type(s)==\"function\"then K,x=pcall(s)else K,x=pcall(e[s.cmd],s)end;if not K then d={}printError(\"Could not run boot script: \"..x)print(\"Press any key to continue.\")os.pullEventRaw(\"key\")return false end end;if not d.fn then d={}printError(\"Could not run boot script: missing boot type command\")print(\"Press any key to continue.\")os.pullEventRaw(\"key\")return false end;d.fn(table.unpack(d.args))return true end;local L;local M=setmetatable({title=\"Phoenix pxboot\",titlecolor=colors.white,backgroundcolor=colors.black,textcolor=colors.white,boxcolor=colors.white,boxbackground=colors.black,selectcolor=colors.white,selecttext=colors.black,background=nil,defaultentry=nil,timeout=30,menuentry=function(C)a(1,C,\"string\")return function(J)a(2,J,\"table\")local N=1;for E,s in pairs(J)do if type(E)==\"number\"then N=math.max(E,N)end end;local O={name=C,commands={}}for E=1,N do local P=J[E]if type(P)~=\"table\"and type(P)~=\"function\"or not P.cmd then error(\"bad command entry #\"..E..(P==nil and\" (unknown command)\"or\" (missing arguments)\"),2)end;if type(P)==\"function\"then O.commands[#O.commands+1]=P elseif P.cmd==\"description\"then O.description=P.text elseif e[P.cmd]then O.commands[#O.commands+1]=P else error(\"bad command entry #\"..E..\" (unknown command \"..P.cmd..\")\",2)end end;b[#b+1]=O;c[C]=O end end,include=function(i)a(1,i,\"string\")for o,s in ipairs(fs.find(fs.combine(L,i)))do repeat local v,x=loadfile(s,\"t\",getfenv(2))if not v then printError(\"Could not load config file: \"..x)print(\"Press any key to continue...\")os.pullEvent(\"key\")break end;local Q=L;L=fs.getDir(s)local K,x=pcall(v)L=Q;if not K then printError(\"Failed to execute config file: \"..x)print(\"Press any key to continue...\")os.pullEvent(\"key\")break end until true end end,description=function(R)a(1,R,\"string\")return{cmd=\"description\",text=R,line=debug.getinfo(2,\"l\").currentline}end,kernel=function(i)a(1,i,\"string\")return{cmd=\"kernel\",path=i,line=debug.getinfo(2,\"l\").currentline}end,chainloader=function(i)a(1,i,\"string\")return{cmd=\"chainloader\",path=i,line=debug.getinfo(2,\"l\").currentline}end,args=function(S)a(1,S,\"string\",\"table\")if type(S)==\"table\"then return{cmd=\"args\",args=S,line=debug.getinfo(2,\"l\").currentline}else local m={\"\"}local T;for P in S:gmatch\".\"do if T then if P==T then T=nil else m[#m]=m[#m]..P end elseif P=='\"'or P==\"'\"then T=P elseif P==' 'then m[#m+1]=\"\"else m[#m]=m[#m]..P end end;local N=2;return setmetatable({cmd=\"args\",args=m,line=debug.getinfo(2,\"l\").currentline},{__call=function(self,U)a(N,U,\"string\")N=N+1;local m=self.args;local T;m[#m+1]=\"\"for P in U:gmatch\".\"do if T then if P==T then T=nil else m[#m]=m[#m]..P end elseif P=='\"'or P==\"'\"then T=P elseif P==' 'then m[#m+1]=\"\"else m[#m]=m[#m]..P end end;return self end})end end,craftos={cmd=\"craftos\"},global=function(F)return function(G)return{cmd=\"global\",key=F,value=G}end end,monitor=function(C)return{cmd=\"monitor\",name=C}end,insmod=function(C)a(1,C,\"string\")return setmetatable({cmd=\"insmod\",name=C,line=debug.getinfo(2,\"l\").currentline},{__call=function(self,S)a(2,S,\"table\")self.args=S;setmetatable(self,nil)return self end})end},{__index=_ENV})term.clear()term.setCursorPos(1,1)repeat local v,x=loadfile(shell and fs.combine(fs.getDir(shell.getRunningProgram()),\"config.lua\")or\"pxboot/config.lua\",\"t\",M)if not v then printError(\"Could not load config file: \"..x)print(\"Press any key to continue...\")os.pullEvent(\"key\")break end;L=shell and fs.getDir(shell.getRunningProgram())or\"pxboot\"local K,x=pcall(v)L=nil;if not K then printError(\"Failed to execute config file: \"..x)print(\"Press any key to continue...\")os.pullEvent(\"key\")break end until true;local function V()end;if#b==0 then return V()end;local function W(N)return(\"0123456789abcdef\"):sub(N,N)end;local X,Y=term.getSize()local Z=Y-11;local _=window.create(term.current(),2,4,X-2,Y-9)local a0=window.create(_,2,2,X-4,Z)term.setBackgroundColor(M.backgroundcolor)term.clear()_.setBackgroundColor(M.boxbackground or M.backgroundcolor)_.clear()a0.setBackgroundColor(M.boxbackground or M.backgroundcolor)a0.clear()local a1,a2=1,1;if M.defaultentry then for E=1,#b do if b[E].name==M.defaultentry then a1=E;break end end;if M.timeout==0 and I(b[a1])then return end end;local function a3()a0.setVisible(false)a0.setBackgroundColor(M.boxbackground or M.backgroundcolor)a0.clear()for E=a2,a2+Z-1 do local a4=b[E]if not a4 then break end;a0.setCursorPos(2,E-a2+1)if E==a1 then a0.setBackgroundColor(M.selectcolor)a0.setTextColor(M.selecttext)else a0.setBackgroundColor(M.boxbackground or M.backgroundcolor)a0.setTextColor(M.textcolor)end;a0.clearLine()a0.write(#a4.name>X-6 and a4.name:sub(1,X-9)..\"...\"or a4.name)if E==a1 and M.timeout then local a5=tostring(M.timeout)a0.setCursorPos(X-4-#a5,E-a2+1)a0.write(a5)a0.setCursorPos(2,E-a2+1)end end;a0.setVisible(true)term.setCursorPos(5,Y-5)term.clearLine()term.setTextColor(M.titlecolor)term.write(b[a1].description or\"\")end;local function a6()local a7,a8=W(select(2,math.frexp(M.boxbackground or M.backgroundcolor))),W(select(2,math.frexp(M.boxcolor or M.textcolor)))_.setTextColor(M.boxcolor or M.textcolor)_.setCursorPos(1,1)_.write(\"\\x9C\"..(\"\\x8C\"):rep(X-4))_.blit(\"\\x93\",a7,a8)for a9=2,Y-10 do _.setCursorPos(1,a9)_.blit(\"\\x95\",a8,a7)_.setCursorPos(X-2,a9)_.blit(\"\\x95\",a7,a8)end;_.setCursorPos(1,Y-9)_.setBackgroundColor(M.boxbackground or M.backgroundcolor)_.setTextColor(M.boxcolor or M.textcolor)_.write(\"\\x8D\"..(\"\\x8C\"):rep(X-4)..\"\\x8E\")term.setCursorPos((X-#M.title)/2,2)term.setTextColor(M.titlecolor or M.textcolor)term.write(M.title)term.setCursorPos(5,Y-3)term.write(\"Use the \\x18 and \\x19 keys to select.\")term.setCursorPos(5,Y-2)term.write(\"Press enter to boot the selected OS.\")term.setCursorPos(5,Y-1)term.write(\"'c' for shell, 'e' to edit.\")a3()end;a6()local aa=M.defaultentry and M.timeout and os.startTimer(1)while true do local ab={coroutine.yield()}if ab[1]==\"timer\"and ab[2]==aa then M.timeout=M.timeout-1;if M.timeout==0 then if I(c[M.defaultentry])then return end end;a3()aa=os.startTimer(1)elseif ab[1]==\"key\"then if aa then os.cancelTimer(aa)M.timeout,aa=nil;a3()end;if(ab[2]==keys.down or ab[2]==keys.numPad2)and a1<#b then a1=a1+1;if a1>a2+Z-1 then a2=a2+1 end;a3()elseif(ab[2]==keys.up or ab[2]==keys.numPad8)and a1>1 then a1=a1-1;if a1<a2 then a2=a2-1 end;a3()elseif ab[2]==keys.enter then if I(b[a1])then return end elseif ab[2]==keys.c then V()a6()end elseif ab[1]==\"terminate\"then break end end\n",setuser=false,size=11564,modified=1757997042343,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["config.lua.d"]={permissions={root={write=true,read=true,execute=true}},created=1757997042345,contents={["99-craftos.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997042345,data="menuentry\"CraftOS\"{description\"Boot into CraftOS.\",craftos}\n",setuser=false,size=60,modified=1757997042342,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997042345,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},["config.lua"]={permissions={root={write=true,read=true,execute=false}},created=1757997042344,data="\n",setuser=false,size=1,modified=1757997042342,worldPermissions={write=false,read=true,execute=false},type="file",owner="root"},["kernel.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039421,data="if _ENV~=_G then error(\"Phoenix must be run in the global environment, with a bootloader such as pxboot or UnBIOS. It cannot be run as a normal program.\")end;PHOENIX_VERSION=\"0.0.9\"PHOENIX_BUILD=\"PRERELEASE NONFREE Mon Sep 15 23:39:00 2025\"systemStartTime=os.epoch\"utc\"args={init=\"/sbin/init.lua\",root=\"/root\",rootfstype=\"craftos\",preemptive=true,quantum=20000,splitkernpath=\"/boot/kernel.lua.d\",loglevel=1,console=\"tty1\",traceback=true}syscalls={}processes={[0]={name=\"kernel\",id=0,user=\"root\",dir=\"/\",root=\"/\",env=_G,vars={},dependents={}}}KERNEL=processes[0]modules={}eventHooks={}shutdownHooks={}debugHooks=setmetatable({},{__mode=\"k\"})kSyscallYield={}kSyscallComplete={}process={}filesystem={}terminal={}syslog={}hardware={}if discord then discord(\"Phoenix\",\"Booting Phoenix \"..PHOENIX_VERSION)end;expect={}local a={[\"nil\"]=true,boolean=true,number=true,string=true,table=true,[\"function\"]=true,userdata=true,thread=true}local function b(c)return type(c)==\"table\"and(getmetatable(c)or{}).__call or type(c)==\"function\"end;local function d(e,g,...)local h=type(g)local i;if h==\"table\"then local j=getmetatable(g)if j then i=j.__name end end;local args=table.pack(...)for k,l in ipairs(args)do if a[l]then if h==l then return g end elseif i==l then return g elseif b(l)and l(g)then return g end end;local info=debug.getinfo(2,\"n\")if info and info.name and info.name~=\"\"then e=e..\" to '\"..info.name..\"'\"end;local m;if#args==1 and b(args[1])then local k,n=args[1](g)error(e..\" (\"..n..\")\",3)else for o,c in ipairs(args)do args[o]=tostring(c)end;if args.n==1 then m=args[1]elseif args.n==2 then m=args[1]..\" or \"..args[2]else m=table.concat(args,\", \",1,args.n-1)..\", or \"..args[args.n]end;error(e..\" (expected \"..m..\", got \"..h..\")\",3)end end;function expect.expect(p,g,...)return d(\"bad argument #\"..p,g,...)end;function expect.field(q,r,...)local s,t=pcall(string.format,\"%q\",r)if not s then t=tostring(r)end;return d(\"bad field \"..t,q[r],...)end;function expect.range(u,v,w)expect.expect(1,u,\"number\")expect.expect(2,v,\"number\",\"nil\")expect.expect(3,w,\"number\",\"nil\")if w and v and w<v then error(\"bad argument #3 (min must be less than or equal to max)\",2)end;if u~=u or u<(v or-math.huge)or u>(w or math.huge)then error((\"number outside of range (expected %s to be within %s and %s)\"):format(u,v or-math.huge,w or math.huge),3)end;return u end;setmetatable(expect,{__call=function(self,...)return expect.expect(...)end})local x={[\"and\"]=true,[\"break\"]=true,[\"do\"]=true,[\"else\"]=true,[\"elseif\"]=true,[\"end\"]=true,[\"false\"]=true,[\"for\"]=true,[\"function\"]=true,[\"goto\"]=true,[\"if\"]=true,[\"in\"]=true,[\"local\"]=true,[\"nil\"]=true,[\"not\"]=true,[\"or\"]=true,[\"repeat\"]=true,[\"return\"]=true,[\"then\"]=true,[\"true\"]=true,[\"until\"]=true,[\"while\"]=true}local function y(z,A,B,C)if A[z]then error(\"Cannot serialize recursive value\",0)end;local D=type(z)if D==\"table\"then if not next(z)then return\"{}\"end;A[z]=true;local E=B.minified and\"{\"or\"{\\n\"local u={}for o,c in ipairs(z)do if not B.minified then E=E..(\"    \"):rep(C)end;u[o]=true;E=E..y(c,A,B,C+1)..(B.minified and\",\"or\",\\n\")end;for F,c in pairs(z)do if not u[F]then if not B.minified then E=E..(\"    \"):rep(C)end;if type(F)==\"string\"and F:match\"^[A-Za-z_][A-Za-z0-9_]*$\"and not x[F]then E=E..F else E=E..\"[\"..y(F,A,B,C+1)..\"]\"end;E=E..(B.minified and\"=\"or\" = \")..y(c,A,B,C+1)..(B.minified and\",\"or\",\\n\")end end;if B.minified then E=E:gsub(\",$\",\"\")else E=E..(\"    \"):rep(C-1)end;A[z]=nil;return E..\"}\"elseif D==\"nil\"or D==\"number\"or D==\"boolean\"or D==\"string\"then return(\"%q\"):format(z):gsub(\"\\\\\\n\",\"\\\\n\"):gsub(\"\\\\?[%z\\1-\\31\\127-\\255]\",function(G)return(\"\\\\%03d\"):format(string.byte(G))end)else error(\"Cannot serialize type \"..D,0)end end;function serialize(z,B)expect(2,B,\"table\",\"nil\")return y(z,{},B or{},1)end;function unserialize(t)expect(1,t,\"string\")return assert(load(\"return \"..t,\"=unserialize\",\"t\",{}))()end;do local H=fs.open(\"/rom/apis/keys.lua\",\"r\")local I=setmetatable({dofile=function()return expect end},{__index=_G})if _VERSION<\"Lua 5.2\"then I._ENV=I end;local J;if loadstring and setfenv then J=loadstring(H.readAll(),\"@/rom/apis/keys.lua\")setfenv(J,I)else J=load(H.readAll(),\"@/rom/apis/keys.lua\",\"t\",I)end;H.close()J()keys={}for F,c in pairs(I)do keys[F]=c end end;local K=load;if not pcall(load,\"return\",\"=test\",\"t\",{})then local L,M,expect,setfenv=load,loadstring,expect,setfenv;function load(N,O,P,I)expect(1,N,\"string\",\"function\")expect(2,O,\"string\",\"nil\")expect(3,P,\"string\",\"nil\")expect(4,I,\"table\",\"nil\")if type(N)==\"string\"then if N:sub(1,4)==\"\\27Lua\"then if P==nil or P:find\"b\"then local J,n=M(N,O)if J and I then setfenv(J,I)end;return J,n else return nil,\"attempt to load a binary chunk (mode is '\"..(P or\"bt\")..\"')\"end else if P==nil or P:find\"t\"then local J,n=M(N,O)if J and I then setfenv(J,I)end;return J,n else return nil,\"attempt to load a text chunk (mode is '\"..(P or\"bt\")..\"')\"end end else local J,n=L(N,O)if J then setfenv(J,I)end;return J,n end end end;loadstring=nil;if bit then if not bit32 then local bit=bit;bit32={bnot=bit.bnot,lshift=bit.blshift,rshift=bit.blogic_rshift,arshift=bit.brshift}function bit32.band(Q,R,...)expect(1,Q,\"number\")expect(2,R,\"number\",\"nil\")if not R then return Q end;return bit32.band(bit.band(Q,R),...)end;function bit32.bor(Q,R,...)expect(1,Q,\"number\")expect(2,R,\"number\",\"nil\")if not R then return Q end;return bit32.bor(bit.bor(Q,R),...)end;function bit32.bxor(Q,R,...)expect(1,Q,\"number\")expect(2,R,\"number\",\"nil\")if not R then return Q end;return bit32.bxor(bit.bxor(Q,R),...)end;function bit32.btest(...)return bit32.band(...)~=0 end;function bit32.extract(S,T,U)expect(1,S,\"number\")expect(2,T,\"number\")expect(3,U,\"number\",\"nil\")(expect.range or function()end)(T,0,31)(expect.range or function()end)(T+U-1,0,31)U=U or 1;local E=0;for o=T+U-1,T,-1 do E=E*2+bit.band(S,2^o)/2^o end;return E end;function bit32.replace(S,c,T,U)expect(1,S,\"number\")expect(2,c,\"number\")expect(3,T,\"number\")expect(4,U,\"number\",\"nil\")(expect.range or function()end)(T,0,31)(expect.range or function()end)(T+U-1,0,31)U=U or 1;local V=2^U-1;return bit.bor(bit.band(S,bit.bnot(bit.blshift(V,T))),bit.blshift(bit.band(c,V),T))end;function bit32.lrotate(Q,W)return bit.bor(bit.blshift(Q,W),bit.blogic_rshift(Q,32-W))end;function bit32.rrotate(Q,W)return bit.bor(bit.blogic_rshift(Q,W),bit.blshift(Q,32-W))end end;bit=nil end;if _VERSION==\"Lua 5.1\"and load(\"::a:: goto a\")then _VERSION=\"Lua 5.2\"if load(\"return 1 >> 2 & 3\")then _VERSION=\"Lua 5.3\"if load(\"local <const> a = 2\")then _VERSION=\"Lua 5.4\"end end end;if _VERSION==\"Lua 5.1\"then if not table.pack then table.pack=function(...)local X={...}X.n=select(\"#\",...)return X end end;if not table.unpack then table.unpack,unpack=unpack,nil end;local k,c=xpcall(function(Y)return Y end,function()end,true)if not c then local Z=xpcall;xpcall=function(f,_,...)if select(\"#\",...)>0 then local args=table.pack(...)return Z(function()return f(table.unpack(args,1,args.n))end,_)else return Z(f,_)end end end end;if tonumber(_HOST:match\"ComputerCraft 1.(%d+)\")<95 then local a0=fs.combine;function fs.combine(a1,...)if...~=nil then return a0(a1,fs.combine(...))else return a1 end end end;if not string.pack then local expect=expect.expect;local a2={BIG_ENDIAN=1,LITTLE_ENDIAN=2}local a3={b=1,B=1,h=1,H=1,l=1,L=1,j=1,J=1,T=1}local a4={b=1,B=1,x=1,h=2,H=2,f=4,j=4,J=4,l=8,L=8,T=8,d=8,n=8}local function a5(S)if S%1>=0.5 then return math.ceil(S)else return math.floor(S)end end;local function a6(f)if f==0 then return 0 elseif f==-0 then return 0x80000000 elseif f==math.huge then return 0x7F800000 elseif f==-math.huge then return 0xFF800000 end;local Y,a7=math.frexp(f)if a7>127 or a7<-126 then error(\"number out of range\",3)end;a7,Y=a7+126,a5((math.abs(Y)-0.5)*0x1000000)if Y>0x7FFFFF then a7=a7+1 end;return bit32.bor(f<0 and 0x80000000 or 0,bit32.lshift(bit32.band(a7,0xFF),23),bit32.band(Y,0x7FFFFF))end;local function a8(f)if f==0 then return 0,0 elseif f==-0 then return 0x80000000,0 elseif f==math.huge then return 0x7FF00000,0 elseif f==-math.huge then return 0xFFF00000,0 end;local Y,a7=math.frexp(f)if a7>1023 or a7<-1022 then error(\"number out of range\",3)end;a7,Y=a7+1022,a5((math.abs(Y)-0.5)*0x20000000000000)if Y>0xFFFFFFFFFFFFF then a7=a7+1 end;return bit32.bor(f<0 and 0x80000000 or 0,bit32.lshift(bit32.band(a7,0x7FF),20),bit32.band(Y/0x100000000,0xFFFFF)),bit32.band(Y,0xFFFFFFFF)end;local function a9(aa)if aa==0 then return 0 elseif aa==0x80000000 then return-0 elseif aa==0x7F800000 then return math.huge elseif aa==0xFF800000 then return-math.huge end;local Y,a7=bit32.band(aa,0x7FFFFF),bit32.band(bit32.rshift(aa,23),0xFF)a7,Y=a7-126,Y/0x1000000+0.5;local S=math.ldexp(Y,a7)return bit32.btest(aa,0x80000000)and-S or S end;local function ab(ac,ad)if ac==0 and ad==0 then return 0 elseif ac==0x80000000 and ad==0 then return-0 elseif ac==0x7FF00000 and ad==0 then return math.huge elseif ac==0xFFF00000 and ad==0 then return-math.huge end;local Y,a7=bit32.band(ac,0xFFFFF)*0x100000000+bit32.band(ad,0xFFFFFFFF),bit32.band(bit32.rshift(ac,20),0x7FF)a7,Y=a7-1022,Y/0x20000000000000+0.5;local S=math.ldexp(Y,a7)return bit32.btest(ac,0x80000000)and-S or S end;local function ae(u,af,ag,ah,ai,aj,ak)local al=0;if ah%math.min(af,ai)~=0 and ai>1 then local o=0;while ah%math.min(af,ai)~=0 and o<ai do ag[ah]=0;ah=ah+1;al=al+1;o=o+1 end end;if aj==a2.BIG_ENDIAN then local am=0;if af>8 then for o=0,af-9 do ag[ah+o]=ak and u>=2^(af*8-1)~=0 and 0xFF or 0;am=am+1;al=al+1 end end;for o=am,af-1 do ag[ah+o]=bit32.band(bit32.rshift(u,(af-o-1)*8),0xFF)al=al+1 end else for o=0,math.min(af,8)-1 do ag[ah+o]=u/2^(o*8)%256;al=al+1 end;for o=8,af-1 do ag[ah+o]=ak and u>=2^(af*8-1)~=0 and 0xFF or 0;al=al+1 end end;return al end;local function an(t,ah,af,aj,ai,ak)local ao,ap=0,0;if ah%math.min(af,ai)~=0 and ai>1 then for o=0,ai-1 do if ah%math.min(af,ai)==0 then break end;ah=ah+1;ap=ap+1 end end;for o=0,af-1 do ao=ao+t:byte(ah+o)*2^((aj==a2.BIG_ENDIAN and af-o-1 or o)*8)ap=ap+1 end;if ak and ao>=2^(af*8-1)then ao=ao-2^(af*8)end;return ao,ap end;local function aq(ar,ai)local as=a4[ar]or 0;if ai>1 and as%ai~=0 then as=as+ai-as%ai end;return as end;function string.pack(...)local at=expect(1,...,\"string\")local aj=a2.LITTLE_ENDIAN;local ai=1;local au=1;local av=2;local ag={}local o=1;while o<=#at do local G=at:sub(o,o)o=o+1;if G=='='or G=='<'then aj=a2.LITTLE_ENDIAN elseif G=='>'then aj=a2.BIG_ENDIAN elseif G=='!'then local af=-1;while o<=#at and at:sub(o,o):match(\"%d\")do if af>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;af=math.max(af,0)*10+tonumber(at:sub(o,o))o=o+1 end;if af>16 or af==0 then error(string.format(\"integral size (%d) out of limits [1,16]\",af),2)elseif af==-1 then ai=4 else ai=af end elseif a3[G]then local u=expect(av,select(av,...),\"number\")av=av+1;if u>=math.pow(2,aq(G,0)*8-(G:match(\"%l\")and 1 or 0))or u<(G:match(\"%l\")and-math.pow(2,aq(G,0)*8-1)or 0)then error(string.format(\"bad argument #%d to 'pack' (integer overflow)\",av-1),2)end;au=au+ae(u,aq(G,0),ag,au,ai,aj,false)elseif G:lower()=='i'then local ak=G=='i'local af=-1;while o<=#at and at:sub(o,o):match(\"%d\")do if af>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;af=math.max(af,0)*10+tonumber(at:sub(o,o))o=o+1 end;if af>16 or af==0 then error(string.format(\"integral size (%d) out of limits [1,16]\",af),2)elseif ai>1 and(af~=1 and af~=2 and af~=4 and af~=8 and af~=16)then error(\"bad argument #1 to 'pack' (format asks for alignment not power of 2)\",2)elseif af==-1 then af=4 end;local u=expect(av,select(av,...),\"number\")av=av+1;if u>=math.pow(2,af*8-(G:match(\"%l\")and 1 or 0))or u<(G:match(\"%l\")and-math.pow(2,af*8-1)or 0)then error(string.format(\"bad argument #%d to 'pack' (integer overflow)\",av-1),2)end;au=au+ae(u,af,ag,au,ai,aj,ak)elseif G=='f'then local f=expect(av,select(av,...),\"number\")av=av+1;local aa=a6(f)if au%math.min(4,ai)~=0 and ai>1 then for aw=0,ai-1 do if au%math.min(4,ai)==0 then break end;ag[au]=0;au=au+1 end end;for aw=0,3 do ag[au+(aj==a2.BIG_ENDIAN and 3-aw or aw)]=bit32.band(bit32.rshift(aa,aw*8),0xFF)end;au=au+4 elseif G=='d'or G=='n'then local f=expect(av,select(av,...),\"number\")av=av+1;local ac,ad=a8(f)if au%math.min(8,ai)~=0 and ai>1 then for aw=0,ai-1 do if au%math.min(8,ai)==0 then break end;ag[au]=0;au=au+1 end end;for aw=0,3 do ag[au+(aj==a2.BIG_ENDIAN and 7-aw or aw)]=bit32.band(bit32.rshift(ad,aw*8),0xFF)end;for aw=4,7 do ag[au+(aj==a2.BIG_ENDIAN and 7-aw or aw)]=bit32.band(bit32.rshift(ac,(aw-4)*8),0xFF)end;au=au+8 elseif G=='c'then local af=0;if o>#at or not at:sub(o,o):match(\"%d\")then error(\"missing size for format option 'c'\",2)end;while o<=#at and at:sub(o,o):match(\"%d\")do if af>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;af=af*10+tonumber(at:sub(o,o))o=o+1 end;if au+af<au or au+af>0xFFFFFFFF then error(\"bad argument #1 to 'pack' (format result too large)\",2)end;local t=expect(av,select(av,...),\"string\")av=av+1;if#t>af then error(string.format(\"bad argument #%d to 'pack' (string longer than given size)\",av-1),2)end;if af>0 then for aw=0,af-1 do ag[au+aw]=t:byte(aw+1)or 0 end;au=au+af end elseif G=='z'then local t=expect(av,select(av,...),\"string\")av=av+1;for ax in t:gmatch\".\"do if ax=='\\0'then error(string.format(\"bad argument #%d to 'pack' (string contains zeros)\",av-1),2)end end;for aw=0,#t-1 do ag[au+aw]=t:byte(aw+1)end;ag[au+#t]=0;au=au+#t+1 elseif G=='s'then local af=0;while o<=#at and at:sub(o,o):match(\"%d\")do if af>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;af=af*10+tonumber(at:sub(o,o))o=o+1 end;if af>16 then error(string.format(\"integral size (%d) out of limits [1,16]\",af),2)elseif af==0 then af=4 end;local t=expect(av,select(av,...),\"string\")av=av+1;if#t>=math.pow(2,af*8)then error(string.format(\"bad argument #%d to 'pack' (string length does not fit in given size)\",av-1),2)end;ae(#t,af,ag,au,1,aj,false)for aw=af,#t+af-1 do ag[au+aw]=t:byte(aw-af+1)or 0 end;au=au+#t+af elseif G=='x'then ag[au]=0;au=au+1 elseif G=='X'then if o>=#at then error(\"invalid next option for option 'X'\",2)end;local af=0;local G=at:sub(o,o)o=o+1;if G:lower()=='i'then while o<=#at and at:sub(o,o):match(\"%d\")do if af>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;af=af*10+tonumber(at:sub(o,o))o=o+1 end;if af>16 or af==0 then error(string.format(\"integral size (%d) out of limits [1,16]\",af),2)end else af=aq(G,0)end;if af<1 then error(\"invalid next option for option 'X'\",2)end;if au%math.min(af,ai)~=0 and ai>1 then for aw=1,ai do if au%math.min(af,ai)==0 then break end;ag[au]=0;au=au+1 end end elseif G~=' 'then error(string.format(\"invalid format option '%s'\",G),2)end end;return string.char(table.unpack(ag))end;function string.packsize(at)local au=0;local ai=1;local o=1;while o<=#at do local G=at:sub(o,o)o=o+1;if G=='!'then local af=0;while o<=#at and at:sub(o,o):match(\"%d\")do if af>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;af=af*10+tonumber(at:sub(o,o))o=o+1 end;if af>16 then error(string.format(\"integral size (%d) out of limits [1,16]\",af),2)elseif af==0 then ai=4 else ai=af end elseif a3[G]then local af=aq(G,0)if au%math.min(af,ai)~=0 and ai>1 then for aw=1,ai do if au%math.min(af,ai)==0 then break end;au=au+1 end end;au=au+af elseif G:lower()=='i'then local af=0;while o<=#at and at:sub(o,o):match(\"%d\")do if af>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;af=af*10+tonumber(at:sub(o,o))o=o+1 end;if af>16 then error(string.format(\"integral size (%d) out of limits [1,16]\",af))elseif ai>1 and(af~=1 and af~=2 and af~=4 and af~=8 and af~=16)then error(\"bad argument #1 to 'pack' (format asks for alignment not power of 2)\",2)elseif af==0 then af=4 end;if au%math.min(af,ai)~=0 and ai>1 then for aw=1,ai do if au%math.min(af,ai)==0 then break end;au=au+1 end end;au=au+af elseif G=='f'then if au%math.min(4,ai)~=0 and ai>1 then for aw=1,ai do if au%math.min(4,ai)==0 then break end;au=au+1 end end;au=au+4 elseif G=='d'or G=='n'then if au%math.min(8,ai)~=0 and ai>1 then for aw=1,ai do if au%math.min(8,ai)==0 then break end;au=au+1 end end;au=au+8 elseif G=='c'then local af=0;if o>#at or not at:sub(o,o):match(\"%d\")then error(\"missing size for format option 'c'\",2)end;while o<=#at and at:sub(o,o):match(\"%d\")do if af>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;af=af*10+tonumber(at:sub(o,o))o=o+1 end;if au+af<au or au+af>0x7FFFFFFF then error(\"bad argument #1 to 'packsize' (format result too large)\",2)end;au=au+af elseif G=='x'then au=au+1 elseif G=='X'then if o>=#at then error(\"invalid next option for option 'X'\",2)end;local af=0;local G=at:sub(o,o)o=o+1;if G:lower()=='i'then while o<=#at and at:sub(o,o):match(\"%d\")do if af>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;af=af*10+tonumber(at:sub(o,o))o=o+1 end;if af>16 or af==0 then error(string.format(\"integral size (%d) out of limits [1,16]\",af),2)end else af=aq(G,0)end;if af<1 then error(\"invalid next option for option 'X'\",2)end;if au%math.min(af,ai)~=0 and ai>1 then for aw=1,ai do if au%math.min(af,ai)==0 then break end;au=au+1 end end elseif G=='s'or G=='z'then error(\"bad argument #1 to 'packsize' (variable-length format)\",2)elseif G~=' 'and G~='<'and G~='>'and G~='='then error(string.format(\"invalid format option '%s'\",G),2)end end;return au end;function string.unpack(at,t,au)expect(1,at,\"string\")expect(2,t,\"string\")expect(3,au,\"number\",\"nil\")if au then if au<0 then au=#t+au elseif au==0 then error(\"bad argument #3 to 'unpack' (initial position out of string)\",2)end;if au>#t or au<0 then error(\"bad argument #3 to 'unpack' (initial position out of string)\",2)end else au=1 end;local aj=a2.LITTLE_ENDIAN;local ai=1;local as={}local o=1;while o<=#at do local G=at:sub(o,o)o=o+1;if G=='<'or G=='='then aj=a2.LITTLE_ENDIAN elseif G=='>'then aj=a2.BIG_ENDIAN elseif G=='!'then local af=0;while o<=#at and at:sub(o,o):match(\"%d\")do if af>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;af=af*10+tonumber(at:sub(o,o))o=o+1 end;if af>16 then error(string.format(\"integral size (%d) out of limits [1,16]\",af))elseif af==0 then ai=4 else ai=af end elseif a3[G]then if au+aq(G,0)>#t+1 then error(\"data string too short\",2)end;local E,ay=an(t,au,aq(G,0),aj,ai,G:match(\"%l\")~=nil)as[#as+1]=E;au=au+ay elseif G:lower()=='i'then local ak=G=='i'local af=0;while o<=#at and at:sub(o,o):match(\"%d\")do if af>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;af=af*10+tonumber(at:sub(o,o))o=o+1 end;if af>16 then error(string.format(\"integral size (%d) out of limits [1,16]\",af),2)elseif af>8 then error(string.format(\"%d-byte integer does not fit into Lua Integer\",af),2)elseif af==0 then af=4 end;if au+af>#t+1 then error(\"data string too short\",2)end;local E,ay=an(t,au,af,aj,ai,ak)as[#as+1]=E;au=au+ay elseif G=='f'then if au%math.min(4,ai)~=0 and ai>1 then for aw=1,ai do if au%math.min(4,ai)==0 then break end;au=au+1 end end;if au+4>#t+1 then error(\"data string too short\",2)end;local E=an(t,au,4,aj,ai,false)as[#as+1]=a9(E)au=au+4 elseif G=='d'or G=='n'then if au%math.min(8,ai)~=0 and ai>1 then for aw=1,ai do if au%math.min(8,ai)==0 then break end;au=au+1 end end;if au+8>#t+1 then error(\"data string too short\",2)end;local ac,ad=0,0;for aw=0,3 do ac=bit32.bor(ac,bit32.lshift(t:byte(au+aw),(aj==a2.BIG_ENDIAN and 3-aw or aw)*8))end;for aw=0,3 do ad=bit32.bor(ad,bit32.lshift(t:byte(au+aw+4),(aj==a2.BIG_ENDIAN and 3-aw or aw)*8))end;if aj==a2.LITTLE_ENDIAN then ac,ad=ad,ac end;as[#as+1]=ab(ac,ad)au=au+8 elseif G=='c'then local af=0;if o>#at or not at:sub(o,o):match(\"%d\")then error(\"missing size for format option 'c'\",2)end;while o<=#at and at:sub(o,o):match(\"%d\")do if af>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\")end;af=af*10+tonumber(at:sub(o,o))o=o+1 end;if au+af>#t+1 then error(\"data string too short\",2)end;as[#as+1]=t:sub(au,au+af-1)au=au+af elseif G=='z'then local af=0;while t:byte(au+af)~=0 do af=af+1;if au+af>#t then error(\"unfinished string for format 'z'\",2)end end;as[#as+1]=t:sub(au,au+af-1)au=au+af+1 elseif G=='s'then local af=0;while o<=#at and at:sub(o,o):match(\"%d\")do if af>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;af=af*10+tonumber(at:sub(o,o))o=o+1 end;if af>16 then error(string.format(\"integral size (%d) out of limits [1,16]\",af),2)elseif af==0 then af=4 end;if au+af>#t+1 then error(\"data string too short\",2)end;local u,az=an(t,au,af,aj,ai,false)au=au+az;if au+u>#t+1 then error(\"data string too short\",2)end;as[#as+1]=t:sub(au,au+u-1)au=au+u elseif G=='x'then au=au+1 elseif G=='X'then if o>=#at then error(\"invalid next option for option 'X'\",2)end;local af=0;local G=at:sub(o,o)o=o+1;if G:lower()=='i'then while o<=#at and at:sub(o,o):match(\"%d\")do if af>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;af=af*10+tonumber(at:sub(o,o))o=o+1 end;if af>16 or af==0 then error(string.format(\"integral size (%d) out of limits [1,16]\",af),2)elseif af==-1 then af=4 end else af=aq(G,0)end;if af<1 then error(\"invalid next option for option 'X'\",2)end;if au%math.min(af,ai)~=0 and ai>1 then for aw=1,ai do if au%math.min(af,ai)==0 then break end;au=au+1 end end elseif G~=' 'then error(string.format(\"invalid format option '%s'\",G),2)end end;as[#as+1]=au;return table.unpack(as)end end;function panic(aA)term.setBackgroundColor(32768)term.setTextColor(16384)term.setCursorBlink(false)local Q,R=term.getCursorPos()Q=1;local aB,aC=term.getSize()aA=\"panic: \"..(aA or\"unknown\")for aD in aA:gmatch\"%S+\"do if Q+#aD>=aB then Q,R=1,R+1;if R>aC then term.scroll(1)R=R-1 end end;term.setCursorPos(Q,R)if Q==1 then term.clearLine()end;term.write(aD..\" \")Q=Q+#aD+1 end;Q,R=1,R+1;if R>aC then term.scroll(1)R=R-1 end;if debug then local aE=debug.traceback(nil,2)for aF in aE:gmatch\"[^\\n]+\"do term.setCursorPos(1,R)term.write(aF)R=R+1;if R>aC then term.scroll(1)R=R-1 end end end;term.setCursorPos(1,R)term.setTextColor(2)term.write(\"panic: We are hanging here...\")mainThread=nil;if _HEADLESS then os.shutdown(1)end;while true do coroutine.yield()end end;function do_syscall(aG,...)local E=table.pack(coroutine.yield(\"syscall\",aG,...))if E[1]then return table.unpack(E,2,E.n)else error(E[2],3)end end;function deepcopy(aH)if type(aH)==\"table\"then local as=setmetatable({},deepcopy(getmetatable(aH)))for F,c in pairs(aH)do as[deepcopy(F)]=deepcopy(c)end;return as else return aH end end;function split(t,aI)local X={}for aJ in t:gmatch(\"[^\"..(aI or\"%s\")..\"]+\")do X[#X+1]=aJ end;return X end;local aK=pcall(os.epoch,\"nano\")and function()return os.epoch\"nano\"/1000000 end or(ccemux and function()return ccemux.nanoTime()/1000000 end or function()return os.epoch\"utc\"end)local aL;function getCurrentThread()return aL end;local aM={n=0}function executeThread(process,aN,aO,aP,aQ)local args;if aN.paused then return false,aQ end;if aN.status==\"starting\"then args=aN.args elseif aN.status==\"syscall\"then args=table.pack(table.unpack(aN.syscall_return,3,aN.syscall_return.n))elseif aN.status==\"preempt\"then args=aM elseif aN.status==\"suspended\"then args={aO[1],{}}for F,c in pairs(aO[2])do args[2][F]=c end elseif aN.status==\"paused\"then return false,aQ end;if aN.status~=\"dead\"and(not aN.filter or aN.filter(process,aN,aO))then local aR=aP;aP=false;aN.filter=nil;local aS;if aN.yielding then aS={n=aN.syscall_return.n,true,\"syscall\",aN.yielding,table.unpack(aN.syscall_return,4,aN.syscall_return.n)}aN.yielding=nil else assert(process.globalMetatables,\"Process \"..process.id..\" has no global metatables\")aL=aN;local aT=globalMetatables;globalMetatables=process.globalMetatables;updateGlobalMetatables()local aU=aK()aS=table.pack(coroutine.resume(aN.coro,table.unpack(args,1,args.n)))process.cputime=process.cputime+(aK()-aU)/1000;globalMetatables=aT;updateGlobalMetatables()aL=nil end;if aS[2]==\"secure_syscall\"then aS[2]=\"syscall\"elseif aS[2]==\"secure_event\"then aS[2]=nil end;if aS[2]==\"syscall\"then aN.status=\"syscall\"local aV=aQ;aQ=false;if aS[3]and syscalls[aS[3]]then local aU=aK()aN.syscall_return=table.pack(coroutine.resume(aN.syscall,aS[3],process,aN,table.unpack(aS,4,aS.n)))process.systime=process.systime+(aK()-aU)/1000;if aN.syscall_return[2]==kSyscallComplete then if not aN.syscall_return[3]and type(aN.syscall_return[4])==\"string\"then syslog.log({level=\"debug\",category=\"Syscall Failure\",process=0,module=aS[3]},aN.syscall_return[4])aN.syscall_return[4]=aN.syscall_return[4]:gsub(\"kernel:%d+: \",\"\")end;if aN.syscall_return[4]==kSyscallYield then aN.yielding=aN.syscall_return[5]aQ=aV end else aN.yielding=aS[3]end else aN.syscall_return={false,\"No such syscall\",n=2}end elseif aS[2]==\"preempt\"then aN.status=\"preempt\"aQ=false elseif coroutine.status(aN.coro)==\"dead\"then aN.status=\"dead\"aN.return_value=aS[2]if aS[1]then process.lastReturnValue={pid=process.id,thread=aN.id,value=aS[2],n=aS.n-1,table.unpack(aS,2,aS.n)}else process.lastReturnValue={pid=process.id,thread=aN.id,error=aS[2],traceback=debug.traceback(aN.coro)}end;if not aS[1]then aN.did_error=true;syslog.log({level=_G.args.traceback and\"error\"or\"debug\",process=process.id,thread=aN.id,category=\"Application Error\",traceback=true},debug.traceback(aN.coro,aS[2]))if aS[2]and process.stderr and process.stderr.isTTY then terminal.write(process.stderr,aS[2]..\"\\n\")end end;process.threads[aN.id]=nil;aP=aR else aN.status=\"suspended\"aQ=aQ and#process.eventQueue==0 end end;return aP,aQ end;mainThread=coroutine.running()function userModeCallback(process,aW,...)local aX=syscalls.newthread(process,nil,aW,...)local aN=process.threads[aX]aN.name=\"<user mode callback>\"while aN.status~=\"dead\"do if coroutine.running()==mainThread then error(\"userModeCallback not called from a yieldable context\",2)end;coroutine.yield()end;return not aN.did_error,aN.return_value end;function make_ENV(I)if type(I)~=\"table\"or _VERSION~=\"Lua 5.1\"then return I end;repeat local j=getmetatable(I)if j and j.__env then I=j.__env end until not j or not j.__env;local X=setmetatable({},{__index=function(self,aY)if self==I then I=getmetatable(self).__env end;if aY==\"_ENV\"then return I else return I[aY]end end,__newindex=function(self,aY,z)if self==I then I=getmetatable(self).__env end;if aY==\"_ENV\"then I=z else I[aY]=z end end,__pairs=function(self)if self==I then I=getmetatable(self).__env end;return next,I end,__len=function(self)if self==I then I=getmetatable(self).__env end;return#I end,__env=I})return X end;for k,c in ipairs({...})do local r,g=c:match(\"^([^=]+)=(.+)$\")if r and g then if type(args[r])==\"boolean\"then args[r]=g:lower()==\"true\"or g==\"1\"elseif type(args[r])==\"number\"then args[r]=tonumber(g)else args[r]=g end elseif r==\"silent\"then args.loglevel=5 elseif r==\"quiet\"then args.loglevel=3 end end;if _HEADLESS then args.headless=true end;local function aZ(a_)local E;if _CC_VERSION then E=a_<=_CC_VERSION elseif not _HOST then E=a_<=os.version():gsub(\"CraftOS \",\"\")elseif _HOST:match(\"ComputerCraft 1%.1%d+\")~=a_:match(\"1%.1%d+\")then a_=a_:gsub(\"(1%.)([02-9])\",\"%10%2\")local b0=_HOST:gsub(\"(ComputerCraft 1%.)([02-9])\",\"%10%2\")E=a_<=b0:match(\"ComputerCraft ([0-9%.]+)\")else E=a_<=_HOST:match(\"ComputerCraft ([0-9%.]+)\")end;return E end;if not aZ\"1.87.0\"then panic(\"Phoenix requires ComputerCraft 1.87.0 or later. Please upgrade your version of ComputerCraft.\")end;if jit and args.preemptive then panic(\"Phoenix does not support preemption when running under LuaJIT. Please set preemptive to false in the kernel arguments.\")end;if not debug and args.preemptive then panic(\"Phoenix does not support preemption without the debug API. Please set preemptive to false in the kernel arguments.\")end;if args.preemptive then PHOENIX_BUILD=PHOENIX_BUILD..\" PREEMPT\"end;if not getfenv then if not debug then panic(\"Phoenix requires the debug API when running under Lua 5.2 and later.\")end;function getfenv(J)local o=1;while true do local O,z=debug.getupvalue(J,o)if O==\"_ENV\"then return z elseif not O then break end;o=o+1 end end;function setfenv(J,I)local o=1;while true do local O=debug.getupvalue(J,o)if O==\"_ENV\"then debug.upvaluejoin(J,o,function()return I end,1)break elseif not O then break end;o=o+1 end;return J end elseif getfenv(function()end)==_ENV then local getfenv,b1,I=getfenv,debug.getfenv,_ENV;function _G.getfenv(b2)local a7=getfenv(b2)if a7==I then a7=nil;local o=1;if type(b2)==\"number\"then b2=debug.getinfo(b2).func end;while true do local O,z=debug.getupvalue(b2,o)if O==\"_ENV\"and z~=I then return z elseif not O then break end;o=o+1 end end;return a7 end;function debug.getfenv(b2)local a7=b1(b2)if a7==I then a7=nil;local o=1;if type(b2)==\"number\"then b2=debug.getinfo(b2).func end;while true do local O,z=debug.getupvalue(b2,o)if O==\"_ENV\"and z~=I then return z elseif not O then break end;o=o+1 end end;return a7 end end;globalMetatables={[\"nil\"]={},[\"boolean\"]={},[\"number\"]={},[\"string\"]={__index=string},[\"function\"]={},[\"thread\"]={__index=coroutine,__call=coroutine.resume},[\"userdata\"]={}}local b3,b4=debug.getmetatable,debug.setmetatable;function updateGlobalMetatables()b4(nil,globalMetatables[\"nil\"])b4(false,globalMetatables[\"boolean\"])b4(0,globalMetatables[\"number\"])b4(\"\",globalMetatables[\"string\"])b4(assert,globalMetatables[\"function\"])b4(coroutine.running(),globalMetatables[\"thread\"])if debug.upvalueid then b4(debug.upvalueid(executeThread,1),globalMetatables[\"userdata\"])end end;local type=type;function debug.getmetatable(z)if type(z)==\"table\"then return b3(z)else return globalMetatables[type(z)]end end;function debug.setmetatable(z,aH)expect(2,aH,\"table\")if type(z)==\"table\"then return b4(z,aH)else globalMetatables[type(z)]=aH end end;do local b5;local b6,b7,b1,b8,b9,ba,bb,bc,bd=getfenv,setfenv,debug.getfenv,debug.getlocal,debug.getupvalue,debug.setfenv,debug.setlocal,debug.setupvalue,debug.upvaluejoin;local error,be,bf,select,setmetatable,type,tonumber=error,debug.getinfo,coroutine.running,select,setmetatable,type,tonumber;local bg;local function keys(X,c,...)if c then X[c]=true end;if select(\"#\",...)>0 then return keys(X,...)else return X end end;local function bh(c,...)if select(\"#\",...)>0 then return bg[c or\"\"]or c,bh(...)else return bg[c or\"\"]or c end end;local function bi(S)S=bit32.band(tonumber(S),0xFFFFFFFF)if bit32.btest(S,0x80000000)then S=S-0x100000000 end;return S end;function debug.getinfo(aN,aW,bj)if type(aN)~=\"thread\"then bj,aW,aN=aW,aN,bf()end;local as;if tonumber(aW)then as=be(aN,aW+1,bj)else as=be(aN,aW,bj)end;if as and as.func then as.func=bg[as.func]or as.func end;return as end;function debug.getlocal(aN,C,bk)if bk==nil then bk,C,aN=C,aN,bf()end;local F,c;if type(C)==\"function\"then local bl=be(2,\"f\")if b5[C]and not(bl and b5[C][bl.func])then return nil end;F,c=bh(b8(C,bk))elseif tonumber(C)then local info=be(aN,C+1,\"f\")local bl=be(2,\"f\")if info and b5[info.func]and not(bl and b5[info.func][bl.func])then return nil end;F,c=bh(b8(aN,C+1,bk))else F,c=bh(b8(aN,C,bk))end;return F,c end;function debug.getupvalue(aW,bm)if type(aW)==\"function\"then local bl=be(2,\"f\")if b5[aW]and not(bl and b5[aW][bl.func])then return nil end end;local F,c=bh(b9(aW,bm))return F,c end;function debug.setlocal(aN,C,bk,g)if bk==nil then bk,C,aN=C,aN,bf()end;if tonumber(C)then local info=be(aN,C+1,\"f\")local bl=be(2,\"f\")if info and b5[info.func]and not(bl and b5[info.func][bl.func])then error(\"attempt to set local of protected function\",2)end;bb(aN,C+1,bk,g)else bb(aN,C,bk,g)end end;function debug.setupvalue(aW,bm,g)if type(aW)==\"function\"then local bl=be(2,\"f\")if b5[aW]and not(bl and b5[aW][bl.func])then error(\"attempt to set upvalue of protected function\",2)end end;bc(aW,bm,g)end;function _G.getfenv(f)local c;if f==nil then c=b6(2)elseif tonumber(f)and bi(f)>0 then local info=be(f+1,\"f\")local bl=be(2,\"f\")if info and b5[info.func]and not(bl and b5[info.func][bl.func])then return nil end;c=b6(f+1)elseif type(f)==\"function\"then local bl=be(2,\"f\")if b5[f]and not(bl and b5[f][bl.func])then return nil end;c=b6(f)else c=b6(f)end;return c end;function _G.setfenv(f,aH)if tonumber(f)and bi(f)>0 then local info=be(f+1,\"f\")local bl=be(2,\"f\")if info and b5[info.func]and not(bl and b5[info.func][bl.func])then error(\"attempt to set environment of protected function\",2)end;b7(f+1,aH)elseif type(f)==\"function\"then local bl=be(2,\"f\")if b5[f]and not(bl and b5[f][bl.func])then error(\"attempt to set environment of protected function\",2)end end;b7(f,aH)end;if b1 then function debug.getfenv(b2)if type(b2)==\"function\"then local bl=be(2,\"f\")if b5[b2]and not(bl and b5[b2][bl.func])then return nil end end;local c=b1(b2)return c end;function debug.setfenv(b2,aH)if type(b2)==\"function\"then local bl=be(2,\"f\")if b5[b2]and not(bl and b5[b2][bl.func])then error(\"attempt to set environment of protected function\",2)end end;ba(b2,aH)end end;if bd then function debug.upvaluejoin(bn,bo,bp,bq)if type(bn)==\"function\"and type(bp)==\"function\"then local bl=be(2,\"f\")if b5[bn]and not(bl and b5[bn][bl.func])then error(\"attempt to get upvalue of protected function\",2)end;if b5[bp]and not(bl and b5[bp][bl.func])then error(\"attempt to set upvalue of protected function\",2)end end;bd(bn,bo,bp,bq)end end;function debug.protect(aW)if type(aW)~=\"function\"then error(\"bad argument #1 (expected function, got \"..type(aW)..\")\",2)end;if b5[aW]then error(\"attempt to protect a protected function\",2)end;b5[aW]=keys(setmetatable({},{__mode=\"k\"}))end;bg={[b8]=debug.getlocal,[bb]=debug.setlocal,[b9]=debug.getupvalue,[bc]=debug.setupvalue,[be]=debug.getinfo,[bh]=function()end,[K]=function()end}if debug.upvaluejoin then bg[bd]=debug.upvaluejoin end;if debug.getfenv then bg[b1]=debug.getfenv end;if debug.setfenv then bg[ba]=debug.setfenv end;if _G.getfenv then bg[b6]=_G.getfenv end;if _G.setfenv then bg[b7]=_G.setfenv end;b5=keys(setmetatable({},{__mode=\"k\"}),getfenv,setfenv,debug.getfenv,debug.setfenv,debug.getlocal,debug.setlocal,debug.getupvalue,debug.setupvalue,debug.upvaluejoin,debug.getinfo,bh,debug.protect)for F,c in pairs(b5)do b5[F]={}end end;debug.protect(_G.load)if _G.load~=K then debug.protect(K)end;debug.protect(debug.getmetatable)debug.protect(debug.setmetatable)mounts={}fifos={}fsevents={}filesystems={craftos={meta={meta={type=\"directory\",owner=\"root\",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}},metapath=\"/meta.ltn\",lastDispatch=0},tmpfs={},drivefs={},tablefs={},bind={}}local function br(process,bs)local a1=fs.combine(process.root,bs:sub(1,1)==\"/\"and\"\"or process.dir,bs)if\"/\"..a1 ..\"/\"~=process.root and a1:find(process.root:sub(2),1,true)~=1 then error(bs..\": No such file or directory\",4)end;return a1 end;local function bt(process,bs,bu)local bv=split(br(process,bs),\"/\\\\\")if#bv==0 then if bu then return mounts[\"\"],bs,\"\"end;return mounts[\"\"][1],bs,\"\"end;local bw;for F in pairs(mounts)do local s=true;for o,G in ipairs(split(F,\"/\\\\\"))do if bv[o]~=G then s=false;break end end;if s and(not bw or#F>#bw)then bw=F end end;if not bw then panic(\"Could not find mount for path \"..bs..\". Where is root?\")end;local bx=split(bw,\"/\\\\\")local a1=#bv>=#bx+1 and fs.combine(table.unpack(bv,#bx+1,#bv))or\"\"local mounts=mounts[bw]if bu then return mounts,a1,bw end;local by=mounts[1]if#mounts>1 then for k,c in ipairs(mounts)do local s,E=pcall(c.stat,c,process,a1,true)if s and E then by=c;break end end end;return by,a1,bw end;function filesystem.readhandle(process,bz,bA)if bz==\"\"then local bB=false;local function bC()if bB then return nil end;bB=true;return\"\"end;local bD={readLine=bC,readAll=bC,read=bC,close=function()end}if bA then function bD.seek()bB=false end;function bD.read(S)if not S then return nil end;return bC()end end;return bD end;local au=1;local bE=false;local X={readLine=function(bF)if bE then error(\"attempt to use a closed file\",2)end;if au>#bz then return nil end;local bG;bG,au=bz:match(\"([^\\n]*\"..(bF and\"\\n?)\"or\")\\n?\")..\"()\",au)return bG end,readAll=function()if bE then error(\"attempt to use a closed file\",2)end;if au>#bz then return nil end;local bG=bz:sub(au)au=#bG+1;return bG end,read=function(S)if bE then error(\"attempt to use a closed file\",2)end;if S~=nil and type(S)~=\"number\"then error(\"bad argument #1 (expected number, got \"..type(S)..\")\",2)end;S=S or 1;if au>#bz then return nil end;local bG=bz:sub(au,au+S-1)au=au+S;return bG end,close=function()if bE then error(\"attempt to use a closed file\",2)end;bE=true end}if bA then X.read=function(S)if bE then error(\"attempt to use a closed file\",2)end;if S~=nil and type(S)~=\"number\"then error(\"bad argument #1 (expected number, got \"..type(S)..\")\",2)end;if au>#bz then return nil end;if S then local bG=bz:sub(au,au+S-1)au=au+S;return bG else local bG=bz:byte(au)au=au+1;return bG end end;X.seek=function(bH,ah)if bH~=nil and type(bH)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(bH)..\")\",2)end;if ah~=nil and type(ah)~=\"number\"then error(\"bad argument #2 (expected number, got \"..type(ah)..\")\",2)end;bH=bH or\"cur\"ah=ah or 0;if bE then error(\"attempt to use closed file\",2)end;if bH==\"set\"then au=ah+1 elseif bH==\"cur\"then au=au+ah elseif bH==\"end\"then au=math.max(#bz-ah,1)else error(\"Invalid whence\",2)end;return au-1 end else bz=bz:gsub(\"[\\x80-\\xFF]+\",function(bI)local bJ=\"\"if not pcall(function()for k,bK in utf8.codes(bI)do bJ=bJ..(bK<256 and string.char(bK)or\"?\")end end)then return bI end;return bJ end)end;for k,c in pairs(X)do setfenv(c,process.env)debug.protect(c)end;return setmetatable(X,{__name=\"file\"})end;function filesystem.writehandle(process,bL,bA)setfenv(bL,process.env)local function bM(X)for k,c in pairs(X)do setfenv(c,process.env)debug.protect(c)end;return setmetatable(X,{__name=\"file\"})end;local bE=false;if bA then local au=1;local bN=\"\"local bO=\"\"return bM{write=function(bG)if bE then error(\"attempt to use a closed file\",2)end;if type(bG)==\"number\"then bN,au=bN:sub(1,au-1)..string.char(bG)..bN:sub(au+1),au+1;if bO then bO=bO..string.char(bG)end elseif type(bG)==\"string\"then bN,au=bN:sub(1,au-1)..bG..bN:sub(au+#bG),au+#bG;if bO then bO=bO..bG end else error(\"bad argument #1 (expected string or number, got \"..type(bG)..\")\",2)end end,writeLine=function(bG)if bE then error(\"attempt to use a closed file\",2)end;if type(bG)==\"number\"then bN,au=bN:sub(1,au-1)..string.char(bG)..\"\\n\"..bN:sub(au+2),au+2;if bO then bO=bO..string.char(bG)..\"\\n\"end elseif type(bG)==\"string\"then bN,au=bN:sub(1,au-1)..bG..\"\\n\"..bN:sub(au+#bG+1),au+#bG+1;if bO then bO=bO..bG..\"\\n\"end else error(\"bad argument #1 (expected string or number, got \"..type(bG)..\")\",2)end end,seek=function(bH,ah)if bH~=nil and type(bH)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(bH)..\")\",2)end;if ah~=nil and type(ah)~=\"number\"then error(\"bad argument #2 (expected number, got \"..type(ah)..\")\",2)end;bH=bH or\"cur\"ah=ah or 0;if bE then error(\"attempt to use closed file\",2)end;local bP=au;if bH==\"set\"then au=ah+1 elseif bH==\"cur\"then au=au+ah elseif bH==\"end\"then au=math.max(#bN-ah,1)else error(\"Invalid whence\",2)end;if bP~=au then bO=nil end;return au-1 end,flush=function()if bE then error(\"attempt to use a closed file\",2)end;if bO then bL(bO,false)else bL(bN,true)end;bO=\"\"end,close=function()if bE then error(\"attempt to use a closed file\",2)end;bE=true;if bO then bL(bO,false)else bL(bN,true)end;bO=\"\"end}else local bN=\"\"return bM{write=function(bG)if bE then error(\"attempt to use a closed file\",2)end;bN=bN..tostring(bG)end,writeLine=function(bG)if bE then error(\"attempt to use a closed file\",2)end;bN=bN..tostring(bG)..\"\\n\"end,flush=function()if bE then error(\"attempt to use a closed file\",2)end;bL(bN,false)bN=\"\"end,close=function()if bE then error(\"attempt to use a closed file\",2)end;bL(bN,false)bN=\"\"bE=true end}end end;function filesystem.fifohandle(process,bQ,P)local bE=false;local function bM(X)for k,c in pairs(X)do setfenv(c,process.env)debug.protect(c)end;return setmetatable(X,{__name=\"file\"})end;if P==\"r\"then return bM{readLine=function(bF)if bE then error(\"attempt to use a closed file\",2)end;if#bQ.data==0 then return nil end;local bG;bG,bQ.data=bQ.data:match(\"([^\\n]*\"..(bF and\"\\n?)\"or\")\\n?\")..\"(.*)\")return bG end,readAll=function()if bE then error(\"attempt to use a closed file\",2)end;if#bQ.data==0 then return nil end;local bG=bQ.data;bQ.data=\"\"return bG end,read=function(S)if bE then error(\"attempt to use a closed file\",2)end;if S~=nil and type(S)~=\"number\"then error(\"bad argument #1 (expected number, got \"..type(S)..\")\",2)end;S=S or 1;if#bQ.data==0 then return nil end;local bG=bQ.data:sub(1,S)bQ.data=bQ.data:sub(S+1)return bG end,close=function()if bE then error(\"attempt to use a closed file\",2)end;bE=true end}elseif P==\"w\"or P==\"a\"then local bN=bQ.data;return bM{write=function(bG)if bE then error(\"attempt to use a closed file\",2)end;bN=bN..tostring(bG)end,writeLine=function(bG)if bE then error(\"attempt to use a closed file\",2)end;bN=bN..tostring(bG)..\"\\n\"end,flush=function()if bE then error(\"attempt to use a closed file\",2)end;bQ.data=bN end,close=function()if bE then error(\"attempt to use a closed file\",2)end;bQ.data=bN;bE=true end}elseif P==\"rb\"then return bM{readLine=function(bF)if bE then error(\"attempt to use a closed file\",2)end;if#bQ.data==0 then return nil end;local bG;bG,bQ.data=bQ.data:match(\"([^\\n]*\"..(bF and\"\\n?)\"or\")\\n?\")..\"(.*)\")return bG end,readAll=function()if bE then error(\"attempt to use a closed file\",2)end;if#bQ.data==0 then return nil end;local bG=bQ.data;bQ.data=\"\"return bG end,read=function(S)if bE then error(\"attempt to use a closed file\",2)end;if S~=nil and type(S)~=\"number\"then error(\"bad argument #1 (expected number, got \"..type(S)..\")\",2)end;if#bQ.data==0 then return nil end;if S then local bG=bQ.data:sub(1,S)bQ.data=bQ.data:sub(S+1)return bG else local bG=bQ.data:byte()bQ.data=bQ.data:sub(2)return bG end end,seek=function(bH,ah)if bH~=nil and type(bH)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(bH)..\")\",2)end;if ah~=nil and type(ah)~=\"number\"then error(\"bad argument #2 (expected number, got \"..type(ah)..\")\",2)end;if bE then error(\"attempt to use closed file\",2)end;return 0 end,close=function()if bE then error(\"attempt to use a closed file\",2)end;bE=true end}elseif P==\"wb\"or P==\"ab\"then local bN=bQ.data;return bM{write=function(bG)if bE then error(\"attempt to use a closed file\",2)end;if type(bG)==\"number\"then bN=bN..string.char(bG)elseif type(bG)==\"string\"then bN=bN..bG else error(\"bad argument #1 (expected string or number, got \"..type(bG)..\")\",2)end end,writeLine=function(bG)if bE then error(\"attempt to use a closed file\",2)end;if type(bG)==\"number\"then bN=bN..string.char(bG)..\"\\n\"elseif type(bG)==\"string\"then bN=bN..bG..\"\\n\"else error(\"bad argument #1 (expected string or number, got \"..type(bG)..\")\",2)end end,seek=function(bH,ah)if bH~=nil and type(bH)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(bH)..\")\",2)end;if ah~=nil and type(ah)~=\"number\"then error(\"bad argument #2 (expected number, got \"..type(ah)..\")\",2)end;if bE then error(\"attempt to use closed file\",2)end;return#bQ.data+#bN end,flush=function()if bE then error(\"attempt to use a closed file\",2)end;bQ.data=bN end,close=function()if bE then error(\"attempt to use a closed file\",2)end;bQ.data=bN;bE=true end}else return nil,\"Invalid mode\"end end;filesystem.openfifo=filesystem.fifohandle;do local H=fs.open(\"/meta.ltn\",\"r\")if H then filesystems.craftos.meta=unserialize(H.readAll())or filesystems.craftos.meta;filesystems.craftos.lastDispatch=os.epoch\"utc\"H.close()end end;shutdownHooks[#shutdownHooks+1]=function()syslog.log(\"Syncing filesystem\")local H=fs.open(filesystems.craftos.metapath,\"w\")if H then H.write(serialize(filesystems.craftos.meta,{compact=true}))H.close()end end;if args.fsmeta then local H=fs.open(args.fsmeta,\"r\")if H then local bR=unserialize(H.readAll())H.close()if bR then local function bS(bT,bU)for F,c in pairs(bT)do if bU[F]and type(bU[F])==\"table\"and type(c)==\"table\"then bS(c,bU[F])else bU[F]=c end end end;bS(bR,filesystems.craftos.meta)end end end;function filesystems.craftos:getmeta(bV,bs,bW)local A={}local X=self.meta;local bx=split(bs,\"/\\\\\")for o,a1 in ipairs(bx)do if a1==\"..\"then X=table.remove(A)if not X then return nil end elseif not a1:match\"^%.*$\"then if not X then return nil elseif X.meta.type~=\"directory\"then error(\"Not a directory\",2)elseif X.meta.permissions[bV]then if not X.meta.permissions[bV].execute then error(\"Permission denied\",2)end elseif not X.meta.worldPermissions.execute then error(\"Permission denied\",2)end;A[#A+1]=X;X=X.contents[a1]if X and X.meta.type==\"link\"and not bW then local bX=filesystem.combine(X.meta.link,table.unpack(bx,o+1))if fs.combine(bX)==fs.combine(bs)then error(\"Loop in link\",2)end;error{link=true,path=bX,orig=bs}end end end;return X and X.meta end;function filesystems.craftos:setmeta(bV,bs,bR,bW)local A={}local X=self.meta;local O;local bx=split(bs,\"/\\\\\")for o,a1 in ipairs(bx)do if a1==\"..\"then X=table.remove(A)if not X then error(\"Not a directory\",2)end elseif not a1:match\"^%.*$\"then if X.meta.type~=\"directory\"then error(\"Not a directory\",2)elseif X.meta.permissions[bV]then if not X.meta.permissions[bV].execute then error(\"Permission denied\",2)end elseif not X.meta.worldPermissions.execute then error(\"Permission denied\",2)end;if not X.contents[a1]then X.contents[a1]={meta={type=\"directory\",owner=X.meta.owner or\"root\",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}}end;A[#A+1]=X;X=X.contents[a1]O=a1;if X and X.meta.type==\"link\"and not bW then local bX=filesystem.combine(X.meta.link,table.unpack(bx,o+1))if fs.combine(bX)==fs.combine(bs)then error(\"Loop in link\",2)end;error{link=true,path=bX,orig=bs}end end end;if bR~=nil then X.meta={type=bR.type,owner=bR.owner,permissions=deepcopy(bR.permissions),worldPermissions=deepcopy(bR.worldPermissions),setuser=bR.setuser,link=bR.link}if bR.type~=\"directory\"then X.contents=nil end else A[#A].contents[O]=nil end;if os.epoch\"utc\"-self.lastDispatch>1000 then local H=assert(fs.open(self.metapath,\"w\"))H.write(serialize(self.meta,{compact=true}))H.close()self.lastDispatch=os.epoch\"utc\"end end;function filesystems.craftos:new(process,bs,bY)expect.field(bY,\"ro\",\"boolean\",\"nil\")if process.user~=\"root\"then error(\"Could not mount \"..bs..\": Permission denied\",3)elseif not fs.isDir(bs)then error(\"Could not mount \"..bs..\": No such directory\",3)end;return setmetatable({path=bs,readOnly=bY.ro},{__index=self})end;function filesystems.craftos:open(process,bs,P)local s,bZ=pcall(self.stat,self,process,bs)if not s then if type(bZ)==\"table\"then error(bZ)end;return nil,bZ elseif not bZ then if P:sub(1,1)==\"w\"or P:sub(1,1)==\"a\"then if self.readOnly then return nil,\"Read-only filesystem\"end;local b_,c0=pcall(self.stat,self,process,fs.getDir(bs))if not b_ or not c0 then if type(c0)==\"table\"then error(c0)end;local c1,n=pcall(self.mkdir,self,process,fs.getDir(bs))if not c1 then if type(n)==\"table\"then error(n)end;return nil,n:gsub(\"kernel:%d: \",\"\")end;c0=self:stat(process,fs.getDir(bs))if not c0 then return nil,\"Could not stat \"..fs.getDir(bs)end end;if process.user~=\"root\"then local c2=c0.permissions[process.user]or c0.worldPermissions;if not c2.write then return nil,\"Permission denied\"end end;local bR={type=\"file\",owner=process.user,permissions=deepcopy(c0.permissions),worldPermissions=deepcopy(c0.worldPermissions),setuser=false}if c0.owner then local X=bR.permissions[c0.owner]bR.permissions[c0.owner]=nil;bR.permissions[process.user]=X end;self:setmeta(process.user,fs.combine(self.path,bs),bR)local H,n=fs.open(fs.combine(self.path,bs),P)if not H then return H,n end;return setmetatable(H,{__name=\"file\"})else return nil,\"File not found\"end elseif bZ.type==\"directory\"then return nil,\"Is a directory\"end;local c2=bZ.permissions[process.user]or bZ.worldPermissions;if process.user~=\"root\"and(P:sub(1,1)==\"r\"and not c2.read or(P:sub(1,1)==\"w\"or P:sub(1,1)==\"a\")and not c2.write)then return nil,\"Permission denied\"end;if bZ.type==\"fifo\"then local bR=self:getmeta(process.user,fs.combine(self.path,bs))local c3=fifos[bR]if not c3 then c3={data=\"\"}fifos[bR]=c3 end;return filesystem.fifohandle(process,c3,P)end;local H,n=fs.open(fs.combine(self.path,bs),P)if not H then return nil,n end;return setmetatable(H,{__name=\"file\"})end;function filesystems.craftos:list(process,bs)local bZ=self:stat(process,bs)if not bZ or bZ.type~=\"directory\"then error(bs..\": Not a directory\",2)end;if process.user~=\"root\"then local c2=bZ.permissions[process.user]or bZ.worldPermissions;if not c2.read then error(bs..\": Permission denied\",2)end end;return fs.list(fs.combine(self.path,bs))end;function filesystems.craftos:stat(process,bs,bW)local a1=fs.combine(self.path,bs)if a1:find(self.path:gsub(\"^/\",\"\"):gsub(\"/$\",\"\"),1,false)~=1 then return nil end;local s,c4=pcall(fs.attributes,a1)if not s or not c4 then return nil end;c4.type=c4.isDir and\"directory\"or\"file\"c4.special={}c4.isDir=nil;if not c4.modified then c4.modified=c4.modification end;c4.modification=nil;c4.capacity=fs.getCapacity(a1)or 0;c4.freeSpace=fs.getFreeSpace(a1)local c5=c4.isReadOnly;c4.isReadOnly=nil;local bR=self:getmeta(process.user,fs.combine(self.path,bs),bW)if bR then c4.owner=bR.owner;c4.permissions=deepcopy(bR.permissions)c4.worldPermissions=deepcopy(bR.worldPermissions)c4.type=bR.type or c4.type;c4.setuser=bR.setuser;c4.link=bR.link else c4.owner=\"root\"c4.permissions={root={read=true,write=true,execute=true}}c4.worldPermissions={read=true,write=false,execute=true}c4.setuser=false end;if c5 then c4.worldPermissions.write=false;for k,c in pairs(c4.permissions)do c.write=false end end;return c4 end;function filesystems.craftos:remove(process,bs)if self.readOnly then error(bs..\": Read-only filesystem\",2)end;local bZ=self:stat(process,bs,true)if not bZ then return end;local function c6(a1)local bI=self:stat(process,a1,true)local c2=bI.permissions[process.user]or bI.worldPermissions;if process.user~=\"root\"and not c2.write then error(a1 ..\": Permission denied\",3)end;if bI.type==\"directory\"then if process.user~=\"root\"and not c2.read then error(a1 ..\": Permission denied\",3)end;for k,c in ipairs(fs.list(fs.combine(self.path,a1)))do c6(fs.combine(a1,c))end end end;c6(bs)fs.delete(fs.combine(self.path,bs))self:setmeta(process.user,fs.combine(self.path,bs),nil,true)end;function filesystems.craftos:rename(process,c7,c8)if self.readOnly then error(\"Read-only filesystem\",2)end;local c9=self:stat(process,c7,true)local ca=self:stat(process,c8,true)if not c9 then error(c7 ..\": No such file or directory\",2)elseif ca then error(c8 ..\": \"..ca.type:gsub(\"%w\",string.upper,1)..\" already exists\",2)end;ca=self:stat(process,fs.getDir(c8))if not ca then self:mkdir(process,fs.getDir(c8))ca=self:stat(process,fs.getDir(c8))end;if process.user~=\"root\"then local c2=ca.permissions[process.user]or ca.worldPermissions;if not c2.write then error(c8 ..\": Permission denied\",2)end end;fs.move(fs.combine(self.path,c7),fs.combine(self.path,c8))self:setmeta(process.user,fs.combine(self.path,c8),self:getmeta(process.user,fs.combine(self.path,c7),true),true)self:setmeta(process.user,fs.combine(self.path,c7),nil,true)end;function filesystems.craftos:mkdir(process,bs)if self.readOnly then error(bs..\": Read-only filesystem\",2)end;local bZ=self:stat(process,bs)if bZ then if bZ.type==\"directory\"then return else error(bs..\": File already exists\",2)end end;local bx=split(bs,\"/\\\\\")local o=#bx;repeat o=o-1;bZ=self:stat(process,table.concat(bx,\"/\",1,o))if bZ then if bZ.type==\"directory\"then break else error(bs..\": File already exists\",2)end end until bZ or o<=0;if not bZ then if bs:match\"^/\"then bZ=assert(self:stat(process,\"/\"))else bZ=assert(filesystem.stat(process,process.dir))end end;if process.user~=\"root\"then local c2=bZ.permissions[process.user]or bZ.worldPermissions;if not c2.write then error(bs..\": Permission denied\",2)end end;local bR={type=\"directory\",owner=process.user,permissions=deepcopy(bZ.permissions),worldPermissions=deepcopy(bZ.worldPermissions)}if bZ.owner then local X=bR.permissions[bZ.owner]bR.permissions[bZ.owner]=nil;bR.permissions[process.user]=X end;o=o+1;while o<=#bx do self:setmeta(process.user,fs.combine(self.path,table.concat(bx,\"/\",1,o)),deepcopy(bR))o=o+1 end;fs.makeDir(fs.combine(self.path,bs))end;function filesystems.craftos:link(process,bs,cb)local bZ=self:stat(process,bs,true)if bZ then error(bs..\": File exists\",2)end;self:setmeta(process.user,fs.combine(self.path,bs),nil,true)assert(self:open(process,bs,\"w\")).close()local bR=self:getmeta(process.user,fs.combine(self.path,bs),true)bR.type,bR.link=\"link\",cb;self:setmeta(process.user,fs.combine(self.path,bs),bR,true)end;function filesystems.craftos:mkfifo(process,bs)local bZ=self:stat(process,bs)if bZ then error(bs..\": File exists\",2)end;assert(self:open(process,bs,\"w\")).close()local bR=self:getmeta(process.user,fs.combine(self.path,bs),true)bR.type=\"fifo\"self:setmeta(process.user,fs.combine(self.path,bs),bR,true)end;function filesystems.craftos:chmod(process,bs,bV,P)if self.readOnly then error(bs..\": Read-only filesystem\",2)end;local bZ=self:stat(process,bs,true)if not bZ then error(bs..\": No such file or directory\",2)end;if not bZ.owner or process.user~=\"root\"and process.user~=bZ.owner then error(bs..\": Permission denied\",2)end;local c2;if bV==nil then c2=bZ.worldPermissions else c2=bZ.permissions[bV]if not c2 then c2=deepcopy(bZ.worldPermissions)bZ.permissions[bV]=c2 end end;if type(P)==\"string\"then if P:match\"^[%+%-=][rwxs]+$\"then local Y=P:sub(1,1)local X={}for G in P:gmatch(\"[rwxs]\")do if G==\"r\"then X.read=true elseif G==\"w\"then X.write=true elseif G==\"s\"then X.setuser=true else X.execute=true end end;if Y==\"+\"then if X.read then c2.read=true end;if X.write then c2.write=true end;if X.execute then c2.execute=true end;if X.setuser then bZ.setuser=true end elseif Y==\"-\"then if X.read then c2.read=false end;if X.write then c2.write=false end;if X.execute then c2.execute=false end;if X.setuser then bZ.setuser=false end else c2.read=X.read or false;c2.write=X.write or false;c2.execute=X.execute or false;bZ.setuser=X.setuser or false end else c2.read=P:sub(1,1)~=\"-\"c2.write=P:sub(2,2)~=\"-\"c2.execute=P:sub(3,3)~=\"-\"bZ.setuser=P:sub(3,3)==\"s\"end elseif type(P)==\"number\"then bZ.setuser=bit32.btest(P,8)c2.read=bit32.btest(P,4)c2.write=bit32.btest(P,2)c2.execute=bit32.btest(P,1)else if P.read~=nil then c2.read=P.read end;if P.write~=nil then c2.write=P.write end;if P.execute~=nil then c2.execute=P.execute end;if P.setuser~=nil then bZ.setuser=P.setuser end end;self:setmeta(process.user,fs.combine(self.path,bs),deepcopy(bZ),true)end;function filesystems.craftos:chown(process,bs,cc)if self.readOnly then error(bs..\": Read-only filesystem\",2)end;local bZ=self:stat(process,bs,true)if not bZ then error(bs..\": No such file or directory\",2)end;if not bZ.owner or process.user~=\"root\"and process.user~=bZ.owner then error(bs..\": Permission denied\",2)end;bZ.owner=cc;bZ.setuser=false;self:setmeta(process.user,fs.combine(self.path,bs),deepcopy(bZ),true)end;function filesystems.craftos:info()return\"craftos\",self.path,{ro=self.readOnly}end;function filesystems.tmpfs:getpath(bV,bs,bW)local X=self;local bx=split(bs,\"/\\\\\")for o,a1 in ipairs(bx)do if not X then return nil elseif X.type~=\"directory\"then error(\"Not a directory\",2)elseif X.permissions[bV]then if not X.permissions[bV].execute then error(\"Permission denied\",2)end elseif not X.worldPermissions.execute then error(\"Permission denied\",2)end;X=X.contents[a1]if X and X.type==\"link\"and not(bW and o==#bx)then error{link=true,path=filesystem.combine(X.link,table.unpack(bx,o+1)),orig=bs}end end;return X end;function filesystems.tmpfs:setpath(bV,bs,bz,bW)local X=self;local a7=split(bs,\"/\\\\\")local cd=a7[#a7]a7[#a7]=nil;for o,a1 in ipairs(a7)do if X.type~=\"directory\"then error(\"Not a directory\",2)elseif X.permissions[bV]then if not X.permissions[bV].execute then error(\"Permission denied\",2)end elseif not X.worldPermissions.execute then error(\"Permission denied\",2)end;if not X.contents[a1]then X.contents[a1]={type=\"directory\",owner=X.owner,permissions=deepcopy(X.permissions),worldPermissions=deepcopy(X.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\",contents={}}end;X=X.contents[a1]if X and X.type==\"link\"then error{link=true,path=filesystem.combine(X.link,table.unpack(a7,o+1)),orig=bs}end end;if X.type~=\"directory\"then error(\"Not a directory\",2)elseif bV~=\"root\"then if X.permissions[bV]then if not X.permissions[bV].execute then error(\"Permission denied\",2)end elseif not X.worldPermissions.execute then error(\"Permission denied\",2)end end;if not bW and X.contents[cd]and X.contents[cd].type==\"link\"then error{link=true,path=X.contents[cd].link,orig=bs}end;X.contents[cd]=bz end;function filesystems.tmpfs:new(process,bT,bY)return setmetatable({type=\"directory\",owner=process.user,permissions={[process.user]={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\",contents={}},{__index=self})end;function filesystems.tmpfs:_open_internal(process,bs,P)local ce=os.epoch;local bz=self:getpath(process.user,bs)if not bz then return nil,\"No such file\"end;if P==\"r\"or P==\"rb\"then return filesystem.readhandle(process,bz.data,P==\"rb\")elseif P==\"w\"or P==\"wb\"then bz.data=\"\"bz.modified=ce\"utc\"return filesystem.writehandle(process,function(bN,cf)if cf then bz.data=bN else bz.data=bz.data..bN end;bz.modified=ce\"utc\"if self.__flush then self:__flush()end end,P==\"wb\")elseif P==\"a\"or P==\"ab\"then local cg=bz.data;return filesystem.writehandle(process,function(bN,cf)if cf then bz.data=cg..bN else bz.data=bz.data..bN end;bz.modified=ce\"utc\"if self.__flush then self:__flush()end end,P==\"ab\")else return nil,\"Invalid mode\"end end;function filesystems.tmpfs:open(process,bs,P)if self.readOnly and(P:sub(1,1)==\"w\"or P:sub(1,1)==\"a\")then return nil,\"Read-only filesystem\"end;local s,bZ=pcall(self.stat,self,process,bs)if not s then if type(bZ)==\"table\"then error(bZ)end;return nil,bZ elseif not bZ then if P:sub(1,1)==\"w\"or P:sub(1,1)==\"a\"then local b_,c0=pcall(self.stat,self,process,fs.getDir(bs))if not b_ or not c0 then if type(c0)==\"table\"then error(c0)end;local c1,n=pcall(self.mkdir,self,process,fs.getDir(bs))if not c1 then if type(n)==\"table\"then error(n)end;return nil,n:gsub(\"kernel:%d: \",\"\")end;c0=self:stat(process,fs.getDir(bs))end;if process.user~=\"root\"then local c2=c0.permissions[process.user]or c0.worldPermissions;if not c2.write then return nil,\"Permission denied\"end end;local bR={type=\"file\",owner=process.user,permissions=deepcopy(c0.permissions),worldPermissions=deepcopy(c0.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\",data=\"\"}local X=bR.permissions[c0.owner]bR.permissions[c0.owner]=nil;bR.permissions[process.user]=X;self:setpath(process.user,bs,bR)return self:_open_internal(process,bs,P)else return nil,\"File not found\"end elseif bZ.type==\"directory\"then return nil,\"Is a directory\"end;if process.user~=\"root\"then local c2=bZ.permissions[process.user]or bZ.worldPermissions;if P:sub(1,1)==\"r\"and not c2.read or(P:sub(1,1)==\"w\"or P:sub(1,1)==\"a\")and not c2.write then return nil,\"Permission denied\"end end;if bZ.type==\"fifo\"then local bR=self:getpath(process.user,bs)local c3=fifos[bR]if not c3 then c3={data=\"\"}fifos[bR]=c3 end;return filesystem.fifohandle(process,c3,P)end;return self:_open_internal(process,bs,P)end;function filesystems.tmpfs:list(process,bs)local bz=self:getpath(process.user,bs)if not bz or bz.type~=\"directory\"then error(bs..\": Not a directory\",2)end;if process.user~=\"root\"then local c2=bz.permissions[process.user]or bz.worldPermissions;if not c2.read then error(bs..\": Permission denied\",2)end end;local as={}for F in pairs(bz.contents)do as[#as+1]=F end;table.sort(as)return as end;function filesystems.tmpfs:stat(process,bs,bW)local bz=self:getpath(process.user,bs,bW)if not bz then return nil end;return{size=bz.type==\"file\"and#bz.data or(bz.type==\"directory\"and#bz.contents or 0),type=bz.type,created=bz.created,modified=bz.modified,owner=bz.owner,permissions=deepcopy(bz.permissions),worldPermissions=deepcopy(bz.worldPermissions),setuser=bz.setuser,capacity=math.huge,freeSpace=math.huge,link=rawget(bz,\"link\"),special={}}end;function filesystems.tmpfs:remove(process,bs)if self.readOnly then error(\"Read-only filesystem\",2)end;local ch=self:getpath(process.user,fs.getDir(bs))local O=fs.getName(bs)if not ch or ch.type~=\"directory\"or not ch.contents[O]then return end;if process.user~=\"root\"and not(ch.permissions[process.user]or ch.worldPermissions).write then error(bs..\": Permission denied\",2)end;local bz=ch.contents[O]if process.user~=\"root\"and not(bz.permissions[process.user]or bz.worldPermissions).write then error(bs..\": Permission denied\",2)end;local function c6(bI)local c2=bI.permissions[process.user]or bI.worldPermissions;if process.user~=\"root\"and not c2.write then error(bs..\": Permission denied\",3)end;if bI.type==\"directory\"then if process.user~=\"root\"and not c2.read then error(bs..\": Permission denied\",3)end;for k,c in pairs(bI.contents)do c6(c)end end end;c6(bz)ch.contents[O]=nil;ch.modified=os.epoch\"utc\"end;function filesystems.tmpfs:rename(process,c7,c8)if self.readOnly then error(\"Read-only filesystem\",2)end;local ci=self:getpath(process.user,fs.getDir(c7))local cj=fs.getName(c7)if not ci or ci.type~=\"directory\"or not ci.contents[cj]then error(c7 ..\": No such file or directory\",2)end;if process.user~=\"root\"and not(ci.permissions[process.user]or ci.worldPermissions).write then error(c7 ..\": Permission denied\",2)end;local ck=ci.contents[cj]if process.user~=\"root\"and not(ck.permissions[process.user]or ck.worldPermissions).write then error(c7 ..\": Permission denied\",2)end;local cl=self:getpath(process.user,fs.getDir(c8))local cm=fs.getName(c8)if not cl or cl.type~=\"directory\"then error(c8 ..\": No such file or directory\",2)end;if process.user~=\"root\"and not(cl.permissions[process.user]or cl.worldPermissions).write then error(c8 ..\": Permission denied\",2)end;local cn=cl.contents[cm]if cn then error(c8 ..\": File already exists\",2)end;cl.contents[cm],ci.contents[cj]=ck,nil;local co=os.epoch\"utc\"ci.modified,cl.modified=co,co end;function filesystems.tmpfs:mkdir(process,bs)if self.readOnly then error(\"Read-only filesystem\",2)end;local X=self;for k,a1 in ipairs(split(bs,\"/\\\\\"))do local c2=X.permissions[process.user]or X.worldPermissions;if X.type~=\"directory\"then error(bs..\": File exists\",2)elseif process.user~=\"root\"and not c2.execute then error(bs..\": Permission denied\",2)end;if not X.contents[a1]then if process.user~=\"root\"and not c2.write then error(bs..\": Permission denied\",2)end;X.contents[a1]={type=\"directory\",owner=X.owner,permissions=deepcopy(X.permissions),worldPermissions=deepcopy(X.worldPermissions),created=os.epoch\"utc\",modified=os.epoch\"utc\",contents={}}X.modified=os.epoch\"utc\"end;X=X.contents[a1]end end;function filesystems.tmpfs:link(process,bs,cb)if self.readOnly then error(\"Read-only filesystem\",2)end;local bZ=self:stat(process,bs)if bZ then error(bs..\": File exists\",2)end;local b_,c0=pcall(self.stat,self,process,fs.getDir(bs))if not b_ or not c0 then if type(c0)==\"table\"then error(c0)end;local c1,n=pcall(self.mkdir,self,process,fs.getDir(bs))if not c1 then if type(n)==\"table\"then error(n)end;return nil,type(n)==\"string\"and n:gsub(\"kernel:%d: \",\"\")or n end;c0=self:stat(process,fs.getDir(bs))end;self:setpath(process.user,bs,{type=\"link\",owner=process.user,permissions=deepcopy(c0.permissions),worldPermissions=deepcopy(c0.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\",path=cb},true)end;function filesystems.tmpfs:mkfifo(process,bs)if self.readOnly then error(\"Read-only filesystem\",2)end;local bZ=self:stat(process,bs)if bZ then error(bs..\": File exists\",2)end;local b_,c0=pcall(self.stat,self,process,fs.getDir(bs))if not b_ or not c0 then if type(c0)==\"table\"then error(c0)end;local c1,n=pcall(self.mkdir,self,process,fs.getDir(bs))if not c1 then if type(n)==\"table\"then error(n)end;return nil,type(n)==\"string\"and n:gsub(\"kernel:%d: \",\"\")or n end;c0=self:stat(process,fs.getDir(bs))end;self:setpath(process.user,bs,{type=\"fifo\",owner=process.user,permissions=deepcopy(c0.permissions),worldPermissions=deepcopy(c0.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\"},true)end;function filesystems.tmpfs:chmod(process,bs,bV,P)if self.readOnly then error(\"Read-only filesystem\",2)end;local bZ=self:getpath(process.user,bs,true)if not bZ then error(bs..\": No such file or directory\",2)end;if not bZ.owner or process.user~=\"root\"and process.user~=bZ.owner then error(bs..\": Permission denied\",2)end;local c2;if bV==nil then c2=bZ.worldPermissions else c2=bZ.permissions[bV]if not c2 then c2=deepcopy(bZ.worldPermissions)bZ.permissions[bV]=c2 end end;if type(P)==\"string\"then if P:match\"^[%+%-=][rwxs]+$\"then local Y=P:sub(1,1)local X={}for G in P:gmatch(\"[rwxs]\")do if G==\"r\"then X.read=true elseif G==\"w\"then X.write=true elseif G==\"s\"then X.setuser=true else X.execute=true end end;if Y==\"+\"then if X.read then c2.read=true end;if X.write then c2.write=true end;if X.execute then c2.execute=true end;if X.setuser then bZ.setuser=true end elseif Y==\"-\"then if X.read then c2.read=false end;if X.write then c2.write=false end;if X.execute then c2.execute=false end;if X.setuser then bZ.setuser=false end else c2.read=X.read or false;c2.write=X.write or false;c2.execute=X.execute or false;bZ.setuser=X.setuser or false end else c2.read=P:sub(1,1)~=\"-\"c2.write=P:sub(2,2)~=\"-\"c2.execute=P:sub(3,3)~=\"-\"bZ.setuser=P:sub(3,3)==\"s\"end elseif type(P)==\"number\"then bZ.setuser=bit32.btest(P,8)c2.read=bit32.btest(P,4)c2.write=bit32.btest(P,2)c2.execute=bit32.btest(P,1)else if P.read~=nil then c2.read=P.read end;if P.write~=nil then c2.write=P.write end;if P.execute~=nil then c2.execute=P.execute end;if P.setuser~=nil then bZ.setuser=P.setuser end end end;function filesystems.tmpfs:chown(process,bs,cc)if self.readOnly then error(\"Read-only filesystem\",2)end;local bZ=self:getpath(process.user,bs,true)if not bZ then error(bs..\": No such file or directory\",2)end;if not bZ.owner or process.user~=\"root\"and process.user~=bZ.owner then error(bs..\": Permission denied\",2)end;bZ.owner=cc;bZ.setuser=false end;function filesystems.tmpfs:info()return\"tmpfs\",\"memory\",{ro=self.readOnly}end;setmetatable(filesystems.drivefs,{__index=filesystems.craftos})function filesystems.drivefs:stat(process,bs)local E,n=filesystems.craftos.stat(self,process,bs)if bs==\"\"and E==nil then return{size=0,type=\"directory\",created=0,modified=0,owner=self.owner,capacity=0,freeSpace=0,permissions={[self.owner]={read=false,write=true,execute=false}},worldPermissions={read=false,write=false,execute=false},setuser=false}end;return E,n end;function filesystems.drivefs:new(process,bT,bY)local cp=hardware.get(bT)if not cp then error(\"Could not find drive at \"..bT)end;local bs=hardware.call(process,cp,\"getMountPath\")local fs=filesystems.craftos:new(process,bs,bY)fs.drive=cp.uuid;fs.owner=process.user;fs.meta={meta={type=\"directory\",owner=\"root\",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}}fs.metapath=fs.combine(bs,\".meta.ltn\")local H=fs.open(fs.metapath,\"r\")if H then fs.meta=unserialize(H.readAll())or fs.meta;H.close()end;return setmetatable(fs,{__index=self})end;function filesystems.drivefs:info()return\"drivefs\",self.drive,{ro=self.readOnly}end;setmetatable(filesystems.tablefs,{__index=filesystems.tmpfs})function filesystems.tablefs:new(process,bT,bY)local X;local H,n;if process~=KERNEL and mounts[\"\"]then H,n=filesystem.open(process,bT,\"r\")else H,n=fs.open(bT,\"r\")end;if H then local bz=H.readAll()or\"\"H.close()local s,E=pcall(unserialize,bz)if not s then error(\"Could not mount \"..bT..\": \"..E,3)elseif type(E)~=\"table\"or E.type~=\"directory\"or type(E.contents)~=\"table\"then error(\"Could not mount \"..bT..\": Invalid table file\",3)end;X=E else if not(bY.rw and not bY.ro)then error(\"Could not mount \"..bT..\": \"..n,3)end;X={type=\"directory\",owner=process.user,permissions={[process.user]={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\",contents={}}end;X.src=bT;X.readOnly=bY.ro;if bY.rw and not bY.ro then function X:__flush()local f,bI=self.__flush,self.src;self.__flush,self.src=nil;local s,E=pcall(serialize,self)self.__flush,self.src=f,bI;if not s then error(E)end;local H,n=filesystem.open(process,bT,\"w\")if not H then syslog.log({level=4},\"Could not save mount to \"..bT..\": \"..n)return end;H.write(E)H.close()end end;return setmetatable(X,{__index=self})end;function filesystems.tablefs:info()return\"tablefs\",self.src,{rw=self.__flush~=nil,ro=self.readOnly}end;function filesystems.bind:new(process,bs,bY)local bZ,n=filesystem.stat(process,bs)if not bZ then error(\"Could not bind \"..bs..\": \"..n,3)elseif bZ.type~=\"directory\"then error(\"Could not bind \"..bs..\": Not a directory\",3)end;return setmetatable({path=bs},{__index=self})end;function filesystems.bind:open(process,bs,P)return filesystem.open(process,fs.combine(self.path,bs),P)end;function filesystems.bind:list(process,bs)return filesystem.list(process,fs.combine(self.path,bs))end;function filesystems.bind:stat(process,bs,bW)return filesystem.stat(process,fs.combine(self.path,bs),bW)end;function filesystems.bind:remove(process,bs)return filesystem.remove(process,fs.combine(self.path,bs))end;function filesystems.bind:rename(process,c7,c8)return filesystem.rename(process,fs.combine(self.path,c7),fs.combine(self.path,c8))end;function filesystems.bind:mkdir(process,bs)return filesystem.mkdir(process,fs.combine(self.path,bs))end;function filesystems.bind:link(process,bs,cb)return filesystem.link(process,fs.combine(self.path,bs),cb)end;function filesystems.bind:mkfifo(process,bs)return filesystem.mkfifo(process,fs.combine(self.path,bs))end;function filesystems.bind:chmod(process,bs,bV,P)return filesystem.chmod(process,fs.combine(self.path,bs),bV,P)end;function filesystems.bind:chown(process,bs,cc)return filesystem.chown(process,fs.combine(self.path,bs),cc)end;function filesystems.bind:info()return\"bind\",self.path,{}end;local function cq(process,bs,cr,cs)local ct=br(process,bs)if cs then if ct==\"\"then ct=nil else ct=fs.getDir(ct)end end;if ct and fsevents[ct]then for k,c in pairs(fsevents[ct])do local cu=ct;if cu:find(c.root,1,true)==1 then cu=cu:sub(#c.root+1)end;c.eventQueue[#c.eventQueue+1]={\"fsevent\",{path=cu,event=cr,name=cs and fs.getName(ct)or nil,process=process.id}}wakeup(c)end end end;function filesystem.open(process,bs,P)expect(0,process,\"table\")expect(1,bs,\"string\")expect(2,P,\"string\")if not P:match\"^[rwa]b?$\"then error(\"Invalid mode\",0)end;for k=1,1000 do local s,by,a1=pcall(bt,process,bs)if not s then return nil,by end;local E=table.pack(pcall(by.open,by,process,a1,P))if E[1]then if E[2]and P~=\"r\"and P~=\"rb\"then cq(process,bs,\"open\",false)cq(process,bs,\"open_child\",true)end;return table.unpack(E,2,E.n)elseif type(E[2])~=\"table\"or type(E[2].path)~=\"string\"then error(E[2],2)end;bs=E[2].path end;error(\"Too many levels of symbolic links\",2)end;local function cv(process,bs,cw)local as={}local mounts,a1=bt(process,bs,true)for k,by in ipairs(mounts)do local s,E=pcall(by.list,by,process,a1)if not s then if type(E)~=\"table\"or type(E.path)~=\"string\"then if#mounts==1 and cw then error(E,2)else E={}end else E=cv(process,E.path,false)end end;for k,c in ipairs(E)do as[#as+1]=c end end;return as end;function filesystem.list(process,bs)expect(0,process,\"table\")expect(1,bs,\"string\")local as=cv(process,bs,true)table.sort(as)local o=2;while o<=#as do if as[o]==as[o-1]then table.remove(as,o)else o=o+1 end end;return as end;function filesystem.stat(process,bs,bW)expect(0,process,\"table\")expect(1,bs,\"string\")for k=1,1000 do local s,by,a1,cx=pcall(bt,process,bs)if not s then return nil,by end;local cy,E,n=pcall(by.stat,by,process,a1,bW)if cy then if E then E.mountpoint=\"/\"..cx end;return E,n elseif type(E)~=\"table\"or type(E.path)~=\"string\"then error(E,2)end;bs=E.path end;error(\"Too many levels of symbolic links\",2)end;function filesystem.remove(process,bs)expect(0,process,\"table\")expect(1,bs,\"string\")for k=1,1000 do local by,a1=bt(process,bs)local s,E=pcall(by.remove,by,process,a1)if s then cq(process,bs,\"remove\",false)cq(process,bs,\"remove_child\",true)return elseif type(E)~=\"table\"or type(E.path)~=\"string\"then error(E,2)end;bs=E.path end;error(\"Too many levels of symbolic links\",2)end;function filesystem.rename(process,c7,c8)expect(0,process,\"table\")expect(1,c7,\"string\")expect(2,c8,\"string\")for k=1,1000 do local cz,cA=bt(process,c7)local cB,cC=bt(process,c8)if cz~=cB then error(\"Attempt to rename file across two filesystems\",0)end;local s,E=pcall(cz.rename,cz,process,cA,cC)if s then cq(process,c7,\"rename_from\",false)cq(process,c7,\"rename_from_child\",true)cq(process,c8,\"rename_to\",false)cq(process,c8,\"rename_to_child\",true)return elseif type(E)~=\"table\"or type(E.path)~=\"string\"then error(E,2)end;if E.orig==c7 then c7=E.path else c8=E.path end end;error(\"Too many levels of symbolic links\",2)end;function filesystem.mkdir(process,bs)expect(0,process,\"table\")expect(1,bs,\"string\")for k=1,1000 do local by,a1=bt(process,bs)local s,E=pcall(by.mkdir,by,process,a1)if s then cq(process,bs,\"mkdir\",false)cq(process,bs,\"mkdir_child\",true)return elseif type(E)~=\"table\"or type(E.path)~=\"string\"then error(E,2)end;bs=E.path end;error(\"Too many levels of symbolic links\",2)end;function filesystem.link(process,bs,cb)expect(0,process,\"table\")expect(1,bs,\"string\")expect(2,cb,\"string\")if fs.combine(bs)==fs.combine(cb)then error(\"Cannot link file to itself\",2)end;syslog.debug(\"Creating link\",bs,\" => \",cb)for k=1,1000 do local by,a1=bt(process,bs)if not by.link then error(\"Filesystem does not support links\",2)end;local s,E=pcall(by.link,by,process,a1,cb)if s then cq(process,bs,\"link\",false)cq(process,bs,\"link_child\",true)return elseif type(E)~=\"table\"or type(E.path)~=\"string\"then error(E,2)end;bs=E.path end;error(\"Too many levels of symbolic links\",2)end;function filesystem.mkfifo(process,bs)expect(0,process,\"table\")expect(1,bs,\"string\")for k=1,1000 do local by,a1=bt(process,bs)if not by.mkfifo then error(\"Filesystem does not support FIFOs\",2)end;local s,E=pcall(by.mkfifo,by,process,a1)if s then cq(process,bs,\"mkfifo\",false)cq(process,bs,\"mkfifo_child\",true)return elseif type(E)~=\"table\"or type(E.path)~=\"string\"then error(E,2)end;bs=E.path end;error(\"Too many levels of symbolic links\",2)end;function filesystem.chmod(process,bs,bV,P)expect(0,process,\"table\")expect(1,bs,\"string\")expect(2,bV,\"string\",\"nil\")expect(3,P,\"number\",\"string\",\"table\")if type(P)==\"string\"and not P:match\"^[%+%-=][rwxs]+$\"and not P:match\"^[r%-][w%-][xs%-]$\"then error(\"bad argument #3 (invalid mode)\",2)elseif type(P)==\"table\"then expect.field(P,\"read\",\"boolean\",\"nil\")expect.field(P,\"write\",\"boolean\",\"nil\")expect.field(P,\"execute\",\"boolean\",\"nil\")end;for k=1,1000 do local by,a1=bt(process,bs)local s,E=pcall(by.chmod,by,process,a1,bV,P)if s then return elseif type(E)~=\"table\"or type(E.path)~=\"string\"then error(E,2)end;bs=E.path end;error(\"Too many levels of symbolic links\",2)end;function filesystem.chown(process,bs,bV)expect(0,process,\"table\")expect(1,bs,\"string\")expect(2,bV,\"string\")for k=1,1000 do local by,a1=bt(process,bs)local s,E=pcall(by.chown,by,process,a1,bV)if s then return elseif type(E)~=\"table\"or type(E.path)~=\"string\"then error(E,2)end;bs=E.path end;error(\"Too many levels of symbolic links\",2)end;function filesystem.chroot(process,bs)expect(0,process,\"table\")expect(1,bs,\"string\")if process.user~=\"root\"then error(\"Could not change root: Permission denied\",2)end;local cD=\"/\"..fs.combine(process.root,bs)..\"/\"if cD==\"//\"then cD=\"/\"end;if cD:find(process.root,1,true)~=1 then error(\"Could not change root: No such file or directory\",2)end;local bI=filesystem.stat(process,\"/\"..bs)if not bI then error(bs..\": No such directory\",2)end;if bI.type~=\"directory\"then error(bs..\": Not a directory\",2)end;process.root=cD end;function filesystem.mount(process,type,bT,bU,bY)expect(0,process,\"table\")expect(1,type,\"string\")expect(2,bT,\"string\")expect(3,bU,\"string\")expect(4,bY,\"table\",\"nil\")if not filesystems[type]then error(\"No such filesystem '\"..type..\"'\",2)end;local a1=br(process,bU)if a1==\"\"then if process.user~=\"root\"then error(\"Could not mount to \"..bU..\": Permission denied\",2)end;if mounts[a1]and not(bY and bY.overlay)then error(\"Could not mount to \"..bU..\": Mount already exists (use overlay to mount over)\")end;if not mounts[a1]and(bY and bY.overlay)then error(\"Could not mount to \"..bU..\": No base mount exists for overlay\")end else local bZ=filesystem.stat(process,bU)if not bZ then error(\"Could not mount to \"..bU..\": No such directory\",2)end;if bZ.type~=\"directory\"then error(\"Could not mount to \"..bU..\": Not a directory\",2)end;if process.user~=\"root\"and not(bZ.permissions[process.user]or bZ.worldPermissions).write then error(\"Could not mount to \"..bU..\": Permission denied\",2)end;if mounts[a1]and not(bY and bY.overlay)then error(\"Could not mount to \"..bU..\": Mount already exists (use overlay to mount over)\")end;if not mounts[a1]and(bY and bY.overlay)then error(\"Could not mount to \"..bU..\": No base mount exists for overlay\")end end;local by=filesystems[type]:new(process,bT,bY or{})if bY and bY.overlay then mounts[a1][#mounts[a1]+1]=by else mounts[a1]={by}end end;function filesystem.unmount(process,bs)expect(0,process,\"table\")expect(1,bs,\"string\")bs=br(process,bs)if not mounts[bs]then error(bs..\": No such mount\",2)end;local cd=#mounts[bs]local bZ=mounts[bs][cd]:stat(process,\"\")if not bZ then error(\"Internal error in unmount: could not get stat for root! Please report this to the maintainer of the target filesystem.\",2)elseif process.user~=\"root\"and not(bZ.permissions[process.user]or bZ.worldPermissions).write then error(bs..\": Permission denied\",2)end;if mounts[bs][cd].unmount then mounts[bs][cd]:unmount(process)end;mounts[bs][cd]=nil;if cd==1 then mounts[bs]=nil end end;function filesystem.mountlist(process)expect(0,process,\"table\")local as={}for F,c in pairs(mounts)do if\"/\"..F..\"/\"==process.root or F:find(process.root:sub(2),1,true)==1 then for k,by in ipairs(c)do local type,bs,bY=by:info()as[#as+1]={path=\"/\"..F,type=type,source=bs,options=bY}end end end;return as end;function filesystem.combine(cE,...)expect(1,cE,\"string\")local t=fs.combine(cE,...)if cE:match\"^/\"then t=\"/\"..t end;return t end;function syscalls.open(process,aN,...)return filesystem.open(process,...)end;function syscalls.list(process,aN,...)return filesystem.list(process,...)end;function syscalls.stat(process,aN,...)return filesystem.stat(process,...)end;function syscalls.remove(process,aN,...)return filesystem.remove(process,...)end;function syscalls.rename(process,aN,...)return filesystem.rename(process,...)end;function syscalls.mkdir(process,aN,...)return filesystem.mkdir(process,...)end;function syscalls.link(process,aN,...)return filesystem.link(process,...)end;function syscalls.mkfifo(process,aN,...)return filesystem.mkfifo(process,...)end;function syscalls.chmod(process,aN,...)return filesystem.chmod(process,...)end;function syscalls.chown(process,aN,...)return filesystem.chown(process,...)end;function syscalls.chroot(process,aN,...)return filesystem.chroot(process,...)end;function syscalls.mount(process,aN,...)return filesystem.mount(process,...)end;function syscalls.unmount(process,aN,...)return filesystem.unmount(process,...)end;function syscalls.mountlist(process,aN,...)return filesystem.mountlist(process,...)end;function syscalls.combine(process,aN,...)return filesystem.combine(...)end;function syscalls.loadCraftOSAPI(process,aN,cF)expect(1,cF,\"string\")local I;I=setmetatable({dofile=function(bs)local H,n=fs.open(bs,\"rb\")if not H then error(\"Could not open module: \"..n,0)end;local J,n=load(H.readAll(),\"@\"..bs,nil,I)H.close()if not J then error(\"Could not load module: \"..n,0)end;return J()end,require=function(O)return I.dofile(\"rom/modules/main/\"..O:gsub(\"%.\",\"/\")..\".lua\")end},{__index=process.env})I._ENV=I;if cF:sub(1,3)==\"cc.\"then local bs=fs.combine(\"rom/modules/main\",cF:gsub(\"%.\",\"/\")..\".lua\")if not bs:match\"^/?rom/modules/main/\"then error(\"Invalid module path\",0)end;return I.dofile(bs)else if not cF:match\"^[a-z]+$\"then error(\"Invalid API name\",0)end;local bs=fs.combine(\"rom/apis\",cF..\".lua\")local H,n=fs.open(bs,\"rb\")if not H then error(\"Could not open module: \"..n,0)end;local J,n=load(H.readAll(),\"@\"..bs,nil,I)H.close()if not J then error(\"Could not load module: \"..n,0)end;J()local X={}for F,c in pairs(I)do if F~=\"dofile\"and F~=\"require\"and F~=\"_ENV\"then X[F]=c end end;return X end end;function syscalls.fsevent(process,aN,bs,cG)expect(1,bs,\"string\")expect(2,cG,\"boolean\",\"nil\")if cG==nil then cG=true end;bs=br(process,bs)syslog.debug(\"Registering fsevents for\",bs)fsevents[bs]=fsevents[bs]or setmetatable({},{__mode=\"v\"})fsevents[bs][#fsevents[bs]+1]=cG and process or nil end;xpcall(function()if args.initrd then if args.initrd:match\"^_G%..\"then local cw=_G[args.initrd:match\"^_G%.(.+)\"]if type(cw)~=\"table\"then error(\"Requested root filesystem in global '\"..args.initrd..\"' is not a table\")end;cw.src=args.initrd;mounts[\"\"]={setmetatable(cw,{__index=filesystems.tablefs})}else mounts[\"\"]={filesystems.tablefs:new(KERNEL,args.initrd,{})}end else local bY={}if args.rootflags then for Y in args.rootflags:gmatch\"[^,]+\"do local F,c=Y:match(\"^([^=]+)=(.*)$\")if F and c then if c==\"true\"then bY[F]=true elseif c==\"false\"then bY[F]=false else bY[F]=tonumber(c)or c end else bY[Y]=true end end end;mounts[\"\"]={filesystems[args.rootfstype]:new(KERNEL,args.root,bY)}end end,panic)local do_syscall=do_syscall;local expect=expect;local function cH(cI,cJ,cK,cL)local cM={bit32.extract(cJ,0,16),bit32.extract(cJ,16,16),bit32.extract(cI,0,16),bit32.extract(cI,16,16)}local ax={bit32.extract(cL,0,16),bit32.extract(cL,16,16),bit32.extract(cK,0,16),bit32.extract(cK,16,16)}local bO={{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0}}for cN=1,4 do for cO=1,4 do local S=cM[cO]*ax[cN]+bO[cN][cO]bO[cN][cO+1],bO[cN][cO]=bit32.rshift(S,16),bit32.band(S,0xFFFF)end end;local cP={0,0,0,0,0,0,0,0}for cQ=1,8 do for cR=1,4 do cP[cQ]=cP[cQ]+(bO[cR][cQ-cR+1]or 0)end;cP[cQ+1],cP[cQ]=bit32.rshift(cP[cQ],16),bit32.band(cP[cQ],0xFFFF)end;return cP[3]+cP[4]*0x10000,cP[1]+cP[2]*0x10000 end;local function cS(ax,cI,cJ)return cI+math.floor((cJ+ax)/0x100000000),bit32.band(cJ+ax,0xFFFFFFFF)end;function makeRandom()local cT,cU=0,0;local function next(cV)cT,cU=cS(0xB,cH(cT,cU,0x5,0xDEECE66D))cT=bit32.band(cT,0xFFFF)return math.floor(cT/2^(16-cV))+math.floor(cU/2^(48-cV))end;local function cW(v,w)expect(1,v,\"number\",\"nil\")expect(2,w,\"number\",\"nil\")if v then expect.range(v,0,0x7FFFFFFF)if not w then v,w=0,v else expect.range(w,0,0x7FFFFFFF)end;local cX=w-v+1;local cY;if math.log(cX,2)%1==0 then cY=math.floor(cX*next(31)/0x80000000)else local cV;repeat cV=next(31)cY=cV%cX until cV-cY+cX-1>=0 end;return cY+v else return(next(26)*0x8000000+next(27))/0x20000000000000 end end;local function cZ(c_)expect(1,c_,\"number\")cT,cU=bit32.band(bit32.bxor(0x5,math.floor(c_/0x100000000)),0xFFFF),bit32.bxor(0xDEECE66D,math.floor(c_))end;cZ(os.epoch\"utc\"*tonumber(tostring(next):match(\"%x+\")or\"1\",16))return cW,cZ end;do math.random,math.randomseed=makeRandom()end;function createLuaLib(process)local d0={}for k,c in ipairs{\"assert\",\"error\",\"getmetatable\",\"ipairs\",\"next\",\"pairs\",\"pcall\",\"rawequal\",\"rawget\",\"rawset\",\"select\",\"setmetatable\",\"tonumber\",\"tostring\",\"type\",\"_VERSION\",\"xpcall\",\"collectgarbage\"}do d0[c]=_G[c]end;function d0.dofile(bs)if bs~=nil and type(bs)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(bs)..\")\",2)end;local J,n=loadfile(bs or io.stdin:read(\"*a\"))if not J then error(n,2)end;return J()end;do local load,getfenv,setfenv,make_ENV=load,getfenv,setfenv,make_ENV;if _VERSION==\"Lua 5.1\"then function d0.load(N,O,P,I)return load(N,O,P,make_ENV(I or process.env))end;function d0.getfenv(f)local c;if f==nil then c=getfenv(2)elseif tonumber(f)and tonumber(f)>0 then c=getfenv(f+1)elseif type(f)==\"function\"then c=getfenv(f)else c=getfenv(f)end;local j=getmetatable(f)if j and j.__env then return j.__env else return c end end;function d0.setfenv(f,a7)return setfenv(f,make_ENV(a7))end else d0.load,d0.getfenv,d0.setfenv=function(N,O,P,I)return load(N,O,P,I or process.env)end,getfenv,setfenv end end;function d0.loadfile(bs,P,I)if I==nil and type(P)==\"table\"then I,P=P,nil end;if bs==nil then bs=io.stdin:read(\"*a\")end;if type(bs)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(bs)..\")\",2)end;if P~=nil and type(P)~=\"string\"then error(\"bad argument #2 (expected string, got \"..type(P)..\")\",2)end;if I~=nil and type(I)~=\"table\"then error(\"bad argument #3 (expected table, got \"..type(I)..\")\",2)end;local H,n=do_syscall(\"open\",bs,\"rb\")if not H then error(n,2)end;local bz=H.readAll()H.close()return load(bz,\"@\"..bs,P,I)end;function d0.print(...)local args=table.pack(...)if args.n==0 then args={\"\",n=1}end;args[args.n]=tostring(args[args.n])..\"\\n\"return do_syscall(\"write\",table.unpack(args,1,args.n))end;d0.coroutine=deepcopy(coroutine)d0.string=deepcopy(string)d0.table=deepcopy(table)d0.math=deepcopy(math)d0.bit32=deepcopy(bit32)d0.utf8=deepcopy(utf8)d0.math.random,d0.math.randomseed=makeRandom()local d1=\"\"local d2=setmetatable({close=function()end,lines=function(self,...)local args=table.pack(...)return function()return self:read(table.unpack(args,1,args.n))end end,read=function(self,at,...)local bI,a7;at=at or\"*l\"if type(at)==\"number\"then while#d1<at do d1=d1 ..do_syscall(\"read\",at)end elseif type(at)==\"string\"then at=at:gsub(\"^%*\",\"\")if at==\"n\"then while not d1:find(\"%d\")do local bJ=do_syscall(\"readline\")if bJ==nil then break end;d1=d1 ..bJ..\"\\n\"end elseif at==\"a\"then while true do local bJ=do_syscall(\"readline\")if bJ==nil then break end;d1=d1 ..bJ..\"\\n\"end elseif at==\"l\"or at==\"L\"then local bJ=do_syscall(\"readline\")if bJ==nil then return nil end;d1=d1 ..bJ..\"\\n\"else error(\"bad argument (invalid format '\"..at..\"')\",2)end else error(\"bad argument (expected string or number, got \"..type(at),2)end;if type(at)==\"number\"then bI,a7=d1:sub(1,at),at+1 elseif at==\"n\"then bI,a7=d1:match(\"(%d)()\")elseif at==\"a\"then bI,a7=d1,#d1+1 elseif at==\"l\"then bI,a7=d1:match(\"(.*)\\n()\")else bI,a7=d1:match(\"(.*\\n)()\")end;if not bI then return nil end;d1=d1:sub(a7)if select(\"#\",...)>0 then return bI,self:read(...)else return bI end end,seek=function()return nil,\"Cannot seek default file\"end,setvbuf=function()end},{__name=\"FILE*\"})local d3=setmetatable({close=function()end,flush=function()end,seek=function()return nil,\"Cannot seek default file\"end,setvbuf=function()end,write=function(self,...)do_syscall(\"write\",...)return self end},{__name=\"FILE*\"})local d4=setmetatable({close=function()end,flush=function()end,seek=function()return nil,\"Cannot seek default file\"end,setvbuf=function()end,write=function(self,...)do_syscall(\"writeerr\",...)return self end},{__name=\"FILE*\"})local d5,d6=d2,d3;local d7={close=function(self)self._file.close()self._closed=true end,lines=function(self,...)local args=table.pack(...)return function()return self:read(table.unpack(args,1,args.n))end end,read=function(self,at,...)local c;if at==nil then at=\"l\"end;if type(at)==\"number\"then c=self._file.read(at)elseif type(at)==\"string\"then at=at:gsub(\"^%*\",\"\")if at==\"a\"then c=self._file.readAll()elseif at==\"l\"then c=self._file.readLine(false)elseif at==\"L\"then c=self._file.readLine(true)elseif at==\"n\"then local bI,G=\"\"repeat G=self._file.read(1)until G:match(\"%d\")while G:match(\"%d\")do bI,G=bI..G,self._file.read(1)end;c=tonumber(bI)else error(\"bad argument (invalid format '\"..at..\"')\",2)end else error(\"bad argument (expected string or number, got \"..type(at)..\")\",2)end;if select(\"#\",...)>0 then return c,self:read(...)else return c end end,seek=function(self,bH,ah)if self._file.seek then return self._file.seek(bH,ah)else return nil,\"Cannot seek text file\"end end,setvbuf=function()end}local d8={close=function(self)self._file.close()self._closed=true end,flush=function(self)self._file:flush()end,seek=function(self,bH,ah)if self._file.seek then return self._file.seek(bH,ah)else return nil,\"Cannot seek text file\"end end,setvbuf=function()end,write=function(self,...)self._file.write(...)return self end}for k,c in ipairs{d2,d3,d4,d7,d8}do for k,f in pairs(c)do local s,I=pcall(getfenv,f)if s and I then setfenv(f,d0)debug.protect(f)end end end;d0.io={close=function(H)if H==nil then d6:close()elseif type(H)==\"table\"and getmetatable(H)and getmetatable(H).__name==\"FILE*\"then H:close()else error(\"bad argument #1 (expected FILE*, got \"..type(H)..\")\",2)end end,flush=function()return d6:flush()end,input=function(H)if H==nil then return d5 elseif type(H)==\"string\"then local aC,n=io.open(H,\"r\")if not aC then error(n,2)end;d5=aC elseif type(H)==\"table\"and getmetatable(H)and getmetatable(H).__name==\"FILE*\"then d5=H else error(\"bad argument #1 (expected string or FILE*, got \"..type(H)..\")\",2)end end,lines=function(d9,...)if d9==nil then return d5:lines(...)end;if type(d9)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(d9)..\")\",2)end;local aC,n=io.open(d9,\"r\")if not aC then error(n,2)end;local J=aC:lines(...)return function(...)local as=table.pack(J(...))if as.n==0 or as[1]==nil then aC:close()end;return table.unpack(as,1,as.n)end end,open=function(d9,P)if type(d9)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(d9)..\")\",2)end;if P==nil then P=\"r\"end;if type(P)~=\"string\"then error(\"bad argument #2 (expected string, got \"..type(P)..\")\",2)end;local H,n=do_syscall(\"open\",d9,P)if not H then return nil,n elseif P:find(\"r\")then return setmetatable({_file=H},{__index=d7,__name=\"FILE*\"})else return setmetatable({_file=H},{__index=d8,__name=\"FILE*\"})end end,output=function(H)if H==nil then return d6 elseif type(H)==\"string\"then local aC,n=io.open(H,\"w\")if not aC then error(n,2)end;d6=aC elseif type(H)==\"table\"and getmetatable(H)and getmetatable(H).__name==\"FILE*\"then d6=H else error(\"bad argument #1 (expected string or FILE*, got \"..type(H)..\")\",2)end end,popen=function(bs,P)expect(1,bs,\"string\")P=expect(2,P,\"string\",\"nil\")or\"r\"if P~=\"r\"and P~=\"w\"and P~=\"rw\"then error(\"bad argument #2 (invalid mode)\",2)end;if P==\"rw\"then local da,db=\"\",\"\"local dc;local dd={read=function(S)if da==\"\"then return nil elseif S then local bI=da:sub(1,S)da=da:sub(S+1)return bI else local bI,a7=da:match\"([^\\n]*\\n?)()\"da=da:sub(a7)return bI end end}local de={write=function(bI)da=da..bI end,flush=function()end,close=function()local info=do_syscall(\"getpinfo\",dc)if not info then return end;repeat local aO,df=coroutine.yield()until aO==\"process_complete\"and df.pid==dc end}local dg={read=function(S)if db==\"\"then return nil elseif S then local bI=db:sub(1,S)db=db:sub(S+1)return bI else local bI=db:byte()db=db:sub(2)return bI end end,readLine=function()if db==\"\"then return nil end;local bI,a7=db:match\"([^\\n]*)\\n*()\"db=db:sub(a7)return bI end,readAll=function()if db==\"\"then return nil end;local bI=db;db=\"\"return bI end,close=function()local info=do_syscall(\"getpinfo\",dc)if not info then return end;repeat local aO,df=coroutine.yield()until aO==\"process_complete\"and df.pid==dc end}local dh={write=function(bI)db=db..bI end}dc=do_syscall(\"fork\",function()do_syscall(\"stdin\",dd)do_syscall(\"stdout\",dh)do_syscall(\"exec\",\"/bin/sh\",\"-c\",bs)end)return setmetatable({_file=dg},{__index=d7,__name=\"FILE*\"}),setmetatable({_file=de},{__index=d8,__name=\"FILE*\"})else local di=\"\"local bE=false;local dc;local dj={read=function(S)if di==\"\"then if bE then return nil else return\"\"end elseif S then local bI=di:sub(1,S)di=di:sub(S+1)return bI else local bI,a7=di:match\"([^\\n]*\\n?)()\"di=di:sub(a7)return bI end end,readLine=function()local bI,a7=di:match\"([^\\n]*\\n?)()\"di=di:sub(a7)return bI end,readAll=function()local bI=di;di=\"\"return bI end,close=function()bE=true;local info=do_syscall(\"getpinfo\",dc)if not info then return end;repeat local aO,df=coroutine.yield()until aO==\"process_complete\"and df.pid==dc end}local dk={write=function(bI)di=di..bI end,flush=function()end,close=function()bE=true;local info=do_syscall(\"getpinfo\",dc)if not info then return end;repeat local aO,df=coroutine.yield()until aO==\"process_complete\"and df.pid==dc end}dc=do_syscall(\"fork\",function()do_syscall(P==\"r\"and\"stdout\"or\"stdin\",P==\"r\"and dk or dj)do_syscall(\"exec\",\"/bin/sh\",\"-c\",bs)end)return P==\"r\"and setmetatable({_file=dj},{__index=d7,__name=\"FILE*\"})or setmetatable({_file=dk},{__index=d8,__name=\"FILE*\"})end end,read=function(...)return d5:read(...)end,tmpfile=function()return io.open(os.tmpname(),\"a\")end,type=function(bQ)if type(bQ)==\"table\"and getmetatable(bQ)and getmetatable(bQ).__name==\"FILE*\"then if bQ._closed then return\"closed file\"else return\"file\"end else return nil end end,write=function(...)return d6:write(...)end,stdin=d2,stdout=d3,stderr=d4}local dl=os;d0.os={clock=function()return do_syscall(\"clock\")end,date=function(at,co)if type(at)==\"string\"and at:sub(1,1)==\"?\"then local bG=dl.date(\"!\"..at:sub(2),co or dl.epoch\"ingame\"/1000)if type(bG)==\"table\"then bG.year=bG.year-1970 end;return bG else return dl.date(at,co)end end,difftime=function(cM,ax)return cM-ax end,execute=function(bs)do_syscall(\"exec\",\"/bin/sh\",\"-c\",bs)end,exit=function(bK)do_syscall(\"exit\",bK)end,getenv=function(O)expect(1,O,\"string\")local I=do_syscall(\"getenv\")if not I then return nil end;return I[O]end,remove=function(bs)expect(1,bs,\"string\")local s,n=do_syscall(\"remove\",bs)if not s then s=nil end;return s,n end,rename=function(c7,c8)expect(1,c7,\"string\")expect(2,c8,\"string\")local s,n=do_syscall(\"rename\",c7,c8)if not s then s=nil end;return s,n end,setlocale=function(dm)if dm then error(\"setlocale is not supported\",2)else return\"C\"end end,time=function(X)if X==\"ingame\"then return dl.epoch\"ingame\"/1000 elseif X==\"nano\"then return ccemux and ccemux.nanoTime()or dl.epoch\"nano\"end;expect(1,X,\"table\",\"nil\")if X then return dl.time(X)else return dl.epoch\"utc\"/1000 end end,tmpname=function()local O=\"/tmp/lua_\"for o=1,6 do local S=math.random(1,64)O=O..(\"qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890._\"):sub(S,S)end;return O end}d0.debug=deepcopy(debug)local dn={}function d0.debug.getregistry()return dn end;setfenv(d0.debug.getregistry,d0)debug.protect(d0.debug.getregistry)local dp,dq,dr,be,getCurrentThread,ds,dt,next,xpcall,wakeup=coroutine.resume,coroutine.yield,debug.sethook,debug.getinfo,getCurrentThread,table.pack,table.unpack,next,xpcall,wakeup;local du=debugHooks;function d0.coroutine.resume(dv,...)expect(1,dv,\"thread\")local aN=getCurrentThread()if process.debugging then for aX,dw in next,process.breakpoints do if dw.type==\"resume\"and(dw.thread==nil or dw.thread==aN.id)then local s=true;if dw.filter then for F,c in next,dw.filter do if info[F]~=c then s=false;break end end end;if s then dw.process.eventQueue[#dw.process.eventQueue+1]={\"debug_break\",{process=process.id,thread=aN.id,breakpoint=aX}}wakeup(dw.process)aN.paused=true;dq(\"preempt\")end end end end;local dx=#aN.coroStack+1;aN.coroStack[dx]=dv;local as=ds(dp(dv,...))while as.n>=2 and as[1]==true and(as[2]==\"preempt\"or as[2]==\"secure_syscall\"or as[2]==\"secure_event\")do as=ds(dp(dv,dq(dt(as,2,as.n))))end;if process.debugging and not as[1]then local info=be(dv,1)for aX,dw in next,process.breakpoints do if dw.type==\"error\"and(dw.thread==nil or dw.thread==aN.id)then local s=true;if dw.filter then for F,c in next,dw.filter do if info[F]~=c then s=false;break end end end;if s then dw.process.eventQueue[#dw.process.eventQueue+1]={\"debug_break\",{process=process.id,thread=aN.id,breakpoint=aX}}wakeup(dw.process)aN.paused=true;dq(\"preempt\")end end end end;aN.coroStack[dx]=nil;return dt(as,1,as.n)end;function d0.coroutine.yield(cM,ax,...)if process.debugging then local aN=getCurrentThread()local info=be(2)for aX,dw in next,process.breakpoints do if dw.type==\"syscall\"and not(dw.filter and dw.filter.name and dw.filter.name~=ax)and(dw.thread==nil or dw.thread==aN.id)then dw.process.eventQueue[#dw.process.eventQueue+1]={\"debug_break\",{process=process.id,thread=aN.id,breakpoint=aX}}wakeup(dw.process)aN.paused=true;dq(\"preempt\")elseif dw.type==\"yield\"and(dw.thread==nil or dw.thread==aN.id)then local s=true;if dw.filter then for F,c in next,dw.filter do if info[F]~=c then s=false;break end end end;if s then dw.process.eventQueue[#dw.process.eventQueue+1]={\"debug_break\",{process=process.id,thread=aN.id,breakpoint=aX}}wakeup(dw.process)aN.paused=true;dq(\"preempt\")end end end end;return dq(cM,ax,...)end;function d0.debug.gethook(dv)expect(1,dv,\"thread\",\"nil\")dv=dv or coroutine.running()local aC=du[dv]if not aC then return nil end;return aC.func,aC.mask,aC.count end;function d0.debug.sethook(dv,aW,V,dy)if type(dv)~=\"thread\"then dv,aW,V,dy=coroutine.running(),dv,aW,V end;expect(1,dv,\"thread\")expect(2,aW,\"function\",\"nil\")if aW then expect(3,V,\"string\")expect(4,dy,\"number\",\"nil\")du[dv]={func=aW,mask=V,count=dy}if not process.debugging then dr(dv,process.hookf,V,process.quantum)end else du[dv]=nil;if not process.debugging then dr(dv,process.hookf,\"\",process.quantum)end end end;setfenv(d0.debug.gethook,d0)debug.protect(d0.debug.gethook)setfenv(d0.debug.sethook,d0)debug.protect(d0.debug.sethook)function d0.pcall(f,...)return xpcall(f,function(n)if process.debugging then local aN=getCurrentThread()local info=be(2)for aX,dw in next,process.breakpoints do if dw.type==\"error\"and(dw.thread==nil or dw.thread==aN.id)then local s=true;if dw.filter then for F,c in next,dw.filter do if info[F]~=c then s=false;break end end end;if s then dw.process.eventQueue[#dw.process.eventQueue+1]={\"debug_break\",{process=process.id,thread=aN.id,breakpoint=aX,error=n}}wakeup(dw.process)aN.paused=true;dq(\"preempt\")end end end end;return n end,...)end;function d0.xpcall(f,dz,...)return xpcall(f,function(n)if process.debugging then local aN=getCurrentThread()local info=be(2)for aX,dw in next,process.breakpoints do if dw.type==\"error\"and(dw.thread==nil or dw.thread==aN.id)then local s=true;if dw.filter then for F,c in next,dw.filter do if info[F]~=c then s=false;break end end end;if s then dw.process.eventQueue[#dw.process.eventQueue+1]={\"debug_break\",{process=process.id,thread=aN.id,breakpoint=aX,error=n}}wakeup(dw.process)aN.paused=true;dq(\"preempt\")end end end end;return dz(n)end,...)end;createRequire(process,d0)for F,c in pairs(d0)do if type(c)==\"function\"then pcall(setfenv,c,d0)pcall(debug.protect,c)elseif type(c)==\"table\"and F~=\"debug\"then for k,aB in pairs(c)do if type(aB)==\"function\"then pcall(setfenv,aB,d0)pcall(debug.protect,aB)end end end end;return d0 end;function loadfile(bs,P,I)if I==nil and type(P)==\"table\"then I,P=P,nil end;if type(bs)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(bs)..\")\",2)end;if P~=nil and type(P)~=\"string\"then error(\"bad argument #2 (expected string, got \"..type(P)..\")\",2)end;if I~=nil and type(I)~=\"table\"then error(\"bad argument #3 (expected table, got \"..type(I)..\")\",2)end;local H,n=filesystem.open(KERNEL,bs,\"rb\")if not H then error(n,2)end;local bz=H.readAll()H.close()return load(bz,\"@\"..bs,P,I)end;function dofile(bs)if bs~=nil and type(bs)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(bs)..\")\",2)end;local J,n=loadfile(bs or io.stdin:read(\"*a\"))if not J then error(n,2)end;return J()end;function print(...)for o=1,select(\"#\",...)do local c=tostring(select(o,...))terminal.write(TTY[1],c)end end;function terminal.makeTTY(term,U,dA)local as={isTTY=true,flags={cbreak=false,delay=true,echo=true,keypad=false,nlcr=true,raw=false},cursor={x=1,y=1},cursorBlink=true,colors={fg='0',bg='f',bold=false},size={width=U,height=dA},dirtyLines={},palette={},dirtyPalette={},buffer=\"\",preBuffer=\"\",isLocked=false,isGraphics=false,textBuffer={},graphicsBuffer={},frontmostProcess=nil,processList={},eof=false,term=term}for R=1,dA do as[R]={(' '):rep(U),('0'):rep(U),('f'):rep(U)}as.dirtyLines[R]=true end;for o=0,15 do as.palette[o]={_G.term.nativePaletteColor(2^o)}as.dirtyPalette[o]=true end;return as end;do local dB,dC=term.getSize()TTY={terminal.makeTTY(term,dB,dC),terminal.makeTTY(term,dB,dC),terminal.makeTTY(term,dB,dC),terminal.makeTTY(term,dB,dC),terminal.makeTTY(term,dB,dC),terminal.makeTTY(term,dB,dC),terminal.makeTTY(term,dB,dC),terminal.makeTTY(term,dB,dC)}end;currentTTY=TTY[1]terminal.userTTYs={}do local S=args.console:match\"^tty(%d+)$\"if S then KERNEL.stdout,KERNEL.stderr,KERNEL.stdin=TTY[tonumber(S)],TTY[tonumber(S)],TTY[tonumber(S)]end end;keysHeld={ctrl=false,alt=false,shift=false}eventHooks.term_resize=eventHooks.term_resize or{}eventHooks.char=eventHooks.char or{}eventHooks.paste=eventHooks.paste or{}eventHooks.key=eventHooks.key or{}eventHooks.key_up=eventHooks.key_up or{}eventHooks.term_resize[#eventHooks.term_resize+1]=function()local aB,aC=term.getSize()for o=1,8 do terminal.resize(TTY[o],aB,aC)end end;eventHooks.char[#eventHooks.char+1]=function(aO)if not currentTTY.isLocked then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer..aO[2]else currentTTY.preBuffer=currentTTY.preBuffer..aO[2]end;if currentTTY.flags.echo then terminal.write(currentTTY,aO[2])terminal.redraw(currentTTY)end end end;eventHooks.paste[#eventHooks.paste+1]=function(aO)if not currentTTY.isLocked then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer..aO[2]else currentTTY.preBuffer=currentTTY.preBuffer..aO[2]end;if currentTTY.flags.echo then terminal.write(currentTTY,aO[2])terminal.redraw(currentTTY)end end end;eventHooks.key[#eventHooks.key+1]=function(aO)if not currentTTY.isLocked then if aO[2]==keys.enter then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer..\"\\n\"else currentTTY.buffer=currentTTY.buffer..currentTTY.preBuffer..\"\\n\"currentTTY.preBuffer=\"\"end;if currentTTY.flags.echo then terminal.write(currentTTY,\"\\n\")terminal.redraw(currentTTY)end elseif aO[2]==keys.backspace then if currentTTY.flags.cbreak then elseif#currentTTY.preBuffer>0 then currentTTY.preBuffer=currentTTY.preBuffer:sub(1,-2)if currentTTY.flags.echo then terminal.write(currentTTY,\"\\b \\b\")terminal.redraw(currentTTY)end end end end;if aO[2]==keys.leftCtrl or aO[2]==keys.rightCtrl then keysHeld.ctrl=true elseif aO[2]==keys.leftAlt or aO[2]==keys.rightAlt then keysHeld.alt=true elseif aO[2]==keys.leftShift or aO[2]==keys.rightShift then keysHeld.shift=true end;if not currentTTY.flags.raw and currentTTY.frontmostProcess and keysHeld.ctrl and not keysHeld.alt and not keysHeld.shift then if aO[2]==keys.c then killProcess(currentTTY.frontmostProcess.id,2)terminal.write(currentTTY,\"^C\")elseif aO[2]==keys.backslash then killProcess(currentTTY.frontmostProcess.id,3)terminal.write(currentTTY,\"^\\\\\")elseif aO[2]==keys.z then killProcess(currentTTY.frontmostProcess.id,19)terminal.write(currentTTY,\"^Z\")elseif aO[2]==keys.d then currentTTY.eof=true;terminal.write(currentTTY,\"^D\")elseif aO[2]==keys.l and currentTTY.cursor.y>1 then local R=currentTTY.cursor.y-1;terminal.write(currentTTY,\"\\x1b[\"..R..\"T\\x1b[1;\"..currentTTY.cursor.x..\"H\")end end;if keysHeld.ctrl and not keysHeld.alt and keysHeld.shift then local dD=true;if aO[2]==keys.f1 then currentTTY=TTY[1]elseif aO[2]==keys.f2 then currentTTY=TTY[2]elseif aO[2]==keys.f3 then currentTTY=TTY[3]elseif aO[2]==keys.f4 then currentTTY=TTY[4]elseif aO[2]==keys.f5 then currentTTY=TTY[5]elseif aO[2]==keys.f6 then currentTTY=TTY[6]elseif aO[2]==keys.f7 then currentTTY=TTY[7]elseif aO[2]==keys.f8 then currentTTY=TTY[8]elseif aO[2]==keys.left then for o=1,8 do if currentTTY==TTY[o]then currentTTY=TTY[(o+7)%8]break end end elseif aO[2]==keys.right then for o=1,8 do if currentTTY==TTY[o]then currentTTY=TTY[(o+1)%8]break end end else dD=false end;if dD then terminal.redraw(currentTTY,true)end end end;eventHooks.key_up[#eventHooks.key_up+1]=function(aO)if aO[2]==keys.leftCtrl or aO[2]==keys.rightCtrl then keysHeld.ctrl=false elseif aO[2]==keys.leftAlt or aO[2]==keys.rightAlt then keysHeld.alt=false elseif aO[2]==keys.leftShift or aO[2]==keys.rightShift then keysHeld.shift=false end end;function terminal.redraw(dE,cf)if _HEADLESS and dE==TTY[1]and not dE.isLocked then return end;if dE.process then dE.process.eventQueue[#dE.process.eventQueue+1]={\"tty_redraw\",{id=dE.id}}return elseif currentTTY~=dE and not dE.isMonitor then return end;local term=dE.term;local di=dE;if dE.isLocked then if dE.isGraphics then term.setGraphicsMode(2)if term.setFrozen then term.setFrozen(true)end;if cf then term.clear()term.drawPixels(0,0,dE.graphicsBuffer)for o=0,255 do term.setPaletteColor(o,dE.graphicsBuffer.palette[o][1],dE.graphicsBuffer.palette[o][2],dE.graphicsBuffer.palette[o][3])end else if dE.graphicsBuffer.frozen then if term.setFrozen then term.setFrozen(false)end;return end;for k,c in ipairs(dE.graphicsBuffer.dirtyRects)do if c.color then term.setPixel(c.x,c.y,c.color,c.width,c.height)else term.drawPixels(c.x,c.y,c)end end;for o in pairs(dE.graphicsBuffer.dirtyPalette)do term.setPaletteColor(o,dE.graphicsBuffer.palette[o][1],dE.graphicsBuffer.palette[o][2],dE.graphicsBuffer.palette[o][3])end end;if term.setFrozen then term.setFrozen(false)end;di.dirtyRects,di.dirtyPalette={},{}return end;if term.setGraphicsMode then term.setGraphicsMode(false)end;di=dE.textBuffer elseif dE.isGraphics then term.setGraphicsMode(false)dE.isGraphics=false end;term.setCursorBlink(false)if cf then term.clear()for R=1,dE.size.height do term.setCursorPos(1,R)term.blit(di[R][1],di[R][2],di[R][3])end;for o=0,15 do term.setPaletteColor(2^o,di.palette[o][1],di.palette[o][2],di.palette[o][3])end else for R in pairs(di.dirtyLines)do if not di[R]then error(debug.traceback(R))end;term.setCursorPos(1,R)if#di[R][1]~=#di[R][2]or#di[R][2]~=#di[R][3]then syslog.log({level=\"critical\"},\"Bug in text writer! Inequal lengths: \"..#di[R][1]..\", \"..#di[R][2]..\", \"..#di[R][3])error(\"Invalid lengths\")end;term.blit(di[R][1],di[R][2],di[R][3])end;for o in pairs(di.dirtyPalette)do term.setPaletteColor(2^o,di.palette[o][1],di.palette[o][2],di.palette[o][3])end end;term.setCursorPos(di.cursor.x,di.cursor.y)term.setCursorBlink(di.cursorBlink)term.setTextColor(2^tonumber(di.colors.fg,16))di.dirtyLines,di.dirtyPalette={},{}end;function terminal.resize(dE,U,dA)if U>dE.size.width then for R=1,dE.size.height do dE[R][1]=dE[R][1]..(' '):rep(U-dE.size.width)dE[R][2]=dE[R][2]..dE.colors.fg:rep(U-dE.size.width)dE[R][3]=dE[R][3]..dE.colors.bg:rep(U-dE.size.width)dE.dirtyLines[R]=true end;if dE.isLocked then if dE.isGraphics then for R=1,dE.size.height*9 do dE.graphicsBuffer[R]=dE.graphicsBuffer[R]..('\\15'):rep((U-dE.size.width)*6)end;dE.graphicsBuffer.dirtyRects[#dE.graphicsBuffer.dirtyRects+1]={x=dE.size.width*6+1,y=1,width=(U-dE.size.width)*6,height=dE.size.height*9}else for R=1,dE.size.height do dE.textBuffer[R][1]=dE.textBuffer[R][1]..(' '):rep(U-dE.size.width)dE.textBuffer[R][2]=dE.textBuffer[R][2]..dE.textBuffer.colors.fg:rep(U-dE.size.width)dE.textBuffer[R][3]=dE.textBuffer[R][3]..dE.textBuffer.colors.bg:rep(U-dE.size.width)dE.textBuffer.dirtyLines[R]=true end end end elseif U<dE.size.width then for R=1,dE.size.height do dE[R][1]=dE[R][1]:sub(1,U)dE[R][2]=dE[R][2]:sub(1,U)dE[R][3]=dE[R][3]:sub(1,U)dE.dirtyLines[R]=true end;if dE.isLocked then if dE.isGraphics then for R=1,dE.size.height*9 do dE.graphicsBuffer[R]=dE.graphicsBuffer[R]:sub(1,U*6)end else for R=1,dE.size.height do dE.textBuffer[R][1]=dE.textBuffer[R][1]:sub(1,U)dE.textBuffer[R][2]=dE.textBuffer[R][2]:sub(1,U)dE.textBuffer[R][3]=dE.textBuffer[R][3]:sub(1,U)end end end end;dE.size.width=U;if dE.cursor.x>U then dE.cursor.x=U end;if dA>dE.size.height then for R=dE.size.height+1,dA do dE[R]={(' '):rep(U),dE.colors.fg:rep(U),dE.colors.bg:rep(U)}dE.dirtyLines[R]=true end;if dE.isLocked then if dE.isGraphics then for R=dE.size.height*9+1,dA*9 do dE.graphicsBuffer[R]=('\\15'):rep(U*6)end;dE.graphicsBuffer.dirtyRects[#dE.graphicsBuffer.dirtyRects+1]={x=1,y=dE.size.height*9+1,width=dE.size.width*6,height=(dA-dE.size.height)*9}else for R=dE.size.height+1,dA do dE.textBuffer[R]={(' '):rep(U),dE.textBuffer.colors.fg:rep(U),dE.textBuffer.colors.bg:rep(U)}dE.textBuffer.dirtyLines[R]=true end end end elseif dA<dE.size.height then for R=dA+1,dE.size.height do dE[R]=nil;dE.dirtyLines[R]=nil end;if dE.isLocked then if dE.isGraphics then for R=dA*9+1,dE.size.height*9 do dE.graphicsBuffer[R]=nil end else for R=dA+1,dE.size.height do dE.textBuffer[R]=nil;dE.textBuffer.dirtyLines[R]=nil end end end end;dE.size.height=dA;if dE.cursor.y>dA then dE.cursor.y=dA end end;local function dF(dE)local dG=dE.cursor;local R=dG.y+1;dG.y=R;local af=dE.size;local dA=af.height;if R>dA then local dH=dE.dirtyLines;for o=1,dA-1 do dE[o]=dE[o+1]dH[o]=true end;local U=af.width;local dI=dE.colors;dE[dA]={(' '):rep(U),dI.fg:rep(U),dI.bg:rep(U)}dH[dA]=true;dG.y=dA end end;local dJ={['@']=function(dE,aS)local a1=aS[1]or 1;if a1==0 then a1=1 end;local dK,dL=a1%dE.size.width,math.floor(a1/dE.size.width)local S={dE[dE.cursor.y][1]:sub(dE.size.width-dK+1),dE[dE.cursor.y][2]:sub(dE.size.width-dK+1),dE[dE.cursor.y][3]:sub(dE.size.width-dK+1)}dE[dE.cursor.y][1]=dE[dE.cursor.y][1]:sub(1,dE.cursor.x-1)..(\" \"):rep(a1)..dE[dE.cursor.y+dL][1]:sub(dE.cursor.x,dE.size.width-dK)dE[dE.cursor.y][2]=dE[dE.cursor.y][2]:sub(1,dE.cursor.x-1)..dE.colors.fg:rep(a1)..dE[dE.cursor.y+dL][2]:sub(dE.cursor.x,dE.size.width-dK)dE[dE.cursor.y][3]=dE[dE.cursor.y][3]:sub(1,dE.cursor.x-1)..dE.colors.bg:rep(a1)..dE[dE.cursor.y+dL][3]:sub(dE.cursor.x,dE.size.width-dK)dE.dirtyLines[dE.cursor.y]=true;for R=dE.cursor.y+dL+1,dE.size.height do local dM={dE[R-dL][1]:sub(dE.size.width-a1+1),dE[R-dL][2]:sub(dE.size.width-a1+1),dE[R-dL][3]:sub(dE.size.width-a1+1)}dE[R][1]=S[1]..dE[R-dL][1]:sub(1,dE.size.width-dK)dE[R][2]=S[2]..dE[R-dL][2]:sub(1,dE.size.width-dK)dE[R][3]=S[3]..dE[R-dL][3]:sub(1,dE.size.width-dK)dE.dirtyLines[R]=true;S=dM end;for R=dE.cursor.y+1,dE.cursor.y+dL do dE[R][1]=(\" \"):rep(dE.size.width)dE[R][2]=dE.colors.fg:rep(dE.size.width)dE[R][3]=dE.colors.bg:rep(dE.size.width)dE.dirtyLines[R]=true end end,A=function(dE,aS)local a1=aS[1]or 1;if a1==0 then a1=1 end;dE.cursor.y=math.max(dE.cursor.y-a1,1)end,B=function(dE,aS)local a1=aS[1]or 1;if a1==0 then a1=1 end;dE.cursor.y=math.min(dE.cursor.y+a1,dE.size.height)end,C=function(dE,aS)local a1=aS[1]or 1;if a1==0 then a1=1 end;dE.cursor.y=math.min(math.max(dE.cursor.y+math.floor((dE.cursor.x-1+a1)/dE.size.width),1),dE.size.height)dE.cursor.x=(dE.cursor.x-1+a1)%dE.size.width+1 end,D=function(dE,aS)local a1=aS[1]or 1;if a1==0 then a1=1 end;dE.cursor.y=math.min(math.max(dE.cursor.y+math.floor((dE.cursor.x-1-a1)/dE.size.width),1),dE.size.height)dE.cursor.x=(dE.cursor.x-1-a1)%dE.size.width+1 end,E=function(dE,aS)local a1=aS[1]or 1;if a1==0 then a1=1 end;dE.cursor.y=math.min(dE.cursor.y+a1,dE.size.height)dE.cursor.x=1 end,F=function(dE,aS)local a1=aS[1]or 1;if a1==0 then a1=1 end;dE.cursor.y=math.max(dE.cursor.y-a1,1)dE.cursor.x=1 end,G=function(dE,aS)local a1=aS[1]or 1;if a1==0 then a1=1 end;dE.cursor.x=math.min(a1,dE.size.width)end,H=function(dE,aS)local bJ,G=aS[1]or 1,aS[2]or 1;if bJ==0 then bJ=1 end;if G==0 then G=1 end;dE.cursor.x,dE.cursor.y=math.min(G,dE.size.width),math.min(bJ,dE.size.height)end,I=function(dE,aS)end,J=function(dE,aS)local S=aS[1]or 0;if S==0 then dE[dE.cursor.y][1]=dE[dE.cursor.y][1]:sub(1,dE.cursor.x-1)..(\" \"):rep(dE.size.width-dE.cursor.x)dE[dE.cursor.y][2]=dE[dE.cursor.y][2]:sub(1,dE.cursor.x-1)..dE.colors.fg:rep(dE.size.width-dE.cursor.x)dE[dE.cursor.y][3]=dE[dE.cursor.y][3]:sub(1,dE.cursor.x-1)..dE.colors.bg:rep(dE.size.width-dE.cursor.x)dE.dirtyLines[dE.cursor.y]=true;for R=dE.cursor.y+1,dE.size.height do dE[R][1]=(\" \"):rep(dE.size.width)dE[R][2]=dE.colors.fg:rep(dE.size.width)dE[R][3]=dE.colors.bg:rep(dE.size.width)dE.dirtyLines[R]=true end elseif S==1 then dE[dE.cursor.y][1]=(\" \"):rep(dE.cursor.x)..dE[dE.cursor.y][1]:sub(dE.cursor.x)dE[dE.cursor.y][2]=dE.colors.fg:rep(dE.cursor.x)..dE[dE.cursor.y][2]:sub(dE.cursor.x)dE[dE.cursor.y][3]=dE.colors.bg:rep(dE.cursor.x)..dE[dE.cursor.y][3]:sub(dE.cursor.x)dE.dirtyLines[dE.cursor.y]=true;for R=dE.cursor.y-1,1,-1 do dE[R][1]=(\" \"):rep(dE.size.width)dE[R][2]=dE.colors.fg:rep(dE.size.width)dE[R][3]=dE.colors.bg:rep(dE.size.width)dE.dirtyLines[R]=true end elseif S==2 then for R=1,dE.size.height do dE[R][1]=(\" \"):rep(dE.size.width)dE[R][2]=dE.colors.fg:rep(dE.size.width)dE[R][3]=dE.colors.bg:rep(dE.size.width)dE.dirtyLines[R]=true end end end,K=function(dE,aS)local S=aS[1]or 0;if S==0 then dE[dE.cursor.y][1]=dE[dE.cursor.y][1]:sub(1,dE.cursor.x-1)..(\" \"):rep(dE.size.width-dE.cursor.x)dE[dE.cursor.y][2]=dE[dE.cursor.y][2]:sub(1,dE.cursor.x-1)..dE.colors.fg:rep(dE.size.width-dE.cursor.x)dE[dE.cursor.y][3]=dE[dE.cursor.y][3]:sub(1,dE.cursor.x-1)..dE.colors.bg:rep(dE.size.width-dE.cursor.x)dE.dirtyLines[dE.cursor.y]=true elseif S==1 then dE[dE.cursor.y][1]=(\" \"):rep(dE.cursor.x)..dE[dE.cursor.y][1]:sub(dE.cursor.x)dE[dE.cursor.y][2]=dE.colors.fg:rep(dE.cursor.x)..dE[dE.cursor.y][2]:sub(dE.cursor.x)dE[dE.cursor.y][3]=dE.colors.bg:rep(dE.cursor.x)..dE[dE.cursor.y][3]:sub(dE.cursor.x)dE.dirtyLines[dE.cursor.y]=true elseif S==2 then dE[dE.cursor.y][1]=(\" \"):rep(dE.size.width)dE[dE.cursor.y][2]=dE.colors.fg:rep(dE.size.width)dE[dE.cursor.y][3]=dE.colors.bg:rep(dE.size.width)dE.dirtyLines[dE.cursor.y]=true end end,L=function(dE,aS)end,M=function(dE,aS)end,N=function(dE,aS)end,O=function(dE,aS)end,P=function(dE,aS)local a1=aS[1]or 1;if a1==0 then a1=1 end;local dK,dL=a1%dE.size.width,math.floor(a1/dE.size.width)local S={(\" \"):rep(dK),dE.colors.fg:rep(dK),dE.colors.bg:rep(dK)}for R=dE.size.height-dL,dE.cursor.y+1,-1 do local dM={dE[R+dL][1]:sub(1,dK),dE[R+dL][2]:sub(1,dK),dE[R+dL][3]:sub(1,dK)}dE[R][1]=dE[R+dL][1]:sub(dK+1)..S[1]dE[R][2]=dE[R+dL][2]:sub(dK+1)..S[2]dE[R][3]=dE[R+dL][3]:sub(dK+1)..S[3]dE.dirtyLines[R]=true;S=dM end;for R=dE.size.height-dL+1,dE.size.height do dE[R][1]=(\" \"):rep(dE.size.width)dE[R][2]=dE.colors.fg:rep(dE.size.width)dE[R][3]=dE.colors.bg:rep(dE.size.width)dE.dirtyLines[R]=true end;dE[dE.cursor.y][1]=dE[dE.cursor.y][1]:sub(1,dE.cursor.x-1)..dE[dE.cursor.y+dL][1]:sub(dE.cursor.x+dK,dE.size.width)..S[1]dE[dE.cursor.y][2]=dE[dE.cursor.y][2]:sub(1,dE.cursor.x-1)..dE[dE.cursor.y+dL][2]:sub(dE.cursor.x+dK,dE.size.width)..S[2]dE[dE.cursor.y][3]=dE[dE.cursor.y][3]:sub(1,dE.cursor.x-1)..dE[dE.cursor.y+dL][3]:sub(dE.cursor.x+dK,dE.size.width)..S[3]dE.dirtyLines[dE.cursor.y]=true end,Q=function(dE,aS)end,R=function(dE,aS)end,S=function(dE,aS)local S=aS[1]or 0;if S==0 then S=1 end;for k=1,S do table.insert(dE,1,{(' '):rep(dE.size.width),dE.colors.fg:rep(dE.size.width),dE.colors.bg:rep(dE.size.width)})dE[dE.size.height+1]=nil end;for R=1,dE.size.height do dE.dirtyLines[R]=true end end,T=function(dE,aS)local S=aS[1]or 0;if S==0 then S=1 end;for k=1,S do table.remove(dE,1)dE[dE.size.height]={(' '):rep(dE.size.width),dE.colors.fg:rep(dE.size.width),dE.colors.bg:rep(dE.size.width)}end;for R=1,dE.size.height do dE.dirtyLines[R]=true end end,U=function(dE,aS)end,V=function(dE,aS)end,W=function(dE,aS)end,X=function(dE,aS)end,Y=function(dE,aS)end,Z=function(dE,aS)end,['[']=function(dE,aS)end,['\\\\']=function(dE,aS)end,[']']=function(dE,aS)end,['^']=function(dE,aS)end,['_']=function(dE,aS)end,['`']=function(dE,aS)end,a=function(dE,aS)end,b=function(dE,aS)end,c=function(dE,aS)end,d=function(dE,aS)end,e=function(dE,aS)end,f=function(dE,aS)end,g=function(dE,aS)end,h=function(dE,aS)if aS[1]==25 then dE.cursorBlink=true end end,i=function(dE,aS)end,j=function(dE,aS)end,k=function(dE,aS)end,l=function(dE,aS)if aS[1]==25 then dE.cursorBlink=false end end,m=function(dE,aS)local S,Y=aS[1]or 0,aS[2]if S==0 then dE.colors.fg,dE.colors.bg,dE.colors.bold='0','f',false elseif S==1 then dE.colors.bold=true elseif S==7 or S==27 then dE.colors.fg,dE.colors.bg=dE.colors.bg,dE.colors.fg elseif S==22 then dE.colors.bold=false elseif S>=30 and S<=37 then dE.colors.fg=(\"%x\"):format(15-(S-30)-(dE.colors.bold and 8 or 0))elseif S==39 then dE.colors.fg='0'elseif S>=40 and S<=47 then dE.colors.bg=(\"%x\"):format(15-(S-40)-(dE.colors.bold and 8 or 0))elseif S==49 then dE.colors.bg='f'elseif S>=90 and S<=97 then dE.colors.fg=(\"%x\"):format(15-(S-90)-8)elseif S>=100 and S<=107 then dE.colors.bg=(\"%x\"):format(15-(S-100)-8)end;if Y~=nil then if Y==0 then dE.colors.fg,dE.colors.bg='0','f'elseif Y==1 then dE.colors.bold=true elseif Y==7 or Y==27 then dE.colors.fg,dE.colors.bg=dE.colors.bg,dE.colors.fg elseif Y==22 then dE.colors.bold=false elseif Y>=30 and Y<=37 then dE.colors.fg=(\"%x\"):format(15-(Y-30)-(dE.colors.bold and 8 or 0))elseif Y==39 then dE.colors.fg='0'elseif Y>=40 and Y<=47 then dE.colors.bg=(\"%x\"):format(15-(Y-40)-(dE.colors.bold and 8 or 0))elseif Y==49 then dE.colors.bg='f'elseif Y>=90 and Y<=97 then dE.colors.fg=(\"%x\"):format(15-(Y-90)-8)elseif Y>=100 and Y<=107 then dE.colors.bg=(\"%x\"):format(15-(Y-100)-8)end end end,n=function(dE,aS)end,o=function(dE,aS)end}for o=0x70,0x7F do dJ[string.char(o)]=function(dE,aS)end end;function terminal.write(dE,dN)if _HEADLESS and dE==TTY[1]then return term.write(dN)end;local aU,af=1,0;local function dO(Q)if af==0 then aU,af=Q,0;return end;while dE.cursor.x+af>dE.size.width do dE[dE.cursor.y][1]=dE[dE.cursor.y][1]:sub(1,dE.cursor.x-1)..dN:sub(aU,aU+dE.size.width-dE.cursor.x)dE[dE.cursor.y][2]=dE[dE.cursor.y][2]:sub(1,dE.cursor.x-1)..dE.colors.fg:rep(dE.size.width-dE.cursor.x+1)dE[dE.cursor.y][3]=dE[dE.cursor.y][3]:sub(1,dE.cursor.x-1)..dE.colors.bg:rep(dE.size.width-dE.cursor.x+1)dE.dirtyLines[dE.cursor.y]=true;aU=aU+dE.size.width-dE.cursor.x+1;af=af-(dE.size.width-dE.cursor.x+1)dE.cursor.x=1;dF(dE)end;dE[dE.cursor.y][1]=dE[dE.cursor.y][1]:sub(1,dE.cursor.x-1)..dN:sub(aU,aU+af-1)..dE[dE.cursor.y][1]:sub(dE.cursor.x+af)dE[dE.cursor.y][2]=dE[dE.cursor.y][2]:sub(1,dE.cursor.x-1)..dE.colors.fg:rep(af)..dE[dE.cursor.y][2]:sub(dE.cursor.x+af)dE[dE.cursor.y][3]=dE[dE.cursor.y][3]:sub(1,dE.cursor.x-1)..dE.colors.bg:rep(af)..dE[dE.cursor.y][3]:sub(dE.cursor.x+af)dE.dirtyLines[dE.cursor.y]=true;dE.cursor.x=dE.cursor.x+af;aU,af=Q,0 end;local dP=0;local aS,dQ;for Q,G,S in dN:gmatch\"()(.)()\"do if dP==0 then if G=='\\a'then dO(S)local dR=hardware.find(\"speaker\")if dR then hardware.call(dR,\"playNote\",\"pling\")end elseif G=='\\b'then dO(S)if dE.cursor.x==1 then if dE.cursor.y>1 then dE.cursor.x,dE.cursor.y=dE.size.width,dE.cursor.y-1 end else dE.cursor.x=dE.cursor.x-1 end elseif G=='\\t'then dO(S)dE.cursor.x=math.floor((dE.cursor.x-1)/8)*8+9;if dE.cursor.x>dE.size.width then dE.cursor.x=1;dF(dE)end elseif G=='\\n'then dO(S)dF(dE)if dE.flags.nlcr then dE.cursor.x=1 end elseif G=='\\f'then dO(S)dF(dE)elseif G=='\\r'then dO(S)dE.cursor.x=1 elseif G=='\\27'then dP=1 else af=af+1 end elseif dP==1 then if false then elseif G=='['then dP=2;aS,dQ={},0 elseif G==']'then if dN:byte(S)==0x50 then dP=4;aS={}else dP=3;aS,dQ={},0 end else dO(S)dP=0 end elseif dP==2 then if G>='@'and G<='\\127'then dO(S)aS[#aS+1]=dQ;dJ[G](dE,aS)dP=0 elseif G>='0'and G<='?'then if G<='9'then dQ=dQ*10+tonumber(G)elseif G==';'then aS[#aS+1],dQ=dQ,0 end else dO(S)dP=0 end elseif dP==3 then if G=='\\\\'and dN:byte(Q-1)=='\\27'then dO(S)dP=0 end elseif dP==4 then if#aS==0 then aS[1]=tonumber(G,16)or 0 elseif#aS==1 and not dQ then dQ=(tonumber(G,16)or 0)*16 elseif#aS==1 then aS[2],dQ=dQ+(tonumber(G,16)or 0),nil elseif#aS==2 and not dQ then dQ=(tonumber(G,16)or 0)*16 elseif#aS==2 then aS[3],dQ=dQ+(tonumber(G,16)or 0),nil elseif#aS==3 and not dQ then dQ=(tonumber(G,16)or 0)*16 elseif#aS==3 then dO(S)aS[4],dQ=dQ+(tonumber(G,16)or 0),nil;dE.palette[aS[1]]={aS[2]/255,aS[3]/255,aS[4]/255}dE.dirtyPalette[aS[1]]=true;dP=0 end end end;dO()end;function syscalls.write(process,aN,...)if not process.stdout then return end;local function dS(X)if process.stdout.isTTY then terminal.write(process.stdout,X)else process.stdout.write(X)end end;local args=table.pack(...)for o=1,args.n do if o>1 then dS(\"\\t\")end;dS(tostring(args[o]))end;if process.stdout.isTTY then terminal.redraw(process.stdout)end end;function syscalls.writeerr(process,aN,...)if not process.stderr then return end;local function dS(X)if process.stderr.isTTY then terminal.write(process.stderr,X)else process.stderr.write(X)end end;local args=table.pack(...)for o=1,args.n do if o>1 then dS(\"\\t\")end;dS(tostring(args[o]))end;if process.stderr.isTTY then terminal.redraw(process.stderr)end end;function syscalls.read(process,aN,S)expect(1,S,\"number\")if process.stdin then if process.stdin.eof then process.stdin.eof=false;return nil end;while#process.stdin.buffer<S do if process.stdin.eof then process.stdin.eof=false;return nil end;if process.stdin.isTTY and not process.stdin.flags.delay then return nil end;if process.stdin.read then local bI=process.stdin.read(S-#process.stdin.buffer)if not bI then return nil end;process.stdin.buffer=process.stdin.buffer..bI else return kSyscallYield,\"read\",S end end;local bI=process.stdin.buffer:sub(1,S-1)process.stdin.buffer=process.stdin.buffer:sub(S)return bI else return nil end end;function syscalls.readline(process,aN)if process.stdin then if process.stdin.eof then process.stdin.eof=false;return nil end;while not process.stdin.buffer:find(\"\\n\")do if process.stdin.eof then process.stdin.eof=false;return nil end;if process.stdin.isTTY and not process.stdin.flags.delay then return nil end;if process.stdin.read then local bI=process.stdin.read()if not bI then return nil end;process.stdin.buffer=process.stdin.buffer..bI else return kSyscallYield,\"readline\"end end;local S=process.stdin.buffer:find(\"\\n\")local bI=process.stdin.buffer:sub(1,S-1)process.stdin.buffer=process.stdin.buffer:sub(S+1)return bI else return nil end end;function syscalls.termctl(process,aN,dT)expect(1,dT,\"table\",\"nil\")if not process.stdout or not process.stdout.isTTY then return nil end;if dT then expect.field(dT,\"cbreak\",\"boolean\",\"nil\")expect.field(dT,\"delay\",\"boolean\",\"nil\")expect.field(dT,\"echo\",\"boolean\",\"nil\")expect.field(dT,\"keypad\",\"boolean\",\"nil\")expect.field(dT,\"nlcr\",\"boolean\",\"nil\")expect.field(dT,\"raw\",\"boolean\",\"nil\")for F,c in pairs(dT)do if process.stdout.flags[F]~=nil then process.stdout.flags[F]=c end end end;local X=deepcopy(process.stdout.flags)X.hasgfx=term.getGraphicsMode~=nil;return X end;function terminal.openterm(dE,process)if dE.isLocked then if not dE.isGraphics and dE.frontmostProcess==process then return dE.screenHandle end;return nil,\"Terminal already in use\"end;local af=dE.size;local di={cursor={x=1,y=1},cursorBlink=false,colors={fg='0',bg='f'},palette={},dirtyLines={},dirtyPalette={}}dE.textBuffer=di;dE.isLocked=true;dE.isGraphics=false;for R=1,af.height do di[R]={(' '):rep(af.width),('0'):rep(af.width),('f'):rep(af.width)}di.dirtyLines[R]=true end;for o=0,15 do di.palette[o]={term.nativePaletteColor(2^o)}di.dirtyPalette[o]=true end;dE.processList[#dE.processList+1]=dE.frontmostProcess;dE.frontmostProcess=process;local dU=setmetatable({},{__name=\"Terminal\"})local dV=terminal.redraw;local expect=expect;dE.screenHandle=dU;function dU.close()if not dU then error(\"terminal is already closed\",2)end;dU=nil;dE.isLocked=false;dE.frontmostProcess=table.remove(dE.processList)dE.screenHandle=nil;dV(dE,true)end;function dU.write(dN)if not dU then error(\"terminal is already closed\",2)end;dN=tostring(dN)expect(1,dN,\"string\")if di.cursor.y<1 or di.cursor.y>af.height then return elseif di.cursor.x>af.width or di.cursor.x+#dN<1 then di.cursor.x=di.cursor.x+#dN;return elseif di.cursor.x<1 then dN=dN:sub(-di.cursor.x+2)di.cursor.x=1 end;local dW=#dN;if di.cursor.x+#dN>af.width then dN=dN:sub(1,af.width-di.cursor.x+1)end;di[di.cursor.y][1]=di[di.cursor.y][1]:sub(1,di.cursor.x-1)..dN..di[di.cursor.y][1]:sub(di.cursor.x+#dN)di[di.cursor.y][2]=di[di.cursor.y][2]:sub(1,di.cursor.x-1)..di.colors.fg:rep(#dN)..di[di.cursor.y][2]:sub(di.cursor.x+#dN)di[di.cursor.y][3]=di[di.cursor.y][3]:sub(1,di.cursor.x-1)..di.colors.bg:rep(#dN)..di[di.cursor.y][3]:sub(di.cursor.x+#dN)di.cursor.x=di.cursor.x+dW;di.dirtyLines[di.cursor.y]=true end;function dU.blit(dN,dX,dY)if not dU then error(\"terminal is already closed\",2)end;dN=tostring(dN)expect(1,dN,\"string\")expect(2,dX,\"string\")expect(3,dY,\"string\")if#dN~=#dX or#dX~=#dY then error(\"Arguments must be the same length\",2)end;if di.cursor.y<1 or di.cursor.y>af.height then return elseif di.cursor.x>af.width or di.cursor.x<1-#dN then di.cursor.x=di.cursor.x+#dN;dV(dE)return elseif di.cursor.x<1 then dN,dX,dY=dN:sub(-di.cursor.x+2),dX:sub(-di.cursor.x+2),dY:sub(-di.cursor.x+2)di.cursor.x=1 end;local dW=#dN;if di.cursor.x+#dN>af.width then dN,dX,dY=dN:sub(1,af.width-di.cursor.x+1),dX:sub(1,af.width-di.cursor.x+1),dY:sub(1,af.width-di.cursor.x+1)end;di[di.cursor.y][1]=di[di.cursor.y][1]:sub(1,di.cursor.x-1)..dN..di[di.cursor.y][1]:sub(di.cursor.x+#dN)di[di.cursor.y][2]=di[di.cursor.y][2]:sub(1,di.cursor.x-1)..dX..di[di.cursor.y][2]:sub(di.cursor.x+#dX)di[di.cursor.y][3]=di[di.cursor.y][3]:sub(1,di.cursor.x-1)..dY..di[di.cursor.y][3]:sub(di.cursor.x+#dY)di.cursor.x=di.cursor.x+dW;di.dirtyLines[di.cursor.y]=true end;function dU.clear()if not dU then error(\"terminal is already closed\",2)end;for R=1,af.height do di[R]={(' '):rep(af.width),di.colors.fg:rep(af.width),di.colors.bg:rep(af.width)}di.dirtyLines[R]=true end end;function dU.clearLine()if not dU then error(\"terminal is already closed\",2)end;if di.cursor.y>=1 and di.cursor.y<=af.height then di[di.cursor.y]={(' '):rep(af.width),di.colors.fg:rep(af.width),di.colors.bg:rep(af.width)}di.dirtyLines[di.cursor.y]=true end end;function dU.getCursorPos()if not dU then error(\"terminal is already closed\",2)end;return di.cursor.x,di.cursor.y end;function dU.setCursorPos(dZ,d_)if not dU then error(\"terminal is already closed\",2)end;expect(1,dZ,\"number\")expect(2,d_,\"number\")if dZ==di.cursor.x and d_==di.cursor.y then return end;di.cursor.x,di.cursor.y=math.floor(dZ),math.floor(d_)end;function dU.getCursorBlink()if not dU then error(\"terminal is already closed\",2)end;return di.cursorBlink end;function dU.setCursorBlink(ax)if not dU then error(\"terminal is already closed\",2)end;expect(1,ax,\"boolean\")di.cursorBlink=ax end;function dU.isColor()if not dU then error(\"terminal is already closed\",2)end;return true end;function dU.getSize()if not dU then error(\"terminal is already closed\",2)end;return af.width,af.height end;function dU.scroll(e0)if not dU then error(\"terminal is already closed\",2)end;expect(1,e0,\"number\")if math.abs(e0)>=af.width then for R=1,af.height do di[R]={(' '):rep(af.width),di.colors.fg:rep(af.width),di.colors.bg:rep(af.width)}end elseif e0>0 then for o=e0+1,af.height do di[o]=di[o-e0]end;for o=af.height-e0+1,af.height do di[o]={(' '):rep(af.width),di.colors.fg:rep(af.width),di.colors.bg:rep(af.width)}end elseif e0<0 then for o=1,af.height+e0 do di[o-e0]=di[o]end;for o=1,-e0 do di[o]={(' '):rep(af.width),di.colors.fg:rep(af.width),di.colors.bg:rep(af.width)}end else return end;for o=1,af.height do di.dirtyLines[o]=true end end;function dU.getTextColor()if not dU then error(\"terminal is already closed\",2)end;return tonumber(di.colors.fg,16)end;function dU.setTextColor(e1)if not dU then error(\"terminal is already closed\",2)end;expect(1,e1,\"number\")expect.range(e1,0,15)di.colors.fg=(\"%x\"):format(e1)end;function dU.getBackgroundColor()if not dU then error(\"terminal is already closed\",2)end;return tonumber(di.colors.bg,16)end;function dU.setBackgroundColor(e1)if not dU then error(\"terminal is already closed\",2)end;expect(1,e1,\"number\")expect.range(e1,0,15)di.colors.bg=(\"%x\"):format(e1)end;function dU.getPaletteColor(e1)if not dU then error(\"terminal is already closed\",2)end;expect(1,e1,\"number\")expect.range(e1,0,15)return table.unpack(di.palette[math.floor(e1)])end;function dU.setPaletteColor(e1,bJ,e2,ax)if not dU then error(\"terminal is already closed\",2)end;expect(1,e1,\"number\")expect(2,bJ,\"number\")if e2==nil and ax==nil then bJ,e2,ax=bit32.band(bit32.rshift(bJ,16),0xFF)/255,bit32.band(bit32.rshift(bJ,8),0xFF)/255,bit32.band(bJ,0xFF)/255 end;expect(3,e2,\"number\")expect(4,ax,\"number\")expect.range(e1,0,15)if bJ<0 or bJ>1 then error(\"bad argument #2 (value out of range)\",2)end;if e2<0 or e2>1 then error(\"bad argument #3 (value out of range)\",2)end;if ax<0 or ax>1 then error(\"bad argument #4 (value out of range)\",2)end;di.palette[math.floor(e1)]={bJ,e2,ax}di.dirtyPalette[math.floor(e1)]=true end;function dU.getLine(R)if not dU then error(\"terminal is already closed\",2)end;expect(1,R,\"number\")local aa=di[R]if aa then return table.unpack(aa,1,3)end end;local e3=term.nativePaletteColor;function dU.nativePaletteColor(e1)expect(1,e1,\"number\")expect.range(e1,0,15)return e3(2^e1)end;for k,c in pairs(dU)do setfenv(c,process.env)debug.protect(c)end;dU.isColour=dU.isColor;dU.getTextColour=dU.getTextColor;dU.setTextColour=dU.setTextColor;dU.getBackgroundColour=dU.getBackgroundColor;dU.setBackgroundColour=dU.setBackgroundColor;dU.getPaletteColour=dU.getPaletteColor;dU.setPaletteColour=dU.setPaletteColor;dU.nativePaletteColour=dU.nativePaletteColor;process.dependents[#process.dependents+1]={gc=function()if dU then return dU.close()end end}dV(dE,true)return dU end;function syscalls.openterm(process,aN)if not process.stdout or not process.stdout.isTTY then return nil,\"No valid TTY attached\"end;if process~=process.stdout.frontmostProcess then syscalls.kill(KERNEL,nil,process.id,22)if process.paused then return kSyscallYield,\"openterm\"end end;return terminal.openterm(process.stdout,process)end;function terminal.opengfx(dE,process)if not term.drawPixels then return nil,\"Graphics mode not supported\"end;if dE.isLocked then if dE.isGraphics and dE.frontmostProcess==process then return dE.screenHandle end;return nil,\"Terminal already in use\"end;local af=dE.size;local di={palette={},dirtyRects={},dirtyPalette={},frozen=false}dE.graphicsBuffer=di;dE.isLocked=true;dE.isGraphics=true;for R=1,af.height*9 do di[R]=('\\15'):rep(af.width*6)end;for o=0,15 do di.palette[o]={term.nativePaletteColor(2^o)}di.dirtyPalette[o]=true end;for o=16,255 do di.palette[o]={0,0,0}di.dirtyPalette[o]=true end;dE.processList[#dE.processList+1]=dE.frontmostProcess;dE.frontmostProcess=process;local dU=setmetatable({},{__name=\"GFXTerminal\"})local dV=terminal.redraw;local expect=expect;dE.screenHandle=dU;function dU.close()if not dU then error(\"terminal is already closed\",2)end;dU=nil;dE.isLocked=false;dE.frontmostProcess=table.remove(dE.processList)dE.screenHandle=nil;dV(dE,true)end;function dU.getSize()return af.width*6,af.height*9 end;function dU.clear()if not dU then error(\"terminal is already closed\",2)end;for R=1,af.height*9 do di[R]=('\\15'):rep(af.width*6)end;dV(dE,true)end;function dU.getPixel(Q,R)if not dU then error(\"terminal is already closed\",2)end;expect(1,Q,\"number\")expect(2,R,\"number\")expect.range(Q,0,af.width*6-1)expect.range(R,0,af.height*9-1)Q,R=math.floor(Q),math.floor(R)return di[R+1]:byte(Q+1)end;function dU.setPixel(Q,R,e1)if not dU then error(\"terminal is already closed\",2)end;expect(1,Q,\"number\")expect(2,R,\"number\")expect(3,e1,\"number\")expect.range(Q,0,af.width*6-1)expect.range(R,0,af.height*9-1)expect.range(e1,0,255)Q,R=math.floor(Q),math.floor(R)di[R+1]=di[R+1]:sub(1,Q)..string.char(e1)..di[R+1]:sub(Q+2)di.dirtyRects[#di.dirtyRects+1]={x=Q,y=R,color=e1}end;function dU.getPixels(Q,R,U,dA,e4)if not dU then error(\"terminal is already closed\",2)end;expect(1,Q,\"number\")expect(2,R,\"number\")expect(3,U,\"number\")expect(4,dA,\"number\")expect(5,e4,\"boolean\",\"nil\")expect.range(U,0)expect.range(dA,0)Q,R=math.floor(Q),math.floor(R)local X={}for e5=1,dA do if e4 then X[e5]=di[R+e5]:sub(Q+1,Q+U)else X[e5]={di[R+e5]:sub(Q+1,Q+U):byte(1,-1)}end end;return X end;function dU.drawPixels(Q,R,bz,U,dA)if not dU then error(\"terminal is already closed\",2)end;expect(1,Q,\"number\")expect(2,R,\"number\")expect(3,bz,\"table\",\"number\")local e6=type(bz)==\"number\"expect(4,U,\"number\",not e6 and\"nil\"or nil)expect(5,dA,\"number\",not e6 and\"nil\"or nil)expect.range(Q,0,af.width*6-1)expect.range(R,0,af.height*9-1)if U then expect.range(U,0)end;if dA then expect.range(dA,0)end;if e6 then expect.range(bz,0,255)end;if U==0 or dA==0 then return end;Q,R=math.floor(Q),math.floor(R)if U and Q+U>=af.width*6 then U=af.width*6-Q end;dA=dA or#bz;local e7={x=Q,y=R,width=U,height=dA}for e5=1,dA do if R+e5>af.height*9 then break end;if e6 then local bI=string.char(bz):rep(U)di[R+e5]=di[R+e5]:sub(1,Q)..bI..di[R+e5]:sub(Q+U+1)e7[e5]=bI elseif bz[e5]~=nil then if type(bz[e5])~=\"table\"and type(bz[e5])~=\"string\"then error(\"bad argument #3 to 'drawPixels' (invalid row \"..e5 ..\")\",2)end;local U=U or#bz[e5]if Q+U>=af.width*6 then U=af.width*6-Q end;local bI;if type(bz[e5])==\"string\"then bI=bz[e5]if#bI<U then bI=bI..('\\15'):rep(U-#bI)elseif#bI>U then bI=bI:sub(1,U)end else bI=\"\"for e8=1,U do bI=bI..string.char(bz[e5][e8]or di[R+e5]:byte(Q+e8))end end;di[R+e5]=di[R+e5]:sub(1,Q)..bI..di[R+e5]:sub(Q+U+1)e7[e5]=bI end end;di.dirtyRects[#di.dirtyRects+1]=e7 end;function dU.getFrozen()if not dU then error(\"terminal is already closed\",2)end;return di.frozen end;function dU.setFrozen(f)if not dU then error(\"terminal is already closed\",2)end;expect(1,f,\"boolean\")di.frozen=f end;function dU.getPaletteColor(e1)if not dU then error(\"terminal is already closed\",2)end;expect(1,e1,\"number\")expect.range(e1,0,255)return table.unpack(di.palette[e1])end;function dU.setPaletteColor(e1,bJ,e2,ax)if not dU then error(\"terminal is already closed\",2)end;expect(1,e1,\"number\")expect(2,bJ,\"number\")if e2==nil and ax==nil then bJ,e2,ax=bit32.band(bit32.rshift(bJ,16),0xFF)/255,bit32.band(bit32.rshift(bJ,8),0xFF)/255,bit32.band(bJ,0xFF)/255 end;expect(3,e2,\"number\")expect(4,ax,\"number\")expect.range(bJ,0,1)expect.range(e2,0,1)expect.range(ax,0,1)expect.range(e1,0,255)di.palette[e1]={bJ,e2,ax}di.dirtyPalette[e1]=true end;local e3=term.nativePaletteColor;function dU.nativePaletteColor(e1)expect(1,e1,\"number\")expect.range(e1,0,15)return e3(2^e1)end;for k,c in pairs(dU)do setfenv(c,process.env)debug.protect(c)end;dU.getPaletteColour=dU.getPaletteColor;dU.setPaletteColour=dU.setPaletteColor;dU.nativePaletteColour=dU.nativePaletteColor;process.dependents[#process.dependents+1]={gc=function()if dU then return dU.close()end end}dV(dE,true)return dU end;function syscalls.opengfx(process,aN)if not process.stdout or not process.stdout.isTTY then return nil,\"No valid TTY attached\"end;if process~=process.stdout.frontmostProcess then syscalls.kill(KERNEL,nil,process.id,22)if process.paused then return kSyscallYield,\"openterm\"end end;return terminal.opengfx(process.stdout,process)end;function syscalls.mktty(process,aN,U,dA)expect(1,U,\"number\")expect(2,dA,\"number\")expect.range(U,1)expect.range(dA,1)local dE=terminal.makeTTY(term,U,dA)dE.id=math.random(0,0x7FFFFFFF)dE.process=process;local j={__index=dE,__metatable={__name=\"TTY\"}}local as=setmetatable({},j)local do_syscall=do_syscall;function as.sendEvent(cr,df)return do_syscall(\"__ttyevent\",as,cr,df)end;function as.write(dN)return do_syscall(\"__ttyevent\",as,\"paste\",tostring(dN))end;debug.protect(as.sendEvent)debug.protect(as.write)j.__newindex=function()error(\"cannot modify TTY\",2)end;terminal.userTTYs[as]=dE;process.dependents[#process.dependents+1]={gc=function()terminal.userTTYs[as]=nil end}return as end;function syscalls.__ttyevent(process,aN,e9,cr,df)expect(1,e9,\"table\")expect(2,cr,\"string\")expect(3,df,\"table\")local dE=terminal.userTTYs[e9]if not dE then error(\"Invalid TTY\")end;if dE.process~=process then error(\"Invalid TTY\")end;if not dE.frontmostProcess then return end;if cr==\"key\"then expect.field(df,\"keycode\",\"number\")expect.field(df,\"isRepeat\",\"boolean\")dE.frontmostProcess.eventQueue[#dE.frontmostProcess.eventQueue+1]={\"key\",{keycode=df.keycode,isRepeat=df.isRepeat,ctrlHeld=keysHeld.ctrl,altHeld=keysHeld.alt,shiftHeld=keysHeld.shift}}if not dE.isLocked then if df.keycode==10 then if dE.flags.cbreak then dE.buffer=dE.buffer..\"\\n\"else dE.buffer=dE.buffer..dE.preBuffer..\"\\n\"dE.preBuffer=\"\"end;if dE.flags.echo then terminal.write(dE,\"\\n\")terminal.redraw(dE)end elseif df.keycode==8 then if dE.flags.cbreak then elseif#dE.preBuffer>0 then dE.preBuffer=dE.preBuffer:sub(1,-2)if dE.flags.echo then terminal.write(dE,\"\\b \\b\")terminal.redraw(dE)end end end end elseif cr==\"key_up\"then expect.field(df,\"keycode\",\"number\")dE.frontmostProcess.eventQueue[#dE.frontmostProcess.eventQueue+1]={\"key_up\",{keycode=df.keycode,ctrlHeld=keysHeld.ctrl,altHeld=keysHeld.alt,shiftHeld=keysHeld.shift}}elseif cr==\"char\"then expect.field(df,\"character\",\"string\")dE.frontmostProcess.eventQueue[#dE.frontmostProcess.eventQueue+1]={\"char\",{character=df.character}}if not dE.isLocked then if dE.flags.cbreak then dE.buffer=dE.buffer..df.character else dE.preBuffer=dE.preBuffer..df.character end;if dE.flags.echo then terminal.write(dE,df.character)terminal.redraw(dE)end end elseif cr==\"paste\"then expect.field(df,\"text\",\"string\")dE.frontmostProcess.eventQueue[#dE.frontmostProcess.eventQueue+1]={\"paste\",{text=df.text}}if not dE.isLocked then if dE.flags.cbreak then dE.buffer=dE.buffer..df.text else dE.preBuffer=dE.preBuffer..df.text end;if dE.flags.echo then terminal.write(dE,df.text)terminal.redraw(dE)end end elseif cr==\"mouse_click\"or cr==\"mouse_up\"or cr==\"mouse_drag\"then expect.field(df,\"x\",\"number\")expect.field(df,\"y\",\"number\")expect.field(df,\"button\",\"number\")dE.frontmostProcess.eventQueue[#dE.frontmostProcess.eventQueue+1]={cr,{x=df.x,y=df.y,button=df.button,buttonMask=0}}elseif cr==\"mouse_scroll\"then expect.field(df,\"x\",\"number\")expect.field(df,\"y\",\"number\")expect.field(df,\"direction\",\"number\")dE.frontmostProcess.eventQueue[#dE.frontmostProcess.eventQueue+1]={cr,{x=df.x,y=df.y,button=df.direction}}else error(\"Invalid event\")end;wakeup(dE.frontmostProcess)end;function syscalls.capture(process,aN)local bD=process.stdin;if not bD or not bD.isTTY then return end;bD.processList[#bD.processList+1]=bD.frontmostProcess;bD.frontmostProcess=process end;function syscalls.release(process,aN)local bD=process.stdin;if not bD or not bD.isTTY then return end;if bD.frontmostProcess==process then bD.frontmostProcess=table.remove(bD.processList)else local ea=nil;for o=#bD.processList,1,-1 do if bD.processList[o]==process then if ea then table.remove(bD.processList,ea)break else ea=o end end end end end;function syscalls.stdin(process,aN,bD)expect(1,bD,\"number\",\"table\",\"string\",\"nil\")if process.stdin and process.stdin.isTTY and process.stdin.frontmostProcess==process then process.stdin.preBuffer=\"\"end;if type(bD)==\"number\"then bD=TTY[bD]if bD and process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)bD.processList[#bD.processList+1]=bD.frontmostProcess;bD.frontmostProcess=process;if discord and process.stdin==currentTTY then discord(\"Phoenix\",\"Executing \"..process.name)end end;process.stdin=bD elseif type(bD)==\"string\"then local eb=hardware.get(bD)if not eb then error(\"bad argument #1 (no such device)\",2)end;if not eb.internalState.tty then error(\"bad argument #1 (no TTY available on device)\",2)end;bD=eb.internalState.tty;if process.stdin and process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)bD.processList[#bD.processList+1]=bD.frontmostProcess;bD.frontmostProcess=process end;process.stdin=bD elseif bD==nil then if process.stdin and process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)end;process.stdin=nil else if bD.isTTY then bD=terminal.userTTYs[bD]if not bD then error(\"bad argument #1 (invalid TTY)\",2)end;if process.stdin and process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)bD.processList[#bD.processList+1]=bD.frontmostProcess;bD.frontmostProcess=process;bD.preBuffer=\"\"end else expect.field(bD,\"read\",\"function\")local bC=bD.read;bD={buffer=\"\",read=function(...)local s,E=userModeCallback(process,bC,...)if s then return E else error(E,2)end end}end;process.stdin=bD end end;function syscalls.stdout(process,aN,bD)expect(1,bD,\"number\",\"table\",\"string\",\"nil\")if process.stdout and process.stdout.isTTY and process.stdout.frontmostProcess==process then if discord and process.stdout==currentTTY then discord(\"Phoenix\",\"Executing \"..process.stdout.frontmostProcess.name)end end;if type(bD)==\"number\"then bD=TTY[bD]if bD and process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)bD.processList[#bD.processList+1]=bD.frontmostProcess;bD.frontmostProcess=process;if discord and process.stdout==currentTTY then discord(\"Phoenix\",\"Executing \"..process.name)end end;process.stdout=bD elseif type(bD)==\"string\"then local eb=hardware.get(bD)if not eb then error(\"bad argument #1 (no such device)\",2)end;if not eb.internalState.tty then error(\"bad argument #1 (no TTY available on device)\",2)end;bD=eb.internalState.tty;if process.stdout and process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)bD.processList[#bD.processList+1]=bD.frontmostProcess;bD.frontmostProcess=process;if discord and process.stdout==currentTTY then discord(\"Phoenix\",\"Executing \"..process.name)end end;process.stdout=bD elseif bD==nil then if process.stdout and process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)if discord and process.stdout==currentTTY then discord(\"Phoenix\",\"Executing \"..process.name)end end;process.stdout=nil else if bD.isTTY then bD=terminal.userTTYs[bD]if not bD then error(\"bad argument #1 (invalid TTY)\",2)end;if process.stdout and process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)bD.processList[#bD.processList+1]=bD.frontmostProcess;bD.frontmostProcess=process;if discord and process.stdout==currentTTY then discord(\"Phoenix\",\"Executing \"..process.name)end end else expect.field(bD,\"write\",\"function\")local dS=bD.write;bD={write=function(...)local s,E=userModeCallback(process,dS,...)if s then return E else error(E,2)end end}end;process.stdout=bD end end;function syscalls.stderr(process,aN,bD)expect(1,bD,\"number\",\"table\",\"string\",\"nil\")if process.stderr and process.stderr.isTTY and process.stderr.frontmostProcess==process then end;if type(bD)==\"number\"then bD=TTY[bD]if bD and process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)bD.processList[#bD.processList+1]=bD.frontmostProcess;bD.frontmostProcess=process;if discord and process.stderr==currentTTY then discord(\"Phoenix\",\"Executing \"..process.name)end end;process.stderr=bD elseif type(bD)==\"string\"then local eb=hardware.get(bD)if not eb then error(\"bad argument #1 (no such device)\",2)end;if not eb.internalState.tty then error(\"bad argument #1 (no TTY available on device)\",2)end;bD=eb.internalState.tty;if process.stderr and process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)bD.processList[#bD.processList+1]=bD.frontmostProcess;bD.frontmostProcess=process end;process.stderr=bD elseif bD==nil then if process.stderr and process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)end;process.stderr=nil else if bD.isTTY then bD=terminal.userTTYs[bD]if not bD then error(\"bad argument #1 (invalid TTY)\",2)end;if process.stderr and process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)bD.processList[#bD.processList+1]=bD.frontmostProcess;bD.frontmostProcess=process end else expect.field(bD,\"write\",\"function\")local dS=bD.write;bD={write=function(...)local s,E=userModeCallback(process,dS,...)if s then return E else error(E,2)end end}end;process.stderr=bD end end;function syscalls.istty(process,aN)return process.stdin and process.stdin.isTTY,process.stdout and process.stdout.isTTY end;function syscalls.termsize(process,aN)if not process.stdout or not process.stdout.isTTY then return nil,nil end;return process.stdout.size.width,process.stdout.size.height end;function syscalls.chvt(process,aN,h)expect(1,h,\"number\")if not TTY[h]then error(\"TTY out of range\",0)end;if process.user~=\"root\"then error(\"Permission denied\",0)end;currentTTY=TTY[h]terminal.redraw(currentTTY,true)end;syslogs={default={stream={},tty=KERNEL.stdout,tty_level=args.loglevel,colorize=true}}local ec={[0]=\"Debug\",\"Info\",\"Notice\",\"Warning\",\"Error\",\"Critical\",\"Panic\"}local ed={}for o=0,#ec do ed[ec[o]:lower()]=o end;local ee={[0]='\\27[90m','\\27[97m','\\27[36m','\\27[93m','\\27[31m','\\27[95m','\\27[96m'}local function ef(X,aI,o,aw)if o>=aw then return tostring(X[o])else return tostring(X[o])..aI..ef(X,aI,o+1,aw)end end;function syscalls.syslog(process,aN,bY,...)local args=table.pack(...)if type(bY)==\"table\"then expect.field(bY,\"name\",\"string\",\"nil\")expect.field(bY,\"category\",\"string\",\"nil\")expect.field(bY,\"level\",\"number\",\"string\",\"nil\")expect.field(bY,\"time\",\"number\",\"nil\")expect.field(bY,\"process\",\"number\",\"nil\")expect.field(bY,\"thread\",\"number\",\"nil\")expect.field(bY,\"module\",\"string\",\"nil\")expect.field(bY,\"traceback\",\"boolean\",\"nil\")if type(bY.level)==\"string\"then bY.level=ed[bY.level:lower()]if not bY.level then error(\"bad field 'level' (invalid name)\",0)end elseif bY.level and(bY.level<0 or bY.level>#ec)then error(\"bad field 'level' (level out of range)\",0)end;bY.name=bY.name or\"default\"bY.process=bY.process or process.id;bY.thread=bY.thread or aN and aN.id;bY.level=bY.level or 1;bY.time=bY.time or os.epoch\"utc\"else local S=args.n;table.insert(args,1,bY)args.n=S+1;bY={process=process.id,thread=aN and aN.id,level=1,name=\"default\",time=os.epoch\"utc\"}end;local eg=syslogs[bY.name]if eg==nil then error(\"No such log named \"..bY.name,0)end;local aA;for o=1,args.n do aA=(o==1 and\"\"or aA..\" \")..serialize(args[o])end;if eg.file then eg.file.write((\"[%s]%s %s[%d%s]%s [%s]: %s\\n\"):format(os.date(\"%b %d %X\",bY.time/1000),bY.category and\" <\"..bY.category..\">\"or\"\",processes[bY.process]and processes[bY.process].name or\"(unknown)\",bY.process,bY.thread and\":\"..bY.thread or\"\",bY.module and\" (\"..bY.module..\")\"or\"\",ec[bY.level],ef(args,\" \",1,args.n)))eg.file.flush()end;if eg.stream then bY.message=aA;for k,c in pairs(eg.stream)do local s=true;if c.filter then local O,eh,z=\"\"local o=1;local ei,ej=false,false;while o<#c.filter do if eh==nil then O,o=c.filter:match(\"(%a+)%s*()\",o)if bY[O]==nil then s=false;break end;eh=\"\"elseif z==nil then local b2=c.filter:sub(o,o+1)if b2==\"==\"or b2==\"!=\"or b2==\"=%\"or b2==\"!%\"or b2==\"<=\"or b2==\">=\"then eh=b2 elseif b2==\"~=\"then eh=\"!=\"elseif b2==\"~%\"then eh=\"!%\"elseif c.filter:sub(o,o)=='<'or c.filter:sub(o,o)=='>'then eh=c.filter:sub(o,o)else s=false;break end;z=\"\"else local G=c.filter:sub(o,o)if ei then if G==ei and not ej then ei,ej=false,false else z=z..G;if not ej and G=='\\\\'then ej=true else ej=false end end elseif G=='\"'or G==\"'\"then ei=G elseif G=='|'or G==';'then if eh==\"==\"and bY[O]==z or eh==\"!=\"and bY[O]~=z or eh==\"=%\"and bY[O]:match(z)or eh==\"!%\"and not bY[O]:match(z)or eh==\"<\"and(tonumber(bY[O])or 0)<(tonumber(z)or 0)or eh==\"<=\"and(tonumber(bY[O])or 0)<=(tonumber(z)or 0)or eh==\">=\"and(tonumber(bY[O])or 0)>=(tonumber(z)or 0)or eh==\">\"and(tonumber(bY[O])or 0)>(tonumber(z)or 0)then if G=='|'then o=c.filter:match(\"[^;]*;+()\",o)if o==nil then break end;o=o-1 end;O,eh,z=\"\"ei,ej=false,false else s=G=='|'z=\"\"if not s then break end end elseif not(G==' 'and z==\"\")then z=z..G end;o=o+1 end end;if ei then s=false;break end end;if s then local process=processes[c.pid]if process then process.eventQueue[#process.eventQueue+1]={\"syslog\",deepcopy(bY)}end end end end;if eg.tty and eg.tty_level<=bY.level then if eg.tty.isTTY then local t=ef(args,\" \",1,args.n)if eg.colorize and bY.traceback then t=t:gsub(\"\\t\",\"  \"):gsub(\"([^\\n]+):(%d+):\",\"\\27[96m%1\\27[37m:\\27[95m%2\\27[37m:\"):gsub(\"'([^']+)'\\n\",\"\\27[93m'%1'\\27[37m\\n\")end;terminal.write(eg.tty,(\"%s[%s]%s %s[%d%s]%s [%s]: %s%s\\n\"):format(eg.colorize and ee[bY.level]or\"\",os.date(\"%b %d %X\",bY.time/1000),bY.category and\" <\"..bY.category..\">\"or\"\",processes[bY.process]and processes[bY.process].name or\"(unknown)\",bY.process,bY.thread and\":\"..bY.thread or\"\",bY.module and\" (\"..bY.module..\")\"or\"\",ec[bY.level],t,eg.colorize and\"\\27[0m\"or\"\"))terminal.redraw(eg.tty)else end end end;function syscalls.mklog(process,aN,O,ek,bs)expect(1,O,\"string\")expect(2,ek,\"boolean\",\"nil\")expect(3,bs,\"string\",\"nil\")if syslogs[O]then return end;syslogs[O]={}if bs then local n;syslogs[O].file,n=filesystem.open(process,bs,\"a\")if syslogs[O].file==nil then syslogs[O]=nil;return error(\"Could not open log file: \"..n,0)end end;if ek then syslogs[O].stream={}end end;function syscalls.rmlog(process,aN,O)expect(1,O,\"string\")if O==\"default\"then error(\"Cannot delete default log\",0)end;if not syslogs[O]then error(\"Log does not exist\",0)end;if syslogs[O].stream then for k,c in pairs(syslogs[O].stream)do processes[c.pid].eventQueue[#processes[c.pid].eventQueue+1]={\"syslog_close\",{id=c.id}}processes[c.pid].dependents[c.id]=nil;wakeup(processes[c.pid])end end;syslogs[O]=nil end;function syscalls.openlog(process,aN,O,el)expect(1,O,\"string\")expect(2,el,\"string\",\"nil\")if not syslogs[O]then error(\"Log does not exist\",0)end;if not syslogs[O].stream then error(\"Log does not have streaming enabled\",0)end;local aX=#process.dependents+1;local dc=process.id;process.dependents[aX]={type=\"log\",name=O,filter=el,gc=function()for o,c in pairs(syslogs[O].stream)do if c.id==aX and c.pid==dc then syslogs[O].stream[o]=nil end end end}syslogs[O].stream[#syslogs[O].stream+1]={pid=dc,id=aX,filter=el}return aX end;function syscalls.closelog(process,aN,O)expect(1,O,\"string\",\"number\")if type(O)==\"string\"then if not syslogs[O]then error(\"Log does not exist\",0)end;if not syslogs[O].stream then error(\"Log does not have streaming enabled\",0)end;for o,c in pairs(syslogs[O].stream)do if c.pid==process.id then process.dependents[c.id]=nil;syslogs[O].stream[o]=nil end end else if not process.dependents[O]then error(\"Log connection does not exist\",0)end;local eg=syslogs[process.dependents[O].name].stream;for o,c in pairs(eg)do if c.pid==process.id and c.id==O then process.dependents[c.id]=nil;eg[o]=nil;break end end end end;function syscalls.logtty(process,aN,O,dE,C)if process.user~=\"root\"then error(\"Permission denied\",0)end;expect(1,O,\"string\")expect(2,dE,\"table\",\"number\",\"nil\")expect(3,C,\"number\",\"nil\")if not syslogs[O]then error(\"Log does not exist\",0)end;syslogs[O].tty=type(dE)==\"table\"and dE or TTY[dE]syslogs[O].tty_level=C;return true end;function syslog.log(bY,...)return pcall(syscalls.syslog,KERNEL,nil,bY,...)end;function syslog.debug(...)return pcall(syscalls.syslog,KERNEL,nil,{level=\"debug\",process=0},...)end;local em=panic;function panic(aA)xpcall(function()currentTTY=TTY[1]TTY[1].isLocked=false;syslog.log({level=\"panic\"},\"Kernel panic:\",aA)if debug then local aE=debug.traceback(nil,2)syslog.log({level=\"panic\",traceback=true},aE)end;syslog.log({level=\"panic\"},\"We are hanging here...\")terminal.redraw(TTY[1],true)term.setCursorBlink(false)mainThread=nil;if _HEADLESS then os.shutdown(1)end;while true do coroutine.yield()end end,function(Y)em(aA..\"; and an error occurred while logging the error: \"..Y)end)end;xpcall(function()local n;syslogs.default.file,n=filesystem.open(KERNEL,\"/var/log/default.log\",\"a\")shutdownHooks[#shutdownHooks+1]=function()if syslogs.default.file then syslogs.default.file.close()end end;syslog.log(\"Starting Phoenix version\",PHOENIX_VERSION,PHOENIX_BUILD)syslog.log(\"Initialized system logger\")syslog.log(\"System started at \"..systemStartTime..\" on computer \"..os.computerID()..(os.computerLabel()and\"('\"..os.computerLabel()..\"')\"or\"\"))syslog.log(\"Computer host is \".._HOST)if syslogs.default.file==nil then syslog.log({level=\"notice\"},\"An error occurred while opening the log file at /var/log/default.log:\",n,\". System logs will not be saved to disk.\")end end,panic)local function en(bI)return string.match(bI,'^()%s*$')and''or string.match(bI,'^%s*(.*%S)')end;local expect,do_syscall=expect,do_syscall;local function eo(bz)local au=1;local function bC(G)if au>#bz then return nil end;G=G or 1;local bI=bz:sub(au,au+G-1)au=au+G;return bI end;if bC(8)~=\"!<arch>\\n\"then error(\"Not an ar archive\",2)end;local as={}local ep=nil;local eq={}while true do local bz={}local er=bC()while er==\"\\n\"do er=bC()end;if er==nil then break end;local O=bC(15)if O==nil then break end;O=er..O;if string.find(O,\"/\")and string.find(O,\"/\")>1 then O=string.sub(O,1,string.find(O,\"/\")-1)else O=en(O)end;bz.timestamp=tonumber(en(bC(12)))bz.owner=tonumber(en(bC(6)))bz.group=tonumber(en(bC(6)))bz.mode=tonumber(en(bC(8)),8)local af=tonumber(en(bC(10)))if bC(2)~=\"`\\n\"then error(\"Invalid header for file \"..O,2)end;if string.match(O,\"^#1/%d+$\")then O=bC(tonumber(string.match(O,\"#1/(%d+)\")))elseif string.match(O,\"^/%d+$\")then if ep then local S=tonumber(string.match(O,\"/(%d+)\"))O=ep:match(\"[^/]*\",S+1)else table.insert(eq,O)end end;bz.name=O;bz.data=bC(af)if O==\"//\"then ep=bz.data elseif O~=\"/\"and O~=\"/SYM64/\"then table.insert(as,bz)end end;if ep then for F,c in pairs(eq)do local S=tonumber(string.match(c,\"/(%d+)\"))for aa,aB in pairs(as)do if aB.name==c then aB.name=ep:match(\"[^/]*\",S+1)break end end end end;local es={}for k,c in ipairs(as)do es[c.name]=c end;return es end;function createRequire(process,d0)local et,eu={},{}d0.package={}local ev=processes[process.parent]and processes[process.parent].env;if ev then d0.package.path=ev.package and ev.package.path;d0.package.libpath=ev.package and ev.package.libpath end;d0.package.path=d0.package.path or\"/lib/?.lua;/lib/?/init.lua;/usr/lib/?.lua;/usr/lib/?/init.lua;./?.lua;./?/init.lua\"if type(process.vars.PACKAGE_PATH)==\"string\"then d0.package.path=process.vars.PACKAGE_PATH..';'..d0.package.path end;d0.package.libpath=d0.package.libpath or\"/lib/lib?.a;/usr/lib/lib?.a\"if type(process.vars.PACKAGE_LIBPATH)==\"string\"then d0.package.libpath=process.vars.PACKAGE_LIBPATH..';'..d0.package.libpath end;d0.package.config=\"/\\n;\\n?\\n!\\n-\"d0.package.loaded=et;d0.package.preload=eu;d0.package.forceload=false;for F,c in pairs(d0)do if type(c)==\"table\"then et[F]=c end end;local ew=setmetatable({},{__newindex=function()end,__metatable=false})local ex={}local function ey(O,bs)local H,n=do_syscall(\"open\",bs,\"rb\")if not H then error(bs..\": \"..n,3)end;local bz=H.readAll()H.close()local J,n=load(bz,\"@\"..bs,nil,_ENV)if not J then error(bs..\": \"..n,3)end;local cs=bs:match(\"^(.*)/[^/]*$\")or\"/\"ex[#ex+1]=function(ez)local bs,n=package.searchpath(ez,cs..\"/?.lua;\"..cs..\"/?/init.lua\")if not bs then return nil,n end;return ey,bs end;local s,E=pcall(J,O)ex[#ex]=nil;if s then return E else error(bs..\": \"..E,3)end end;local function eA(O,bs)local eB;if bs:find\"%z\"then bs,eB=bs:match\"^([^%z]*)%z(.*)$\"elseif O:find\"%-\"then eB=O:match(\"^([^%-]*)%-(.*)$\")else eB=\"init\"end;local H,n=do_syscall(\"open\",bs,\"rb\")if not H then error(bs..\": \"..n,3)end;local bz=H.readAll()H.close()local cs=eo(bz)local function eC(O)local a1=O..\".lua\"if not cs[a1]then error(bs..\":\"..a1 ..\": File not found\",0)end;local bz=cs[a1].data;local J,n=load(bz,\"@\"..bs..\":\"..a1,nil,_ENV)if not J then error(bs..\":\"..a1 ..\": \"..n,3)end;local s,E=pcall(J,O)if s then return E else error(bs..\":\"..a1 ..\": \"..E)end end;ex[#ex+1]=function(ez)return eC,ez end;local E=eC(eB)ex[#ex]=nil;return E end;ex[1]=function(O)local cs=do_syscall(\"getname\"):match(\"^(.*)/[^/]*$\")or\"/\"local bs,n=package.searchpath(O,cs..\"/?.lua;\"..cs..\"/?/init.lua\")if not bs then return nil,n end;return ey,bs end;function d0.package.searchpath(O,bs,aI,eD)expect(1,O,\"string\")expect(2,bs,\"string\")expect(3,aI,\"string\",\"nil\")expect(4,eD,\"string\",\"nil\")aI=(aI or\".\"):gsub(\"([%^%$%(%)%%%.%[%]%*%+%-%?])\",\"%%%1\")eD=(eD or\"/\"):gsub(\"([%^%$%(%)%%%.%[%]%*%+%-%?])\",\"%%%1\")local e=\"\"for a1 in bs:gmatch\"[^;]+\"do local cu=a1:gsub(\"%?\",O:gsub(aI,eD),nil)local H,n=do_syscall(\"open\",cu,\"r\")if H then H.close()return cu else e=e..\"\\t\"..cu..\": \"..n..\"\\n\"end end;return nil,e end;d0.package.searchers={function(O)local a1=eu[O]if a1 then return a1 else return nil,\"\\tpackage.preload['\"..O..\"']: No such field\\n\"end end,function(O)local bs,n=package.searchpath(O,package.path)if not bs then return nil,n end;return ey,bs,bs end,function(O)local bs,n=package.searchpath(O:match(\"^[^%-]*\"),package.libpath)if not bs then return nil,n end;local S=O:match(\"%-(.+)$\")if S then return eA,bs,bs..\":\"..S else return eA,bs,bs..\":init\"end end,function(O)if not O:find\"%.\"then return nil end;local bs,n=package.searchpath(O:match(\"^[^%.]*\"),package.libpath)if not bs then return nil,n end;local S=O:match(\"^[^%.]*%.(.*)$\")return eA,bs..\"\\0\"..S,bs..\":\"..S end,function(O)if#ex>0 then return ex[#ex](O)end;return nil,\"no local loaders found\"end}setfenv(ey,d0)debug.protect(ey)setfenv(eA,d0)debug.protect(eA)setfenv(ex[1],d0)debug.protect(ex[1])for k,c in pairs(d0.package.searchers)do setfenv(c,d0)debug.protect(c)end;function d0.require(O)expect(1,O,\"string\")local n=\"module '\"..O..\"' not found:\\n\"local eE,eF,eG;for k,c in ipairs(package.searchers)do eE,eF,eG=c(O)if eE then break end;n=n..(eF or\"\")end;if not eE then error(n,2)end;if eG then if et[eG]then if et[eG]==ew then error(\"loop detected loading '\"..O..\"'\",3)elseif not package.forceload then return et[eG]end end;et[eG]=ew else if et[O]then if et[O]==ew then error(\"loop detected loading '\"..O..\"'\",3)elseif not package.forceload then return et[O]end end end;et[O]=ew;local s,E=pcall(eE,O,eF)if s then if E~=nil then et[O]=E elseif et[O]==ew then et[O]=true end;if eG then if E~=nil then et[eG]=E elseif et[eG]==ew then et[eG]=true end end;return et[O]else et[O]=nil;if eG then et[eG]=nil end;error(n..\"\\t\"..E..\"\\n\",2)end end;return d0 end;do local et,eu={},{}package={}package.path=\"/lib/?.lua;/lib/?/init.lua;/usr/lib/?.lua;/usr/lib/?/init.lua\"package.libpath=\"/lib/lib?.a;/usr/lib/lib?.a\"package.config=\"/\\n;\\n?\\n!\\n-\"package.loaded=et;package.preload=eu;package.forceload=false;for F,c in pairs(_G)do if type(c)==\"table\"then et[F]=c end end;local ew=setmetatable({},{__newindex=function()end,__metatable=false})local ex={}local function ey(O,bs)local bZ,n=filesystem.stat(KERNEL,bs)if not bZ then error(bs..\": \"..n,3)end;if bZ.owner~=\"root\"or bZ.worldPermissions.write then error(bs..\": Insecure file permissions\",3)end;for F,c in pairs(bZ.permissions)do if F~=\"root\"and c.write then error(bs..\": Insecure file permissions\",3)end end;local H,n=filesystem.open(KERNEL,bs,\"rb\")if not H then error(bs..\": \"..n,3)end;local bz=H.readAll()H.close()local J,n=load(bz,\"@\"..bs,nil,_G)if not J then error(bs..\": \"..n,3)end;local cs=bs:match(\"^(.*)/[^/]*$\")or\"/\"ex[#ex+1]=function(ez)local bs,n=package.searchpath(ez,cs..\"/?.lua;\"..cs..\"/?/init.lua\")if not bs then return nil,n end;return ey,bs end;local s,E=pcall(J,O)ex[#ex]=nil;if s then return E else error(bs..\": \"..E,3)end end;local function eA(O,bs)local eB;if bs:find\"%z\"then bs,eB=bs:match\"^([^%z]*)%z(.*)$\"elseif O:find\"%-\"then eB=O:match(\"^([^%-]*)%-(.*)$\")else eB=\"init\"end;local bZ,n=filesystem.stat(KERNEL,bs)if not bZ then error(bs..\": \"..n,3)end;if bZ.owner~=\"root\"or bZ.worldPermissions.write then error(bs..\": Insecure file permissions\",3)end;for F,c in pairs(bZ.permissions)do if F~=\"root\"and c.write then error(bs..\": Insecure file permissions\",3)end end;local H,n=filesystem.open(KERNEL,bs,\"rb\")if not H then error(bs..\": \"..n,3)end;local bz=H.readAll()H.close()local cs=eo(bz)local function eC(O)local a1=O..\".lua\"if not cs[a1]then error(bs..\":\"..a1 ..\": File not found\",0)end;local bz=cs[a1].data;local J,n=load(bz,\"@\"..bs..\":\"..a1,nil,_ENV)if not J then error(bs..\":\"..a1 ..\": \"..n,3)end;local s,E=pcall(J,O)if s then return E else error(bs..\":\"..a1 ..\": \"..E)end end;ex[#ex+1]=function(ez)return eC,ez end;local E=eC(eB)ex[#ex]=nil;return E end;function package.searchpath(O,bs,aI,eD)expect(1,O,\"string\")expect(2,bs,\"string\")expect(3,aI,\"string\",\"nil\")expect(4,eD,\"string\",\"nil\")aI=(aI or\".\"):gsub(\"([%^%$%(%)%%%.%[%]%*%+%-%?])\",\"%%%1\")eD=(eD or\"/\"):gsub(\"([%^%$%(%)%%%.%[%]%*%+%-%?])\",\"%%%1\")local e=\"\"for a1 in bs:gmatch\"[^;]+\"do local cu=a1:gsub(\"%?\",O:gsub(aI,eD),nil)local H,n=filesystem.open(KERNEL,cu,\"r\")if H then H.close()return cu else e=e..\"\\t\"..cu..\": \"..n..\"\\n\"end end;return nil,e end;package.searchers={function(O)local a1=eu[O]if a1 then return a1 else return nil,\"\\tpackage.preload['\"..O..\"']: No such field\\n\"end end,function(O)local bs,n=package.searchpath(O,package.path)if not bs then return nil,n end;return ey,bs,bs end,function(O)local bs,n=package.searchpath(O:match(\"^[^%-]*\"),package.libpath)if not bs then return nil,n end;local S=O:match(\"%-(.+)$\")if S then return eA,bs,bs..\":\"..S else return eA,bs,bs..\":init\"end end,function(O)if not O:find\"%.\"then return nil end;local bs,n=package.searchpath(O:match(\"^[^%.]*\"),package.libpath)if not bs then return nil,n end;local S=O:match(\"^[^%.]*%.(.*)$\")return eA,bs..\"\\0\"..S,bs..\":\"..S end,function(O)if#ex>0 then return ex[#ex](O)end;return nil,\"\\tno local loaders found\"end}function require(O)expect(1,O,\"string\")local n=\"module '\"..O..\"' not found:\\n\"local eE,eF,eG;for k,c in ipairs(package.searchers)do eE,eF,eG=c(O)if eE then break end;n=n..(eF or\"\")end;if not eE then error(n,2)end;if eG then if et[eG]then if et[eG]==ew then error(\"loop detected loading '\"..O..\"'\",3)elseif not package.forceload then return et[eG]end end;et[eG]=ew else if et[O]then if et[O]==ew then error(\"loop detected loading '\"..O..\"'\",3)elseif not package.forceload then return et[O]end end end;et[O]=ew;local s,E=pcall(eE,O,eF)if s then if E~=nil then et[O]=E elseif et[O]==ew then et[O]=true end;if eG then if E~=nil then et[eG]=E elseif et[eG]==ew then et[eG]=true end end;return et[O]else et[O]=nil;if eG then et[eG]=nil end;error(n..\"\\t\"..E..\"\\n\",2)end end end;timerMap={}alarmMap={}local eH={}function syscalls.kill(process,aN,dc,eI)expect(1,dc,\"number\")expect(2,eI,\"number\")local eJ=processes[dc]if not eJ then error(\"No such process\",2)end;if process.user~=\"root\"and process.user~=eJ.user then error(\"Permission denied\",2)end;if eI==9 then reap_process(eJ)if processes[eJ.parent]then syscalls.queueEvent(processes[eJ.parent],nil,\"process_complete\",{id=dc,result=9})end;processes[dc]=nil elseif eJ.signalHandlers[eI]then userModeCallback(eJ,eJ.signalHandlers[eI],eI)else syscalls.queueEvent(eJ,nil,\"signal\",{signal=eI})end end;function killProcess(dc,eI)expect(1,dc,\"number\")expect(2,eI,\"number\")local eJ=processes[dc]if not eJ then return end;if eI==9 then reap_process(eJ)if processes[eJ.parent]then syscalls.queueEvent(processes[eJ.parent],nil,\"process_complete\",{id=dc,result=9})end;processes[dc]=nil elseif eJ.signalHandlers[eI]then local aX=syscalls.newthread(eJ,nil,eJ.signalHandlers[eI],eI)eJ.threads[aX].name=\"<signal handler:\"..eI..\">\"else syscalls.queueEvent(eJ,nil,\"signal\",{signal=eI})end end;function syscalls.signal(process,aN,eI,eK)expect(1,eI,\"number\")expect(2,eK,\"function\",\"nil\")process.signalHandlers[eI]=eK end;function syscalls.queueEvent(process,aN,O,aS)expect(1,O,\"string\")expect(2,aS,\"table\")process.eventQueue[#process.eventQueue+1]={O,aS}end;function syscalls.sendEvent(process,aN,dc,O,aS)expect(1,dc,\"number\")expect(2,O,\"string\")local eJ=processes[dc]if not eJ then return false end;eJ.eventQueue[#eJ.eventQueue+1]={\"remote_event\",{type=O,sender=process.id,data=aS}}wakeup(eJ)return true end;function syscalls.peekEvent(process,aN)local aO=process.eventQueue[#process.eventQueue]if not aO then return nil end;local args={}for F,c in pairs(aO[2])do args[F]=c end;return aO[1],args end;function syscalls.register(process,aN,O)expect(1,O,\"string\")if eH[O]then return false end;eH[O]=process.id;process.dependents[#process.dependents+1]={gc=function()eH[O]=nil end}return true end;function syscalls.lookup(process,aN,O)expect(1,O,\"string\")return eH[O]end;function syscalls.timer(process,aN,eL)expect(1,eL,\"number\")local eM=os.startTimer(eL)timerMap[eM]=process;return bit32.band(eM,0x7FFFFFFF)end;function syscalls.alarm(process,aN,eL)expect(1,eL,\"number\")local eM=os.setAlarm(eL)alarmMap[eM]=process;return bit32.bor(eM,0x80000000)end;function syscalls.cancel(process,aN,eM)expect(1,eM,\"number\")if bit32.btest(eM,0x80000000)then eM=bit32.band(eM,0x7FFFFFFF)if alarmMap[eM]~=process then error(\"No such alarm\")end;os.cancelAlarm(eM)alarmMap[eM]=nil else if timerMap[eM]~=process then error(\"No such timer\")end;os.cancelTimer(eM)timerMap[eM]=nil end end;eventHooks.terminate=eventHooks.terminate or{}eventHooks.terminate[#eventHooks.terminate+1]=function()if currentTTY.frontmostProcess then syscalls.kill(KERNEL,nil,currentTTY.frontmostProcess.id,2)terminal.write(currentTTY,\"^T\")end end;eventParameterMap={alarm={\"id\"},char={\"character\"},key={\"keycode\",\"isRepeat\"},key_up={\"keycode\"},mouse_click={\"button\",\"x\",\"y\"},mouse_drag={\"button\",\"x\",\"y\"},mouse_up={\"button\",\"x\",\"y\"},mouse_scroll={\"direction\",\"x\",\"y\"},paste={\"text\"},redstone={},term_resize={},timer={\"id\"},turtle_inventory={}}do local eN=0;for k,c in pairs(keys)do if type(c)==\"number\"then eN=math.max(eN,c)end end;if table.create then keymap=table.create(eN,0)else local bK;local eO,eP=pcall(string.dump,function()end)if eO then local eQ=(function(Q)if Q<8 then return Q end;local a7=0;while Q>=128 do Q,a7=bit32.rshift(Q+0xf,4),a7+4 end;while Q>=16 do Q,a7=bit32.rshift(Q+1,1),a7+1 end;return bit32.bor((a7+1)*8,Q-8)end)(eN)syslog.debug(\"Key table sizes:\",eN,eQ)if _VERSION==\"Lua 5.1\"then bK=eP:sub(1,12)..(\"I\"..eP:byte(9)..\"IIBBBBIIIIIIII\"):pack(0,0,0,0,0,0,1,2,eQ*0x800000+10,0x0100001E,0,0,0,0,0)elseif _VERSION==\"Lua 5.2\"then bK=eP:sub(1,18)..(\"IIBBBIIIIIIIIII\"):pack(0,0,0,0,1,2,eQ*0x800000+11,0x0100001F,0,0,0,0,0,0,0)elseif _VERSION==\"Lua 5.3\"then bK=eP:sub(1,17+(\"jn\"):packsize())..(\"BBIIBBBIIIIIIIII\"):pack(0,0,0,0,0,0,1,2,eQ*0x800000+11,0x01000026,0,0,0,0,0,0)elseif _VERSION==\"Lua 5.4\"then bK=eP:sub(1,15+(\"jn\"):packsize())..(\"BBBBBBBBIIIBBBBBBB\"):pack(0,0x80,0x80,0x80,0,0,1,0x83,0x00000013,eN*0x80+82,0x00008048,0x80,0x80,0x80,0x80,0x80,0x80,0x80)end;if bK then local J,n=load(bK,nil,\"b\")if J then keymap=J()else syslog.debug(\"Could not load key table code:\",n)end end end;if not keymap then keymap=load(\"return {\"..(\"nil,\"):rep(eN)..\"}\")()end end;for o=0x61,0x7A do keymap[keys[string.char(o)]]=o end;for o=0x81,0x99 do if keys[\"f\"..bit32.band(o,31)]then keymap[keys[\"f\"..bit32.band(o,31)]]=o end end;for o=0xA0,0xA9 do keymap[keys[\"numPad\"..bit32.band(o,15)]]=o end;keymap[keys.backspace]=0x08;keymap[keys.tab]=0x09;keymap[keys.enter or keys[\"return\"]]=0x0A;keymap[keys.space]=0x20;keymap[keys.apostrophe]=0x27;keymap[keys.comma]=0x2C;keymap[keys.minus]=0x2D;keymap[keys.period]=0x2E;keymap[keys.slash]=0x2F;keymap[keys.zero]=0x30;keymap[keys.one]=0x31;keymap[keys.two]=0x32;keymap[keys.three]=0x33;keymap[keys.four]=0x34;keymap[keys.five]=0x35;keymap[keys.six]=0x36;keymap[keys.seven]=0x37;keymap[keys.eight]=0x38;keymap[keys.nine]=0x39;keymap[keys.semicolon or keys.semiColon]=0x3B;keymap[keys.equals]=0x3D;keymap[keys.leftBracket]=0x5B;keymap[keys.backslash]=0x5C;keymap[keys.rightBracket]=0x5D;keymap[keys.grave]=0x60;keymap[keys.delete]=0x7F;keymap[keys.insert]=0x80;if keys.convert then keymap[keys.convert]=0x9A end;if keys.noconvert then keymap[keys.noconvert]=0x9B end;if keys.kana then keymap[keys.kana]=0x9C end;if keys.kanji then keymap[keys.kanji]=0x9D end;if keys.yen then keymap[keys.yen]=0x9E end;keymap[keys.numPadDecimal]=0x9F;keymap[keys.numPadAdd]=0xAA;keymap[keys.numPadSubtract]=0xAB;if keys.numPadMultiply then keymap[keys.numPadMultiply]=0xAC end;keymap[keys.numPadDivide]=0xAD;keymap[keys.numPadEqual or keys.numPadEquals]=0xAE;keymap[keys.numPadEnter]=0xAF;keymap[keys.leftCtrl]=0xB0;keymap[keys.rightCtrl]=0xB1;keymap[keys.leftAlt]=0xB2;keymap[keys.rightAlt]=0xB3;keymap[keys.leftShift]=0xB4;keymap[keys.rightShift]=0xB5;if keys.leftSuper then keymap[keys.leftSuper]=0xB6 end;if keys.rightSuper then keymap[keys.rightSuper]=0xB7 end;keymap[keys.capsLock]=0xB8;keymap[keys.numLock]=0xB9;keymap[keys.scrollLock or keys.scollLock]=0xBA;if keys.printScreen then keymap[keys.printScreen]=0xBB end;keymap[keys.pause]=0xBC;if keys.menu then keymap[keys.menu]=0xBD end;if keys.stop then keymap[keys.stop]=0xBE end;if keys.ax then keymap[keys.ax]=0xBF end;keymap[keys.up]=0xC0;keymap[keys.down]=0xC1;keymap[keys.left]=0xC2;keymap[keys.right]=0xC3;keymap[keys.pageUp]=0xC4;keymap[keys.pageDown]=0xC5;keymap[keys.home]=0xC6;keymap[keys[\"end\"]]=0xC7;if keys.circumflex or keys.cimcumflex then keymap[keys.circumflex or keys.cimcumflex]=0xC8 end;if keys.at then keymap[keys.at]=0xC9 end;if keys.colon then keymap[keys.colon]=0xCA end;if keys.underscore then keymap[keys.underscore]=0xCB end end;local eR={id=0,name=\"\",coro=coroutine.create(function()end),coroStack={},status=\"starting\",args={\"a\",n=1},filter=function(process,aN,cr)end,paused=false}local eS={id=1,name=\"init\",user=\"root\",dependents={{gc=function()end}},parent=0,dir=\"/\",stdin=TTY[1],stdout={},stderr=TTY[1],cputime=0.2,systime=0.1,debugging=false,allowDebug=true,debugger=nil,breakpoints={},hookf=function()end,env={},syscallyield=nil,eventQueue={},signalHandlers={},paused=false,nice=0,threads={[0]=eR},globalMetatables={}}local eT=1;local function eU(process)local I=createLuaLib(process)if _VERSION<\"Lua 5.2\"then I=make_ENV(I)end;I._G=I;return I end;local eV,eW,debugHooks=coroutine.yield,coroutine.running,debugHooks;local function eX(cr,aF)if cr==\"count\"then eV(\"preempt\")end;local aC=debugHooks[eW()]if aC then if cr==\"count\"and not aC.count then return end;return aC.func(cr,aF)end end;local eY={function(G,...)return load(G:gsub(\"^#![^\\n]+\\n\",\"\"),...)end}function addProcessLoader(eE)table.insert(eY,1,eE)end;function removeProcessLoader(eE)for o,c in ipairs(eY)do if c==eE then table.remove(eY,o)return end end end;function reap_process(process)syslog.debug(\"Reaping process \"..process.id..\" (\"..process.name..\")\")for k,c in ipairs(process.dependents)do c:gc()end;if process.stdin and process.stdin.isTTY then if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)process.stdin.preBuffer=\"\"if discord and process.stdout==currentTTY and process.stdout.frontmostProcess then discord(\"Phoenix\",\"Executing \"..process.stdout.frontmostProcess.name)end else for o,c in ipairs(process.stdin.processList)do if c==process then table.remove(process.stdin.processList,o)break end end end end;if process.stdout and process.stdout.isTTY then if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)else for o,c in ipairs(process.stdout.processList)do if c==process then table.remove(process.stdout.processList,o)break end end end end;if process.stderr and process.stderr.isTTY then if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)else for o,c in ipairs(process.stderr.processList)do if c==process then table.remove(process.stderr.processList,o)break end end end end end;function syscalls.getpid(process,aN)return process.id end;function syscalls.getppid(process,aN)return process.parent end;function syscalls.clock(process,aN)return process.cputime end;function syscalls.getenv(process,aN)return process.vars end;function syscalls.getfenv(process,aN)return process.env end;function syscalls.getname(process,aN)return process.name end;function syscalls.getcwd(process,aN)return process.dir end;function syscalls.chdir(process,aN,cs)expect(1,cs,\"string\")local bZ=filesystem.stat(process,cs)if not bZ or bZ.type~=\"directory\"then return false,\"No such file or directory\"elseif not(bZ.permissions[process.user]or bZ.worldPermissions).execute then return false,\"Permission denied\"end;process.dir=cs:gsub(\"^([^/])\",\"/\"..process.dir..\"/%1\")return true end;function syscalls.getuser(process,aN)return process.user,process.realuser end;function syscalls.setuser(process,aN,bV)expect(1,bV,\"string\")if process.user~=\"root\"then error(\"Permission denied\")end;process.user=bV;process.realuser=nil end;local function eZ(d0)return{[\"nil\"]={},[\"boolean\"]={__unm=function()end},[\"number\"]={},[\"string\"]={__index=d0.string},[\"function\"]={},[\"thread\"]={__index=d0.coroutine,__call=d0.coroutine.resume},[\"userdata\"]={}}end;function syscalls.fork(process,aN,aW,O,...)expect(1,aW,\"function\")expect(2,O,\"string\",\"nil\")local aX=eT;eT=eT+1;processes[aX]={id=aX,name=O or process.name,user=process.user,dependents={},parent=process.id,dir=process.dir,env=nil,root=process.root,stdin=process.stdin,stdout=process.stdout,stderr=process.stderr,vars=deepcopy(process.vars),cputime=0,systime=0,debugging=false,allowDebug=true,breakpoints={},hookf=eX,quantum=args.quantum,syscallyield=nil,eventQueue={},globalMetatables={},signalHandlers={[1]=function()return coroutine.yield(\"syscall\",\"exit\",1)end,[2]=function()return coroutine.yield(\"syscall\",\"exit\",1)end,[3]=function()coroutine.yield(\"syscall\",\"syslog\",{level=\"error\",category=\"Application Error\",traceback=true},debug.traceback(\"Quit\"))return coroutine.yield(\"syscall\",\"exit\",1)end,[6]=function(n)coroutine.yield(\"syscall\",\"syslog\",{level=\"error\",category=\"Application Error\",traceback=true},debug.traceback(n or\"Aborted\"))return coroutine.yield(\"syscall\",\"exit\",1)end,[13]=function()return coroutine.yield(\"syscall\",\"exit\",1)end,[15]=function()return coroutine.yield(\"syscall\",\"exit\",1)end,[19]=function()return coroutine.yield(\"syscall\",\"suspend\")end,[21]=function()return coroutine.yield(\"syscall\",\"suspend\")end,[22]=function()return coroutine.yield(\"syscall\",\"suspend\")end},paused=false,nice=0,threads={[0]={id=0,name=\"<main thread>\",coro=coroutine.create(aW),syscall=coroutine.create(function(...)local args=table.pack(...)while true do args=table.pack(coroutine.yield(kSyscallComplete,xpcall(syscalls[args[1]],debug.traceback,table.unpack(args,2,args.n))))end end),status=\"starting\",args=table.pack(...),filter=nil,coroStack=nil,paused=false}}}processes[aX].threads[0].coroStack={processes[aX].threads[0].coro}processes[aX].env=eU(processes[aX])processes[aX].globalMetatables=eZ(processes[aX].env)setfenv(aW,processes[aX].env)if process.stdin and process.stdin.isTTY and not process.stdin.isLocked then process.stdin.processList[#process.stdin.processList+1]=process.stdin.frontmostProcess;process.stdin.frontmostProcess=processes[aX]process.stdin.preBuffer=\"\"if discord and process.stdout==currentTTY then discord(\"Phoenix\",\"Executing \"..process.name)end end;if process.stdout and process.stdout.isTTY and not process.stdout.isLocked and process.stdout.frontmostProcess~=processes[aX]then process.stdout.processList[#process.stdout.processList+1]=process.stdout.frontmostProcess;process.stdout.frontmostProcess=processes[aX]end;if process.stderr and process.stderr.isTTY and not process.stderr.isLocked and process.stderr.frontmostProcess~=processes[aX]then process.stderr.processList[#process.stderr.processList+1]=process.stderr.frontmostProcess;process.stderr.frontmostProcess=processes[aX]end;if args.preemptive then debug.sethook(processes[aX].threads[0].coro,eX,\"\",processes[aX].quantum)end;return aX end;function syscalls.exec(process,aN,bs,...)expect(1,bs,\"string\")local H,n=filesystem.open(process,bs,\"r\")if not H then bs=bs..\".lua\"H,n=filesystem.open(process,bs,\"r\")if not H then error(\"Could not open file: \"..n,0)end end;local e_=H.readAll()H.close()if e_:find(\"[%z\\1-\\31]\")then H,n=filesystem.open(process,bs,\"rb\")if not H then error(\"Could not open file: \"..n,0)end;e_=H.readAll()H.close()end;local bZ=assert(filesystem.stat(process,bs))if not(bZ.permissions[bZ.owner]or bZ.worldPermissions).execute then error(\"Could not execute file: Permission denied\",0)end;if bZ.setuser then process.env=createLuaLib(process)if process.stdin and not process.stdin.isTTY then process.stdin=nil end;if process.stdout and not process.stdout.isTTY then process.stdout=nil end;if process.stderr and not process.stderr.isTTY then process.stderr=nil end;process.realuser,process.user=process.user,bZ.owner end;if e_:sub(1,2)==\"#!\"and not(e_:match\"^#!/bin/lua\"or e_:match\"^#!/usr/bin/lua\"or e_:match\"^#!/usr/bin/env lua\")then local f0=e_:sub(3,e_:find(\"\\n\")-1)local args,o={},0;for bI in f0:gmatch\"%S+\"do args[o]=bI;o=o+1 end;args[o],o=bs,o+1;for k,c in ipairs{...}do args[o]=c;o=o+1 end;if args[0]==bs then error(\"Recursive path detected while resolving shebang\",0)end;syscalls.exec(process,aN,args[0],table.unpack(args,1,o))process.name=\"/\"..fs.combine(bs:sub(1,1)==\"/\"and\"\"or process.dir,bs)else local aW,n;for k,eE in ipairs(eY)do aW,n=eE(e_,\"@\"..bs,\"bt\",process.env)if aW then break end end;if not aW then error(\"Could not execute file: \"..n,0)end;process.name=\"/\"..fs.combine(bs:sub(1,1)==\"/\"and\"\"or process.dir,bs)process.threads={[0]={id=0,name=\"<main thread>\",coro=coroutine.create(aW),syscall=coroutine.create(function(...)local args=table.pack(...)while true do args=table.pack(coroutine.yield(kSyscallComplete,xpcall(syscalls[args[1]],debug.traceback,table.unpack(args,2,args.n))))end end),status=\"starting\",args=table.pack(...),filter=nil}}process.threads[0].coroStack={process.threads[0].coro}if args.preemptive then debug.sethook(process.threads[0].coro,process.hookf,process.debugging and\"crl\"or\"\",process.quantum)end end;if discord and process.stdin and process.stdin.isTTY and process.stdin.frontmostProcess==process then discord(\"Phoenix\",\"Executing \"..process.name)end end;function syscalls.newthread(process,aN,aW,...)expect(1,aW,\"function\")local aX=#process.threads+1;process.threads[aX]={id=aX,name=\"<thread:\"..aX..\">\",coro=coroutine.create(aW),syscall=coroutine.create(function(...)local args=table.pack(...)while true do args=table.pack(coroutine.yield(kSyscallComplete,xpcall(syscalls[args[1]],debug.traceback,table.unpack(args,2,args.n))))end end),status=\"starting\",args=table.pack(...),filter=nil,coroStack=nil,paused=false}setfenv(aW,process.env)process.threads[aX].coroStack={process.threads[aX].coro}if args.preemptive then debug.sethook(process.threads[aX].coro,process.hookf,process.debugging and\"crl\"or\"\",process.quantum)end;return aX end;function syscalls.exit(process,aN,bK)process.lastReturnValue={pid=process.id,thread=aN.id,value=bK,n=1,bK}for k,aN in pairs(process.threads)do aN.status=\"dead\"aN.return_value=bK end end;function syscalls.atexit(process,aN,J)expect(1,J,\"function\")process.dependents[#process.dependents+1]={gc=function()local aX=syscalls.newthread(process,nil,J)local o=0;while process.threads[aX]and process.threads[aX].coro:status()==\"suspended\"and o<100 do executeThread(process,process.threads[aX],{n=0},false,false)o=o+1 end end}end;function syscalls.getplist(process,aN)local f1={}for F in pairs(processes)do f1[#f1+1]=F end;table.sort(f1)return f1 end;function syscalls.getpinfo(process,aN,dc)expect(1,dc,\"number\")local a1=processes[dc]if not a1 then return nil,\"No such process\"end;local f2,f3,f4;for o,c in ipairs(TTY)do if a1.stdin==c then f2=o end;if a1.stdout==c then f3=o end;if a1.stderr==c then f4=o end end;local f5={}if a1.threads then for o,c in pairs(a1.threads)do f5[o]={id=c.id,name=c.name,status=c.status,paused=c.pause or false}end end;return{id=a1.id,name=a1.name,user=a1.user,realuser=a1.realuser,parent=a1.parent,dir=a1.dir,stdin=f2,stdout=f3,stderr=f4,cputime=a1.cputime or 0,systime=a1.systime or 0,threads=f5,allowDebug=a1.allowDebug,debugging=a1.debugging}end;function syscalls.suspend(process,aN)process.paused=true end;function syscalls.nice(process,aN,C,dc)expect(1,C,\"number\")expect.range(C,-20,20)expect(2,dc,\"number\",\"nil\")if C<0 and process.user~=\"root\"then error(\"Permission denied\",0)end;local eJ=dc and assert(processes[dc],\"Invalid process ID\")or process;if eJ.user~=process.user and process.user~=\"root\"then error(\"Permission denied\",0)end;eJ.nice=C;eJ.quantum=args.quantum*10^(C/-10)if args.preemptive then for k,X in pairs(eJ.threads)do debug.sethook(X.coro,eX,\"\",eJ.quantum)end end end;local function f6(process)local f7,next,f8,getCurrentThread,wakeup=string.find,next,debug.getinfo,getCurrentThread,wakeup;local function f9(cr,aF)if cr==\"count\"then eV(\"preempt\")end;local info=f8(2)local aN=getCurrentThread()for aX,dw in next,process.breakpoints do if dw.type==cr or dw.type==\"call\"and cr==\"tail call\"then local s=dw.thread==nil or dw.thread==aN.id;if dw.filter then for F,c in next,dw.filter do if info[F]~=c then s=false;break end end end;if s then dw.process.eventQueue[#dw.process.eventQueue+1]={\"debug_break\",{process=process.id,thread=aN.id,breakpoint=aX}}wakeup(dw.process)aN.paused=true;eV(\"preempt\")break end end end;while aN.pendingExec do local E=table.pack(pcall(aN.pendingExec))E.ok=table.remove(E,1)E.n=E.n-1;if not E.ok then E.error=E[1]end;E.process=process.id;E.thread=aN.id;local fa=aN.pendingExecProcess.eventQueue;fa[#fa+1]={\"debug_exec_result\",E}wakeup(aN.pendingExecProcess)aN.pendingExec,aN.pendingExecProcess=nil;aN.paused=true;eV(\"preempt\")end;local aC=debugHooks[eW()]if aC then if cr==\"count\"and not aC.count or(cr==\"call\"or cr==\"tail call\")and not f7(aC.mask,\"c\")or cr==\"return\"and not f7(aC.mask,\"r\")or cr==\"line\"and not f7(aC.mask,\"l\")then return end;return aC.func(cr,aF)end end;setfenv(f9,process.env)debug.protect(f9)process.hookf=f9;for k,c in pairs(process.threads)do for k,aB in ipairs(c.coroStack)do debug.sethook(aB,f9,\"clr\",process.quantum)end end end;local function fb(process)for k,c in pairs(process.threads)do c.paused=false;for k,aB in ipairs(c.coroStack)do local aC=debugHooks[aB]debug.sethook(aB,eX,aC and aC.mask or\"\",process.quantum)end end;process.hookf=eX end;function syscalls.debug_enable(process,aN,dc,cG)expect(1,dc,\"number\",\"nil\")expect(2,cG,\"boolean\")local a1;if dc==process.id or dc==nil then a1=process;process.allowDebug=cG else a1=processes[dc]if not a1 then error(\"No such process\")end;if not a1.allowDebug or a1.user~=process.user and process.user~=\"root\"then error(\"Permission denied\")end end;if a1.debugging~=cG then if cG then f6(a1)else fb(a1)end end;a1.debugging=cG;if cG and a1~=process then a1.debugger=process end end;function syscalls.debug_break(process,aN,dc,fc)if dc==nil then if not process.debugger or not processes[process.debugger.id]then return end;process.debugger.eventQueue[#process.debugger.eventQueue+1]={\"debug_break\",{process=process.id,thread=aN.id}}wakeup(process.debugger)aN.paused=true;return end;expect(1,dc,\"number\")expect(2,fc,\"number\",\"nil\")local a1=processes[dc]if not a1 then error(\"No such process\")end;if a1.user~=process.user and process.user~=\"root\"then error(\"Permission denied\")end;if not a1.debugging then error(\"Process does not have debugging enabled\")end;if fc then local X=a1.threads[fc]if not X then error(\"No such thread\")end;if not X.paused then process.eventQueue[#process.eventQueue+1]={\"debug_break\",{process=a1.id,thread=X.id}}end;X.paused=true else for k,X in pairs(a1.threads)do if not X.paused then process.eventQueue[#process.eventQueue+1]={\"debug_break\",{process=a1.id,thread=X.id}}end;X.paused=true end end end;function syscalls.debug_continue(process,aN,dc,fc)expect(1,dc,\"number\")expect(2,fc,\"number\",\"nil\")local a1=processes[dc]if not a1 then error(\"No such process\")end;if a1.user~=process.user and process.user~=\"root\"then error(\"Permission denied\")end;if not a1.debugging then error(\"Process does not have debugging enabled\")end;if fc then local X=a1.threads[fc]if not X then error(\"No such thread\")end;X.paused=false else for k,X in pairs(a1.threads)do X.paused=false end end end;local fd={call=true,[\"return\"]=true,line=true,error=true,resume=true,yield=true}function syscalls.debug_setbreakpoint(process,aN,dc,fc,l,el)expect(1,dc,\"number\")expect(2,fc,\"number\",\"nil\")expect(3,l,\"string\",\"number\")expect(4,el,\"table\",\"nil\")if type(l)~=\"number\"and not fd[l]then error(\"bad argument #3 (invalid option '\"..l..\"')\")end;local a1=processes[dc]if not a1 then error(\"No such process\")end;if a1.user~=process.user and process.user~=\"root\"then error(\"Permission denied\")end;if not a1.debugging then error(\"Process does not have debugging enabled\")end;local aX=#a1.breakpoints+1;a1.breakpoints[aX]={process=process,thread=fc,type=l,filter=el}return aX end;function syscalls.debug_unsetbreakpoint(process,aN,dc,fe)expect(1,dc,\"number\")expect(2,fe,\"number\")local a1=processes[dc]if not a1 then error(\"No such process\")end;if a1.user~=process.user and process.user~=\"root\"then error(\"Permission denied\")end;if not a1.debugging then error(\"Process does not have debugging enabled\")end;a1.breakpoints[fe]=nil end;function syscalls.debug_listbreakpoints(process,aN,dc)expect(1,dc,\"number\")local a1=processes[dc]if not a1 then error(\"No such process\")end;if a1.user~=process.user and process.user~=\"root\"then error(\"Permission denied\")end;if not a1.debugging then error(\"Process does not have debugging enabled\")end;local as={}for aX,dw in pairs(a1.breakpoints)do as[aX]={type=dw.type,thread=dw.thread}if dw.filter then for F,c in pairs(dw.filter)do as[aX][F]=c end end end;return as end;function syscalls.debug_getinfo(process,aN,dc,fc,C,bj)expect(1,dc,\"number\")expect(2,fc,\"number\")expect(3,C,\"number\")expect(4,bj,\"string\",\"nil\")local a1=processes[dc]if not a1 then error(\"No such process\")end;if a1.user~=process.user and process.user~=\"root\"then error(\"Permission denied\")end;if not a1.debugging then error(\"Process does not have debugging enabled\")end;local X=a1.threads[fc]if not X then error(\"No such thread\")end;return debug.getinfo(X.coroStack[#X.coroStack],C,bj)end;function syscalls.debug_getlocal(process,aN,dc,fc,C,S)expect(1,dc,\"number\")expect(2,fc,\"number\")expect(3,C,\"number\")expect(4,S,\"number\")local a1=processes[dc]if not a1 then error(\"No such process\")end;if a1.user~=process.user and process.user~=\"root\"then error(\"Permission denied\")end;if not a1.debugging then error(\"Process does not have debugging enabled\")end;local X=a1.threads[fc]if not X then error(\"No such thread\")end;return debug.getlocal(X.coroStack[#X.coroStack],C,S)end;function syscalls.debug_getupvalue(process,aN,dc,fc,C,S)expect(1,dc,\"number\")expect(2,fc,\"number\")expect(3,C,\"number\")expect(4,S,\"number\")local a1=processes[dc]if not a1 then error(\"No such process\")end;if a1.user~=process.user and process.user~=\"root\"then error(\"Permission denied\")end;if not a1.debugging then error(\"Process does not have debugging enabled\")end;local X=a1.threads[fc]if not X then error(\"No such thread\")end;local info=debug.getinfo(X.coroStack[#X.coroStack],C,\"f\")if not info then error(\"bad argument #3 (level out of range)\")end;return debug.getupvalue(info.func,S)end;function syscalls.debug_exec(process,aN,dc,fc,J)expect(1,dc,\"number\")expect(2,fc,\"number\")expect(3,J,\"function\")local a1=processes[dc]if not a1 then error(\"No such process\")end;if a1.user~=process.user and process.user~=\"root\"then error(\"Permission denied\")end;if not a1.debugging then error(\"Process does not have debugging enabled\")end;local X=a1.threads[fc]if not X then error(\"No such thread\")end;if not X.paused then error(\"Thread is not paused\")end;setfenv(J,a1.env)X.pendingExec=J;X.pendingExecProcess=process;X.paused=false end;local function ff(t)t=t..\"\\x80\"..(\"\\0\"):rep(-(#t+9)%64)..(\">I8\"):pack(#t)local fg,fh,fi,fj,fk,aB=0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476,0xC3D2E1F0,{}for fl=1,#t,64 do local fm=fl;for o=0,15 do aB[o]=t:byte(fm)*0x1000000+t:byte(fm+1)*0x10000+t:byte(fm+2)*0x100+t:byte(fm+3)fm=fm+4 end;for o=16,79 do aB[o]=bit32.lrotate(bit32.bxor(aB[o-3],aB[o-8],aB[o-14],aB[o-16]),1)end;local cM,ax,G,bG,a7=fg,fh,fi,fj,fk;for o=0,79 do local f,F;if o<=19 then f,F=bit32.bxor(bG,bit32.band(ax,bit32.bxor(G,bG))),0x5A827999 elseif o<=39 then f,F=bit32.bxor(ax,G,bG),0x6ED9EBA1 elseif o<=59 then f,F=bit32.bor(bit32.band(ax,bit32.bor(G,bG)),bit32.band(G,bG)),0x8F1BBCDC else f,F=bit32.bxor(ax,G,bG),0xCA62C1D6 end;local fn=bit32.band(bit32.lrotate(cM,5)+f+a7+F+aB[o],0xFFFFFFFF)a7,bG,G,ax,cM=bG,G,bit32.lrotate(ax,30),cM,fn end;fg=bit32.band(fg+cM,0xFFFFFFFF)fh=bit32.band(fh+ax,0xFFFFFFFF)fi=bit32.band(fi+G,0xFFFFFFFF)fj=bit32.band(fj+bG,0xFFFFFFFF)fk=bit32.band(fk+a7,0xFFFFFFFF)end;return{fg,fh,fi,fj,fk}end;local function fo(fp,O)local fq=ff(fp:gsub(\"%X\",\"\"):gsub(\"%x%x\",function(bI)return string.char(tonumber(bI,16))end)..O)local cM,ax,G,bG=fq[1],bit32.bor(bit32.band(fq[2],0xFFFF0FFF),0x5000),bit32.bor(bit32.band(fq[3],0x3FFFFFFF),0x80000000),fq[4]return(\"%08x-%04x-%04x-%04x-%04x%08x\"):format(cM,bit32.rshift(ax,16),bit32.band(ax,0xFFFF),bit32.rshift(G,16),bit32.band(G,0xFFFF),bG)end;local fr=\"a6f53b7d-50f3-4e51-adef-8728c83e3f3a\"deviceTreeRoot={id=tostring(os.getComputerID()),uuid=fo(fr,tostring(os.getComputerID())),parent=nil,displayName=os.getComputerLabel()or\"\",drivers={},metadata={},internalState={},children={},listeners=setmetatable({},{__mode=\"k\"})}local ft={[deviceTreeRoot.uuid]=deviceTreeRoot}local fu={}function hardware.get(bs)expect(1,bs,\"string\")if bs:find(\"^%x+%-%x+%-%x+%-%x+%-%x+$\")then return ft[bs]elseif bs==\"\"or bs:find(\"/\")then local eb=deviceTreeRoot;for O in bs:gmatch\"[^/]+\"do eb=eb.children[O]if eb==nil then break end end;return eb else local fv={}local function fw(eb)if eb.id==bs or eb.alias==bs then fv[#fv+1]=eb end;for k,c in pairs(eb.children)do fw(c)end end;fw(deviceTreeRoot)return table.unpack(fv)end end;function hardware.find(type)expect(1,type,\"string\")local ea={}local function fx(eb)for k,c in ipairs(eb.drivers)do if c.type==type then ea[#ea+1]=eb;break end end;for k,c in pairs(eb.children)do fx(c)end end;fx(deviceTreeRoot)return table.unpack(ea)end;function hardware.path(eb)expect(1,eb,\"table\")expect.field(eb,\"uuid\",\"string\")if not ft[eb.uuid]then error(\"bad argument #1 (invalid node)\",2)end;local bs=eb.id;eb=eb.parent;while eb do bs=eb.id..\"/\"..bs;eb=eb.parent end;bs=bs:gsub(\"^[^/]+\",\"\")return bs==\"\"and\"/\"or bs end;function hardware.add(ch,O)expect(1,ch,\"table\")expect(2,O,\"string\")expect.field(ch,\"uuid\",\"string\")if not ft[ch.uuid]then return nil,\"Invalid parent node\"end;if ch.children[O]then return nil,\"Node already exists\"end;local eb={id=O,uuid=fo(ch.uuid,O),parent=ch,displayName=\"\",drivers={},metadata={},internalState={},children={},listeners=setmetatable({},{__mode=\"k\"})}ch.children[O]=eb;ft[eb.uuid]=eb;syslog.log({module=\"Hardware\"},\"Added new device at \"..hardware.path(eb))for k,c in ipairs(fu)do if(not c.parent or c.parent==ch)and(not c.pattern or O:match(c.pattern))then c.callback(eb)end end;return eb end;function hardware.remove(eb)expect(1,eb,\"table\")expect.field(eb,\"uuid\",\"string\")if not ft[eb.uuid]then return false,\"Invalid node\"end;if eb==deviceTreeRoot or not eb.parent then return false,\"Cannot remove root node\"end;for o=#eb.drivers,1,-1 do hardware.deregister(eb,eb.drivers[o])end;for k,c in pairs(eb.children)do hardware.remove(c)end;syslog.log({module=\"Hardware\"},\"Device at \"..hardware.path(eb)..\" has been removed\")eb.parent.children[eb.id]=nil;ft[eb.uuid]=nil;eb.parent=nil;return true end;function hardware.register(eb,fy)expect(1,eb,\"table\")expect(2,fy,\"table\")expect.field(eb,\"uuid\",\"string\")expect.field(fy,\"name\",\"string\")expect.field(fy,\"type\",\"string\")expect.field(fy,\"properties\",\"table\")expect.field(fy,\"methods\",\"table\")expect.field(fy,\"init\",\"function\",\"nil\")expect.field(fy,\"deinit\",\"function\",\"nil\")for F in pairs(fy.methods)do if type(F)~=\"string\"then error(\"bad method name '\"..tostring(F)..\"' (not a string)\",2)end;expect.field(fy.methods,F,\"function\")end;for k,c in ipairs(fy.properties)do if type(c)~=\"string\"then error(\"bad property name '\"..tostring(c)..\"' (not a string)\",2)end;if not fy.methods[\"get\"..c:sub(1,1):upper()..c:sub(2)]then error(\"bad property '\"..c..\"' (no getter present)\",2)end end;if not ft[eb.uuid]then error(\"bad argument #1 (invalid node)\",2)end;for k,c in ipairs(eb.drivers)do if c==fy then return false end end;eb.drivers[#eb.drivers+1]=fy;syslog.log({module=\"Hardware\"},\"Registered device with type \"..fy.type..\" on device \"..hardware.path(eb)..\" using driver \"..fy.name)if fy.init then fy.init(eb)end;return true end;function hardware.register_callback(fy)return function(eb)return hardware.register(eb,fy)end end;function hardware.deregister(eb,fy)expect(1,eb,\"table\")expect(2,fy,\"table\")expect.field(eb,\"uuid\",\"string\")if not ft[eb.uuid]then error(\"bad argument #1 (invalid node)\",2)end;for o,c in ipairs(eb.drivers)do if c==fy then if fy.deinit then fy.deinit(eb)end;table.remove(eb.drivers,o)syslog.log({module=\"Hardware\"},\"Driver \"..fy.name..\" has been deregistered from device \"..hardware.path(eb))return true end end;return false end;function hardware.listen(fz,ch,fA)expect(1,fz,\"function\")expect(2,ch,\"table\",\"nil\")expect(3,fA,\"string\",\"nil\")if ch then expect.field(ch,\"uuid\",\"string\")end;if fA and not pcall(string.match,\"\",fA)then error(\"bad argument #3 (invalid pattern)\",2)end;fu[#fu+1]={callback=fz,parent=ch,pattern=fA}end;function hardware.unlisten(fz)expect(1,fz,\"function\")local o=1;while o<#fu do if fu[o].callback==fz then table.remove(fu,o)else o=o+1 end end end;function hardware.broadcast(eb,cr,df)expect(1,eb,\"table\")expect(2,cr,\"string\")expect(3,df,\"table\")expect.field(eb,\"uuid\",\"string\")if not ft[eb.uuid]then error(\"bad argument #1 (invalid node)\",2)end;for c in pairs(eb.listeners)do c.eventQueue[#c.eventQueue+1]={cr,df}wakeup(c)end end;function hardware.call(process,eb,fB,...)for k,fy in ipairs(eb.drivers)do if fy.methods[fB]then return fy.methods[fB](eb,process,...)end end;error(\"No such method\",2)end;function syscalls.devlookup(process,aN,O)expect(1,O,\"string\")local fC={hardware.get(O)}for F,c in ipairs(fC)do fC[F]=hardware.path(c)end;return table.unpack(fC)end;function syscalls.devfind(process,aN,type)expect(1,type,\"string\")local fC={hardware.find(type)}for F,c in ipairs(fC)do fC[F]=hardware.path(c)end;return table.unpack(fC)end;function syscalls.devinfo(process,aN,fD)expect(1,fD,\"string\")local eb=hardware.get(fD)if not eb then return nil end;local m={}for k,c in ipairs(eb.drivers)do m[c.type]=c.name end;return{id=eb.id,uuid=eb.uuid,alias=eb.alias,parent=eb.parent and hardware.path(eb.parent)or\"/\",displayName=eb.displayName,types=m,metadata=deepcopy(eb.metadata)}end;function syscalls.devalias(process,aN,fD,fE)expect(1,fD,\"string\")expect(2,fE,\"string\",\"nil\")local eb=hardware.get(fD)if not eb then error(\"No such device\",2)end;eb.alias=fE end;function syscalls.devmethods(process,aN,fD)expect(1,fD,\"string\")local eb=hardware.get(fD)if not eb then error(\"No such device\",2)end;local fF={}for k,c in ipairs(eb.drivers)do for F in pairs(c.methods)do fF[#fF+1]=F end end;return fF end;function syscalls.devproperties(process,aN,fD)expect(1,fD,\"string\")local eb=hardware.get(fD)if not eb then error(\"No such device\",2)end;local fG={}for k,c in ipairs(eb.drivers)do for k,F in pairs(c.properties)do fG[#fG+1]=F end end;return fG end;function syscalls.devchildren(process,aN,fD)expect(1,fD,\"string\")local eb=hardware.get(fD)if not eb then error(\"No such device\",2)end;local fH={}for F in pairs(eb.children)do fH[#fH+1]=F end;return fH end;function syscalls.devcall(process,aN,fD,fB,...)expect(1,fD,\"string\")expect(2,fB,\"string\")local eb=hardware.get(fD)if not eb then error(\"No such device\",2)end;if eb.process and eb.process~=process.id then error(\"Device is locked\",2)end;return hardware.call(process,eb,fB,...)end;function syscalls.devlisten(process,aN,fD,dP)expect(1,fD,\"string\")expect(2,dP,\"boolean\",\"nil\")if dP==nil then dP=true end;local eb=hardware.get(fD)if not eb then error(\"No such device\",2)end;if dP then for k,c in ipairs(eb.listeners)do if c==process then return end end;eb.listeners[process]=true;process.dependents[#process.dependents+1]={type=\"hardware listen\",node=eb,gc=function()eb.listeners[process]=nil end}else eb.listeners[process]=nil;for o,c in ipairs(process.dependents)do if c.type==\"hardware listen\"and c.node==eb then table.remove(process.dependents,o)break end end end end;function syscalls.devlock(process,aN,fD,fI)expect(1,fD,\"string\")expect(2,fI,\"boolean\",\"nil\")if fI==nil then fI=true end;local eb=hardware.get(fD)if not eb then error(\"No such device\",2)end;if eb.process==nil then eb.process=process.id;process.dependents[#process.dependents+1]={type=\"hardware lock\",node=eb,gc=function()eb.process=nil end}return true elseif eb.process==process.id then return true elseif fI then aN.filter=function(process,aN)return eb.process==nil or eb.process==process.id end;return kSyscallYield,\"devlock\",fD,true else return false end end;function syscalls.devunlock(process,aN,fD)expect(1,fD,\"string\")local eb=hardware.get(fD)if not eb then error(\"No such device\",2)end;if eb.process and eb.process~=process.id then error(\"Device is locked\",2)end;eb.process=nil;for o,c in ipairs(process.dependents)do if c.type==\"hardware lock\"and c.node==eb then table.remove(process.dependents,o)break end end end;function syscalls.version(process,aN,fJ)if fJ then return PHOENIX_BUILD else return PHOENIX_VERSION end end;function syscalls.cchost(process,aN)return _HOST end;function syscalls.uptime(process,aN)return(os.epoch\"utc\"-systemStartTime)/1000 end;function syscalls.attach(process,aN,fK,_type,...)if process.user~=\"root\"then error(\"Permission denied\")end;expect(1,fK,\"string\",\"number\")expect(2,_type,\"string\")local s,n;if periphemu then s=periphemu.create(fK,_type,...)elseif ccemux then if type(fK)==\"number\"then fK=_type..\"_\"..fK end;if _type==\"drive\"then _type=\"disk_drive\"elseif _type==\"modem\"then _type=\"wireless_modem\"end;if _type==\"computer\"then local aX=tonumber(fK:match(\"%d+\"))if aX then s,n=pcall(ccemux.openEmu,aX)else s,n=false,\"Invalid side\"end else s,n=pcall(ccemux.attach,fK,_type,...)end else s,n=false,\"Operation not supported\"end;return s,n end;function syscalls.detach(process,aN,fK)if process.user~=\"root\"then error(\"Permission denied\")end;expect(1,fK,\"string\",\"number\")local s,n;if periphemu then s=periphemu.remove(fK)elseif ccemux then if type(fK)==\"number\"then fK=_type..\"_\"..fK end;s,n=pcall(ccemux.detach,fK)else s,n=false,\"Operation not supported\"end;return s,n end;function syscalls.kernargs(process,aN)return deepcopy(args)end;local fL=0;function syscalls.lockmutex(process,aN,fM)expect(1,fM,\"table\")while fM.owner~=nil and fM.owner~=aN.id or fM.pid~=nil and fM.pid~=process.id do coroutine.yield()end;if fM.owner then if type(fM.recursive)==\"number\"then fM.recursive=fM.recursive+1;return else error(\"cannot recursively lock mutex\",0)end end;fM.owner=aN.id;fM.pid=process.id;if fM.recursive then fM.recursive=1 end end;function syscalls.__timeout_check(process,aN,info)if info.timeout then return false end;return syscalls[info.call](process,aN,info.object,0)end;function syscalls.timelockmutex(process,aN,fM,eL)expect(1,fM,\"table\")expect(2,eL,\"number\")if fM.owner then if fM.owner~=aN.id then local fN=os.startTimer(eL)local info={object=fM,timeout=false,call=\"timelockmutex\"}aN.filter=function(process,aN,aO)if aO[1]==\"timer\"and aO[2].id==fN then info.timeout=true;return true end;return fM.owner==nil or fM.owner==aN.id end;return kSyscallYield,\"__timeout_check\",info elseif type(fM.recursive)==\"number\"then fM.recursive=fM.recursive+1 else error(\"cannot recursively lock mutex\",0)end else fM.owner=aN.id;if fM.recursive then fM.recursive=1 end end;return true end;function syscalls.unlockmutex(process,aN,fM)expect(1,fM,\"table\")if fM.owner==aN.id and fM.pid==process.id then if type(fM.recursive)==\"number\"then fM.recursive=fM.recursive-1;if fM.recursive<=0 then fM.owner=nil end else fM.owner,fM.pid=nil end elseif fM.owner==nil then error(\"mutex already unlocked\",0)else error(\"mutex not locked by current thread\")end end;function syscalls.trylockmutex(process,aN,fM)expect(1,fM,\"table\")if fM.owner then if fM.owner~=aN.id or fM.pid~=process.id then return false elseif type(fM.recursive)==\"number\"then fM.recursive=fM.recursive+1;return true else error(\"cannot recursively lock mutex\",0)end else fM.owner=aN.id;fM.pid=process.id;if fM.recursive then fM.recursive=1 end;return true end end;function syscalls.acquiresemaphore(process,aN,fO)expect(1,fO,\"table\")expect.field(fO,\"count\",\"number\")while fO.count<=0 do coroutine.yield()end;fO.count=fO.count-1 end;function syscalls.timeacquiresemaphore(process,aN,fO,eL)expect(1,fO,\"table\")expect.field(fO,\"count\",\"number\")expect(2,eL,\"number\")if fO.count<=0 then local fN=os.startTimer(eL)local info={object=fO,timeout=false,call=\"timeacquiresemaphore\"}aN.filter=function(process,aN,aO)if aO[1]==\"timer\"and aO[2].id==fN then info.timeout=true;return true end;return type(fO.count)~=\"number\"or fO.count>0 end;return kSyscallYield,\"__timeout_check\",info end;fO.count=fO.count-1;return true end;function syscalls.releasesemaphore(process,aN,fO)expect(1,fO,\"table\")expect.field(fO,\"count\",\"number\")fO.count=fO.count+1 end;local fP={name=\"root\",type=\"computer\",properties={\"label\",\"id\"},methods={getLabel=function()end,setLabel=function(fQ)end,getId=function()end,shutdown=function()end,reboot=function()end},init=function(eb)end,deinit=function(eb)end}local fR={top=true,bottom=true,left=true,right=true,front=true,back=true}local fS={}function getNodeById(O)if fR[O]then if deviceTreeRoot.children[O]then return deviceTreeRoot.children[O]end else for F in pairs(fR)do if peripheral.getType(F)==\"modem\"and not peripheral.call(F,\"isWireless\")and deviceTreeRoot.children[F]and deviceTreeRoot.children[F].children[O]then return deviceTreeRoot.children[F].children[O]end end end end;local function fT(self)self.internalState.peripheral=self.internalState.peripheral or{}if not self.internalState.peripheral.call then self.internalState.peripheral.call=peripheral.call end;if self.internalState.peripheral.call==peripheral.call or not self.parent then self.internalState.peripheral.getMethods=peripheral.getMethods else self.internalState.peripheral.getMethods=function(aX)return peripheral.call(self.parent.id,\"getMethodsRemote\",aX)end end end;local function fU(process,j)j.__metatable={}for k,c in pairs(j)do setfenv(c,process.env)debug.protect(c)end;return setmetatable({},j)end;local function fV(fy,type)return function(eb)local m,J;if eb.parent==deviceTreeRoot then m,J={peripheral.getType(eb.id)},peripheral.call else m,J={peripheral.call(eb.parent.id,\"getTypeRemote\",eb.id)},function(...)return peripheral.call(eb.parent.id,\"callRemote\",...)end end;for k,c in ipairs(m)do if c==type then eb.internalState.peripheral={call=J}return hardware.register(eb,fy)end end end end;local function fW(type)return hardware.listen(fV(fS[\"peripheral_\"..type],type),deviceTreeRoot)end;local function fX(fB)return function(self)return self.internalState.peripheral.call(self.id,fB)end end;local function fY(fB)return function(self,process)if process.user~=\"root\"then error(\"Permission denied\",0)end;return self.internalState.peripheral.call(self.id,fB)end end;local function fZ(fB)return function(...)local m={...}return function(self,process,g)expect(1,g,table.unpack(m))return self.internalState.peripheral.call(self.id,fB,g)end end end;local function f_(fB)return function(...)local m={...}return function(self,process,g)expect(1,g,table.unpack(m))if process.user~=\"root\"then error(\"Permission denied\",0)end;return self.internalState.peripheral.call(self.id,fB,g)end end end;local function g0()syslog.log(\"Sending SIGTERM to all processes\")local g1=false;for dc,process in pairs(processes)do if dc~=0 then killProcess(dc,15)local g2,aO=false,nil;local aP=true;for fc,aN in pairs(process.threads)do if not g2 and aN.status==\"suspended\"then aO=table.remove(process.eventQueue,1)g2=true end;if aO or aN.status~=\"suspended\"then aP=executeThread(process,aN,aO or{n=0},aP,true)else aP=false end end;if aP then process.isDead=true;if process.parent~=0 and processes[process.parent]then processes[process.parent].eventQueue[#processes[process.parent].eventQueue+1]={\"process_complete\",process.lastReturnValue}wakeup(processes[process.parent])end;reap_process(process)processes[dc]=nil else g1=true end end end;terminal.redraw(currentTTY)if g1 then syslog.log(\"Sending SIGKILL to all processes\")for dc in pairs(processes)do if dc~=0 then killProcess(dc,9)end end end end;fS.root={name=\"root\",type=\"computer\",properties={\"isOn\",\"label\"},methods={}}function fS.root.methods:getIsOn(process)return true end;function fS.root.methods:getLabel(process)return os.getComputerLabel()end;function fS.root.methods:setLabel(process,fQ)expect(1,fQ,\"string\",\"nil\")os.setComputerLabel(fQ)end;function fS.root.methods:turnOn(process)end;function fS.root.methods:shutdown(process,as)if process.user~=\"root\"then error(\"Permission denied\",2)end;syslog.log(\"System is shutting down.\")function postkill()hardware.deregister(deviceTreeRoot,fS.root)syslog.log(\"Halting system\")for k,c in ipairs(shutdownHooks)do c()end;os.shutdown(as)mainThread=nil;while true do coroutine.yield()end end;g0()end;function fS.root.methods:reboot(process)if process.user~=\"root\"then error(\"Permission denied\",2)end;syslog.log(\"System is restarting.\")function postkill()hardware.deregister(deviceTreeRoot,fS.root)syslog.log(\"Rebooting system\")for k,c in ipairs(shutdownHooks)do c()end;os.reboot()mainThread=nil;while true do coroutine.yield()end end;g0()end;function fS.root:init()local g3=hardware.add(self,\"redstone\")for k,c in ipairs{\"top\",\"bottom\",\"left\",\"right\",\"front\",\"back\"}do local bG=hardware.add(g3,c)bG.internalState.redstone={side=c}hardware.register(bG,fS.root_redstone)end;hardware.register(hardware.add(deviceTreeRoot,\"lo\"),fS.loopback_modem)registerLoopback()for c in pairs(fR)do if peripheral.isPresent(c)then hardware.add(self,c)end end;self.displayName=os.getComputerLabel()self.metadata.id=os.getComputerID()end;function fS.root:deinit()for c in pairs(fR)do if peripheral.isPresent(c)and self.children[c]then hardware.remove(self.children[c])end end;hardware.remove(hardware.get(\"/lo\"))hardware.remove(hardware.get(\"/redstone\"))end;eventHooks.peripheral=eventHooks.peripheral or{}eventHooks.peripheral[#eventHooks.peripheral+1]=function(aO)if fR[aO[2]]then local eb,n=hardware.add(deviceTreeRoot,aO[2])if eb then hardware.broadcast(deviceTreeRoot,\"device_added\",{device=hardware.path(eb)})else syslog.log({level=\"error\",module=\"Hardware\"},\"Could not create new device: \"..n)end else for F in pairs(fR)do if peripheral.getType(F)==\"modem\"and not peripheral.call(F,\"isWireless\")and peripheral.call(F,\"isPresentRemote\",aO[2])then if not deviceTreeRoot.children[F]then hardware.add(deviceTreeRoot,F)end;local eb,n=hardware.add(deviceTreeRoot.children[F],aO[2])if eb then hardware.broadcast(deviceTreeRoot.children[F],\"device_added\",{device=hardware.path(eb)})else syslog.log({level=\"error\",module=\"Hardware\"},\"Could not create new device: \"..n)end;break end end end end;eventHooks.peripheral_detach=eventHooks.peripheral_detach or{}eventHooks.peripheral_detach[#eventHooks.peripheral_detach+1]=function(aO)local eb=getNodeById(aO[2])if not eb then syslog.log({level=\"notice\",module=\"Hardware\"},\"Received \"..aO[1]..\" event for device ID \"..aO[2]..\", but no device node was found; ignoring\")return end;local bs,ch=hardware.path(eb),eb.parent;hardware.remove(eb)hardware.broadcast(ch,\"device_removed\",{device=bs})end;rootDriver=fS.root;fS.root_redstone={name=\"root_redstone\",type=\"redstone\",properties={\"input\",\"output\",\"bundledInput\",\"bundledOutput\"},methods={}}local function g4(S)if S==0 then return nil else return S end end;function fS.root_redstone.methods:getInput()return g4(redstone.getAnalogInput(self.internalState.redstone.side))end;function fS.root_redstone.methods:getOutput()return g4(redstone.getAnalogOutput(self.internalState.redstone.side))end;function fS.root_redstone.methods:setOutput(process,S)S=expect(1,S,\"number\",\"boolean\",\"nil\")or 0;if S==false then S=0 elseif S==true then S=15 end;expect.range(S,0,15)redstone.setAnalogOutput(self.internalState.redstone.side,S)end;function fS.root_redstone.methods:getBundledInput()return redstone.getBundledInput(self.internalState.redstone.side)end;function fS.root_redstone.methods:getBundledOutput()return redstone.getBundledOutput(self.internalState.redstone.side)end;function fS.root_redstone.methods:setBundledOutput(process,S)expect(1,S,\"number\")expect.range(S,0,65535)redstone.setBundledOutput(self.internalState.redstone.side,S)end;function fS.root_redstone:init()if not self.internalState.redstone or not self.internalState.redstone.side then error(\"No assigned side on redstone device!\",2)end;self.displayName=\"Redstone I/O on side \"..self.internalState.redstone.side end;fS.peripheral_command={name=\"peripheral_command\",type=\"command\",properties={\"command\"},methods={}}fS.peripheral_command.methods.getCommand=fY\"getCommand\"fS.peripheral_command.methods.setCommand=f_\"setCommand\"(\"string\")fS.peripheral_command.methods.run=fY\"runCommand\"function fS.peripheral_command:init()fT(self)self.displayName=\"Command block at \"..self.id end;fW\"command\"fS.peripheral_computer={name=\"peripheral_computer\",type=\"computer\",properties={\"isOn\",\"label\"},methods={}}fS.peripheral_computer.methods.getIsOn=fX\"isOn\"fS.peripheral_computer.methods.getLabel=fX\"getLabel\"fS.peripheral_computer.methods.turnOn=fY\"turnOn\"fS.peripheral_computer.methods.shutdown=fY\"shutdown\"fS.peripheral_computer.methods.reboot=fY\"reboot\"function fS.peripheral_command:init()fT(self)local fQ=self.internalState.peripheral.call(self.id,\"getLabel\")self.metadata.id=self.internalState.peripheral.call(self.id,\"getID\")self.displayName=(fQ or\"Computer \"..self.metadata.id)..\" at \"..self.id end;fW\"computer\"hardware.listen(fV(fS[\"peripheral_computer\"],\"turtle\"),deviceTreeRoot)fS.peripheral_drive={name=\"peripheral_drive\",type=\"drive\",properties={\"state\",\"label\"},methods={}}function fS.peripheral_drive.methods:getState(process)if not self.internalState.peripheral.call(self.id,\"isDiskPresent\")then return nil end;return{audio=self.internalState.peripheral.call(self.id,\"getAudioTitle\")or nil,label=self.internalState.peripheral.call(self.id,\"getDiskLabel\"),id=self.internalState.peripheral.call(self.id,\"getDiskID\")}end;fS.peripheral_drive.methods.getLabel=fX\"getDiskLabel\"fS.peripheral_drive.methods.setLabel=fZ\"setDiskLabel\"(\"string\",\"nil\")fS.peripheral_drive.methods.getMountPath=fX\"getMountPath\"function fS.peripheral_drive.methods:play(process)if not self.internalState.peripheral.call(self.id,\"hasAudio\")then error(\"Inserted disk is not an audio disc\",2)end;return self.internalState.peripheral.call(self.id,\"playAudio\")end;fS.peripheral_drive.methods.stop=fX\"stopAudio\"fS.peripheral_drive.methods.eject=fX\"ejectDisk\"fS.peripheral_drive.methods.insert=f_\"insertDisk\"(\"string\")function fS.peripheral_drive:init()fT(self)self.displayName=(self.internalState.peripheral.call(self.id,\"getDiskLabel\")or\"No disk\")..\" on drive \"..self.id end;fW\"drive\"eventHooks.disk=eventHooks.disk or{}eventHooks.disk[#eventHooks.disk+1]=function(aO)local eb=getNodeById(aO[2])if not eb then syslog.log({level=\"notice\",module=\"Hardware\"},\"Received \"..aO[1]..\" event for device ID \"..aO[2]..\", but no device node was found; ignoring\")return end;hardware.broadcast(eb,\"disk\",{device=hardware.path(eb)})end;eventHooks.disk_eject=eventHooks.disk_eject or{}eventHooks.disk_eject[#eventHooks.disk_eject+1]=function(aO)local eb=getNodeById(aO[2])if not eb then syslog.log({level=\"notice\",module=\"Hardware\"},\"Received \"..aO[1]..\" event for device ID \"..aO[2]..\", but no device node was found; ignoring\")return end;hardware.broadcast(eb,\"disk_eject\",{device=hardware.path(eb)})end;fS.peripheral_energy_storage={name=\"peripheral_energy_storage\",type=\"energy_storage\",properties={\"energy\"},methods={}}fS.peripheral_energy_storage.methods.getEnergy=fX\"getEnergy\"function fS.peripheral_energy_storage:init()fT(self)self.displayName=\"Energy storage block at \"..self.id;self.metadata.capacity=self.internalState.peripheral.call(self.id,\"getEnergyCapacity\")end;fW\"energy_storage\"fS.peripheral_fluid_storage={name=\"peripheral_fluid_storage\",type=\"fluid_storage\",properties={\"tanks\"},methods={}}fS.peripheral_fluid_storage.methods.getTanks=fX\"tanks\"function fS.peripheral_fluid_storage.methods:push(process,c8,g5,O)expect(1,c8,\"string\")expect(2,g5,\"number\",\"nil\")expect(3,O,\"string\",\"nil\")local eJ;local g6={hardware.get(c8)}if#g6==1 then eJ=g6[1]else for k,c in ipairs(g6)do if c.parent==self.parent then eJ=c;break end end end;if not eJ then error(\"No such device\",0)elseif eJ.parent~=self.parent then error(\"Devices must be on the same network\",0)end;local s=false;for k,c in ipairs(eJ.drivers)do if c==fS.peripheral_fluid_storage then s=true;break end end;if not s then error(\"Target device is not a fluid storage block\",0)end;return self.internalState.peripheral.call(self.id,\"pushFluid\",eJ.id,g5,O)end;function fS.peripheral_fluid_storage.methods:pull(process,c7,g5,O)expect(1,c7,\"string\")expect(2,g5,\"number\",\"nil\")expect(3,O,\"string\",\"nil\")local eJ;local g6={hardware.get(c7)}if#g6==1 then eJ=g6[1]else for k,c in ipairs(g6)do if c.parent==self.parent then eJ=c;break end end end;if not eJ then error(\"No such device\",0)elseif eJ.parent~=self.parent then error(\"Devices must be on the same network\",0)end;local s=false;for k,c in ipairs(eJ.drivers)do if c==fS.peripheral_fluid_storage then s=true;break end end;if not s then error(\"Target device is not a fluid storage block\",0)end;return self.internalState.peripheral.call(self.id,\"pullFluid\",eJ.id,g5,O)end;function fS.peripheral_fluid_storage:init()fT(self)self.displayName=\"Fluid storage block at \"..self.id end;fW\"fluid_storage\"fS.peripheral_inventory={name=\"peripheral_inventory\",type=\"inventory\",properties={\"items\"},methods={}}fS.peripheral_inventory.methods.getItems=fX\"list\"fS.peripheral_inventory.methods.detail=fZ\"getItemDetail\"(\"number\")fS.peripheral_inventory.methods.limit=fZ\"getItemLimit\"(\"number\")function fS.peripheral_inventory.methods:push(process,c8,g7,g5,g8)expect(1,c8,\"string\")expect(2,g7,\"number\")expect(3,g5,\"number\",\"nil\")expect(4,g8,\"number\",\"nil\")local eJ;local g6={hardware.get(c8)}if#g6==1 then eJ=g6[1]else for k,c in ipairs(g6)do if c.parent==self.parent then eJ=c;break end end end;if not eJ then error(\"No such device\",0)elseif eJ.parent~=self.parent then error(\"Devices must be on the same network\",0)end;local s=false;for k,c in ipairs(eJ.drivers)do if c==fS.peripheral_inventory then s=true;break end end;if not s then error(\"Target device is not an inventory block\",0)end;return self.internalState.peripheral.call(self.id,\"pushItems\",eJ.id,g7,g5,g8)end;function fS.peripheral_inventory.methods:pull(process,c7,g7,g5,g8)expect(1,c7,\"string\")expect(2,g7,\"number\")expect(3,g5,\"number\",\"nil\")expect(4,g8,\"number\",\"nil\")local eJ;local g6={hardware.get(c7)}if#g6==1 then eJ=g6[1]else for k,c in ipairs(g6)do if c.parent==self.parent then eJ=c;break end end end;if not eJ then error(\"No such device\",0)elseif eJ.parent~=self.parent then error(\"Devices must be on the same network\",0)end;local s=false;for k,c in ipairs(eJ.drivers)do if c==fS.peripheral_inventory then s=true;break end end;if not s then error(\"Target device is not an inventory block\",0)end;return self.internalState.peripheral.call(self.id,\"pullItems\",eJ.id,g7,g5,g8)end;function fS.peripheral_inventory:init()fT(self)self.displayName=\"Inventory at \"..self.id;self.metadata.size=self.internalState.peripheral.call(self.id,\"size\")end;fW\"inventory\"fS.peripheral_monitor={name=\"peripheral_monitor\",type=\"monitor\",properties={\"scale\",\"size\"},methods={}}fS.peripheral_monitor.methods.getScale=fX\"getTextScale\"fS.peripheral_monitor.methods.setScale=fZ\"setTextScale\"(\"number\")function fS.peripheral_monitor.methods:getSize()local aB,aC=self.internalState.peripheral.call(self.id,\"getSize\")return{width=aB,height=aC}end;function fS.peripheral_monitor.methods:write(process,...)for o,c in ipairs{...}do if o>1 then terminal.write(self.internalState.tty,\"\\t\")end;terminal.write(self.internalState.tty,c)end;terminal.redraw(self.internalState.tty)end;function fS.peripheral_monitor.methods:termctl(process,dT)expect(1,dT,\"table\",\"nil\")if dT then expect.field(dT,\"cbreak\",\"boolean\",\"nil\")expect.field(dT,\"delay\",\"boolean\",\"nil\")expect.field(dT,\"echo\",\"boolean\",\"nil\")expect.field(dT,\"keypad\",\"boolean\",\"nil\")expect.field(dT,\"nlcr\",\"boolean\",\"nil\")expect.field(dT,\"raw\",\"boolean\",\"nil\")for F,c in pairs(dT)do if self.internalState.tty.flags[F]~=nil then self.internalState.tty.flags[F]=c end end end;local X=deepcopy(self.internalState.tty.flags)X.hasgfx=term.getGraphicsMode~=nil;return X end;function fS.peripheral_monitor.methods:openterm(process)return terminal.openterm(self.internalState.tty,process)end;function fS.peripheral_monitor.methods:opengfx(process)return terminal.opengfx(self.internalState.tty,process)end;function fS.peripheral_monitor:init()fT(self)local aB,aC=self.internalState.peripheral.call(self.id,\"getSize\")local g9=self.internalState.peripheral.call(self.id,\"getTextScale\")self.displayName=aB*g9 ..\"x\"..aC*g9 ..\" monitor at \"..self.id;local term={}for k,c in ipairs(self.internalState.peripheral.getMethods(self.id))do term[c]=function(...)return self.internalState.peripheral.call(self.id,c,...)end end;self.internalState.tty=terminal.makeTTY(term,aB,aC)self.internalState.tty.isMonitor=true;terminal.redraw(self.internalState.tty,true)end;function fS.peripheral_monitor:deinit()local dE=self.internalState.tty;if dE.frontmostProcess then local c=dE.frontmostProcess;if c.stdin==dE then c.stdin=nil end;if c.stdout==dE then c.stdout=nil end;if c.stderr==dE then c.stderr=nil end end;for k,c in ipairs(dE.processList)do if c.stdin==dE then c.stdin=nil end;if c.stdout==dE then c.stdout=nil end;if c.stderr==dE then c.stderr=nil end end end;fW\"monitor\"eventHooks.monitor_resize=eventHooks.monitor_resize or{}eventHooks.monitor_resize[#eventHooks.monitor_resize+1]=function(aO)local eb=getNodeById(aO[2])if not eb then syslog.log({level=\"notice\",module=\"Hardware\"},\"Received \"..aO[1]..\" event for device ID \"..aO[2]..\", but no device node was found; ignoring\")return end;local af=fS.peripheral_monitor.methods.getSize(eb)terminal.resize(eb.internalState.tty,af.width,af.height)hardware.broadcast(eb,\"monitor_resize\",{device=hardware.path(eb),width=af.width,height=af.height})end;fS.peripheral_printer={name=\"peripheral_printer\",type=\"printer\",properties={\"inkLevel\",\"paperLevel\"},methods={}}fS.peripheral_printer.methods.getInkLevel=fX\"getInkLevel\"fS.peripheral_printer.methods.getPaperLevel=fX\"getPaperLevel\"function fS.peripheral_printer.methods:page(process)if self.internalState.printer.open then self.internalState.peripheral.call(self.id,\"endPage\")self.internalState.printer.open=false end;if not self.internalState.peripheral.call(self.id,\"newPage\")then return nil end;self.internalState.printer.open=true;local ga,Q,R;local function dS(...)if not self.internalState.printer.open then error(\"attempt to use closed page\",2)end;return self.internalState.peripheral.call(self.id,\"write\",...)end;local function gb()if not self.internalState.printer.open then return true end;if not self.internalState.peripheral.call(self.id,\"endPage\")then return false end;self.internalState.printer.open=false end;setfenv(dS,process.env)setfenv(gb,process.env)debug.protect(dS)debug.protect(gb)return fU(process,{__index=function(k,aY)if not self.internalState.printer.open then error(\"attempt to use closed page\",2)end;if aY==\"size\"then local U,dA=self.internalState.peripheral.call(self.id,\"getPageSize\")return fU(process,{__index=function(k,aY)if aY==\"width\"then return U elseif aY==\"height\"then return dA end end,__newindex=function()error(\"Cannot modify read-only table\",2)end})elseif aY==\"cursor\"then Q,R=self.internalState.peripheral.call(self.id,\"getCursorPos\")return fU(process,{__index=function(k,aY)if aY==\"x\"then return Q elseif aY==\"y\"then return R end end,__newindex=function(k,aY,z)if aY==\"x\"then Q=z;self.internalState.peripheral.call(self.id,\"setCursorPos\",Q,R)elseif aY==\"y\"then R=z;self.internalState.peripheral.call(self.id,\"setCursorPos\",Q,R)else error(\"Cannot modify member '\"..aY..\"'\",2)end end})elseif aY==\"title\"then return ga elseif aY==\"isOpen\"then return self.internalState.printer.open elseif aY==\"write\"then return dS elseif aY==\"close\"then return gb end end,__newindex=function(k,aY,z)if not self.internalState.printer.open then error(\"attempt to use closed page\",2)end;if aY==\"cursor\"then if type(z)~=\"table\"then error(\"bad value for 'cursor' (expected table, got \"..type(z)..\")\",2)end;expect.field(z,\"x\",\"number\")expect.field(z,\"y\",\"number\")Q,R=z.x,z.y;self.internalState.peripheral.call(self.id,\"setCursorPos\",Q,R)elseif aY==\"title\"then if type(z)~=\"string\"and z~=nil then error(\"bad value for 'title' (expected string, got \"..type(z)..\")\",2)end;ga=z;self.internalState.peripheral.call(self.id,\"setPageTitle\",ga)else error(\"Cannot modify member '\"..aY..\"'\",2)end end})end;function fS.peripheral_printer:init()fT(self)self.displayName=\"Speaker at \"..self.id;self.internalState.printer={open=false}end;fW\"printer\"local gc={name=\"peripheral_redstone_relay_side\",type=\"redstone\",properties={\"input\",\"output\",\"bundledInput\",\"bundledOutput\"},methods={}}function gc.methods:getInput()return g4(self.internalState.peripheral.call(self.id,\"getAnalogInput\",self.internalState.redstone.side))end;function gc.methods:getOutput()return g4(self.internalState.peripheral.call(self.id,\"getAnalogOutput\",self.internalState.redstone.side))end;function gc.methods:setOutput(process,S)S=expect(1,S,\"number\",\"boolean\",\"nil\")or 0;if S==false then S=0 elseif S==true then S=15 end;expect.range(S,0,15)self.internalState.peripheral.call(self.id,\"setAnalogOutput\",self.internalState.redstone.side,S)end;function gc.methods:getBundledInput()return self.internalState.peripheral.call(self.id,\"getBundledInput\",self.internalState.redstone.side)end;function gc.methods:getBundledOutput()return self.internalState.peripheral.call(self.id,\"getBundledOutput\",self.internalState.redstone.side)end;function gc.methods:setBundledOutput(process,S)expect(1,S,\"number\")expect.range(S,0,65535)return self.internalState.peripheral.call(self.id,\"setBundledOnput\",self.internalState.redstone.side,S)end;function gc:init()if not self.internalState.redstone or not self.internalState.redstone.side then error(\"No assigned side on redstone device!\",2)end;self.displayName=\"Redstone Relay '\"..self.id..\"' on side \"..self.internalState.redstone.side end;fS.peripheral_redstone_relay={name=\"peripheral_redstone_relay\",type=\"redstone_relay\",properties={},methods={}}function fS.peripheral_redstone_relay:init()for k,c in ipairs{\"top\",\"bottom\",\"left\",\"right\",\"front\",\"back\"}do local bG=hardware.add(self,c)bG.internalState.redstone={side=c}hardware.register(bG,gc)end end;fW\"redstone_relay\"fS.peripheral_speaker={name=\"peripheral_speaker\",type=\"speaker\",properties={},methods={}}function fS.peripheral_speaker.methods:playNote(process,gd,ge,gf)expect(1,gd,\"string\")expect(2,ge,\"number\",\"nil\")expect(3,gf,\"number\",\"nil\")if ge then expect.range(ge,0,3)end;if gf then expect.range(gf,0,24)end;return self.internalState.peripheral.call(self.id,\"playNote\",gd,ge,gf)end;function fS.peripheral_speaker.methods:playSound(process,O,ge,gg)expect(1,O,\"string\")expect(2,ge,\"number\",\"nil\")expect(3,gg,\"number\",\"nil\")if ge then expect.range(ge,0,3)end;if gg then expect.range(gg,0.5,2.0)end;return self.internalState.peripheral.call(self.id,\"playNote\",O,ge,gg)end;function fS.peripheral_speaker.methods:playAudio(gh,ge)expect(1,gh,\"table\")expect(2,ge,\"number\",\"nil\")if ge then expect.range(ge,0,3)end;return self.internalState.peripheral.call(self.id,\"playAudio\",gh,ge)end;fS.peripheral_speaker.methods.stop=fX\"stop\"function fS.peripheral_speaker:init()fT(self)self.displayName=\"Speaker at \"..self.id end;fW\"speaker\"eventHooks.speaker_audio_empty=eventHooks.speaker_audio_empty or{}eventHooks.speaker_audio_empty[#eventHooks.speaker_audio_empty+1]=function(aO)local eb=getNodeById(aO[2])if not eb then syslog.log({level=\"notice\",module=\"Hardware\"},\"Received \"..aO[1]..\" event for device ID \"..aO[2]..\", but no device node was found; ignoring\")return end;hardware.broadcast(eb,\"speaker_audio_empty\",{device=hardware.path(eb)})end;local gi={fS.peripheral_command,fS.peripheral_computer,fS.peripheral_drive,fS.peripheral_energy_storage,fS.peripheral_fluid_storage,fS.peripheral_inventory,fS.peripheral_monitor,fS.peripheral_printer,fS.peripheral_speaker}function registerDriver(fy)local gj=fy.init;fy.init=function(eb)fT(eb)if gj then return gj(eb)end end;fy.__callback=fV(fy,fy.type)hardware.listen(fy.__callback,deviceTreeRoot)gi[#gi+1]=fy;for k,eb in ipairs{hardware.find(\"modem\")}do if not eb.metadata.wireless then hardware.listen(fy.__callback,eb)eb.internalState.modem.callbacks[#eb.internalState.modem.callbacks+1]=f end end end;function deregisterDriver(fy)if not fy.__callback then return end;hardware.unlisten(fy.__callback)for k,c in ipairs{hardware.find(fy.type)}do hardware.deregister(c,fy)end;for o,c in ipairs(fR)do if c==fy then table.remove(fR,o)break end end;for k,eb in ipairs{hardware.find(\"modem\")}do if not eb.metadata.wireless then hardware.unlisten(fy.__callback)for o,c in ipairs(eb.internalState.modem.callbacks)do if c==fy.__callback then table.remove(eb.internalState.modem.callbacks,o)break end end end end end;fS.peripheral_modem={name=\"peripheral_modem\",type=\"modem\",properties={\"remainingChannels\"},methods={}}function fS.peripheral_modem.methods:getRemainingChannels()local u=128;for k in pairs(self.internalState.modem)do u=u-1 end;return u end;function fS.peripheral_modem.methods:open(process,gk)if not self.internalState.modem[gk]then self.internalState.peripheral.call(self.id,\"open\",gk)self.internalState.modem[gk]={}end;self.internalState.modem[gk][process]=true end;function fS.peripheral_modem.methods:isOpen(process,gk)return not not(self.internalState.modem[gk]and self.internalState.modem[gk][process])end;function fS.peripheral_modem.methods:close(process,gk)if not self.internalState.modem[gk]then return end;self.internalState.modem[gk][process]=nil;if not next(self.internalState.modem[gk])then self.internalState.peripheral.call(self.id,\"close\",gk)self.internalState.modem[gk]=nil end end;function fS.peripheral_modem.methods:closeAll(process)for gk=0,65535 do if self.internalState.modem[gk]then self.internalState.modem[gk][process]=nil;if not next(self.internalState.modem[gk])then self.internalState.peripheral.call(self.id,\"close\",gk)self.internalState.modem[gk]=nil end end end end;function fS.peripheral_modem.methods:transmit(process,gk,gl,gm)expect(1,gk,\"number\")gl=expect(2,gl,\"number\",\"nil\")or gk;return self.internalState.peripheral.call(self.id,\"transmit\",gk,gl,gm)end;function fS.peripheral_modem:init()fT(self)self.metadata.wireless=self.internalState.peripheral.call(self.id,\"isWireless\")self.displayName=(self.metadata.wireless and\"Wireless\"or\"Wired\")..\" modem at \"..self.id;self.internalState.modem={}self.internalState.modem.channels={}self.internalState.peripheral.call(self.id,\"closeAll\")if not self.metadata.wireless then self.internalState.modem.callbacks={}for k,c in ipairs(gi)do local f=fV(c,c.type)hardware.listen(f,self)self.internalState.modem.callbacks[#self.internalState.modem.callbacks+1]=f end;local f=fV(fS[\"peripheral_computer\"],\"turtle\")hardware.listen(f,self)self.internalState.modem.callbacks[#self.internalState.modem.callbacks+1]=f;for k,O in ipairs(self.internalState.peripheral.call(self.id,\"getNamesRemote\"))do hardware.add(self,O)end end end;function fS.peripheral_modem:deinit()if not self.metadata.wireless then for k,c in ipairs(self.internalState.modem.callbacks)do hardware.unlisten(c)end end end;fW\"modem\"eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(aO)local eb=getNodeById(aO[2])or hardware.get(aO[2])if not eb then syslog.log({level=\"notice\",module=\"Hardware\"},\"Received \"..aO[1]..\" event for device ID \"..aO[2]..\", but no device node was found; ignoring\")return end;local as=false;for c in pairs(eb.listeners)do if(eb.internalState.modem[aO[3]]or{})[c]then c.eventQueue[#c.eventQueue+1],as={\"modem_message\",{device=hardware.path(eb),channel=aO[3],replyChannel=aO[4],message=aO[5],distance=aO[6]}},true;wakeup(c)end end;return as end;fS.loopback_modem={name=\"loopback_modem\",type=\"modem\",properties={\"remainingChannels\"},methods={}}function fS.loopback_modem.methods:getRemainingChannels()local u=128;for k in pairs(self.internalState.modem)do u=u-1 end;return u end;function fS.loopback_modem.methods:open(process,gk)if not self.internalState.modem[gk]then self.internalState.modem[gk]={}end;self.internalState.modem[gk][process]=true end;function fS.loopback_modem.methods:isOpen(process,gk)return self.internalState.modem[gk]and self.internalState.modem[gk][process]end;function fS.loopback_modem.methods:close(process,gk)self.internalState.modem[gk][process]=nil;if not next(self.internalState.modem[gk])then self.internalState.modem[gk]=nil end end;function fS.loopback_modem.methods:closeAll(process)for gk=0,65535 do self.internalState.modem[gk][process]=nil;if not next(self.internalState.modem[gk])then self.internalState.modem[gk]=nil end end end;function fS.loopback_modem.methods:transmit(process,gk,gl,gm)expect(1,gk,\"number\")gl=expect(2,gl,\"number\",\"nil\")or gk;os.queueEvent(\"modem_message\",self.uuid,gk,gl,gm,0)end;function fS.loopback_modem:init()self.metadata.wireless=true;self.displayName=\"Loopback modem\"self.internalState.modem={}self.internalState.modem.channels={}end;local function gn(go)local info={scheme=\"\"}for G in go:gmatch\".\"do if info.fragment then if G:match\"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/?]\"then info.fragment=info.fragment..G else error(\"Invalid URI\",3)end elseif info.query then if G==\"#\"then info.fragment=\"\"elseif G:match\"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/?]\"then info.query=info.query..G else error(\"Invalid URI\",3)end elseif info.path then if G==\"/\"and info.path==\"/\"and not info.host then info.path,info.host=nil,\"\"elseif G==\"?\"then info.query=\"\"elseif G==\"#\"then info.fragment=\"\"elseif G:match\"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/]\"then info.path=info.path..G else error(\"Invalid URI\",3)end elseif info.port then if tonumber(G)then info.port=info.port..G elseif G==\"/\"then info.path=\"/\"else error(\"Invalid URI\",3)end elseif info.host then if G==\"@\"and not info.user then info.user,info.host=info.host,\"\"elseif G==\":\"then info.port=\"\"elseif G==\"/\"then info.path=\"/\"elseif G:match\"[%w%-%._~%%/!%$&'%(%)%*%+,;=]\"then info.host=info.host..G else error(\"Invalid URI\",3)end else if G==\":\"then info.path=\"\"elseif G:match(info.scheme==\"\"and\"[%a%+%-%.]\"or\"[%w%+%-%.]\")then info.scheme=info.scheme..G else error(\"Invalid URI\",3)end end end;if info.port then info.port=tonumber(info.port)end;return info end;local function gp(gq)if gq:match\"^%d+$\"then return tonumber(gq)elseif gq:match\"^%d+%.%d+$\"then return tonumber(gq:match\"^%d+\")*0x1000000+tonumber(gq:match\"^%d+%.(%d+)\")elseif gq:match\"^%d+%.%d+%.%d+$\"then return tonumber(gq:match\"^(%d+)\")*0x1000000+tonumber(gq:match\"^%d+%.(%d+)\")*0x10000+tonumber(gq:match\"^%d+%.%d+%.(%d+)\")elseif gq:match\"^%d+%.%d+%.%d+%.%d+$\"then return tonumber(gq:match\"^(%d+)\")*0x1000000+tonumber(gq:match\"^%d+%.(%d+)\")*0x10000+tonumber(gq:match\"^%d+%.%d+%.(%d+)\")*0x100+tonumber(gq:match\"^%d+%.%d+%.%d+%.(%d+)\")else error(\"Invalid IP address\",2)end end;local function gr(u)if not u then return nil end;return(\"%d.%d.%d.%d\"):format(bit32.band(bit32.rshift(u,24),0xFF),bit32.band(bit32.rshift(u,16),0xFF),bit32.band(bit32.rshift(u,8),0xFF),bit32.band(u,0xFF))end;local function gs(gt)local bI=\"\"for o=1,gt do bI=bI..string.char(math.random(0,255))end;return bI end;local function gu(u)return bit32.bnot(2^(32-u)-1)end;local function gv(V)local S=0;while bit32.btest(V,0x80000000)do V,S=bit32.lshift(V,1),S+1 end;return S end;local function gw(eb)if not eb then error(\"No such device\")end;for k,c in pairs(eb.drivers)do if c.type==\"modem\"then return eb end end;error(\"Not a modem\")end;local gx=0;local gy={}local gz={maxn=0,[0]={}}local gA={}local gB={send={},recv={}}local gC={}local gD={}local gE={}local gF=setmetatable({},{__mode=\"k\"})local gG={arp={},socket={}}local gH={}local function gI(gJ,gK)local gL={}for F in pairs(gJ.devices)do gL[F]=true end;if gC[gK]and gC[gK].listen and gC[gK].listen.process==gJ.process then for F in pairs(gC[gK].listen.devices)do gL[F]=nil end end;if gC[gK]then for k,bI in pairs(gC[gK])do if bI.process==gJ.process then for F in pairs(bI.devices)do gL[F]=nil end end end end;for F in pairs(gL)do hardware.call(gJ.process,hardware.get(F),\"close\",gK)end end;function gB.send.link(info,gM,aA)expect(2,gM,\"number\",\"nil\")expect.field(info,\"device\",\"table\")local bQ={PhoenixNetworking=true,type=\"link\",source=os.computerID(),destination=gM,payload=aA}if gM==os.computerID()then os.queueEvent(\"modem_message\",info.device.id,info.outPort or 0,info.inPort or 0,bQ,0)else hardware.call(info.process or KERNEL,info.device,\"transmit\",info.outPort or 0,info.inPort or 0,bQ)end end;function gB.send.arp_request(info,gq)expect.field(info,\"device\",\"table\")expect(2,gq,\"string\")hardware.call(info.process or KERNEL,info.device,\"transmit\",0,0,{PhoenixNetworking=true,type=\"arp\",reply=false,source=os.computerID(),sourceIP=gy[info.device.uuid]and gr(gy[info.device.uuid].ip),destinationIP=gq})end;function gB.send.arp_reply(info,gM,gN)expect.field(info,\"device\",\"table\")expect(2,gM,\"number\")expect(3,gN,\"string\",\"nil\")hardware.call(info.process or KERNEL,info.device,\"transmit\",0,0,{PhoenixNetworking=true,type=\"arp\",reply=true,source=os.computerID(),sourceIP=gr(gy[info.device.uuid].ip),destination=gM,destinationIP=gN})end;function gB.send.internet(info,gM,aA,gO,fz)expect(2,gM,\"number\")local e={PhoenixNetworking=true,type=\"internet\",hopsLeft=gO or 15,payload=aA,destination=gr(gM)}local aX=gs(32)e.messageID=aX;local c;for o=gz.maxn,0,-1 do if gz[o]then for k,gP in ipairs(gz[o])do if bit32.band(gP.source,gP.sourceNetmask)==bit32.band(gM,gP.sourceNetmask)and(not c or gv(gP.sourceNetmask)>gv(c.sourceNetmask))then c=gP end end end end;if not c then local E=gB.recv.control({},{PhoenixNetworking=true,messageType=\"unreachable\",error=\"No route to host\",payload=e})if fz then fz()end;return E end;if c.action==\"unicast\"and gy[c.device.uuid]and gy[c.device.uuid].up then info.device=c.device;e.source=gr(gy[c.device.uuid].ip)if gA[c.device.uuid]and gA[c.device.uuid][c.destination]then local E=gB.send.link(info,gA[c.device.uuid][c.destination],e)if fz then fz()end;return E end;local gQ=false;local fN;local function gR(k,gq,bU)if not gQ and gp(gq)==c.destination then gQ=true;gB.send.link(info,bU,e)if fz then fz()end end;if gQ then for o,f in ipairs(gG.arp)do if f==gR then table.remove(gG.arp,o)break end end end end;local function gS(aO)if aO[2]==fN then if not gQ then gB.recv.control({},{PhoenixNetworking=true,messageType=\"unreachable\",error=\"No route to host\",payload=e})if fz then fz()end end;gQ=true;for o,aB in ipairs(eventHooks.timer)do if aB==gS then table.remove(eventHooks.timer,o)break end end;for o,f in ipairs(gG.arp)do if f==gR then table.remove(gG.arp,o)break end end end end;gG.arp[#gG.arp+1]=gR;gB.send.arp_request(info,gr(c.destination))eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=gS;fN=os.startTimer(2)return elseif c.action==\"broadcast\"and gy[c.device.uuid]and gy[c.device.uuid].up then info.device=c.device;e.source=gr(gy[c.device.uuid].ip)local E=gB.send.link(info,nil,e)if fz then fz()end;return E elseif c.action==\"local\"and gy[c.device.uuid]and gy[c.device.uuid].up then info.device=c.device;e.source=gr(gy[c.device.uuid].ip)if gA[c.device.uuid]and gA[c.device.uuid][gM]then local E=gB.send.link(info,gA[c.device.uuid][gM],e)if fz then fz()end;return E end;local gQ=false;local fN;local function gR(k,gq,bU)if not gQ and gp(gq)==gM then gQ=true;gB.send.link(info,bU,e)if fz then fz()end end;if gQ then for o,f in ipairs(gG.arp)do if f==gR then table.remove(gG.arp,o)break end end end end;local function gS(aO)if aO[2]==fN then if not gQ then gB.recv.control({},{PhoenixNetworking=true,messageType=\"unreachable\",error=\"No route to host\",payload=e})if fz then fz()end end;gQ=true;for o,aB in ipairs(eventHooks.timer)do if aB==gS then table.remove(eventHooks.timer,o)break end end end end;gG.arp[#gG.arp+1]=gR;gB.send.arp_request(info,gr(gM))eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=gS;fN=os.startTimer(2)return elseif c.action==\"unreachable\"then local E=gB.recv.control({},{PhoenixNetworking=true,messageType=\"unreachable\",error=\"Destination unreachable\",payload=e})if fz then fz()end;return E elseif c.action==\"prohibit\"then local E=gB.recv.control({},{PhoenixNetworking=true,messageType=\"unreachable\",error=\"Prohibited\",payload=e})if fz then fz()end;return E elseif c.action==\"blackhole\"then if fz then fz()end;return end end;function gB.send.control(info,gM,type,n,gT,gO)expect(3,type,\"string\")expect(4,n,\"string\",\"nil\")return gB.send.internet(info,gM,{PhoenixNetworking=true,type=\"control\",messageType=type,error=n,payload=gT},gO)end;gB.send.socket={}local gU;function gB.send.socket.connect(info,gq,gK,gJ)for o=1,16384 do local a1=math.random(49152,65535)if not gC[a1]or not gC[a1][gK]then gJ.localPort=a1;break end end;if not gJ.localPort then error(\"Too many open sockets\")end;gJ.id=gx;gx=gx+1;gJ.ip=gq;gJ.port=gK;gJ.sendSeq=math.floor(math.random()*0x10000000000)gJ.sendSeqNext=gJ.sendSeq+2;gJ.sendSeqMax=gJ.sendSeq+256;gJ.status=\"syn-sent\"info.outPort=gK;info.inPort=gJ.localPort;gF[gJ]=function(a1)if a1.type==\"control\"and a1.payload.destination==gr(gq)then gJ.status=\"error\"gJ.error=a1.error;return true end;return false end;gB.send.internet(info,gq,{PhoenixNetworking=true,type=\"socket\",sequence=gJ.sendSeqNext-1,windowSize=256,synchronize=true},nil,function()gJ.devices={[info.device.uuid]=true}local s,n=pcall(hardware.call,info.process or KERNEL,info.device,\"open\",gJ.localPort)if not s then local gV={}for gK,bu in pairs(gC)do for gW,gJ in pairs(bu)do gV[#gV+1]=gK..\" -> \"..gW end end;syslog.debug(\"Purging open channels\",table.concat(gV,\", \"))gU(true)s,n=pcall(hardware.call,info.process or KERNEL,info.device,\"open\",gJ.localPort)if not s then gB.send.internet(info,gq,{PhoenixNetworking=true,type=\"socket\",sequence=gJ.sendSeqNext,windowSize=0,reset=true})gJ.status=\"error\"gJ.error=n;return false end end;gJ.nextUpdate=os.epoch\"utc\"+5000;gJ.process=info.process;gJ.retryCount=0;gC[gJ.localPort]=gC[gJ.localPort]or{}gC[gJ.localPort][gK]=gJ;gD[gJ.id]=gJ end)end;function gB.send.socket.data(info,aA,gJ)info.outPort=gJ.port;info.inPort=gJ.localPort;aA.PhoenixNetworking=true;aA.type=\"socket\"if not aA.sequence then aA.sequence=gJ.sendSeqNext;gJ.sendSeqNext=gJ.sendSeqNext+1 end;aA.acknowledgement=aA.acknowledgement or gJ.recvSeq-1;gJ.nextAck=nil;if not aA.final then aA.windowSize=256 end;return gB.send.internet(info,gJ.ip,aA)end;function gB.send.socket.ack(info,u,gJ)gJ.lastAck=os.epoch\"utc\"return gB.send.socket.data(info,{acknowledgement=u},gJ)end;function gB.send.socket.reset(info,gq,gK,gX,gY,gZ)info.outPort=gK;info.inPort=gZ or gK;return gB.send.internet(info,gq,{PhoenixNetworking=true,type=\"socket\",sequence=gX,acknowledgement=gY,reset=true})end;function gB.send.datagram(info,gq,g_,gK,aA)info.outPort=gK;info.inPort=g_ or math.random(49152,65535)return gB.send.internet(info,gq,{PhoenixNetworking=true,type=\"datagram\",message=aA})end;local function h0(gJ,P,...)P=P or\"*l\"if type(P)~=\"string\"and type(P)~=\"number\"then error(\"bad argument (expected string or number, got \"..type(P)..\")\",2)end;if gJ.buffer==\"\"then return nil end;P=P:gsub(\"^%*\",\"\")if P==\"a\"then local t=gJ.buffer;gJ.buffer=\"\"return t elseif P==\"l\"then local t,au=gJ.buffer:match\"^([^\\n]*)\\n?()\"if t then gJ.buffer=gJ.buffer:sub(au)if select(\"#\",...)>0 then return t,h0(gJ,...)else return t end else return nil end elseif P==\"L\"then local t,au=gJ.buffer:match\"^([^\\n]*\\n?)()\"if t then gJ.buffer=gJ.buffer:sub(au)if select(\"#\",...)>0 then return t,h0(gJ,...)else return t end else return nil end elseif P==\"n\"then local t,au=gJ.buffer:match\"(%d+)()\"if t then gJ.buffer=gJ.buffer:sub(au)if select(\"#\",...)>0 then return tonumber(t),h0(gJ,...)else return tonumber(t)end else return nil end elseif type(P)==\"number\"then local t=gJ.buffer:sub(1,P)gJ.buffer=gJ.buffer:sub(P+1)if select(\"#\",...)>0 then return t,h0(gJ,...)else return t end else error(\"bad argument (invalid mode '\"..P..\"')\",2)end end;local function h1(gJ,bz,...)bz=tostring(bz)gJ.outQueue[gJ.sendSeqNext]=bz;gB.send.socket.data({},{payload=bz},gJ)if select(\"#\",...)>0 then return h1(gJ,...)end end;function syscalls.__socketcall(process,aN,aX,fB,...)local gJ=gD[aX]if not gJ then error(\"No such socket\")end;local h2=process;while process~=gJ.process do if process==nil then error(\"No such socket\")end;process=processes[process.parent or-1]end;if fB==\"close\"then gJ.sendSeqMax=gJ.sendSeqNext;gB.send.socket.data({},{final=true},gJ)gJ.status=\"fin-wait\"elseif fB==\"read\"then return h0(gJ,...)elseif fB==\"write\"then return h1(gJ,...)elseif fB==\"transfer\"then gJ.process=h2 else error(\"No such method\")end end;function syscalls.__datagramcall(process,aN,gK,aX,fB,...)local h3=gE[gK]local h2=process;while process~=h3.process do if process==nil then error(\"No such socket\")end;process=processes[process.parent or-1]end;local gJ;if h3.listen then for k,c in pairs(h3.open)do if c.id==aX then gJ=c;break end end;if not gJ then error(\"No socket found for ID\")end else gJ=h3 end;if fB==\"close\"then if h3.listen then for F,c in pairs(h3.open)do if c.id==aX then h3.open[F]=nil;break end end else gE[gK]=nil end elseif fB==\"read\"then local c=gJ[1]gJ.n=gJ.n-1;for o=1,gJ.n do gJ[o]=gJ[o+1]end;return c elseif fB==\"write\"then return gB.send.datagram({process=process},gJ.sourceIP,gK,gJ.port,...)elseif fB==\"transfer\"then h3.process=h2 else error(\"No such method\")end end;local do_syscall=do_syscall;local function h4(gJ)local bQ=setmetatable({id=gJ.id},{__name=\"socket\"})function bQ:localIP()return gJ.localIP end;function bQ:status()if gJ.status==\"listening\"or gJ.status==\"syn-sent\"or gJ.status==\"syn-received\"then return\"connecting\"elseif gJ.status==\"connected\"or gJ.buffer~=\"\"then return\"open\"elseif gJ.status==\"error\"then return\"error\",gJ.error else return\"closed\"end end;function bQ:read(P,...)if gJ.status~=\"connected\"and gJ.status~=\"close-wait\"and gJ.status~=\"fin-wait\"and gJ.status~=\"closed\"then error(\"attempt to read from a \"..gJ.status..\" handle\",2)end;return do_syscall(\"__socketcall\",gJ.id,\"read\",P,...)end;function bQ:write(bz,...)if gJ.status~=\"connected\"then error(\"attempt to write to a \"..gJ.status..\" handle\",2)end;return do_syscall(\"__socketcall\",gJ.id,\"write\",bz,...)end;function bQ:close()if gJ.status==\"closing\"or gJ.status==\"fin-wait\"or gJ.status==\"closed\"then return end;if not(gJ.status==\"listening\"or gJ.status==\"syn-sent\"or gJ.status==\"syn-received\"or gJ.status==\"connected\")then error(\"attempt to close a \"..gJ.status..\" handle\",2)end;return do_syscall(\"__socketcall\",gJ.id,\"close\")end;function bQ:transfer()return do_syscall(\"__socketcall\",gJ.id,\"transfer\")end;return bQ end;local function h5(gJ,gK)local bQ=setmetatable({id=gJ.id},{__name=\"socket\"})function bQ:localIP()return gr(gJ.localIP)end;function bQ:status()return\"open\"end;function bQ:read(P,...)return do_syscall(\"__datagramcall\",gK,gJ.id,\"read\",P,...)end;function bQ:write(bz,...)return do_syscall(\"__datagramcall\",gK,gJ.id,\"write\",bz,...)end;function bQ:close()return do_syscall(\"__datagramcall\",gK,gJ.id,\"close\")end;function bQ:transfer()return do_syscall(\"__datagramcall\",gK,gJ.id,\"transfer\")end;return bQ end;function gB.recv.link(info,aA)expect.field(aA,\"source\",\"number\")expect.field(aA,\"destination\",\"number\")expect.field(aA,\"payload\",\"table\")syslog.debug(\"Received link message from\",aA.source,\"to\",aA.destination)if aA.destination~=os.computerID()then return end;info.sourceID=aA.source;assert(aA.payload.PhoenixNetworking)expect.field(aA.payload,\"type\",\"string\")if not gB.recv[aA.payload.type]then error(\"Unknown protocol '\"..aA.payload.type..\"'\")end;return gB.recv[aA.payload.type](info,aA.payload)end;function gB.recv.arp(info,aA)expect.field(aA,\"source\",\"number\")expect.field(aA,\"reply\",\"boolean\")syslog.debug(\"Received arp message from\",aA.source)if not aA.reply and aA.destinationIP and aA.sourceIP~=aA.destinationIP then local gq=gp(expect.field(aA,\"destinationIP\",\"string\"))if gy[info.device.uuid]and gy[info.device.uuid].ip==gq then gB.send.arp_reply(info,aA.source,aA.sourceIP)end end;if aA.sourceIP then local gq=gp(expect.field(aA,\"sourceIP\",\"string\"))gA[info.device.uuid]=gA[info.device.uuid]or{}gA[info.device.uuid][gq]=aA.source;local h6={}for o,c in ipairs(gG.arp)do h6[o]=c end;for k,c in ipairs(h6)do c(c,aA.sourceIP,aA.source)end end end;function gB.recv.internet(info,aA)info.sourceIP=gp(expect.field(aA,\"source\",\"string\"))local bU=gp(expect.field(aA,\"destination\",\"string\"))info.localIP=bU;syslog.debug(\"Received internet message from\",aA.source,\"to\",aA.destination)expect.field(aA,\"payload\",\"table\")if gH[expect.field(aA,\"messageID\",\"number\",\"string\")]then return end;gH[aA.messageID]=os.epoch\"utc\"if not gy[info.device.uuid]or gy[info.device.uuid].ip~=bU then local as=false;for k,c in pairs(gF)do as=c(aA)or as end;return as end;if not gA[info.device.uuid]or not gA[info.device.uuid][info.sourceIP]then gA[info.device.uuid]=gA[info.device.uuid]or{}gA[info.device.uuid][info.sourceIP]=info.sourceID;local h6={}for o,c in ipairs(gG.arp)do h6[o]=c end;for k,c in ipairs(h6)do c(c,info.sourceIP,info.sourceID)end end;info.ipPacket=aA;assert(aA.payload.PhoenixNetworking)expect.field(aA.payload,\"type\",\"string\")if not gB.recv[aA.payload.type]then error(\"Unknown protocol '\"..aA.payload.type..\"'\")end;return gB.recv[aA.payload.type](info,aA.payload)end;function gB.recv.control(info,aA)expect.field(aA,\"messageType\",\"string\")syslog.debug(\"Received control message\",aA.messageType)local as=false;if aA.messageType==\"ping\"then gB.send.control({device=info.device},info.sourceIP,\"pong\",nil,info.ipPacket)else for k,c in pairs(gF)do as=c{type=\"control\",messageType=aA.messageType,error=aA.error,payload=aA.payload,sender=gr(info.sourceIP)}or as end end;return as end;local function h7(c)local s,E=pcall(serialize,c)if s then return E else return tostring(c)end end;function gB.recv.socket(info,aA)expect.field(aA,\"sequence\",\"number\")expect.field(aA,\"acknowledgement\",\"number\",\"nil\")expect.field(aA,\"windowSize\",\"number\",\"nil\")expect.field(aA,\"payload\",\"string\",\"nil\")if info.channel==0 or info.replyChannel==0 then syslog.debug(\"Received socket event on channel 0; discarding.\")return end;local gJ=(gC[info.channel]or{})[info.replyChannel]or(gC[info.channel]or{}).listen;if not gJ then if aA.acknowledgement then gB.send.socket.reset(info,info.sourceIP,info.replyChannel,aA.acknowledgement,nil,info.channel)else gB.send.socket.reset(info,info.sourceIP,info.replyChannel,0,aA.sequence+(aA.windowSize or 0),info.channel)end;return end;do local bI={}for F,c in pairs(gJ)do if F~=\"process\"then bI[F]=c end end;syslog.debug(\"Received socket message:\",h7(aA),\"\\nSocket info:\",h7(bI))end;if gJ.status==\"listening\"then if aA.reset then return end;if aA.acknowledgement then gB.send.socket.reset(info,info.sourceIP,info.replyChannel,aA.acknowledgement,nil,info.channel)return end;if not aA.synchronize then return end;gJ.ip=info.sourceIP;gJ.localIP=gr(info.localIP)gJ.port=info.replyChannel;gJ.recvSeq=aA.sequence+1;gJ.recvSeqMax=gJ.recvSeq+(aA.windowSize or 0)gJ.sendSeq=math.floor(math.random()*0x10000000000)gJ.sendSeqNext=gJ.sendSeq+2;gJ.sendSeqMax=gJ.sendSeq+(aA.windowSize or 0)gJ.status=\"syn-received\"gJ.nextUpdate=os.epoch\"utc\"+5000;gJ.retryCount=0;gC[info.channel][info.replyChannel]=gJ;gC[info.channel].listen=nil;gB.send.internet({inPort=info.channel,outPort=info.replyChannel},gJ.ip,{PhoenixNetworking=true,type=\"socket\",sequence=gJ.sendSeqNext-1,acknowledgement=gJ.recvSeq,windowSize=256,synchronize=true})elseif gJ.status==\"syn-sent\"then if aA.reset then gJ.status=\"error\"gJ.error=\"Connection refused\"gC[info.channel][info.replyChannel]=nil;if gJ.process then gJ.process.eventQueue[#gJ.process.eventQueue+1]={\"handle_status_change\",{id=gJ.id,status=\"error\"}}end;return true end;if not aA.synchronize or not aA.acknowledgement or aA.acknowledgement<gJ.sendSeq then gB.send.socket.reset(info,info.sourceIP,info.replyChannel,aA.acknowledgement,nil,info.channel)gJ.status=\"error\"gJ.error=\"Connection refused\"gC[info.channel][info.replyChannel]=nil;if gJ.process then gJ.process.eventQueue[#gJ.process.eventQueue+1]={\"handle_status_change\",{id=gJ.id,status=\"error\"}}end;return true end;gJ.localIP=gr(info.localIP)gJ.status=\"connected\"gJ.sendSeq=aA.acknowledgement;gJ.sendSeqMax=gJ.sendSeq+256;gJ.recvSeq=aA.sequence+1;gJ.recvSeqMax=gJ.recvSeq+(aA.windowSize or 0)gJ.outQueue={}gJ.nextUpdate=os.epoch\"utc\"+2000;gB.send.socket.ack({},gJ.recvSeq,gJ)if gJ.process then gJ.process.eventQueue[#gJ.process.eventQueue+1]={\"handle_status_change\",{id=gJ.id,status=\"connected\"}}end;return true else if aA.sequence<gJ.recvSeq then syslog.debug(\"Sequence out of range\")if aA.reset then gJ.status=\"error\"gJ.error=\"Connection reset by peer\"gC[info.channel][info.replyChannel]=nil;if gJ.process then gJ.process.eventQueue[#gJ.process.eventQueue+1]={\"handle_status_change\",{id=gJ.id,status=\"error\"}}end;return true else gB.send.socket.ack({},gJ.recvSeq,gJ)return end end;if aA.reset then syslog.debug(\"Received reset\")if gJ.status==\"syn-received\"then gJ.status=\"listening\"return elseif gJ.status==\"connected\"or gJ.status==\"fin-wait\"then gJ.status=\"error\"gJ.error=\"Connection reset by peer\"gC[info.channel][info.replyChannel]=nil;if gJ.process then gJ.process.eventQueue[#gJ.process.eventQueue+1]={\"handle_status_change\",{id=gJ.id,status=\"error\"}}end;return true else gJ.status=\"closed\"gC[info.channel][info.replyChannel]=nil;gI(gJ,info.channel)if gJ.process then gJ.process.eventQueue[#gJ.process.eventQueue+1]={\"handle_status_change\",{id=gJ.id,status=\"closed\"}}end;return true end end;if aA.synchronize then gB.send.socket.reset(info,info.sourceIP,info.replyChannel,aA.acknowledgement,nil,info.channel)gJ.status=\"error\"gJ.error=\"Connection reset by host\"gC[info.channel][info.replyChannel]=nil;if gJ.process then gJ.process.eventQueue[#gJ.process.eventQueue+1]={\"handle_status_change\",{id=gJ.id,status=\"error\"}}end;return true end;local as;if not aA.acknowledgement then syslog.debug(\"No acknowledgement\")return end;if gJ.status==\"syn-received\"then if aA.acknowledgement>=gJ.sendSeq and aA.acknowledgement<=gJ.sendSeqNext then gJ.status=\"connected\"gJ.outQueue={}gJ.nextUpdate=os.epoch\"utc\"+2000;if gJ.process then gJ.process.eventQueue[#gJ.process.eventQueue+1]={\"network_request\",{uri=gJ.uri,ip=gr(info.sourceIP),handle=h4(gJ)}}end;as=true else gB.send.socket.reset(info,info.sourceIP,info.replyChannel,aA.acknowledgement,nil,info.channel)gJ.status=\"error\"gJ.error=\"Connection reset by host\"gC[info.channel][info.replyChannel]=nil;if gJ.process then gJ.process.eventQueue[#gJ.process.eventQueue+1]={\"handle_status_change\",{id=gJ.id,status=\"error\"}}end;return true end elseif gJ.status==\"close-wait\"then if aA.acknowledgement==gJ.sendSeqMax then syslog.debug(\"Socket closed\")gJ.status=\"closed\"gC[info.channel][info.replyChannel]=nil;gI(gJ,info.channel)if gJ.process then gJ.process.eventQueue[#gJ.process.eventQueue+1]={\"handle_status_change\",{id=gJ.id,status=\"closed\"}}end;return true end elseif gJ.status==\"time-wait\"then if aA.final then gB.send.socket.ack({},aA.sequence,gJ)gJ.nextUpdate=os.epoch\"utc\"+10000;return end else if aA.acknowledgement>gJ.sendSeq and aA.acknowledgement<=gJ.sendSeqNext then for o=gJ.sendSeq,aA.acknowledgement do gJ.outQueue[o]=nil end;gJ.sendSeq=aA.acknowledgement;if aA.windowSize and gJ.status~=\"fin-wait\"and gJ.status~=\"closing\"then gJ.sendSeqMax=gJ.sendSeq+aA.windowSize end end;if gJ.status==\"fin-wait\"then if aA.acknowledgement==gJ.sendSeqMax then if not aA.final then gB.send.socket.reset(info,info.sourceIP,info.replyChannel,aA.acknowledgement,nil,info.channel)gJ.status=\"error\"gJ.error=\"Connection reset by host\"gC[info.channel][info.replyChannel]=nil;if gJ.process then gJ.process.eventQueue[#gJ.process.eventQueue+1]={\"handle_status_change\",{id=gJ.id,status=\"error\"}}end;return true end;gJ.status=\"time-wait\"gJ.nextUpdate=os.epoch\"utc\"+10000 end elseif gJ.status==\"closing\"then if aA.acknowledgement==gJ.sendSeqMax then gJ.status=\"time-wait\"gJ.nextUpdate=os.epoch\"utc\"+10000 end end end;if gJ.status==\"connected\"and aA.sequence==gJ.recvSeq then if aA.payload then gJ.buffer=gJ.buffer..aA.payload;gJ.nextAck=true;gJ.nextUpdate=os.epoch\"utc\"+100;if gJ.process then syslog.debug(\"Sending data event to PID \"..gJ.process.id)gJ.process.eventQueue[#gJ.process.eventQueue+1]={\"handle_data_ready\",{id=gJ.id}}end;as=true end;gJ.recvSeq=gJ.recvSeq+1 end;if aA.final then syslog.debug(\"Got final message\")gJ.recvSeq=aA.sequence+1;if gJ.status==\"syn-received\"or gJ.status==\"connected\"then gJ.sendSeqMax=gJ.sendSeqNext;gB.send.socket.data({},{final=true,acknowledgement=aA.sequence},gJ)gJ.status=\"close-wait\"if gJ.process then gJ.process.eventQueue[#gJ.process.eventQueue+1]={\"handle_status_change\",{id=gJ.id,status=\"closed\"}}end;return true elseif gJ.status==\"fin-wait\"then gB.send.socket.ack({},aA.sequence,gJ)if aA.acknowledgement~=gJ.sendSeqMax then gJ.status=\"closing\"else gJ.status=\"time-wait\"gJ.nextUpdate=os.epoch\"utc\"+10000 end else gB.send.socket.ack({},aA.sequence,gJ)end;syslog.debug(gJ.status)end;return as end end;function gU(h8)local co=os.epoch\"utc\"local cr=false;for gK,bu in pairs(gC)do for gW,gJ in pairs(bu)do if co>=gJ.nextUpdate then if gJ.status==\"syn-sent\"then gJ.status=\"error\"gJ.error=\"Connection timed out (syn-sent)\"gC[gK][gW]=nil;if gJ.process then gJ.process.eventQueue[#gJ.process.eventQueue+1]={\"handle_status_change\",{id=gJ.id,status=\"error\"}}cr=true end elseif gJ.status==\"syn-received\"then gJ.retryCount=gJ.retryCount+1;if gJ.retryCount>3 then gJ.status=\"error\"gJ.error=\"Connection timed out (syn-received)\"gC[gK][gW]=nil;if gJ.process then gJ.process.eventQueue[#gJ.process.eventQueue+1]={\"handle_status_change\",{id=gJ.id,status=\"error\"}}cr=true end else gJ.nextUpdate=os.epoch\"utc\"+2000 end elseif gJ.status==\"connected\"then for o=gJ.sendSeq+1,gJ.sendSeqNext-1 do if gJ.outQueue[o]then gB.send.socket.data({},{sequence=o,payload=gJ.outQueue[o]},gJ)end end;if gJ.nextAck then gB.send.socket.ack({},gJ.recvSeq-1,gJ)gJ.nextAck=nil end;gJ.nextUpdate=os.epoch\"utc\"+2000 elseif gJ.status==\"fin-wait\"then elseif gJ.status==\"close-wait\"then end elseif gJ.status==\"time-wait\"and(co>=gJ.nextUpdate or h8)then syslog.debug(\"Time wait finished on port \"..gK)gJ.status=\"closed\"gC[gK][gW]=nil;if gW~=\"listen\"then gI(gJ,gK)end end end end;return cr end;function gB.recv.datagram(info,aA)if not gE[info.channel]then syslog.debug(\"Received spurious PDP message on port \"..info.channel..\", discarding.\")return end;local h3=gE[info.channel]if h3.listen then local gJ=h3.open[info.sourceIP]if gJ then gJ.n=gJ.n+1;gJ[gJ.n]=aA.message;h3.process.eventQueue[#h3.process.eventQueue+1]={\"handle_data_ready\",{id=gJ.id}}else h3.open[info.sourceIP]={id=gx,sourceIP=info.sourceIP,localIP=info.localIP,port=info.replyChannel,n=1,aA.message}gx=gx+1;h3.process.eventQueue[#h3.process.eventQueue+1]={\"network_request\",{uri=h3.uri,ip=gr(info.sourceIP),handle=h5(h3.open[info.sourceIP],info.channel)}}end else h3.n=h3.n+1;h3[h3.n]=aA.message;h3.process.eventQueue[#h3.process.eventQueue+1]={\"handle_data_ready\",{id=h3.id}}end;return true end;eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(aO)if type(aO[5])==\"table\"and aO[5].PhoenixNetworking and type(aO[5].type)==\"string\"and gB.recv[aO[5].type]then local eb=getNodeById(aO[2])or hardware.get(aO[2])if not eb then syslog.log({level=\"notice\",module=\"Network\"},\"Received network event for device ID \"..aO[2]..\", but no device node was found; ignoring\")return end;if not gy[eb.uuid]or not gy[eb.uuid].up then return end;syslog.debug(aO[2],h7(aO[5]))local s,n=pcall(gB.recv[aO[5].type],{channel=aO[3],replyChannel=aO[4],device=eb},aO[5])if not s then syslog.log({level=\"debug\",module=\"Network\"},\"Network event errored while processing:\",n)else return n end end end;local h9=os.startTimer(1)eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=function(aO)if aO[2]==h9 then h9=os.startTimer(1)return gU()end end;local function ha(process,bY)local go=gn(bY.url)if not go.port then error(\"No port specified\")end;local gq=gp(go.host)local gK=go.port;local gJ={process=process,buffer=\"\"}gB.send.socket.connect({process=process},gq,gK,gJ)return h4(gJ)end;local function hb(process,bY)local go=gn(bY.url)if not go.port then error(\"No port specified\")end;local hc;for o=1,16384 do local a1=math.random(49152,65535)if not gE[a1]then hc=a1;break end end;if not hc then error(\"Too many open sockets\")end;local gq=gp(go.host)local gK=go.port;local gJ={process=process,id=gx,sourceIP=gq,port=gK,n=0}gx=gx+1;gE[hc]=gJ;for k,c in ipairs{hardware.find(\"modem\")}do hardware.call(process,c,\"open\",hc)end;return h5(gJ,hc)end;local hd={}local he={}local hf={}local hg=os.computerID()%65500;local hh={}local hi,hj;if http then eventHooks.http_success=eventHooks.http_success or{}eventHooks.http_success[#eventHooks.http_success+1]=function(aO)local info=hd[aO[2]]if info then info.handle,info.status=aO[3],\"open\"info.process.eventQueue[#info.process.eventQueue+1]={\"handle_status_change\",{id=info.id,status=\"open\"}}hd[aO[2]]=nil;return true else syslog.log({level=\"notice\"},\"Received HTTP response for \"..aO[2]..\" but nobody requested it; ignoring.\")end end;eventHooks.http_failure=eventHooks.http_failure or{}eventHooks.http_failure[#eventHooks.http_failure+1]=function(aO)local info=hd[aO[2]]if info then if aO[4]then info.handle,info.status=aO[4],\"open\"else info.status,info.error=\"error\",aO[3]end;info.process.eventQueue[#info.process.eventQueue+1]={\"handle_status_change\",{id=info.id,status=info.status}}hd[aO[2]]=nil;return true else syslog.log({level=\"notice\"},\"Received HTTP response for \"..aO[2]..\" but nobody requested it; ignoring.\")end end;eventHooks.websocket_success=eventHooks.websocket_success or{}eventHooks.websocket_success[#eventHooks.websocket_success+1]=function(aO)local info=hd[aO[2]]if info then info.handle,info.status=aO[3],\"open\"info.process.eventQueue[#info.process.eventQueue+1]={\"handle_status_change\",{id=info.id,status=\"open\"}}return true else syslog.log({level=\"notice\"},\"Received WebSocket response for \"..aO[2]..\" but nobody requested it; ignoring.\")end end;eventHooks.websocket_failure=eventHooks.websocket_failure or{}eventHooks.websocket_failure[#eventHooks.websocket_failure+1]=function(aO)local info=hd[aO[2]]if info then info.status,info.error=\"error\",aO[3]info.process.eventQueue[#info.process.eventQueue+1]={\"handle_status_change\",{id=info.id,status=info.status}}return true else syslog.log({level=\"notice\"},\"Received WebSocket response for \"..aO[2]..\" but nobody requested it; ignoring.\")end end;eventHooks.websocket_message=eventHooks.websocket_message or{}eventHooks.websocket_message[#eventHooks.websocket_message+1]=function(aO)local info=hd[aO[2]]if info then info.buffer=info.buffer..aO[3]info.process.eventQueue[#info.process.eventQueue+1]={\"handle_data_ready\",{id=info.id}}return true else syslog.log({level=\"notice\"},\"Received WebSocket message for \"..aO[2]..\" but nobody requested it; ignoring.\")end end;eventHooks.websocket_closed=eventHooks.websocket_closed or{}eventHooks.websocket_closed[#eventHooks.websocket_closed+1]=function(aO)local info=hd[aO[2]]if info then info.status=\"closed\"info.process.eventQueue[#info.process.eventQueue+1]={\"handle_status_change\",{id=info.id,status=info.status}}hd[aO[2]]=nil;return true else syslog.log({level=\"notice\"},\"Received WebSocket message for \"..aO[2]..\" but it's not open; ignoring.\")end end;eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(aO)local as=false;if he[aO[2]]and(aO[3]==hg or aO[3]==65535)and type(aO[5])==\"table\"and type(aO[5].nMessageID)==\"number\"and aO[5].nMessageID==aO[5].nMessageID and not hh[aO[5].nMessageID]and(aO[5].nRecipient and aO[5].nRecipient==os.computerID()or aO[3]==65535)then if hf[aO[5].nSender]then for k,c in ipairs(hf[aO[5].nSender])do if not c.protocol or c.protocol==aO[5].sProtocol then c.buffer[#c.buffer+1]=deepcopy(aO[5].message)hh[aO[5].nMessageID]=os.clock()+9.5;c.process.eventQueue[#c.process.eventQueue+1]={\"handle_data_ready\",{id=c.id}}as=true end end end;if hf[0xFFFFFFFF]then for k,c in ipairs(hf[0xFFFFFFFF])do if not c.protocol or c.protocol==aO[5].sProtocol then c.buffer[#c.buffer+1]=deepcopy(aO[5].message)hh[aO[5].nMessageID]=os.clock()+9.5;c.process.eventQueue[#c.process.eventQueue+1]={\"handle_data_ready\",{id=c.id}}as=true end end end;for F,c in pairs(hh)do if c<os.clock()then hh[F]=nil end end end;return as end;local hk=http.request;function hi(process,bY)expect.field(bY,\"encoding\",\"string\",\"nil\")expect.field(bY,\"headers\",\"table\",\"nil\")expect.field(bY,\"method\",\"string\",\"nil\")expect.field(bY,\"redirect\",\"boolean\",\"nil\")local info={status=\"ready\",process=process,id=gx}local bQ=setmetatable({id=gx},{__name=\"socket\"})gx=gx+1;function bQ:status()return info.status,info.error end;function bQ:read(P,...)if info.status~=\"open\"then error(\"attempt to read from a \"..info.status..\" handle\",2)end;P=P or\"*l\"if type(P)~=\"string\"and type(P)~=\"number\"then error(\"bad argument (expected string or number, got \"..type(P)..\")\",2)end;P=P:gsub(\"^%*\",\"\")if P==\"a\"then if select(\"#\",...)>0 then return info.handle.readAll(),self:read(...)else return info.handle.readAll()end elseif P==\"l\"then if select(\"#\",...)>0 then return info.handle.readLine(false),self:read(...)else return info.handle.readLine(false)end elseif P==\"L\"then if select(\"#\",...)>0 then return info.handle.readLine(true),self:read(...)else return info.handle.readLine(true)end elseif P==\"n\"then local t;repeat t=info.handle.read(1)if not t then return nil end until tonumber(t)while true do local G=info.handle.read(1)if not G or not G:match\"%d\"then break end;t=t..G end;if select(\"#\",...)>0 then return tonumber(t),self:read(...)else return tonumber(t)end elseif type(P)==\"number\"then if select(\"#\",...)>0 then return info.handle.read(P),self:read(...)else return info.handle.read(P)end else error(\"bad argument (invalid mode '\"..P..\"')\",2)end end;function bQ:write(...)if info.status~=\"ready\"then error(\"attempt to write to a \"..info.status..\" handle\",2)end;local bz;if select(\"#\",...)>0 then bz=\"\"for k,c in ipairs{...}do bz=bz..tostring(c)end end;local hl=bY.url..\"#\"..info.id;local s,n=hk{url=hl,body=bz,headers=bY.headers,binary=bY.encoding==\"binary\"or bY.encoding==nil,method=bY.method,redirect=bY.redirect}if s then hd[hl]=info;info.status=\"connecting\"else info.status,info.error=\"error\",n end end;function bQ:close()if info.status~=\"open\"then error(\"attempt to close a \"..info.status..\" handle\",2)end;info.handle.close()info.status=\"closed\"end;function bQ:responseHeaders()if info.status~=\"open\"then error(\"attempt to read from a \"..info.status..\" handle\",2)end;return info.handle.getResponseHeaders()end;function bQ:responseCode()if info.status~=\"open\"then error(\"attempt to read from a \"..info.status..\" handle\",2)end;return info.handle.getResponseCode()end;return bQ end;function hj(process,bY)expect.field(bY,\"encoding\",\"string\",\"nil\")expect.field(bY,\"headers\",\"table\",\"nil\")local info={process=process,id=gx,buffer=\"\"}local bQ=setmetatable({id=gx},{__name=\"socket\"})gx=gx+1;function bQ:status()return info.status,info.error end;function bQ:read(P,...)if info.status~=\"open\"then error(\"attempt to read from a \"..info.status..\" handle\",2)end;P=P or\"*l\"if type(P)~=\"string\"and type(P)~=\"number\"then error(\"bad argument (expected string or number, got \"..type(P)..\")\",2)end;if info.buffer==\"\"then return nil end;P=P:gsub(\"^%*\",\"\")if P==\"a\"then local t=info.buffer;info.buffer=\"\"return t elseif P==\"l\"then local t,au=info.buffer:match\"^([^\\n]*)\\n?()\"if t then info.buffer=info.buffer:sub(au)if select(\"#\",...)>0 then return t,self:read(...)else return t end else return nil end elseif P==\"L\"then local t,au=info.buffer:match\"^([^\\n]*\\n?)()\"if t then info.buffer=info.buffer:sub(au)if select(\"#\",...)>0 then return t,self:read(...)else return t end else return nil end elseif P==\"n\"then local t,au=info.buffer:match\"(%d+)()\"if t then info.buffer=info.buffer:sub(au)if select(\"#\",...)>0 then return tonumber(t),self:read(...)else return tonumber(t)end else return nil end elseif type(P)==\"number\"then local t=info.buffer:sub(1,P)info.buffer=info.buffer:sub(P+1)if select(\"#\",...)>0 then return t,self:read(...)else return t end else error(\"bad argument (invalid mode '\"..P..\"')\",2)end end;function bQ:write(bz,...)if info.status~=\"open\"then error(\"attempt to write to a \"..info.status..\" handle\",2)end;info.handle.send(tostring(bz),bY.encoding==\"binary\")if select(\"#\",...)>0 then return self:write(...)end end;function bQ:close()if info.status~=\"open\"then error(\"attempt to close a \"..info.status..\" handle\",2)end;info.handle.close()info.status=\"closed\"end;local hl=bY.url..\"#\"..info.id;local s,n=http.websocket(hl,bY.headers)if s then hd[hl]=info;info.status=\"connecting\"else return nil,n end;return bQ end end;local function hm(process,bY)expect.field(bY,\"device\",\"string\",\"nil\")local hn;if bY.device then hn={hardware.get(bY.device)}else hn={hardware.find(\"modem\")}end;if#hn==0 then error(\"Could not find a modem\",2)end;for k,c in ipairs(hn)do gw(c)if not he[c]then hardware.call(process,c,\"open\",hg)hardware.call(process,c,\"open\",65535)he[c]=1 else he[c]=he[c]+1 end end;local go=gn(bY.url)if not go.host then error(\"Missing host\",2)end;local aX=gp(go.host)local info={process=process,id=gx,buffer={},protocol=go.scheme:match\"rednet%+(.+)\"}local bQ=setmetatable({id=gx},{__name=\"socket\"})gx=gx+1;function bQ:status()return info.closed and\"closed\"or\"open\"end;function bQ:read(P,...)if info.closed then error(\"attempt to read from a \"..info.status..\" handle\",2)end;P=P or\"*l\"if type(P)~=\"string\"and type(P)~=\"number\"then error(\"bad argument (expected string or number, got \"..type(P)..\")\",2)end;if#info.buffer==0 then return nil end;P=P:gsub(\"^%*\",\"\")if P==\"a\"then return table.remove(info.buffer,1)elseif P==\"l\"then info.buffer[1]=tostring(info.buffer[1])local t,au=info.buffer[1]:match\"^([^\\n]*)\\n?()\"if t then info.buffer[1]=info.buffer[1]:sub(au)if select(\"#\",...)>0 then return t,self:read(...)else return t end else table.remove(info.buffer,1)return self:read(P,...)end elseif P==\"L\"then info.buffer[1]=tostring(info.buffer[1])local t,au=info.buffer[1]:match\"^([^\\n]*\\n?)()\"if t then info.buffer[1]=info.buffer[1]:sub(au)if select(\"#\",...)>0 then return t,self:read(...)else return t end else table.remove(info.buffer,1)return self:read(P,...)end elseif P==\"n\"then info.buffer[1]=tostring(info.buffer[1])local t,au=info.buffer[1]:match\"(%d+)()\"if t then info.buffer[1]=info.buffer[1]:sub(au)if select(\"#\",...)>0 then return tonumber(t),self:read(...)else return tonumber(t)end else table.remove(info.buffer,1)return self:read(P,...)end elseif type(P)==\"number\"then local t=\"\"while#t<P do info.buffer[1]=tostring(info.buffer[1])t=t..info.buffer[1]:sub(1,P-#t)info.buffer[1]=info.buffer[1]:sub(P-#t+1)if info.buffer[1]==\"\"then table.remove(info.buffer,1)end;if#info.buffer==0 then break end end;if select(\"#\",...)>0 then return t,self:read(...)else return t end else error(\"bad argument (invalid mode '\"..P..\"')\",2)end end;function bQ:write(bz,...)if info.closed then error(\"attempt to write to a \"..info.status..\" handle\",2)end;local ho=math.random(1,0x7FFFFFFF)local e={nMessageID=ho,nRecipient=aX,nSender=os.computerID(),message=bz,sProtocol=info.protocol}if aX==os.computerID()then for k,c in ipairs(hn)do os.queueEvent(\"modem_message\",c.id,hg,hg,e,0)end else hh[ho]=os.clock()+9.5;for k,c in ipairs(hn)do hardware.call(process,c,\"transmit\",aX==0xFFFFFFFF and 65535 or aX%65500,hg,e)hardware.call(process,c,\"transmit\",65533,hg,e)end end;if select(\"#\",...)>0 then return self:write(...)end end;function bQ:close()if info.closed then error(\"attempt to close a \"..info.status..\" handle\",2)end;for k,c in ipairs(hn)do he[c]=he[c]-1;if he[c]==0 then hardware.call(process,c,\"close\",hg)hardware.call(process,c,\"close\",65535)he[c]=nil end end;info.status=\"closed\"end;return bQ end;uriSchemes={[\"https?\"]=hi,[\"wss?\"]=hj,[\"rednet\"]=hm,[\"rednet%+%a+\"]=hm,[\"psp\"]=ha,[\"pdp\"]=hb}function syscalls.connect(process,aN,bY)if type(bY)==\"string\"then bY={url=bY}end;expect(1,bY,\"table\")expect.field(bY,\"url\",\"string\")local go=gn(bY.url)local bQ,n;for F,c in pairs(uriSchemes)do if go.scheme:match(F)then bQ,n=c(process,bY)break end end;if not bQ and not n then error(\"Invalid protocol \"..go.scheme)end;if bQ then for k,c in pairs(bQ)do if type(c)==\"function\"then setfenv(c,process.env)debug.protect(c)end end end;return bQ,n end;function syscalls.listen(process,aN,go)expect(1,go,\"string\")local hp=gn(go)if http and http.addListener then if hp.scheme==\"http\"then http.addListener(hp.port or 80)return elseif hp.scheme==\"ws\"then http.websocket(hp.port or 80)return end end;if hp.scheme==\"psp\"then if not hp.port then error(\"Missing port\")end;if gC[hp.port]and gC[hp.port].listen then error(\"Port already open\")end;local gq=gp(hp.host)local gL={}for F,c in pairs(gy)do if c.up and(gq==0 or c.ip==gq)then local fC=hardware.get(F)if not pcall(hardware.call,process,fC,\"open\",hp.port)then local gV={}for gK,bu in pairs(gC)do for gW,gJ in pairs(bu)do gV[#gV+1]=gK..\" -> \"..gW..\" (\"..gJ.status..\")\"end end;syslog.debug(\"Purging open channels\",table.concat(gV,\", \"))gU(true)hardware.call(process,fC,\"open\",hp.port)end;gL[fC.uuid]=true end end;local gJ={localPort=hp.port,id=gx,devices=gL,status=\"listening\",process=process,nextUpdate=math.huge,retryCount=0,uri=go,buffer=\"\"}gx=gx+1;gC[hp.port]=gC[hp.port]or{}gC[hp.port].listen=gJ;gD[gJ.id]=gJ;return elseif hp.scheme==\"pdp\"then if not hp.port then error(\"Missing port\")end;if gE[hp.port]then error(\"Port already open\")end;local gq=gp(hp.host)for F,c in pairs(gy)do if c.up and(gq==0 or c.ip==gq)then hardware.call(process,hardware.get(F),\"open\",hp.port)end end;gE[hp.port]={process=process,listen=true,open={}}return end;error(\"Invalid protocol \"..hp.scheme)end;function syscalls.unlisten(process,aN,go)expect(1,go,\"string\")local hp=gn(go)if http and http.addListener then if hp.scheme==\"http\"then http.removeListener(hp.port or 80)return elseif hp.scheme==\"ws\"then return end end;if hp.scheme==\"psp\"then if not hp.port then error(\"Missing port\")end;if not gC[hp.port]or not gC[hp.port].listen then return end;if gC[hp.port].listen.process~=process then error(\"Port open in another process\")end;for F in pairs(gC[hp.port].listen.devices)do hardware.call(process,hardware.get(F),\"close\",hp.port)end;gC[hp.port].listen=nil;return elseif hp.scheme==\"pdp\"then if not hp.port then error(\"Missing port\")end;if not gE[hp.port]then return end;local gq=gp(hp.host)for F,c in pairs(gy)do if c.up and(gq==0 or c.ip==gq)then hardware.call(process,hardware.get(F),\"close\",hp.port)end end;gE[hp.port]=nil;return end;error(\"Invalid protocol \"..hp.scheme)end;function syscalls.ipconfig(process,aN,fD,info)if info and process.user~=\"root\"then error(\"Permission denied\")end;expect(1,fD,\"string\")expect(2,info,\"table\",\"nil\")local eb=gw(hardware.get(fD))local X=gy[eb.uuid]if not X then if info then expect.field(info,\"ip\",\"string\",\"number\")expect.field(info,\"netmask\",\"string\",\"number\")X={up=true}gy[eb.uuid]=X;hardware.call(KERNEL,eb,\"open\",0)else return nil end end;if info then expect.field(info,\"ip\",\"string\",\"number\",\"nil\")expect.field(info,\"netmask\",\"string\",\"number\",\"nil\")expect.field(info,\"up\",\"boolean\",\"nil\")local hq,hr;if X.ip then for k,c in ipairs(gz[0])do if c.source==bit32.band(X.ip,X.netmask)and c.netmask==X.netmask then hq=c elseif c.source==bit32.bor(bit32.band(X.ip,X.netmask),bit32.bnot(X.netmask))and c.netmask==0xFFFFFFFF then hr=c end end end;if info.ip then if gA[eb.uuid]then gA[eb.uuid][X.ip]=nil end;if type(info.ip)==\"number\"then X.ip=bit32.band(info.ip,0xFFFFFFFF)else X.ip=gp(info.ip)end;if hq then hq.source=bit32.band(X.ip,X.netmask)end;if hr then hr.source=bit32.bor(bit32.band(X.ip,X.netmask),bit32.bnot(X.netmask))end;gA[eb.uuid]=gA[eb.uuid]or{}gA[eb.uuid][X.ip]=os.computerID()end;if info.netmask then if type(info.netmask)==\"number\"then X.netmask=gu(info.netmask)else X.netmask=gp(info.netmask)end;if hq then hq.source=bit32.band(X.ip,X.netmask)end;if hr then hr.source=bit32.bor(bit32.band(X.ip,X.netmask),bit32.bnot(X.netmask))end end;if info.up~=nil then X.up=info.up;if X.up then hardware.call(KERNEL,eb,\"open\",0)else hardware.call(KERNEL,eb,\"close\",0)end end;if not hq then gz[0][#gz[0]+1]={source=bit32.band(X.ip,X.netmask),sourceNetmask=X.netmask,action=\"local\",device=eb}end;if not hr then gz[0][#gz[0]+1]={source=bit32.bor(bit32.band(X.ip,X.netmask),bit32.bnot(X.netmask)),sourceNetmask=0xFFFFFFFF,action=\"broadcast\",device=eb}end end;return{ip=gr(X.ip),netmask=gv(X.netmask),up=X.up}end;function syscalls.routelist(process,aN,u)u=expect(1,u,\"number\",\"nil\")or 1;expect.range(u,0)if not gz[u]then return nil end;local as={}for o,X in ipairs(gz[u])do as[o]={source=gr(X.source),sourceNetmask=gv(X.sourceNetmask),action=X.action,device=X.device and hardware.path(X.device),destination=X.destination and gr(X.destination)}end;return as end;local hs={unicast=true,broadcast=true,[\"local\"]=true,unreachable=true,prohibit=true,blackhole=true}function syscalls.routeadd(process,aN,bY)if process.user~=\"root\"then error(\"Permission denied\")end;expect(1,bY,\"table\")expect.field(bY,\"source\",\"string\",\"number\")expect.field(bY,\"sourceNetmask\",\"string\",\"number\")expect.field(bY,\"action\",\"string\")expect.field(bY,\"device\",\"string\",bY.action~=\"unicast\"and bY.action~=\"broadcast\"and bY.action~=\"local\"and\"nil\"or nil)expect.field(bY,\"destination\",\"string\",bY.action~=\"unicast\"and\"nil\"or nil)expect.range(expect.field(bY,\"table\",\"number\",\"nil\")or 1,1)bY.table=bY.table or 1;if not hs[bY.action]then error(\"bad field 'action' (invalid option '\"..bY.action..\"')\")end;local X={}if type(bY.source)==\"number\"then X.source=bit32.band(bY.source,0xFFFFFFFF)else X.source=gp(bY.source)end;if type(bY.sourceNetmask)==\"number\"then X.sourceNetmask=gu(bY.sourceNetmask)else X.sourceNetmask=gp(bY.sourceNetmask)end;X.source=bit32.band(X.source,X.sourceNetmask)X.action=bY.action;X.device=bY.device and gw(hardware.get(bY.device))X.destination=bY.destination and gp(bY.destination)gz[bY.table]=gz[bY.table]or{}for k,c in ipairs(gz[bY.table])do if c.source==X.source and c.sourceNetmask==X.sourceNetmask then error(\"Route already exists\")end end;gz[bY.table][#gz[bY.table]+1]=X;gz.maxn=math.max(gz.maxn,bY.table)end;function syscalls.routedel(process,aN,ht,V,u)if process.user~=\"root\"then error(\"Permission denied\")end;expect(1,ht,\"string\",\"number\")expect(2,V,\"string\",\"number\")u=expect(3,u,\"number\",\"nil\")or 1;expect.range(u,1)if type(V)==\"number\"then V=gu(V)else V=gp(V)end;if type(ht)==\"number\"then ht=bit32.band(ht,V)else ht=bit32.band(gp(ht),V)end;if not gz[u]then error(\"Route table does not exist\")end;for o,c in ipairs(gz[u])do if c.source==ht and c.sourceNetmask==V then table.remove(gz[u],o)return end end end;function syscalls.arplist(process,aN,fD)expect(1,fD,\"string\")local eb=gw(hardware.get(fD))local as={}for F,c in pairs(gA[eb.uuid]or{})do as[gr(F)]=c end;return as end;function syscalls.arpset(process,aN,fD,gq,aX)if process.user~=\"root\"then error(\"Permission denied\")end;expect(1,fD,\"string\")expect(2,gq,\"string\",\"number\")expect(3,aX,\"number\")local eb=gw(hardware.get(fD))if type(gq)==\"string\"then gq=gp(gq)else gq=bit32.band(gq,0xFFFFFFFF)end;gA[eb.uuid]=gA[eb.uuid]or{}gA[eb.uuid][gq]=aX end;local hu={ping=true,pong=true,unreachable=true,timeout=true}function syscalls.netcontrol(process,aN,gq,l,n,gO)if process.user~=\"root\"then error(\"Permission denied\")end;expect(1,gq,\"string\",\"number\")expect(2,l,\"string\")expect(3,n,\"string\",\"nil\")expect(4,gO,\"number\",\"nil\")if not hu[l]then error(\"bad argument #2 (invalid option '\"..l..\"')\")end;if type(gq)==\"string\"then gq=gp(gq)else gq=bit32.band(gq,0xFFFFFFFF)end;gB.send.control({process=process},gq,l,n,gO)end;function syscalls.netevent(process,aN,dP)if process.user~=\"root\"then error(\"Permission denied\")end;expect(1,dP,\"boolean\",\"nil\")if dP==true then gF[process]=function(aA)process.eventQueue[#process.eventQueue+1]={\"network_event\",deepcopy(aA)}return true end elseif dP==false then gF[process]=nil end;return gF[process]~=nil end;function syscalls.checkuri(process,aN,go)end;function registerLoopback()local eb=hardware.get(\"/lo\")if eb then gy[eb.uuid]={ip=0x7F000001,netmask=0xFF000000,up=true}gz[0][#gz[0]+1]={source=0x7F000000,sourceNetmask=0xFF000000,action=\"local\",device=eb}gz[0][#gz[0]+1]={source=0x7FFFFFFF,sourceNetmask=0xFFFFFFFF,action=\"broadcast\",device=eb}gA[eb.uuid]=setmetatable({},{__index=function()return os.computerID()end})syslog.log(\"Configured IP for loopback device\")end end;function syscalls.listmodules()local as={}for F in pairs(modules)do as[#as+1]=F end;return as end;function syscalls.loadmodule(process,aN,bs)expect(1,bs,\"string\")if process.user~=\"root\"then error(\"Could not load kernel module: Permission denied\",2)end;local bZ=filesystem.stat(process,bs)if bZ.type==\"directory\"then error(\"Could not load kernel module: Is a directory\",2)end;if bZ.owner~=\"root\"or bZ.worldPermissions.write then error(\"Insecure permissions set on kernel module, refusing to load\",2)end;local O=bs:match\"([^%./]+)[^/]*$\"syslog.log(\"Loading kernel module \"..O..\" from \"..bs)local H,n=filesystem.open(process,bs,\"rb\")if H then local bz=H.readAll()or\"\"H.close()local J,n=load(bz,\"@\"..bs)if J then local s,E=pcall(J,bs)if s then modules[O]=E or true else syslog.log({level=\"error\"},\"Kernel module \"..O..\" threw an error:\",E)end else syslog.log({level=\"error\"},\"Could not load \"..O..\":\",n)end else syslog.log({level=\"error\"},\"Could not open \"..bs..\":\",n)end end;function syscalls.unloadmodule(process,aN,O)expect(1,O,\"string\")if process.user~=\"root\"then error(\"Could not load kernel module: Permission denied\",2)end;if type(modules[O])==\"table\"and modules[O].unload then modules[O].unload(process,aN)end;modules[O]=nil end;function syscalls.callmodule(process,aN,O,aW,...)expect(1,O,\"string\")expect(2,aW,\"string\")if not modules[O]then error(\"Module '\"..O..\"' does not exist\",2)elseif type(modules[O])~=\"table\"then error(\"Module '\"..O..\"' does not have a callable interface\",2)elseif aW==\"unload\"or type(modules[O][aW])~=\"function\"then error(\"Module '\"..O..\"' does not have a method '\"..aW..\"'\",2)end;return modules[O][aW](process,aN,...)end;syslog.log(\"Loading kernel modules from /lib/modules\")local s,hv=pcall(filesystem.list,KERNEL,\"/lib/modules\")if s then for k,c in ipairs(hv)do local a1=filesystem.combine(\"/lib/modules\",c)local bZ=filesystem.stat(KERNEL,a1)if bZ.type~=\"directory\"then local s,n=pcall(syscalls.loadmodule,KERNEL,nil,a1)if not s then syslog.log({level=\"error\"},\"Could not load module from \"..a1 ..\": \"..n)end end end else syslog.log({level=\"notice\"},\"Could not open /lib/modules:\",hv)end;xpcall(hardware.register,function(error)panic(\"An error occurred while registering devices: \"..error)end,deviceTreeRoot,rootDriver)local aM={n=0}local hw=processes[syscalls.fork(KERNEL,nil,function()end,\"init\")]local hx=hw.id;local hy,hz;if args.init then hy,hz=pcall(syscalls.exec,hw,nil,args.initrd and\"/init\"or args.init)end;if not hy then syslog.log({level=\"error\",process=0},\"Could not load init:\",hz)syslog.log(\"Could not find provided init, trying default locations\")for k,c in ipairs{\"/sbin/init\",\"/etc/init\",\"/bin/init\",\"/bin/sh\"}do syslog.log(\"Trying\",c)hy,hz=pcall(syscalls.exec,hw,nil,c)if not hy then syslog.log({level=\"error\",process=0},\"Could not load init:\",hz)end;if hy then break end end;if not hy then panic(\"No working init found\")end end;syslog.log(\"Starting init from \"..processes[hx].name)local aQ=false;local hA=setmetatable({},{__mode=\"k\"})function wakeup(process)if#process.eventQueue>0 and not hA[process]then aQ=false end end;local dq=coroutine.yield;function coroutine.yield(...)if coroutine.running()==mainThread then error(\"attempt to yield from kernel main thread\",2)end;return dq(...)end;debug.protect(coroutine.yield)eventHooks.key=eventHooks.key or{}eventHooks.key[#eventHooks.key+1]=function(aO)if keysHeld.ctrl and keysHeld.shift and aO[2]==keys.f10 then local aT=currentTTY;local dE=terminal.makeTTY(term,term.getSize())currentTTY=dE;terminal.write(dE,\"Entering debug console.\\n\")terminal.redraw(dE,true)local bf=true;while bf do terminal.write(dE,\"lua> \")terminal.redraw(dE)while true do local aO={dq()}if aO[1]==\"char\"or aO[1]==\"paste\"then if dE.flags.cbreak then dE.buffer=dE.buffer..aO[2]else dE.preBuffer=dE.preBuffer..aO[2]end;if dE.flags.echo then terminal.write(dE,aO[2])terminal.redraw(dE)end elseif aO[1]==\"key\"then if aO[2]==keys.enter then if dE.flags.cbreak then dE.buffer=dE.buffer..\"\\n\"else dE.buffer=dE.buffer..dE.preBuffer..\"\\n\"dE.preBuffer=\"\"end;if dE.flags.echo then terminal.write(dE,\"\\n\")terminal.redraw(dE)end;break elseif aO[2]==keys.backspace then if dE.flags.cbreak then elseif#dE.preBuffer>0 then dE.preBuffer=dE.preBuffer:sub(1,-2)if dE.flags.echo then terminal.write(dE,\"\\b \\b\")terminal.redraw(dE)end end end end end;local J,n=load(\"return \"..dE.buffer,\"=lua\",\"t\",setmetatable({exit=function()bf=false end,ps=function()local as={}for F,c in pairs(processes)do as[F]=c.name end;return as end},{__index=_G}))if not J then J,n=load(dE.buffer,\"=lua\",\"t\",setmetatable({exit=function()bf=false end,ps=function()local as={}for F,c in pairs(processes)do as[F]=c.name end;return as end},{__index=_G}))end;dE.buffer=\"\"if J then local E=table.pack(pcall(J))if E[1]then for o=2,E.n do if pretty_print then pretty_print(dE,E[o])else local bI=tostring(E[o])if type(E[o])==\"table\"then local s,hB=pcall(serialize,E[o])if s and hB then bI=hB end end;terminal.write(dE,bI..\"\\n\")end end else terminal.write(dE,\"\\x1b[31m\"..E[2]..\"\\x1b[0m\\n\")end else terminal.write(dE,\"\\x1b[31m\"..n..\"\\x1b[0m\\n\")end;terminal.redraw(dE)end;currentTTY=aT;terminal.redraw(currentTTY,true)end end;local hC={char=true,key=true,key_up=true,mouse_click=true,mouse_up=true,mouse_drag=true,mouse_scroll=true,paste=true}local s,n=xpcall(function()while processes[hx]do if not aQ then os.queueEvent(\"__event_queue_back\")end;while true do local aO=table.pack(dq())local O=aO[1]if O==\"__event_queue_back\"then break end;local hD=false;if eventHooks[O]then for k,c in ipairs(eventHooks[O])do hD=c(aO)or hD end end;if eventParameterMap[O]then local aS={}for o=2,#eventParameterMap[O]+1 do aS[eventParameterMap[O][o-1]]=aO[o]end;if O==\"key\"or O==\"key_up\"then aS.keycode=keymap[aS.keycode]aS.ctrlHeld=keysHeld.ctrl;aS.altHeld=keysHeld.alt;aS.shiftHeld=keysHeld.shift end;if O==\"mouse_scroll\"then aS.direction=aS.direction>0 end;if hC[O]and currentTTY.frontmostProcess then currentTTY.frontmostProcess.eventQueue[#currentTTY.frontmostProcess.eventQueue+1]={O,aS}hD=true elseif O==\"timer\"or O==\"alarm\"then local hE;if O==\"timer\"then hE=timerMap[aO[2]]else hE,aS.id=alarmMap[aO[2]],bit32.bor(aS.id,0x80000000)end;if hE then hE.eventQueue[#hE.eventQueue+1],hD={O,aS},true end end end;if aQ and hD then break end end;aQ=true;hA=setmetatable({},{__mode=\"k\"})for dc,process in pairs(processes)do if dc~=0 and not process.paused then local g2,aO=false,nil;local aP=true;for fc,aN in pairs(process.threads)do if not g2 and aN.status==\"suspended\"then aO=table.remove(process.eventQueue,1)g2=true end;if aO or aN.status~=\"suspended\"then local hF;aP,hF=executeThread(process,aN,aO or aM,aP,aQ)aQ=hF and aQ else aP=false end end;if aP then process.isDead=true;if process.lastReturnValue then if dc==hx then init_retval=process.lastReturnValue.value or process.lastReturnValue.error elseif processes[process.parent]then process.lastReturnValue.id=dc;processes[process.parent].eventQueue[#processes[process.parent].eventQueue+1]={\"process_complete\",process.lastReturnValue}end end;reap_process(process)processes[dc]=nil;aQ=false end;hA[process]=true end end;terminal.redraw(currentTTY)end end,debug.traceback)if not s then syslog.log({level=\"critical\",traceback=true},n)end;if postkill then postkill()end;if init_retval~=nil then syslog.log({level=4},\"init exited with result\",init_retval)end;panic(\"init program exited\")\n",setuser=false,size=283375,modified=1757997039421,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"}},setuser=false,size=0,modified=1757997043456,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},etc={permissions={root={write=true,read=true,execute=true}},created=1757997043159,contents={["ftpmgr.conf"]={permissions={root={read=true,write=true,execute=false}},created=1757997040614,data="## ftpmgr configuration file\n#:schema https://phoenix.madefor.cc/schema/ftpmgr.schema.json\n\n## The IP address to serve on. \"0.0.0.0\" indicates any IP/interface.\nip = \"0.0.0.0\"\n\n## The port to serve the command stream on. FTP standard is 21.\nport = 21\n\n## The range of ports to reserve for passive connections.\npassivePortRange = [65000, 65535]\n\n## Uncomment this to allow any user registered on the system to log in.\n#allUsers = true\n\n## The users allowed to connect. A special \"anonymous\" user is used for\n## connections without a login - if not present, clients will be required to log\n## in before accessing files.\n\n## The default root login, which authenticates via usermgr, and allows access to\n## the entire filesystem with root permissions.\n\n[users.root]\n\n## An example of an anonymous login, which runs as a virtual user and does not\n## require a password.\n\n#[users.anonymous]\n#    systemUser = \"ftp-user\"   # The Phoenix username to run the server as\n#    allowWrite = false        # Whether to allow the user to write files\n#    useSystemLogin = false    # Whether to use usermgr to authenticate logins\n#    root = \"/var/ftp\"         # The filesystem root visible to the user\n\n## An example of a virtual user with a password. This user runs as root, but\n## does not have write permissions.\n\n#[users.virtual]\n#    password = \"virtual-user-password!\"    # The password for the user (plaintext!)\n#    allowWrite = false                     # Whether to allow the user to write files\n#    root = \"/\"                             # The filesystem root visible to the user\n\n## An example of a virtual user with a more securely stored password. This user\n## runs as a user named \"virtual\", but does not check usermgr, and thus does not\n## need to be a registered user on the system.\n\n#[users.virtual-secure]\n#    systemUser = \"virtual\"     # The Phoenix username to run the server as\n#    # The hash of the password in SHA-256\n#    passwordHash = \"05bb25e9186d1014c5eb723edb0bf17987e6fe1b9eaeae5c88f217d1b3024b23\"\n#    passwordSalt = \"12345678\"  # The salt applied to the end of the password\n#    allowWrite = true          # Whether to allow the user to write files\n#    root = \"/\"                 # The filesystem root visible to the user\n",setuser=false,size=2243,modified=1757997040588,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},initrd={permissions={root={write=true,read=true,execute=true}},created=1757997040840,contents={scripts={permissions={root={write=true,read=true,execute=true}},created=1757997040510,contents={["encryptfs.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040510,data="io.write(\"Enter encryption password: \")coroutine.yield(\"syscall\",\"termctl\",{echo=false})options.encryptfs_password=io.read()io.write(\"\\n\")coroutine.yield(\"syscall\",\"termctl\",{echo=true})\n",setuser=false,size=187,modified=1757997040504,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997040510,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},["hooks.d"]={permissions={root={write=true,read=true,execute=true}},created=1757997040839,contents={["01-files.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040837,data="if not config.modules then return end;local a=require\"system.filesystem\"for b,c in ipairs(config.files)do local d,e=c:match(\"^([^=]+)=(.+)$\")if not e then d,e=c,c end;e=a.combine(rootDirectory,e)a.copy(d,e,true)end\n",setuser=false,size=215,modified=1757997040824,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["10-init.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040839,data="local a=[==[\nprint(\"initrd: init running\")\noptions = {}\n]==]if config.hook_preflight then for b,c in ipairs(config.hook_preflight)do a=a..'print(\"initrd: running hook '..c..'\")\\ndofile(\"'..c..'\")\\n'end end;a=a..[==[\nprint(\"initrd: mounting root filesystem\")\nlocal _, args = coroutine.yield(\"syscall\", \"kernargs\")\nif args.rootflags then\n    for m in args.rootflags:gmatch \"[^,]+\" do\n        local k, v = m:match(\"^([^=]+)=(.*)$\")\n        if k and v then\n            if v == \"true\" then options[k] = true\n            elseif v == \"false\" then options[k] = false\n            else options[k] = tonumber(v) or v end\n        else options[m] = true end\n    end\nend\ncoroutine.yield(\"syscall\", \"unmount\", \"/\")\nlocal ok, err = coroutine.yield(\"syscall\", \"mount\", args.rootfstype or \"craftos\", args.root, \"/\", options)\nif not ok then\n    coroutine.yield(\"syscall\", \"syslog\", {module = \"initrd\", level = 6}, \"initrd: could not mount root device: \" .. err .. \"\\n\")\n    while true do coroutine.yield() end\n    return false\nend\n-- TODO: reopen log file\n]==]if config.hook_postflight then for b,c in ipairs(config.hook_postflight)do a=a..'print(\"initrd: running hook '..c..'\")\\ndofile(\"'..c..'\")\\n'end end;a=a..[==[\nprint(\"initrd: starting real init\")\nif args.init then coroutine.yield(\"syscall\", \"exec\", args.init) end\nprint(\"Could not find provided init, trying default locations\")\ncoroutine.yield(\"syscall\", \"exec\", \"/sbin/init\")\ncoroutine.yield(\"syscall\", \"exec\", \"/etc/init\")\ncoroutine.yield(\"syscall\", \"exec\", \"/bin/init\")\ncoroutine.yield(\"syscall\", \"exec\", \"/bin/sh\")\nio.stderr:write(\"initrd: no working init found\")\nreturn false\n]==]local d=assert(io.open(rootDirectory..\"/init.lua\",\"w\"))d:write(a)d:close()\n",setuser=false,size=1699,modified=1757997040825,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["05-shell.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040838,data="if not config.rescue_shell then return end;local a=require\"system.filesystem\"a.copy(\"/bin/cash.lua\",a.combine(rootDirectory,\"bin/cash.lua\"),true)a.copy(\"/bin/chmod.lua\",a.combine(rootDirectory,\"bin/chmod.lua\"),true)a.copy(\"/bin/chown.lua\",a.combine(rootDirectory,\"bin/chown.lua\"),true)a.copy(\"/bin/chroot.lua\",a.combine(rootDirectory,\"bin/chroot.lua\"),true)a.copy(\"/bin/cp.lua\",a.combine(rootDirectory,\"bin/cp.lua\"),true)a.copy(\"/bin/kill.lua\",a.combine(rootDirectory,\"bin/kill.lua\"),true)a.copy(\"/bin/less.lua\",a.combine(rootDirectory,\"bin/less.lua\"),true)a.copy(\"/bin/link.lua\",a.combine(rootDirectory,\"bin/link.lua\"),true)a.copy(\"/bin/ls.lua\",a.combine(rootDirectory,\"bin/ls.lua\"),true)a.copy(\"/bin/lua.lua\",a.combine(rootDirectory,\"bin/lua.lua\"),true)a.copy(\"/bin/mkdir.lua\",a.combine(rootDirectory,\"bin/mkdir.lua\"),true)a.copy(\"/bin/mount.lua\",a.combine(rootDirectory,\"bin/mount.lua\"),true)a.copy(\"/bin/nano.lua\",a.combine(rootDirectory,\"bin/nano.lua\"),true)a.copy(\"/bin/ps.lua\",a.combine(rootDirectory,\"bin/ps.lua\"),true)a.copy(\"/bin/rm.lua\",a.combine(rootDirectory,\"bin/rm.lua\"),true)a.copy(\"/bin/sh.lua\",a.combine(rootDirectory,\"bin/sh.lua\"),true)a.copy(\"/bin/unmount.lua\",a.combine(rootDirectory,\"bin/unmount.lua\"),true)a.copy(\"/lib/libsystem.a\",a.combine(rootDirectory,\"lib/libsystem.a\"),true)\n",setuser=false,size=1304,modified=1757997040825,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["00-modules.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040836,data="if not config.modules then return end;local a=require\"system.filesystem\"a.mkdir(a.combine(rootDirectory,\"lib/modules\"))for b,c in ipairs(config.modules)do local d=a.combine(rootDirectory,\"lib/modules\",c..\".lua\")a.copy(\"/lib/modules/\"..c..\".lua\",d)a.chmod(d,\"root\",\"rwx\")a.chmod(d,nil,\"r-x\")a.chown(d,\"root\")end\n",setuser=false,size=311,modified=1757997040823,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997040839,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},["initrd.conf.template"]={permissions={root={write=true,read=true,execute=true}},created=1757997040509,contents={["encryptfs.conf"]={permissions={root={read=true,write=true,execute=false}},created=1757997040509,data="## Copy this file to /etc/initrd/initrd.conf.d to use encryptfs as a root filesystem.\n\nmodules[#modules+1] = \"encryptfs\"\n\nfiles[#files+1] = \"/etc/initrd/scripts/encryptfs.lua=/encryptfs.lua\"\nfiles[#files+1] = \"/usr/lib/libccryptolib.a\"\nfiles[#files+1] = \"/lib/libsystem.a\"\n\nhook_preflight[#hook_preflight+1] = \"/encryptfs.lua\"\n",setuser=false,size=327,modified=1757997040503,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["compressfs.conf"]={permissions={root={read=true,write=true,execute=false}},created=1757997040054,data="## Copy this file to /etc/initrd/initrd.conf.d to use compressfs as a root filesystem.\n\nmodules[#modules+1] = \"compressfs\"\n\nfiles[#files+1] = \"/usr/lib/libdeflate.lua\"\nfiles[#files+1] = \"/lib/libsystem.a\"\n",setuser=false,size=205,modified=1757997040051,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997040509,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},["initrd.conf"]={permissions={root={read=true,write=true,execute=false}},created=1757997040840,data="# initrd configuration file\n\n# Uncomment this line to add a rescue shell and utilites to the initrd.\n# rescue_shell = true\n\n# A list of kernel modules to include in the initrd.\n# Example:\n# modules = {\"spanfs\", \"gfxterm\"}\nmodules = {}\n\n# A list of files to copy to the initrd.\n# These should be absolute paths to files on the main filesystem, with an\n# optional \"=<path>\" to move the file to a different location.\n# Example:\n# files = {\"/bin/nano.lua\", \"/lib/libsystem.a\", \"/etc/initrd/myhook.lua=/myhook.lua\"}\nfiles = {}\n\n# A list of files to execute in the init program before mounting the root filesystem.\n# These are executed using dofile, and thus must be full Lua file names, with\n# extensions if needed.\n# Example:\n# hook_preflight = {\"/myhook.lua\"}\nhook_preflight = {}\n\n# A list of files to execute in the init program after root is mounted but before\n# the real init is executed. The initrd is no longer mounted at this point.\n# These are executed using dofile, and thus must be full Lua file names, with\n# extensions if needed.\n# Example:\n# hook_postflight = {\"/bin/myhook.lua\"}\nhook_postflight = {}\n\n# Where to save the initrd file to.\noutput_path = \"/boot/initrd.img\"",setuser=false,size=1179,modified=1757997040826,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997040840,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},["dhcpmgr.conf"]={permissions={root={read=true,write=true,execute=false}},created=1757997040158,data="## dhcpmgr configuration file\n#:schema https://phoenix.madefor.cc/schema/dhcpmgr.schema.json\n\n## The network interface to host on. Leaving it undefined will host on a random\n## interface - this is not recommended for most uses, so make sure to set it.\n#interface = \"/back\"\n\n## The first address to assign to clients.\nfirstaddr = \"10.0.1.2\"\n\n## The last address to assign to clients.\nlastaddr = \"10.0.1.254\"\n\n## The network mask for assigned addresses. If not set, the mask will be\n## inferred from the first and last addresses.\n#netmask = \"255.255.255.0\"\n\n## The gateway address to report to clients. Leave unset to not report a gateway.\ngateway = \"10.0.1.1\"\n\n## The DNS server addresses to report to clients. Leave unset to not report DNS.\ndns = [\"10.0.1.1\"]\n\n## The length of a DHCP lease, in seconds. Unset means the lease never expires.\nleasetime = 86400\n\n## Whether to allow clients to request static addresses.\nallowrequests = true\n\n## Whether to store address assignments for clients permanently.\n## If this is enabled, the server will store the first address assigned to a\n## client, and will prefer to use that address if available.\nstoreassignments = false\n\n## Whether to force re-assigning addresses if a client requests an IP before its\n## lease expires.\nforcereassign = false\n\n## Static address assignments. This maps computer IDs to IP addresses.\n[static]\n#    25 = \"10.0.1.15\"\n#    28 = \"10.0.1.132\"\n\n## Other options to provide to clients.\n[options]\n#    domain = \"subnet.cc\"\n#    bootServers = [\"10.0.1.1\"]\n#    bootFile = \"/boot.lua\"\n",setuser=false,size=1552,modified=1757997040155,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},fstab={permissions={root={read=true,write=true,execute=false}},created=1757997043456,data="tmpfs /tmp tmpfs defaults,auto 0 0\ntmpfs /var/log tmpfs defaults,auto 0 0\n/rom /rom craftos defaults,auto 0 0\n/ /root craftos defaults,auto 0 0\n",setuser=false,size=144,modified=1757997043456,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},startmgr={permissions={root={write=true,read=true,execute=true}},created=1757997039901,contents={system={permissions={root={write=true,read=true,execute=true}},created=1757997043421,contents={["login.service"]={permissions={root={read=true,write=true,execute=false}},created=1757997043160,data="local process = require \"system.process\"\n\nunit.description = \"Login Prompt\"\nunit.requires = {\"usermgr\"}\nunit.after = {\"usermgr\"}\nservice.restart = \"always\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.start(\"/usr/bin/login\")\n    return true\nend\n",setuser=false,size=300,modified=1757997043106,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["ftpmgr.service"]={permissions={root={read=true,write=true,execute=false}},created=1757997040615,data="local process = require \"system.process\"\n\nunit.description = \"FTP server\"\nservice.restart = \"always\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.startbg(\"/usr/libexec/ftpmgr\")\n    return true\nend\n",setuser=false,size=252,modified=1757997040589,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["automount.service"]={permissions={root={read=true,write=true,execute=false}},created=1757997039933,data="local process = require \"system.process\"\n\nunit.description = \"Automatically mount filesystems\"\nservice.restart = \"no\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.startbg(\"/bin/mount\", \"-a\")\n    return true\nend",setuser=false,size=265,modified=1757997039901,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["yellowbox.service"]={permissions={root={read=true,write=true,execute=false}},created=1757997043421,data="local filesystem = require \"system.filesystem\"\nlocal process = require \"system.process\"\nlocal yellowbox = require \"yellowbox\"\n\nunit.description = \"Virtual CraftOS container\"\nservice.restart = \"always\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    \nend\n\nfunction stop()\n\nend\n",setuser=false,size=303,modified=1757997043405,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["startup.service"]={permissions={root={read=true,write=true,execute=false}},created=1757997042775,data="unit.description = \"Startup Tasks\"\nunit.requires = {}\n\nfunction start() return true end\nfunction stop() return true end",setuser=false,size=119,modified=1757997042750,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["startup.service.wants"]={permissions={root={write=true,read=true,execute=true}},created=1757997043174,contents={["login.service"]={permissions={root={read=true,write=true,execute=false}},created=1757997043160,data="local process = require \"system.process\"\n\nunit.description = \"Login Prompt\"\nunit.requires = {\"usermgr\"}\nunit.after = {\"usermgr\"}\nservice.restart = \"always\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.start(\"/usr/bin/login\")\n    return true\nend\n",setuser=false,size=300,modified=1757997043106,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["diskmgr.service"]={permissions={root={read=true,write=true,execute=false}},created=1757997040256,data="local process = require \"system.process\"\n\nunit.description = \"Disk Manager\"\nservice.restart = \"always\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.startbg(\"/usr/libexec/diskmgr\")\n    return true\nend\n",setuser=false,size=255,modified=1757997040253,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["automount.service"]={permissions={root={read=true,write=true,execute=false}},created=1757997039933,data="local process = require \"system.process\"\n\nunit.description = \"Automatically mount filesystems\"\nservice.restart = \"no\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.startbg(\"/bin/mount\", \"-a\")\n    return true\nend",setuser=false,size=265,modified=1757997039901,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997043174,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},["netmgr.service"]={permissions={root={read=true,write=true,execute=false}},created=1757997041536,data="local process = require \"system.process\"\n\nunit.description = \"Networking Manager\"\nservice.restart = \"always\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.startbg(\"/usr/libexec/netmgr\")\n    return true\nend\n",setuser=false,size=260,modified=1757997041532,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["usermgr.service"]={permissions={root={read=true,write=true,execute=false}},created=1757997043161,data="local process = require \"system.process\"\n\nunit.description = \"User Manager\"\nservice.restart = \"always\"\nservice.restartTime = 0\n\nfunction start()\n    service.pid[1] = process.startbg(\"/usr/libexec/usermgr\")\n    return true\nend\n",setuser=false,size=226,modified=1757997043107,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["diskmgr.service"]={permissions={root={read=true,write=true,execute=false}},created=1757997040256,data="local process = require \"system.process\"\n\nunit.description = \"Disk Manager\"\nservice.restart = \"always\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.startbg(\"/usr/libexec/diskmgr\")\n    return true\nend\n",setuser=false,size=255,modified=1757997040253,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["dhcpmgr.service"]={permissions={root={read=true,write=true,execute=false}},created=1757997040159,data="local process = require \"system.process\"\n\nunit.description = \"DHCP Manager\"\nservice.restart = \"always\"\nservice.restartTime = 0\nservice.wants = {\"netmgr\"}\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.startbg(\"/usr/libexec/dhcpmgr\")\n    return true\nend\n",setuser=false,size=282,modified=1757997040155,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997043421,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"}},size=0,modified=1757997039901,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},["network.conf"]={permissions={root={read=true,write=true,execute=false}},created=1757997041535,data="## netmgr network configuration file\n## WORK-IN-PROGRESS - not all features implemented\n#:schema https://phoenix.madefor.cc/schema/netmgr.schema.json\n\n## Defines a set of rules for a specific network interface.\n## `[auto]` will be used for any device that doesn't have its own config.\n## Otherwise, use `[\"<device>\"]` to select a device.\n\n[auto]\n    ## Sets the way to acquire a network address. Valid options:\n    ## none - Do not configure this device\n    ## dhcp - Use DHCP to automatically acquire an address from a server/router\n    ## dhcp-static - Use DHCP with a manual requested address\n    ## static - Use a static address\n    acquire = \"dhcp\"\n\n    ## If using a static IP address, define its parameters here.\n    ## dhcp-static only needs `address`.\n    ## static needs `address`, `netmask` (if not in the address), and `gateway`.\n    # address = \"10.0.1.2/24\"   # sets the netmask in the address\n    # address = \"10.0.1.2\"      # sets the netmask separately\n    # netmask = \"255.255.255.0\"\n    # gateway = \"10.0.1.1\"\n\n    ## DNS servers to use when resolving domain names. Optional if using DHCP.\n    # dns = [\n    #     \"10.0.1.1\",\n    #     \"10.0.1.4\"\n    # ]\n\n## Sets the IP for the loopback device.\n[\"/lo\"]\n    acquire = \"static\"\n    address = \"127.0.0.1/24\"\n",setuser=false,size=1275,modified=1757997041531,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},skel={permissions={root={write=true,read=true,execute=true}},created=1757997043159,contents={[".cashrc"]={permissions={root={read=true,write=true,execute=false}},created=1757997043159,data="PS1=\"\\033[1;32m\\u@\\h\\033[39m:\\033[34m\\W\\033[0m\\$ \"",setuser=false,size=50,modified=1757997043105,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997043159,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},motd={permissions={root={read=true,write=true,execute=false}},created=1757997043158,data="\nWelcome to Phoenix, the next generation operating system for ComputerCraft.\n",setuser=false,size=77,modified=1757997043103,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},passwd={permissions={root={read=true,write=true,execute=false}},created=1757997043456,data="phoenix:x::::/home/phoenix:/bin/cash\n",setuser=false,size=37,modified=1757997043456,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},apt={permissions={root={write=true,read=true,execute=true}},created=1757997039608,contents={["sources.list"]={permissions={root={read=true,write=true,execute=false}},created=1757997039608,data="deb https://phoenix.madefor.cc/packages/ latest main\n",setuser=false,size=53,modified=1757997039594,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["trusted.gpg.d"]={permissions={root={write=true,read=true,execute=true}},created=1757997039609,contents={["phoenix.gpg"]={permissions={root={read=true,write=true,execute=false}},created=1757997039609,data="\1523\004f\178\254i\022\009+\006\001\004\001\218G\015\001\001\007@\1563[E4\188\183\236D\245B\157mb\030\128\241\233k\024:\001\178\212\190\136\150\014\214{-\230\180;Phoenix APT Signing <jackmacwindowslinux+phoenix@gmail.com>\136\153\004\019\022\n\000A\022!\004\n\003\211 k S\r\129\028\141\253\165Y\213\249\001Nr\132\005\002f\178\254i\002\027\003\005\009\005\1646\023\005\011\009\008\007\002\002\"\002\006\021\n\009\008\011\002\004\022\002\003\001\002\030\007\002\023\128\000\n\009\016\165Y\213\249\001Nr\132\031\245\000\254*\215P\142\154?D\165\"\024\215V$=C\222\172\1270\008\216\009sc\207$\180\241\178\224\134\n\000\255_\1638~\248\002Z\022mC\027\254W\242j\173\253\139\184\163\018\190\028\175\151G\029bw\031\231\002\137\001\179\004\016\001\008\000\029\022!\004X_\136&](?\163\129@(]\190\145\144\247$5\164%\005\002f\178\254\170\000\n\009\016\190\145\144\247$5\164%\238\166\011\2542\019\238\192,\180h>l\141%\254\2207\254\255yK\002\145\000\241_\206V>\238\213\028\230F\022X{|\133\145\251/\016{\178J\180\147\189\000i\0176_\148\171k\n\213\207m\206'\253D\225\249\225\201K\164\222bF$\163\n\210:\134\152\235\r\169\"Q\140\008\020\003\187\174\128)\022\212n\169\158m\009)\161Y\153|\018\008\230\187\224d\023w\144No]S\175wE\171R)\254\144\000:\150\248Us\018Z\181#$\200\178\241\141\017,\173\172\191\176\002T\255\167\181\244\237\142\210\225<\218b\197\146\197\247\157\026:\205u\241\027\233\186\167j!\140\165p\2214\014]\217\143q\198\145\181S\245\144~[\185\177\233\221\148Fq\127@PQ\020\212f\014\174G\250\254\207\147\213#V\190C\"!\204\197d2\018\210!\148j\154\015\243\001\0287\235\230\132-\221\000\182:\172n\142\008P~\210\187u\159V)\150T\012G`\214ti\196\022%6C\196\169\149\134x\208O\1994k\252\184YB{]\027\235\168\\092/\171\246\n\135_39r\006\197\006\223/Mzu\171\221\210\222\142uX\197\021\188\031U\148W3\170\215x\207A\\092\2221\134\131\210\023\182>c\137\183\182\133\254e\197\024_\222^7Z3\026I9\140T\021b\234k\015\228\192n+;+\142X*\2263\246'\191SL\\}`\178\158\207\234\1848\004f\178\254i\018\n+\006\001\004\001\151U\001\005\001\001\007@\213\\092\141\016Uc\136\1342\1402\001\006\226\170\178\020j\236\215\228\206\006\238\131\225\148\255*\184)\003\001\008\007\136~\004\024\022\n\000&\022!\004\n\003\211 k S\r\129\028\141\253\165Y\213\249\001Nr\132\005\002f\178\254i\002\027\012\005\009\005\1646\023\000\n\009\016\165Y\213\249\001Nr\132(\168\001\000\130\253\024^8$I\1901\\092\031\154@R\255\026\030\146\004\127\210^\235\207\154\210\002m\227\239\150\001\000\150\130Y\236\\092\157\149\252\129\140\247\150\228\014P\005\239r^\157\170a\180P\019\201\0197\162\025\014",setuser=false,size=893,modified=1757997039595,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997039609,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"}},size=0,modified=1757997039608,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},shadow={permissions={root={read=true,write=true,execute=false}},created=1757997043456,data="phoenix:$5$atf2kZPrcjWCESpuOohJXA==$OTIxYmM2NTYwMWM5Y2M5MWZmMzhmNzc2OTRkNjQ4YTA1M2EzNzc0NmIxYjU4YzJkZGYyYjhkMWMwYjllNGJjYQ==:19540::::::\n",setuser=false,size=137,modified=1757997043456,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997043159,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},var={permissions={root={write=true,read=true,execute=true}},created=1757997039421,contents={lib={permissions={root={write=true,read=true,execute=true}},created=1757997043418,contents={dpkg={permissions={root={write=true,read=true,execute=true}},created=1757997043425,contents={triggers={permissions={root={write=true,read=true,execute=true}},created=1757997043453,contents={File={permissions={root={read=true,write=true,execute=true}},created=1757997039904,data="/usr/share/man baseutils\n",setuser=false,size=25,modified=1757997039904,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},Unincorp={permissions={root={read=true,write=true,execute=true}},created=1757997043452,data="",setuser=false,size=0,modified=1757997043451,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"}},setuser=false,size=0,modified=1757997043453,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},status={permissions={root={read=true,write=true,execute=true}},created=1757997043454,data="Package: encryptfs\nDepends: libsystem, ccryptolib (>= 1.2.0)\nVersion: 1.0-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nPriority: optional\nStatus: install ok installed\nSection: kernel\nDescription: Encrypted file system driver\n Implements a file system that encrypts diskcontents automatically.\n\nPackage: muxzcat\nArchitecture: phoenix\nSection: libraries\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nVersion: 1.1-1\nStatus: install ok installed\nDescription: LZMA/XZ decompression library\n Provides functions for decompressing LZMA and XZformat compressed files.\n\nPackage: asn1\nVersion: 1.0-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nHomepage: https://github.com/kunkku/lua-asn1\nArchitecture: phoenix\nSection: libraries\nStatus: install ok installed\nPriority: optional\nDescription: ASN.1 serialization library\n Handles serializing and deserializing tables inASN.1 DER format.\n\nPackage: diff\nDepends: libsystem\nVersion: 1.0-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: utils\nArchitecture: phoenix\nStatus: install ok installed\nPriority: important\nDescription: File comparison library and utility\n Provides a library for comparing files, as well asprograms for comparing and patching using the lib.\n\nPackage: apt\nDepends: libsystem (>= 0.1.6), dpkg (>= 0.2.6), sha2, pgp, libdeflate, muxzcat\nVersion: 0.2.2-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: admin\nArchitecture: phoenix\nStatus: install ok installed\nPriority: standard\nDescription: Advanced Package Tool for Phoenix\n A port of the Debian Advanced Package Tool to thePhoenix operating system, written in Lua.\n\nPackage: initrd-utils\nDepends: libsystem\nVersion: 0.1.1-2\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nPriority: optional\nStatus: install ok installed\nSection: admin\nDescription: initrd management tools\n Contains a collection of utility programs to createand manage initial ramdisk (initrd) files.\n\nPackage: deflateans\nArchitecture: phoenix\nSection: libraries\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nVersion: 1.0-1\nStatus: install ok installed\nDescription: Compression algorithm utilizing ANS\n A variant of DEFLATE that uses asymmetrical numeral systemsinstead of Huffman coding, increasing decompression speed with similarcompression ratios.\n\nPackage: pdb\nDepends: libsystem (>= 0.1.6)\nVersion: 0.1.1-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: devel\nStatus: install ok installed\nPriority: optional\nArchitecture: phoenix\nDescription: Phoenix debugger program\n Implements a GDB-like debugger for Phoenixprograms.\n\nPackage: mpi\nArchitecture: phoenix\nSection: libraries\nStatus: install ok installed\nPriority: optional\nVersion: 1.0-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Multi-precision integer library\n Provides functions for working with multi-precision integers, with functions for RSAencryption included.\n\nPackage: netutils\nDepends: libsystem\nVersion: 0.1-2\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: net\nArchitecture: phoenix\nStatus: install ok installed\nPriority: optional\nDescription: Network configuration utilities\n Provides a set of programs to configure the systemnetworking layer.\n\nPackage: startmgr\nDepends: libsystem\nVersion: 0.1.2-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: admin\nStatus: install ok installed\nArchitecture: phoenix\nPriority: standard\nEssential: yes\nDescription: Phoenix service manager and init system\n Provides automatic service management facilitiesfor Phoenix systems.\n\nPackage: libdeflate\nArchitecture: phoenix\nSection: libraries\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nVersion: 1.0.2-3\nStatus: install ok installed\nDescription: DEFLATE/zlib compression library\n Provides compression and decompression for DEFLATEformatted archives, including zlib and gzip files.\n\nPackage: tar\nDepends: libsystem\nVersion: 1.0.1-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: utils\nArchitecture: phoenix\nStatus: install ok installed\nPriority: important\nDescription: TAR archive format library and program\n Allows creating and extracting TAR archives.\n\nPackage: fuse\nArchitecture: phoenix\nSection: kernel\nStatus: install ok installed\nPriority: optional\nVersion: 0.1-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Filesystem in userspace module\n fuse implements filesystems in userspace, allowingfilesystems to be implemented without using kernelmodules.\n\nPackage: yahtcc\nDepends: libsystem\nVersion: 1.0-3\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nPriority: optional\nStatus: install ok installed\nSection: games\nDescription: Yahtzee game for Phoenix\n Yahtzee game for Phoenix\n\nPackage: baseutils\nDepends: libsystem\nVersion: 0.2.2-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nPriority: important\nStatus: install ok installed\nSection: utils\nDescription: base utility set for Phoenix\n Contains a standard set of POSIX utilities for Phoenix.\n\nPackage: ftp\nDepends: libsystem, sha2\nVersion: 0.1.1-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nRecommends: fuse, usermgr, startmgr\nSection: net\nStatus: install ok installed\nPriority: optional\nDescription: RFC 959-compliant FTP client & server\n Implements the FTP protocol on top of Phoenixsockets. Includes an object-oriented library formanaging clients and servers, as well as a smallserver manager for FTP access, and a FUSEfilesystem for mounting FTP shares locally.\n\nPackage: yellowbox\nDepends: libsystem, libcraftos\nVersion: 0.1-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: otherosfs\nArchitecture: phoenix\nStatus: install ok installed\nPriority: optional\nDescription: CraftOS emulator in the kernel\n    Kernel module that implements a ComputerCraft   emulator in the Phoenix kernel. Allows runningCraftOS programs on a proper CraftOS machine,without using shims or compatibility libraries.\n\nPackage: pxboot\nVersion: 0.1.3-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: admin\nArchitecture: phoenix\nEssential: yes\nStatus: install ok installed\nPriority: required\nDescription: Multipurpose bootloader for ComputerCraft\n A bootloader for ComputerCraft operating systemswith built-in UnBIOS functionality, a configurableselection menu, and more. Designed for Phoenix,but supports other OSes as well, including CraftOS.\n\nPackage: libsystem\nVersion: 0.1.6-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nSection: libraries\nPriority: required\nStatus: install ok installed\nEssential: yes\nDescription: System libraries for Phoenix\n Provides convenient wrapper functions for usingPhoenix syscalls, as well as various usefulcomponents for programs.\n\nPackage: pgp\nDepends: libsystem, ccryptolib, sha2, aes, mpi\nVersion: 0.2-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nSection: utils\nPriority: standard\nStatus: install ok installed\nDescription: OpenPGP implementation for Phoenix\n Implements the OpenPGP (RFC 4880/9580) standardcryptography scheme in Phoenix, including GPGextensions.\n\nPackage: sha2\nDepends: libsystem\nVersion: 12-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: libraries\nStatus: install ok installed\nPriority: optional\nArchitecture: phoenix\nDescription: SHA-1, SHA-2, SHA-3, BLAKE2 and BLAKE3 functions written in pure Lua and optimized for speed.\n This module contains functions to calculate SHA digest:   MD5, SHA-1,   SHA-224, SHA-256, SHA-512/224, SHA-512/256, SHA-384, SHA-512,   SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, SHAKE256,   HMAC,   BLAKE2b, BLAKE2s, BLAKE2bp, BLAKE2sp, BLAKE2Xb, BLAKE2Xs,   BLAKE3, BLAKE3_KDFWritten in pure Lua.Compatible with:   Lua 5.1, Lua 5.2, Lua 5.3, Lua 5.4, Fengari, LuaJIT 2.0/2.1 (any CPU endianness).Main feature of this module: it was heavily optimized for speed.For every Lua version the module contains particular implementation branch to get benefits from version-specific features.   - branch for Lua 5.1 (emulating bitwise operators using look-up table)   - branch for Lua 5.2 (using bit32/bit library), suitable for both Lua 5.2 with native \"bit32\" and Lua 5.1 with external library \"bit\"   - branch for Lua 5.3/5.4 (using native 64-bit bitwise operators)   - branch for Lua 5.3/5.4 (using native 32-bit bitwise operators) for Lua built with LUA_INT_TYPE=LUA_INT_INT   - branch for LuaJIT without FFI library (useful in a sandboxed environment)   - branch for LuaJIT x86 without FFI library (LuaJIT x86 has oddity because of lack of CPU registers)   - branch for LuaJIT 2.0 with FFI library (bit.* functions work only with Lua numbers)   - branch for LuaJIT 2.1 with FFI library (bit.* functions can work with \"int64_t\" arguments)\n\nPackage: usermgr\nDepends: libsystem\nVersion: 0.1.3-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nPriority: standard\nEssential: yes\nStatus: install ok installed\nSection: admin\nDescription: user account manager\n Manager service to handle user accounts, includinglogin, passwords, creation, and deletion.\n\nPackage: luz\nDepends: libdeflate\nVersion: 0.1.1-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: libraries\nArchitecture: phoenix\nStatus: install ok installed\nPriority: optional\nDescription: Lua compression algorithm\n Efficient compressor for Lua scripts. Includes ashared library, a command-line utility to compressand decompress Lua files, and a kernel module toallow direct execution of Luz files.\n\nPackage: dhcpmgr\nDepends: libsystem\nVersion: 0.1.1-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nPriority: optional\nStatus: install ok installed\nSection: net\nDescription: DHCP server manager for Phoenix\n Implements a Dynamic Host Configuration Protocolserver, which allocates and assigns IP addressesto computers on a network.\n\nPackage: typescript\nVersion: 1.28.1-2\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nHomepage: https://typescript-to-lua.github.io\nSection: libraries\nArchitecture: phoenix\nStatus: install ok installed\nPriority: optional\nDescription: TypeScriptToLua library features bundle\n Provides important polyfills to allow TypeScript code to run on Lua platforms.To use, set \"luaLibImport\" to \"require\" in tsconfig.json, and either set\"luaLibName\" to \"typescript\" (requires @jackmacwindows/typescript-to-lua), orreplace `require(\"lualib-bundle\")` with `require(\"typescript\")` in generatedfiles.\n\nPackage: libcraftos\nArchitecture: phoenix\nSection: libraries\nStatus: install ok installed\nPriority: optional\nVersion: 0.2.3-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: CraftOS compatibility library\n Provides CraftOS shim functions to allow runningCraftOS programs on Phoenix.\n\nPackage: spanfs\nDepends: libsystem\nVersion: 0.1.1-2\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nSection: kernel\nPriority: optional\nStatus: install ok installed\nDescription: Spanning filesystem kernel module & utilities\n spanfs provides a RAID-like spanning filesystemthat allows concatenating multiple disk drivesinto a single large virtual disk. One disk storesan index file containing the filesystem structure,and the file data is spread across the rest of thedisks.\n\nPackage: netmgr\nDepends: libsystem\nVersion: 0.1-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nPriority: optional\nStatus: install ok installed\nSection: net\nDescription: Network manager service\n Background manager that automatically configuresnetworking on all available modems.\n\nPackage: ar\nDepends: libsystem\nVersion: 1.1.1-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: utils\nStatus: install ok installed\nPriority: standard\nArchitecture: phoenix\nDescription: ar archive format library and program\n Allows creating and extracting ar/.a archives.\n\nPackage: libcert\nDepends: libsystem, ccryptolib, sha2, aes\nVersion: 1.0.1-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: libraries\nArchitecture: phoenix\nStatus: install ok installed\nPriority: optional\nDescription: Certificate and security library\n Handles the storage and use of cryptographicresources on the system, including certificates,passwords, API keys, and encryption keys. Alsoprovides functions for validating certificateroots, verifying signatures, and encryption ofdata using certificates.\n\nPackage: ccryptolib\nDepends: libsystem\nVersion: 1.2.2-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: libraries\nArchitecture: phoenix\nStatus: install ok installed\nPriority: optional\nDescription: cryptography library for Phoenix\n An integrated collection of cryptographicprimitives written in Lua using the ComputerCraft/Phoenix system API.\n\nPackage: diskmgr\nDepends: libsystem\nVersion: 1.0.1-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: utils\nStatus: install ok installed\nPriority: standard\nArchitecture: phoenix\nDescription: disk auto mounting manager\n Manager service to handle automatically mountingattached disks.\n\nPackage: phoenix-docs\nArchitecture: all\nSection: doc\nStatus: install ok installed\nPriority: optional\nVersion: 0.0.4-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Documentation files for Phoenix\n Contains manual files for Phoenix syscalls andkernel API functions, libsystem modules, andbaseutils programs. These are separated from themain packages to save space.\n\nPackage: aes\nArchitecture: phoenix\nSection: libraries\nStatus: install ok installed\nPriority: optional\nVersion: 1.0-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: AES encryption library\n Provides functions to encrypt and decrypt datausing the AES algorithm. Supports 128, 192, 256bit keys, and ECB or CBC cipher modes.\n\nPackage: githubfs\nDepends: libsystem, fuse\nVersion: 1.0-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nSection: utils\nPriority: optional\nStatus: install ok installed\nDescription: GitHub filesystem provider\n Provides a filesystem for mounting GitHubrepositories on the local system.\n\nPackage: compressfs\nDepends: libsystem, libdeflate\nVersion: 1.0-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nRecommends: deflateans, luz\nStatus: install ok installed\nPriority: optional\nSection: kernel\nDescription: Compressed file system driver\n Implements a file system that compresses diskcontents automatically. Supports DEFLATE (throughlibdeflate), DEFLATE-ANS (through deflateans), andLuz (through luz) on supported Lua files.\n\nPackage: dpkg\nDepends: ar, diff, libdeflate, libsystem, muxzcat, sha2, tar\nVersion: 0.2.9-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nSection: admin\nPriority: required\nStatus: install ok installed\nDescription: Debian Package Manager for Phoenix\n A port of the Debian Package Manager to thePhoenix operating system, written in Lua.\n\n",setuser=false,size=15219,modified=1757997043454,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},info={permissions={root={write=true,read=true,execute=true}},created=1757997043420,contents={["initrd-utils.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997040836,data="8032576522e153987a0fd69fc99d689b  etc/initrd/hooks.d/10-init.lua\nc737755eb7c50bccabd06de16ac53c0b  etc/initrd/hooks.d/00-modules.lua\n0fddcca5345e03354ce487ac30956628  etc/initrd/initrd.conf\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/update-initrd.md\nd8b1a2233c15c3046f0487033043371f  etc/initrd/hooks.d/01-files.lua\n9e3969cffb4e6f97ccde4da9c8e8a72e  usr/bin/mktablefs.lua\na56442d2083dfaae3061210edf9250ba  usr/bin/update-initrd.lua\ncfebff55cd8b5fd35eabc347f4faec66  etc/initrd/hooks.d/05-shell.lua\n",setuser=false,size=508,modified=1757997040836,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["spanfs.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997042632,data="7c5d3c8cf149d4e6a14f4f43ccf95e1b  usr/share/man/man8/spanadd.md\n1500428c94799e469bf39de9cfe1d6b7  sbin/spaninfo.lua\n1e86a7b4870ab26673ba335f84cb43a2  usr/share/man/man8/spaninfo.md\n125e008924e81e287b896ca534c39a9c  sbin/mkspanfs.lua\n842808b46a8b1f43ccc3960ca1eea0ab  usr/share/man/man8/mkspanfs.md\n9575416a1150421a627a924015700d6b  lib/modules/spanfs.lua\nda4cc0b9de4f274cde762fdcf4960a78  usr/share/man/man7/spanfs.md\n12ae0eecfc9726d37b739bbfabd91fa4  sbin/spanadd.lua\n",setuser=false,size=469,modified=1757997042632,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["diskmgr.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997040255,data="bef0900b5d48f903c15177c062b52e35  usr/libexec/diskmgr.lua\n52dfeac33b5887d026695dff5dc9dbac  etc/startmgr/system/diskmgr.service\n",setuser=false,size=128,modified=1757997040255,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["baseutils.postinst"]={permissions={root={read=true,write=true,execute=true}},created=1757997039905,data="if ... == \"triggered\" then return coroutine.yield(\"syscall\", \"exec\", \"/bin/man.lua\", \"-u\") end",setuser=false,size=94,modified=1757997039905,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["baseutils.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997039903,data="/\n/bin/\n/bin/apropos.lua\n/bin/attach.lua\n/bin/basename.lua\n/bin/cal.lua\n/bin/cash.lua\n/bin/cat.lua\n/bin/cd.lua\n/bin/chmod.lua\n/bin/chown.lua\n/bin/chroot.lua\n/bin/cksum.lua\n/bin/clear.lua\n/bin/cmp.lua\n/bin/comm.lua\n/bin/compress.lua\n/bin/cp.lua\n/bin/curl.lua\n/bin/date.lua\n/bin/df.lua\n/bin/dirname.lua\n/bin/dj.lua\n/bin/du.lua\n/bin/echo.lua\n/bin/eject.lua\n/bin/env.lua\n/bin/expand.lua\n/bin/expr.lua\n/bin/false.lua\n/bin/halt.lua\n/bin/id.lua\n/bin/kill.lua\n/bin/label.lua\n/bin/less.lua\n/bin/link.lua\n/bin/logger.lua\n/bin/ls.lua\n/bin/lsdev.lua\n/bin/lua.lua\n/bin/man.lua\n/bin/mkdir.lua\n/bin/mkfifo.lua\n/bin/mount.lua\n/bin/mv.lua\n/bin/nano.lua\n/bin/nice.lua\n/bin/nm.lua\n/bin/printf.lua\n/bin/ps.lua\n/bin/pwd.lua\n/bin/reboot.lua\n/bin/redstone.lua\n/bin/renice.lua\n/bin/rm.lua\n/bin/rmdir.lua\n/bin/screenfetch.lua\n/bin/sh.lua\n/bin/sleep.lua\n/bin/touch.lua\n/bin/true.lua\n/bin/tty.lua\n/bin/uname.lua\n/bin/uncompress.lua\n/bin/unlink.lua\n/bin/unmount.lua\n/bin/whoami.lua\n/etc/\n/etc/fstab\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/automount.service\n/etc/startmgr/system/startup.service.wants/\n/etc/startmgr/system/startup.service.wants/automount.service\n",setuser=false,size=1152,modified=1757997039903,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["phoenix-docs.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997042198,data="/\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man1/\n/usr/share/man/man1/logger.md\n/usr/share/man/man2/\n/usr/share/man/man2/_template.md\n/usr/share/man/man2/acquiresemaphore.md\n/usr/share/man/man2/alarm.md\n/usr/share/man/man2/arplist.md\n/usr/share/man/man2/arpset.md\n/usr/share/man/man2/attach.md\n/usr/share/man/man2/callmodule.md\n/usr/share/man/man2/cancel.md\n/usr/share/man/man2/cchost.md\n/usr/share/man/man2/checkuri.md\n/usr/share/man/man2/chmod.md\n/usr/share/man/man2/chown.md\n/usr/share/man/man2/chroot.md\n/usr/share/man/man2/combine.md\n/usr/share/man/man2/connect.md\n/usr/share/man/man2/detach.md\n/usr/share/man/man2/devalias.md\n/usr/share/man/man2/devcall.md\n/usr/share/man/man2/devchildren.md\n/usr/share/man/man2/devfind.md\n/usr/share/man/man2/devinfo.md\n/usr/share/man/man2/devlisten.md\n/usr/share/man/man2/devlock.md\n/usr/share/man/man2/devlookup.md\n/usr/share/man/man2/devmethods.md\n/usr/share/man/man2/devproperties.md\n/usr/share/man/man2/devunlock.md\n/usr/share/man/man2/ipconfig.md\n/usr/share/man/man2/kernargs.md\n/usr/share/man/man2/kill.md\n/usr/share/man/man2/link.md\n/usr/share/man/man2/list.md\n/usr/share/man/man2/listen.md\n/usr/share/man/man2/listmodules.md\n/usr/share/man/man2/loadCraftOSAPI.md\n/usr/share/man/man2/loadmodule.md\n/usr/share/man/man2/lockmutex.md\n/usr/share/man/man2/mkdir.md\n/usr/share/man/man2/mkfifo.md\n/usr/share/man/man2/mount.md\n/usr/share/man/man2/mountlist.md\n/usr/share/man/man2/netcontrol.md\n/usr/share/man/man2/netevent.md\n/usr/share/man/man2/open.md\n/usr/share/man/man2/queueEvent.md\n/usr/share/man/man2/releasesemaphore.md\n/usr/share/man/man2/remove.md\n/usr/share/man/man2/rename.md\n/usr/share/man/man2/routeadd.md\n/usr/share/man/man2/routedel.md\n/usr/share/man/man2/routelist.md\n/usr/share/man/man2/sendEvent.md\n/usr/share/man/man2/signal.md\n/usr/share/man/man2/stat.md\n/usr/share/man/man2/timeacquiresemaphore.md\n/usr/share/man/man2/timelockmutex.md\n/usr/share/man/man2/timer.md\n/usr/share/man/man2/trylockmutex.md\n/usr/share/man/man2/unlisten.md\n/usr/share/man/man2/unloadmodule.md\n/usr/share/man/man2/unlockmutex.md\n/usr/share/man/man2/unmount.md\n/usr/share/man/man2/uptime.md\n/usr/share/man/man2/version.md\n/usr/share/man/man3/\n/usr/share/man/man3/system.expect.md\n/usr/share/man/man3/system.filesystem.md\n/usr/share/man/man3/system.framebuffer.md\n/usr/share/man/man3/system.graphics.md\n/usr/share/man/man3/system.hardware.md\n/usr/share/man/man3/system.ipc.md\n/usr/share/man/man3/system.keys.md\n/usr/share/man/man3/system.log.md\n/usr/share/man/man3/system.network.md\n/usr/share/man/man3/system.pretty.md\n/usr/share/man/man3/system.process.md\n/usr/share/man/man3/system.serialization.md\n/usr/share/man/man3/system.sync.md\n/usr/share/man/man3/system.terminal.md\n/usr/share/man/man3/system.util.md\n/usr/share/man/man9/\n/usr/share/man/man9/kernel.md\n",setuser=false,size=2803,modified=1757997042198,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["compressfs.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997040053,data="/\n/etc/\n/etc/initrd/\n/etc/initrd/initrd.conf.template/\n/etc/initrd/initrd.conf.template/compressfs.conf\n/lib/\n/lib/modules/\n/lib/modules/compressfs.lua\n",setuser=false,size=152,modified=1757997040053,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["ftp.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997040613,data="e4a01ba4833d4d6283e94b8b4d803541  etc/ftpmgr.conf\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/ftpmgr.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man3/ftp.md\n49482e88b6b6a5b1684d20af8ed2e289  lib/fuse/ftp.lua\nfb8f26e52240525783a09925f60edd02  usr/libexec/ftpmgr.lua\ndaf955dbbcdcad648af2ad9d52a11cb8  etc/startmgr/system/ftpmgr.service\n0d311fd801635be99833577c8317072a  usr/share/man/man5/ftpmgr.conf.md\ne4110f4b039744954570b38b23ef6dd8  usr/lib/ftp.lua\n",setuser=false,size=468,modified=1757997040613,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["yahtcc.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997043300,data="/\n/usr/\n/usr/bin/\n/usr/bin/yahtcc.lua\n/usr/share/\n/usr/share/man/\n/usr/share/man/man6/\n/usr/share/man/man6/yahtcc.md\n",setuser=false,size=117,modified=1757997043300,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["netmgr.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997041534,data="5f6e8b6f9644d4c54ffdc86d004201a5  etc/startmgr/system/netmgr.service\n1a8951fa370e9218f32bbb88177623df  etc/network.conf\n33e5368d3024cbc43bb5eaa650d114e9  usr/libexec/netmgr.lua\n",setuser=false,size=177,modified=1757997041534,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["typescript.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997043013,data="/\n/lib/\n/lib/typescript.lua\n",setuser=false,size=28,modified=1757997043013,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["diff.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997040203,data="c861d0c4f89d14b794beb174269bcede  lib/diff.lua\n",setuser=false,size=47,modified=1757997040203,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["libdeflate.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997041134,data="/\n/usr/\n/usr/bin/\n/usr/bin/gzip.lua\n/usr/lib/\n/usr/lib/LibDeflate.lua\n",setuser=false,size=70,modified=1757997041134,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["baseutils.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997039903,data="19a7ed0f8311b94f930979801ee228e3  bin/kill.lua\n5e2f6f33e2ae0953eff784bc9d151adb  bin/true.lua\n94acf0509749ce1c89dfc0fdef87999e  bin/id.lua\nbbdb66d558c4bfa0ac8c80912e68031f  bin/curl.lua\n28cd84b2857ade19e4b5999e32e5a977  bin/ps.lua\n157c726b4783bd2673d2cba23237a907  bin/man.lua\n22dc5bb80fb08df6b1eb3f56a23f4a7a  bin/expr.lua\n2102f2892490510c6e9e544cdf3b7d0a  bin/lua.lua\ne5590661b9ac5ad7431baf87f9f6ebd8  bin/ls.lua\n71c3a28801bfa5038fbae9aa13bbf34f  bin/halt.lua\n37b20313032486367bc1355219ad3df0  bin/label.lua\n6cf0176b6703a4c406cea8c00bab5f99  bin/sleep.lua\n987d142e32bf4435302ea980d722f662  bin/chroot.lua\nef8b2b3d019a3599cbed101638862f4a  bin/uncompress.lua\n822d221ba295280690311191dc59116c  bin/mv.lua\nf979bb61d1ec11feadbf75599f242e8a  bin/eject.lua\nd1bc55425d94166e624eefd0c3db0461  bin/mount.lua\n0162e4fb0aa8420b1f0e1535d0db3b91  bin/rm.lua\na200214f00028170ec84b4bac4ab2d65  bin/mkdir.lua\naec4174943d2ec4e79d75872f627417c  bin/logger.lua\nc1821d21f33e68c32514f1a1b47e332b  bin/rmdir.lua\ndb653efad0b708300165886068c5120f  bin/less.lua\n386461ecb77eda2da55fc1f7f1930dec  bin/printf.lua\na0acb3bbd7647ffc42881b5b1f652101  bin/false.lua\n69c9945d22bca607f5fc6fd9e9c0d8d6  etc/startmgr/system/automount.service\n35a3925e059a2329500a5653892ebde5  bin/sh.lua\n8f755c0034fbb537900935d56d738be0  bin/cash.lua\n7e38b7acf96e039b14919857ca2dfff0  bin/echo.lua\n6f1593ad1511d26efa3b5c696a7df2b2  bin/clear.lua\n92ce61ebeec4cf62b1d20c5818f4a06a  bin/whoami.lua\nd0b417ad3ed2f618495a08ac7ccdfbc7  bin/unlink.lua\nc5d8cb7436d8ad18d06d999ac0465340  bin/nano.lua\n517599d164412eaf63b10648690a16aa  bin/cat.lua\nbac687f4efd22b8d455f1c76a78a3e9a  bin/chmod.lua\n35f1f8cc65e3946559a835134046bf21  bin/dirname.lua\n1e17ad07b4de339a36733bb6b64df2ef  etc/fstab\n469245890049f26bfb8b637caa23f4f7  bin/mkfifo.lua\nad5fba84720b513d6f26372dd5b5ab28  bin/comm.lua\n47df5ee3376c8d52c08065546dd944df  bin/cd.lua\nd7b659299185af45cce85813753429bd  bin/renice.lua\nb01fc398510a4f29b9f20688da4c8416  bin/date.lua\nef798e1b9b0a0fc28f350411eb197935  bin/reboot.lua\n51f8cdc2583e09f579c03b6ef5062e73  bin/attach.lua\n9cef8a2758c30e387122857d87f120a3  bin/nice.lua\n987e5f6bb8457528c7ddb9027544b038  bin/expand.lua\ne1fd3abb99d7ba394544afdd8bc3219f  bin/apropos.lua\n7bc6b5e904c9e9a3b895d107a7fd7494  bin/touch.lua\n4cf589c746eec22552853c5e16159c41  bin/cp.lua\nf440e472d544d26738a6525dfa90b75d  bin/env.lua\naf6fa5fb651bfc8b592147b8d24edb63  bin/compress.lua\na871b89d41c7dbb7f4538eb3fc305c22  bin/nm.lua\ne37948d8fe2173d8aed103b254c62d1f  bin/tty.lua\nc2a7b0aebf221a4b99d35e5960f2fb95  bin/cksum.lua\n714914be6658567665f655a1022cc8ce  bin/dj.lua\nd58ed7910c0ba7ba878abc6b05f6048e  bin/screenfetch.lua\ndd5fbf031731db755455e1f38629c4d1  bin/chown.lua\n1c3eb4de206e2d9e1c901daa830b358e  bin/redstone.lua\ne03ef0f14153ee028a78157730d8720d  bin/cmp.lua\ned2b6fdd6beca77514505804a2a73769  bin/lsdev.lua\na405b344188c49650c4271f25a7ab484  bin/pwd.lua\n3f3c71d1bccbde885221c4b14d9ea111  bin/cal.lua\n0f10a6f7c075b3a617909ead335f4d98  bin/uname.lua\nda5ce367b0a4c3af6d41af201ef276d4  bin/du.lua\na143fa05fa09243d41711837a71a42f9  bin/df.lua\ne73afa8bb012520a303ca3848e7f1a76  bin/unmount.lua\na47b79d65900867e04baeb6e74b981aa  bin/basename.lua\nb6f9425e648bbe725388f999543121fe  bin/link.lua\n",setuser=false,size=3207,modified=1757997039903,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["compressfs.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997040053,data="93f785ad5cb4c073d9e441b333484734  etc/initrd/initrd.conf.template/compressfs.conf\n3316177fb4bc33f803c1620b18ef08c3  lib/modules/compressfs.lua\n",setuser=false,size=143,modified=1757997040053,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["dhcpmgr.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997040157,data="096ab38be9345203bf98238c3a432439  etc/startmgr/system/dhcpmgr.service\n0c9a08f2a83e9e0e51a66665c6da0624  etc/dhcpmgr.conf\n1d128e416fc3afcd2e69f41c46815b3e  usr/libexec/dhcpmgr.lua\n",setuser=false,size=179,modified=1757997040157,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["aes.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997039494,data="/\n/usr/\n/usr/lib/\n/usr/lib/aes.lua\n",setuser=false,size=35,modified=1757997039494,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["yellowbox.postinst"]={permissions={root={read=true,write=true,execute=true}},created=1757997043419,data="",setuser=false,size=0,modified=1757997043419,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["asn1.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997039707,data="",setuser=false,size=0,modified=1757997039707,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["yahtcc.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997043301,data="32f4ff232b0ae7535cc9bdbd16d6649e  usr/share/man/man6/yahtcc.md\nd8e5bc545009c73a7a15ed2cfd9da260  usr/bin/yahtcc.lua\n",setuser=false,size=116,modified=1757997043301,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["ccryptolib.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997040009,data="98f9289f49c33b9ec13eb53f071efcb9  usr/lib/libccryptolib.a\n",setuser=false,size=58,modified=1757997040009,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["muxzcat.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997041459,data="/\n/usr/\n/usr/bin/\n/usr/bin/unxz.lua\n/usr/lib/\n/usr/lib/muxzcat.lua\n",setuser=false,size=67,modified=1757997041459,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["netutils.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997041597,data="/\n/usr/\n/usr/bin/\n/usr/bin/arp.lua\n/usr/bin/dhclient.lua\n/usr/bin/ifconfig.lua\n/usr/bin/nc.lua\n/usr/bin/ping.lua\n/usr/bin/route.lua\n",setuser=false,size=132,modified=1757997041597,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["baseutils.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997039903,data="/etc/fstab\n",setuser=false,size=11,modified=1757997039903,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["pxboot.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997042343,data="/\n/boot/\n/boot/config.lua\n/boot/config.lua.d/\n/boot/config.lua.d/99-craftos.lua\n/boot/pxboot.lua\n",setuser=false,size=97,modified=1757997042343,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["typescript.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997043013,data="",setuser=false,size=0,modified=1757997043013,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["pgp.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997041723,data="/\n/usr/\n/usr/lib/\n/usr/lib/pgp.lua\n",setuser=false,size=35,modified=1757997041723,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["fuse.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997040696,data="",setuser=false,size=0,modified=1757997040696,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["apt.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997039607,data="/\n/etc/\n/etc/apt/\n/etc/apt/sources.list\n/etc/apt/trusted.gpg.d/\n/etc/apt/trusted.gpg.d/phoenix.gpg\n/usr/\n/usr/bin/\n/usr/bin/add-apt-repository.lua\n/usr/bin/apt-cache.lua\n/usr/bin/apt-config.lua\n/usr/bin/apt-get.lua\n/usr/bin/apt-key.lua\n/usr/bin/apt-mark.lua\n/usr/bin/apt.lua\n/usr/lib/\n/usr/lib/apt/\n/usr/lib/apt/cache.lua\n/usr/lib/apt/config.lua\n/usr/lib/apt/get.lua\n/usr/lib/apt/init.lua\n/usr/lib/apt/methods/\n/usr/lib/apt/methods/file.lua\n/usr/lib/apt/methods/ftp.lua\n/usr/lib/apt/methods/http.lua\n/usr/lib/apt/planners/\n/usr/lib/apt/planners/80-default.lua\n/usr/lib/apt/repo.lua\n/usr/lib/apt/solvers/\n/usr/lib/apt/solvers/80-default.lua\n/usr/bin/apt-add-repository.lua\n/usr/lib/apt/methods/https.lua\n",setuser=false,size=703,modified=1757997039607,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["usermgr.postinst"]={permissions={root={read=true,write=true,execute=true}},created=1757997043157,data="if ... == \"configure\" then\n    coroutine.yield(\"syscall\", \"chmod\", \"/usr/bin/login.lua\", nil, {setuser = true})\n    coroutine.yield(\"syscall\", \"chmod\", \"/usr/bin/passwd.lua\", nil, {setuser = true})\n    coroutine.yield(\"syscall\", \"chmod\", \"/usr/bin/su.lua\", nil, {setuser = true})\n    coroutine.yield(\"syscall\", \"chmod\", \"/usr/bin/sudo.lua\", nil, {setuser = true})\n    return true\nelse return true end",setuser=false,size=400,modified=1757997043157,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["usermgr.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997043157,data="d41d8cd98f00b204e9800998ecf8427e  etc/passwd\nd41d8cd98f00b204e9800998ecf8427e  etc/shadow\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man5/motd.md\n30ad13f1feab0ef81ec18681b7169906  usr/bin/useradd.lua\n9abcdf1508d65b47447dd06690f48148  usr/bin/passwd.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/usermgr.md\na5753c9417f97ba3db5643e832d4081e  etc/motd\n3002c310b119126bf84cffcb481bb5f5  usr/libexec/usermgr.lua\n411b0f50d7cf8abf5dfefce9268fbe62  etc/startmgr/system/login.service\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/login.md\nef1d6d3bade9ab1b89dcd7d2d5f38711  usr/bin/sudo.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/sudo.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/useradd.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/usermod.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man5/shadow.md\n20e62d30ab6ebfe3b09bb0356c20e458  etc/startmgr/system/usermgr.service\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/userdel.md\naf3c31f5dad89603d41beb445629bdb9  etc/skel/.cashrc\n1bb5c78c3606b66eb1a599f2aecb9150  usr/bin/su.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/passwd.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man3/usermgr.md\n4adde33f29a34744772eeb0c470d34cf  usr/bin/usermod.lua\n1953929dcde52061f67ee4bc1b58a580  usr/bin/userdel.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/su.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man5/passwd.md\n1e159a4f4b48bfdd90a41b87c92fc010  usr/bin/login.lua\n82623dc508d076c29b0bb73deb041330  usr/lib/usermgr.lua\n",setuser=false,size=1553,modified=1757997043157,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["startmgr.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997042774,data="/\n/etc/\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/startup.service\n/lib/\n/lib/startmgr.lua\n/sbin/\n/sbin/init.lua\n/sbin/shutdown.lua\n/sbin/startctl.lua\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man1/\n/usr/share/man/man1/shutdown.md\n/usr/share/man/man1/startctl.md\n/usr/share/man/man1/startmgr.md\n/usr/share/man/man3/\n",setuser=false,size=338,modified=1757997042774,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["dhcpmgr.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997040157,data="/etc/dhcpmgr.conf\n",setuser=false,size=18,modified=1757997040157,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["usermgr.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997043157,data="/etc/passwd\n/etc/shadow\n/etc/motd\n/etc/skel/.cashrc\n",setuser=false,size=52,modified=1757997043157,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["libcert.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997040936,data="/\n/usr/\n/usr/bin/\n/usr/bin/certutil.lua\n/usr/bin/signtool.lua\n/usr/lib/\n/usr/lib/cert/\n/usr/lib/cert/chain.lua\n/usr/lib/cert/container.lua\n/usr/lib/cert/crypto.lua\n/usr/lib/cert/csr.lua\n/usr/lib/cert/init.lua\n/usr/lib/cert/signature.lua\n/usr/lib/cert/util.lua\n",setuser=false,size=260,modified=1757997040936,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["libcraftos.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997041052,data="96654d5385d7f6f6cd4df591b4187f0a  usr/share/man/man1/shell.md\nf3d31d93421629073eb2226ad016116d  lib/libcraftos.a\n2491e895910d32c9f82fcb6541fd3e34  bin/craftos.lua\n191ca4cf0fc3b7d0362f3caecf2ef411  lib/libcc.a\n254d1461a35ee297995f9da936cd60e5  bin/shell.lua\n2ae28cfcf7043e98dfa59e3899d6a837  usr/share/man/man1/craftos.md\n",setuser=false,size=321,modified=1757997041052,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["ccryptolib.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997040008,data="/\n/usr/\n/usr/lib/\n/usr/lib/libccryptolib.a\n",setuser=false,size=43,modified=1757997040008,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["apt.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997039608,data="/etc/apt/sources.list\n",setuser=false,size=22,modified=1757997039608,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["sha2.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997042484,data="0b23c04f92d6d68601b90ebc0acdba3d  usr/bin/md5sum.lua\nf1245ba271f47d6318e39fac55a96258  usr/bin/sha1sum.lua\n89854efcea24687d4f30272d0225950a  usr/bin/sha224sum.lua\n5b6687a44f299b26cb8e8d97b0469fd4  usr/bin/sha512sum.lua\n88b53fee64630fb7bbfa178142d1c92d  usr/bin/sha384sum.lua\n44304a9aa632161afa6524d6bc03e42a  usr/bin/sha256sum.lua\n3d3f60e38d1e37fea659736e340ddeb9  usr/bin/b2sum.lua\n124dbf6c8623dbc523f29b8c2a7a366c  usr/lib/sha2.lua\n368538cdc6f626d57abd0198700058d3  usr/bin/shasum.lua\n",setuser=false,size=487,modified=1757997042484,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["yellowbox.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997043419,data="",setuser=false,size=0,modified=1757997043419,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["yellowbox.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997043419,data="953d8809284e3a96dbc22832fafe0d91  usr/share/man/man1/yellowbox.md\nb51f91cd5db06fd5bf8c98b842ce1e44  etc/startmgr/system/yellowbox.service\n7853969f1eb90ad06f2cf6bd8e793bd0  usr/share/man/man7/yellowbox.md\n68b329da9893e34099c7d8ad5cb9c940  var/lib/yellowbox/startup.lua\n55bd44bbb67383a3b7bcfa88743d0658  bin/yellowbox.lua\n1d494b3289e328798db15f4e2a8ddfdd  lib/modules/yellowbox.lua\n68b329da9893e34099c7d8ad5cb9c940  lib/yellowbox.lua\n",setuser=false,size=432,modified=1757997043419,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["fuse.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997040696,data="09dc6c64b9805a78c159c544f2ac9560  usr/share/man/man7/fuse.md\n4f70313f4c99be264d2232cec45c8ad5  lib/modules/fuse.lua\n",setuser=false,size=116,modified=1757997040696,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["tar.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997042892,data="/\n/bin/\n/bin/tar.lua\n/lib/\n/lib/tar.lua\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man1/\n/usr/share/man/man1/tar.md\n",setuser=false,size=122,modified=1757997042892,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["mpi.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997041390,data="",setuser=false,size=0,modified=1757997041390,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["githubfs.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997040757,data="b17c71098acb992c51ae34386d563dd4  lib/fuse/githubfs.lua\nb39be2e408528ee49dadcc4608f8814f  usr/share/man/man7/githubfs.md\n",setuser=false,size=121,modified=1757997040757,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["startmgr.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997042774,data="d41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/startmgr.md\n1f6093323d818261b3fc4d0db3966e66  etc/startmgr/system/startup.service\n02794145e8ba948a089985bb283f3dcc  sbin/startctl.lua\nd2439cbe3dccf4c8e86575b5ef2d19b3  lib/startmgr.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/shutdown.md\n2f681b48d8fd9ea8060c31a931c7f6c1  sbin/init.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/startctl.md\n99a9872f41e5aae13ed404f4b1fb6a0b  sbin/shutdown.lua\n",setuser=false,size=468,modified=1757997042774,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["usermgr.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997043157,data="/\n/etc/\n/etc/motd\n/etc/passwd\n/etc/shadow\n/etc/skel/\n/etc/skel/.cashrc\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/login.service\n/etc/startmgr/system/startup.service.wants/\n/etc/startmgr/system/usermgr.service\n/usr/\n/usr/bin/\n/usr/bin/login.lua\n/usr/bin/passwd.lua\n/usr/bin/su.lua\n/usr/bin/sudo.lua\n/usr/bin/useradd.lua\n/usr/bin/userdel.lua\n/usr/bin/usermod.lua\n/usr/lib/\n/usr/lib/usermgr.lua\n/usr/libexec/\n/usr/libexec/usermgr.lua\n/usr/share/\n/usr/share/man/\n/usr/share/man/man1/\n/usr/share/man/man1/login.md\n/usr/share/man/man1/passwd.md\n/usr/share/man/man1/su.md\n/usr/share/man/man1/sudo.md\n/usr/share/man/man3/\n/usr/share/man/man3/usermgr.md\n/usr/share/man/man5/\n/usr/share/man/man5/motd.md\n/usr/share/man/man5/passwd.md\n/usr/share/man/man5/shadow.md\n/usr/share/man/man8/\n/usr/share/man/man8/useradd.md\n/usr/share/man/man8/userdel.md\n/usr/share/man/man8/usermgr.md\n/usr/share/man/man8/usermod.md\n/etc/startmgr/system/startup.service.wants/login.service\n",setuser=false,size=971,modified=1757997043157,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["muxzcat.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997041459,data="",setuser=false,size=0,modified=1757997041459,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["pgp.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997041723,data="",setuser=false,size=0,modified=1757997041723,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["libcert.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997040936,data="",setuser=false,size=0,modified=1757997040936,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["spanfs.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997042631,data="/\n/lib/\n/lib/modules/\n/lib/modules/spanfs.lua\n/sbin/\n/sbin/mkspanfs.lua\n/sbin/spanadd.lua\n/sbin/spaninfo.lua\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man7/\n/usr/share/man/man7/spanfs.md\n/usr/share/man/man8/\n/usr/share/man/man8/mkspanfs.md\n/usr/share/man/man8/spanadd.md\n/usr/share/man/man8/spaninfo.md\n",setuser=false,size=310,modified=1757997042631,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["spanfs.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997042631,data="",setuser=false,size=0,modified=1757997042631,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["deflateans.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997040104,data="",setuser=false,size=0,modified=1757997040104,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["dpkg.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997040419,data="c1b4ca58881e6ac1f122c2381a87de10  usr/lib/dpkg/control.lua\n94f3f1673bbfa8596df3c7bd66bdb444  usr/bin/dpkg.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/components.md\nddb74df4a7ad2b15c614ab754ee5f4a9  usr/bin/update.lua\naab6bf7c06734a559f26f40128f89df0  usr/bin/components.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/update.md\n0b9e4c3020d8d775a34920b3098eb458  usr/lib/dpkg/divert.lua\nee8d434c364fa8c02a622d3a061db437  usr/lib/dpkg/init.lua\nfe7d452efa9f06e888ab5dcf2e167ed1  usr/lib/dpkg/trigger.lua\n8ed0455495f6d0c4456249006281b069  usr/bin/dpkg-deb.lua\n6b4db8ad793341893d392ace5a084eab  usr/lib/dpkg/query.lua\n76fe1d9953d075f6811758c949da30d2  usr/lib/dpkg/deb.lua\nd5e27e7174a1fea197a7f2d6a4fe2335  usr/bin/dpkg-query.lua\nba58b004afcc6edbe9f409f5b0877d33  usr/bin/dpkg-divert.lua\n637f90e0ca1924d17008cf6073e19887  usr/bin/dpkg-trigger.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/dpkg.md\n",setuser=false,size=925,modified=1757997040419,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["netmgr.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997041533,data="/\n/etc/\n/etc/network.conf\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/netmgr.service\n/usr/\n/usr/libexec/\n/usr/libexec/netmgr.lua\n",setuser=false,size=143,modified=1757997041533,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["sha2.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997042484,data="/\n/usr/\n/usr/bin/\n/usr/bin/b2sum.lua\n/usr/bin/md5sum.lua\n/usr/bin/sha1sum.lua\n/usr/bin/sha224sum.lua\n/usr/bin/sha256sum.lua\n/usr/bin/sha384sum.lua\n/usr/bin/sha512sum.lua\n/usr/bin/shasum.lua\n/usr/lib/\n/usr/lib/sha2.lua\n",setuser=false,size=218,modified=1757997042484,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["apt.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997039608,data="e82389c36a06eade98e9c23f599f9c73  usr/bin/apt-cache.lua\n95e132a3aa46e01e76f8c8af43ac994e  usr/lib/apt/get.lua\n68b329da9893e34099c7d8ad5cb9c940  usr/lib/apt/init.lua\n68b329da9893e34099c7d8ad5cb9c940  usr/bin/apt-key.lua\n73a7a36e3dfd551106e524b1736364c7  usr/bin/apt-get.lua\n60cfe56b8d78b9e75853e6fc788f81dc  etc/apt/trusted.gpg.d/phoenix.gpg\n1f73b4686ae1658edf2e8063914173cb  usr/lib/apt/cache.lua\n99919e861b2eb6f7b1eea5c2aeb21c36  usr/lib/apt/config.lua\n791ca0fb0664879bfd1a59f66a076fc8  usr/lib/apt/methods/http.lua\nd013b81e1bee637ee2283da4de5f558e  usr/lib/apt/repo.lua\nb4ba488bd66be283f54342e8c25b2cba  usr/lib/apt/planners/80-default.lua\n7ba3e2e2e1464c6a16769ecc454a06d5  usr/lib/apt/methods/file.lua\n003d584082322d997e648590256c12f2  usr/bin/add-apt-repository.lua\n386ff5fdbfb4c5d0f5cc42246b3cfcf7  usr/bin/apt-config.lua\n0c4d226fa1543eb731e6acfdbf93e9e7  etc/apt/sources.list\nd904cbb97bd4bfccec8a5da574ee11de  usr/lib/apt/solvers/80-default.lua\n5c305865f8ff529a0f1e3effbdc3535a  usr/bin/apt.lua\n68b329da9893e34099c7d8ad5cb9c940  usr/bin/apt-mark.lua\n4f165d8af19433b864b41486eb348fbf  usr/lib/apt/methods/ftp.lua\n",setuser=false,size=1118,modified=1757997039608,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["ftp.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997040613,data="/etc/ftpmgr.conf\n",setuser=false,size=17,modified=1757997040613,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["mpi.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997041390,data="11fc9ef7684cfd95d6983d7099f0c4fb  usr/lib/mpi.lua\n",setuser=false,size=50,modified=1757997041390,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["pxboot.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997042344,data="bdb340a10570edcffedc694989ec8ffc  boot/config.lua.d/99-craftos.lua\n68b329da9893e34099c7d8ad5cb9c940  boot/config.lua\n59333490fc59f5e7b3f71cbe20a24ca5  boot/pxboot.lua\n",setuser=false,size=167,modified=1757997042344,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["typescript.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997043014,data="f77829dfb9cf4aeb049bbe0a65ac3488  lib/typescript.lua\n",setuser=false,size=53,modified=1757997043014,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["phoenix-docs.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997042198,data="f4ab4a41e3fa302d47096ea8534aed80  usr/share/man/man2/mount.md\n9de4abbd2b0da2b14c5da9dbf81bc23c  usr/share/man/man2/arpset.md\n4346c291bae58e8d989ebe3101ee7338  usr/share/man/man2/timer.md\n3392e744c6cf94bf74a63cd1ee0f8472  usr/share/man/man2/routeadd.md\nf3afcb4b2f99ed91a29178f38323f345  usr/share/man/man2/devlookup.md\n8e7e90089d0ba1d260e65c8fef1d6882  usr/share/man/man2/devmethods.md\n791883f15b0b6d761feeee712293d767  usr/share/man/man3/system.sync.md\nda74496fbe0ae2de16e985af5eaf7367  usr/share/man/man2/listmodules.md\n05b2b6ce596d1911ecc622e0d91c03d4  usr/share/man/man2/cchost.md\n2efd87231f058c6ff1d2954ac15f3a26  usr/share/man/man2/mkdir.md\n3aecf75563c43ac627904e5557db6d93  usr/share/man/man2/acquiresemaphore.md\n5f19cc0f6ab4148ba9335d6e814d8356  usr/share/man/man2/callmodule.md\n49d3e4050d1082830f48ad6967eae91f  usr/share/man/man3/system.pretty.md\ne63ea2179e036d83f3d5f37aec41a229  usr/share/man/man2/attach.md\n338b606dbe6b417f1e6eee5d61042d13  usr/share/man/man2/rename.md\na9af46d4ab2b6d36714d9177510e26ca  usr/share/man/man3/system.terminal.md\n696a2040bc36af8af6ad66fe78433ae7  usr/share/man/man3/system.process.md\nd0e27457aa68149eb780fe1b63977a9a  usr/share/man/man2/chmod.md\n28291760a2e4b96be1171acc644c5d6e  usr/share/man/man3/system.hardware.md\nd0996ceaa773d903957e6e9619641906  usr/share/man/man2/devproperties.md\ndd26ad844296daa48ce9824f78112145  usr/share/man/man2/unlockmutex.md\n05279006f5323ad189eaa20c795a8fe4  usr/share/man/man2/connect.md\ne741c0b7f30cf6ac9b7ee24923645449  usr/share/man/man2/devlisten.md\n278ed6f961df2429b512436974dbbde6  usr/share/man/man2/lockmutex.md\n0389a13f78cfe99d7bc6e7d1972b27f8  usr/share/man/man2/devalias.md\n3f9fd39c8c546bd480bc96cde4ce451f  usr/share/man/man2/devfind.md\n153307238fe3c50cd989e29fcf673cc8  usr/share/man/man2/checkuri.md\n300a370b5355fc236a4e3bcd5ce6e771  usr/share/man/man2/listen.md\n1bef5a63b0fe7719b02a57aa85b65f41  usr/share/man/man2/loadmodule.md\nfaa2cb304a8d49cf6d1ef8a3e03f8e4d  usr/share/man/man3/system.network.md\n969be2cabd57377208f2fcc306f4e390  usr/share/man/man3/system.graphics.md\n9acb7f91203c9ea3969f7830ad4bd6a5  usr/share/man/man3/system.serialization.md\nf92254ae8278c8f48402cd0a6e3ab2c3  usr/share/man/man2/devlock.md\n37c295514dbf251035461e407ec667b3  usr/share/man/man3/system.expect.md\nee2402f90c4ad6d76fbb8d79514463ec  usr/share/man/man2/timelockmutex.md\n6fc3507c68de16d6909370c3e2b0eeb6  usr/share/man/man2/signal.md\n005fc8770f15afd6e1c2422202eeb837  usr/share/man/man2/devchildren.md\n0df54115cb3ece67b17c2d74a9c7c42a  usr/share/man/man2/ipconfig.md\nab2514f962bed9c4833e34cda902fed7  usr/share/man/man3/system.framebuffer.md\n5cab43ff97f5780078c29e9f75cad7b5  usr/share/man/man2/_template.md\n132985fdf367e06d1c55fdb223876ce0  usr/share/man/man2/sendEvent.md\n998c1f99fc18bb138afb96f8a290829b  usr/share/man/man2/stat.md\nd18a93b14fed71208f5f8aa3acd3626c  usr/share/man/man2/mkfifo.md\n06124b31ba7e667b1618f4f0f993456a  usr/share/man/man2/devunlock.md\nea033221bc9037a8519781148c3e36b9  usr/share/man/man2/arplist.md\n3af4e3ce46827777ebc9a72faadc8656  usr/share/man/man2/timeacquiresemaphore.md\n9d542afcd7482e1c80531b8b987c2d8a  usr/share/man/man3/system.keys.md\n0d28ca0a43641a8e25ea4f57ba9c53a3  usr/share/man/man2/routedel.md\n5e4ac8f69342bd5e07b28d77bc4aebca  usr/share/man/man2/releasesemaphore.md\nfa70b112de755bca55aeed95aefceae6  usr/share/man/man3/system.filesystem.md\n78d09c5fb0699148ad0f03f55e1aa0dd  usr/share/man/man2/netevent.md\na04eafd5194d4bf030b1f98a92b71e64  usr/share/man/man2/queueEvent.md\ne9fcc0a2c89dd521a771880001556e07  usr/share/man/man2/chroot.md\n2cc2c7a42459d2e32c6bc49a9d2d4021  usr/share/man/man2/chown.md\nc3d0d69b999f47463b8e679e2d04651d  usr/share/man/man1/logger.md\n911e57faab1316f11d584a94eca7eefd  usr/share/man/man9/kernel.md\n7ac41cc3c74aa8163d90e4614d492e75  usr/share/man/man3/system.util.md\n2501ef2ed4f1fbdf54649e4920f1b584  usr/share/man/man3/system.log.md\nd181c9ee13a5868c6b636b035eef1f27  usr/share/man/man2/open.md\nbafeb327ddff1f91ee06ec03d87f06b3  usr/share/man/man3/system.ipc.md\n2e226e3b72e730965dd894189fa98b45  usr/share/man/man2/devcall.md\n927b9673495ee1ab6372804aaffb0602  usr/share/man/man2/link.md\nca0bfb454428824d3b9adbb2ad49175f  usr/share/man/man2/unloadmodule.md\n9d644b65cd00553301c202322b78ecf3  usr/share/man/man2/version.md\n90939a50982f279ff8bc78b7feb98d84  usr/share/man/man2/list.md\nb48e433d717c524cc10da33c4c23472b  usr/share/man/man2/remove.md\n1580cca776cbe49c5a7e738522f88bd1  usr/share/man/man2/unmount.md\n1e3f6c4fe095b7dfcc595a0493101f29  usr/share/man/man2/kernargs.md\ne6e6e85c1c165f256ac8529611f99129  usr/share/man/man2/netcontrol.md\n97d3a6b6fa05ad9d5abad1d52032952d  usr/share/man/man2/alarm.md\n2e0a0cdc9d2ade4fbe183999475535ac  usr/share/man/man2/routelist.md\n567d15c62ba1bef2a7d1455df96abb3d  usr/share/man/man2/devinfo.md\ne15a8b674e3b2317a49f49c68dffbf37  usr/share/man/man2/unlisten.md\nf9b544105798e40052a32bc6e997de7c  usr/share/man/man2/uptime.md\n005eb4b4db66b177c3a09068c7d5e5c8  usr/share/man/man2/trylockmutex.md\n468f1c781f256e30f3f7fdeeac94b6bf  usr/share/man/man2/mountlist.md\nfe185470ef69904cd06ff581fea471fb  usr/share/man/man2/cancel.md\na594570023aefc380e2ffeb3cce0c052  usr/share/man/man2/combine.md\ncb5483b392e5196c755d8f4fb3bb6d5d  usr/share/man/man2/loadCraftOSAPI.md\nd69b17d40fc99325335341dc5c80fd36  usr/share/man/man2/detach.md\ndafda555c67469ef269165d080d4f537  usr/share/man/man2/kill.md\n",setuser=false,size=5356,modified=1757997042198,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["diff.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997040203,data="/\n/bin/\n/lib/\n/lib/diff.lua\n",setuser=false,size=28,modified=1757997040203,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["pxboot.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997042344,data="/boot/config.lua\n",setuser=false,size=17,modified=1757997042344,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["aes.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997039495,data="",setuser=false,size=0,modified=1757997039495,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["pgp.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997041724,data="a2c06489c22ed02b9e3e85f5c45f35a2  usr/lib/pgp.lua\n",setuser=false,size=50,modified=1757997041724,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["yahtcc.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997043300,data="",setuser=false,size=0,modified=1757997043300,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["githubfs.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997040757,data="/\n/lib/\n/lib/fuse/\n/lib/fuse/githubfs.lua\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man7/\n/usr/share/man/man7/githubfs.md\n",setuser=false,size=129,modified=1757997040757,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["compressfs.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997040053,data="",setuser=false,size=0,modified=1757997040053,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["pdb.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997041665,data="ba656c2c7bfa11ae7150ddbe61719dbd  usr/bin/pdb.lua\n",setuser=false,size=50,modified=1757997041665,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["baseutils.triggers"]={permissions={root={read=true,write=true,execute=true}},created=1757997039905,data="interest /usr/share/man",setuser=false,size=23,modified=1757997039905,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["fuse.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997040696,data="/\n/lib/\n/lib/modules/\n/lib/modules/fuse.lua\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man7/\n/usr/share/man/man7/fuse.md\n",setuser=false,size=127,modified=1757997040696,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["encryptfs.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997040508,data="3756973d1f50c546354db12fbd084c1b  etc/initrd/initrd.conf.template/encryptfs.conf\n672733d614dcf0b631ae1caad162cd6c  etc/initrd/scripts/encryptfs.lua\nb06c84afb1362e6fd83a5adfbccdd98b  sbin/mkencryptfs.lua\nab6d506d9382b92aa9190c744ff4e892  lib/modules/encryptfs.lua\n",setuser=false,size=263,modified=1757997040508,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["diskmgr.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997040255,data="",setuser=false,size=0,modified=1757997040255,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["libsystem.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997041257,data="",setuser=false,size=0,modified=1757997041257,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["luz.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997041334,data="",setuser=false,size=0,modified=1757997041334,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["dhcpmgr.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997040157,data="/\n/etc/\n/etc/dhcpmgr.conf\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/dhcpmgr.service\n/usr/\n/usr/libexec/\n/usr/libexec/dhcpmgr.lua\n",setuser=false,size=145,modified=1757997040157,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["dpkg.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997040419,data="/\n/usr/\n/usr/bin/\n/usr/bin/components.lua\n/usr/bin/dpkg-deb.lua\n/usr/bin/dpkg-divert.lua\n/usr/bin/dpkg-query.lua\n/usr/bin/dpkg-trigger.lua\n/usr/bin/dpkg.lua\n/usr/bin/update.lua\n/usr/lib/\n/usr/lib/dpkg/\n/usr/lib/dpkg/control.lua\n/usr/lib/dpkg/deb.lua\n/usr/lib/dpkg/divert.lua\n/usr/lib/dpkg/init.lua\n/usr/lib/dpkg/query.lua\n/usr/lib/dpkg/trigger.lua\n/usr/share/\n/usr/share/man/\n/usr/share/man/man8/\n/usr/share/man/man8/components.md\n/usr/share/man/man8/dpkg.md\n/usr/share/man/man8/update.md\n",setuser=false,size=489,modified=1757997040419,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["encryptfs.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997040507,data="/\n/etc/\n/etc/initrd/\n/etc/initrd/initrd.conf.template/\n/etc/initrd/initrd.conf.template/encryptfs.conf\n/etc/initrd/scripts/\n/etc/initrd/scripts/encryptfs.lua\n/lib/\n/lib/modules/\n/lib/modules/encryptfs.lua\n/sbin/\n/sbin/mkencryptfs.lua\n",setuser=false,size=234,modified=1757997040507,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["pdb.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997041665,data="/\n/usr/\n/usr/bin/\n/usr/bin/pdb.lua\n",setuser=false,size=35,modified=1757997041665,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["diskmgr.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997040255,data="/\n/etc/\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/diskmgr.service\n/etc/startmgr/system/startup.service.wants/\n/usr/\n/usr/libexec/\n/usr/libexec/diskmgr.lua\n/etc/startmgr/system/startup.service.wants/diskmgr.service\n",setuser=false,size=230,modified=1757997040255,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["luz.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997041334,data="12b1258d8ec144f602549a2e0f79a809  lib/luz/minify.lua\n9654f6e61a1f848f18834d44b4a622c2  lib/luz/lex.lua\ncba820ecaa45e4b4d38d4cb511259021  lib/luz/init.lua\nbf692665ff81a957298f784d7bf73531  lib/luz/token_encode_map.lua\na9979c022975187f0dc8945a0d4cc1c6  lib/luz/compress.lua\n16f1b23c5035e2dc69e08a69501bfd72  lib/luz/lz77.lua\nc6f4c9d10659f0a6438e22e0a787d573  lib/luz/decompress.lua\n2f4c8200e228ef34efece3e66286d41c  lib/modules/luz.lua\n802f60c677e8859a1e515169219c5f8f  bin/luz.lua\ncfaab46b772f6efe1fe86af611a8ba7f  lib/luz/maketree.lua\n",setuser=false,size=535,modified=1757997041334,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["ftp.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997040612,data="/\n/etc/\n/etc/ftpmgr.conf\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/ftpmgr.service\n/lib/\n/lib/fuse/\n/lib/fuse/ftp.lua\n/usr/\n/usr/lib/\n/usr/lib/ftp.lua\n/usr/libexec/\n/usr/libexec/ftpmgr.lua\n/usr/share/\n/usr/share/man/\n/usr/share/man/man3/\n/usr/share/man/man3/ftp.md\n/usr/share/man/man5/\n/usr/share/man/man5/ftpmgr.conf.md\n/usr/share/man/man8/\n/usr/share/man/man8/ftpmgr.md\n",setuser=false,size=387,modified=1757997040612,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["githubfs.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997040757,data="",setuser=false,size=0,modified=1757997040757,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["yellowbox.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997043419,data="/\n/bin/\n/bin/yellowbox.lua\n/etc/\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/yellowbox.service\n/lib/\n/lib/modules/\n/lib/modules/yellowbox.lua\n/lib/yellowbox.lua\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man1/\n/usr/share/man/man1/yellowbox.md\n/usr/share/man/man7/\n/usr/share/man/man7/yellowbox.md\n/var/\n/var/lib/\n/var/lib/yellowbox/\n/var/lib/yellowbox/rom/\n/var/lib/yellowbox/startup.lua\n",setuser=false,size=408,modified=1757997043419,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["libdeflate.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997041134,data="61a11f1b095de6ecf98a981e4e84be8c  usr/bin/gzip.lua\n9ab27810840ddae0b90ef4d0bc39d960  usr/lib/LibDeflate.lua\n",setuser=false,size=108,modified=1757997041134,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["libcraftos.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997041052,data="",setuser=false,size=0,modified=1757997041052,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["tar.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997042892,data="",setuser=false,size=0,modified=1757997042892,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["netmgr.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997041534,data="/etc/network.conf\n",setuser=false,size=18,modified=1757997041534,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["muxzcat.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997041460,data="dded8eb9f482a41f6db65e6a30f501b8  usr/bin/unxz.lua\n9e36d7eecb443bceb4fb37befc2b85b0  usr/lib/muxzcat.lua\n",setuser=false,size=105,modified=1757997041460,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["sha2.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997042484,data="",setuser=false,size=0,modified=1757997042484,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["mpi.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997041390,data="/\n/usr/\n/usr/lib/\n/usr/lib/mpi.lua\n",setuser=false,size=35,modified=1757997041390,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["netutils.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997041597,data="",setuser=false,size=0,modified=1757997041597,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["pdb.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997041665,data="",setuser=false,size=0,modified=1757997041665,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["luz.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997041334,data="/\n/bin/\n/bin/luz.lua\n/lib/\n/lib/luz/\n/lib/luz/compress.lua\n/lib/luz/decompress.lua\n/lib/luz/init.lua\n/lib/luz/lex.lua\n/lib/luz/lz77.lua\n/lib/luz/maketree.lua\n/lib/luz/minify.lua\n/lib/luz/token_encode_map.lua\n/lib/modules/\n/lib/modules/luz.lua\n",setuser=false,size=243,modified=1757997041334,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["libcraftos.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997041051,data="/\n/bin/\n/bin/craftos.lua\n/bin/shell.lua\n/lib/\n/lib/libcc.a\n/lib/libcraftos.a\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man1/\n/usr/share/man/man1/craftos.md\n/usr/share/man/man1/shell.md\n",setuser=false,size=192,modified=1757997041051,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["ar.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997039661,data="/\n/bin/\n/bin/ar.lua\n/lib/\n/lib/ar.lua\n",setuser=false,size=38,modified=1757997039661,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["asn1.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997039707,data="6e4ca60e383e8f822d5cdd2de92f8c4c  usr/lib/asn1.lua\n",setuser=false,size=51,modified=1757997039707,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["tar.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997042892,data="8d5cffca8266e5a47fe9522c4388a306  lib/tar.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/tar.md\n30746ebcd4553deb0b26ceee80967a53  bin/tar.lua\n",setuser=false,size=152,modified=1757997042892,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["libsystem.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997041257,data="/\n/lib/\n/lib/libsystem.a\n",setuser=false,size=25,modified=1757997041257,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["initrd-utils.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997040835,data="/etc/initrd/initrd.conf\n",setuser=false,size=24,modified=1757997040835,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["deflateans.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997040104,data="/\n/usr/\n/usr/lib/\n/usr/lib/deflateans.lua\n",setuser=false,size=42,modified=1757997040104,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["initrd-utils.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997040835,data="/\n/etc/\n/etc/initrd/\n/etc/initrd/hooks.d/\n/etc/initrd/hooks.d/00-modules.lua\n/etc/initrd/hooks.d/01-files.lua\n/etc/initrd/hooks.d/05-shell.lua\n/etc/initrd/hooks.d/10-init.lua\n/etc/initrd/initrd.conf\n/usr/\n/usr/bin/\n/usr/bin/mktablefs.lua\n/usr/bin/update-initrd.lua\n/usr/share/\n/usr/share/man/\n/usr/share/man/man8/\n/usr/share/man/man8/update-initrd.md\n",setuser=false,size=351,modified=1757997040835,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["ar.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997039662,data="313f5e82958c0d8f26b6167440648acd  bin/ar.lua\n4767aeea93f79bff928f7f84b31ba365  lib/ar.lua\n",setuser=false,size=90,modified=1757997039662,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["libdeflate.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997041134,data="",setuser=false,size=0,modified=1757997041134,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["asn1.list"]={permissions={root={read=true,write=true,execute=true}},created=1757997039707,data="/\n/usr/\n/usr/lib/\n/usr/lib/asn1.lua\n",setuser=false,size=36,modified=1757997039707,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["ccryptolib.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997040008,data="",setuser=false,size=0,modified=1757997040008,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["netutils.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997041597,data="37ee6f33589bcfdb8d03c43aa367c3cf  usr/bin/dhclient.lua\n41c9783bf056efa1345e0e058ed4d63a  usr/bin/ifconfig.lua\n5881edfd5fc61aaea57986174d5e1a8c  usr/bin/ping.lua\nf7aabeec00376eb5e12643392fb5abae  usr/bin/arp.lua\n158a50065b8d605ce928a75ed7b83d98  usr/bin/route.lua\n68b329da9893e34099c7d8ad5cb9c940  usr/bin/nc.lua\n",setuser=false,size=312,modified=1757997041597,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["dpkg.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997040419,data="",setuser=false,size=0,modified=1757997040419,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["aes.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997039495,data="728e4a1a718c49f7f582635aaaa85000  usr/lib/aes.lua\n",setuser=false,size=50,modified=1757997039495,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["encryptfs.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997040508,data="",setuser=false,size=0,modified=1757997040508,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["ar.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997039662,data="",setuser=false,size=0,modified=1757997039662,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["libsystem.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997041257,data="253f272005ecfc31ad810a207b2b4b28  lib/libsystem.a\n",setuser=false,size=50,modified=1757997041257,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["libcert.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997040937,data="2aa2766decd687bc085b5d7792d8cb5b  usr/lib/cert/container.lua\n0122e4c6755d2c424f3f0241c4acca1b  usr/lib/cert/crypto.lua\n68b329da9893e34099c7d8ad5cb9c940  usr/bin/certutil.lua\nf108397430aa0c735a82b3b368bab887  usr/lib/cert/signature.lua\n4e3bc9fa02601e756ca245a2a04f0d72  usr/lib/cert/init.lua\n8e090b05517380e0b2c63f35f0ece1a8  usr/lib/cert/util.lua\n4282e0924abe538d0497d7865d4a47b5  usr/lib/cert/csr.lua\n68b329da9893e34099c7d8ad5cb9c940  usr/bin/signtool.lua\n6314125c3b54fbd117e4b64d59c3ad37  usr/lib/cert/chain.lua\n",setuser=false,size=514,modified=1757997040937,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["diff.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997040203,data="",setuser=false,size=0,modified=1757997040203,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["startmgr.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997042774,data="",setuser=false,size=0,modified=1757997042774,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["deflateans.md5sums"]={permissions={root={read=true,write=true,execute=true}},created=1757997040104,data="048e66916139912611cc33796299e6d0  usr/lib/deflateans.lua\n",setuser=false,size=57,modified=1757997040104,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["phoenix-docs.conffiles"]={permissions={root={read=true,write=true,execute=true}},created=1757997042198,data="",setuser=false,size=0,modified=1757997042198,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"}},size=0,modified=1757997043420,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},["status-old"]={permissions={root={read=true,write=true,execute=true}},created=1757997043453,data="Package: encryptfs\nDepends: libsystem, ccryptolib (>= 1.2.0)\nVersion: 1.0-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: kernel\nArchitecture: phoenix\nStatus: install ok installed\nPriority: optional\nDescription: Encrypted file system driver\n Implements a file system that encrypts diskcontents automatically.\n\nPackage: muxzcat\nArchitecture: phoenix\nSection: libraries\nStatus: install ok installed\nPriority: optional\nVersion: 1.1-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: LZMA/XZ decompression library\n Provides functions for decompressing LZMA and XZformat compressed files.\n\nPackage: asn1\nVersion: 1.0-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nHomepage: https://github.com/kunkku/lua-asn1\nSection: libraries\nArchitecture: phoenix\nStatus: install ok installed\nPriority: optional\nDescription: ASN.1 serialization library\n Handles serializing and deserializing tables inASN.1 DER format.\n\nPackage: diff\nDepends: libsystem\nVersion: 1.0-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: utils\nStatus: install ok installed\nPriority: important\nArchitecture: phoenix\nDescription: File comparison library and utility\n Provides a library for comparing files, as well asprograms for comparing and patching using the lib.\n\nPackage: apt\nDepends: libsystem (>= 0.1.6), dpkg (>= 0.2.6), sha2, pgp, libdeflate, muxzcat\nVersion: 0.2.2-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: admin\nStatus: install ok installed\nPriority: standard\nArchitecture: phoenix\nDescription: Advanced Package Tool for Phoenix\n A port of the Debian Advanced Package Tool to thePhoenix operating system, written in Lua.\n\nPackage: initrd-utils\nDepends: libsystem\nVersion: 0.1.1-2\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: admin\nArchitecture: phoenix\nStatus: install ok installed\nPriority: optional\nDescription: initrd management tools\n Contains a collection of utility programs to createand manage initial ramdisk (initrd) files.\n\nPackage: deflateans\nArchitecture: phoenix\nSection: libraries\nStatus: install ok installed\nPriority: optional\nVersion: 1.0-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Compression algorithm utilizing ANS\n A variant of DEFLATE that uses asymmetrical numeral systemsinstead of Huffman coding, increasing decompression speed with similarcompression ratios.\n\nPackage: pdb\nDepends: libsystem (>= 0.1.6)\nVersion: 0.1.1-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nSection: devel\nPriority: optional\nStatus: install ok installed\nDescription: Phoenix debugger program\n Implements a GDB-like debugger for Phoenixprograms.\n\nPackage: mpi\nArchitecture: phoenix\nSection: libraries\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nVersion: 1.0-1\nStatus: install ok installed\nDescription: Multi-precision integer library\n Provides functions for working with multi-precision integers, with functions for RSAencryption included.\n\nPackage: netutils\nDepends: libsystem\nVersion: 0.1-2\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: net\nStatus: install ok installed\nPriority: optional\nArchitecture: phoenix\nDescription: Network configuration utilities\n Provides a set of programs to configure the systemnetworking layer.\n\nPackage: startmgr\nDepends: libsystem\nVersion: 0.1.2-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: admin\nPriority: standard\nEssential: yes\nStatus: install ok installed\nArchitecture: phoenix\nDescription: Phoenix service manager and init system\n Provides automatic service management facilitiesfor Phoenix systems.\n\nPackage: libdeflate\nArchitecture: phoenix\nSection: libraries\nStatus: install ok installed\nPriority: optional\nVersion: 1.0.2-3\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: DEFLATE/zlib compression library\n Provides compression and decompression for DEFLATEformatted archives, including zlib and gzip files.\n\nPackage: tar\nDepends: libsystem\nVersion: 1.0.1-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: utils\nStatus: install ok installed\nPriority: important\nArchitecture: phoenix\nDescription: TAR archive format library and program\n Allows creating and extracting TAR archives.\n\nPackage: fuse\nArchitecture: phoenix\nSection: kernel\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nVersion: 0.1-1\nStatus: install ok installed\nDescription: Filesystem in userspace module\n fuse implements filesystems in userspace, allowingfilesystems to be implemented without using kernelmodules.\n\nPackage: yahtcc\nDepends: libsystem\nVersion: 1.0-3\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: games\nArchitecture: phoenix\nStatus: install ok installed\nPriority: optional\nDescription: Yahtzee game for Phoenix\n Yahtzee game for Phoenix\n\nPackage: baseutils\nDepends: libsystem\nVersion: 0.2.2-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: utils\nArchitecture: phoenix\nStatus: install ok installed\nPriority: important\nDescription: base utility set for Phoenix\n Contains a standard set of POSIX utilities for Phoenix.\n\nPackage: ftp\nDepends: libsystem, sha2\nVersion: 0.1.1-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nRecommends: fuse, usermgr, startmgr\nStatus: install ok installed\nPriority: optional\nSection: net\nDescription: RFC 959-compliant FTP client & server\n Implements the FTP protocol on top of Phoenixsockets. Includes an object-oriented library formanaging clients and servers, as well as a smallserver manager for FTP access, and a FUSEfilesystem for mounting FTP shares locally.\n\nPackage: pxboot\nVersion: 0.1.3-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nSection: admin\nStatus: install ok installed\nPriority: required\nEssential: yes\nDescription: Multipurpose bootloader for ComputerCraft\n A bootloader for ComputerCraft operating systemswith built-in UnBIOS functionality, a configurableselection menu, and more. Designed for Phoenix,but supports other OSes as well, including CraftOS.\n\nPackage: netmgr\nDepends: libsystem\nVersion: 0.1-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: net\nArchitecture: phoenix\nStatus: install ok installed\nPriority: optional\nDescription: Network manager service\n Background manager that automatically configuresnetworking on all available modems.\n\nPackage: libcert\nDepends: libsystem, ccryptolib, sha2, aes\nVersion: 1.0.1-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: libraries\nStatus: install ok installed\nPriority: optional\nArchitecture: phoenix\nDescription: Certificate and security library\n Handles the storage and use of cryptographicresources on the system, including certificates,passwords, API keys, and encryption keys. Alsoprovides functions for validating certificateroots, verifying signatures, and encryption ofdata using certificates.\n\nPackage: sha2\nDepends: libsystem\nVersion: 12-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nSection: libraries\nPriority: optional\nStatus: install ok installed\nDescription: SHA-1, SHA-2, SHA-3, BLAKE2 and BLAKE3 functions written in pure Lua and optimized for speed.\n This module contains functions to calculate SHA digest:   MD5, SHA-1,   SHA-224, SHA-256, SHA-512/224, SHA-512/256, SHA-384, SHA-512,   SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, SHAKE256,   HMAC,   BLAKE2b, BLAKE2s, BLAKE2bp, BLAKE2sp, BLAKE2Xb, BLAKE2Xs,   BLAKE3, BLAKE3_KDFWritten in pure Lua.Compatible with:   Lua 5.1, Lua 5.2, Lua 5.3, Lua 5.4, Fengari, LuaJIT 2.0/2.1 (any CPU endianness).Main feature of this module: it was heavily optimized for speed.For every Lua version the module contains particular implementation branch to get benefits from version-specific features.   - branch for Lua 5.1 (emulating bitwise operators using look-up table)   - branch for Lua 5.2 (using bit32/bit library), suitable for both Lua 5.2 with native \"bit32\" and Lua 5.1 with external library \"bit\"   - branch for Lua 5.3/5.4 (using native 64-bit bitwise operators)   - branch for Lua 5.3/5.4 (using native 32-bit bitwise operators) for Lua built with LUA_INT_TYPE=LUA_INT_INT   - branch for LuaJIT without FFI library (useful in a sandboxed environment)   - branch for LuaJIT x86 without FFI library (LuaJIT x86 has oddity because of lack of CPU registers)   - branch for LuaJIT 2.0 with FFI library (bit.* functions work only with Lua numbers)   - branch for LuaJIT 2.1 with FFI library (bit.* functions can work with \"int64_t\" arguments)\n\nPackage: compressfs\nDepends: libsystem, libdeflate\nVersion: 1.0-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: kernel\nRecommends: deflateans, luz\nArchitecture: phoenix\nPriority: optional\nStatus: install ok installed\nDescription: Compressed file system driver\n Implements a file system that compresses diskcontents automatically. Supports DEFLATE (throughlibdeflate), DEFLATE-ANS (through deflateans), andLuz (through luz) on supported Lua files.\n\nPackage: luz\nDepends: libdeflate\nVersion: 0.1.1-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: libraries\nStatus: install ok installed\nPriority: optional\nArchitecture: phoenix\nDescription: Lua compression algorithm\n Efficient compressor for Lua scripts. Includes ashared library, a command-line utility to compressand decompress Lua files, and a kernel module toallow direct execution of Luz files.\n\nPackage: ar\nDepends: libsystem\nVersion: 1.1.1-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nSection: utils\nPriority: standard\nStatus: install ok installed\nDescription: ar archive format library and program\n Allows creating and extracting ar/.a archives.\n\nPackage: dpkg\nDepends: ar, diff, libdeflate, libsystem, muxzcat, sha2, tar\nVersion: 0.2.9-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nPriority: required\nStatus: install ok installed\nSection: admin\nDescription: Debian Package Manager for Phoenix\n A port of the Debian Package Manager to thePhoenix operating system, written in Lua.\n\nPackage: libcraftos\nArchitecture: phoenix\nSection: libraries\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nVersion: 0.2.3-1\nStatus: install ok installed\nDescription: CraftOS compatibility library\n Provides CraftOS shim functions to allow runningCraftOS programs on Phoenix.\n\nPackage: spanfs\nDepends: libsystem\nVersion: 0.1.1-2\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nPriority: optional\nStatus: install ok installed\nSection: kernel\nDescription: Spanning filesystem kernel module & utilities\n spanfs provides a RAID-like spanning filesystemthat allows concatenating multiple disk drivesinto a single large virtual disk. One disk storesan index file containing the filesystem structure,and the file data is spread across the rest of thedisks.\n\nPackage: usermgr\nDepends: libsystem\nVersion: 0.1.3-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: admin\nStatus: install ok installed\nArchitecture: phoenix\nPriority: standard\nEssential: yes\nDescription: user account manager\n Manager service to handle user accounts, includinglogin, passwords, creation, and deletion.\n\nPackage: dhcpmgr\nDepends: libsystem\nVersion: 0.1.1-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: net\nArchitecture: phoenix\nStatus: install ok installed\nPriority: optional\nDescription: DHCP server manager for Phoenix\n Implements a Dynamic Host Configuration Protocolserver, which allocates and assigns IP addressesto computers on a network.\n\nPackage: phoenix-docs\nArchitecture: all\nSection: doc\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nVersion: 0.0.4-1\nStatus: install ok installed\nDescription: Documentation files for Phoenix\n Contains manual files for Phoenix syscalls andkernel API functions, libsystem modules, andbaseutils programs. These are separated from themain packages to save space.\n\nPackage: ccryptolib\nDepends: libsystem\nVersion: 1.2.2-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: libraries\nStatus: install ok installed\nPriority: optional\nArchitecture: phoenix\nDescription: cryptography library for Phoenix\n An integrated collection of cryptographicprimitives written in Lua using the ComputerCraft/Phoenix system API.\n\nPackage: diskmgr\nDepends: libsystem\nVersion: 1.0.1-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nSection: utils\nPriority: standard\nStatus: install ok installed\nDescription: disk auto mounting manager\n Manager service to handle automatically mountingattached disks.\n\nPackage: typescript\nVersion: 1.28.1-2\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nHomepage: https://typescript-to-lua.github.io\nArchitecture: phoenix\nSection: libraries\nStatus: install ok installed\nPriority: optional\nDescription: TypeScriptToLua library features bundle\n Provides important polyfills to allow TypeScript code to run on Lua platforms.To use, set \"luaLibImport\" to \"require\" in tsconfig.json, and either set\"luaLibName\" to \"typescript\" (requires @jackmacwindows/typescript-to-lua), orreplace `require(\"lualib-bundle\")` with `require(\"typescript\")` in generatedfiles.\n\nPackage: aes\nArchitecture: phoenix\nSection: libraries\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: optional\nVersion: 1.0-1\nStatus: install ok installed\nDescription: AES encryption library\n Provides functions to encrypt and decrypt datausing the AES algorithm. Supports 128, 192, 256bit keys, and ECB or CBC cipher modes.\n\nPackage: githubfs\nDepends: libsystem, fuse\nVersion: 1.0-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nPriority: optional\nStatus: install ok installed\nSection: utils\nDescription: GitHub filesystem provider\n Provides a filesystem for mounting GitHubrepositories on the local system.\n\nPackage: pgp\nDepends: libsystem, ccryptolib, sha2, aes, mpi\nVersion: 0.2-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nPriority: standard\nStatus: install ok installed\nSection: utils\nDescription: OpenPGP implementation for Phoenix\n Implements the OpenPGP (RFC 4880/9580) standardcryptography scheme in Phoenix, including GPGextensions.\n\nPackage: libsystem\nVersion: 0.1.6-1\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nSection: libraries\nArchitecture: phoenix\nEssential: yes\nStatus: install ok installed\nPriority: required\nDescription: System libraries for Phoenix\n Provides convenient wrapper functions for usingPhoenix syscalls, as well as various usefulcomponents for programs.\n\n",setuser=false,size=14770,modified=1757997043453,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"}},setuser=false,size=0,modified=1757997043425,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},yellowbox={permissions={root={write=true,read=true,execute=true}},created=1757997043425,contents={rom={permissions={root={write=true,read=true,execute=true}},created=1757997043418,contents={},size=0,modified=1757997043418,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},["startup.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997043425,data="\n",setuser=false,size=1,modified=1757997043418,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997043425,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"}},setuser=false,size=0,modified=1757997043418,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},log={permissions={root={read=true,write=true,execute=true}},created=1757997039421,contents={["default.log"]={permissions={root={read=true,write=true,execute=true}},created=1757997043454,data="[Sep 16 00:30:39] kernel[0] [Info]: Starting Phoenix version 0.0.9 PRERELEASE NONFREE Mon Sep 15 23:39:00 2025 PREEMPT\n[Sep 16 00:30:39] kernel[0] [Info]: Initialized system logger\n[Sep 16 00:30:39] kernel[0] [Info]: System started at 1757997039431 on computer 0\n[Sep 16 00:30:39] kernel[0] [Info]: Computer host is ComputerCraft 1.112.0 (CraftOS-PC v2.8.3)\n[Sep 16 00:30:39] kernel[0] [Debug]: Key table sizes: 211 46\n[Sep 16 00:30:39] kernel[0] [Info]: Loading kernel modules from /lib/modules\n[Sep 16 00:30:39] kernel[0] [Info]: Loading kernel module spanfs from /lib/modules/spanfs.lua\n[Sep 16 00:30:39] kernel[0] (spanfs) [Info]: spanfs is now loaded\n[Sep 16 00:30:39] kernel[0] (Hardware) [Info]: Registered device with type computer on device / using driver root\n[Sep 16 00:30:39] kernel[0] (Hardware) [Info]: Added new device at /redstone\n[Sep 16 00:30:39] kernel[0] (Hardware) [Info]: Added new device at /redstone/top\n[Sep 16 00:30:39] kernel[0] (Hardware) [Info]: Registered device with type redstone on device /redstone/top using driver root_redstone\n[Sep 16 00:30:39] kernel[0] (Hardware) [Info]: Added new device at /redstone/bottom\n[Sep 16 00:30:39] kernel[0] (Hardware) [Info]: Registered device with type redstone on device /redstone/bottom using driver root_redstone\n[Sep 16 00:30:39] kernel[0] (Hardware) [Info]: Added new device at /redstone/left\n[Sep 16 00:30:39] kernel[0] (Hardware) [Info]: Registered device with type redstone on device /redstone/left using driver root_redstone\n[Sep 16 00:30:39] kernel[0] (Hardware) [Info]: Added new device at /redstone/right\n[Sep 16 00:30:39] kernel[0] (Hardware) [Info]: Registered device with type redstone on device /redstone/right using driver root_redstone\n[Sep 16 00:30:39] kernel[0] (Hardware) [Info]: Added new device at /redstone/front\n[Sep 16 00:30:39] kernel[0] (Hardware) [Info]: Registered device with type redstone on device /redstone/front using driver root_redstone\n[Sep 16 00:30:39] kernel[0] (Hardware) [Info]: Added new device at /redstone/back\n[Sep 16 00:30:39] kernel[0] (Hardware) [Info]: Registered device with type redstone on device /redstone/back using driver root_redstone\n[Sep 16 00:30:39] kernel[0] (Hardware) [Info]: Added new device at /lo\n[Sep 16 00:30:39] kernel[0] (Hardware) [Info]: Registered device with type modem on device /lo using driver loopback_modem\n[Sep 16 00:30:39] kernel[0] [Info]: Configured IP for loopback device\n[Sep 16 00:30:39] kernel[0] [Info]: Starting init from /mkramfs_stage2.lua\n[Sep 16 00:30:39] kernel[0] [Debug]: Reaping process 2 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:39] kernel[0] [Debug]: Creating link /usr/bin/apt-add-repository.lua.dpkg-new  =>  /usr/bin/add-apt-repository.lua\n[Sep 16 00:30:39] kernel[0] [Debug]: Creating link /usr/lib/apt/methods/https.lua.dpkg-new  =>  /usr/lib/apt/methods/http.lua\n[Sep 16 00:30:39] kernel[0] [Debug]: Reaping process 3 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:39] kernel[0] [Debug]: Reaping process 4 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:39] kernel[0] [Debug]: Reaping process 5 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:39] kernel[0] [Debug]: Creating link /etc/startmgr/system/startup.service.wants/automount.service.dpkg-new  =>  /etc/startmgr/system/automount.service\n[Sep 16 00:30:39] kernel[0] [Debug]: Reaping process 7 (/var/lib/dpkg/info/baseutils.postinst)\n[Sep 16 00:30:39] kernel[0] [Debug]: Reaping process 6 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:40] kernel[0] [Debug]: Reaping process 8 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:40] kernel[0] [Debug]: Reaping process 9 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:40] kernel[0] [Debug]: Reaping process 10 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:40] kernel[0] [Debug]: Reaping process 11 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:40] kernel[0] [Debug]: Reaping process 12 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:40] kernel[0] [Debug]: Creating link /etc/startmgr/system/startup.service.wants/diskmgr.service.dpkg-new  =>  /etc/startmgr/system/diskmgr.service\n[Sep 16 00:30:40] kernel[0] [Debug]: Reaping process 13 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:40] kernel[0] [Debug]: Reaping process 15 (/bin/man.lua)\n[Sep 16 00:30:40] kernel[0] [Debug]: Reaping process 14 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:40] kernel[0] [Debug]: Reaping process 16 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:40] kernel[0] [Debug]: Reaping process 18 (/bin/man.lua)\n[Sep 16 00:30:40] kernel[0] [Debug]: Reaping process 17 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:40] kernel[0] [Debug]: Reaping process 20 (/bin/man.lua)\n[Sep 16 00:30:40] kernel[0] [Debug]: Reaping process 19 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:40] kernel[0] [Debug]: Reaping process 22 (/bin/man.lua)\n[Sep 16 00:30:40] kernel[0] [Debug]: Reaping process 21 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:40] kernel[0] [Debug]: Reaping process 24 (/bin/man.lua)\n[Sep 16 00:30:40] kernel[0] [Debug]: Reaping process 23 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:40] kernel[0] [Debug]: Reaping process 25 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:41] kernel[0] [Debug]: Reaping process 27 (/bin/man.lua)\n[Sep 16 00:30:41] kernel[0] [Debug]: Reaping process 26 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:41] kernel[0] [Debug]: Reaping process 28 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:41] kernel[0] [Debug]: Reaping process 29 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:41] kernel[0] [Debug]: Reaping process 30 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:41] kernel[0] [Debug]: Reaping process 31 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:41] kernel[0] [Debug]: Reaping process 32 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:41] kernel[0] [Debug]: Reaping process 33 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:41] kernel[0] [Debug]: Reaping process 34 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:41] kernel[0] [Debug]: Reaping process 35 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:41] kernel[0] [Debug]: Reaping process 36 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:42] kernel[0] [Debug]: Reaping process 38 (/bin/man.lua)\n[Sep 16 00:30:42] kernel[0] [Debug]: Reaping process 37 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:42] kernel[0] [Debug]: Reaping process 39 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:42] kernel[0] [Debug]: Reaping process 40 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:42] kernel[0] [Debug]: Reaping process 42 (/bin/man.lua)\n[Sep 16 00:30:42] kernel[0] [Debug]: Reaping process 41 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:42] kernel[0] [Debug]: Reaping process 44 (/bin/man.lua)\n[Sep 16 00:30:42] kernel[0] [Debug]: Reaping process 43 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:42] kernel[0] [Debug]: Reaping process 46 (/bin/man.lua)\n[Sep 16 00:30:42] kernel[0] [Debug]: Reaping process 45 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:43] kernel[0] [Debug]: Reaping process 47 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:43] kernel[0] [Debug]: Creating link /etc/startmgr/system/startup.service.wants/login.service.dpkg-new  =>  /etc/startmgr/system/login.service\n[Sep 16 00:30:43] kernel[0] [Debug]: Reaping process 49 (/var/lib/dpkg/info/usermgr.postinst)\n[Sep 16 00:30:43] kernel[0] [Debug]: Reaping process 50 (/bin/man.lua)\n[Sep 16 00:30:43] kernel[0] [Debug]: Reaping process 48 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:43] kernel[0] [Debug]: Reaping process 52 (/bin/man.lua)\n[Sep 16 00:30:43] kernel[0] [Debug]: Reaping process 51 (/usr/bin/dpkg.lua)\n[Sep 16 00:30:43] kernel[0] [Debug]: Reaping process 54 (/var/lib/dpkg/info/yellowbox.postinst)\n[Sep 16 00:30:43] kernel[0] [Debug]: Reaping process 55 (/bin/man.lua)\n[Sep 16 00:30:43] kernel[0] [Debug]: Reaping process 53 (/usr/bin/dpkg.lua)\n",setuser=false,size=7327,modified=1757997043454,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"}},setuser=false,size=0,modified=1757997039421,worldPermissions={read=true,write=false,execute=true},type="directory",owner="root"}},setuser=false,size=0,modified=1757997039421,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},rom={permissions={root={write=true,read=true,execute=true}},created=1757997043457,contents={},size=0,modified=1757997043457,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},usr={permissions={root={write=true,read=true,execute=true}},created=1757997040406,contents={lib={permissions={root={write=true,read=true,execute=true}},created=1757997043165,contents={["ftp.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040616,data="local a=require(\"system.filesystem\")local b;b=require(\"system.hardware\").call;local c,d,e;do local f=require(\"system.network\")c,d,e=f.connect,f.listen,f.unlisten end;local g;g=require(\"system.process\").newthread;local h;h=require(\"system.sync\").barrier;local i,j,k;do local f=require(\"system.util\")i,j,k=f.timer,f.cancel,f.sleep end;local l;l=function(m,n)local o=c(\"psp://\"..m..\":\"..n)while o:status()==\"connecting\"do coroutine.yield()end;if o:status()==\"error\"then return nil,select(2,o:status())end;return o end;local p;p=function(m,n,q)local r=\"psp://\"..m..\":\"..n;d(r)local s;if q then s=i(q)end;while true do local t,u=coroutine.yield()if t==\"network_request\"and u.uri==r then e(r)if q then j(s)end;return u.handle elseif t==\"timer\"and u.id==s then e(r)return nil end end end;local v;v=function(o,w)local x=o:read(w or\"*a\")while x==nil and o:status()==\"open\"do coroutine.yield()x=o:read(w or\"*a\")end;return x end;local y;y=function(z,A)if#z<A then return z..(\" \"):rep(A-z)else return z:sub(1,A)end end;local B;B=function()local C={}return function(D)if D==nil then if C[20]==nil then C[20]=true;return 20 else local E=5000;while E<65536 and C[E]do E=E+1 end;if E>65535 then return nil else return E end end else C[D]=nil end end end;local F;do local G;local H={_send_command=function(self,I)if not self.connection:status()==\"open\"then return false,421,\"Connection closed\"end;if I~=nil then self.connection:write(I..\"\\r\\n\")end;local x=v(self.connection,\"*l\")if x==nil then error(\"Could not receive reply\",2)end;local J=x:sub(1,3)if tonumber(J)==nil then error(\"Malformed reply (invalid code): \"..x)end;local K=\"\"if x:sub(4,4)=='-'then for L in x:sub(5):gmatch(\"[^\\n]+\")do if L:sub(1,4)==J..\" \"then K=K..L:sub(5)break else K=K..L..\"\\n\"end end elseif x:sub(4,4)==' 'then K=x:sub(5)else error(\"Malformed reply (invalid code separator):\"..x)end;local M=math.floor(tonumber(J)/100)if 1==M then return self:_send_command()elseif 2==M or 3==M then return true,tonumber(J),K elseif 4==M or 5==M then return false,tonumber(J),K else return error(\"Malformed reply (invalid code): \"..J)end end,_receive_data=function(self,I)if self.pasv then local n=self:pasv()if n==nil then error(\"Ran out of ports for data connection\")end;local N,J,x=self:_send_command(\"PORT \"..self.connection:localIP():gsub(\"%.\",\",\")..\",\"..math.floor(n/256)..\",\"..n%256)if J~=200 then return nil,J,x end;local O,P,Q;local R=h.new(3)g(function()N,J,Q=self:_send_command(I)if not N then P:close()end;R:wait()end)g(function()P=p(self.connection:localIP(),n,self.timeout)if not P then return end;while true do local S=v(P)if not S then break end;local M=self.transfer_params.mode;if\"S\"==M then O=(O or\"\")..S elseif\"B\"==M then local T=S:byte(1)local A=S:byte(2)*256+S:byte(3)O=(O or\"\")..y(S,A)if math.floor(T/128)==1 then P:close()break end elseif\"C\"==M then R=S:byte(1)if R==0 and math.floor(S:byte(2)/128)==1 then P:close()break elseif math.floor(R/128)==0 then O=(O or\"\")..S:sub(2,R%128+1)elseif math.floor(R/64)%2==0 then O=(O or\"\")..S:sub(2,2):rep(R%64)else if self.transfer_params.type==\"A\"or self.transfer_params.type==\"E\"then O=(O or\"\")..(\" \"):rep(R%64)elseif self.transfer_params.type==\"I\"or self.transfer_params.type==\"L\"then O=(O or\"\")..(\"\\0\"):rep(R%64)end end end end;R:wait()end)R:wait()if P:status()==\"open\"then P:close()end;self:pasv(n)if self.transfer_params.type==\"A\"and O~=nil then O=O:gsub(\"[\\128-\\255]\",\"?\")end;return O,J,Q else local N,J,x=self:_send_command(\"PASV\")if J~=227 then return nil,J,x end;local U,V,W,X,Y,Z=x:match((\"(%d+),\"):rep(5)..\"(%d+)\")local _=U..\".\"..V..\".\"..W..\".\"..X;local n=tonumber(Y)*256+tonumber(Z)local P,Q=l(_,n)if P==nil then return nil,0,\"Could not connect to server: \"..Q end;local O,Q;local R=h.new(3)g(function()N,J,Q=self:_send_command(I)if not N then P:close()end;R:wait()end)g(function()while true do local S=v(P)if not S then break end;local M=self.transfer_params.mode;if\"S\"==M then O=(O or\"\")..S elseif\"B\"==M then local T=S:byte(1)local A=S:byte(2)*256+S:byte(3)O=(O or\"\")..y(S,A)if math.floor(T/128)==1 then P:close()break end elseif\"C\"==M then R=S:byte(1)if R==0 and math.floor(S:byte(2)/128)==1 then P:close()break elseif math.floor(R/128)==0 then O=(O or\"\")..S:sub(2,R%128+1)elseif math.floor(R/64)%2==0 then O=(O or\"\")..S:sub(2,2):rep(R%64)else if self.transfer_params.type==\"A\"or self.transfer_params.type==\"E\"then O=(O or\"\")..(\" \"):rep(R%64)elseif self.transfer_params.type==\"I\"or self.transfer_params.type==\"L\"then O=(O or\"\")..(\"\\0\"):rep(R%64)end end end end;R:wait()end)R:wait()if P:status()==\"open\"then P:close()end;if self.transfer_params.type==\"A\"and O~=nil then O=O:gsub(\"[\\128-\\255]\",\"?\")end;return O,J,Q end end,_send_data=function(self,I,O)if self.transfer_params.type==\"A\"then O=O:gsub(\"[\\128-\\255]\",\"?\")end;if self.pasv then local n=self:pasv()if n==nil then error(\"Ran out of ports for data connection\")end;local N,J,x=self:_send_command(\"PORT \"..self.connection:localIP():gsub(\"%.\",\",\")..\",\"..math.floor(n/256)..\",\"..n%256)if J~=200 then return false,J,x end;local P,Q;local R=h.new(2)g(function()N,J,Q=self:_send_command(I)if N then while true do coroutine.yield()end end;if R then R:wait()end end)g(function()P=p(self.connection:localIP(),n,self.timeout)if not P then return end;local M=self.transfer_params.mode;if\"S\"==M then for E=1,#O,65536 do P:write(O:sub(E,E+65535))end elseif\"B\"==M then for E=1,#O,65535 do local S=O:sub(E,E+65534)P:write((function()if#S<65535 then return\"\\0\"else return\"\\128\"end end)()..string.char(#S/256)..string.char(#S%256)..S)end elseif\"C\"==M then for E=1,#O,127 do local S=O:sub(E,E+126)P:write(string.char(#S)..S)end;P:write(\"\\0\\128\")end;P:close()if R then R:wait()end end)R:wait()R=nil;self:pasv(n)return N,J,Q else local N,J,x=self:_send_command(\"PASV\")if J~=227 then return false,J,x end;local U,V,W,X,Y,Z=x:match((\"(%d+),\"):rep(5)..\"(%d+)\")local _=U..\".\"..V..\".\"..W..\".\"..X;local n=tonumber(Y)*256+tonumber(Z)local P,Q=l(_,n)if P==nil then return false,0,\"Could not connect to server: \"..Q end;N,J,Q=self:_send_command(I)if not N then P:close()return N,J,Q end;local M=self.transfer_params.mode;if\"S\"==M then for E=1,#O,65536 do P:write(O:sub(E,E+65535))end elseif\"B\"==M then for E=1,#O,65535 do local S=O:sub(E,E+65534)P:write((function()if#S<65535 then return\"\\0\"else return\"\\128\"end end)()..string.char(#S/256)..string.char(#S%256)..S)end elseif\"C\"==M then for E=1,#O,127 do local S=O:sub(E,E+126)P:write(string.char(#S)..S)end;P:write(\"\\0\\128\")end;P:close()return true end end,login=function(self,a0,a1)if type(a0)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a0)..\")\",2)end;if a1~=nil and type(a1)~=\"string\"then error(\"bad argument #2 (expected string, got \"..type(a1)..\")\",2)end;local N,J,Q=self:_send_command(\"USER \"..a0)local M=J;if 230==M then return true elseif 500==M or 501==M or 421==M or 530==M then return false,Q elseif 331==M or 332==M then if a1==nil then return false,\"Password required\"end else error(\"Malformed reply (invalid code): \"..J)end;N,J,Q=self:_send_command(\"PASS \"..a1)local a2=J;if 230==a2 then return true elseif 202==a2 then return true elseif 500==a2 or 502==a2 or 421==a2 or 530==a2 then return false,Q elseif 332==a2 then return false,Q else return error(\"Malformed reply (invalid code): \"..J)end end,close=function(self)self:_send_command(\"QUIT\")return self.connection:close()end,setTransferParams=function(self,a3,w)if a3==nil then a3=self.transfer_params.type end;if w==nil then w=self.transfer_params.mode end;if type(a3)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a3)..\")\",2)end;if type(w)~=\"string\"then error(\"bad argument #2 (expected string, got \"..type(w)..\")\",2)end;if a3~=\"A\"and a3~=\"I\"then error(\"bad argument #1 (invalid data type)\",2)end;if w~=\"S\"and w~=\"B\"and w~=\"C\"then error(\"bad argument #2 (invalid transmission mode)\",2)end;if a3~=self.transfer_params.type then local N,J,Q=self:_send_command(\"TYPE \"..a3)if J==200 then self.transfer_params.type=a3 end end;if w~=self.transfer_params.mode then local N,J,Q=self:_send_command(\"MODE \"..w)if J==200 then self.transfer_params.mode=w end end;return self.transfer_params.type,self.transfer_params.mode end,list=function(self,a4)if type(a4)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a4)..\")\",2)end;if a4==\"\"then a4=\"/\"end;local a5;if self.transfer_params.type~=\"A\"then a5=self.transfer_params.type;if self:setTransferParams(\"A\")~=\"A\"then error(\"Could not switch to ASCII data type\")end end;local O,J,Q=self:_receive_data(\"NLST \"..a4)if a5 then self:setTransferParams(a5)end;if not O then error(Q..\" (\"..J..\")\",2)end;local a6={}local a7=1;for L in O:gmatch(\"[^\\r\\n]+\")do a6[a7]=L;a7=a7+1 end;return a6 end,stat=function(self,a4)return{size=0,type=self:isDir(a4)and\"directory\"or\"file\",created=0,modified=0,owner=\"root\",permissions={},worldPermissions={read=true,write=true,execute=true},setuser=false,capacity=0,freeSpace=0,special={}}end,isDir=function(self,a4)if type(a4)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a4)..\")\",2)end;if a4==\"\"then a4=\"/\"end;local N,J,Q=self:_send_command(\"CWD \"..a4)local M=J;if 533==M or 550==M then return false elseif 200==M or 250==M then self:_send_command(\"CWD /\")return true else return error(Q..\" (\"..J..\")\",2)end end,mkdir=function(self,a4)if type(a4)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a4)..\")\",2)end;local N,J,Q=self:_send_command(\"MKD \"..a4)if not N then return error(Q..\" (\"..J..\")\",2)end end,rename=function(self,a8,a9)if type(a8)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a8)..\")\",2)end;if type(a9)~=\"string\"then error(\"bad argument #2 (expected string, got \"..type(a9)..\")\",2)end;local N,J,Q=self:_send_command(\"RNFR \"..a8)if not N then error(Q..\" (\"..J..\")\",2)end;N,J,Q=self:_send_command(\"RNTO \"..a9)if not N then return error(Q..\" (\"..J..\")\",2)end end,remove=function(self,a4)if type(a4)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a4)..\")\",2)end;local N,J,Q=self:_send_command(\"DELE \"..a4)if not N then N=self:_send_command(\"RMD \"..a4)if N then for aa in ipairs(self:list(a4))do self:remove(a.combine(a4,aa))end else return error(Q..\" (\"..J..\")\",2)end end end,open=function(self,a4,w)if type(a4)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a4)..\")\",2)end;if type(w)~=\"string\"then error(\"bad argument #2 (expected string, got \"..type(w)..\")\",2)end;local M=w;if\"r\"==M then if self:setTransferParams(\"A\")~=\"A\"then error(\"Could not switch to ASCII data type\")end;local O,J,Q=self:_receive_data(\"RETR \"..a4)if O==nil then return nil,Q..\" (\"..J..\")\"end;local ab=1;return{close=function()return nil end,readLine=function()if ab>=#O then return nil end;local E=O:find(\"\\n\",ab)or#O+1;local ac=O:sub(ab,E-1)ab=E+1;return ac end,readAll=function()if ab>=#O then return nil end;local ac=O:sub(ab)ab=#O;return ac end,read=function(A)if ab>=#O then return nil end;local ac=O:sub(ab,ab+A)ab=ab+A;return ac end,seek=function(ad,ae)ae=ae or 0;if type(ad)==\"number\"and type(ae)==nil then ae=ad;ad=\"cur\"end;local a2=ad;if\"cur\"==a2 then ab=ab+math.max(math.min(ae,#O),0)elseif\"set\"==a2 then ab=math.max(math.min(ae,#O),0)elseif\"end\"==a2 then ab=math.max(math.min(#O-ae,#O),0)end;return ab end}elseif\"w\"==M then local O=\"\"local ab=1;local af={flush=function()if self:setTransferParams(\"A\")~=\"A\"then error(\"Could not switch to ASCII data type\")end;local N,J,Q=self:_send_data(\"STOR \"..a4,O)if not N then return error(Q..\" (\"..J..\")\")end end,write=function(z)O=O:sub(1,ab-1)..z..O:sub(ab)ab=ab+#z end,writeLine=function(z)O=O:sub(1,ab-1)..z..\"\\n\"..O:sub(ab)ab=ab+#z+1 end,seek=function(ad,ae)ae=ae or 0;if type(ad)==\"number\"and type(ae)==nil then ae=ad;ad=\"cur\"end;local a2=ad;if\"cur\"==a2 then ab=ab+math.max(math.min(ae,#O),0)elseif\"set\"==a2 then ab=math.max(math.min(ae,#O),0)elseif\"end\"==a2 then ab=math.max(math.min(#O-ae,#O),0)end;return ab end}af.close=af.flush;return af elseif\"a\"==M then local O=\"\"local ab=1;return{close=function()if self:setTransferParams(\"A\")~=\"A\"then error(\"Could not switch to ASCII data type\")end;local N,J,Q=self:_send_data(\"STOA \"..a4,O)if not N then return error(Q..\" (\"..J..\")\")end end,write=function(z)O=O:sub(1,ab-1)..z..O:sub(ab)ab=ab+#z end,writeLine=function(z)O=O:sub(1,ab-1)..z..\"\\n\"..O:sub(ab)ab=ab+#z+1 end,flush=function()return nil end}elseif\"rb\"==M then if self:setTransferParams(\"I\")~=\"I\"then error(\"Could not switch to Image data type\")end;local O,J,Q=self:_receive_data(\"RETR \"..a4)if O==nil then return nil,Q..\" (\"..J..\")\"end;local ab=1;return{close=function()return nil end,readAll=function()if ab>=#O then return nil end;local ac=O:sub(ab)ab=#O;return ac end,read=function(A)if ab>=#O then return nil end;if A==nil then ab=ab+1;return O:byte(ab-1)end;local ac=O:sub(ab,ab+A)ab=ab+A;return ac end,seek=function(ad,ae)ae=ae or 0;if type(ad)==\"number\"and type(ae)==nil then ae=ad;ad=\"cur\"end;local a2=ad;if\"cur\"==a2 then ab=ab+math.max(math.min(ae,#O),0)elseif\"set\"==a2 then ab=math.max(math.min(ae,#O),0)elseif\"end\"==a2 then ab=math.max(math.min(#O-ae,#O),0)end;return ab end}elseif\"wb\"==M then local O=\"\"local ab=1;local af={flush=function()if self:setTransferParams(\"I\")~=\"I\"then error(\"Could not switch to Image data type\")end;local N,J,Q=self:_send_data(\"STOR \"..a4,O)if not N then return error(Q..\" (\"..J..\")\")end end,write=function(z)O=O:sub(1,ab-1)..(function()if type(z)==\"number\"then return string.char(z)else return z end end)()..O:sub(ab)ab=ab+#z end,seek=function(ad,ae)ae=ae or 0;if type(ad)==\"number\"and type(ae)==nil then ae=ad;ad=\"cur\"end;local a2=ad;if\"cur\"==a2 then ab=ab+math.max(math.min(ae,#O),0)elseif\"set\"==a2 then ab=math.max(math.min(ae,#O),0)elseif\"end\"==a2 then ab=math.max(math.min(#O-ae,#O),0)end;return ab end}af.close=af.flush;return af elseif\"ab\"==M then local O=\"\"local ab=1;return{close=function()if self:setTransferParams(\"I\")~=\"I\"then error(\"Could not switch to Image data type\")end;local N,J,Q=self:_send_data(\"STOA \"..a4,O)if not N then return error(Q..\" (\"..J..\")\")end end,write=function(z)O=O:sub(1,ab-1)..(function()if type(z)==\"number\"then return string.char(z)else return z end end)()..O:sub(ab)ab=ab+#z end,flush=function()return nil end}else return nil,\"Unknown mode \\\"\"..w..'\"'end end}H.__index=H;G=setmetatable({__init=function(self,m,n,ag,q)if n==nil then n=21 end;if ag==nil then ag=false end;if q==nil then q=5 end;self.timeout=q;local Q;self.connection,Q=l(m,n)if self.connection==nil then error(\"Could not connect to server: \"..Q,2)end;self.pasv=ag;self.transfer_params={type=\"A\",mode=\"S\"}return self:_send_command()end,__base=H,__name=\"client\"},{__index=H,__call=function(ah,...)local ai=setmetatable({},H)ah.__init(ai,...)return ai end})H.__class=G;F=G end;local aj;do local G;local H={send=function(self,S)self.connection.socket:write(S)self.status.total_bytes=self.status.total_bytes+#S;self.status.current_bytes=self.status.current_bytes+#S end,send_data=function(self,O,ak)self.status.current_bytes=0;self.status.target_bytes=#O;local M=self.transfer_params.mode;if\"S\"==M then for E=1,#O,65536 do self:send(O:sub(E,E+65535))end elseif\"B\"==M then for E=1,#O,65535 do local S=O:sub(E,E+65534)self:send((function()if#S<65535 then return\"\\0\"else return\"\\128\"end end)()..string.char(#S/256)..string.char(#S%256)..S)end elseif\"C\"==M then for E=1,#O,127 do local S=O:sub(E,E+126)self:send(string.char(#S)..S)end;self:send(\"\\0\\128\")end;self.socket:write(\"226 Transfer complete\\n\")self.connection.socket:close()if self.connection.ip==nil then return ak(self.connection.port)end end,receive_data=function(self,ak)local O=\"\"while self.connection.socket:status()==\"open\"do local S=v(self.connection.socket)local M=self.transfer_params.mode;if\"S\"==M then O=(O or\"\")..S elseif\"B\"==M then local T=S:byte(1)local A=S:byte(2)*256+S:byte(3)O=(O or\"\")..y(S,A)if math.floor(T/128)==1 then self.connection.socket:close()break end elseif\"C\"==M then local R=S:byte(1)if R==0 and math.floor(S:byte(2)/128)==1 then self.connection.socket:close()break elseif math.floor(R/128)==0 then O=(O or\"\")..S:sub(2,R%128+1)elseif math.floor(R/64)%2==0 then O=(O or\"\")..S:sub(2,2):rep(R%64)else if self.transfer_params.type==\"A\"or self.transfer_params.type==\"E\"then O=(O or\"\")..(\" \"):rep(R%64)elseif self.transfer_params.type==\"I\"or self.transfer_params.type==\"L\"then O=(O or\"\")..(\"\\0\"):rep(R%64)end end end end;if self.connection.ip==nil then ak(self.connection.port)end;return O end}H.__index=H;G=setmetatable({__init=function(self,o)self.socket=o;self.dir=\"\"self.transfer_params={type=\"A\",mode=\"S\"}self.status={total_bytes=0,current_bytes=nil,target_bytes=nil,current_command=nil}end,__base=H,__name=\"server_connection\"},{__index=H,__call=function(ah,...)local ai=setmetatable({},H)ah.__init(ai,...)return ai end})H.__class=G;aj=G end;local al;do local G;local H={commands={USER=function(self,am,a0)if a0==nil then return\"501 Missing username\"end;am.username=a0;if self.auth==nil or self.auth(am.username)then return\"230 User logged in, proceed.\"else return\"331 User name okay, need password.\"end end,PASS=function(self,am,a1)if a1==nil then return\"501 Missing password\"end;am.password=a1;if self.auth==nil then return\"202 Password not required for this server.\"elseif self.auth(am.username,am.password)then return\"230 User logged in, proceed.\"else return\"530 Login incorrect.\"end end,ACCT=function(self,am)return\"502 ACCT command not implemented\"end,CWD=function(self,am,an)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if an==nil then return\"501 Missing file name\"end;local a4;if an:sub(1,1)==\"/\"then a4=an else a4=a.combine(am.dir,an)end;if not a.isDir(a4)then return\"550 Not a directory\"end;am.dir=a4;return\"200 OK\"end,CDUP=function(self,am)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;am.dir=a.combine(am.dir,\"..\")return\"200 OK\"end,SMNT=function(self,am)return\"502 SMNT command not implemented\"end,REIN=function(self,am)am.username=nil;am.password=nil;am.dir=\"\"am.connection=nil;am.transfer_params={type=\"A\",mode=\"S\"}return\"220 Service ready for new user.\"end,QUIT=function(self,am)am.socket:write(\"221 Goodbye.\\n\")return am.socket:close()end,PORT=function(self,am,n)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if n==nil then return\"501 Missing ID/port\"end;local ao={n:match(\"(%d+),(%d+),(%d+),(%d+),(%d+),(%d+)\")}if tonumber(ao[1])==nil or tonumber(ao[2])==nil or tonumber(ao[3])==nil or tonumber(ao[4])==nil or tonumber(ao[5])==nil or tonumber(ao[6])==nil then return\"501 Port specified is not correctly formatted\"end;am.connection={ip=(\"%d.%d.%d.%d\"):format(ao[1],ao[2],ao[3],ao[4]),port=bit32.lshift(tonumber(ao[5]),8)+tonumber(ao[6])}return\"200 OK\"end,PASV=function(self,am)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;am.connection={ip=nil,port=self.port_provider()}if not am.connection.port then return\"425 Can't open data connection.\"end;local _=am.socket.localIP()am.connection.task=self:_add_task(function()am.connection.socket=p(_,am.connection.port)end,\"passive listener \"..am.connection.port)return(\"227 Entering passive mode. %s,%d,%d\"):format(_:gsub(\"%.\",\",\"),bit32.rshift(bit32.band(am.connection.port,0xFF00),8),bit32.band(am.connection.port,0xFF))end,TYPE=function(self,am,type)local ap=type:sub(1,1):upper()if ap==\"E\"or ap==\"L\"then return\"504 Transfer type \"..ap..\" not supported\"end;if ap~=\"A\"and ap~=\"I\"then return\"501 Unknown transfer type \"..ap end;am.transfer_params.type=ap;return\"200 OK\"end,STRU=function(self,am)return\"502 STRU command not implemented\"end,MODE=function(self,am,w)local ap=w:sub(1,1):upper()if ap~=\"S\"and ap~=\"B\"and ap~=\"C\"then return\"501 Unknown transfer mode \"..ap end;am.transfer_params.mode=ap;return\"200 OK\"end,RETR=function(self,am,aq)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if aq==nil then return\"501 Missing file name\"end;if am.connection.port==nil then return\"503 Bad sequence of commands\"end;if am.current_task~=nil then return\"425 Data connection already open\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;if not a.exists(a4)or a.isDir(a4)then am.connection=nil;return\"550 \"..(a.isDir(a4)and\"Path is directory\"or\"File '\"..a4 ..\"' does not exist\")end;am.current_task=self:_add_task(function()if am.connection.ip~=nil then am.connection.socket=l(am.connection.ip,self.connection.port)end;if am.connection.socket==nil then if am.connection.task~=nil then self.tasks[am.connection.task]=nil end;am.connection=nil;am.socket:write(\"425 Unable to open data connection.\")return end;local O;if am.transfer_params.type==\"A\"then local ar,Q=a.open(a4,\"r\")if not ar then am.connection.socket:close()am.connection=nil;am.current_task=nil;am.status.current_bytes=nil;am.status.target_bytes=nil;am.status.current_command=nil;am.socket:write(\"425 Unable to open file. (\"..Q..\")\")return end;O=ar.readAll()ar.close()else local ar,Q=a.open(a4,\"rb\")if not ar then am.connection.socket:close()am.connection=nil;am.current_task=nil;am.status.current_bytes=nil;am.status.target_bytes=nil;am.status.current_command=nil;am.socket:write(\"425 Unable to open file. (\"..Q..\")\")return end;O=ar.readAll()ar.close()end;am:send_data(O,self.port_provider)am.connection=nil;am.current_task=nil;am.status.current_bytes=nil;am.status.target_bytes=nil;am.status.current_command=nil end,\"send data \"..aq)am.status.current_command=\"RETR \"..a4;if am.connection.socket==nil then return\"150 Opening data connection\"else return\"125 Data connection already open; transfer starting.\"end end,STOR=function(self,am,aq)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if aq==nil then return\"501 Missing file name\"end;if am.connection.port==nil then return\"503 Bad sequence of commands\"end;if am.current_task~=nil then return\"425 Data connection already open\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;if a.isDir(a4)then am.connection=nil;return\"550 Path is directory\"end;am.current_task=self:_add_task(function()if am.connection.ip~=nil then am.connection.socket=l(am.connection.ip,self.connection.port)end;if am.connection.socket==nil then if am.connection.task~=nil then self.tasks[am.connection.task]=nil end;am.connection=nil;am.socket:write(\"425 Unable to open data connection.\")end;local O=am:receive_data(self.port_provider)local ar;if am.transfer_params.type==\"A\"then ar=a.open(a4,\"w\")else ar=a.open(a4,\"wb\")end;ar.write(O)ar.close()am.socket:write(\"250 Transfer complete\")am.connection=nil;am.current_task=nil;am.status.current_bytes=nil;am.status.target_bytes=nil;am.status.current_command=nil end,\"receive data \"..aq)am.status.current_command=\"STOR \"..a4;if am.connection.socket==nil then return\"150 Opening data connection\"else return\"125 Data connection already open; transfer starting.\"end end,STOU=function(self,am)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if am.connection.port==nil then return\"503 Bad sequence of commands\"end;if am.current_task~=nil then return\"425 Data connection already open\"end;local as,a4;as=table.concat((function()local a6={}local a7=1;for E=1,8 do a6[a7]=string.char(math.random(65,90))a7=a7+1 end;return a6 end)())..\".\"..table.concat((function()local a6={}local a7=1;for E=1,3 do a6[a7]=string.char(math.random(65,90))a7=a7+1 end;return a6 end)())a4=a.combine(am.dir,as)while a.exists(a4 or a.isDir(a4))do as=table.concat((function()local a6={}local a7=1;for E=1,8 do a6[a7]=string.char(math.random(65,90))a7=a7+1 end;return a6 end)())..\".\"..table.concat((function()local a6={}local a7=1;for E=1,3 do a6[a7]=string.char(math.random(65,90))a7=a7+1 end;return a6 end)())a4=a.combine(am.dir,as)end;am.current_task=self:_add_task(function()if am.connection.ip~=nil then am.connection.socket=l(am.connection.ip,self.connection.port)end;if am.connection.socket==nil then if am.connection.task~=nil then self.tasks[am.connection.task]=nil end;am.connection=nil;am.socket:write(\"425 Unable to open data connection.\")end;local O=am:receive_data(self.port_provider)local ar;if am.transfer_params.type==\"A\"then ar=a.open(a4,\"w\")else ar=a.open(a4,\"wb\")end;ar.write(O)ar.close()am.socket:write(\"250 Transfer complete: \"..as)am.connection=nil;am.current_task=nil;am.status.current_bytes=nil;am.status.target_bytes=nil;am.status.current_command=nil end,\"store unique \"..a4)am.status.current_command=\"STOU \"..a4;if am.connection.socket==nil then return\"150 Opening data connection\"else return\"125 Data connection already open; transfer starting.\"end end,APPE=function(self,am,aq)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if aq==nil then return\"501 Missing file name\"end;if am.connection.port==nil then return\"503 Bad sequence of commands\"end;if am.current_task~=nil then return\"425 Data connection already open\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;if a.isDir(a4)then am.connection=nil;return\"550 Path is directory\"end;am.current_task=self:_add_task(function()if am.connection.ip~=nil then am.connection.socket=l(am.connection.ip,self.connection.port)end;if am.connection.socket==nil then if am.connection.task~=nil then self.tasks[am.connection.task]=nil end;am.connection=nil;am.socket:write(\"425 Unable to open data connection.\")end;local O=am:receive_data(self.port_provider)local ar;if am.transfer_params.type==\"A\"then ar=a.open(a4,\"a\")else ar=a.open(a4,\"ab\")end;ar.write(O)ar.close()am.socket:write(\"250 Transfer complete\")am.connection=nil;am.current_task=nil;am.status.current_bytes=nil;am.status.target_bytes=nil;am.status.current_command=nil end,\"append \"..aq)am.status.current_command=\"APPE \"..a4;if am.connection.socket==nil then return\"150 Opening data connection\"else return\"125 Data connection already open; transfer starting.\"end end,ALLO=function(self,am)return\"502 ALLO command not implemented\"end,REST=function(self,am)return\"502 REST command not implemented\"end,RNFR=function(self,am,as)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if as==nil then return\"501 Missing file name\"end;am.rename_from=as;return\"350 Awaiting name to rename to.\"end,RNTO=function(self,am,as)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if as==nil then return\"501 Missing file name\"end;if am.rename_from==nil then return\"503 Bad sequence of commands\"end;local at;if am.rename_from:sub(1,1)==\"/\"then at=am.rename_from else at=a.combine(am.dir,am.rename_from)end;local au;if as:sub(1,1)==\"/\"then au=as else au=a.combine(am.dir,as)end;a.move(at,au)am.rename_from=nil;return\"250 File operation succeeded\"end,ABOR=function(self,am)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if self.current_task==nil then return\"226 No data transfer in progress\"end;self.tasks[am.current_task]=nil;am.socket:write(\"426 Data transfer aborted.\")return\"226 Data transfer successfully aborted.\"end,DELE=function(self,am,aq)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if aq==nil then return\"501 Missing file name\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;if not fs.exists(a4)then return\"550 File not found\"end;if fs.isDir(a4)then return\"550 Path is directory\"end;a.delete(a4)return\"250 File deleted\"end,RMD=function(self,am,aq)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if aq==nil then return\"501 Missing file name\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;if not fs.exists(a4)then return\"550 Directory not found\"end;if not fs.isDir(a4)then return\"550 Path is not directory\"end;a.delete(a4)return\"250 Directory deleted\"end,MKD=function(self,am,aq)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if aq==nil then return\"501 Missing file name\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;a.makeDir(a4)return'257 Created directory \"'..a4 ..'\"'end,PWD=function(self,am)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;return'257 \"/'..am.dir..'\"'end,LIST=function(self,am,aq)if aq==nil then aq=am.dir end;if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if am.connection.port==nil then return\"503 Bad sequence of commands\"end;if am.current_task~=nil then return\"425 Data connection already open\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;if not a.isDir(a4)then am.connection=nil;return\"550 Path is not a directory\"end;am.current_task=self:_add_task(function()if am.connection.ip~=nil then am.connection.socket=l(am.connection.ip,self.connection.port)end;if am.connection.socket==nil then if am.connection.task~=nil then self.tasks[am.connection.task]=nil end;am.connection=nil;am.socket:write(\"425 Unable to open data connection.\")end;local av={}for E,aw in ipairs(a.list(a4))do local ao=a.combine(a4,aw)local ax=a.attributes(ao)av[E]=(\"%s%s % 4d craftos craftos % 8d %s %s\"):format(ax.isDir and\"d\"or\"-\",(ax.isReadOnly and\"r-x\"or\"rwx\"):rep(3),ax.isDir and#a.list(ao)or 1,ax.size,os.date(\"%h %e  %Y\",ax.modified/1000),aw)end;am:send_data(table.concat(av,\"\\n\")..\"\\n\",self.port_provider)am.connection=nil;am.current_task=nil;am.status.current_bytes=nil;am.status.target_bytes=nil;am.status.current_command=nil end,\"name list \"..aq)am.status.current_command=\"NLST \"..a4;if am.connection.socket==nil then return\"150 Opening data connection\"else return\"125 Data connection already open; transfer starting.\"end end,NLST=function(self,am,aq)if aq==nil then aq=am.dir end;if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if am.connection.port==nil then return\"503 Bad sequence of commands\"end;if am.current_task~=nil then return\"425 Data connection already open\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;if not a.isDir(a4)then am.connection=nil;return\"550 Path is not a directory\"end;am.current_task=self:_add_task(function()if am.connection.ip~=nil then am.connection.socket=l(am.connection.ip,self.connection.port)end;if am.connection.socket==nil then if am.connection.task~=nil then self.tasks[am.connection.task]=nil end;am.connection=nil;am.socket:write(\"425 Unable to open data connection.\")end;am:send_data(table.concat((function()local a6={}local a7=1;for ay,aw in ipairs(a.list(a4))do a6[a7]=aw;a7=a7+1 end;return a6 end)(),\"\\n\")..\"\\n\",self.port_provider)am.connection=nil;am.current_task=nil;am.status.current_bytes=nil;am.status.target_bytes=nil;am.status.current_command=nil end,\"name list \"..aq)am.status.current_command=\"NLST \"..a4;if am.connection.socket==nil then return\"150 Opening data connection\"else return\"125 Data connection already open; transfer starting.\"end end,SITE=function(self,am)return\"202 Not implemented\"end,SYST=function(self,am)return\"215 UNKNOWN Phoenix\"end,STAT=function(self,am)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;return\"211-Status of '\"..tostring(b(\"/\",\"getLabel\"))..\"'\\n Connected from ID \"..tostring(am.socket.id)..\"\\n Logged in as \"..tostring(am.username)..\"\\n TYPE: \"..tostring(am.transfer.params==\"A\"and\"ASCII\"or\"Image\")..\", STRUcture: File, Mode: \"..tostring(am.transfer.params==\"S\"and\"Stream\"or(am.transfer.params==\"B\"and\"Block\"or\"Compressed\"))..\"\\n Total bytes transferred for session: \"..tostring(am.status.total_bytes)..\"\\n\"..(self.current_task==nil and\"No data connection\"or tostring(am.connection.id==nil and\"Passive\"or\"Active\")..\" data transfer from \"..tostring(am.connection.socket.id)..\" port \"..tostring(am.connection.port)..\"\\n\"..tostring(am.status.current_command)..\" (\"..tostring(am.status.target_bytes)..\"/\"..tostring(am.status.current_bytes)..\")\")..\"\\n211 End of status\"end,HELP=function(self,am,az)return\"202 Not implemented (yet)\"end,NOOP=function(self,am)return\"200 NOOP command successful\"end},_add_task=function(self,aA,as)return g(aA)end,listen=function(self)local r=\"psp://\"..self.ip..\":\"..self.port;d(r)while true do local t,u=coroutine.yield()if t==\"network_request\"and u.uri==r then self:_add_task(function()return self:run(u.handle)end,\"connection \"..u.handle.id)end end end,run=function(self,o)return self:_run_connection(aj(o))end,_run_connection=function(self,am)am.socket:write(\"220 Hello!\\n\")while am.socket:status()==\"open\"do local aB=v(am.socket)if not aB then break end;local I,aC=aB:gsub(\"%s+$\",\"\")if aB:find(\" \")then I,aC=aB:sub(1,aB:find(\" \")-1):upper():gsub(\"%s+$\",\"\"),aB:sub(aB:find(\" \")+1):gsub(\"%s+$\",\"\")end;if self.commands[I]==nil then am.socket:write(\"500 Unknown command '\"..I..\"'\\n\")else if aC==\"\"then aC=nil end;local K=self.commands[I](self,am,aC)if not(am.socket:status()==\"open\")then break end;if K and self.commands[I]~=nil then am.socket:write(K..\"\\n\")end end end;return am.socket:close()end}H.__index=H;G=setmetatable({__init=function(self,m,n,aD,ak)if m==nil then m=\"0.0.0.0\"end;if n==nil then n=21 end;if aD==nil then aD=nil end;if ak==nil then ak=B()end;self.port=n;self.auth=aD;self.filesystem=a;self.port_provider=ak;self.ip=m end,__base=H,__name=\"server\"},{__index=H,__call=function(ah,...)local ai=setmetatable({},H)ah.__init(ai,...)return ai end})H.__class=G;al=G end;return{client=F,server=al}\n",setuser=false,size=33432,modified=1757997040590,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["usermgr.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997043165,data="local a=require\"system.expect\"local b=require\"system.ipc\"local c=require\"system.process\"local d={}local e;local function f(g,h)if not e then e=b.lookup(\"usermgr\")end;if not e then error(\"Could not connect to user authentication service\",2)end;b.sendEvent(e,\"usermgr.request.\"..g,h)local i,j=b.receiveEvent(e,\"usermgr.response.\"..g,5)if not j then error(\"Timed out waiting for user authentication service\",2)end;return j end;function d.authenticate(k,l)a(1,k,\"string\")a(2,l,\"string\")if c.getuser()~=\"root\"then error(\"Permission denied\",2)end;local m=f(\"authenticate\",{user=k,password=l})return m.result or false,m.error or m.message end;function d.getUserInfo(k)a(1,k,\"string\")local m=f(\"getUserInfo\",{user=k})if m.error then error(m.error,2)end;return m.result end;function d.addUser(k,l,n)a(1,k,\"string\")a(2,l,\"string\",\"nil\")n=a(3,n,\"table\",\"nil\")or{}a.field(n,\"fullName\",\"string\",\"nil\")a.field(n,\"home\",\"string\",\"nil\")a.field(n,\"shell\",\"string\",\"nil\")n.user=k;n.password=l;if c.getuser()~=\"root\"then error(\"Permission denied\",2)end;local m=f(\"addUser\",n)if m.error then error(m.error,2)end;return m.result or false end;function d.removeUser(k)a(1,k,\"string\")if c.getuser()~=\"root\"then error(\"Permission denied\",2)end;local m=f(\"removeUser\",{user=k})if m.error then error(m.error,2)end;return m.result or false end;function d.editUser(k,n)a(1,k,\"string\")a(2,n,\"table\")a.field(n,\"fullName\",\"string\",\"nil\")a.field(n,\"home\",\"string\",\"nil\")a.field(n,\"shell\",\"string\",\"nil\")n.user=k;local o=c.getuser()if o~=\"root\"and o~=k then error(\"Permission denied\",2)end;local m=f(\"editUser\",n)if m.error then error(m.error,2)end;return m.result or false end;function d.setPassword(k,l,n)a(1,k,\"string\")a(2,l,\"string\",\"nil\")n=a(3,n,\"table\",\"nil\")or{}a.field(n,\"nextChange\",\"number\",\"nil\")a.field(n,\"expirationTime\",\"number\",\"nil\")a.field(n,\"expirationWarning\",\"number\",\"nil\")a.field(n,\"lockTime\",\"number\",\"nil\")a.field(n,\"isLocked\",\"boolean\",\"nil\")if c.getuser()~=\"root\"then error(\"Permission denied\",2)end;n.user,n.password=k,l;local m=f(\"setPassword\",n)if m.error then error(m.error,2)end;return m.result or false end;return d\n",setuser=false,size=2114,modified=1757997043113,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["LibDeflate.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997041136,data="local a;do local b=\"1.0.2-release\"local c=\"LibDeflate\"local d=3;local e=\"LibDeflate \"..b..\" Copyright (C) 2018-2021 Haoqian He.\"..\" Licensed under the zlib License\"if LibStub then local f,g=LibStub:GetLibrary(c,true)if f and g and g>=d then return f else a=LibStub:NewLibrary(c,d)end else a={}end;a._VERSION=b;a._MAJOR=c;a._MINOR=d;a._COPYRIGHT=e end;local assert=assert;local error=error;local pairs=pairs;local h=string.byte;local i=string.char;local j=string.find;local k=string.gsub;local l=string.sub;local m=table.concat;local n=table.sort;local tostring=tostring;local type=type;local o={}local p={}local q={}local r={}local s={}local t={}local u={}local v={}local w={}local x={3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258}local y={0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0}local z={[0]=1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577}local A={[0]=0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13}local B={16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15}local C;local D;local E;local F;local G;local H;local I;local J;for K=0,255 do p[K]=i(K)end;do local L=1;for K=0,32 do o[K]=L;L=L*2 end end;for K=1,9 do q[K]={}for M=0,o[K+1]-1 do local N=0;local O=M;for P=1,K do N=N-N%2+((N%2==1 or O%2==1)and 1 or 0)O=(O-O%2)/2;N=N*2 end;q[K][M]=(N-N%2)/2 end end;do local Q=18;local R=16;local S=265;local T=1;for U=3,258 do if U<=10 then r[U]=U+254;t[U]=0 elseif U==258 then r[U]=285;t[U]=0 else if U>Q then Q=Q+R;R=R*2;S=S+4;T=T+1 end;local V=U-Q-1+R/2;r[U]=(V-V%(R/8))/(R/8)+S;t[U]=T;s[U]=V%(R/8)end end end;do u[1]=0;u[2]=1;w[1]=0;w[2]=0;local Q=3;local R=4;local W=2;local T=0;for X=3,256 do if X>R then Q=Q*2;R=R*2;W=W+2;T=T+1 end;u[X]=X<=Q and W or W+1;w[X]=T<0 and 0 or T;if R>=8 then v[X]=(X-R/2-1)%(R/4)end end end;local Y,Z,_,a0,a1=bit32.band,bit32.bnot,bit32.bxor,bit32.lshift,bit32.rshift;local a2=0xEDB88320;local function a3(a4)local a5={}local V=setmetatable({},a5)function a5:__index(a6)local a7=a4(a6)V[a6]=a7;return a7 end;return V end;local a8=a3(function(K)local a9=K;for P=1,8 do local R=Y(a9,1)a9=a1(a9,1)if R==1 then a9=_(a9,a2)end end;return a9 end)local function aa(ab,a9)a9=Z(a9 or 0)local ac=a1(a9,8)local ad=a8[_(a9%256,ab)]return Z(_(ac,ad))end;local function ae(af,a9)a9=a9 or 0;for K=1,#af do a9=aa(af:byte(K),a9)end;return a9 end;function a:CRC32(af,a9)if type(af)=='string'then return ae(af,a9)else return aa(af,a9)end end;function a:Adler32(ag)if type(ag)~=\"string\"then error((\"Usage: LibDeflate:Adler32(str):\"..\" 'str' - string expected got '%s'.\"):format(type(ag)),2)end;local ah=#ag;local K=1;local Q=1;local R=0;while K<=ah-15 do local ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax=h(ag,K,K+15)R=(R+16*Q+16*ai+15*aj+14*ak+13*al+12*am+11*an+10*ao+9*ap+8*aq+7*ar+6*as+5*at+4*au+3*av+2*aw+ax)%65521;Q=(Q+ai+aj+ak+al+am+an+ao+ap+aq+ar+as+at+au+av+aw+ax)%65521;K=K+16 end;while K<=ah do local ay=h(ag,K,K)Q=(Q+ay)%65521;R=(R+Q)%65521;K=K+1 end;return(R*65536+Q)%4294967296 end;local function az(aA,aB)return aA%4294967296==aB%4294967296 end;function a:CreateDictionary(ag,ah,aC)if type(ag)~=\"string\"then error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\"..\" 'str' - string expected got '%s'.\"):format(type(ag)),2)end;if type(ah)~=\"number\"then error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\"..\" 'strlen' - number expected got '%s'.\"):format(type(ah)),2)end;if type(aC)~=\"number\"then error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\"..\" 'adler32' - number expected got '%s'.\"):format(type(aC)),2)end;if ah~=#ag then error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\"..\" 'strlen' does not match the actual length of 'str'.\"..\" 'strlen': %u, '#str': %u .\"..\" Please check if 'str' is modified unintentionally.\"):format(ah,#ag))end;if ah==0 then error(\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\"..\" 'str' - Empty string is not allowed.\",2)end;if ah>32768 then error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\"..\" 'str' - string longer than 32768 bytes is not allowed.\"..\" Got %d bytes.\"):format(ah),2)end;local aD=self:Adler32(ag)if not az(aC,aD)then error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\"..\" 'adler32' does not match the actual adler32 of 'str'.\"..\" 'adler32': %u, 'Adler32(str)': %u .\"..\" Please check if 'str' is modified unintentionally.\"):format(aC,aD))end;local aE={}aE.adler32=aC;aE.hash_tables={}aE.string_table={}aE.strlen=ah;local aF=aE.string_table;local aG=aE.hash_tables;aF[1]=h(ag,1,1)aF[2]=h(ag,2,2)if ah>=3 then local K=1;local aH=aF[1]*256+aF[2]while K<=ah-2-3 do local ai,aj,ak,al=h(ag,K+2,K+5)aF[K+2]=ai;aF[K+3]=aj;aF[K+4]=ak;aF[K+5]=al;aH=(aH*256+ai)%16777216;local V=aG[aH]if not V then V={}aG[aH]=V end;V[#V+1]=K-ah;K=K+1;aH=(aH*256+aj)%16777216;V=aG[aH]if not V then V={}aG[aH]=V end;V[#V+1]=K-ah;K=K+1;aH=(aH*256+ak)%16777216;V=aG[aH]if not V then V={}aG[aH]=V end;V[#V+1]=K-ah;K=K+1;aH=(aH*256+al)%16777216;V=aG[aH]if not V then V={}aG[aH]=V end;V[#V+1]=K-ah;K=K+1 end;while K<=ah-2 do local ay=h(ag,K+2)aF[K+2]=ay;aH=(aH*256+ay)%16777216;local V=aG[aH]if not V then V={}aG[aH]=V end;V[#V+1]=K-ah;K=K+1 end end;return aE end;local function aI(aE)if type(aE)~=\"table\"then return false,(\"'dictionary' - table expected got '%s'.\"):format(type(aE))end;if type(aE.adler32)~=\"number\"or type(aE.string_table)~=\"table\"or type(aE.strlen)~=\"number\"or aE.strlen<=0 or aE.strlen>32768 or aE.strlen~=#aE.string_table or type(aE.hash_tables)~=\"table\"then return false,(\"'dictionary' - corrupted dictionary.\"):format(type(aE))end;return true,\"\"end;local aJ={[0]={false,nil,0,0,0},[1]={false,nil,4,8,4},[2]={false,nil,5,18,8},[3]={false,nil,6,32,32},[4]={true,4,4,16,16},[5]={true,8,16,32,32},[6]={true,8,16,128,128},[7]={true,8,32,128,256},[8]={true,32,128,258,1024},[9]={true,32,258,258,4096}}local function aK(ag,aL,aE,aM,aN)if type(ag)~=\"string\"then return false,(\"'str' - string expected got '%s'.\"):format(type(ag))end;if aL then local aO,aP=aI(aE)if not aO then return false,aP end end;if aM then local aQ=type(aN)if aQ~=\"nil\"and aQ~=\"table\"then return false,(\"'configs' - nil or table expected got '%s'.\"):format(type(aN))end;if aQ==\"table\"then for a6,a7 in pairs(aN)do if a6~=\"level\"and a6~=\"strategy\"then return false,(\"'configs' - unsupported table key in the configs: '%s'.\"):format(a6)elseif a6==\"level\"and not aJ[a7]then return false,(\"'configs' - unsupported 'level': %s.\"):format(tostring(a7))elseif a6==\"strategy\"and a7~=\"fixed\"and a7~=\"huffman_only\"and a7~=\"dynamic\"then return false,(\"'configs' - unsupported 'strategy': '%s'.\"):format(tostring(a7))end end end end;return true,\"\"end;local aR=0;local aS=1;local aT=2;local aU=3;local function aV()local aW=0;local aX=0;local aY=0;local aZ=0;local a_={}local b0={}local function b1(O,T)aX=aX+O*o[aY]aY=aY+T;aZ=aZ+T;if aY>=32 then aW=aW+1;a_[aW]=p[aX%256]..p[(aX-aX%256)/256%256]..p[(aX-aX%65536)/65536%256]..p[(aX-aX%16777216)/16777216%256]local b2=o[32-aY+T]aX=(O-O%b2)/b2;aY=aY-32 end end;local function b3(ag)for P=1,aY,8 do aW=aW+1;a_[aW]=i(aX%256)aX=(aX-aX%256)/256 end;aY=0;aW=aW+1;a_[aW]=ag;aZ=aZ+#ag*8 end;local function b4(b5)if b5==aU then return aZ end;if b5==aS or b5==aT then local b6=(8-aY%8)%8;if aY>0 then aX=aX-o[aY]+o[aY+b6]for P=1,aY,8 do aW=aW+1;a_[aW]=p[aX%256]aX=(aX-aX%256)/256 end;aX=0;aY=0 end;if b5==aT then aZ=aZ+b6;return aZ end end;local b7=m(a_)a_={}aW=0;b0[#b0+1]=b7;if b5==aR then return aZ else return aZ,m(b0)end end;return b1,b3,b4 end;local function b8(b9,ba,bb)bb=bb+1;b9[bb]=ba;local O=ba[1]local bc=bb;local bd=(bc-bc%2)/2;while bd>=1 and b9[bd][1]>O do local V=b9[bd]b9[bd]=ba;b9[bc]=V;bc=bd;bd=(bd-bd%2)/2 end end;local function be(b9,bb)local bf=b9[1]local ba=b9[bb]local O=ba[1]b9[1]=ba;b9[bb]=bf;bb=bb-1;local bc=1;local bg=bc*2;local bh=bg+1;while bg<=bb do local bi=b9[bg]if bh<=bb and b9[bh][1]<bi[1]then local bj=b9[bh]if bj[1]<O then b9[bh]=ba;b9[bc]=bj;bc=bh;bg=bc*2;bh=bg+1 else break end else if bi[1]<O then b9[bg]=ba;b9[bc]=bi;bc=bg;bg=bc*2;bh=bg+1 else break end end end;return bf end;local function bk(bl,bm,bn,bo)local bp=0;local bq={}local br={}for T=1,bo do bp=(bp+(bl[T-1]or 0))*2;bq[T]=bp end;for bs=0,bn do local T=bm[bs]if T then bp=bq[T]bq[T]=bp+1;if T<=9 then br[bs]=q[T][bp]else local N=0;for P=1,T do N=N-N%2+((N%2==1 or bp%2==1)and 1 or 0)bp=(bp-bp%2)/2;N=N*2 end;br[bs]=(N-N%2)/2 end end end;return br end;local function bt(Q,R)return Q[1]<R[1]or Q[1]==R[1]and Q[2]<R[2]end;local function bu(bv,bo,bn)local bb;local bw=-1;local bx={}local b9={}local bm={}local by={}local bl={}local bz=0;for bs,bA in pairs(bv)do bz=bz+1;bx[bz]={bA,bs}end;if bz==0 then return{},{},-1 elseif bz==1 then local bs=bx[1][2]bm[bs]=1;by[bs]=0;return bm,by,bs else n(bx,bt)bb=bz;for K=1,bb do b9[K]=bx[K]end;while bb>1 do local bB=be(b9,bb)bb=bb-1;local bC=be(b9,bb)bb=bb-1;local bD={bB[1]+bC[1],-1,bB,bC}b8(b9,bD,bb)bb=bb+1 end;local bE=0;local bF={b9[1],0,0,0}local bG=1;local bH=1;b9[1][1]=0;while bH<=bG do local ba=bF[bH]local T=ba[1]local bs=ba[2]local bi=ba[3]local bj=ba[4]if bi then bG=bG+1;bF[bG]=bi;bi[1]=T+1 end;if bj then bG=bG+1;bF[bG]=bj;bj[1]=T+1 end;bH=bH+1;if T>bo then bE=bE+1;T=bo end;if bs>=0 then bm[bs]=T;bw=bs>bw and bs or bw;bl[T]=(bl[T]or 0)+1 end end;if bE>0 then repeat local T=bo-1;while(bl[T]or 0)==0 do T=T-1 end;bl[T]=bl[T]-1;bl[T+1]=(bl[T+1]or 0)+2;bl[bo]=bl[bo]-1;bE=bE-2 until bE<=0;bH=1;for T=bo,1,-1 do local bI=bl[T]or 0;while bI>0 do local bs=bx[bH][2]bm[bs]=T;bI=bI-1;bH=bH+1 end end end;by=bk(bl,bm,bn,bo)return bm,by,bw end end;local function bJ(bK,bL,bM,bN)local bO=0;local bP={}local bQ={}local bR=0;local bS={}local bT=nil;local bA=0;bN=bN<0 and 0 or bN;local bU=bL+bN+1;for W=0,bU+1 do local U=W<=bL and(bK[W]or 0)or(W<=bU and(bM[W-bL-1]or 0)or nil)if U==bT then bA=bA+1;if U~=0 and bA==6 then bO=bO+1;bP[bO]=16;bR=bR+1;bS[bR]=3;bQ[16]=(bQ[16]or 0)+1;bA=0 elseif U==0 and bA==138 then bO=bO+1;bP[bO]=18;bR=bR+1;bS[bR]=127;bQ[18]=(bQ[18]or 0)+1;bA=0 end else if bA==1 then bO=bO+1;bP[bO]=bT;bQ[bT]=(bQ[bT]or 0)+1 elseif bA==2 then bO=bO+1;bP[bO]=bT;bO=bO+1;bP[bO]=bT;bQ[bT]=(bQ[bT]or 0)+2 elseif bA>=3 then bO=bO+1;local bV=bT~=0 and 16 or(bA<=10 and 17 or 18)bP[bO]=bV;bQ[bV]=(bQ[bV]or 0)+1;bR=bR+1;bS[bR]=bA<=10 and bA-3 or bA-11 end;bT=U;if U and U~=0 then bO=bO+1;bP[bO]=U;bQ[U]=(bQ[U]or 0)+1;bA=0 else bA=1 end end end;return bP,bS,bQ end;local function bW(ag,V,bX,bY,bZ)local K=bX-bZ;while K<=bY-15-bZ do V[K],V[K+1],V[K+2],V[K+3],V[K+4],V[K+5],V[K+6],V[K+7],V[K+8],V[K+9],V[K+10],V[K+11],V[K+12],V[K+13],V[K+14],V[K+15]=h(ag,K+bZ,K+15+bZ)K=K+16 end;while K<=bY-bZ do V[K]=h(ag,K+bZ,K+bZ)K=K+1 end;return V end;local function b_(c0,aF,aG,c1,c2,bZ,aE)local c3=aJ[c0]local c4,c5,c6,c7,c8=c3[1],c3[2],c3[3],c3[4],c3[5]local c9=not c4 and c6 or 2147483646;local ca=c8-c8%4/4;local aH;local cb;local cc;local cd=0;if aE then cb=aE.hash_tables;cc=aE.string_table;cd=aE.strlen;assert(c1==1)if c2>=c1 and cd>=2 then aH=cc[cd-1]*65536+cc[cd]*256+aF[1]local V=aG[aH]if not V then V={}aG[aH]=V end;V[#V+1]=-1 end;if c2>=c1+1 and cd>=1 then aH=cc[cd]*65536+aF[1]*256+aF[2]local V=aG[aH]if not V then V={}aG[aH]=V end;V[#V+1]=0 end end;local ce=cd+3;aH=(aF[c1-bZ]or 0)*256+(aF[c1+1-bZ]or 0)local cf={}local cg=0;local ch={}local ci={}local cj=0;local ck={}local cl={}local cm=0;local cn={}local co=0;local cp=false;local cq;local cr;local cs=0;local ct=0;local bH=c1;local cu=c2+(c4 and 1 or 0)while bH<=cu do local cv=bH-bZ;local cw=bZ-3;cq=cs;cr=ct;cs=0;aH=(aH*256+(aF[cv+2]or 0))%16777216;local cx;local cy;local cz=aG[aH]local cA;if not cz then cA=0;cz={}aG[aH]=cz;if cb then cy=cb[aH]cx=cy and#cy or 0 else cx=0 end else cA=#cz;cy=cz;cx=cA end;if bH<=c2 then cz[cA+1]=bH end;if cx>0 and bH+2<=c2 and(not c4 or cq<c6)then local cB=c4 and cq>=c5 and ca or c8;local cC=c2-bH;cC=cC>=257 and 257 or cC;cC=cC+cv;local cD=cv+3;while cx>=1 and cB>0 do local bT=cy[cx]if bH-bT>32768 then break end;if bT<bH then local cE=cD;if bT>=-257 then local cF=bT-cw;while cE<=cC and aF[cF]==aF[cE]do cE=cE+1;cF=cF+1 end else local cF=ce+bT;while cE<=cC and cc[cF]==aF[cE]do cE=cE+1;cF=cF+1 end end;local M=cE-cv;if M>cs then cs=M;ct=bH-bT end;if cs>=c7 then break end end;cx=cx-1;cB=cB-1;if cx==0 and bT>0 and cb then cy=cb[aH]cx=cy and#cy or 0 end end end;if not c4 then cq,cr=cs,ct end;if(not c4 or cp)and(cq>3 or cq==3 and cr<4096)and cs<=cq then local W=r[cq]local cG=t[cq]local cH,cI,cJ;if cr<=256 then cH=u[cr]cJ=v[cr]cI=w[cr]else cH=16;cI=7;local Q=384;local R=512;while true do if cr<=Q then cJ=(cr-R/2-1)%(R/4)break elseif cr<=R then cJ=(cr-R/2-1)%(R/4)cH=cH+1;break else cH=cH+2;cI=cI+1;Q=Q*2;R=R*2 end end end;cg=cg+1;cf[cg]=W;ch[W]=(ch[W]or 0)+1;cj=cj+1;ci[cj]=cH;ck[cH]=(ck[cH]or 0)+1;if cG>0 then local cK=s[cq]cm=cm+1;cl[cm]=cK end;if cI>0 then co=co+1;cn[co]=cJ end;for K=bH+1,bH+cq-(c4 and 2 or 1)do aH=(aH*256+(aF[K-bZ+2]or 0))%16777216;if cq<=c9 then cz=aG[aH]if not cz then cz={}aG[aH]=cz end;cz[#cz+1]=K end end;bH=bH+cq-(c4 and 1 or 0)cp=false elseif not c4 or cp then local W=aF[c4 and cv-1 or cv]cg=cg+1;cf[cg]=W;ch[W]=(ch[W]or 0)+1;bH=bH+1 else cp=true;bH=bH+1 end end;cg=cg+1;cf[cg]=256;ch[256]=(ch[256]or 0)+1;return cf,cl,ch,ci,cn,ck end;local function cL(ch,ck)local cM,cN,bL=bu(ch,15,285)local cO,cP,bN=bu(ck,15,29)local cQ,bS,cR=bJ(cM,bL,cO,bN)local cS,cT=bu(cR,7,18)local cU=0;for K=1,19 do local bs=B[K]local cV=cS[bs]or 0;if cV~=0 then cU=K end end;cU=cU-4;local cW=bL+1-257;local cX=bN+1-1;if cX<0 then cX=0 end;return cW,cX,cU,cS,cT,cQ,bS,cM,cN,cO,cP end;local function cY(cf,ci,cU,cS,cQ,cM,cO)local cZ=17;cZ=cZ+(cU+4)*3;for K=1,#cQ do local W=cQ[K]cZ=cZ+cS[W]if W>=16 then cZ=cZ+(W==16 and 2 or(W==17 and 3 or 7))end end;local c_=0;for K=1,#cf do local W=cf[K]local d0=cM[W]cZ=cZ+d0;if W>256 then c_=c_+1;if W>264 and W<285 then local d1=y[W-256]cZ=cZ+d1 end;local cH=ci[c_]local d2=cO[cH]cZ=cZ+d2;if cH>3 then local cI=(cH-cH%2)/2-1;cZ=cZ+cI end end end;return cZ end;local function d3(b1,d4,cf,cl,ci,cn,cW,cX,cU,cS,cT,cQ,bS,cM,cN,cO,cP)b1(d4 and 1 or 0,1)b1(2,2)b1(cW,5)b1(cX,5)b1(cU,4)for K=1,cU+4 do local bs=B[K]local cV=cS[bs]or 0;b1(cV,3)end;local d5=1;for K=1,#cQ do local W=cQ[K]b1(cT[W],cS[W])if W>=16 then local d6=bS[d5]b1(d6,W==16 and 2 or(W==17 and 3 or 7))d5=d5+1 end end;local c_=0;local d7=0;local d8=0;for K=1,#cf do local d9=cf[K]local bp=cN[d9]local d0=cM[d9]b1(bp,d0)if d9>256 then c_=c_+1;if d9>264 and d9<285 then d7=d7+1;local da=cl[d7]local d1=y[d9-256]b1(da,d1)end;local db=ci[c_]local dc=cP[db]local d2=cO[db]b1(dc,d2)if db>3 then d8=d8+1;local cJ=cn[d8]local cI=(db-db%2)/2-1;b1(cJ,cI)end end end end;local function dd(cf,ci)local cZ=3;local c_=0;for K=1,#cf do local W=cf[K]local d0=E[W]cZ=cZ+d0;if W>256 then c_=c_+1;if W>264 and W<285 then local d1=y[W-256]cZ=cZ+d1 end;local cH=ci[c_]cZ=cZ+5;if cH>3 then local cI=(cH-cH%2)/2-1;cZ=cZ+cI end end end;return cZ end;local function de(b1,d4,cf,cl,ci,cn)b1(d4 and 1 or 0,1)b1(1,2)local c_=0;local d7=0;local d8=0;for K=1,#cf do local df=cf[K]local bp=C[df]local d0=E[df]b1(bp,d0)if df>256 then c_=c_+1;if df>264 and df<285 then d7=d7+1;local da=cl[d7]local d1=y[df-256]b1(da,d1)end;local cH=ci[c_]local dc=G[cH]b1(dc,5)if cH>3 then d8=d8+1;local cJ=cn[d8]local cI=(cH-cH%2)/2-1;b1(cJ,cI)end end end end;local function dg(c1,c2,aZ)assert(c2-c1+1<=65535)local cZ=3;aZ=aZ+3;local b6=(8-aZ%8)%8;cZ=cZ+b6;cZ=cZ+32;cZ=cZ+(c2-c1+1)*8;return cZ end;local function dh(b1,b3,d4,ag,c1,c2,aZ)assert(c2-c1+1<=65535)b1(d4 and 1 or 0,1)b1(0,2)aZ=aZ+3;local b6=(8-aZ%8)%8;if b6>0 then b1(o[b6]-1,b6)end;local di=c2-c1+1;b1(di,16)local dj=255-di%256+(255-(di-di%256)/256)*256;b1(dj,16)b3(ag:sub(c1,c2))end;local function dk(aN,b1,b3,b4,ag,aE)local aF={}local aG={}local d4=nil;local c1;local c2;local dl;local aZ=b4(aU)local ah=#ag;local bZ;local c0;local dm;if aN then if aN.level then c0=aN.level end;if aN.strategy then dm=aN.strategy end end;if not c0 then if ah<2048 then c0=7 elseif ah>65536 then c0=3 else c0=5 end end;while not d4 do if not c1 then c1=1;c2=64*1024-1;bZ=0 else c1=c2+1;c2=c2+32*1024;bZ=c1-32*1024-1 end;if c2>=ah then c2=ah;d4=true else d4=false end;local cf,cl,ch,ci,cn,ck;local cW,cX,cU,cS,cT,cQ,bS,cM,cN,cO,cP;local dn;local dp;local dq;if c0~=0 then bW(ag,aF,c1,c2+3,bZ)if c1==1 and aE then local cc=aE.string_table;local dr=aE.strlen;for K=0,-dr+1<-257 and-257 or-dr+1,-1 do aF[K]=cc[dr+K]end end;if dm==\"huffman_only\"then cf={}bW(ag,cf,c1,c2,c1-1)cl={}ch={}cf[c2-c1+2]=256;for K=1,c2-c1+2 do local W=cf[K]ch[W]=(ch[W]or 0)+1 end;ci={}cn={}ck={}else cf,cl,ch,ci,cn,ck=b_(c0,aF,aG,c1,c2,bZ,aE)end;cW,cX,cU,cS,cT,cQ,bS,cM,cN,cO,cP=cL(ch,ck)dn=cY(cf,ci,cU,cS,cQ,cM,cO)dp=dd(cf,ci)end;dq=dg(c1,c2,aZ)local ds=dq;ds=dp and dp<ds and dp or ds;ds=dn and dn<ds and dn or ds;if c0==0 or dm~=\"fixed\"and dm~=\"dynamic\"and dq==ds then dh(b1,b3,d4,ag,c1,c2,aZ)aZ=aZ+dq elseif dm~=\"dynamic\"and(dm==\"fixed\"or dp==ds)then de(b1,d4,cf,cl,ci,cn)aZ=aZ+dp elseif dm==\"dynamic\"or dn==ds then d3(b1,d4,cf,cl,ci,cn,cW,cX,cU,cS,cT,cQ,bS,cM,cN,cO,cP)aZ=aZ+dn end;if d4 then dl=b4(aU)else dl=b4(aR)end;assert(dl==aZ)if not d4 then local M;if aE and c1==1 then M=0;while aF[M]do aF[M]=nil;M=M-1 end end;aE=nil;M=1;for K=c2-32767,c2 do aF[M]=aF[K-bZ]M=M+1 end;for a6,V in pairs(aG)do local dt=#V;if dt>0 and c2+1-V[1]>32768 then if dt==1 then aG[a6]=nil else local du={}local dv=0;for K=2,dt do M=V[K]if c2+1-M<=32768 then dv=dv+1;du[dv]=M end end;aG[a6]=du end end end end end end;local function dw(ag,aE,aN)local b1,b3,b4=aV()dk(aN,b1,b3,b4,ag,aE)local aZ,dx=b4(aS)local b6=(8-aZ%8)%8;return dx,b6 end;local function dy(ag,aE,aN)local b1,b3,b4=aV()local dz=8;local dA=7;local dB=dA*16+dz;b1(dB,8)local dC=aE and 1 or 0;local dD=2;local dE=dD*64+dC*32;local dF=31-(dB*256+dE)%31;dE=dE+dF;b1(dE,8)if dC==1 then local aC=aE.adler32;local dG=aC%256;aC=(aC-dG)/256;local dH=aC%256;aC=(aC-dH)/256;local dI=aC%256;aC=(aC-dI)/256;local dJ=aC%256;b1(dJ,8)b1(dI,8)b1(dH,8)b1(dG,8)end;dk(aN,b1,b3,b4,ag,aE)b4(aT)local aC=a:Adler32(ag)local dJ=aC%256;aC=(aC-dJ)/256;local dI=aC%256;aC=(aC-dI)/256;local dH=aC%256;aC=(aC-dH)/256;local dG=aC%256;b1(dG,8)b1(dH,8)b1(dI,8)b1(dJ,8)local aZ,dx=b4(aS)local b6=(8-aZ%8)%8;return dx,b6 end;function a:CompressDeflate(ag,aN)local dK,dL=aK(ag,false,nil,true,aN)if not dK then error(\"Usage: LibDeflate:CompressDeflate(str, configs): \"..dL,2)end;return dw(ag,nil,aN)end;function a:CompressDeflateWithDict(ag,aE,aN)local dK,dL=aK(ag,true,aE,true,aN)if not dK then error(\"Usage: LibDeflate:CompressDeflateWithDict\"..\"(str, dictionary, configs): \"..dL,2)end;return dw(ag,aE,aN)end;function a:CompressZlib(ag,aN)local dK,dL=aK(ag,false,nil,true,aN)if not dK then error(\"Usage: LibDeflate:CompressZlib(str, configs): \"..dL,2)end;return dy(ag,nil,aN)end;function a:CompressZlibWithDict(ag,aE,aN)local dK,dL=aK(ag,true,aE,true,aN)if not dK then error(\"Usage: LibDeflate:CompressZlibWithDict\"..\"(str, dictionary, configs): \"..dL,2)end;return dy(ag,aE,aN)end;local function ab(dM,R)return Y(a1(dM,R*8),0xFF)end;function a:CompressGzip(ag,aN)local dK,dL=aK(ag,false,nil,true,aN)if not dK then error(\"Usage: LibDeflate:CompressGzip(str, configs): \"..dL,2)end;local dN,dO=dw(ag,nil,aN)if dN==nil then return dN,dO end;local V=os.time()local dP=0;local a9=self:CRC32(ag)local U=string.len(ag)if aN~=nil and aN.level~=nil then if aN.level==0 then dP=0x04 elseif aN.level==9 then dP=0x02 end end;return i(0x1f,0x8b,8,0,ab(V,0),ab(V,1),ab(V,2),ab(V,3),dP,0xFF)..dN..i(ab(a9,0),ab(a9,1),ab(a9,2),ab(a9,3),ab(U,0),ab(U,1),ab(U,2),ab(U,3))end;local function dQ(dR)local dS=dR;local dT=#dR;local dU=1;local aY=0;local aX=0;local function dV(T)local b2=o[T]local W;if T<=aY then W=aX%b2;aX=(aX-W)/b2;aY=aY-T else local dW=o[aY]local dH,dI,dJ,dX=h(dS,dU,dU+3)aX=aX+((dH or 0)+(dI or 0)*256+(dJ or 0)*65536+(dX or 0)*16777216)*dW;dU=dU+4;aY=aY+32-T;W=aX%b2;aX=(aX-W)/b2 end;return W end;local function dY(dZ,a_,aW)assert(aY%8==0)local d_=aY/8<dZ and aY/8 or dZ;for P=1,d_ do local ab=aX%256;aW=aW+1;a_[aW]=i(ab)aX=(aX-ab)/256 end;aY=aY-d_*8;dZ=dZ-d_;if(dT-dU-dZ+1)*8+aY<0 then return-1 end;for K=dU,dU+dZ-1 do aW=aW+1;a_[aW]=l(dS,K,K)end;dU=dU+dZ;return aW end;local function e0(e1,e2,ds)local W=0;local e3=0;local bH=0;local bA;if ds>0 then if aY<15 and dS then local dW=o[aY]local dH,dI,dJ,dX=h(dS,dU,dU+3)aX=aX+((dH or 0)+(dI or 0)*256+(dJ or 0)*65536+(dX or 0)*16777216)*dW;dU=dU+4;aY=aY+32 end;local b2=o[ds]aY=aY-ds;W=aX%b2;aX=(aX-W)/b2;W=q[ds][W]bA=e1[ds]if W<bA then return e2[W]end;bH=bA;e3=bA*2;W=W*2 end;for T=ds+1,15 do local e4;e4=aX%2;aX=(aX-e4)/2;aY=aY-1;W=e4==1 and W+1-W%2 or W;bA=e1[T]or 0;local e5=W-e3;if e5<bA then return e2[bH+e5]end;bH=bH+bA;e3=e3+bA;e3=e3*2;W=W*2 end;return-10 end;local function e6()return(dT-dU+1)*8+aY end;local function e7()local e8=aY%8;local b2=o[e8]aY=aY-e8;aX=(aX-aX%b2)/b2 end;return dV,dY,e0,e6,e7 end;local function e9(ag,aE)local dV,dY,e0,e6,e7=dQ(ag)local ea={ReadBits=dV,ReadBytes=dY,Decode=e0,ReaderBitlenLeft=e6,SkipToByteBoundary=e7,buffer_size=0,buffer={},result_buffer={},dictionary=aE}return ea end;local function eb(ec,bn,bo)local e1={}local ds=bo;for bs=0,bn do local T=ec[bs]or 0;ds=T>0 and T<ds and T or ds;e1[T]=(e1[T]or 0)+1 end;if e1[0]==bn+1 then return 0,e1,{},0 end;local ed=1;for U=1,bo do ed=ed*2;ed=ed-(e1[U]or 0)if ed<0 then return ed end end;local ee={}ee[1]=0;for U=1,bo-1 do ee[U+1]=ee[U]+(e1[U]or 0)end;local e2={}for bs=0,bn do local T=ec[bs]or 0;if T~=0 then local bZ=ee[T]e2[bZ]=bs;ee[T]=ee[T]+1 end end;return ed,e1,e2,ds end;local function ef(ea,cM,eg,eh,cO,ei,ej)local a_,aW,dV,e0,e6,b0=ea.buffer,ea.buffer_size,ea.ReadBits,ea.Decode,ea.ReaderBitlenLeft,ea.result_buffer;local aE=ea.dictionary;local cc;local dr;local ek=1;if aE and not a_[0]then cc=aE.string_table;dr=aE.strlen;ek=-dr+1;for K=0,-dr+1<-257 and-257 or-dr+1,-1 do a_[K]=p[cc[dr+K]]end end;repeat local bs=e0(cM,eg,eh)if bs<0 or bs>285 then return-10 elseif bs<256 then aW=aW+1;a_[aW]=p[bs]elseif bs>256 then bs=bs-256;local T=x[bs]T=bs>=8 and T+dV(y[bs])or T;bs=e0(cO,ei,ej)if bs<0 or bs>29 then return-10 end;local X=z[bs]X=X>4 and X+dV(A[bs])or X;local el=aW-X+1;if el<ek then return-11 end;if el>=-257 then for P=1,T do aW=aW+1;a_[aW]=a_[el]el=el+1 end else el=dr+el;for P=1,T do aW=aW+1;a_[aW]=p[cc[el]]el=el+1 end end end;if e6()<0 then return 2 end;if aW>=65536 then b0[#b0+1]=m(a_,\"\",1,32768)for K=32769,aW do a_[K-32768]=a_[K]end;aW=aW-32768;a_[aW+1]=nil end until bs==256;ea.buffer_size=aW;return 0 end;local function em(ea)local a_,aW,dV,dY,e6,e7,b0=ea.buffer,ea.buffer_size,ea.ReadBits,ea.ReadBytes,ea.ReaderBitlenLeft,ea.SkipToByteBoundary,ea.result_buffer;e7()local dZ=dV(16)if e6()<0 then return 2 end;local en=dV(16)if e6()<0 then return 2 end;if dZ%256+en%256~=255 then return-2 end;if(dZ-dZ%256)/256+(en-en%256)/256~=255 then return-2 end;aW=dY(dZ,a_,aW)if aW<0 then return 2 end;if aW>=65536 then b0[#b0+1]=m(a_,\"\",1,32768)for K=32769,aW do a_[K-32768]=a_[K]end;aW=aW-32768;a_[aW+1]=nil end;ea.buffer_size=aW;return 0 end;local function eo(ea)return ef(ea,F,D,7,J,H,5)end;local function ep(ea)local dV,e0=ea.ReadBits,ea.Decode;local eq=dV(5)+257;local er=dV(5)+1;local es=dV(4)+4;if eq>286 or er>30 then return-3 end;local cS={}for K=1,es do cS[B[K]]=dV(3)end;local et,eu,ev,ew=eb(cS,18,7)if et~=0 then return-4 end;local cM={}local cO={}local bH=0;while bH<eq+er do local bs;local T;bs=e0(eu,ev,ew)if bs<0 then return bs elseif bs<16 then if bH<eq then cM[bH]=bs else cO[bH-eq]=bs end;bH=bH+1 else T=0;if bs==16 then if bH==0 then return-5 end;if bH-1<eq then T=cM[bH-1]else T=cO[bH-eq-1]end;bs=3+dV(2)elseif bs==17 then bs=3+dV(3)else bs=11+dV(7)end;if bH+bs>eq+er then return-6 end;while bs>0 do bs=bs-1;if bH<eq then cM[bH]=T else cO[bH-eq]=T end;bH=bH+1 end end end;if(cM[256]or 0)==0 then return-9 end;local ex,ey,eg,eh=eb(cM,eq-1,15)if ex~=0 and(ex<0 or eq~=(ey[0]or 0)+(ey[1]or 0))then return-7 end;local ez,eA,ei,ej=eb(cO,er-1,15)if ez~=0 and(ez<0 or er~=(eA[0]or 0)+(eA[1]or 0))then return-8 end;return ef(ea,ey,eg,eh,eA,ei,ej)end;local function eB(ea)local dV=ea.ReadBits;local d4;while not d4 do d4=dV(1)==1;local eC=dV(2)local eD;if eC==0 then eD=em(ea)elseif eC==1 then eD=eo(ea)elseif eC==2 then eD=ep(ea)else return nil,-1 end;if eD~=0 then return nil,eD end end;ea.result_buffer[#ea.result_buffer+1]=m(ea.buffer,\"\",1,ea.buffer_size)local dx=m(ea.result_buffer)return dx end;local function eE(ag,aE)local ea=e9(ag,aE)local dx,eD=eB(ea)if not dx then return nil,eD end;local eF=ea.ReaderBitlenLeft()local eG=(eF-eF%8)/8;return dx,eG end;local function eH(ag,aE)local ea=e9(ag,aE)local dV=ea.ReadBits;local dB=dV(8)if ea.ReaderBitlenLeft()<0 then return nil,2 end;local dz=dB%16;local dA=(dB-dz)/16;if dz~=8 then return nil,-12 end;if dA>7 then return nil,-13 end;local dE=dV(8)if ea.ReaderBitlenLeft()<0 then return nil,2 end;if(dB*256+dE)%31~=0 then return nil,-14 end;local dC=(dE-dE%32)/32%2;local dD=(dE-dE%64)/64%4;if dC==1 then if not aE then return nil,-16 end;local dJ=dV(8)local dI=dV(8)local dH=dV(8)local dG=dV(8)local aD=dJ*16777216+dI*65536+dH*256+dG;if ea.ReaderBitlenLeft()<0 then return nil,2 end;if not az(aD,aE.adler32)then return nil,-17 end end;local dx,eD=eB(ea)if not dx then return nil,eD end;ea.SkipToByteBoundary()local eI=dV(8)local eJ=dV(8)local eK=dV(8)local eL=dV(8)if ea.ReaderBitlenLeft()<0 then return nil,2 end;local eM=eI*16777216+eJ*65536+eK*256+eL;local eN=a:Adler32(dx)if not az(eM,eN)then return nil,-15 end;local eF=ea.ReaderBitlenLeft()local eG=(eF-eF%8)/8;return dx,eG end;function a:DecompressDeflate(ag)local dK,dL=aK(ag)if not dK then error(\"Usage: LibDeflate:DecompressDeflate(str): \"..dL,2)end;return eE(ag)end;function a:DecompressDeflateWithDict(ag,aE)local dK,dL=aK(ag,true,aE)if not dK then error(\"Usage: LibDeflate:DecompressDeflateWithDict(str, dictionary): \"..dL,2)end;return eE(ag,aE)end;function a:DecompressZlib(ag)local dK,dL=aK(ag)if not dK then error(\"Usage: LibDeflate:DecompressZlib(str): \"..dL,2)end;return eH(ag)end;function a:DecompressZlibWithDict(ag,aE)local dK,dL=aK(ag,true,aE)if not dK then error(\"Usage: LibDeflate:DecompressZlibWithDict(str, dictionary): \"..dL,2)end;return eH(ag,aE)end;function a:DecompressGzip(ag)local dK,dL=aK(ag)if not dK then error(\"Usage: LibDeflate:DecompressGzip(str): \"..dL,2)end;if h(string.sub(ag,1,1))~=31 or h(string.sub(ag,2,2))~=139 then return nil,-1 end;if Y(h(string.sub(ag,4,4)),0xE0)~=0 then return nil,-3 end;if h(string.sub(ag,3,3))~=8 then return nil,-4 end;local bZ=10;if Y(h(string.sub(ag,4,4)),4)==4 then bZ=bZ+h(string.sub(ag,11,11))*256+h(string.sub(ag,12,12))end;if Y(h(string.sub(ag,4,4)),8)==8 then while h(string.sub(ag,bZ,bZ))~=0 do bZ=bZ+1 end end;if Y(h(string.sub(ag,4,4)),16)==16 then while h(string.sub(ag,bZ,bZ))~=0 do bZ=bZ+1 end end;if Y(h(string.sub(ag,4,4)),2)==2 then local eO=h(string.sub(ag,bZ+1,bZ+1))*256+h(string.sub(ag,bZ,bZ))local eP=Y(self:CRC32(string.sub(ag,1,bZ-1)),0xFFFF)if _(eO,eP)~=0xFFFF then return nil,-5 end;bZ=bZ+2 end;local dN,dO=eE(string.sub(ag,bZ+1,-8))if dN==nil then return dN,dO end;local eO=h(string.sub(ag,-5,-5))*0x1000000+h(string.sub(ag,-6,-6))*0x10000+h(string.sub(ag,-7,-7))*256+h(string.sub(ag,-8,-8))eO=Z(eO)local eP=self:CRC32(dN)if _(eO,eP)~=0xFFFFFFFF then return nil,-2 end;return dN end;do E={}for eQ=0,143 do E[eQ]=8 end;for eQ=144,255 do E[eQ]=9 end;for eQ=256,279 do E[eQ]=7 end;for eQ=280,287 do E[eQ]=8 end;I={}for X=0,31 do I[X]=5 end;local eD;eD,F,D=eb(E,287,9)assert(eD==0)eD,J,H=eb(I,31,5)assert(eD==0)C=bk(F,E,287,9)G=bk(J,I,31,5)end;a.internals={LoadStringToTable=bW,IsValidDictionary=aI,IsEqualAdler32=az,_byte_to_6bit_char=_byte_to_6bit_char,_6bit_to_byte=_6bit_to_byte,InternalClearCache=InternalClearCache}return a\n",setuser=false,size=27630,modified=1757997041133,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["asn1.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997039708,data="local a={}local function b(c)local d={tag=c:byte(),len=c:byte(2)}local e=2;assert(bit32.band(d.tag,0x1F)~=0x1F)if bit32.btest(d.len,0x80)then e=2+bit32.band(d.len,0x7F)if e<3 then error('Invalid long length encoding')end;d.len=0;for f,g in ipairs{c:byte(3,e)}do d.len=bit32.bor(bit32.lshift(d.len,8),g)end end;d.total_len=e+d.len;return d,c:sub(e+1,-1)end;local function h(i,j)local k=type(i)if k~=j then error('Invalid value ('..j..' expected, got '..k..')')end end;local function l(m,n,o)if not o then o={}end;local function p(c)return m(c,o)end;local function q(r)return n(r,o)end;return setmetatable({_decode=p,decode=function(c)local r=p(c)if r~=nil then return r end;if not o.optional then error('DER data does not conform to type definition')end end,encode=q,extend=function(s,t)return l(function(c)return s(p(c))end,function(r)return q(t(r))end,o)end,_params=o},{__call=function(j,u)if u then if u.tag and not u.class then u.class='context'end;setmetatable(u,{__index=o})else u=o end;return l(m,n,u)end})end;local function v(m,n)local function w(o)assert(o.tag<0x1F)local x=bit32.bor(({universal=0x00,context=0x80})[o.class],o.tag)if o.constructed then x=bit32.bor(x,0x20)end;return x end;local function y(r,z)return(not z.min or r>=z.min)and(not z.max or r<=z.max)end;local function A(r,o)return not o.size or y(#r,o.size)end;return l(function(c,o)local d,c=b(c)if#c~=d.len then error('Data length ('..#c..') does not match with the DER-encoded length ('..d.len..')')return end;if o.tag~=nil and d.tag~=w(o)then return end;local r=m(c,o)if A(r,o)and y(r,o)then return r end end,function(r,o)if o.value_type then h(r,o.value_type)end;if not A(r,o)then error('Value to be encoded is of invalid length ('..#r..')')end;if not y(r,o)then error('Value to be encoded is outside the allowed range ('..r..')')end;local c=n(r,o)local B=#c;local C={}if B<0x80 then C[1]=B else while B>0 do table.insert(C,1,bit32.band(B,0xFF))B=bit32.rshift(B,8)end;table.insert(C,1,bit32.bor(0x80,#C))end;return string.char(w(o),table.unpack(C))..c end)end;local function D(w)local function E(F)return F end;return v(E,E){class='universal',constructed=false,tag=w,value_type='string'}end;local function G(m,n)return v(m,n){class='universal',constructed=true,tag=0x10,value_type='table'}end;local function H(m,n)return v(m,n){class='universal',constructed=true,tag=0x11,value_type='table'}end;function a.choice(I)return l(function(c)for f,J in ipairs(I)do local r=J[2]._decode(c)if r then return{[J[1]]=r}end end end,function(r)local c;for f,J in ipairs(I)do local i=r[J[1]]if i then if c then error('Ambiguous choice definition')end;c=J[2].encode(i)end end;if c then return c end;error('Value to be encoded does not conform to any choice alternative')end)end;function a.optional(K)return l(function(c)return K._decode(c)end,function(r)if r~=nil then return K.encode(r)end;return\"\"end,{optional=true})end;function a.default(K,L)return l(function(c)local r=K._decode(c)if r==nil then r=L end;return r end,function(r)if r~=nil then return K.encode(r)end;return\"\"end,{optional=true})end;a.any=l(function(i)return i end,function(i)return i end)a.null=v(function()return nil end,function()return\"\"end){class='universal',constructed=false,tag=0x05,value_type='nil',optional=true}a.boolean=v(function(c)return string.byte(c)~=0x00 end,function(r)return string.char(r and 0xFF or 0x00)end){class='universal',constructed=false,tag=0x01,value_type='boolean'}local M={__eq=function(N,g)return N.data==g.data end}a.integer=v(function(c)if#c>6 then return setmetatable({type=\"INTEGER\",data=c},M)end;local r=string.byte(c)assert(bit32.band(r,0x80)==0x00)for f,g in ipairs{string.byte(c,2,-1)}do r=r*256+g end;return r end,function(r)if type(r)==\"table\"and r.type==\"INTEGER\"then return r.data end;h(r,\"number\")if r~=math.floor(r)then error('Not an integer: '..r)end;assert(r>-1)local O={}while r>0 do table.insert(O,1,r%256)r=math.floor(r/256)end;if#O==0 then O[1]=0 end;if bit32.band(O[1],0x80)==0x80 then table.insert(O,1,0)end;return string.char(table.unpack(O))end){class='universal',constructed=false,tag=0x02}a.bit_string=v(function(c,o)local P=c:byte()if P>7 then error('Invalid DER encoding for unused bits')end;if not o.enum then return{type=\"BIT STRING\",data=c:sub(2),unused=P}end;local r=''while#c>1 do c=c:sub(2,-1)local Q=c:byte()for R=7,#c==1 and P or 0,-1 do local S=bit32.lshift(R,1)r=r..(bit32.band(Q,S)==S and'1'or'0')end end;local T={}for R=1,#r do T[o.enum[R]]=r:sub(R,R)=='1'end;return T end,function(r,o)if o.enum then h(r,'table')local F=''for f,U in ipairs(o.enum)do F=F..(r[U]and'1'or'0')end;r=F;local O={}local P=0;while r>''do local Q=0;P=8;while r>''and P>0 do P=P-1;Q=bit32.bor(Q,bit32.lshift(tonumber(r:sub(1,1),2),P))r=r:sub(2,-1)end;table.insert(O,Q)end;table.insert(O,1,P)return string.char(table.unpack(O))else h(r,'table')return string.char(r.unused)..r.data end end){class='universal',constructed=false,tag=0x03}a.octet_string=D(0x04)a.ia5string=D(0x16)a.printable_string=D(0x13)a.teletex_string=D(0x15)a.bmp_string=D(0x1E)a.universal_string=D(0x1C)a.utf8string=v(function(c)local V=\"\"for f,W in utf8.codes(c)do if W<256 then V=V..string.char(W)else V=V..\"\\x1A\"end end;return V end,function(r)h(r,\"string\")return utf8.char(r:byte(1,-1))end){class='universal',constructed=false,tag=0x0C}a.oid=v(function(c,o)local X=c:byte()local Y={type=\"OBJECT IDENTIFIER\",math.floor(X/40),X%40}local Z=2;while Z<=#c do local W=c:byte(Z)Z=Z+1;X=bit32.band(W,0x7F)while bit32.btest(W,0x80)do W=c:byte(Z)Z=Z+1;X=bit32.lshift(X,7)+bit32.band(W,0x7F)end;Y[#Y+1]=X end;Y.string=table.concat(Y,\".\")return Y end,function(r,o)if type(r)==\"string\"then local j={}for X in r:gmatch\"%d+\"do j[#j+1]=tonumber(X)end;r=j end;h(r,\"table\")local V=string.char(r[1]*40+r[2])for R=3,#r do local X=r[R]if X>0x7F then local O={}while X>0x7F do table.insert(O,1,bit32.band(X,0x7F)+0x80)X=bit32.rshift(X,7)end;table.insert(O,1,X+0x80)O[#O]=bit32.band(O[#O],0x7F)V=V..string.char(table.unpack(O))else V=V..string.char(X)end end;return V end){class='universal',constructed=false,tag=0x06}a.utc_time=v(function(c,o)local _,a,a0,a1,T,F,a2=c:match(\"(%d%d)(%d%d)(%d%d)(%d%d)(%d%d)(%d?%d?)Z?([%+%-]?%d*)\")_,a,a0=tonumber(_),tonumber(a),tonumber(a0)a1,T,F=tonumber(a1),tonumber(T),tonumber(F)or 0;if#a2>0 then local a3=a2:sub(1,1)==\"+\"and 1 or-1;a2=tonumber(a2:sub(2))a2=(a2%100+math.floor(a2/100)*60)*a3 else a2=0 end;return{type=\"UTCTime\",year=_+(_>=50 and 1900 or 2000),month=a,day=a0,hour=a1,min=T,sec=F,offset=0}end,function(r,o)return(\"%02d%02d%02d%02d%02d%02dZ\"):format(r.year%100,r.month,r.day,r.hour,r.min,r.sec or 0)end){class='universal',constructed=false,tag=0x17}a.generalized_time=v(function(c,o)local _,a,a0,a1,T,F,a2=c:match(\"(%d%d%d%d)(%d%d)(%d%d)(%d%d)(%d%d)(%d?%d?)Z?([%+%-]?%d*)\")_,a,a0=tonumber(_),tonumber(a),tonumber(a0)a1,T,F=tonumber(a1),tonumber(T),tonumber(F)or 0;if#a2>0 then local a3=a2:sub(1,1)==\"+\"and 1 or-1;a2=tonumber(a2:sub(2))a2=(a2%100+math.floor(a2/100)*60)*a3 else a2=0 end;return{type=\"GeneralizedTime\",year=_,month=a,day=a0,hour=a1,min=T,sec=F,offset=a2}end,function(r,o)return(\"%04d%02d%02d%02d%02d%02dZ\"):format(r.year,r.month,r.day,r.hour,r.min,r.sec or 0,r.offset)end){class='universal',constructed=false,tag=0x18}function a.explicit(w,a4)return v(function(c)return a4.decode(c)end,function(r)return a4.encode(r)end){class='context',constructed=true,tag=w}end;function a.implicit(w,a4)return a4{class='context',tag=w}end;function a.sequence(a5)return G(function(c)local r={}for f,a6 in ipairs(a5)do if#c==0 then if not a6[2]._params.optional then error(\"Incomplete sequence\")end else local d=b(c)local i;if a6[2]==a.any then i=c:sub(1,d.total_len)else i=a6[2].decode(c:sub(1,d.total_len))end;r[a6[1]]=i;if i~=nil then c=c:sub(d.total_len+1,-1)end end end;if#c>0 then error('Excess data after a DER-encoded sequence')end;return r end,function(r)local c=''for f,a6 in ipairs(a5)do if a6[2]==a.any then c=c..r[a6[1]]else c=c..a6[2].encode(r[a6[1]])end end;return c end)end;function a.sequence_of(a5)return G(function(c)local r={}while#c>0 do local d=b(c)table.insert(r,a5.decode(c:sub(1,d.total_len)))c=c:sub(d.total_len+1,-1)end;return r end,function(r)local c=''for f,a6 in ipairs(r)do c=c..a5.encode(a6)end;return c end)end;function a.set(a5)return H(function(c)local r={}for f,a6 in ipairs(a5)do local d=b(c)local i;if a6[2]==a.any then i=c:sub(1,d.total_len)else i=a6[2].decode(c:sub(1,d.total_len))end;r[a6[1]]=i;if i~=nil then c=c:sub(d.total_len+1,-1)end end;if#c>0 then error('Excess data after a DER-encoded sequence')end;return r end,function(r)local c=''for f,a6 in ipairs(a5)do if a6[2]==a.any then c=c..r[a6[1]]else c=c..a6[2].encode(r[a6[1]])end end;return c end)end;function a.set_of(a5)return H(function(c)local r={}while#c>0 do local d=b(c)table.insert(r,a5.decode(c:sub(1,d.total_len)))c=c:sub(d.total_len+1,-1)end;return r end,function(r)local t={}for f,a6 in ipairs(r)do t[#t+1]=a5.encode(a6)end;table.sort(t)return table.concat(t)end)end;function a.class(a5)return G(function(c)local r={}do local d=b(c)r.type=a.oid.decode(c:sub(1,d.total_len))c=c:sub(d.total_len+1,-1)end;local K=a5[r.type.string]if K==nil then error(\"Unknown type for class\")end;for f,a6 in ipairs(K)do if#c==0 then if not a6[2]._params.optional then error(\"Incomplete sequence\")end else local d=b(c)if a6[2]==a.any then r[a6[1]]=c:sub(1,d.total_len)else r[a6[1]]=a6[2].decode(c:sub(1,d.total_len))end;c=c:sub(d.total_len+1,-1)end end;if c>''then error('Excess data after a DER-encoded sequence')end;return r end,function(r)local c=a.oid.encode(r.type)local V=type(r.type)==\"string\"and r.type or r.type.string;local K=a5[V]if K==nil then error(\"Unknown type for class\")end;for f,a6 in ipairs(K)do if a6[2]==a.any then c=c..r[a6[1]]else c=c..a6[2].encode(r[a6[1]])end end;return c end)end;return a\n",setuser=false,size=9783,modified=1757997039706,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["sha2.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997042489,data="local a=false;local unpack,b,c,d,e,f,g,h,i,j,k,l,m,tonumber,type,n=table.unpack or unpack,table.concat,string.byte,string.char,string.rep,string.sub,string.gsub,string.gmatch,string.format,math.floor,math.ceil,math.min,math.max,tonumber,type,math.huge;local function o(p)local q,r,s,t=0,p,p;while true do q,t,r,s=q+1,r,r+r+1,s+s+q%2;if q>256 or r-(r-1)~=1 or s-(s-1)~=1 or r==s then return q,false elseif r==t then return q,true end end end;local u=2/3;local v=u*5>3 and u*4<3 and o(1.0)>=53;assert(v,\"at least 53-bit floating point numbers are required\")local w,x=o(1)local y=x and w==64;local z=x and w==32;assert(y or z or not x,\"Lua integers must be either 32-bit or 64-bit\")local A=({false,[1]=true})[1]and _VERSION~=\"Luau\"and(type(jit)~=\"table\"or jit.version_num>=20000)local B;local C;local D;local E;local F;if A then E=require\"bit\"F=\"bit\"local G,H=pcall(require,\"ffi\")if G then D=H end;B=not not loadstring\"b=0b0\"C=type(jit)==\"table\"and jit.arch or D and D.arch or nil else for I,J in ipairs(_VERSION==\"Lua 5.2\"and{\"bit32\",\"bit\"}or{\"bit\",\"bit32\"})do if type(_G[J])==\"table\"and _G[J].bxor then E=_G[J]F=J;break end end end;if a then print(\"Abilities:\")print(\"   Lua version:               \"..(A and\"LuaJIT \"..(B and\"2.1 \"or\"2.0 \")..(C or\"\")..(D and\" with FFI\"or\" without FFI\")or _VERSION))print(\"   Integer bitwise operators: \"..(y and\"int64\"or z and\"int32\"or\"no\"))print(\"   32-bit bitwise library:    \"..(F or\"not found\"))end;local K,L;if A and D then K=\"Using 'ffi' library of LuaJIT\"L=\"FFI\"elseif A then K=\"Using special code for sandboxed LuaJIT (no FFI)\"L=\"LJ\"elseif F then K=\"Using '\"..F..\"' library\"L=\"LIB32\"else K=\"Emulating bitwise operators using look-up table\"L=\"EMUL\"end;if a then print(\"Implementation selected:\")print(\"   \"..K)end;local M,N,O,P,Q,R,S,T,U,V,W;if L==\"FFI\"or L==\"LJ\"or L==\"LIB32\"then M=E.band;N=E.bor;O=E.bxor;P=E.lshift;Q=E.rshift;R=E.rol or E.lrotate;S=E.ror or E.rrotate;T=E.bnot;U=E.tobit;V=E.tohex;assert(M and N and O and P and Q and R and S and T,\"Library '\"..F..\"' is incomplete\")W=O end;V=V or pcall(i,\"%x\",2^31)and function(u)return i(\"%08x\",u%4294967296)end or function(u)return i(\"%08x\",(u+2^31)%2^32-2^31)end;local function X(u,Y)return O(u,Y or 0xA5A5A5A5)%4294967296 end;local function Z()return{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}end;local _,a0,a1,a2,a3,a4,a5,a6;local a7,a8,a9,aa,ab,ac={},{},{},{},{},{}local ad={[224]={},[256]=aa}local ae,af={[384]={},[512]=a9},{[384]={},[512]=aa}local ag,ah={},{0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476,0xC3D2E1F0}local ai={0,0,0,0,0,0,0,0,28,25,26,27,0,0,10,9,11,12,0,15,16,17,18,0,20,22,23,21}local aj,ak;local al={}local am,an,ao=al,al,{}local ap,aq,ar=4294967296,0,0;local as={{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16},{15,11,5,9,10,16,14,7,2,13,1,3,12,8,6,4},{12,9,13,1,6,3,16,14,11,15,4,7,8,2,10,5},{8,10,4,2,14,13,12,15,3,7,6,11,5,1,16,9},{10,1,6,8,3,5,11,16,15,2,12,13,7,9,4,14},{3,13,7,11,1,12,9,4,5,14,8,6,16,15,2,10},{13,6,2,16,15,14,5,11,1,8,7,4,10,3,9,12},{14,12,8,15,13,2,4,10,6,1,16,5,9,7,3,11},{7,16,15,10,12,4,1,9,13,3,14,8,2,5,11,6},{11,3,9,5,8,7,2,6,16,12,10,15,4,13,14,1}}as[11],as[12]=as[1],as[2]local at={1,3,4,11,13,10,12,6,1,3,4,11,13,10,2,7,5,8,14,15,16,9,2,7,5,8,14,15}local function au(av)local aw={}for I,ax in ipairs{1,9,13,17,18,21}do aw[ax]=\"<\"..e(av,ax)end;return aw end;if L==\"FFI\"then local ay=D.new(\"int32_t[?]\",80)an=ay;ao=D.new(\"int32_t[?]\",16)at=D.new(\"uint8_t[?]\",#at+1,0,unpack(at))for az=1,10 do as[az]=D.new(\"uint8_t[?]\",#as[az]+1,0,unpack(as[az]))end;as[11],as[12]=as[1],as[2]function _(aA,aB,aC,ax)local aD,aE=ay,a8;for aF=aC,aC+ax-1,64 do for az=0,15 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aG,24),P(E,16),P(aH,8),aI)end;for az=16,63 do local aG,E=aD[az-15],aD[az-2]aD[az]=U(O(S(aG,7),R(aG,14),Q(aG,3))+O(R(E,15),R(E,13),Q(E,10))+aD[az-7]+aD[az-16])end;local aG,E,aH,aI,aJ,aK,aL,aM=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for az=0,63,8 do local aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az]+aE[az+1]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az+1]+aE[az+2]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az+2]+aE[az+3]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az+3]+aE[az+4]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az+4]+aE[az+5]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az+5]+aE[az+6]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az+6]+aE[az+7]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az+7]+aE[az+8]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)end;aA[1],aA[2],aA[3],aA[4]=U(aG+aA[1]),U(E+aA[2]),U(aH+aA[3]),U(aI+aA[4])aA[5],aA[6],aA[7],aA[8]=U(aJ+aA[5]),U(aK+aA[6]),U(aL+aA[7]),U(aM+aA[8])end end;local aO=D.new(\"int64_t[?]\",80)am=aO;local aP=D.typeof\"int64_t\"local aQ=D.typeof\"int32_t\"local aR=D.typeof\"uint32_t\"aq=aP(2^32)if B then local aS,aT,aU,aV,aW,aX,aY,aZ=M,N,O,T,P,Q,R,S;aj=V;do local a_=D.new(\"int64_t[?]\",16)local aD=am;local function b0(aG,E,aH,aI,b1,b2)local b3,b4,b5,b6=a_[aG],a_[E],a_[aH],a_[aI]b3=aD[b1]+b3+b4;b6=aZ(aU(b6,b3),32)b5=b5+b6;b4=aZ(aU(b4,b5),24)b3=aD[b2]+b3+b4;b6=aZ(aU(b6,b3),16)b5=b5+b6;b4=aY(aU(b4,b5),1)a_[aG],a_[E],a_[aH],a_[aI]=b3,b4,b5,b6 end;function a5(aA,I,aB,aC,ax,b7,b8,b9)local ba,bb,bc,bd,be,bf,bg,bh=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for aF=aC,aC+ax-1,128 do if aB then for az=1,16 do aF=aF+8;local aG,E,aH,aI,aJ,aK,aL,aM=c(aB,aF-7,aF)aD[az]=aU(N(P(aM,24),P(aL,16),P(aK,8),aJ)*aP(2^32),aR(aQ(N(P(aI,24),P(aH,16),P(E,8),aG))))end end;a_[0x0],a_[0x1],a_[0x2],a_[0x3],a_[0x4],a_[0x5],a_[0x6],a_[0x7]=ba,bb,bc,bd,be,bf,bg,bh;a_[0x8],a_[0x9],a_[0xA],a_[0xB],a_[0xD],a_[0xE],a_[0xF]=a9[1],a9[2],a9[3],a9[4],a9[6],a9[7],a9[8]b7=b7+(b8 or 128)a_[0xC]=aU(a9[5],b7)if b8 then a_[0xE]=aV(a_[0xE])end;if b9 then a_[0xF]=aV(a_[0xF])end;for az=1,12 do local bi=as[az]b0(0,4,8,12,bi[1],bi[2])b0(1,5,9,13,bi[3],bi[4])b0(2,6,10,14,bi[5],bi[6])b0(3,7,11,15,bi[7],bi[8])b0(0,5,10,15,bi[9],bi[10])b0(1,6,11,12,bi[11],bi[12])b0(2,7,8,13,bi[13],bi[14])b0(3,4,9,14,bi[15],bi[16])end;ba=aU(ba,a_[0x0],a_[0x8])bb=aU(bb,a_[0x1],a_[0x9])bc=aU(bc,a_[0x2],a_[0xA])bd=aU(bd,a_[0x3],a_[0xB])be=aU(be,a_[0x4],a_[0xC])bf=aU(bf,a_[0x5],a_[0xD])bg=aU(bg,a_[0x6],a_[0xE])bh=aU(bh,a_[0x7],a_[0xF])end;aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]=ba,bb,bc,bd,be,bf,bg,bh;return b7 end end;local bj=D.typeof\"int64_t[?]\"ak=0;ar=aP(2^32)function Z()return bj(30)end;function a3(bk,I,aB,aC,ax,bl)local bm=ab;local bn=Q(bl,3)for aF=aC,aC+ax-1,bl do for az=0,bn-1 do aF=aF+8;local aM,aL,aK,aJ,aI,aH,E,aG=c(aB,aF-7,aF)bk[az]=aU(bk[az],aT(N(P(aG,24),P(E,16),P(aH,8),aI)*aP(2^32),aR(aQ(N(P(aJ,24),P(aK,16),P(aL,8),aM)))))end;for bo=1,24 do for az=0,4 do bk[25+az]=aU(bk[az],bk[az+5],bk[az+10],bk[az+15],bk[az+20])end;local bp=aU(bk[25],aY(bk[27],1))bk[1],bk[6],bk[11],bk[16]=aY(aU(bp,bk[6]),44),aY(aU(bp,bk[16]),45),aY(aU(bp,bk[1]),1),aY(aU(bp,bk[11]),10)bk[21]=aY(aU(bp,bk[21]),2)bp=aU(bk[26],aY(bk[28],1))bk[2],bk[7],bk[12],bk[22]=aY(aU(bp,bk[12]),43),aY(aU(bp,bk[22]),61),aY(aU(bp,bk[7]),6),aY(aU(bp,bk[2]),62)bk[17]=aY(aU(bp,bk[17]),15)bp=aU(bk[27],aY(bk[29],1))bk[3],bk[8],bk[18],bk[23]=aY(aU(bp,bk[18]),21),aY(aU(bp,bk[3]),28),aY(aU(bp,bk[23]),56),aY(aU(bp,bk[8]),55)bk[13]=aY(aU(bp,bk[13]),25)bp=aU(bk[28],aY(bk[25],1))bk[4],bk[14],bk[19],bk[24]=aY(aU(bp,bk[24]),14),aY(aU(bp,bk[19]),8),aY(aU(bp,bk[4]),27),aY(aU(bp,bk[14]),39)bk[9]=aY(aU(bp,bk[9]),20)bp=aU(bk[29],aY(bk[26],1))bk[5],bk[10],bk[15],bk[20]=aY(aU(bp,bk[10]),3),aY(aU(bp,bk[20]),18),aY(aU(bp,bk[5]),36),aY(aU(bp,bk[15]),41)bk[0]=aU(bp,bk[0])bk[0],bk[1],bk[2],bk[3],bk[4]=aU(bk[0],aS(aV(bk[1]),bk[2]),bm[bo]),aU(bk[1],aS(aV(bk[2]),bk[3])),aU(bk[2],aS(aV(bk[3]),bk[4])),aU(bk[3],aS(aV(bk[4]),bk[0])),aU(bk[4],aS(aV(bk[0]),bk[1]))bk[5],bk[6],bk[7],bk[8],bk[9]=aU(bk[8],aS(aV(bk[9]),bk[5])),aU(bk[9],aS(aV(bk[5]),bk[6])),aU(bk[5],aS(aV(bk[6]),bk[7])),aU(bk[6],aS(aV(bk[7]),bk[8])),aU(bk[7],aS(aV(bk[8]),bk[9]))bk[10],bk[11],bk[12],bk[13],bk[14]=aU(bk[11],aS(aV(bk[12]),bk[13])),aU(bk[12],aS(aV(bk[13]),bk[14])),aU(bk[13],aS(aV(bk[14]),bk[10])),aU(bk[14],aS(aV(bk[10]),bk[11])),aU(bk[10],aS(aV(bk[11]),bk[12]))bk[15],bk[16],bk[17],bk[18],bk[19]=aU(bk[19],aS(aV(bk[15]),bk[16])),aU(bk[15],aS(aV(bk[16]),bk[17])),aU(bk[16],aS(aV(bk[17]),bk[18])),aU(bk[17],aS(aV(bk[18]),bk[19])),aU(bk[18],aS(aV(bk[19]),bk[15]))bk[20],bk[21],bk[22],bk[23],bk[24]=aU(bk[22],aS(aV(bk[23]),bk[24])),aU(bk[23],aS(aV(bk[24]),bk[20])),aU(bk[24],aS(aV(bk[20]),bk[21])),aU(bk[20],aS(aV(bk[21]),bk[22])),aU(bk[21],aS(aV(bk[22]),bk[23]))end end end;local bq=0xA5A5A5A5*aP(2^32+1)function X(br,bs)return aU(br,bs or bq)end;function a0(aA,I,aB,aC,ax)local aD,aE=aO,a7;for aF=aC,aC+ax-1,128 do for az=0,15 do aF=aF+8;local aG,E,aH,aI,aJ,aK,aL,aM=c(aB,aF-7,aF)aD[az]=aT(N(P(aG,24),P(E,16),P(aH,8),aI)*aP(2^32),aR(aQ(N(P(aJ,24),P(aK,16),P(aL,8),aM))))end;for az=16,79 do local aG,E=aD[az-15],aD[az-2]aD[az]=aU(aZ(aG,1),aZ(aG,8),aX(aG,7))+aU(aZ(E,19),aY(E,3),aX(E,6))+aD[az-7]+aD[az-16]end;local aG,E,aH,aI,aJ,aK,aL,aM=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for az=0,79,8 do local aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+1]+aD[az]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN;aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+2]+aD[az+1]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN;aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+3]+aD[az+2]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN;aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+4]+aD[az+3]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN;aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+5]+aD[az+4]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN;aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+6]+aD[az+5]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN;aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+7]+aD[az+6]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN;aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+8]+aD[az+7]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN end;aA[1]=aG+aA[1]aA[2]=E+aA[2]aA[3]=aH+aA[3]aA[4]=aI+aA[4]aA[5]=aJ+aA[5]aA[6]=aK+aA[6]aA[7]=aL+aA[7]aA[8]=aM+aA[8]end end else local bt=D.new(\"union{int64_t i64; struct{int32_t \"..(D.abi(\"le\")and\"lo, hi\"or\"hi, lo\")..\";} i32;}[3]\")local function bu(aG)bt[0].i64=aG;local bv,bw=bt[0].i32.lo,bt[0].i32.hi;local bx=O(Q(bv,1),P(bw,31),Q(bv,8),P(bw,24),Q(bv,7),P(bw,25))local by=O(Q(bw,1),P(bv,31),Q(bw,8),P(bv,24),Q(bw,7))return by*aP(2^32)+aR(aQ(bx))end;local function bz(E)bt[0].i64=E;local bA,bB=bt[0].i32.lo,bt[0].i32.hi;local bC=O(Q(bA,19),P(bB,13),P(bA,3),Q(bB,29),Q(bA,6),P(bB,26))local bD=O(Q(bB,19),P(bA,13),P(bB,3),Q(bA,29),Q(bB,6))return bD*aP(2^32)+aR(aQ(bC))end;local function bE(aJ)bt[0].i64=aJ;local bF,bG=bt[0].i32.lo,bt[0].i32.hi;local bC=O(Q(bF,14),P(bG,18),Q(bF,18),P(bG,14),P(bF,23),Q(bG,9))local bD=O(Q(bG,14),P(bF,18),Q(bG,18),P(bF,14),P(bG,23),Q(bF,9))return bD*aP(2^32)+aR(aQ(bC))end;local function bH(aG)bt[0].i64=aG;local bA,bB=bt[0].i32.lo,bt[0].i32.hi;local bC=O(Q(bA,28),P(bB,4),P(bA,30),Q(bB,2),P(bA,25),Q(bB,7))local bD=O(Q(bB,28),P(bA,4),P(bB,30),Q(bA,2),P(bB,25),Q(bA,7))return bD*aP(2^32)+aR(aQ(bC))end;local function bI(aJ,aK,aL)bt[0].i64=aK;bt[1].i64=aL;bt[2].i64=aJ;local bJ,bK=bt[0].i32.lo,bt[0].i32.hi;local bL,bM=bt[1].i32.lo,bt[1].i32.hi;local bF,bG=bt[2].i32.lo,bt[2].i32.hi;local bN=O(bL,M(bF,O(bJ,bL)))local bO=O(bM,M(bG,O(bK,bM)))return bO*aP(2^32)+aR(aQ(bN))end;local function bP(aG,E,aH)bt[0].i64=aG;bt[1].i64=E;bt[2].i64=aH;local bv,bw=bt[0].i32.lo,bt[0].i32.hi;local bA,bB=bt[1].i32.lo,bt[1].i32.hi;local bQ,bR=bt[2].i32.lo,bt[2].i32.hi;local bN=O(M(O(bv,bA),bQ),M(bv,bA))local bO=O(M(O(bw,bB),bR),M(bw,bB))return bO*aP(2^32)+aR(aQ(bN))end;local function bS(aG,E,s)bt[0].i64=aG;bt[1].i64=E;local bv,bw=bt[0].i32.lo,bt[0].i32.hi;local bA,bB=bt[1].i32.lo,bt[1].i32.hi;local bQ,bR=O(bv,bA),O(bw,bB)local bx=O(Q(bQ,s),P(bR,-s))local by=O(Q(bR,s),P(bQ,-s))return by*aP(2^32)+aR(aQ(bx))end;local function bT(aG,E)bt[0].i64=aG;bt[1].i64=E;local bv,bw=bt[0].i32.lo,bt[0].i32.hi;local bA,bB=bt[1].i32.lo,bt[1].i32.hi;local bQ,bR=O(bv,bA),O(bw,bB)local bx=O(P(bQ,1),Q(bR,31))local by=O(P(bR,1),Q(bQ,31))return by*aP(2^32)+aR(aQ(bx))end;local function bU(aG,E)bt[0].i64=aG;bt[1].i64=E;local bv,bw=bt[0].i32.lo,bt[0].i32.hi;local bA,bB=bt[1].i32.lo,bt[1].i32.hi;local by,bx=O(bv,bA),O(bw,bB)return by*aP(2^32)+aR(aQ(bx))end;local function aU(aG,E)bt[0].i64=aG;bt[1].i64=E;local bv,bw=bt[0].i32.lo,bt[0].i32.hi;local bA,bB=bt[1].i32.lo,bt[1].i32.hi;local bx,by=O(bv,bA),O(bw,bB)return by*aP(2^32)+aR(aQ(bx))end;local function bV(aG,E,aH)bt[0].i64=aG;bt[1].i64=E;bt[2].i64=aH;local bv,bw=bt[0].i32.lo,bt[0].i32.hi;local bA,bB=bt[1].i32.lo,bt[1].i32.hi;local bQ,bR=bt[2].i32.lo,bt[2].i32.hi;local bx,by=O(bv,bA,bQ),O(bw,bB,bR)return by*aP(2^32)+aR(aQ(bx))end;function X(br,bs)bt[0].i64=br;local bW,bX=bt[0].i32.lo,bt[0].i32.hi;local bY,bZ=0xA5A5A5A5,0xA5A5A5A5;if bs then bt[1].i64=bs;bY,bZ=bt[1].i32.lo,bt[1].i32.hi end;bW=O(bW,bY)bX=O(bX,bZ)return bX*aP(2^32)+aR(aQ(bW))end;function aj(br)bt[0].i64=br;return V(bt[0].i32.hi)..V(bt[0].i32.lo)end;function a0(aA,I,aB,aC,ax)local aD,aE=aO,a7;for aF=aC,aC+ax-1,128 do for az=0,15 do aF=aF+8;local aG,E,aH,aI,aJ,aK,aL,aM=c(aB,aF-7,aF)aD[az]=N(P(aG,24),P(E,16),P(aH,8),aI)*aP(2^32)+aR(aQ(N(P(aJ,24),P(aK,16),P(aL,8),aM)))end;for az=16,79 do aD[az]=bu(aD[az-15])+bz(aD[az-2])+aD[az-7]+aD[az-16]end;local aG,E,aH,aI,aJ,aK,aL,aM=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for az=0,79,8 do local aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+1]+aD[az]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN;aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+2]+aD[az+1]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN;aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+3]+aD[az+2]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN;aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+4]+aD[az+3]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN;aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+5]+aD[az+4]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN;aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+6]+aD[az+5]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN;aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+7]+aD[az+6]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN;aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+8]+aD[az+7]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN end;aA[1]=aG+aA[1]aA[2]=E+aA[2]aA[3]=aH+aA[3]aA[4]=aI+aA[4]aA[5]=aJ+aA[5]aA[6]=aK+aA[6]aA[7]=aL+aA[7]aA[8]=aM+aA[8]end end;do local a_=D.new(\"int64_t[?]\",16)local aD=am;local function b0(aG,E,aH,aI,b1,b2)local b3,b4,b5,b6=a_[aG],a_[E],a_[aH],a_[aI]b3=aD[b1]+b3+b4;b6=bU(b6,b3)b5=b5+b6;b4=bS(b4,b5,24)b3=aD[b2]+b3+b4;b6=bS(b6,b3,16)b5=b5+b6;b4=bT(b4,b5)a_[aG],a_[E],a_[aH],a_[aI]=b3,b4,b5,b6 end;function a5(aA,I,aB,aC,ax,b7,b8,b9)local ba,bb,bc,bd,be,bf,bg,bh=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for aF=aC,aC+ax-1,128 do if aB then for az=1,16 do aF=aF+8;local aG,E,aH,aI,aJ,aK,aL,aM=c(aB,aF-7,aF)aD[az]=aU(N(P(aM,24),P(aL,16),P(aK,8),aJ)*aP(2^32),aR(aQ(N(P(aI,24),P(aH,16),P(E,8),aG))))end end;a_[0x0],a_[0x1],a_[0x2],a_[0x3],a_[0x4],a_[0x5],a_[0x6],a_[0x7]=ba,bb,bc,bd,be,bf,bg,bh;a_[0x8],a_[0x9],a_[0xA],a_[0xB],a_[0xD],a_[0xE],a_[0xF]=a9[1],a9[2],a9[3],a9[4],a9[6],a9[7],a9[8]b7=b7+(b8 or 128)a_[0xC]=aU(a9[5],b7)if b8 then a_[0xE]=-1-a_[0xE]end;if b9 then a_[0xF]=-1-a_[0xF]end;for az=1,12 do local bi=as[az]b0(0,4,8,12,bi[1],bi[2])b0(1,5,9,13,bi[3],bi[4])b0(2,6,10,14,bi[5],bi[6])b0(3,7,11,15,bi[7],bi[8])b0(0,5,10,15,bi[9],bi[10])b0(1,6,11,12,bi[11],bi[12])b0(2,7,8,13,bi[13],bi[14])b0(3,4,9,14,bi[15],bi[16])end;ba=bV(ba,a_[0x0],a_[0x8])bb=bV(bb,a_[0x1],a_[0x9])bc=bV(bc,a_[0x2],a_[0xA])bd=bV(bd,a_[0x3],a_[0xB])be=bV(be,a_[0x4],a_[0xC])bf=bV(bf,a_[0x5],a_[0xD])bg=bV(bg,a_[0x6],a_[0xE])bh=bV(bh,a_[0x7],a_[0xF])end;aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]=ba,bb,bc,bd,be,bf,bg,bh;return b7 end end end;function a1(aA,aB,aC,ax)local aD,aE=ay,ag;for aF=aC,aC+ax-1,64 do for az=0,15 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aI,24),P(aH,16),P(E,8),aG)end;local aG,E,aH,aI=aA[1],aA[2],aA[3],aA[4]for az=0,15,4 do aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az+1]+aD[az]+aG,7)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az+2]+aD[az+1]+aG,12)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az+3]+aD[az+2]+aG,17)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az+4]+aD[az+3]+aG,22)+E)end;for az=16,31,4 do local aL=5*az;aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az+1]+aD[M(aL+1,15)]+aG,5)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az+2]+aD[M(aL+6,15)]+aG,9)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az+3]+aD[M(aL-5,15)]+aG,14)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az+4]+aD[M(aL,15)]+aG,20)+E)end;for az=32,47,4 do local aL=3*az;aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az+1]+aD[M(aL+5,15)]+aG,4)+E)aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az+2]+aD[M(aL+8,15)]+aG,11)+E)aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az+3]+aD[M(aL-5,15)]+aG,16)+E)aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az+4]+aD[M(aL-2,15)]+aG,23)+E)end;for az=48,63,4 do local aL=7*az;aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az+1]+aD[M(aL,15)]+aG,6)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az+2]+aD[M(aL+7,15)]+aG,10)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az+3]+aD[M(aL-2,15)]+aG,15)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az+4]+aD[M(aL+5,15)]+aG,21)+E)end;aA[1],aA[2],aA[3],aA[4]=U(aG+aA[1]),U(E+aA[2]),U(aH+aA[3]),U(aI+aA[4])end end;function a2(aA,aB,aC,ax)local aD=ay;for aF=aC,aC+ax-1,64 do for az=0,15 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aG,24),P(E,16),P(aH,8),aI)end;for az=16,79 do aD[az]=R(O(aD[az-3],aD[az-8],aD[az-14],aD[az-16]),1)end;local aG,E,aH,aI,aJ=aA[1],aA[2],aA[3],aA[4],aA[5]for az=0,19,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+1]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+2]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+3]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+4]+0x5A827999+aJ)end;for az=20,39,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+1]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+2]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+3]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+4]+0x6ED9EBA1+aJ)end;for az=40,59,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+1]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+2]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+3]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+4]+0x8F1BBCDC+aJ)end;for az=60,79,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+1]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+2]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+3]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+4]+0xCA62C1D6+aJ)end;aA[1],aA[2],aA[3],aA[4],aA[5]=U(aG+aA[1]),U(E+aA[2]),U(aH+aA[3]),U(aI+aA[4]),U(aJ+aA[5])end end end;if L==\"FFI\"and not B or L==\"LJ\"then if L==\"FFI\"then local b_=D.typeof\"int32_t[?]\"function Z()return b_(31)end end;function a3(c0,c1,aB,aC,ax,bl)local c2,c3=ab,ac;local bn=Q(bl,3)for aF=aC,aC+ax-1,bl do for az=1,bn do local aG,E,aH,aI=c(aB,aF+1,aF+4)c0[az]=O(c0[az],N(P(aI,24),P(aH,16),P(E,8),aG))aF=aF+8;aG,E,aH,aI=c(aB,aF-3,aF)c1[az]=O(c1[az],N(P(aI,24),P(aH,16),P(E,8),aG))end;for bo=1,24 do for az=1,5 do c0[25+az]=O(c0[az],c0[az+5],c0[az+10],c0[az+15],c0[az+20])end;for az=1,5 do c1[25+az]=O(c1[az],c1[az+5],c1[az+10],c1[az+15],c1[az+20])end;local c4=O(c0[26],P(c0[28],1),Q(c1[28],31))local c5=O(c1[26],P(c1[28],1),Q(c0[28],31))c0[2],c1[2],c0[7],c1[7],c0[12],c1[12],c0[17],c1[17]=O(Q(O(c4,c0[7]),20),P(O(c5,c1[7]),12)),O(Q(O(c5,c1[7]),20),P(O(c4,c0[7]),12)),O(Q(O(c4,c0[17]),19),P(O(c5,c1[17]),13)),O(Q(O(c5,c1[17]),19),P(O(c4,c0[17]),13)),O(P(O(c4,c0[2]),1),Q(O(c5,c1[2]),31)),O(P(O(c5,c1[2]),1),Q(O(c4,c0[2]),31)),O(P(O(c4,c0[12]),10),Q(O(c5,c1[12]),22)),O(P(O(c5,c1[12]),10),Q(O(c4,c0[12]),22))local c6,aA=O(c4,c0[22]),O(c5,c1[22])c0[22],c1[22]=O(P(c6,2),Q(aA,30)),O(P(aA,2),Q(c6,30))c4=O(c0[27],P(c0[29],1),Q(c1[29],31))c5=O(c1[27],P(c1[29],1),Q(c0[29],31))c0[3],c1[3],c0[8],c1[8],c0[13],c1[13],c0[23],c1[23]=O(Q(O(c4,c0[13]),21),P(O(c5,c1[13]),11)),O(Q(O(c5,c1[13]),21),P(O(c4,c0[13]),11)),O(Q(O(c4,c0[23]),3),P(O(c5,c1[23]),29)),O(Q(O(c5,c1[23]),3),P(O(c4,c0[23]),29)),O(P(O(c4,c0[8]),6),Q(O(c5,c1[8]),26)),O(P(O(c5,c1[8]),6),Q(O(c4,c0[8]),26)),O(Q(O(c4,c0[3]),2),P(O(c5,c1[3]),30)),O(Q(O(c5,c1[3]),2),P(O(c4,c0[3]),30))c6,aA=O(c4,c0[18]),O(c5,c1[18])c0[18],c1[18]=O(P(c6,15),Q(aA,17)),O(P(aA,15),Q(c6,17))c4=O(c0[28],P(c0[30],1),Q(c1[30],31))c5=O(c1[28],P(c1[30],1),Q(c0[30],31))c0[4],c1[4],c0[9],c1[9],c0[19],c1[19],c0[24],c1[24]=O(P(O(c4,c0[19]),21),Q(O(c5,c1[19]),11)),O(P(O(c5,c1[19]),21),Q(O(c4,c0[19]),11)),O(P(O(c4,c0[4]),28),Q(O(c5,c1[4]),4)),O(P(O(c5,c1[4]),28),Q(O(c4,c0[4]),4)),O(Q(O(c4,c0[24]),8),P(O(c5,c1[24]),24)),O(Q(O(c5,c1[24]),8),P(O(c4,c0[24]),24)),O(Q(O(c4,c0[9]),9),P(O(c5,c1[9]),23)),O(Q(O(c5,c1[9]),9),P(O(c4,c0[9]),23))c6,aA=O(c4,c0[14]),O(c5,c1[14])c0[14],c1[14]=O(P(c6,25),Q(aA,7)),O(P(aA,25),Q(c6,7))c4=O(c0[29],P(c0[26],1),Q(c1[26],31))c5=O(c1[29],P(c1[26],1),Q(c0[26],31))c0[5],c1[5],c0[15],c1[15],c0[20],c1[20],c0[25],c1[25]=O(P(O(c4,c0[25]),14),Q(O(c5,c1[25]),18)),O(P(O(c5,c1[25]),14),Q(O(c4,c0[25]),18)),O(P(O(c4,c0[20]),8),Q(O(c5,c1[20]),24)),O(P(O(c5,c1[20]),8),Q(O(c4,c0[20]),24)),O(P(O(c4,c0[5]),27),Q(O(c5,c1[5]),5)),O(P(O(c5,c1[5]),27),Q(O(c4,c0[5]),5)),O(Q(O(c4,c0[15]),25),P(O(c5,c1[15]),7)),O(Q(O(c5,c1[15]),25),P(O(c4,c0[15]),7))c6,aA=O(c4,c0[10]),O(c5,c1[10])c0[10],c1[10]=O(P(c6,20),Q(aA,12)),O(P(aA,20),Q(c6,12))c4=O(c0[30],P(c0[27],1),Q(c1[27],31))c5=O(c1[30],P(c1[27],1),Q(c0[27],31))c0[6],c1[6],c0[11],c1[11],c0[16],c1[16],c0[21],c1[21]=O(P(O(c4,c0[11]),3),Q(O(c5,c1[11]),29)),O(P(O(c5,c1[11]),3),Q(O(c4,c0[11]),29)),O(P(O(c4,c0[21]),18),Q(O(c5,c1[21]),14)),O(P(O(c5,c1[21]),18),Q(O(c4,c0[21]),14)),O(Q(O(c4,c0[6]),28),P(O(c5,c1[6]),4)),O(Q(O(c5,c1[6]),28),P(O(c4,c0[6]),4)),O(Q(O(c4,c0[16]),23),P(O(c5,c1[16]),9)),O(Q(O(c5,c1[16]),23),P(O(c4,c0[16]),9))c0[1],c1[1]=O(c4,c0[1]),O(c5,c1[1])c0[1],c0[2],c0[3],c0[4],c0[5]=O(c0[1],M(T(c0[2]),c0[3]),c2[bo]),O(c0[2],M(T(c0[3]),c0[4])),O(c0[3],M(T(c0[4]),c0[5])),O(c0[4],M(T(c0[5]),c0[1])),O(c0[5],M(T(c0[1]),c0[2]))c0[6],c0[7],c0[8],c0[9],c0[10]=O(c0[9],M(T(c0[10]),c0[6])),O(c0[10],M(T(c0[6]),c0[7])),O(c0[6],M(T(c0[7]),c0[8])),O(c0[7],M(T(c0[8]),c0[9])),O(c0[8],M(T(c0[9]),c0[10]))c0[11],c0[12],c0[13],c0[14],c0[15]=O(c0[12],M(T(c0[13]),c0[14])),O(c0[13],M(T(c0[14]),c0[15])),O(c0[14],M(T(c0[15]),c0[11])),O(c0[15],M(T(c0[11]),c0[12])),O(c0[11],M(T(c0[12]),c0[13]))c0[16],c0[17],c0[18],c0[19],c0[20]=O(c0[20],M(T(c0[16]),c0[17])),O(c0[16],M(T(c0[17]),c0[18])),O(c0[17],M(T(c0[18]),c0[19])),O(c0[18],M(T(c0[19]),c0[20])),O(c0[19],M(T(c0[20]),c0[16]))c0[21],c0[22],c0[23],c0[24],c0[25]=O(c0[23],M(T(c0[24]),c0[25])),O(c0[24],M(T(c0[25]),c0[21])),O(c0[25],M(T(c0[21]),c0[22])),O(c0[21],M(T(c0[22]),c0[23])),O(c0[22],M(T(c0[23]),c0[24]))c1[1],c1[2],c1[3],c1[4],c1[5]=O(c1[1],M(T(c1[2]),c1[3]),c3[bo]),O(c1[2],M(T(c1[3]),c1[4])),O(c1[3],M(T(c1[4]),c1[5])),O(c1[4],M(T(c1[5]),c1[1])),O(c1[5],M(T(c1[1]),c1[2]))c1[6],c1[7],c1[8],c1[9],c1[10]=O(c1[9],M(T(c1[10]),c1[6])),O(c1[10],M(T(c1[6]),c1[7])),O(c1[6],M(T(c1[7]),c1[8])),O(c1[7],M(T(c1[8]),c1[9])),O(c1[8],M(T(c1[9]),c1[10]))c1[11],c1[12],c1[13],c1[14],c1[15]=O(c1[12],M(T(c1[13]),c1[14])),O(c1[13],M(T(c1[14]),c1[15])),O(c1[14],M(T(c1[15]),c1[11])),O(c1[15],M(T(c1[11]),c1[12])),O(c1[11],M(T(c1[12]),c1[13]))c1[16],c1[17],c1[18],c1[19],c1[20]=O(c1[20],M(T(c1[16]),c1[17])),O(c1[16],M(T(c1[17]),c1[18])),O(c1[17],M(T(c1[18]),c1[19])),O(c1[18],M(T(c1[19]),c1[20])),O(c1[19],M(T(c1[20]),c1[16]))c1[21],c1[22],c1[23],c1[24],c1[25]=O(c1[23],M(T(c1[24]),c1[25])),O(c1[24],M(T(c1[25]),c1[21])),O(c1[25],M(T(c1[21]),c1[22])),O(c1[21],M(T(c1[22]),c1[23])),O(c1[22],M(T(c1[23]),c1[24]))end end end end;if L==\"LJ\"then function _(aA,aB,aC,ax)local aD,aE=al,a8;for aF=aC,aC+ax-1,64 do for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aG,24),P(E,16),P(aH,8),aI)end;for az=17,64 do local aG,E=aD[az-15],aD[az-2]aD[az]=U(U(O(S(aG,7),R(aG,14),Q(aG,3))+O(R(E,15),R(E,13),Q(E,10)))+U(aD[az-7]+aD[az-16]))end;local aG,E,aH,aI,aJ,aK,aL,aM=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for az=1,64,8 do local aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az]+aD[az]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az+1]+aD[az+1]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az+2]+aD[az+2]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az+3]+aD[az+3]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az+4]+aD[az+4]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az+5]+aD[az+5]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az+6]+aD[az+6]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az+7]+aD[az+7]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)end;aA[1],aA[2],aA[3],aA[4]=U(aG+aA[1]),U(E+aA[2]),U(aH+aA[3]),U(aI+aA[4])aA[5],aA[6],aA[7],aA[8]=U(aJ+aA[5]),U(aK+aA[6]),U(aL+aA[7]),U(aM+aA[8])end end;local function c7(bv,bw,bA,bB,bQ,bR,c8,c9)local ca=bv%2^32+bA%2^32+bQ%2^32+c8%2^32;local cb=bw+bB+bR+c9;local bN=U(ca)local bO=U(cb+j(ca/2^32))return bN,bO end;if C==\"x86\"then function a0(cc,cd,aB,aC,ax)local aD,ce,cf=al,a7,a8;for aF=aC,aC+ax-1,128 do for az=1,16*2 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aG,24),P(E,16),P(aH,8),aI)end;for cg=17*2,80*2,2 do local bv,bw=aD[cg-30],aD[cg-31]local bx=O(N(Q(bv,1),P(bw,31)),N(Q(bv,8),P(bw,24)),N(Q(bv,7),P(bw,25)))local by=O(N(Q(bw,1),P(bv,31)),N(Q(bw,8),P(bv,24)),Q(bw,7))local bA,bB=aD[cg-4],aD[cg-5]local bC=O(N(Q(bA,19),P(bB,13)),N(P(bA,3),Q(bB,29)),N(Q(bA,6),P(bB,26)))local bD=O(N(Q(bB,19),P(bA,13)),N(P(bB,3),Q(bA,29)),Q(bB,6))aD[cg],aD[cg-1]=c7(bx,by,bC,bD,aD[cg-14],aD[cg-15],aD[cg-32],aD[cg-33])end;local bv,bA,bQ,c8,bF,bJ,bL,ch=cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]local bw,bB,bR,c9,bG,bK,bM,ci=cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]local cj=0;for az=1,80 do local bx=O(bL,M(bF,O(bJ,bL)))local by=O(bM,M(bG,O(bK,bM)))local bC=O(N(Q(bF,14),P(bG,18)),N(Q(bF,18),P(bG,14)),N(P(bF,23),Q(bG,9)))local bD=O(N(Q(bG,14),P(bF,18)),N(Q(bG,18),P(bF,14)),N(P(bG,23),Q(bF,9)))local ca=bC%2^32+bx%2^32+ch%2^32+ce[az]+aD[2*az]%2^32;local ck,cl=U(ca),U(bD+by+ci+cf[az]+aD[2*az-1]+j(ca/2^32))cj=cj+cj;ch,ci,bL,bM,bJ,bK=N(cj,bL),N(cj,bM),N(cj,bJ),N(cj,bK),N(cj,bF),N(cj,bG)local ca=ck%2^32+c8%2^32;bF,bG=U(ca),U(cl+c9+j(ca/2^32))c8,c9,bQ,bR,bA,bB=N(cj,bQ),N(cj,bR),N(cj,bA),N(cj,bB),N(cj,bv),N(cj,bw)bC=O(N(Q(bA,28),P(bB,4)),N(P(bA,30),Q(bB,2)),N(P(bA,25),Q(bB,7)))bD=O(N(Q(bB,28),P(bA,4)),N(P(bB,30),Q(bA,2)),N(P(bB,25),Q(bA,7)))bx=N(M(c8,bQ),M(bA,O(c8,bQ)))by=N(M(c9,bR),M(bB,O(c9,bR)))local ca=ck%2^32+bx%2^32+bC%2^32;bv,bw=U(ca),U(cl+by+bD+j(ca/2^32))end;cc[1],cd[1]=c7(cc[1],cd[1],bv,bw,0,0,0,0)cc[2],cd[2]=c7(cc[2],cd[2],bA,bB,0,0,0,0)cc[3],cd[3]=c7(cc[3],cd[3],bQ,bR,0,0,0,0)cc[4],cd[4]=c7(cc[4],cd[4],c8,c9,0,0,0,0)cc[5],cd[5]=c7(cc[5],cd[5],bF,bG,0,0,0,0)cc[6],cd[6]=c7(cc[6],cd[6],bJ,bK,0,0,0,0)cc[7],cd[7]=c7(cc[7],cd[7],bL,bM,0,0,0,0)cc[8],cd[8]=c7(cc[8],cd[8],ch,ci,0,0,0,0)end end else function a0(cc,cd,aB,aC,ax)local aD,ce,cf=al,a7,a8;for aF=aC,aC+ax-1,128 do for az=1,16*2 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aG,24),P(E,16),P(aH,8),aI)end;for cg=17*2,80*2,2 do local bv,bw=aD[cg-30],aD[cg-31]local bx=O(N(Q(bv,1),P(bw,31)),N(Q(bv,8),P(bw,24)),N(Q(bv,7),P(bw,25)))local by=O(N(Q(bw,1),P(bv,31)),N(Q(bw,8),P(bv,24)),Q(bw,7))local bA,bB=aD[cg-4],aD[cg-5]local bC=O(N(Q(bA,19),P(bB,13)),N(P(bA,3),Q(bB,29)),N(Q(bA,6),P(bB,26)))local bD=O(N(Q(bB,19),P(bA,13)),N(P(bB,3),Q(bA,29)),Q(bB,6))aD[cg],aD[cg-1]=c7(bx,by,bC,bD,aD[cg-14],aD[cg-15],aD[cg-32],aD[cg-33])end;local bv,bA,bQ,c8,bF,bJ,bL,ch=cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]local bw,bB,bR,c9,bG,bK,bM,ci=cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]for az=1,80 do local bx=O(bL,M(bF,O(bJ,bL)))local by=O(bM,M(bG,O(bK,bM)))local bC=O(N(Q(bF,14),P(bG,18)),N(Q(bF,18),P(bG,14)),N(P(bF,23),Q(bG,9)))local bD=O(N(Q(bG,14),P(bF,18)),N(Q(bG,18),P(bF,14)),N(P(bG,23),Q(bF,9)))local ca=bC%2^32+bx%2^32+ch%2^32+ce[az]+aD[2*az]%2^32;local ck,cl=U(ca),U(bD+by+ci+cf[az]+aD[2*az-1]+j(ca/2^32))ch,ci,bL,bM,bJ,bK=bL,bM,bJ,bK,bF,bG;local ca=ck%2^32+c8%2^32;bF,bG=U(ca),U(cl+c9+j(ca/2^32))c8,c9,bQ,bR,bA,bB=bQ,bR,bA,bB,bv,bw;bC=O(N(Q(bA,28),P(bB,4)),N(P(bA,30),Q(bB,2)),N(P(bA,25),Q(bB,7)))bD=O(N(Q(bB,28),P(bA,4)),N(P(bB,30),Q(bA,2)),N(P(bB,25),Q(bA,7)))bx=N(M(c8,bQ),M(bA,O(c8,bQ)))by=N(M(c9,bR),M(bB,O(c9,bR)))local ca=ck%2^32+bC%2^32+bx%2^32;bv,bw=U(ca),U(cl+bD+by+j(ca/2^32))end;cc[1],cd[1]=c7(cc[1],cd[1],bv,bw,0,0,0,0)cc[2],cd[2]=c7(cc[2],cd[2],bA,bB,0,0,0,0)cc[3],cd[3]=c7(cc[3],cd[3],bQ,bR,0,0,0,0)cc[4],cd[4]=c7(cc[4],cd[4],c8,c9,0,0,0,0)cc[5],cd[5]=c7(cc[5],cd[5],bF,bG,0,0,0,0)cc[6],cd[6]=c7(cc[6],cd[6],bJ,bK,0,0,0,0)cc[7],cd[7]=c7(cc[7],cd[7],bL,bM,0,0,0,0)cc[8],cd[8]=c7(cc[8],cd[8],ch,ci,0,0,0,0)end end end;function a1(aA,aB,aC,ax)local aD,aE=al,ag;for aF=aC,aC+ax-1,64 do for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aI,24),P(aH,16),P(E,8),aG)end;local aG,E,aH,aI=aA[1],aA[2],aA[3],aA[4]for az=1,16,4 do aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az]+aD[az]+aG,7)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az+1]+aD[az+1]+aG,12)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az+2]+aD[az+2]+aG,17)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az+3]+aD[az+3]+aG,22)+E)end;for az=17,32,4 do local aL=5*az-4;aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az]+aD[M(aL,15)+1]+aG,5)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az+1]+aD[M(aL+5,15)+1]+aG,9)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az+2]+aD[M(aL+10,15)+1]+aG,14)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az+3]+aD[M(aL-1,15)+1]+aG,20)+E)end;for az=33,48,4 do local aL=3*az+2;aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az]+aD[M(aL,15)+1]+aG,4)+E)aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az+1]+aD[M(aL+3,15)+1]+aG,11)+E)aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az+2]+aD[M(aL+6,15)+1]+aG,16)+E)aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az+3]+aD[M(aL-7,15)+1]+aG,23)+E)end;for az=49,64,4 do local aL=az*7;aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az]+aD[M(aL-7,15)+1]+aG,6)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az+1]+aD[M(aL,15)+1]+aG,10)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az+2]+aD[M(aL+7,15)+1]+aG,15)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az+3]+aD[M(aL-2,15)+1]+aG,21)+E)end;aA[1],aA[2],aA[3],aA[4]=U(aG+aA[1]),U(E+aA[2]),U(aH+aA[3]),U(aI+aA[4])end end;function a2(aA,aB,aC,ax)local aD=al;for aF=aC,aC+ax-1,64 do for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aG,24),P(E,16),P(aH,8),aI)end;for az=17,80 do aD[az]=R(O(aD[az-3],aD[az-8],aD[az-14],aD[az-16]),1)end;local aG,E,aH,aI,aJ=aA[1],aA[2],aA[3],aA[4],aA[5]for az=1,20,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+1]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+2]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+3]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+4]+0x5A827999+aJ)end;for az=21,40,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+1]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+2]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+3]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+4]+0x6ED9EBA1+aJ)end;for az=41,60,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+1]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+2]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+3]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+4]+0x8F1BBCDC+aJ)end;for az=61,80,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+1]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+2]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+3]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+4]+0xCA62C1D6+aJ)end;aA[1],aA[2],aA[3],aA[4],aA[5]=U(aG+aA[1]),U(E+aA[2]),U(aH+aA[3]),U(aI+aA[4]),U(aJ+aA[5])end end;do local cm,cn={},{}local function b0(aG,E,aH,aI,b1,b2)local aD=al;local co,cp,cq,cr=cm[aG],cm[E],cm[aH],cm[aI]local cs,ct,cu,cv=cn[aG],cn[E],cn[aH],cn[aI]local aN=aD[2*b1-1]+co%2^32+cp%2^32;co=U(aN)cs=U(aD[2*b1]+cs+ct+j(aN/2^32))cr,cv=O(cv,cs),O(cr,co)aN=cq%2^32+cr%2^32;cq=U(aN)cu=U(cu+cv+j(aN/2^32))cp,ct=O(cp,cq),O(ct,cu)cp,ct=O(Q(cp,24),P(ct,8)),O(Q(ct,24),P(cp,8))aN=aD[2*b2-1]+co%2^32+cp%2^32;co=U(aN)cs=U(aD[2*b2]+cs+ct+j(aN/2^32))cr,cv=O(cr,co),O(cv,cs)cr,cv=O(Q(cr,16),P(cv,16)),O(Q(cv,16),P(cr,16))aN=cq%2^32+cr%2^32;cq=U(aN)cu=U(cu+cv+j(aN/2^32))cp,ct=O(cp,cq),O(ct,cu)cp,ct=O(P(cp,1),Q(ct,31)),O(P(ct,1),Q(cp,31))cm[aG],cm[E],cm[aH],cm[aI]=co,cp,cq,cr;cn[aG],cn[E],cn[aH],cn[aI]=cs,ct,cu,cv end;function a5(cc,cd,aB,aC,ax,b7,b8,b9)local aD=al;local cw,cx,cy,cz,cA,cB,cC,cD=cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]local cE,cF,cG,cH,cI,cJ,cK,cL=cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]for aF=aC,aC+ax-1,128 do if aB then for az=1,32 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=aI*2^24+N(P(aH,16),P(E,8),aG)end end;cm[0x0],cm[0x1],cm[0x2],cm[0x3],cm[0x4],cm[0x5],cm[0x6],cm[0x7]=cw,cx,cy,cz,cA,cB,cC,cD;cm[0x8],cm[0x9],cm[0xA],cm[0xB],cm[0xC],cm[0xD],cm[0xE],cm[0xF]=a9[1],a9[2],a9[3],a9[4],a9[5],a9[6],a9[7],a9[8]cn[0x0],cn[0x1],cn[0x2],cn[0x3],cn[0x4],cn[0x5],cn[0x6],cn[0x7]=cE,cF,cG,cH,cI,cJ,cK,cL;cn[0x8],cn[0x9],cn[0xA],cn[0xB],cn[0xC],cn[0xD],cn[0xE],cn[0xF]=aa[1],aa[2],aa[3],aa[4],aa[5],aa[6],aa[7],aa[8]b7=b7+(b8 or 128)local cM=b7%2^32;local cN=j(b7/2^32)cm[0xC]=O(cm[0xC],cM)cn[0xC]=O(cn[0xC],cN)if b8 then cm[0xE]=T(cm[0xE])cn[0xE]=T(cn[0xE])end;if b9 then cm[0xF]=T(cm[0xF])cn[0xF]=T(cn[0xF])end;for az=1,12 do local bi=as[az]b0(0,4,8,12,bi[1],bi[2])b0(1,5,9,13,bi[3],bi[4])b0(2,6,10,14,bi[5],bi[6])b0(3,7,11,15,bi[7],bi[8])b0(0,5,10,15,bi[9],bi[10])b0(1,6,11,12,bi[11],bi[12])b0(2,7,8,13,bi[13],bi[14])b0(3,4,9,14,bi[15],bi[16])end;cw=O(cw,cm[0x0],cm[0x8])cx=O(cx,cm[0x1],cm[0x9])cy=O(cy,cm[0x2],cm[0xA])cz=O(cz,cm[0x3],cm[0xB])cA=O(cA,cm[0x4],cm[0xC])cB=O(cB,cm[0x5],cm[0xD])cC=O(cC,cm[0x6],cm[0xE])cD=O(cD,cm[0x7],cm[0xF])cE=O(cE,cn[0x0],cn[0x8])cF=O(cF,cn[0x1],cn[0x9])cG=O(cG,cn[0x2],cn[0xA])cH=O(cH,cn[0x3],cn[0xB])cI=O(cI,cn[0x4],cn[0xC])cJ=O(cJ,cn[0x5],cn[0xD])cK=O(cK,cn[0x6],cn[0xE])cL=O(cL,cn[0x7],cn[0xF])end;cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]=cw%2^32,cx%2^32,cy%2^32,cz%2^32,cA%2^32,cB%2^32,cC%2^32,cD%2^32;cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]=cE%2^32,cF%2^32,cG%2^32,cH%2^32,cI%2^32,cJ%2^32,cK%2^32,cL%2^32;return b7 end end end;if L==\"FFI\"or L==\"LJ\"then do local aD=an;local a_=ao;local function b0(aG,E,aH,aI,b1,b2)local b3,b4,b5,b6=a_[aG],a_[E],a_[aH],a_[aI]b3=U(aD[b1]+b3+b4)b6=S(O(b6,b3),16)b5=U(b5+b6)b4=S(O(b4,b5),12)b3=U(aD[b2]+b3+b4)b6=S(O(b6,b3),8)b5=U(b5+b6)b4=S(O(b4,b5),7)a_[aG],a_[E],a_[aH],a_[aI]=b3,b4,b5,b6 end;function a4(aA,aB,aC,ax,b7,b8,b9)local ba,bb,bc,bd,be,bf,bg,bh=U(aA[1]),U(aA[2]),U(aA[3]),U(aA[4]),U(aA[5]),U(aA[6]),U(aA[7]),U(aA[8])for aF=aC,aC+ax-1,64 do if aB then for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aI,24),P(aH,16),P(E,8),aG)end end;a_[0x0],a_[0x1],a_[0x2],a_[0x3],a_[0x4],a_[0x5],a_[0x6],a_[0x7]=ba,bb,bc,bd,be,bf,bg,bh;a_[0x8],a_[0x9],a_[0xA],a_[0xB],a_[0xE],a_[0xF]=U(aa[1]),U(aa[2]),U(aa[3]),U(aa[4]),U(aa[7]),U(aa[8])b7=b7+(b8 or 64)local cO=b7%2^32;local cP=j(b7/2^32)a_[0xC]=O(aa[5],cO)a_[0xD]=O(aa[6],cP)if b8 then a_[0xE]=T(a_[0xE])end;if b9 then a_[0xF]=T(a_[0xF])end;for az=1,10 do local bi=as[az]b0(0,4,8,12,bi[1],bi[2])b0(1,5,9,13,bi[3],bi[4])b0(2,6,10,14,bi[5],bi[6])b0(3,7,11,15,bi[7],bi[8])b0(0,5,10,15,bi[9],bi[10])b0(1,6,11,12,bi[11],bi[12])b0(2,7,8,13,bi[13],bi[14])b0(3,4,9,14,bi[15],bi[16])end;ba=O(ba,a_[0x0],a_[0x8])bb=O(bb,a_[0x1],a_[0x9])bc=O(bc,a_[0x2],a_[0xA])bd=O(bd,a_[0x3],a_[0xB])be=O(be,a_[0x4],a_[0xC])bf=O(bf,a_[0x5],a_[0xD])bg=O(bg,a_[0x6],a_[0xE])bh=O(bh,a_[0x7],a_[0xF])end;aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]=ba,bb,bc,bd,be,bf,bg,bh;return b7 end;function a6(aB,aC,ax,cQ,cR,cS,cT,cU,cV)cV=cV or 64;local ba,bb,bc,bd,be,bf,bg,bh=U(cS[1]),U(cS[2]),U(cS[3]),U(cS[4]),U(cS[5]),U(cS[6]),U(cS[7]),U(cS[8])cT=cT or cS;for aF=aC,aC+ax-1,64 do if aB then for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aI,24),P(aH,16),P(E,8),aG)end end;a_[0x0],a_[0x1],a_[0x2],a_[0x3],a_[0x4],a_[0x5],a_[0x6],a_[0x7]=ba,bb,bc,bd,be,bf,bg,bh;a_[0x8],a_[0x9],a_[0xA],a_[0xB]=U(aa[1]),U(aa[2]),U(aa[3]),U(aa[4])a_[0xC]=U(cR%2^32)a_[0xD]=j(cR/2^32)a_[0xE],a_[0xF]=cV,cQ;for az=1,7 do b0(0,4,8,12,at[az],at[az+14])b0(1,5,9,13,at[az+1],at[az+2])b0(2,6,10,14,at[az+16],at[az+7])b0(3,7,11,15,at[az+15],at[az+17])b0(0,5,10,15,at[az+21],at[az+5])b0(1,6,11,12,at[az+3],at[az+6])b0(2,7,8,13,at[az+4],at[az+18])b0(3,4,9,14,at[az+19],at[az+20])end;if cU then cT[9]=O(ba,a_[0x8])cT[10]=O(bb,a_[0x9])cT[11]=O(bc,a_[0xA])cT[12]=O(bd,a_[0xB])cT[13]=O(be,a_[0xC])cT[14]=O(bf,a_[0xD])cT[15]=O(bg,a_[0xE])cT[16]=O(bh,a_[0xF])end;ba=O(a_[0x0],a_[0x8])bb=O(a_[0x1],a_[0x9])bc=O(a_[0x2],a_[0xA])bd=O(a_[0x3],a_[0xB])be=O(a_[0x4],a_[0xC])bf=O(a_[0x5],a_[0xD])bg=O(a_[0x6],a_[0xE])bh=O(a_[0x7],a_[0xF])end;cT[1],cT[2],cT[3],cT[4],cT[5],cT[6],cT[7],cT[8]=ba,bb,bc,bd,be,bf,bg,bh end end end;O=O or X;if L==\"LIB32\"or L==\"EMUL\"then function _(aA,aB,aC,ax)local aD,aE=al,a8;local ba,bb,bc,bd,be,bf,bg,bh=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for aF=aC,aC+ax-1,64 do for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=((aG*256+E)*256+aH)*256+aI end;for az=17,64 do local aG,E=aD[az-15],aD[az-2]local cW,cX,cY,cZ=aG/2^7,aG/2^18,E/2^17,E/2^19;aD[az]=(O(cW%1*(2^32-1)+cW,cX%1*(2^32-1)+cX,(aG-aG%2^3)/2^3)+aD[az-16]+aD[az-7]+O(cY%1*(2^32-1)+cY,cZ%1*(2^32-1)+cZ,(E-E%2^10)/2^10))%2^32 end;local aG,E,aH,aI,aJ,aK,aL,aM=ba,bb,bc,bd,be,bf,bg,bh;for az=1,64 do aJ=aJ%2^32;local c_,d0,d1=aJ/2^6,aJ/2^11,aJ*2^7;local d2=d1%2^32;local aN=M(aJ,aK)+M(-1-aJ,aL)+aM+aE[az]+aD[az]+O(c_%1*(2^32-1)+c_,d0%1*(2^32-1)+d0,d2+(d1-d2)/2^32)aM=aL;aL=aK;aK=aJ;aJ=aN+aI;aI=aH;aH=E;E=aG%2^32;local d3,d4,d5=E/2^2,E/2^13,E*2^10;local d6=d5%2^32;aG=aN+M(aI,aH)+M(E,O(aI,aH))+O(d3%1*(2^32-1)+d3,d4%1*(2^32-1)+d4,d6+(d5-d6)/2^32)end;ba,bb,bc,bd=(aG+ba)%2^32,(E+bb)%2^32,(aH+bc)%2^32,(aI+bd)%2^32;be,bf,bg,bh=(aJ+be)%2^32,(aK+bf)%2^32,(aL+bg)%2^32,(aM+bh)%2^32 end;aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]=ba,bb,bc,bd,be,bf,bg,bh end;function a0(cc,cd,aB,aC,ax)local aD,ce,cf=al,a7,a8;local cw,cx,cy,cz,cA,cB,cC,cD=cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]local cE,cF,cG,cH,cI,cJ,cK,cL=cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]for aF=aC,aC+ax-1,128 do for az=1,16*2 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=((aG*256+E)*256+aH)*256+aI end;for cg=17*2,80*2,2 do local bw,bv,bB,bA=aD[cg-31],aD[cg-30],aD[cg-5],aD[cg-4]local d7,d8,d9,da,db,dc,dd,de,df,dg=bB%2^6,bB%2^19,bB%2^29,bA%2^19,bA%2^29,bw%2^1,bw%2^7,bw%2^8,bv%2^1,bv%2^8;local dh=O((bv-df)/2^1+dc*2^31,(bv-dg)/2^8+de*2^24,(bv-bv%2^7)/2^7+dd*2^25)%2^32+O((bA-da)/2^19+d8*2^13,db*2^3+(bB-d9)/2^29,(bA-bA%2^6)/2^6+d7*2^26)%2^32+aD[cg-14]+aD[cg-32]local di=dh%2^32;aD[cg-1]=(O((bw-dc)/2^1+df*2^31,(bw-de)/2^8+dg*2^24,(bw-dd)/2^7)+O((bB-d8)/2^19+da*2^13,d9*2^3+(bA-db)/2^29,(bB-d7)/2^6)+aD[cg-15]+aD[cg-33]+(dh-di)/2^32)%2^32;aD[cg]=di end;local bv,bA,bQ,c8,bF,bJ,bL,ch=cw,cx,cy,cz,cA,cB,cC,cD;local bw,bB,bR,c9,bG,bK,bM,ci=cE,cF,cG,cH,cI,cJ,cK,cL;for az=1,80 do local cg=2*az;local dj,dk,dl,dm,dn,dp=bF%2^9,bF%2^14,bF%2^18,bG%2^9,bG%2^14,bG%2^18;local dh=(M(bF,bJ)+M(-1-bF,bL))%2^32+ch+ce[az]+aD[cg]+O((bF-dk)/2^14+dn*2^18,(bF-dl)/2^18+dp*2^14,dj*2^23+(bG-dm)/2^9)%2^32;local ck=dh%2^32;local cl=M(bG,bK)+M(-1-bG,bM)+ci+cf[az]+aD[cg-1]+(dh-ck)/2^32+O((bG-dn)/2^14+dk*2^18,(bG-dp)/2^18+dl*2^14,dm*2^23+(bF-dj)/2^9)ch=bL;ci=bM;bL=bJ;bM=bK;bJ=bF;bK=bG;dh=ck+c8;bF=dh%2^32;bG=(cl+c9+(dh-bF)/2^32)%2^32;c8=bQ;c9=bR;bQ=bA;bR=bB;bA=bv;bB=bw;local dq,dr,ds,dt,du,dv=bA%2^2,bA%2^7,bA%2^28,bB%2^2,bB%2^7,bB%2^28;dh=ck+(M(c8,bQ)+M(bA,O(c8,bQ)))%2^32+O((bA-ds)/2^28+dv*2^4,dq*2^30+(bB-dt)/2^2,dr*2^25+(bB-du)/2^7)%2^32;bv=dh%2^32;bw=(cl+M(c9,bR)+M(bB,O(c9,bR))+(dh-bv)/2^32+O((bB-dv)/2^28+ds*2^4,dt*2^30+(bA-dq)/2^2,du*2^25+(bA-dr)/2^7))%2^32 end;bv=cw+bv;cw=bv%2^32;cE=(cE+bw+(bv-cw)/2^32)%2^32;bv=cx+bA;cx=bv%2^32;cF=(cF+bB+(bv-cx)/2^32)%2^32;bv=cy+bQ;cy=bv%2^32;cG=(cG+bR+(bv-cy)/2^32)%2^32;bv=cz+c8;cz=bv%2^32;cH=(cH+c9+(bv-cz)/2^32)%2^32;bv=cA+bF;cA=bv%2^32;cI=(cI+bG+(bv-cA)/2^32)%2^32;bv=cB+bJ;cB=bv%2^32;cJ=(cJ+bK+(bv-cB)/2^32)%2^32;bv=cC+bL;cC=bv%2^32;cK=(cK+bM+(bv-cC)/2^32)%2^32;bv=cD+ch;cD=bv%2^32;cL=(cL+ci+(bv-cD)/2^32)%2^32 end;cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]=cw,cx,cy,cz,cA,cB,cC,cD;cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]=cE,cF,cG,cH,cI,cJ,cK,cL end;if L==\"LIB32\"then function a1(aA,aB,aC,ax)local aD,aE,ai=al,ag,ai;local ba,bb,bc,bd=aA[1],aA[2],aA[3],aA[4]for aF=aC,aC+ax-1,64 do for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=((aI*256+aH)*256+E)*256+aG end;local aG,E,aH,aI=ba,bb,bc,bd;local dw=25;for az=1,16 do local dx=S(M(E,aH)+M(-1-E,aI)+aG+aE[az]+aD[az],dw)+E;dw=ai[dw]aG=aI;aI=aH;aH=E;E=dx end;dw=27;for az=17,32 do local dx=S(M(aI,E)+M(-1-aI,aH)+aG+aE[az]+aD[(5*az-4)%16+1],dw)+E;dw=ai[dw]aG=aI;aI=aH;aH=E;E=dx end;dw=28;for az=33,48 do local dx=S(O(O(E,aH),aI)+aG+aE[az]+aD[(3*az+2)%16+1],dw)+E;dw=ai[dw]aG=aI;aI=aH;aH=E;E=dx end;dw=26;for az=49,64 do local dx=S(O(aH,N(E,-1-aI))+aG+aE[az]+aD[(az*7-7)%16+1],dw)+E;dw=ai[dw]aG=aI;aI=aH;aH=E;E=dx end;ba=(aG+ba)%2^32;bb=(E+bb)%2^32;bc=(aH+bc)%2^32;bd=(aI+bd)%2^32 end;aA[1],aA[2],aA[3],aA[4]=ba,bb,bc,bd end end;function a2(aA,aB,aC,ax)local aD=al;local ba,bb,bc,bd,be=aA[1],aA[2],aA[3],aA[4],aA[5]for aF=aC,aC+ax-1,64 do for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=((aG*256+E)*256+aH)*256+aI end;for az=17,80 do local aG=O(aD[az-3],aD[az-8],aD[az-14],aD[az-16])%2^32*2;local E=aG%2^32;aD[az]=E+(aG-E)/2^32 end;local aG,E,aH,aI,aJ=ba,bb,bc,bd,be;for az=1,20 do local dy=aG*2^5;local aN=dy%2^32;aN=aN+(dy-aN)/2^32+M(E,aH)+M(-1-E,aI)+0x5A827999+aD[az]+aJ;aJ=aI;aI=aH;aH=E/2^2;aH=aH%1*(2^32-1)+aH;E=aG;aG=aN%2^32 end;for az=21,40 do local dy=aG*2^5;local aN=dy%2^32;aN=aN+(dy-aN)/2^32+O(E,aH,aI)+0x6ED9EBA1+aD[az]+aJ;aJ=aI;aI=aH;aH=E/2^2;aH=aH%1*(2^32-1)+aH;E=aG;aG=aN%2^32 end;for az=41,60 do local dy=aG*2^5;local aN=dy%2^32;aN=aN+(dy-aN)/2^32+M(aI,aH)+M(E,O(aI,aH))+0x8F1BBCDC+aD[az]+aJ;aJ=aI;aI=aH;aH=E/2^2;aH=aH%1*(2^32-1)+aH;E=aG;aG=aN%2^32 end;for az=61,80 do local dy=aG*2^5;local aN=dy%2^32;aN=aN+(dy-aN)/2^32+O(E,aH,aI)+0xCA62C1D6+aD[az]+aJ;aJ=aI;aI=aH;aH=E/2^2;aH=aH%1*(2^32-1)+aH;E=aG;aG=aN%2^32 end;ba=(aG+ba)%2^32;bb=(E+bb)%2^32;bc=(aH+bc)%2^32;bd=(aI+bd)%2^32;be=(aJ+be)%2^32 end;aA[1],aA[2],aA[3],aA[4],aA[5]=ba,bb,bc,bd,be end;function a3(c0,c1,aB,aC,ax,bl)local c2,c3=ab,ac;local bn=bl/8;for aF=aC,aC+ax-1,bl do for az=1,bn do local aG,E,aH,aI=c(aB,aF+1,aF+4)c0[az]=O(c0[az],((aI*256+aH)*256+E)*256+aG)aF=aF+8;aG,E,aH,aI=c(aB,aF-3,aF)c1[az]=O(c1[az],((aI*256+aH)*256+E)*256+aG)end;local dz,dA,dB,dC,dD,dE,dF,dG,dH,dI,dJ,dK,dL,dM,dN,dO,dP,dQ,dR,dS,dT,dU,dV,dW,dX,dY,dZ,d_,e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,ea,eb,ec,ed,ee,ef,eg,eh,ei,ej,ek,el=c0[1],c1[1],c0[2],c1[2],c0[3],c1[3],c0[4],c1[4],c0[5],c1[5],c0[6],c1[6],c0[7],c1[7],c0[8],c1[8],c0[9],c1[9],c0[10],c1[10],c0[11],c1[11],c0[12],c1[12],c0[13],c1[13],c0[14],c1[14],c0[15],c1[15],c0[16],c1[16],c0[17],c1[17],c0[18],c1[18],c0[19],c1[19],c0[20],c1[20],c0[21],c1[21],c0[22],c1[22],c0[23],c1[23],c0[24],c1[24],c0[25],c1[25]for bo=1,24 do local em=O(dz,dJ,dT,e2,ec)local en=O(dA,dK,dU,e3,ed)local eo=O(dB,dL,dV,e4,ee)local ep=O(dC,dM,dW,e5,ef)local eq=O(dD,dN,dX,e6,eg)local er=O(dE,dO,dY,e7,eh)local es=O(dF,dP,dZ,e8,ei)local et=O(dG,dQ,d_,e9,ej)local eu=O(dH,dR,e0,ea,ek)local ev=O(dI,dS,e1,eb,el)local c4=O(em,eq*2+(er%2^32-er%2^31)/2^31)local c5=O(en,er*2+(eq%2^32-eq%2^31)/2^31)local ew=O(c4,dB)local ex=O(c5,dC)local ey=O(c4,dL)local ez=O(c5,dM)local eA=O(c4,dV)local eB=O(c5,dW)local eC=O(c4,e4)local eD=O(c5,e5)local eE=O(c4,ee)local eF=O(c5,ef)dB=(ey%2^32-ey%2^20)/2^20+ez*2^12;dC=(ez%2^32-ez%2^20)/2^20+ey*2^12;dL=(eC%2^32-eC%2^19)/2^19+eD*2^13;dM=(eD%2^32-eD%2^19)/2^19+eC*2^13;dV=ew*2+(ex%2^32-ex%2^31)/2^31;dW=ex*2+(ew%2^32-ew%2^31)/2^31;e4=eA*2^10+(eB%2^32-eB%2^22)/2^22;e5=eB*2^10+(eA%2^32-eA%2^22)/2^22;ee=eE*2^2+(eF%2^32-eF%2^30)/2^30;ef=eF*2^2+(eE%2^32-eE%2^30)/2^30;c4=O(eo,es*2+(et%2^32-et%2^31)/2^31)c5=O(ep,et*2+(es%2^32-es%2^31)/2^31)ew=O(c4,dD)ex=O(c5,dE)ey=O(c4,dN)ez=O(c5,dO)eA=O(c4,dX)eB=O(c5,dY)eC=O(c4,e6)eD=O(c5,e7)eE=O(c4,eg)eF=O(c5,eh)dD=(eA%2^32-eA%2^21)/2^21+eB*2^11;dE=(eB%2^32-eB%2^21)/2^21+eA*2^11;dN=(eE%2^32-eE%2^3)/2^3+eF*2^29%2^32;dO=(eF%2^32-eF%2^3)/2^3+eE*2^29%2^32;dX=ey*2^6+(ez%2^32-ez%2^26)/2^26;dY=ez*2^6+(ey%2^32-ey%2^26)/2^26;e6=eC*2^15+(eD%2^32-eD%2^17)/2^17;e7=eD*2^15+(eC%2^32-eC%2^17)/2^17;eg=(ew%2^32-ew%2^2)/2^2+ex*2^30%2^32;eh=(ex%2^32-ex%2^2)/2^2+ew*2^30%2^32;c4=O(eq,eu*2+(ev%2^32-ev%2^31)/2^31)c5=O(er,ev*2+(eu%2^32-eu%2^31)/2^31)ew=O(c4,dF)ex=O(c5,dG)ey=O(c4,dP)ez=O(c5,dQ)eA=O(c4,dZ)eB=O(c5,d_)eC=O(c4,e8)eD=O(c5,e9)eE=O(c4,ei)eF=O(c5,ej)dF=eC*2^21%2^32+(eD%2^32-eD%2^11)/2^11;dG=eD*2^21%2^32+(eC%2^32-eC%2^11)/2^11;dP=ew*2^28%2^32+(ex%2^32-ex%2^4)/2^4;dQ=ex*2^28%2^32+(ew%2^32-ew%2^4)/2^4;dZ=eA*2^25%2^32+(eB%2^32-eB%2^7)/2^7;d_=eB*2^25%2^32+(eA%2^32-eA%2^7)/2^7;e8=(eE%2^32-eE%2^8)/2^8+eF*2^24%2^32;e9=(eF%2^32-eF%2^8)/2^8+eE*2^24%2^32;ei=(ey%2^32-ey%2^9)/2^9+ez*2^23%2^32;ej=(ez%2^32-ez%2^9)/2^9+ey*2^23%2^32;c4=O(es,em*2+(en%2^32-en%2^31)/2^31)c5=O(et,en*2+(em%2^32-em%2^31)/2^31)ew=O(c4,dH)ex=O(c5,dI)ey=O(c4,dR)ez=O(c5,dS)eA=O(c4,e0)eB=O(c5,e1)eC=O(c4,ea)eD=O(c5,eb)eE=O(c4,ek)eF=O(c5,el)dH=eE*2^14+(eF%2^32-eF%2^18)/2^18;dI=eF*2^14+(eE%2^32-eE%2^18)/2^18;dR=ey*2^20%2^32+(ez%2^32-ez%2^12)/2^12;dS=ez*2^20%2^32+(ey%2^32-ey%2^12)/2^12;e0=eC*2^8+(eD%2^32-eD%2^24)/2^24;e1=eD*2^8+(eC%2^32-eC%2^24)/2^24;ea=ew*2^27%2^32+(ex%2^32-ex%2^5)/2^5;eb=ex*2^27%2^32+(ew%2^32-ew%2^5)/2^5;ek=(eA%2^32-eA%2^25)/2^25+eB*2^7;el=(eB%2^32-eB%2^25)/2^25+eA*2^7;c4=O(eu,eo*2+(ep%2^32-ep%2^31)/2^31)c5=O(ev,ep*2+(eo%2^32-eo%2^31)/2^31)ey=O(c4,dJ)ez=O(c5,dK)eA=O(c4,dT)eB=O(c5,dU)eC=O(c4,e2)eD=O(c5,e3)eE=O(c4,ec)eF=O(c5,ed)dJ=eA*2^3+(eB%2^32-eB%2^29)/2^29;dK=eB*2^3+(eA%2^32-eA%2^29)/2^29;dT=eE*2^18+(eF%2^32-eF%2^14)/2^14;dU=eF*2^18+(eE%2^32-eE%2^14)/2^14;e2=(ey%2^32-ey%2^28)/2^28+ez*2^4;e3=(ez%2^32-ez%2^28)/2^28+ey*2^4;ec=(eC%2^32-eC%2^23)/2^23+eD*2^9;ed=(eD%2^32-eD%2^23)/2^23+eC*2^9;dz=O(c4,dz)dA=O(c5,dA)dz,dB,dD,dF,dH=O(dz,M(-1-dB,dD)),O(dB,M(-1-dD,dF)),O(dD,M(-1-dF,dH)),O(dF,M(-1-dH,dz)),O(dH,M(-1-dz,dB))dA,dC,dE,dG,dI=O(dA,M(-1-dC,dE)),O(dC,M(-1-dE,dG)),O(dE,M(-1-dG,dI)),O(dG,M(-1-dI,dA)),O(dI,M(-1-dA,dC))dJ,dL,dN,dP,dR=O(dP,M(-1-dR,dJ)),O(dR,M(-1-dJ,dL)),O(dJ,M(-1-dL,dN)),O(dL,M(-1-dN,dP)),O(dN,M(-1-dP,dR))dK,dM,dO,dQ,dS=O(dQ,M(-1-dS,dK)),O(dS,M(-1-dK,dM)),O(dK,M(-1-dM,dO)),O(dM,M(-1-dO,dQ)),O(dO,M(-1-dQ,dS))dT,dV,dX,dZ,e0=O(dV,M(-1-dX,dZ)),O(dX,M(-1-dZ,e0)),O(dZ,M(-1-e0,dT)),O(e0,M(-1-dT,dV)),O(dT,M(-1-dV,dX))dU,dW,dY,d_,e1=O(dW,M(-1-dY,d_)),O(dY,M(-1-d_,e1)),O(d_,M(-1-e1,dU)),O(e1,M(-1-dU,dW)),O(dU,M(-1-dW,dY))e2,e4,e6,e8,ea=O(ea,M(-1-e2,e4)),O(e2,M(-1-e4,e6)),O(e4,M(-1-e6,e8)),O(e6,M(-1-e8,ea)),O(e8,M(-1-ea,e2))e3,e5,e7,e9,eb=O(eb,M(-1-e3,e5)),O(e3,M(-1-e5,e7)),O(e5,M(-1-e7,e9)),O(e7,M(-1-e9,eb)),O(e9,M(-1-eb,e3))ec,ee,eg,ei,ek=O(eg,M(-1-ei,ek)),O(ei,M(-1-ek,ec)),O(ek,M(-1-ec,ee)),O(ec,M(-1-ee,eg)),O(ee,M(-1-eg,ei))ed,ef,eh,ej,el=O(eh,M(-1-ej,el)),O(ej,M(-1-el,ed)),O(el,M(-1-ed,ef)),O(ed,M(-1-ef,eh)),O(ef,M(-1-eh,ej))dz=O(dz,c2[bo])dA=dA+c3[bo]end;c0[1]=dz;c1[1]=dA;c0[2]=dB;c1[2]=dC;c0[3]=dD;c1[3]=dE;c0[4]=dF;c1[4]=dG;c0[5]=dH;c1[5]=dI;c0[6]=dJ;c1[6]=dK;c0[7]=dL;c1[7]=dM;c0[8]=dN;c1[8]=dO;c0[9]=dP;c1[9]=dQ;c0[10]=dR;c1[10]=dS;c0[11]=dT;c1[11]=dU;c0[12]=dV;c1[12]=dW;c0[13]=dX;c1[13]=dY;c0[14]=dZ;c1[14]=d_;c0[15]=e0;c1[15]=e1;c0[16]=e2;c1[16]=e3;c0[17]=e4;c1[17]=e5;c0[18]=e6;c1[18]=e7;c0[19]=e8;c1[19]=e9;c0[20]=ea;c1[20]=eb;c0[21]=ec;c1[21]=ed;c0[22]=ee;c1[22]=ef;c0[23]=eg;c1[23]=eh;c0[24]=ei;c1[24]=ej;c0[25]=ek;c1[25]=el end end;function a4(aA,aB,aC,ax,b7,b8,b9)local aD=al;local ba,bb,bc,bd,be,bf,bg,bh=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for aF=aC,aC+ax-1,64 do if aB then for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=((aI*256+aH)*256+E)*256+aG end end;local eG,eH,eI,eJ,eK,eL,eM,eN=ba,bb,bc,bd,be,bf,bg,bh;local eO,eP,eQ,eR,eS,eT,eU,eV=aa[1],aa[2],aa[3],aa[4],aa[5],aa[6],aa[7],aa[8]b7=b7+(b8 or 64)local cO=b7%2^32;local cP=(b7-cO)/2^32;eS=O(eS,cO)eT=O(eT,cP)if b8 then eU=-1-eU end;if b9 then eV=-1-eV end;for az=1,10 do local bi=as[az]eG=eG+eK+aD[bi[1]]eS=O(eS,eG)%2^32/2^16;eS=eS%1*(2^32-1)+eS;eO=eO+eS;eK=O(eK,eO)%2^32/2^12;eK=eK%1*(2^32-1)+eK;eG=eG+eK+aD[bi[2]]eS=O(eS,eG)%2^32/2^8;eS=eS%1*(2^32-1)+eS;eO=eO+eS;eK=O(eK,eO)%2^32/2^7;eK=eK%1*(2^32-1)+eK;eH=eH+eL+aD[bi[3]]eT=O(eT,eH)%2^32/2^16;eT=eT%1*(2^32-1)+eT;eP=eP+eT;eL=O(eL,eP)%2^32/2^12;eL=eL%1*(2^32-1)+eL;eH=eH+eL+aD[bi[4]]eT=O(eT,eH)%2^32/2^8;eT=eT%1*(2^32-1)+eT;eP=eP+eT;eL=O(eL,eP)%2^32/2^7;eL=eL%1*(2^32-1)+eL;eI=eI+eM+aD[bi[5]]eU=O(eU,eI)%2^32/2^16;eU=eU%1*(2^32-1)+eU;eQ=eQ+eU;eM=O(eM,eQ)%2^32/2^12;eM=eM%1*(2^32-1)+eM;eI=eI+eM+aD[bi[6]]eU=O(eU,eI)%2^32/2^8;eU=eU%1*(2^32-1)+eU;eQ=eQ+eU;eM=O(eM,eQ)%2^32/2^7;eM=eM%1*(2^32-1)+eM;eJ=eJ+eN+aD[bi[7]]eV=O(eV,eJ)%2^32/2^16;eV=eV%1*(2^32-1)+eV;eR=eR+eV;eN=O(eN,eR)%2^32/2^12;eN=eN%1*(2^32-1)+eN;eJ=eJ+eN+aD[bi[8]]eV=O(eV,eJ)%2^32/2^8;eV=eV%1*(2^32-1)+eV;eR=eR+eV;eN=O(eN,eR)%2^32/2^7;eN=eN%1*(2^32-1)+eN;eG=eG+eL+aD[bi[9]]eV=O(eV,eG)%2^32/2^16;eV=eV%1*(2^32-1)+eV;eQ=eQ+eV;eL=O(eL,eQ)%2^32/2^12;eL=eL%1*(2^32-1)+eL;eG=eG+eL+aD[bi[10]]eV=O(eV,eG)%2^32/2^8;eV=eV%1*(2^32-1)+eV;eQ=eQ+eV;eL=O(eL,eQ)%2^32/2^7;eL=eL%1*(2^32-1)+eL;eH=eH+eM+aD[bi[11]]eS=O(eS,eH)%2^32/2^16;eS=eS%1*(2^32-1)+eS;eR=eR+eS;eM=O(eM,eR)%2^32/2^12;eM=eM%1*(2^32-1)+eM;eH=eH+eM+aD[bi[12]]eS=O(eS,eH)%2^32/2^8;eS=eS%1*(2^32-1)+eS;eR=eR+eS;eM=O(eM,eR)%2^32/2^7;eM=eM%1*(2^32-1)+eM;eI=eI+eN+aD[bi[13]]eT=O(eT,eI)%2^32/2^16;eT=eT%1*(2^32-1)+eT;eO=eO+eT;eN=O(eN,eO)%2^32/2^12;eN=eN%1*(2^32-1)+eN;eI=eI+eN+aD[bi[14]]eT=O(eT,eI)%2^32/2^8;eT=eT%1*(2^32-1)+eT;eO=eO+eT;eN=O(eN,eO)%2^32/2^7;eN=eN%1*(2^32-1)+eN;eJ=eJ+eK+aD[bi[15]]eU=O(eU,eJ)%2^32/2^16;eU=eU%1*(2^32-1)+eU;eP=eP+eU;eK=O(eK,eP)%2^32/2^12;eK=eK%1*(2^32-1)+eK;eJ=eJ+eK+aD[bi[16]]eU=O(eU,eJ)%2^32/2^8;eU=eU%1*(2^32-1)+eU;eP=eP+eU;eK=O(eK,eP)%2^32/2^7;eK=eK%1*(2^32-1)+eK end;ba=O(ba,eG,eO)bb=O(bb,eH,eP)bc=O(bc,eI,eQ)bd=O(bd,eJ,eR)be=O(be,eK,eS)bf=O(bf,eL,eT)bg=O(bg,eM,eU)bh=O(bh,eN,eV)end;aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]=ba,bb,bc,bd,be,bf,bg,bh;return b7 end;function a5(cc,cd,aB,aC,ax,b7,b8,b9)local aD=al;local cw,cx,cy,cz,cA,cB,cC,cD=cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]local cE,cF,cG,cH,cI,cJ,cK,cL=cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]for aF=aC,aC+ax-1,128 do if aB then for az=1,32 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=((aI*256+aH)*256+E)*256+aG end end;local eW,eX,eY,eZ,e_,f0,f1,f2=cw,cx,cy,cz,cA,cB,cC,cD;local f3,f4,f5,f6,f7,f8,f9,fa=cE,cF,cG,cH,cI,cJ,cK,cL;local fb,fc,fd,fe,ff,fg,fh,fi=a9[1],a9[2],a9[3],a9[4],a9[5],a9[6],a9[7],a9[8]local fj,fk,fl,fm,fn,fo,fp,fq=aa[1],aa[2],aa[3],aa[4],aa[5],aa[6],aa[7],aa[8]b7=b7+(b8 or 128)local cM=b7%2^32;local cN=(b7-cM)/2^32;ff=O(ff,cM)fn=O(fn,cN)if b8 then fh=-1-fh;fp=-1-fp end;if b9 then fi=-1-fi;fq=-1-fq end;for az=1,12 do local bi=as[az]local q=bi[1]*2;local aN=eW%2^32+e_%2^32+aD[q-1]eW=aN%2^32;f3=f3+f7+(aN-eW)/2^32+aD[q]ff,fn=O(fn,f3),O(ff,eW)aN=fb%2^32+ff%2^32;fb=aN%2^32;fj=fj+fn+(aN-fb)/2^32;e_,f7=O(e_,fb),O(f7,fj)local ck,cl=e_%2^24,f7%2^24;e_,f7=(e_-ck)/2^24%2^8+cl*2^8,(f7-cl)/2^24%2^8+ck*2^8;q=bi[2]*2;aN=eW%2^32+e_%2^32+aD[q-1]eW=aN%2^32;f3=f3+f7+(aN-eW)/2^32+aD[q]ff,fn=O(ff,eW),O(fn,f3)ck,cl=ff%2^16,fn%2^16;ff,fn=(ff-ck)/2^16%2^16+cl*2^16,(fn-cl)/2^16%2^16+ck*2^16;aN=fb%2^32+ff%2^32;fb=aN%2^32;fj=fj+fn+(aN-fb)/2^32;e_,f7=O(e_,fb),O(f7,fj)ck,cl=e_%2^31,f7%2^31;e_,f7=ck*2^1+(f7-cl)/2^31%2^1,cl*2^1+(e_-ck)/2^31%2^1;q=bi[3]*2;aN=eX%2^32+f0%2^32+aD[q-1]eX=aN%2^32;f4=f4+f8+(aN-eX)/2^32+aD[q]fg,fo=O(fo,f4),O(fg,eX)aN=fc%2^32+fg%2^32;fc=aN%2^32;fk=fk+fo+(aN-fc)/2^32;f0,f8=O(f0,fc),O(f8,fk)ck,cl=f0%2^24,f8%2^24;f0,f8=(f0-ck)/2^24%2^8+cl*2^8,(f8-cl)/2^24%2^8+ck*2^8;q=bi[4]*2;aN=eX%2^32+f0%2^32+aD[q-1]eX=aN%2^32;f4=f4+f8+(aN-eX)/2^32+aD[q]fg,fo=O(fg,eX),O(fo,f4)ck,cl=fg%2^16,fo%2^16;fg,fo=(fg-ck)/2^16%2^16+cl*2^16,(fo-cl)/2^16%2^16+ck*2^16;aN=fc%2^32+fg%2^32;fc=aN%2^32;fk=fk+fo+(aN-fc)/2^32;f0,f8=O(f0,fc),O(f8,fk)ck,cl=f0%2^31,f8%2^31;f0,f8=ck*2^1+(f8-cl)/2^31%2^1,cl*2^1+(f0-ck)/2^31%2^1;q=bi[5]*2;aN=eY%2^32+f1%2^32+aD[q-1]eY=aN%2^32;f5=f5+f9+(aN-eY)/2^32+aD[q]fh,fp=O(fp,f5),O(fh,eY)aN=fd%2^32+fh%2^32;fd=aN%2^32;fl=fl+fp+(aN-fd)/2^32;f1,f9=O(f1,fd),O(f9,fl)ck,cl=f1%2^24,f9%2^24;f1,f9=(f1-ck)/2^24%2^8+cl*2^8,(f9-cl)/2^24%2^8+ck*2^8;q=bi[6]*2;aN=eY%2^32+f1%2^32+aD[q-1]eY=aN%2^32;f5=f5+f9+(aN-eY)/2^32+aD[q]fh,fp=O(fh,eY),O(fp,f5)ck,cl=fh%2^16,fp%2^16;fh,fp=(fh-ck)/2^16%2^16+cl*2^16,(fp-cl)/2^16%2^16+ck*2^16;aN=fd%2^32+fh%2^32;fd=aN%2^32;fl=fl+fp+(aN-fd)/2^32;f1,f9=O(f1,fd),O(f9,fl)ck,cl=f1%2^31,f9%2^31;f1,f9=ck*2^1+(f9-cl)/2^31%2^1,cl*2^1+(f1-ck)/2^31%2^1;q=bi[7]*2;aN=eZ%2^32+f2%2^32+aD[q-1]eZ=aN%2^32;f6=f6+fa+(aN-eZ)/2^32+aD[q]fi,fq=O(fq,f6),O(fi,eZ)aN=fe%2^32+fi%2^32;fe=aN%2^32;fm=fm+fq+(aN-fe)/2^32;f2,fa=O(f2,fe),O(fa,fm)ck,cl=f2%2^24,fa%2^24;f2,fa=(f2-ck)/2^24%2^8+cl*2^8,(fa-cl)/2^24%2^8+ck*2^8;q=bi[8]*2;aN=eZ%2^32+f2%2^32+aD[q-1]eZ=aN%2^32;f6=f6+fa+(aN-eZ)/2^32+aD[q]fi,fq=O(fi,eZ),O(fq,f6)ck,cl=fi%2^16,fq%2^16;fi,fq=(fi-ck)/2^16%2^16+cl*2^16,(fq-cl)/2^16%2^16+ck*2^16;aN=fe%2^32+fi%2^32;fe=aN%2^32;fm=fm+fq+(aN-fe)/2^32;f2,fa=O(f2,fe),O(fa,fm)ck,cl=f2%2^31,fa%2^31;f2,fa=ck*2^1+(fa-cl)/2^31%2^1,cl*2^1+(f2-ck)/2^31%2^1;q=bi[9]*2;aN=eW%2^32+f0%2^32+aD[q-1]eW=aN%2^32;f3=f3+f8+(aN-eW)/2^32+aD[q]fi,fq=O(fq,f3),O(fi,eW)aN=fd%2^32+fi%2^32;fd=aN%2^32;fl=fl+fq+(aN-fd)/2^32;f0,f8=O(f0,fd),O(f8,fl)ck,cl=f0%2^24,f8%2^24;f0,f8=(f0-ck)/2^24%2^8+cl*2^8,(f8-cl)/2^24%2^8+ck*2^8;q=bi[10]*2;aN=eW%2^32+f0%2^32+aD[q-1]eW=aN%2^32;f3=f3+f8+(aN-eW)/2^32+aD[q]fi,fq=O(fi,eW),O(fq,f3)ck,cl=fi%2^16,fq%2^16;fi,fq=(fi-ck)/2^16%2^16+cl*2^16,(fq-cl)/2^16%2^16+ck*2^16;aN=fd%2^32+fi%2^32;fd=aN%2^32;fl=fl+fq+(aN-fd)/2^32;f0,f8=O(f0,fd),O(f8,fl)ck,cl=f0%2^31,f8%2^31;f0,f8=ck*2^1+(f8-cl)/2^31%2^1,cl*2^1+(f0-ck)/2^31%2^1;q=bi[11]*2;aN=eX%2^32+f1%2^32+aD[q-1]eX=aN%2^32;f4=f4+f9+(aN-eX)/2^32+aD[q]ff,fn=O(fn,f4),O(ff,eX)aN=fe%2^32+ff%2^32;fe=aN%2^32;fm=fm+fn+(aN-fe)/2^32;f1,f9=O(f1,fe),O(f9,fm)ck,cl=f1%2^24,f9%2^24;f1,f9=(f1-ck)/2^24%2^8+cl*2^8,(f9-cl)/2^24%2^8+ck*2^8;q=bi[12]*2;aN=eX%2^32+f1%2^32+aD[q-1]eX=aN%2^32;f4=f4+f9+(aN-eX)/2^32+aD[q]ff,fn=O(ff,eX),O(fn,f4)ck,cl=ff%2^16,fn%2^16;ff,fn=(ff-ck)/2^16%2^16+cl*2^16,(fn-cl)/2^16%2^16+ck*2^16;aN=fe%2^32+ff%2^32;fe=aN%2^32;fm=fm+fn+(aN-fe)/2^32;f1,f9=O(f1,fe),O(f9,fm)ck,cl=f1%2^31,f9%2^31;f1,f9=ck*2^1+(f9-cl)/2^31%2^1,cl*2^1+(f1-ck)/2^31%2^1;q=bi[13]*2;aN=eY%2^32+f2%2^32+aD[q-1]eY=aN%2^32;f5=f5+fa+(aN-eY)/2^32+aD[q]fg,fo=O(fo,f5),O(fg,eY)aN=fb%2^32+fg%2^32;fb=aN%2^32;fj=fj+fo+(aN-fb)/2^32;f2,fa=O(f2,fb),O(fa,fj)ck,cl=f2%2^24,fa%2^24;f2,fa=(f2-ck)/2^24%2^8+cl*2^8,(fa-cl)/2^24%2^8+ck*2^8;q=bi[14]*2;aN=eY%2^32+f2%2^32+aD[q-1]eY=aN%2^32;f5=f5+fa+(aN-eY)/2^32+aD[q]fg,fo=O(fg,eY),O(fo,f5)ck,cl=fg%2^16,fo%2^16;fg,fo=(fg-ck)/2^16%2^16+cl*2^16,(fo-cl)/2^16%2^16+ck*2^16;aN=fb%2^32+fg%2^32;fb=aN%2^32;fj=fj+fo+(aN-fb)/2^32;f2,fa=O(f2,fb),O(fa,fj)ck,cl=f2%2^31,fa%2^31;f2,fa=ck*2^1+(fa-cl)/2^31%2^1,cl*2^1+(f2-ck)/2^31%2^1;q=bi[15]*2;aN=eZ%2^32+e_%2^32+aD[q-1]eZ=aN%2^32;f6=f6+f7+(aN-eZ)/2^32+aD[q]fh,fp=O(fp,f6),O(fh,eZ)aN=fc%2^32+fh%2^32;fc=aN%2^32;fk=fk+fp+(aN-fc)/2^32;e_,f7=O(e_,fc),O(f7,fk)ck,cl=e_%2^24,f7%2^24;e_,f7=(e_-ck)/2^24%2^8+cl*2^8,(f7-cl)/2^24%2^8+ck*2^8;q=bi[16]*2;aN=eZ%2^32+e_%2^32+aD[q-1]eZ=aN%2^32;f6=f6+f7+(aN-eZ)/2^32+aD[q]fh,fp=O(fh,eZ),O(fp,f6)ck,cl=fh%2^16,fp%2^16;fh,fp=(fh-ck)/2^16%2^16+cl*2^16,(fp-cl)/2^16%2^16+ck*2^16;aN=fc%2^32+fh%2^32;fc=aN%2^32;fk=fk+fp+(aN-fc)/2^32;e_,f7=O(e_,fc),O(f7,fk)ck,cl=e_%2^31,f7%2^31;e_,f7=ck*2^1+(f7-cl)/2^31%2^1,cl*2^1+(e_-ck)/2^31%2^1 end;cw=O(cw,eW,fb)%2^32;cx=O(cx,eX,fc)%2^32;cy=O(cy,eY,fd)%2^32;cz=O(cz,eZ,fe)%2^32;cA=O(cA,e_,ff)%2^32;cB=O(cB,f0,fg)%2^32;cC=O(cC,f1,fh)%2^32;cD=O(cD,f2,fi)%2^32;cE=O(cE,f3,fj)%2^32;cF=O(cF,f4,fk)%2^32;cG=O(cG,f5,fl)%2^32;cH=O(cH,f6,fm)%2^32;cI=O(cI,f7,fn)%2^32;cJ=O(cJ,f8,fo)%2^32;cK=O(cK,f9,fp)%2^32;cL=O(cL,fa,fq)%2^32 end;cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]=cw,cx,cy,cz,cA,cB,cC,cD;cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]=cE,cF,cG,cH,cI,cJ,cK,cL;return b7 end;function a6(aB,aC,ax,cQ,cR,cS,cT,cU,cV)cV=cV or 64;local aD=al;local ba,bb,bc,bd,be,bf,bg,bh=cS[1],cS[2],cS[3],cS[4],cS[5],cS[6],cS[7],cS[8]cT=cT or cS;for aF=aC,aC+ax-1,64 do if aB then for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=((aI*256+aH)*256+E)*256+aG end end;local eG,eH,eI,eJ,eK,eL,eM,eN=ba,bb,bc,bd,be,bf,bg,bh;local eO,eP,eQ,eR=aa[1],aa[2],aa[3],aa[4]local eS=cR%2^32;local eT=(cR-eS)/2^32;local eU,eV=cV,cQ;for az=1,7 do eG=eG+eK+aD[at[az]]eS=O(eS,eG)%2^32/2^16;eS=eS%1*(2^32-1)+eS;eO=eO+eS;eK=O(eK,eO)%2^32/2^12;eK=eK%1*(2^32-1)+eK;eG=eG+eK+aD[at[az+14]]eS=O(eS,eG)%2^32/2^8;eS=eS%1*(2^32-1)+eS;eO=eO+eS;eK=O(eK,eO)%2^32/2^7;eK=eK%1*(2^32-1)+eK;eH=eH+eL+aD[at[az+1]]eT=O(eT,eH)%2^32/2^16;eT=eT%1*(2^32-1)+eT;eP=eP+eT;eL=O(eL,eP)%2^32/2^12;eL=eL%1*(2^32-1)+eL;eH=eH+eL+aD[at[az+2]]eT=O(eT,eH)%2^32/2^8;eT=eT%1*(2^32-1)+eT;eP=eP+eT;eL=O(eL,eP)%2^32/2^7;eL=eL%1*(2^32-1)+eL;eI=eI+eM+aD[at[az+16]]eU=O(eU,eI)%2^32/2^16;eU=eU%1*(2^32-1)+eU;eQ=eQ+eU;eM=O(eM,eQ)%2^32/2^12;eM=eM%1*(2^32-1)+eM;eI=eI+eM+aD[at[az+7]]eU=O(eU,eI)%2^32/2^8;eU=eU%1*(2^32-1)+eU;eQ=eQ+eU;eM=O(eM,eQ)%2^32/2^7;eM=eM%1*(2^32-1)+eM;eJ=eJ+eN+aD[at[az+15]]eV=O(eV,eJ)%2^32/2^16;eV=eV%1*(2^32-1)+eV;eR=eR+eV;eN=O(eN,eR)%2^32/2^12;eN=eN%1*(2^32-1)+eN;eJ=eJ+eN+aD[at[az+17]]eV=O(eV,eJ)%2^32/2^8;eV=eV%1*(2^32-1)+eV;eR=eR+eV;eN=O(eN,eR)%2^32/2^7;eN=eN%1*(2^32-1)+eN;eG=eG+eL+aD[at[az+21]]eV=O(eV,eG)%2^32/2^16;eV=eV%1*(2^32-1)+eV;eQ=eQ+eV;eL=O(eL,eQ)%2^32/2^12;eL=eL%1*(2^32-1)+eL;eG=eG+eL+aD[at[az+5]]eV=O(eV,eG)%2^32/2^8;eV=eV%1*(2^32-1)+eV;eQ=eQ+eV;eL=O(eL,eQ)%2^32/2^7;eL=eL%1*(2^32-1)+eL;eH=eH+eM+aD[at[az+3]]eS=O(eS,eH)%2^32/2^16;eS=eS%1*(2^32-1)+eS;eR=eR+eS;eM=O(eM,eR)%2^32/2^12;eM=eM%1*(2^32-1)+eM;eH=eH+eM+aD[at[az+6]]eS=O(eS,eH)%2^32/2^8;eS=eS%1*(2^32-1)+eS;eR=eR+eS;eM=O(eM,eR)%2^32/2^7;eM=eM%1*(2^32-1)+eM;eI=eI+eN+aD[at[az+4]]eT=O(eT,eI)%2^32/2^16;eT=eT%1*(2^32-1)+eT;eO=eO+eT;eN=O(eN,eO)%2^32/2^12;eN=eN%1*(2^32-1)+eN;eI=eI+eN+aD[at[az+18]]eT=O(eT,eI)%2^32/2^8;eT=eT%1*(2^32-1)+eT;eO=eO+eT;eN=O(eN,eO)%2^32/2^7;eN=eN%1*(2^32-1)+eN;eJ=eJ+eK+aD[at[az+19]]eU=O(eU,eJ)%2^32/2^16;eU=eU%1*(2^32-1)+eU;eP=eP+eU;eK=O(eK,eP)%2^32/2^12;eK=eK%1*(2^32-1)+eK;eJ=eJ+eK+aD[at[az+20]]eU=O(eU,eJ)%2^32/2^8;eU=eU%1*(2^32-1)+eU;eP=eP+eU;eK=O(eK,eP)%2^32/2^7;eK=eK%1*(2^32-1)+eK end;if cU then cT[9]=O(ba,eO)cT[10]=O(bb,eP)cT[11]=O(bc,eQ)cT[12]=O(bd,eR)cT[13]=O(be,eS)cT[14]=O(bf,eT)cT[15]=O(bg,eU)cT[16]=O(bh,eV)end;ba=O(eG,eO)bb=O(eH,eP)bc=O(eI,eQ)bd=O(eJ,eR)be=O(eK,eS)bf=O(eL,eT)bg=O(eM,eU)bh=O(eN,eV)end;cT[1],cT[2],cT[3],cT[4],cT[5],cT[6],cT[7],cT[8]=ba,bb,bc,bd,be,bf,bg,bh end end;do local function fr(fs,ft,fu,fv)local H,fw,fx,fy={},0.0,0.0,1.0;for az=1,fv do for q=m(1,az+1-#ft),l(az,#fs)do fw=fw+fu*fs[q]*ft[az+1-q]end;local fz=fw%2^24;H[az]=j(fz)fw=(fw-fz)/2^24;fx=fx+fz*fy;fy=fy*2^24 end;return H,fx end;local fA,fB,fC,p,fD,fE=0,{4,1,2,-2,2},4,{1},aa,a9;repeat fC=fC+fB[fC%6]local aI=1;repeat aI=aI+fB[aI%6]if aI*aI>fC then local fF=fC^(1/3)local fG=fF*2^40;fG=fr({fG-fG%1},p,1.0,2)local I,fH=fr(fG,fr(fG,fG,1.0,4),-1.0,4)local fI=fG[2]%65536*65536+j(fG[1]/256)local fJ=fG[1]%256*16777216+j(fH*2^-56/3*fF/fC)if fA<16 then fF=fC^(1/2)fG=fF*2^40;fG=fr({fG-fG%1},p,1.0,2)I,fH=fr(fG,fG,-1.0,2)local fI=fG[2]%65536*65536+j(fG[1]/256)local fJ=fG[1]%256*16777216+j(fH*2^-17/fF)local fA=fA%8+1;ad[224][fA]=fJ;fD[fA],fE[fA]=fI,fJ+fI*aq;if fA>7 then fD,fE=af[384],ae[384]end end;fA=fA+1;a8[fA],a7[fA]=fI,fJ%ap+fI*aq;break end until fC%aI==0 until fA>79 end;for fK=224,256,32 do local cc,cd={}if aj then for az=1,8 do cc[az]=X(a9[az])end else cd={}for az=1,8 do cc[az]=X(a9[az])cd[az]=X(aa[az])end end;a0(cc,cd,\"SHA-512/\"..tostring(fK)..\"\\128\"..e(\"\\0\",115)..\"\\88\",0,128)ae[fK]=cc;af[fK]=cd end;do local fL,fM,fN=math.sin,math.abs,math.modf;for fA=1,64 do local fI,fJ=fN(fM(fL(fA))*2^16)ag[fA]=fI*65536+j(fJ*2^16)end end;do local fO=29;local function fP()local fQ=fO%2;fO=W((fO-fQ)/2,142*fQ)return fQ end;for fA=1,24 do local fJ,s=0;for I=1,6 do s=s and s*s*2 or 1;fJ=fJ+fP()*s end;local fI=fP()*s;ac[fA],ab[fA]=fI,fJ+fI*ar end end;if L==\"FFI\"then a8=D.new(\"uint32_t[?]\",#a8+1,0,unpack(a8))a7=D.new(\"int64_t[?]\",#a7+1,0,unpack(a7))if ar==0 then ab=D.new(\"uint32_t[?]\",#ab+1,0,unpack(ab))ac=D.new(\"uint32_t[?]\",#ac+1,0,unpack(ac))else ab=D.new(\"int64_t[?]\",#ab+1,0,unpack(ab))end end;local function fR(fK,fS)local aA,fT,fU={unpack(ad[fK])},0.0,\"\"local function fV(fW)if fW then if fU then fT=fT+#fW;local aC=0;if fU~=\"\"and#fU+#fW>=64 then aC=64-#fU;_(aA,fU..f(fW,1,aC),0,64)fU=\"\"end;local ax=#fW-aC;local fX=ax%64;_(aA,fW,aC,ax-fX)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then local fY={fU,\"\\128\",e(\"\\0\",(-9-fT)%64+1)}fU=nil;fT=fT*8/256^7;for az=4,10 do fT=fT%1*256;fY[az]=d(j(fT))end;fY=b(fY)_(aA,fY,0,#fY)local fZ=fK/32;for az=1,fZ do aA[az]=V(aA[az])end;aA=b(aA,\"\",1,fZ)end;return aA end end;if fS then return fV(fS)()else return fV end end;local function f_(fK,fS)local fT,fU,cc,cd=0.0,\"\",{unpack(ae[fK])},not aj and{unpack(af[fK])}local function fV(fW)if fW then if fU then fT=fT+#fW;local aC=0;if fU~=\"\"and#fU+#fW>=128 then aC=128-#fU;a0(cc,cd,fU..f(fW,1,aC),0,128)fU=\"\"end;local ax=#fW-aC;local fX=ax%128;a0(cc,cd,fW,aC,ax-fX)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then local fY={fU,\"\\128\",e(\"\\0\",(-17-fT)%128+9)}fU=nil;fT=fT*8/256^7;for az=4,10 do fT=fT%1*256;fY[az]=d(j(fT))end;fY=b(fY)a0(cc,cd,fY,0,#fY)local fZ=k(fK/64)if aj then for az=1,fZ do cc[az]=aj(cc[az])end else for az=1,fZ do cc[az]=V(cd[az])..V(cc[az])end;cd=nil end;cc=f(b(cc,\"\",1,fZ),1,fK/4)end;return cc end end;if fS then return fV(fS)()else return fV end end;local function g0(fS)local aA,fT,fU={unpack(ah,1,4)},0.0,\"\"local function fV(fW)if fW then if fU then fT=fT+#fW;local aC=0;if fU~=\"\"and#fU+#fW>=64 then aC=64-#fU;a1(aA,fU..f(fW,1,aC),0,64)fU=\"\"end;local ax=#fW-aC;local fX=ax%64;a1(aA,fW,aC,ax-fX)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then local fY={fU,\"\\128\",e(\"\\0\",(-9-fT)%64)}fU=nil;fT=fT*8;for az=4,11 do local g1=fT%256;fY[az]=d(g1)fT=(fT-g1)/256 end;fY=b(fY)a1(aA,fY,0,#fY)for az=1,4 do aA[az]=V(aA[az])end;aA=g(b(aA),\"(..)(..)(..)(..)\",\"%4%3%2%1\")end;return aA end end;if fS then return fV(fS)()else return fV end end;local function g2(fS)local aA,fT,fU={unpack(ah)},0.0,\"\"local function fV(fW)if fW then if fU then fT=fT+#fW;local aC=0;if fU~=\"\"and#fU+#fW>=64 then aC=64-#fU;a2(aA,fU..f(fW,1,aC),0,64)fU=\"\"end;local ax=#fW-aC;local fX=ax%64;a2(aA,fW,aC,ax-fX)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then local fY={fU,\"\\128\",e(\"\\0\",(-9-fT)%64+1)}fU=nil;fT=fT*8/256^7;for az=4,10 do fT=fT%1*256;fY[az]=d(j(fT))end;fY=b(fY)a2(aA,fY,0,#fY)for az=1,5 do aA[az]=V(aA[az])end;aA=b(aA)end;return aA end end;if fS then return fV(fS)()else return fV end end;local function g3(bl,g4,g5,fS)if type(g4)~=\"number\"then error(\"Argument 'digest_size_in_bytes' must be a number\",2)end;local fU,c0,c1=\"\",Z(),ar==0 and Z()local H;local function fV(fW)if fW then if fU then local aC=0;if fU~=\"\"and#fU+#fW>=bl then aC=bl-#fU;a3(c0,c1,fU..f(fW,1,aC),0,bl,bl)fU=\"\"end;local ax=#fW-aC;local fX=ax%bl;a3(c0,c1,fW,aC,ax-fX,bl)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then local g6=g5 and 31 or 6;fU=fU..(#fU+1==bl and d(g6+128)or d(g6)..e(\"\\0\",(-2-#fU)%bl)..\"\\128\")a3(c0,c1,fU,0,#fU,bl)fU=nil;local g7=0;local g8=j(bl/8)local g9={}local function ga(bn)if g7>=g8 then a3(c0,c1,\"\\0\\0\\0\\0\\0\\0\\0\\0\",0,8,8)g7=0 end;bn=j(l(bn,g8-g7))if ar~=0 then for az=1,bn do g9[az]=aj(c0[g7+az-1+ak])end else for az=1,bn do g9[az]=V(c1[g7+az])..V(c0[g7+az])end end;g7=g7+bn;return g(b(g9,\"\",1,bn),\"(..)(..)(..)(..)(..)(..)(..)(..)\",\"%8%7%6%5%4%3%2%1\"),bn*8 end;local gb={}local gc,gd=\"\",0;local function ge(gf)gf=gf or 1;if gf<=gd then gd=gd-gf;local gg=gf*2;local H=f(gc,1,gg)gc=f(gc,gg+1)return H end;local gh=0;if gd>0 then gh=1;gb[gh]=gc;gf=gf-gd end;while gf>=8 do local gi,gj=ga(gf/8)gh=gh+1;gb[gh]=gi;gf=gf-gj end;if gf>0 then gc,gd=ga(1)gh=gh+1;gb[gh]=ge(gf)else gc,gd=\"\",0 end;return b(gb,\"\",1,gh)end;if g4<0 then H=ge else H=ge(g4)end end;return H end end;if fS then return fV(fS)()else return fV end end;local gk,gl,gm,gn;do function gk(go)return g(go,\"%x%x\",function(gp)return d(tonumber(gp,16))end)end;function gl(gq)return g(gq,\".\",function(aH)return i(\"%02x\",c(aH))end)end;local gr={['+']=62,['-']=62,[62]='+',['/']=63,['_']=63,[63]='/',['=']=-1,['.']=-1,[-1]='='}local gs=0;for az,gt in ipairs{'AZ','az','09'}do for gu=c(gt),c(gt,2)do local gv=d(gu)gr[gv]=gs;gr[gs]=gv;gs=gs+1 end end;function gm(gq)local H={}for aF=1,#gq,3 do local gw,gx,gy,gz=c(f(gq,aF,aF+2)..'\\0',1,-1)H[#H+1]=gr[j(gw/4)]..gr[gw%4*16+j(gx/16)]..gr[gy and gx%16*4+j(gy/64)or-1]..gr[gz and gy%64 or-1]end;return b(H)end;function gn(gA)local H,gB={},3;for aF,gv in h(g(gA,'%s+',''),'()(.)')do local gC=gr[gv]if gC<0 then gB=gB-1;gC=0 end;local fA=aF%4;if fA>0 then H[-fA]=gC else local gw=H[-1]*4+j(H[-2]/16)local gx=H[-2]%16*16+j(H[-3]/4)local gy=H[-3]%4*64+gC;H[#H+1]=f(d(gw,gx,gy),1,gB)end end;return b(H)end end;local gD;local function gE(aB,fv,gF)return g(aB,\".\",function(aH)return d(W(c(aH),gF))end)..e(d(gF),fv-#aB)end;local function gG(gH,gI,fS)local gJ=gD[gH]if not gJ then error(\"Unknown hash function\",2)end;if#gI>gJ then gI=gk(gH(gI))end;local gK=gH()(gE(gI,gJ,0x36))local H;local function fV(fW)if not fW then H=H or gH(gE(gI,gJ,0x5C)..gk(gK()))return H elseif H then error(\"Adding more chunks is not allowed after receiving the result\",2)else gK(fW)return fV end end;if fS then return fV(fS)()else return fV end end;local function gL(gM,gN,cc,cd)local gO=gN==\"s\"and 16 or 32;local gP=#gM;if gP>gO then error(i(\"For BLAKE2%s/BLAKE2%sp/BLAKE2X%s the 'salt' parameter length must not exceed %d bytes\",gN,gN,gN,gO),2)end;if cc then local gQ,gR,gS=0,gN==\"s\"and 4 or 8,gN==\"s\"and O or X;for az=5,4+k(gP/gR)do local gT,gU;for I=1,gR,4 do gQ=gQ+4;local aG,E,aH,aI=c(gM,gQ-3,gQ)local gV=(((aI or 0)*256+(aH or 0))*256+(E or 0))*256+(aG or 0)gT,gU=gU,gV end;cc[az]=gS(cc[az],gT and gU*aq+gT or gU)if cd then cd[az]=gS(cd[az],gU)end end end end;local function gW(fS,gI,gM,g4,gX,gY)g4=g4 or 32;if g4<1 or g4>32 then error(\"BLAKE2s digest length must be from 1 to 32 bytes\",2)end;gI=gI or\"\"local gZ=#gI;if gZ>32 then error(\"BLAKE2s key length must not exceed 32 bytes\",2)end;gM=gM or\"\"local b7,fU,aA=0.0,\"\",{unpack(aa)}if gY then aA[1]=O(aA[1],g4)aA[2]=O(aA[2],0x20)aA[3]=O(aA[3],gY)aA[4]=O(aA[4],0x20000000+gX)else aA[1]=O(aA[1],0x01010000+gZ*256+g4)if gX then aA[4]=O(aA[4],gX)end end;if gM~=\"\"then gL(gM,\"s\",aA)end;local function fV(fW)if fW then if fU then local aC=0;if fU~=\"\"and#fU+#fW>64 then aC=64-#fU;b7=a4(aA,fU..f(fW,1,aC),0,64,b7)fU=\"\"end;local ax=#fW-aC;local fX=ax>0 and(ax-1)%64+1 or 0;b7=a4(aA,fW,aC,ax-fX,b7)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then if gY then a4(aA,nil,0,64,0,32)else a4(aA,fU..e(\"\\0\",64-#fU),0,64,b7,#fU)end;fU=nil;if not gX or gY then local fZ=k(g4/4)for az=1,fZ do aA[az]=V(aA[az])end;aA=f(g(b(aA,\"\",1,fZ),\"(..)(..)(..)(..)\",\"%4%3%2%1\"),1,g4*2)end end;return aA end end;if gZ>0 then fV(gI..e(\"\\0\",64-gZ))end;if gY then return fV()elseif fS then return fV(fS)()else return fV end end;local function g_(fS,gI,gM,g4,gX,gY)g4=j(g4 or 64)if g4<1 or g4>64 then error(\"BLAKE2b digest length must be from 1 to 64 bytes\",2)end;gI=gI or\"\"local gZ=#gI;if gZ>64 then error(\"BLAKE2b key length must not exceed 64 bytes\",2)end;gM=gM or\"\"local b7,fU,cc,cd=0.0,\"\",{unpack(a9)},not aj and{unpack(aa)}if gY then if cd then cc[1]=X(cc[1],g4)cd[1]=X(cd[1],0x40)cc[2]=X(cc[2],gY)cd[2]=X(cd[2],gX)else cc[1]=X(cc[1],0x40*aq+g4)cc[2]=X(cc[2],gX*aq+gY)end;cc[3]=X(cc[3],0x4000)else cc[1]=X(cc[1],0x01010000+gZ*256+g4)if gX then if cd then cd[2]=X(cd[2],gX)else cc[2]=X(cc[2],gX*aq)end end end;if gM~=\"\"then gL(gM,\"b\",cc,cd)end;local function fV(fW)if fW then if fU then local aC=0;if fU~=\"\"and#fU+#fW>128 then aC=128-#fU;b7=a5(cc,cd,fU..f(fW,1,aC),0,128,b7)fU=\"\"end;local ax=#fW-aC;local fX=ax>0 and(ax-1)%128+1 or 0;b7=a5(cc,cd,fW,aC,ax-fX,b7)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then if gY then a5(cc,cd,nil,0,128,0,64)else a5(cc,cd,fU..e(\"\\0\",128-#fU),0,128,b7,#fU)end;fU=nil;if gX and not gY then if cd then for az=8,1,-1 do cc[az*2]=cd[az]cc[az*2-1]=cc[az]end;return cc,16 end else local fZ=k(g4/8)if cd then for az=1,fZ do cc[az]=V(cd[az])..V(cc[az])end else for az=1,fZ do cc[az]=aj(cc[az])end end;cc=f(g(b(cc,\"\",1,fZ),\"(..)(..)(..)(..)(..)(..)(..)(..)\",\"%8%7%6%5%4%3%2%1\"),1,g4*2)end;cd=nil end;return cc end end;if gZ>0 then fV(gI..e(\"\\0\",128-gZ))end;if gY then return fV()elseif fS then return fV(fS)()else return fV end end;local function h0(fS,gI,gM,g4)g4=g4 or 32;if g4<1 or g4>32 then error(\"BLAKE2sp digest length must be from 1 to 32 bytes\",2)end;gI=gI or\"\"local gZ=#gI;if gZ>32 then error(\"BLAKE2sp key length must not exceed 32 bytes\",2)end;gM=gM or\"\"local h1,fT,h2,H={},0.0,0x02080000+gZ*256+g4;for az=1,8 do local b7,fU,aA=0.0,\"\",{unpack(aa)}h1[az]={b7,fU,aA}aA[1]=O(aA[1],h2)aA[3]=O(aA[3],az-1)aA[4]=O(aA[4],0x20000000)if gM~=\"\"then gL(gM,\"s\",aA)end end;local function fV(fW)if fW then if h1 then local h3=0;while true do local h4=l(h3+64-fT%64,#fW)if h4>h3 then local h5=h1[j(fT/64)%8+1]local h6=f(fW,h3+1,h4)fT,h3=fT+h4-h3,h4;local b7,fU=h5[1],h5[2]if#fU<64 then fU=fU..h6 else local aA=h5[3]b7=a4(aA,fU,0,64,b7)fU=h6 end;h5[1],h5[2]=b7,fU else break end end;return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if h1 then local h7={unpack(aa)}h7[1]=O(h7[1],h2)h7[4]=O(h7[4],0x20010000)if gM~=\"\"then gL(gM,\"s\",h7)end;for az=1,8 do local h5=h1[az]local b7,fU,aA=h5[1],h5[2],h5[3]a4(aA,fU..e(\"\\0\",64-#fU),0,64,b7,#fU,az==8)if az%2==0 then local h8=0;for q=az-1,az do local h5=h1[q]local aA=h5[3]for h9=1,8 do h8=h8+1;an[h8]=aA[h9]end end;a4(h7,nil,0,64,64*(az/2-1),az==8 and 64,az==8)end end;h1=nil;local fZ=k(g4/4)for az=1,fZ do h7[az]=V(h7[az])end;H=f(g(b(h7,\"\",1,fZ),\"(..)(..)(..)(..)\",\"%4%3%2%1\"),1,g4*2)end;return H end end;if gZ>0 then gI=gI..e(\"\\0\",64-gZ)for az=1,8 do fV(gI)end end;if fS then return fV(fS)()else return fV end end;local function ha(fS,gI,gM,g4)g4=g4 or 64;if g4<1 or g4>64 then error(\"BLAKE2bp digest length must be from 1 to 64 bytes\",2)end;gI=gI or\"\"local gZ=#gI;if gZ>64 then error(\"BLAKE2bp key length must not exceed 64 bytes\",2)end;gM=gM or\"\"local h1,fT,h2,H={},0.0,0x02040000+gZ*256+g4;for az=1,4 do local b7,fU,cc,cd=0.0,\"\",{unpack(a9)},not aj and{unpack(aa)}h1[az]={b7,fU,cc,cd}cc[1]=X(cc[1],h2)cc[2]=X(cc[2],az-1)cc[3]=X(cc[3],0x4000)if gM~=\"\"then gL(gM,\"b\",cc,cd)end end;local function fV(fW)if fW then if h1 then local h3=0;while true do local h4=l(h3+128-fT%128,#fW)if h4>h3 then local h5=h1[j(fT/128)%4+1]local h6=f(fW,h3+1,h4)fT,h3=fT+h4-h3,h4;local b7,fU=h5[1],h5[2]if#fU<128 then fU=fU..h6 else local cc,cd=h5[3],h5[4]b7=a5(cc,cd,fU,0,128,b7)fU=h6 end;h5[1],h5[2]=b7,fU else break end end;return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if h1 then local hb,hc={unpack(a9)},not aj and{unpack(aa)}hb[1]=X(hb[1],h2)hb[3]=X(hb[3],0x4001)if gM~=\"\"then gL(gM,\"b\",hb,hc)end;for az=1,4 do local h5=h1[az]local b7,fU,cc,cd=h5[1],h5[2],h5[3],h5[4]a5(cc,cd,fU..e(\"\\0\",128-#fU),0,128,b7,#fU,az==4)if az%2==0 then local h8=0;for q=az-1,az do local h5=h1[q]local cc,cd=h5[3],h5[4]for h9=1,8 do h8=h8+1;am[h8]=cc[h9]if cd then h8=h8+1;am[h8]=cd[h9]end end end;a5(hb,hc,nil,0,128,128*(az/2-1),az==4 and 128,az==4)end end;h1=nil;local fZ=k(g4/8)if aj then for az=1,fZ do hb[az]=aj(hb[az])end else for az=1,fZ do hb[az]=V(hc[az])..V(hb[az])end end;H=f(g(b(hb,\"\",1,fZ),\"(..)(..)(..)(..)(..)(..)(..)(..)\",\"%8%7%6%5%4%3%2%1\"),1,g4*2)end;return H end end;if gZ>0 then gI=gI..e(\"\\0\",128-gZ)for az=1,4 do fV(gI)end end;if fS then return fV(fS)()else return fV end end;local function hd(he,hf,hg,gJ,g4,fS,gI,gM)local hh,hi,hj=2^(gJ/2)-1;if g4==-1 then g4=n;hi=j(hh)hj=true else if g4<0 then g4=-1.0*g4;hj=true end;hi=j(g4)if hi>=hh then error(\"Requested digest is too long.  BLAKE2X\"..hf..\" finite digest is limited by (2^\"..j(gJ/2)..\")-2 bytes.  Hint: you can generate infinite digest.\",2)end end;gM=gM or\"\"if gM~=\"\"then gL(gM,hf)end;local hk=he(nil,gI,gM,nil,hi)local H;local function fV(fW)if fW then if hk then hk(fW)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if hk then local hl,hm=hk()hm,hk=hm or 8;local function hn(ho)local ax=l(gJ,g4-ho*gJ)if ax<=0 then return\"\"end;for az=1,hm do hg[az]=hl[az]end;for az=hm+1,2*hm do hg[az]=0 end;return he(nil,nil,gM,ax,hi,j(ho))end;local hp={}if hj then local aF,hq,hr,hs=0,gJ*2^32;local function ge(ht,hu)if ht==\"seek\"then aF=hu%hq else local ax,h8=ht or 1,0;while ax>0 do local hv=aF%gJ;local ho=(aF-hv)/gJ;local hw=l(ax,gJ-hv)if hr~=ho then hr=ho;hs=hn(ho)end;h8=h8+1;hp[h8]=f(hs,hv*2+1,(hv+hw)*2)ax=ax-hw;aF=(aF+hw)%hq end;return b(hp,\"\",1,h8)end end;H=ge else for az=1.0,k(g4/gJ)do hp[az]=hn(az-1.0)end;H=b(hp)end end;return H end end;if fS then return fV(fS)()else return fV end end;local function hx(g4,fS,gI,gM)return hd(gW,\"s\",an,32,g4,fS,gI,gM)end;local function hy(g4,fS,gI,gM)return hd(g_,\"b\",am,64,g4,fS,gI,gM)end;local function hz(fS,gI,g4,hA,aE,hB)gI=gI or\"\"g4=g4 or 32;hA=hA or 0;if gI==\"\"then aE=aE or aa else local gZ=#gI;if gZ>32 then error(\"BLAKE3 key length must not exceed 32 bytes\",2)end;gI=gI..e(\"\\0\",32-gZ)aE={}for az=1,8 do local aG,E,aH,aI=c(gI,4*az-3,4*az)aE[az]=((aI*256+aH)*256+E)*256+aG end;hA=hA+16 end;local fU,aA,cR,hC,hD,hE=\"\",{},0,0,0,{}local hF,hG,hj,H,cU=aE;local hH=3;local function hI(aB,aC,ax)while ax>0 do local hJ,hK,cS=1,0,aA;if hC==0 then hK=1;cS,hF=aE,aA;hH=2 elseif hC==15 then hK=2;hH=3;hF=aE else hJ=l(ax/64,15-hC)end;local hw=hJ*64;a6(aB,aC,hw,hA+hK,cR,cS,aA)aC,ax=aC+hw,ax-hw;hC=(hC+hJ)%16;if hC==0 then cR=cR+1.0;local hL=2.0;while cR%hL==0 do hL=hL*2.0;hD=hD-8;for az=1,8 do an[az]=hE[hD+az]end;for az=1,8 do an[az+8]=aA[az]end;a6(nil,0,64,hA+4,0,aE,aA)end;for az=1,8 do hE[hD+az]=aA[az]end;hD=hD+8 end end end;local function hn(ho)local ax=l(64,g4-ho*64)if ho<0 or ax<=0 then return\"\"end;if hj then for az=1,16 do an[az]=hE[az+16]end end;a6(nil,0,64,hH,ho,hF,hE,cU,hG)if hB then return hE end;local fZ=k(ax/4)for az=1,fZ do hE[az]=V(hE[az])end;return f(g(b(hE,\"\",1,fZ),\"(..)(..)(..)(..)\",\"%4%3%2%1\"),1,ax*2)end;local function fV(fW)if fW then if fU then local aC=0;if fU~=\"\"and#fU+#fW>64 then aC=64-#fU;hI(fU..f(fW,1,aC),0,64)fU=\"\"end;local ax=#fW-aC;local fX=ax>0 and(ax-1)%64+1 or 0;hI(fW,aC,ax-fX)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then hG=#fU;fU=fU..e(\"\\0\",64-#fU)if an[0]then for az=1,16 do local aG,E,aH,aI=c(fU,4*az-3,4*az)an[az]=N(P(aI,24),P(aH,16),P(E,8),aG)end else for az=1,16 do local aG,E,aH,aI=c(fU,4*az-3,4*az)an[az]=((aI*256+aH)*256+E)*256+aG end end;fU=nil;for hD=hD-8,0,-8 do a6(nil,0,64,hA+hH,cR,hF,aA,nil,hG)cR,hG,hF,hH=0,64,aE,4;for az=1,8 do an[az]=hE[hD+az]end;for az=1,8 do an[az+8]=aA[az]end end;hH=hA+hH+8;if g4<0 then if g4==-1 then g4=n else g4=-1.0*g4 end;hj=true;for az=1,16 do hE[az+16]=an[az]end end;g4=l(2^53,g4)cU=g4>32;if hj then local aF,hr,hs=0.0;local function ge(ht,hu)if ht==\"seek\"then aF=hu*1.0 else local ax,h8=ht or 1,32;while ax>0 do local hv=aF%64;local ho=(aF-hv)/64;local hw=l(ax,64-hv)if hr~=ho then hr=ho;hs=hn(ho)end;h8=h8+1;hE[h8]=f(hs,hv*2+1,(hv+hw)*2)ax=ax-hw;aF=aF+hw end;return b(hE,\"\",33,h8)end end;H=ge elseif g4<=64 then H=hn(0)else local hM=k(g4/64)-1;for ho=0.0,hM do hE[33+ho]=hn(ho)end;H=b(hE,\"\",33,33+hM)end end;return H end end;if fS then return fV(fS)()else return fV end end;local function hN(hO,hP,hQ)if type(hP)~=\"string\"then error(\"'context_string' parameter must be a Lua string\",2)end;local aE=hz(hP,nil,nil,32,nil,true)return hz(hO,nil,hQ,64,aE)end;local hR={md5=g0,sha1=g2,sha224=function(fS)return fR(224,fS)end,sha256=function(fS)return fR(256,fS)end,sha512_224=function(fS)return f_(224,fS)end,sha512_256=function(fS)return f_(256,fS)end,sha384=function(fS)return f_(384,fS)end,sha512=function(fS)return f_(512,fS)end,sha3_224=function(fS)return g3((1600-2*224)/8,224/8,false,fS)end,sha3_256=function(fS)return g3((1600-2*256)/8,256/8,false,fS)end,sha3_384=function(fS)return g3((1600-2*384)/8,384/8,false,fS)end,sha3_512=function(fS)return g3((1600-2*512)/8,512/8,false,fS)end,shake128=function(g4,fS)return g3((1600-2*128)/8,g4,true,fS)end,shake256=function(g4,fS)return g3((1600-2*256)/8,g4,true,fS)end,hmac=gG,hex_to_bin=gk,bin_to_hex=gl,base64_to_bin=gn,bin_to_base64=gm,hex2bin=gk,bin2hex=gl,base642bin=gn,bin2base64=gm,blake2b=g_,blake2s=gW,blake2bp=ha,blake2sp=h0,blake2xb=hy,blake2xs=hx,blake2=g_,blake2b_160=function(fS,gI,gM)return g_(fS,gI,gM,20)end,blake2b_256=function(fS,gI,gM)return g_(fS,gI,gM,32)end,blake2b_384=function(fS,gI,gM)return g_(fS,gI,gM,48)end,blake2b_512=g_,blake2s_128=function(fS,gI,gM)return gW(fS,gI,gM,16)end,blake2s_160=function(fS,gI,gM)return gW(fS,gI,gM,20)end,blake2s_224=function(fS,gI,gM)return gW(fS,gI,gM,28)end,blake2s_256=gW,blake3=hz,blake3_derive_key=hN}gD={[hR.md5]=64,[hR.sha1]=64,[hR.sha224]=64,[hR.sha256]=64,[hR.sha512_224]=128,[hR.sha512_256]=128,[hR.sha384]=128,[hR.sha512]=128,[hR.sha3_224]=144,[hR.sha3_256]=136,[hR.sha3_384]=104,[hR.sha3_512]=72}return hR\n",setuser=false,size=81085,modified=1757997042483,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["libccryptolib.a"]={permissions={root={read=true,write=true,execute=false}},created=1757997040009,data="!<arch>\n//              0           0     0     666     114       `\ninternal_curve25519.lua/\ninternal_edwards25519.lua/\ninternal_packing.lua/\ninternal_sha512.lua/\ninternal_util.lua/\naead.lua/       1722465588  0     0     775     1508      `\nlocal a=require\"system.expect\".expect;local b=require\"internal_util\".lassert;local c=require\"internal_packing\"local d=require\"chacha20\"local e=require\"poly1305\"local f,g=c.compilePack(\"<I8\")local h,i=c.compileUnpack(\"<I4I4I4I4\")local j=bit32.bxor;local function k(l,m,n,o,p)a(1,l,\"string\")b(#l==32,\"key length must be 32\",2)a(2,m,\"string\")b(#m==12,\"nonce length must be 12\",2)a(3,n,\"string\")a(4,o,\"string\")p=a(5,p,\"number\",\"nil\")or 20;b(p%2==0,\"round number must be even\",2)b(p>=8,\"round number must be no smaller than 8\",2)b(p<=20,\"round number must be no larger than 20\",2)local q=(\"\\0\"):rep(64)..n;local r=d.crypt(l,m,q,p,0)local s=r:sub(1,32)local t=r:sub(65)local u=(\"\\0\"):rep(-#o%16)local v=(\"\\0\"):rep(-#t%16)local w=f(\"<I8\",#o)local x=f(\"<I8\",#t)local y=o..u..t..v..w..x;local z=e.mac(s,y)return t,z end;local function A(l,m,z,t,o,p)a(1,l,\"string\")b(#l==32,\"key length must be 32\",2)a(2,m,\"string\")b(#m==12,\"nonce length must be 12\",2)a(3,z,\"string\")b(#z==16,\"tag length must be 16\",2)a(4,t,\"string\")a(5,o,\"string\")p=a(6,p,\"number\",\"nil\")or 20;b(p%2==0,\"round number must be even\",2)b(p>=8,\"round number must be no smaller than 8\",2)b(p<=20,\"round number must be no larger than 20\",2)local s=d.crypt(l,m,(\"\\0\"):rep(32),p,0)local u=(\"\\0\"):rep(-#o%16)local v=(\"\\0\"):rep(-#t%16)local w=f(g,#o)local x=f(g,#t)local y=o..u..t..v..w..x;local B,C,D,E=h(i,z,1)local F,G,H,I=h(i,e.mac(s,y),1)local J=j(B,F)+j(C,G)+j(D,H)+j(E,I)if J~=0 then return nil end;return d.crypt(l,m,t,p)end;return{encrypt=k,decrypt=A}\nblake3.lua/     1722465587  0     0     775     3468      `\nlocal a=require\"system.expect\".expect;local b=require\"internal_util\".lassert;local c=require\"internal_packing\"local unpack=unpack or table.unpack;local d=bit32.bxor;local e=bit32.lrotate;local f,g=c.compilePack(\"<I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\")local h=c.compileUnpack(g)local i,j=c.compileUnpack(\"<I4I4I4I4I4I4I4I4\")local k=0x01;local l=0x02;local m=0x04;local n=0x08;local o=0x10;local p=0x20;local q=0x40;local r={0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19}local function s(t,u,v,w,x,y)local z,A,B,C,D,E,F,G=unpack(t)local H,I,J,K=z,A,B,C;local L,M,N,O=D,E,F,G;local P,Q,R,S=0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a;local T=v%2^32;local U=(v-T)*2^-32;local V,W,X,Y,Z,_,a0,a1,a2,a3,a4,a5,a6,a7,a8,a9=unpack(u)local aa;for ab=1,7 do H=H+L+V;T=e(d(T,H),16)P=P+T;L=e(d(L,P),20)H=H+L+W;T=e(d(T,H),24)P=P+T;L=e(d(L,P),25)I=I+M+X;U=e(d(U,I),16)Q=Q+U;M=e(d(M,Q),20)I=I+M+Y;U=e(d(U,I),24)Q=Q+U;M=e(d(M,Q),25)J=J+N+Z;w=e(d(w,J),16)R=R+w;N=e(d(N,R),20)J=J+N+_;w=e(d(w,J),24)R=R+w;N=e(d(N,R),25)K=K+O+a0;x=e(d(x,K),16)S=S+x;O=e(d(O,S),20)K=K+O+a1;x=e(d(x,K),24)S=S+x;O=e(d(O,S),25)H=H+M+a2;x=e(d(x,H),16)R=R+x;M=e(d(M,R),20)H=H+M+a3;x=e(d(x,H),24)R=R+x;M=e(d(M,R),25)I=I+N+a4;T=e(d(T,I),16)S=S+T;N=e(d(N,S),20)I=I+N+a5;T=e(d(T,I),24)S=S+T;N=e(d(N,S),25)J=J+O+a6;U=e(d(U,J),16)P=P+U;O=e(d(O,P),20)J=J+O+a7;U=e(d(U,J),24)P=P+U;O=e(d(O,P),25)K=K+L+a8;w=e(d(w,K),16)Q=Q+w;L=e(d(L,Q),20)K=K+L+a9;w=e(d(w,K),24)Q=Q+w;L=e(d(L,Q),25)if ab~=7 then aa=X;X=Y;Y=a4;a4=a6;a6=a3;a3=a5;a5=_;_=V;V=aa;aa=a0;a0=Z;Z=a1;a1=a7;a7=a8;a8=a9;a9=a2;a2=W;W=aa end end;if y then return{d(H,P),d(I,Q),d(J,R),d(K,S),d(L,T),d(M,U),d(N,w),d(O,x),d(P,z),d(Q,A),d(R,B),d(S,C),d(T,D),d(U,E),d(w,F),d(x,G)}else return{d(H,P),d(I,Q),d(J,R),d(K,S),d(L,T),d(M,U),d(N,w),d(O,x)}end end;local function ac(ad,ae)for ab=1,8 do ad[ab+8]=ae[ab]end;return ad end;local function af(ag,ah,u,ai)local aj={}local ak=ag;local al=0;local am=0;local an=k;local ao=0;for ab=1,#u-64,64 do local ap={h(g,u,ab)}local aq=ah+an+ao;ak=s(ak,ap,al,64,aq)an=0;am=am+1;if am==15 then ao=l elseif am==16 then local ar=ak;local as=al+1;while as%2==0 do local ap=ac(table.remove(aj),ar)ar=s(ag,ap,0,64,ah+m)as=as/2 end;table.insert(aj,ar)ak=ag;al=al+1;am=0;an=k;ao=0 end end;local at=#u==0 and 0 or(#u-1)%64+1;local au=u:sub(-at)..(\"\\0\"):rep(64)local av={h(g,au,1)}local aw,ax,ay,az;if al>0 then local aq=ah+an+l;local ar=s(ak,av,al,at,aq)for ab=#aj,2,-1 do local ap=ac(aj[ab],ar)ar=s(ag,ap,0,64,ah+m)end;aw=ag;ax=ac(aj[1],ar)ay=64;az=ah+n+m else aw=ak;ax=av;ay=at;az=ah+an+l+n end;local aA={}for ab=0,ai/64 do local aB=s(aw,ax,ab,ay,az,true)aA[ab+1]=f(g,unpack(aB))end;return table.concat(aA):sub(1,ai)end;local function aC(aD,ai)a(1,aD,\"string\")ai=a(2,ai,\"number\",\"nil\")or 32;b(ai%1==0,\"desired output length must be an integer\",2)b(ai>=1,\"desired output length must be positive\",2)return af(r,0,aD,ai)end;local function aE(aF,aD,ai)a(1,aF,\"string\")b(#aF==32,\"key length must be 32\",2)a(2,aD,\"string\")ai=a(3,ai,\"number\",\"nil\")or 32;b(ai%1==0,\"desired output length must be an integer\",2)b(ai>=1,\"desired output length must be positive\",2)return af({i(j,aF,1)},o,aD,ai)end;local function aG(aH)a(1,aH,\"string\")local ag={i(j,af(r,p,aH,32),1)}return function(aI,ai)a(1,aI,\"string\")ai=a(2,ai,\"number\",\"nil\")or 32;b(ai%1==0,\"desired output length must be an integer\",2)b(ai>=1,\"desired output length must be positive\",2)return af(ag,q,aI,ai)end end;return{digest=aC,digestKeyed=aE,deriveKey=aG}\nchacha20.lua/   1722465587  0     0     775     2047      `\nlocal a=require\"system.expect\".expect;local b=require\"internal_util\".lassert;local c=require\"internal_packing\"local d=bit32.bxor;local e=bit32.lrotate;local f,g=c.compileUnpack(\"<I4I4I4I4I4I4I4I4\")local h,i=c.compileUnpack(\"<I4I4I4\")local j,k=c.compilePack(\"<I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\")local l=c.compileUnpack(k)local function m(n,o,p,q,r)a(1,n,\"string\")b(#n==32,\"key length must be 32\",2)a(2,o,\"string\")b(#o==12,\"nonce length must be 12\",2)a(3,p,\"string\")q=a(4,q,\"number\",\"nil\")or 20;b(q%2==0,\"round number must be even\",2)b(q>=8,\"round number must be no smaller than 8\",2)b(q<=20,\"round number must be no larger than 20\",2)r=a(5,r,\"number\",\"nil\")or 1;b(r%1==0,\"offset must be an integer\",2)b(r>=0,\"offset must be nonnegative\",2)b(#p+64*r<=2^38,\"offset too large\",2)local s,t,u,v=0x61707865,0x3320646e,0x79622d32,0x6b206574;local w,x,y,z,A,B,C,D=f(g,n,1)local E,F,G,H=r,h(i,o,1)local I=p..(\"\\0\"):rep(-#p%64)local J={}local K=1;for L=1,#I/64 do local M,N,O,P=s,t,u,v;local Q,R,S,T=w,x,y,z;local U,V,W,X=A,B,C,D;local Y,Z,_,a0=E,F,G,H;for a1=1,q,2 do M=M+Q;Y=e(d(Y,M),16)U=U+Y;Q=e(d(Q,U),12)M=M+Q;Y=e(d(Y,M),8)U=U+Y;Q=e(d(Q,U),7)N=N+R;Z=e(d(Z,N),16)V=V+Z;R=e(d(R,V),12)N=N+R;Z=e(d(Z,N),8)V=V+Z;R=e(d(R,V),7)O=O+S;_=e(d(_,O),16)W=W+_;S=e(d(S,W),12)O=O+S;_=e(d(_,O),8)W=W+_;S=e(d(S,W),7)P=P+T;a0=e(d(a0,P),16)X=X+a0;T=e(d(T,X),12)P=P+T;a0=e(d(a0,P),8)X=X+a0;T=e(d(T,X),7)M=M+R;a0=e(d(a0,M),16)W=W+a0;R=e(d(R,W),12)M=M+R;a0=e(d(a0,M),8)W=W+a0;R=e(d(R,W),7)N=N+S;Y=e(d(Y,N),16)X=X+Y;S=e(d(S,X),12)N=N+S;Y=e(d(Y,N),8)X=X+Y;S=e(d(S,X),7)O=O+T;Z=e(d(Z,O),16)U=U+Z;T=e(d(T,U),12)O=O+T;Z=e(d(Z,O),8)U=U+Z;T=e(d(T,U),7)P=P+Q;_=e(d(_,P),16)V=V+_;Q=e(d(Q,V),12)P=P+Q;_=e(d(_,P),8)V=V+_;Q=e(d(Q,V),7)end;local a2,a3,a4,a5,a6,a7,a8,a9;local aa,ab,ac,ad,ae,af,ag,ah;a2,a3,a4,a5,a6,a7,a8,a9,aa,ab,ac,ad,ae,af,ag,ah,K=l(k,I,K)J[L]=j(k,d(a2,M+s),d(a3,N+t),d(a4,O+u),d(a5,P+v),d(a6,Q+w),d(a7,R+x),d(a8,S+y),d(a9,T+z),d(aa,U+A),d(ab,V+B),d(ac,W+C),d(ad,X+D),d(ae,Y+E),d(af,Z+F),d(ag,_+G),d(ah,a0+H))E=E+1 end;return table.concat(J):sub(1,#p)end;return{crypt=m}\n\ned25519.lua/    1722465587  0     0     775     1243      `\nlocal a=require\"system.expect\".expect;local b=require\"internal_util\".lassert;local c=require\"internal_fq\"local d=require\"internal_sha512\"local e=require\"internal_edwards25519\"local f=require\"random\"local function g(h)a(1,h,\"string\")assert(#h==32,\"secret key length must be 32\")local i=d.digest(h)local j=c.decodeClamped(i:sub(1,32))return e.encode(e.mulG(c.bits(j)))end;local function k(h,l,m)a(1,h,\"string\")b(#h==32,\"secret key length must be 32\",2)a(2,l,\"string\")b(#l==32,\"public key length must be 32\",2)a(3,m,\"string\")local i=d.digest(h)local j=c.decodeClamped(i:sub(1,32))local n=c.decodeWide(f.random(64))local o=e.mulG(c.bits(n))local p=e.encode(o)local q=c.decodeWide(d.digest(p..l..m))local r=c.decodeWide(f.random(64))local s=c.sub(c.add(n,c.mul(c.add(j,r),q)),c.mul(r,q))local t=c.encode(s)return p..t end;local function u(l,m,v)a(1,l,\"string\")b(#l==32,\"public key length must be 32\",2)a(2,m,\"string\")a(3,v,\"string\")b(#v==64,\"signature length must be 64\",2)local w=e.decode(l)if not w then return false end;local p=v:sub(1,32)local t=v:sub(33)local q=c.decodeWide(d.digest(p..l..m))local x=e.mulG(c.bits(c.decode(t)))local y=e.mul(w,c.bits(q))local z=e.sub(x,e.niels(y))return e.encode(z)==p end;return{publicKey=g,sign=k,verify=u}\n\npoly1305.lua/   1722465588  0     0     775     2009      `\nlocal a=require\"system.expect\".expect;local b=require\"internal_util\".lassert;local c=require\"internal_packing\"local d,e=c.compileUnpack(\"<I4I4I4I4\")local f=c.compilePack(e)local function g(h,i)a(1,h,\"string\")b(#h==32,\"key length must be 32\",2)a(2,i,\"string\")local j=#i-15;if#i%16~=0 or#i==0 then i=i..\"\\1\"i=i..(\"\\0\"):rep(-#i%16)end;local k,l,m,n=d(e,h,1)k=k%2^28;l=(l-l%4)%2^28*2^32;m=(m-m%4)%2^28*2^64;n=(n-n%4)%2^28*2^96;local o=k%2^18;local p=k-o;local q=l%2^50;local r=l-q;local s=m%2^82;local t=m-s;local u=n%2^112;local v=n-u;local w=5/2^130*l;local x=5/2^130*m;local y=5/2^130*n;local z=w%2^-80;local A=w-z;local B=x%2^-48;local C=x-B;local D=y%2^-16;local E=y-D;local F,G,H,I,J,K,L,M=0,0,0,0,0,0,0,0;for N=1,#i,16 do local O,P,Q,R=d(e,i,N)local S=F+G+O;local T=H+I+P*2^32;local U=J+K+Q*2^64;local V=L+M+R*2^96;if N<=j then V=V+2^128 end;F=S*o+T*D+U*B+V*z;G=S*p+T*E+U*C+V*A;H=S*q+T*o+U*D+V*B;I=S*r+T*p+U*E+V*C;J=S*s+T*q+U*o+V*D;K=S*t+T*r+U*p+V*E;L=S*u+T*s+U*q+V*o;M=S*v+T*t+U*r+V*p;local W=F+3*2^69-3*2^69;F=F-W;G=G+W;local X=G+3*2^83-3*2^83;G=G-X;H=H+X;local Y=H+3*2^101-3*2^101;H=H-Y;I=I+Y;local Z=I+3*2^115-3*2^115;I=I-Z;J=J+Z;local _=J+3*2^133-3*2^133;J=J-_;K=K+_;local a0=K+3*2^147-3*2^147;K=K-a0;L=L+a0;local a1=L+3*2^163-3*2^163;L=L-a1;M=M+a1;local a2=M+3*2^181-3*2^181;M=M-a2;F=F+5/2^130*a2 end;local a3=F%2^16;G=F-a3+G;local a4=G%2^32;H=G-a4+H;local a5=H%2^48;I=H-a5+I;local a6=I%2^64;J=I-a6+J;local a7=J%2^80;K=J-a7+K;local a8=K%2^96;L=K-a8+L;local a9=L%2^112;M=L-a9+M;local aa=M%2^130;F=a3+5/2^130*(M-aa)a3=F%2^16;a4=F-a3+a4;if aa==0x3ffff*2^112 and a9==0xffff*2^96 and a8==0xffff*2^80 and a7==0xffff*2^64 and a6==0xffff*2^48 and a5==0xffff*2^32 and a4==0xffff*2^16 and a3>=0xfffb then aa,a9,a8,a7,a6,a5,a4,a3=0,0,0,0,0,0,0,a3-0xfffb end;local ab,ac,z,A=d(e,h,17)local ad=ab+a3+a4;local ae=ad%2^32;local af=ad-ae+ac*2^32+a5+a6;local ag=af%2^64;local ah=af-ag+z*2^64+a7+a8;local ai=ah%2^96;local aj=ah-ai+A*2^96+a9+aa;local ak=aj%2^128;return f(e,ae,ag/2^32,ai/2^64,ak/2^96)end;return{mac=g}\n\nrandom.lua/     1722465588  0     0     775     1531      `\nlocal a=require\"system.expect\".expect;local b=require\"blake3\"local c=require\"chacha20\"local d=require\"internal_util\"local e=d.lassert;local f;if KERNEL then f={\"ccryptolib 2023-04-11T19:43Z random.lua initialization context\",os.epoch(\"utc\"),os.epoch(\"ingame\"),math.random(0,2^24-1),math.random(0,2^24-1),tostring({}),tostring({})}else f={\"ccryptolib 2023-04-11T19:43Z random.lua initialization context\",os.time()*1000,os.time(\"ingame\")*1000,math.random(0,2^24-1),math.random(0,2^24-1),tostring({}),tostring({})}end;local g=b.digest(table.concat(f,\"|\"))local h=false;local function i(j)a(1,j,\"string\")g=b.digestKeyed(g,j)h=true end;local function k()return h end;local function l()local m;if KERNEL then assert(os.epoch(\"utc\")~=0)m=assert(load(\"local e=os.epoch return{\"..(\"e'utc',\"):rep(256)..\"}\"))else assert(os.time()~=0)m=assert(load(\"local e=os.time return{\"..(\"e(),\"):rep(256)..\"}\"))end;do local n=m()while n[256]-n[1]>1 do n=m()end end;local o={}for p=1,512 do local n=m()while n[256]==n[1]do n=m()end;for q=1,256 do if n[q]~=n[1]then o[p]=q-1;break end end end;local r={}for p=0,255 do r[p]=0 end;for p=1,#o do r[o[p]]=r[o[p]]+1 end;for p=0,255 do assert(r[p]<20)end;i(string.char(table.unpack(o)))end;local function s(t)a(1,t,\"string\")g=b.digestKeyed(g,t)end;local function u(v)a(1,v,\"number\")e(h,\"attempt to use an uninitialized random generator\",2)local w=(\"\\0\"):rep(math.max(v,0)+32)local x=(\"\\0\"):rep(12)local y=c.crypt(g,x,w,8,0)g=y:sub(1,32)return y:sub(33)end;return{init=i,isInit=k,initWithTiming=l,mix=s,random=u}\n\nsha256.lua/     1722465588  0     0     775     2074      `\nlocal a=require\"system.expect\".expect;local b=require\"internal_util\".lassert;local c=require\"internal_packing\"local d=bit32.lrotate;local e=bit32.rshift;local f=bit32.bxor;local g=bit32.bnot;local h=bit32.band;local unpack=unpack or table.unpack;local i,j=c.compilePack(\">I8\")local k,l=c.compilePack(\">I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\")local m=c.compileUnpack(l)local n,o=c.compilePack(\">I4I4I4I4I4I4I4I4\")local p=c.compileUnpack(o)local function q(r,s)local t={}local u=2;for v=1,r do t[v]=f(u^s%1*2^32)repeat u=u+1 until 2^u%u==2 end;return t end;local w=q(64,1/3)local x=q(8,1/2)local function y(z,A)local x,B,C,D,E,F,G,H=unpack(z)local w=w;for I=17,64 do local J=A[I-15]local K=A[I-2]local L=f(d(J,25),d(J,14),e(J,3))local M=f(d(K,15),d(K,13),e(K,10))A[I]=A[I-16]+L+A[I-7]+M end;local N,O,P,Q,R,S,T,z=x,B,C,D,E,F,G,H;for I=1,64 do local M=f(d(R,26),d(R,21),d(R,7))local U=f(h(R,S),h(g(R),T))local V=z+M+U+w[I]+A[I]local L=f(d(N,30),d(N,19),d(N,10))local W=f(h(N,O),h(N,P),h(O,P))local X=L+W;z=T;T=S;S=R;R=Q+V;Q=P;P=O;O=N;N=V+X end;return{(x+N)%2^32,(B+O)%2^32,(C+P)%2^32,(D+Q)%2^32,(E+R)%2^32,(F+S)%2^32,(G+T)%2^32,(H+z)%2^32}end;local function Y(Z)a(1,Z,\"string\")local _=#Z*8;local a0=-(#Z+9)%64;Z=Z..\"\\x80\"..(\"\\0\"):rep(a0)..i(j,_)local z=x;for v=1,#Z,64 do z=y(z,{m(l,Z,v)})end;return n(o,unpack(z))end;local a1=50;local function a2(a3,a4,a5,a6)a(1,a3,\"string\")a(2,a4,\"string\")a(3,a5,\"number\")b(a5%1==0,\"iteration number must be an integer\",2)b(a5>0,\"iteration number must be positive\",2)a(4,a6,\"function\",\"nil\")if#a3>64 then a3=Y(a3)end;a3={m(l,a3 ..(\"\\0\"):rep(64),1)}local a7={}local a8={}for v=1,16 do a7[v]=f(a3[v],0x36363636)a8[v]=f(a3[v],0x5c5c5c5c)end;local a9=y(x,a7)local aa=y(x,a8)local ab={2^31,0,0,0,0,0,0,0x300}local ac=k(l,unpack(a7))local ad={p(o,Y(ac..a4 ..\"\\0\\0\\0\\1\"),1)}for v=1,8 do ad[v+8]=ab[v]end;ad=y(aa,ad)local t={unpack(ad)}for v=2,a5 do for I=1,8 do ad[I+8]=ab[I]end;ad=y(a9,ad)for I=1,8 do ad[I+8]=ab[I]end;ad=y(aa,ad)for I=1,8 do t[I]=f(t[I],ad[I])end;if a6 and v%a1==0 then a6(v)end end;return n(o,unpack(t))end;return{digest=Y,pbkdf2=a2}\nutil.lua/       1722465588  0     0     775     508       `\nlocal a=require\"system.expect\".expect;local b=require\"random\"local c=require\"poly1305\"local function d(e)a(1,e,\"string\")return(\"%02x\"):rep(#e):format(e:byte(1,-1))end;local function f(g)a(1,g,\"string\")local h={}local i=0;for j in g:gmatch(\"%x%x\")do i=i+1;h[i]=tonumber(j,16)end;if 2*i==#g then return string.char(table.unpack(h))end end;local function k(l,m)a(1,l,\"string\")a(2,m,\"string\")if#l~=#m then return false end;local n=b.random(32)return c.mac(n,l)==c.mac(n,m)end;return{toHex=d,fromHex=f,compare=k}\nx25519.lua/     1722465588  0     0     775     498       `\nlocal a=require\"system.expect\".expect;local b=require\"internal_util\".lassert;local c=require\"internal_util\"local d=require\"internal_curve25519\"local function e(f)a(1,f,\"string\")assert(#f==32,\"secret key length must be 32\")return d.encode(d.scale(d.mulG(c.bits(f))))end;local function g(f,h)a(1,f,\"string\")b(#f==32,\"secret key length must be 32\",2)a(2,h,\"string\")b(#h==32,\"public key length must be 32\",2)return d.encode(d.scale(d.ladder8(d.decode(h),c.bits8(f))))end;return{publicKey=e,exchange=g}\nx25519c.lua/    1722465588  0     0     775     1905      `\nlocal a=require\"system.expect\".expect;local b=require\"internal_util\".lassert;local c=require\"internal_fq\"local d=require\"internal_fp\"local e=require\"internal_curve25519\"local f=require\"internal_sha512\"local g=require\"random\"local function h(i)a(1,i,\"string\")b(#i==32,\"secret key length must be 32\",2)local h=g.random(32)local j=c.decodeClamped(i)local k=c.decodeClamped(h)local l=c.sub(j,k)return c.encode(l)..h end;local function m(i)a(1,i,\"string\")b(#i==32,\"secret key length must be 32\",2)return h(f.digest(i):sub(1,32))end;local function n(o)a(1,o,\"string\")b(#o==64,\"masked secret key length must be 64\",2)local p=g.random(32)local l=c.decode(o:sub(1,32))local k=c.decodeClamped(o:sub(33))local q=c.decodeClamped(p)local r=c.add(l,c.sub(k,q))return c.encode(r)..p end;local function s(o)a(1,o,\"string\")b(#o==64,\"masked secret key length must be 64\",2)return o:sub(33)end;local function t(i,u)local l=c.decode(i:sub(1,32))local k=c.decodeClamped(i:sub(33))local v,w,x=e.prac(u,c.makeRuleset(c.eighth(k),c.eighth(l)))if not v then local y=d.encode(d.num(0))return y,y end;local z=e.dadd(x,v,w)local A,B=u[1],u[2]local C,D=z[1],z[2]local E,F=v[1],v[2]A,B=d.mul(A,B),d.square(B)C,D=d.mul(C,D),d.square(D)E,F=d.mul(E,F),d.square(F)local G=d.square(A)local H=d.square(B)local I=d.mul(A,B)local J=d.kmul(I,486662)local K=d.mul(A,d.add(G,d.carry(d.add(J,H))))local L=d.sqrtDiv(d.num(1),d.mul(d.mul(D,F),K))if not L then local y=d.encode(d.num(0))return y,y end;local M=d.mul(d.square(L),K)local N=d.mul(M,F)local O=d.mul(M,D)return d.encode(d.mul(C,N)),d.encode(d.mul(E,O))end;local function P(o)a(1,o,\"string\")b(#o==64,\"masked secret key length must be 64\",2)return t(o,e.G)end;local function Q(i,R)a(1,i,\"string\")b(#i==64,\"masked secret key length must be 64\",2)a(2,R,\"string\")b(#R==32,\"public key length must be 32\",2)return t(i,e.decode(R))end;return{mask=h,remask=n,publicKey=P,ephemeralSk=s,exchange=Q}\n\n/0              1722465587  0     0     775     2808      `\nlocal a=require\"internal_fp\"local b=require\"internal_edwards25519\"local c=require\"random\"local function d(e)local f,g=e[1],e[2]local h=a.add(f,g)local i=a.square(h)local j=a.sub(f,g)local k=a.square(j)local l=a.sub(i,k)local m=a.mul(i,k)local n=a.mul(l,a.add(k,a.kmul(l,121666)))return{m,n}end;local function o(p,e,q)local r,s=p[1],p[2]local f,g=e[1],e[2]local t,u=q[1],q[2]local h=a.add(f,g)local j=a.sub(f,g)local l=a.add(t,u)local v=a.sub(t,u)local w=a.mul(v,h)local x=a.mul(l,j)local m=a.mul(s,a.square(a.add(w,x)))local n=a.mul(r,a.square(a.sub(w,x)))return{m,n}end;local function y(p,e,q)local r,s=p[1],p[2]local f,g=e[1],e[2]local t,u=q[1],q[2]local h=a.add(f,g)local i=a.square(h)local j=a.sub(f,g)local k=a.square(j)local z=a.sub(i,k)local l=a.add(t,u)local v=a.sub(t,u)local w=a.mul(v,h)local x=a.mul(l,j)local A=a.mul(s,a.square(a.add(w,x)))local B=a.mul(r,a.square(a.sub(w,x)))local m=a.mul(i,k)local n=a.mul(z,a.add(k,a.kmul(z,121666)))return{m,n},{A,B}end;local function C(p,D)local E={a.num(1),a.num(0)}local F=p;for G=#D,1,-1 do if D[G]==0 then E,F=y(p,E,F)else F,E=y(p,F,E)end end;return E end;local function H(E,D)local I=a.decode(c.random(32))E={a.mul(E[1],I),a.mul(E[2],I)}return d(d(d(C(E,D))))end;local function J(E)return{a.mul(E[1],a.invert(E[2])),a.num(1)}end;local function K(E)return a.encode(E[1])end;local function L(M)return{a.decode(M),a.num(1)}end;local function N(M)local O=a.decode(M)local P=a.carry(a.add(a.num(1),O))local v=a.carry(a.sub(a.num(1),O))if a.eqz(v)then return{a.num(0),a.num(1)}else return{P,v}end end;local function Q(D)local E=b.mulG(D)local R,S=E[2],E[3]local T=a.carry(a.add(R,S))local U=a.carry(a.sub(S,R))return{T,U}end;local function V(E,W)local I=a.decode(c.random(32))local X={a.mul(E[1],I),a.mul(E[2],I)}local X=d(d(d(X)))if a.eqz(X[2])then return end;X=C(X,W[1])local Y=W[2]if#Y==0 then return end;local Z,_;local a0=Y[#Y]if a0==2 then local a1=d(X)X,Z,_=o(X,a1,X),X,a1 elseif a0==3 or a0==5 then X,Z,_=d(X),X,X elseif a0==6 then local a1=d(X)local a2=o(X,a1,X)X,Z,_=d(a2),X,o(X,a2,a1)elseif a0==7 then local a1=d(X)local a2=o(X,a1,X)local a3=d(a1)X,Z,_=o(a2,a3,X),X,a3 elseif a0==8 then local a1=d(X)local a2=o(X,a1,X)X,Z,_=d(a1),X,a2 else X,Z,_=X,d(X),X end;for G=#Y-1,1,-1 do local a0=Y[G]if a0==0 then X,Z=Z,X elseif a0==1 then local a4=o(_,X,Z)X,Z=o(Z,a4,X),o(X,a4,Z)elseif a0==2 then X,_=o(Z,o(_,X,Z),X),d(X)elseif a0==3 then X,_=o(_,X,Z),X elseif a0==5 then X,_=d(X),o(Z,X,_)elseif a0==6 then local a4=o(_,X,Z)local a5=d(a4)X,_=o(a4,a5,a4),o(o(X,a4,Z),a5,X)elseif a0==7 then local a4=o(_,X,Z)local a6=o(Z,a4,X)X,_=o(X,a6,a4),o(a4,a6,X)elseif a0==8 then local a7=d(X)X,_=o(_,a7,o(_,X,Z)),o(X,a7,X)else Z,_=d(Z),o(X,_,Z)end end;return X,Z,_ end;return{G={a.num(9),a.num(1)},dadd=o,scale=J,encode=K,decode=L,decodeEd=N,ladder8=H,mulG=Q,prac=V}\n/25             1722465587  0     0     775     3211      `\nlocal a=require\"internal_fp\"local unpack=unpack or table.unpack;local b=a.mul(a.num(-121665),a.invert(a.num(121666)))local c=a.kmul(b,2)local d={a.num(0),a.num(1),a.num(1),a.num(0)}local e=nil;local function f(g)local h,i,j=unpack(g)local k=a.square(h)local l=a.square(i)local m=a.square(j)local n=a.add(m,m)local o=a.add(k,l)local p=a.add(h,i)local q=a.square(p)local r=a.carry(a.sub(q,o))local s=a.sub(l,k)local t=a.carry(a.sub(n,s))local u=a.mul(r,t)local v=a.mul(s,o)local w=a.mul(t,s)local x=a.mul(r,o)return{u,v,w,x}end;local function y(g,z)local h,i,j,A=unpack(g)local B,C,D,E=unpack(z)local k=a.sub(i,h)local l=a.mul(k,C)local m=a.add(i,h)local n=a.mul(m,B)local o=a.mul(A,E)local p=a.mul(j,D)local q=a.sub(n,l)local r=a.sub(p,o)local s=a.add(p,o)local t=a.add(n,l)local u=a.mul(q,r)local v=a.mul(s,t)local w=a.mul(r,s)local x=a.mul(q,t)return{u,v,w,x}end;local function F(g,z)local h,i,j,A=unpack(g)local B,C,D,E=unpack(z)local k=a.sub(i,h)local l=a.mul(k,B)local m=a.add(i,h)local n=a.mul(m,C)local o=a.mul(A,E)local p=a.mul(j,D)local q=a.sub(n,l)local r=a.add(p,o)local s=a.sub(p,o)local t=a.add(n,l)local u=a.mul(q,r)local v=a.mul(s,t)local w=a.mul(r,s)local x=a.mul(q,t)return{u,v,w,x}end;local function G(g)local h,i,j,A=unpack(g)local H=a.add(i,h)local I=a.sub(i,h)local J=a.add(j,j)local K=a.mul(A,c)return{H,I,J,K}end;local function L(g)local h,i,j=unpack(g)local M=a.invert(j)local u=a.mul(h,M)local v=a.mul(i,M)local w=a.num(1)local x=a.mul(u,v)return{u,v,w,x}end;local function N(g)g=L(g)local h,i=unpack(g)local O=a.encode(i)local P=a.canonicalize(h)[1]%2;return O:sub(1,-2)..string.char(O:byte(-1)+P*128)end;local function Q(R)local v=a.decode(R)local k=a.square(v)local l=a.sub(k,a.num(1))local m=a.mul(k,b)local n=a.add(m,a.num(1))local u=a.sqrtDiv(l,n)if not u then return nil end;local P=a.canonicalize(u)[1]%2;if P~=bit32.extract(R:byte(-1),7)then u=a.carry(a.neg(u))end;local w=a.num(1)local x=a.mul(u,v)return{u,v,w,x}end;e=Q(\"Xfffffffffffffffffffffffffffffff\")local function S(T,U)local V=2^U;local W=V/2;local X={}local Y=0;local Z=1;for s=1,#T do Y=Y+T[s]*Z;Z=Z*2;while s==#T and Y>0 or Z>V do local _=Y%V;if _>=W then _=_-V end;Y=(Y-_)/V;Z=Z/V;X[#X+1]=_ end end;return X end;local function a0(a1,U)local X={}for s=1,math.ceil(256/U)do local a2={G(a1)}for t=2,2^U/2 do a1=y(a1,a2[1])a2[t]=G(a1)end;X[s]=a2;a1=f(a1)end;return X end;local a3=5;local a4=a0(e,a3)local function a5(T,U)local V=2^U;local W=V/2;local X={}local Y=0;local Z=1;for s=1,#T do Y=Y+T[s]*Z;Z=Z*2;while s==#T and Y>0 or Z>V do if Y%2==0 then Y=Y/2;Z=Z/2;X[#X+1]=0 else local _=Y%V;if _>=W then _=_-V end;Y=Y-_;X[#X+1]=_ end end end;while X[#X]==0 do X[#X]=nil end;return X end;local function a6(a1,U)local a7=f(a1)local X={G(a1)}for s=3,2^U,2 do X[s]=G(y(a7,X[s-2]))end;return X end;local function a8(T)local a9=S(T,a3)local aa=d;for s=1,#a9 do local l=a9[s]if l>0 then aa=y(aa,a4[s][l])elseif l<0 then aa=F(aa,a4[s][-l])end end;return aa end;local function Z(a1,T)local ab=a5(T,5)local ac=a6(a1,5)local aa=d;for s=#ab,1,-1 do local l=ab[s]if l==0 then aa=f(aa)elseif l>0 then aa=y(aa,ac[l])else aa=F(aa,ac[-l])end end;return aa end;return{double=f,add=y,sub=F,niels=G,scale=L,encode=N,decode=Q,mulG=a8,mul=Z}\n\ninternal_fp.lua/1722465587  0     0     775     6803      `\nlocal a=require\"internal_packing\"local unpack=unpack or table.unpack;local b,c=a.compileUnpack(\"<I3I3I2I3I3I2I3I3I2I3I3I2\")local d={0958640*2^0,0826664*2^22,1613251*2^43,1041528*2^64,0013673*2^85,0387171*2^107,1824679*2^128,0313839*2^149,0709440*2^170,0122635*2^192,0262782*2^213,0712905*2^234}local function e(f)return{f,0,0,0,0,0,0,0,0,0,0,0}end;local function g(h)local i,j,k,l,m,n,o,p,q,r,s,t=unpack(h)return{-i,-j,-k,-l,-m,-n,-o,-p,-q,-r,-s,-t}end;local function u(h,v)local i,j,k,l,m,n,o,p,q,r,s,t=unpack(h)local w,x,y,z,A,B,C,D,E,F,G,H=unpack(v)return{i+w,j+x,k+y,l+z,m+A,n+B,o+C,p+D,q+E,r+F,s+G,t+H}end;local function I(h,v)local i,j,k,l,m,n,o,p,q,r,s,t=unpack(h)local w,x,y,z,A,B,C,D,E,F,G,H=unpack(v)return{i-w,j-x,k-y,l-z,m-A,n-B,o-C,p-D,q-E,r-F,s-G,t-H}end;local function J(h)local i,j,k,l,m,n,o,p,q,r,s,t=unpack(h)local K,L,M,N,O,P,Q,R,S,T,U,V;V=t+3*2^306-3*2^306;i=i+19/2^255*V;K=i+3*2^73-3*2^73;j=j+K;L=j+3*2^94-3*2^94;k=k+L;M=k+3*2^115-3*2^115;l=l+M;N=l+3*2^136-3*2^136;m=m+N;O=m+3*2^158-3*2^158;n=n+O;P=n+3*2^179-3*2^179;o=o+P;Q=o+3*2^200-3*2^200;p=p+Q;R=p+3*2^221-3*2^221;q=q+R;S=q+3*2^243-3*2^243;r=r+S;T=r+3*2^264-3*2^264;s=s+T;U=s+3*2^285-3*2^285;t=t-V+U;V=t+3*2^306-3*2^306;return{i-K+19/2^255*V,j-L,k-M,l-N,m-O,n-P,o-Q,p-R,q-S,r-T,s-U,t-V}end;local function W(h)local i,j,k,l,m,n,o,p,q,r,s,t=unpack(h)local K,L,M,N,O,P,Q,R,S,T,U,V;K=i%2^22;j=i-K+j;L=j%2^43;k=j-L+k;M=k%2^64;l=k-M+l;N=l%2^85;m=l-N+m;O=m%2^107;n=m-O+n;P=n%2^128;o=n-P+o;Q=o%2^149;p=o-Q+p;R=p%2^170;q=p-R+q;S=q%2^192;r=q-S+r;T=r%2^213;s=r-T+s;U=s%2^234;t=s-U+t;V=t%2^255;K=K+19/2^255*(t-V)if V/2^234==2^21-1 and U/2^213==2^21-1 and T/2^192==2^21-1 and S/2^170==2^22-1 and R/2^149==2^21-1 and Q/2^128==2^21-1 and P/2^107==2^21-1 and O/2^85==2^22-1 and N/2^64==2^21-1 and M/2^43==2^21-1 and L/2^22==2^21-1 and K>=2^22-19 then return{19-2^22+K,0,0,0,0,0,0,0,0,0,0,0}else return{K,L,M,N,O,P,Q,R,S,T,U,V}end end;local function X(h,v)local Y=W(I(h,v))for Z=1,12 do if Y[Z]~=0 then return false end end;return true end;local function _(h,v)local i,j,k,l,m,n,o,p,q,r,s,t=unpack(h)local w,x,y,z,A,B,C,D,E,F,G,H=unpack(v)local K,L,M,N,O,P,Q,R,S,T,U,V;K=t*x+s*y+r*z+q*A+p*B+o*C+n*D+m*E+l*F+k*G+j*H;L=t*y+s*z+r*A+q*B+p*C+o*D+n*E+m*F+l*G+k*H;M=t*z+s*A+r*B+q*C+p*D+o*E+n*F+m*G+l*H;N=t*A+s*B+r*C+q*D+p*E+o*F+n*G+m*H;O=t*B+s*C+r*D+q*E+p*F+o*G+n*H;P=t*C+s*D+r*E+q*F+p*G+o*H;Q=t*D+s*E+r*F+q*G+p*H;R=t*E+s*F+r*G+q*H;S=t*F+s*G+r*H;T=t*G+s*H;U=t*H;K=K*19/2^255+i*w;L=L*19/2^255+j*w+i*x;M=M*19/2^255+k*w+j*x+i*y;N=N*19/2^255+l*w+k*x+j*y+i*z;O=O*19/2^255+m*w+l*x+k*y+j*z+i*A;P=P*19/2^255+n*w+m*x+l*y+k*z+j*A+i*B;Q=Q*19/2^255+o*w+n*x+m*y+l*z+k*A+j*B+i*C;R=R*19/2^255+p*w+o*x+n*y+m*z+l*A+k*B+j*C+i*D;S=S*19/2^255+q*w+p*x+o*y+n*z+m*A+l*B+k*C+j*D+i*E;T=T*19/2^255+r*w+q*x+p*y+o*z+n*A+m*B+l*C+k*D+j*E+i*F;U=U*19/2^255+s*w+r*x+q*y+p*z+o*A+n*B+m*C+l*D+k*E+j*F+i*G;V=t*w+s*x+r*y+q*z+p*A+o*B+n*C+m*D+l*E+k*F+j*G+i*H;s=U+3*2^285-3*2^285;V=V+s;t=V+3*2^306-3*2^306;K=K+19/2^255*t;i=K+3*2^73-3*2^73;L=L+i;j=L+3*2^94-3*2^94;M=M+j;k=M+3*2^115-3*2^115;N=N+k;l=N+3*2^136-3*2^136;O=O+l;m=O+3*2^158-3*2^158;P=P+m;n=P+3*2^179-3*2^179;Q=Q+n;o=Q+3*2^200-3*2^200;R=R+o;p=R+3*2^221-3*2^221;S=S+p;q=S+3*2^243-3*2^243;T=T+q;r=T+3*2^264-3*2^264;U=U-s+r;s=U+3*2^285-3*2^285;V=V-t+s;t=V+3*2^306-3*2^306;return{K-i+19/2^255*t,L-j,M-k,N-l,O-m,P-n,Q-o,R-p,S-q,T-r,U-s,V-t}end;local function a0(h)local i,j,k,l,m,n,o,p,q,r,s,t=unpack(h)local a1,a2,a3,a4,a5,a6,a7,a8,a9,aa,ab;local K,L,M,N,O,P,Q,R,S,T,U,V;a1=i+i;a2=j+j;a3=k+k;a4=l+l;a5=m+m;a6=n+n;a7=o+o;a8=p+p;a9=q+q;aa=r+r;ab=s+s;K=t*a2+s*a3+r*a4+q*a5+p*a6+o*o;L=t*a3+s*a4+r*a5+q*a6+p*a7;M=t*a4+s*a5+r*a6+q*a7+p*p;N=t*a5+s*a6+r*a7+q*a8;O=t*a6+s*a7+r*a8+q*q;P=t*a7+s*a8+r*a9;Q=t*a8+s*a9+r*r;R=t*a9+s*aa;S=t*aa+s*s;T=t*ab;U=t*t;K=K*19/2^255+i*i;L=L*19/2^255+j*a1;M=M*19/2^255+k*a1+j*j;N=N*19/2^255+l*a1+k*a2;O=O*19/2^255+m*a1+l*a2+k*k;P=P*19/2^255+n*a1+m*a2+l*a3;Q=Q*19/2^255+o*a1+n*a2+m*a3+l*l;R=R*19/2^255+p*a1+o*a2+n*a3+m*a4;S=S*19/2^255+q*a1+p*a2+o*a3+n*a4+m*m;T=T*19/2^255+r*a1+q*a2+p*a3+o*a4+n*a5;U=U*19/2^255+s*a1+r*a2+q*a3+p*a4+o*a5+n*n;V=t*a1+s*a2+r*a3+q*a4+p*a5+o*a6;s=U+3*2^285-3*2^285;V=V+s;t=V+3*2^306-3*2^306;K=K+19/2^255*t;i=K+3*2^73-3*2^73;L=L+i;j=L+3*2^94-3*2^94;M=M+j;k=M+3*2^115-3*2^115;N=N+k;l=N+3*2^136-3*2^136;O=O+l;m=O+3*2^158-3*2^158;P=P+m;n=P+3*2^179-3*2^179;Q=Q+n;o=Q+3*2^200-3*2^200;R=R+o;p=R+3*2^221-3*2^221;S=S+p;q=S+3*2^243-3*2^243;T=T+q;r=T+3*2^264-3*2^264;U=U-s+r;s=U+3*2^285-3*2^285;V=V-t+s;t=V+3*2^306-3*2^306;return{K-i+19/2^255*t,L-j,M-k,N-l,O-m,P-n,Q-o,R-p,S-q,T-r,U-s,V-t}end;local function ac(h,ad)local i,j,k,l,m,n,o,p,q,r,s,t=unpack(h)local K,L,M,N,O,P,Q,R,S,T,U,V;i=i*ad;j=j*ad;k=k*ad;l=l*ad;m=m*ad;n=n*ad;o=o*ad;p=p*ad;q=q*ad;r=r*ad;s=s*ad;t=t*ad;V=t+3*2^306-3*2^306;i=i+19/2^255*V;K=i+3*2^73-3*2^73;j=j+K;L=j+3*2^94-3*2^94;k=k+L;M=k+3*2^115-3*2^115;l=l+M;N=l+3*2^136-3*2^136;m=m+N;O=m+3*2^158-3*2^158;n=n+O;P=n+3*2^179-3*2^179;o=o+P;Q=o+3*2^200-3*2^200;p=p+Q;R=p+3*2^221-3*2^221;q=q+R;S=q+3*2^243-3*2^243;r=r+S;T=r+3*2^264-3*2^264;s=s+T;U=s+3*2^285-3*2^285;t=t-V+U;V=t+3*2^306-3*2^306;return{i-K+19/2^255*V,j-L,k-M,l-N,m-O,n-P,o-Q,p-R,q-S,r-T,s-U,t-V}end;local function ae(h,f)for af=1,f do h=a0(h)end;return h end;local function ag(h)local ah=a0(h)local ai=_(h,ae(ah,2))local t=_(ai,ah)local aj=_(a0(t),ai)local ak=_(ae(aj,5),aj)local al=_(ae(ak,10),ak)local am=_(ae(al,20),al)local an=_(ae(am,10),ak)local ao=_(ae(an,50),an)local ap=_(ae(ao,100),ao)local aq=_(ae(ap,50),an)return _(ae(aq,5),t)end;local function ar(as,at)as=J(as)local au=a0(at)local av=_(at,au)local aw=a0(av)local ax=_(at,aw)local ay=_(as,ax)local az=_(a0(ay),ay)local aA=_(ae(az,2),az)local aB=_(ae(aA,4),aA)local aC=_(ae(aB,8),aB)local aD=_(ae(aC,2),az)local aE=_(ae(aC,16),aC)local an=_(ae(aE,18),aD)local ao=_(ae(an,50),an)local ap=_(ae(ao,100),ao)local aq=_(ae(ap,50),an)local aF=_(ae(aq,2),ay)local aG=_(as,av)local v=_(aG,aF)local aH=a0(v)local aI=_(at,aH)if not X(aI,as)then v=_(v,d)aH=a0(v)aI=_(at,aH)end;if X(aI,as)then return v else return nil end end;local function aJ(h)h=W(h)local i,j,k,l,m,n,o,p,q,r,s,t=unpack(h)local aK={}local aL=i;local function aM(f)for af=1,f do local aN=aL%256;aK[#aK+1]=aN;aL=(aL-aN)/256 end end;aM(2)aL=aL+j/2^16;aM(3)aL=aL+k/2^40;aM(3)aL=aL+l/2^64;aM(2)aL=aL+m/2^80;aM(3)aL=aL+n/2^104;aM(3)aL=aL+o/2^128;aM(2)aL=aL+p/2^144;aM(3)aL=aL+q/2^168;aM(3)aL=aL+r/2^192;aM(2)aL=aL+s/2^208;aM(3)aL=aL+t/2^232;aM(3)return string.char(unpack(aK))end;local function aO(v)local aP,aQ,aR,aS,aT,aU,aV,aW,aX,aY,aZ,a_=b(c,v,1)a_=a_%2^15;return J{aP,aQ*2^24,aR*2^48,aS*2^64,aT*2^88,aU*2^112,aV*2^128,aW*2^152,aX*2^176,aY*2^192,aZ*2^216,a_*2^240}end;local function b0(h)local Y=W(h)local K,L,M,N,O,P,Q,R,S,T,U,V=unpack(Y)return K+L+M+N+O+P+Q+R+S+T+U+V==0 end;return{num=e,neg=g,add=u,sub=I,kmul=ac,mul=_,canonicalize=W,square=a0,carry=J,invert=ag,sqrtDiv=ar,encode=aJ,decode=aO,eqz=b0}\n\ninternal_fq.lua/1722465587  0     0     775     3077      `\nlocal a=require\"internal_mp\"local b=require\"internal_util\"local c=require\"internal_packing\"local unpack=unpack or table.unpack;local d,e=c.compilePack(\"<I3I3I3I3I3I3I3I3I3I3I2\")local f=c.compileUnpack(e)local g,h=c.compileUnpack(\"<I3I3I3I3I3I3I3I3I3I3I3\")local i,j=c.compileUnpack(\"<I3I3I3I3I3I3I3I3I3I3I1\")local k={16110573,06494812,14047250,10680220,14612958,00000020,00000000,00000000,00000000,00000000,00004096}local l={05537307,01942290,16765621,16628356,10618610,07072433,03735459,01369940,15276086,13038191,13409718}local m={11711996,01747860,08326961,03814718,01859974,13327461,16105061,07590423,04050668,08138906,00000283}local n={5110253,3039345,2503500,11779568,15416472,16766550,16777215,16777215,16777215,16777215,4095}local o=a.num(0)local function p(q)local r=a.sub(q,k)if a.approx(r)<0 then return a.carry(q)end;return a.carry(r)end;local function s(q,t)return p(a.add(q,t))end;local function u(q)return p(a.sub(k,q))end;local function v(q,t)return s(q,u(t))end;local function w(q,t)local x,y=a.mul(q,t)local z,A=a.mul(a.lmul(x,l),k)local B,C=a.dwadd(x,y,z,A)return p(C)end;local function D(q)return w(q,m)end;local function E(q)local z,A=a.mul(a.lmul(q,l),k)local B,C=a.dwadd(q,o,z,A)return p(C)end;local function F(q)return d(e,unpack(E(q)))end;local function G(H)local I={f(e,H,1)}I[12]=nil;return D(I)end;local function J(H)local K={g(h,H,1)}K[12]=nil;local L={i(j,H,34)}L[12]=nil;return s(D(K),D(D(L)))end;local function M(H)local N={f(e,H,1)}N[12]=nil;N[1]=bit32.band(N[1],0xfffff8)N[11]=bit32.band(N[11],0x7fff)N[11]=bit32.bor(N[11],0x4000)return D(N)end;local function O(q)return w(q,n)end;local function P(q)local Q=b.rebaseLE(E(q),2^24,2)for R=254,289 do Q[R]=nil end;return Q end;local function S(q,t)local T=E(q)local U=E(t)local V=a.sub(T,U)local W=a.mod2(T)local X=a.mod2(U)local Y=a.mod3(T)local Z=a.mod3(U)local _=a.approx(U)local a0=a.approx(V)local a1={[0]=0,2,1}local a2={}while a0~=0 do if a0<0 then a2[#a2+1]=0;T,U=U,T;W,X=X,W;Y,Z=Z,Y;_=a.approx(U)V=a.sub(T,U)a0=-a0 elseif 4*a0<_ and Y==a1[Z]then a2[#a2+1]=1;T,U=a.third(a.add(T,V)),a.third(a.sub(U,V))W,X=X,W;Y,Z=a.mod3(T),a.mod3(U)_=a.approx(U)elseif 4*a0<_ and W==X and Y==Z then a2[#a2+1]=2;T=a.half(V)W=a.mod2(T)Y=a1[(Y-Z)%3]V=a.sub(T,U)a0=a.approx(V)elseif a0<3*_ then a2[#a2+1]=3;T=a.carryWeak(V)W=(W-X)%2;Y=(Y-Z)%3;V=a.sub(T,U)a0=a.approx(V)elseif W==X then a2[#a2+1]=2;T=a.half(V)W=a.mod2(T)Y=a1[(Y-Z)%3]V=a.sub(T,U)a0=a.approx(V)elseif W==0 then a2[#a2+1]=5;T=a.half(T)W=a.mod2(T)Y=a1[Y]V=a.sub(T,U)a0=a.approx(V)elseif Y==0 then a2[#a2+1]=6;T=a.carryWeak(a.sub(a.third(T),U))W=(W-X)%2;Y=a.mod3(T)V=a.sub(T,U)a0=a.approx(V)elseif Y==a1[Z]then a2[#a2+1]=7;T=a.third(a.sub(V,U))Y=a.mod3(T)V=a.sub(T,U)a0=a.approx(V)elseif Y==Z then a2[#a2+1]=8;T=a.third(V)W=(W-X)%2;Y=a.mod3(T)V=a.sub(T,U)a0=a.approx(V)else a2[#a2+1]=9;U=a.half(U)X=a.mod2(U)Z=a1[Z]_=a.approx(U)V=a.sub(T,U)a0=a.approx(V)end end;local a3=b.rebaseLE(T,2^24,2)while a3[#a3]==0 do a3[#a3]=nil end;return{a3,a2}end;return{add=s,sub=v,mul=w,encode=F,decode=G,decodeWide=J,decodeClamped=M,eighth=O,bits=P,makeRuleset=S}\n\ninternal_mp.lua/1722465588  0     0     775     3120      `\nlocal unpack=unpack or table.unpack;local function a(b)local c,d,e,f,g,h,i,j,k,l,m=unpack(b)local n=c+3*2^75-3*2^75;d=d+n*2^-24;local o=d+3*2^75-3*2^75;e=e+o*2^-24;local p=e+3*2^75-3*2^75;f=f+p*2^-24;local q=f+3*2^75-3*2^75;g=g+q*2^-24;local r=g+3*2^75-3*2^75;h=h+r*2^-24;local s=h+3*2^75-3*2^75;i=i+s*2^-24;local t=i+3*2^75-3*2^75;j=j+t*2^-24;local u=j+3*2^75-3*2^75;k=k+u*2^-24;local v=k+3*2^75-3*2^75;l=l+v*2^-24;local w=l+3*2^75-3*2^75;m=m+w*2^-24;local x=m+3*2^75-3*2^75;return{c-n,d-o,e-p,f-q,g-r,h-s,i-t,j-u,k-v,l-w,m-x},x*2^-24 end;local function y(b)local c,d,e,f,g,h,i,j,k,l,m=unpack(b)local z=c%2^24;d=d+(c-z)*2^-24;local A=d%2^24;e=e+(d-A)*2^-24;local B=e%2^24;f=f+(e-B)*2^-24;local C=f%2^24;g=g+(f-C)*2^-24;local D=g%2^24;h=h+(g-D)*2^-24;local E=h%2^24;i=i+(h-E)*2^-24;local F=i%2^24;j=j+(i-F)*2^-24;local G=j%2^24;k=k+(j-G)*2^-24;local H=k%2^24;l=l+(k-H)*2^-24;local I=l%2^24;m=m+(l-I)*2^-24;local J=m%2^24;local x=(m-J)*2^-24;return{z,A,B,C,D,E,F,G,H,I,J},x end;local function K(b,L)local c,d,e,f,g,h,i,j,k,l,m=unpack(b)local M,N,O,P,Q,R,S,T,U,V,W=unpack(L)return{c+M,d+N,e+O,f+P,g+Q,h+R,i+S,j+T,k+U,l+V,m+W}end;local function X(b,L)local c,d,e,f,g,h,i,j,k,l,m=unpack(b)local M,N,O,P,Q,R,S,T,U,V,W=unpack(L)return{c-M,d-N,e-O,f-P,g-Q,h-R,i-S,j-T,k-U,l-V,m-W}end;local function Y(b,L)local c,d,e,f,g,h,i,j,k,l,m=unpack(b)local M,N,O,P,Q,R,S,T,U,V,W=unpack(L)return y{c*M,d*M+c*N,e*M+d*N+c*O,f*M+e*N+d*O+c*P,g*M+f*N+e*O+d*P+c*Q,h*M+g*N+f*O+e*P+d*Q+c*R,i*M+h*N+g*O+f*P+e*Q+d*R+c*S,j*M+i*N+h*O+g*P+f*Q+e*R+d*S+c*T,k*M+j*N+i*O+h*P+g*Q+f*R+e*S+d*T+c*U,l*M+k*N+j*O+i*P+h*Q+g*R+f*S+e*T+d*U+c*V,m*M+l*N+k*O+j*P+i*Q+h*R+g*S+f*T+e*U+d*V+c*W}end;local function Z(b,L)local _,a0=Y(b,L)local a1,d,e,f,g,h,i,j,k,l,m=unpack(b)local a1,N,O,P,Q,R,S,T,U,V,W=unpack(L)return _,y{a0+m*N+l*O+k*P+j*Q+i*R+h*S+g*T+f*U+e*V+d*W,m*O+l*P+k*Q+j*R+i*S+h*T+g*U+f*V+e*W,m*P+l*Q+k*R+j*S+i*T+h*U+g*V+f*W,m*Q+l*R+k*S+j*T+i*U+h*V+g*W,m*R+l*S+k*T+j*U+i*V+h*W,m*S+l*T+k*U+j*V+i*W,m*T+l*U+k*V+j*W,m*U+l*V+k*W,m*V+l*W,m*W,0}end;local function a2(a3,a4,a5,a6)local _,a7=y(K(a3,a5))local a8=K(a4,a6)a8[1]=a8[1]+a7;return _,y(a8)end;local function a9(b)local c,d,e,f,g,h,i,j,k,l,m=unpack(b)return a{c*0.5+d*2^23,e*2^23,f*2^23,g*2^23,h*2^23,i*2^23,j*2^23,k*2^23,l*2^23,m*2^23,0}end;local function aa(b)local c,d,e,f,g,h,i,j,k,l,m=unpack(b)local ab=c*0xaaaaaa;local ac=d*0xaaaaaa+ab;local ad=e*0xaaaaaa+ac;local ae=f*0xaaaaaa+ad;local af=g*0xaaaaaa+ae;local ag=h*0xaaaaaa+af;local ah=i*0xaaaaaa+ag;local ai=j*0xaaaaaa+ah;local aj=k*0xaaaaaa+ai;local ak=l*0xaaaaaa+aj;local al=m*0xaaaaaa+ak;return a{c+ab,d+ac,e+ad,f+ae,g+af,h+ag,i+ah,j+ai,k+aj,l+ak,m+al}end;local function am(b)return b[1]%2 end;local function an(b)local c,d,e,f,g,h,i,j,k,l,m=unpack(b)return(c+d+e+f+g+h+i+j+k+l+m)%3 end;local function ao(b)local c,d,e,f,g,h,i,j,k,l,m=unpack(b)return c+d*2^24+e*2^48+f*2^72+g*2^96+h*2^120+i*2^144+j*2^168+k*2^192+l*2^216+m*2^240 end;local function ap(b,L)return ao(X(b,L))end;local function aq(b)return{b,0,0,0,0,0,0,0,0,0,0}end;return{carry=y,carryWeak=a,add=K,sub=X,dwadd=a2,lmul=Y,mul=Z,half=a9,third=aa,mod2=am,mod3=an,approx=ao,cmp=ap,num=aq}\n/52             1722465588  0     0     775     1676      `\nlocal a=string.format;local function b(c,d)local e=\"local C=string.char return function(_,\"local f=0;for g=1,#c do e=e..a(\"n%d,\",g)f=f+c[g]end;e=e:sub(1,-2)..\")local \"for g=1,f do e=e..a(\"b%d,\",g)end;e=e:sub(1,-2)..\" \"local h=1;for g=1,#c do for i=1,c[g]-1 do e=e..a(\"b%d=n%d%%2^8 n%d=(n%d-b%d)*2^-8 \",h,g,g,g,h)h=h+1 end;h=h+1 end;e=e..\"return C(\"h=1;if not d then for g=1,#c do for i=1,c[g]-1 do e=e..a(\"b%d,\",h)h=h+1 end;e=e..a(\"n%d%%2^8,\",g)h=h+1 end else for g=1,#c do e=e..a(\"n%d%%2^8,\",g)h=h+c[g]-2;for i=1,c[g]-1 do e=e..a(\"b%d,\",h)h=h-1 end;h=h+c[g]+1 end end;e=e:sub(1,-2)..\")end\"return load(e)()end;local function j(c,d)local e=\"local B=string.byte return function(_,s,i)local \"local h=1;if not d then for g=1,#c do for i=1,c[g]do e=e..a(\"b%d,\",h)h=h+1 end end else for g=1,#c do h=h+c[g]-1;for i=1,c[g]do e=e..a(\"b%d,\",h)h=h-1 end;h=h+c[g]+1 end end;e=e:sub(1,-2)..a(\"=B(s,i,i+%d)return \",h-2)h=1;for g=1,#c do e=e..a(\"b%d\",h)h=h+1;for k=2,c[g]do e=e..a(\"+b%d*2^%d\",h,8*k-8)h=h+1 end;e=e..\",\"end;e=e..a(\"i+%d end\",h-1)return load(e)()end;if not string.pack or pcall(string.dump,string.pack)then local function l(a,m)local n=assert(a:match(\"^([><])I[I%d]+$\"),\"invalid format string\")local o={}for g in a:gmatch(\"I([%d]+)\")do local p=tonumber(g)or 4;assert(p>0 and p<=16,\"integral size out of limits\")o[#o+1]=p end;return m(o,n==\">\")end;local q={}local r={}local function s(a)if not q[a]then q[a]=l(a,b)end;return q[a],a end;local function t(a)if not r[a]then r[a]=l(a,j)end;return r[a],a end;return{compilePack=s,compileUnpack=t}else local function s(a)return string.pack,a end;local function t(a)return string.unpack,a end;return{compilePack=s,compileUnpack=t}end\n/74             1722465588  0     0     775     4043      `\nlocal a=require\"system.expect\".expect;local b=require\"internal_packing\"local c=bit32.lshift;local d=bit32.rshift;local e=bit32.bxor;local f=bit32.bnot;local g=bit32.band;local h,i=b.compilePack(\">I16\")local j,k=b.compilePack(\">I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\")local l,m=b.compileUnpack(\">I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\")local function n(o,p)local q=p%2^32;o=o+(p-q)/2^32;return o%2^32,q end;local r={0x428a2f98,0xd728ae22,0x71374491,0x23ef65cd,0xb5c0fbcf,0xec4d3b2f,0xe9b5dba5,0x8189dbbc,0x3956c25b,0xf348b538,0x59f111f1,0xb605d019,0x923f82a4,0xaf194f9b,0xab1c5ed5,0xda6d8118,0xd807aa98,0xa3030242,0x12835b01,0x45706fbe,0x243185be,0x4ee4b28c,0x550c7dc3,0xd5ffb4e2,0x72be5d74,0xf27b896f,0x80deb1fe,0x3b1696b1,0x9bdc06a7,0x25c71235,0xc19bf174,0xcf692694,0xe49b69c1,0x9ef14ad2,0xefbe4786,0x384f25e3,0x0fc19dc6,0x8b8cd5b5,0x240ca1cc,0x77ac9c65,0x2de92c6f,0x592b0275,0x4a7484aa,0x6ea6e483,0x5cb0a9dc,0xbd41fbd4,0x76f988da,0x831153b5,0x983e5152,0xee66dfab,0xa831c66d,0x2db43210,0xb00327c8,0x98fb213f,0xbf597fc7,0xbeef0ee4,0xc6e00bf3,0x3da88fc2,0xd5a79147,0x930aa725,0x06ca6351,0xe003826f,0x14292967,0x0a0e6e70,0x27b70a85,0x46d22ffc,0x2e1b2138,0x5c26c926,0x4d2c6dfc,0x5ac42aed,0x53380d13,0x9d95b3df,0x650a7354,0x8baf63de,0x766a0abb,0x3c77b2a8,0x81c2c92e,0x47edaee6,0x92722c85,0x1482353b,0xa2bfe8a1,0x4cf10364,0xa81a664b,0xbc423001,0xc24b8b70,0xd0f89791,0xc76c51a3,0x0654be30,0xd192e819,0xd6ef5218,0xd6990624,0x5565a910,0xf40e3585,0x5771202a,0x106aa070,0x32bbd1b8,0x19a4c116,0xb8d2d0c8,0x1e376c08,0x5141ab53,0x2748774c,0xdf8eeb99,0x34b0bcb5,0xe19b48a8,0x391c0cb3,0xc5c95a63,0x4ed8aa4a,0xe3418acb,0x5b9cca4f,0x7763e373,0x682e6ff3,0xd6b2b8a3,0x748f82ee,0x5defb2fc,0x78a5636f,0x43172f60,0x84c87814,0xa1f0ab72,0x8cc70208,0x1a6439ec,0x90befffa,0x23631e28,0xa4506ceb,0xde82bde9,0xbef9a3f7,0xb2c67915,0xc67178f2,0xe372532b,0xca273ece,0xea26619c,0xd186b8c7,0x21c0c207,0xeada7dd6,0xcde0eb1e,0xf57d4f7f,0xee6ed178,0x06f067aa,0x72176fba,0x0a637dc5,0xa2c898a6,0x113f9804,0xbef90dae,0x1b710b35,0x131c471b,0x28db77f5,0x23047d84,0x32caab7b,0x40c72493,0x3c9ebe0a,0x15c9bebc,0x431d67c4,0x9c100d4c,0x4cc5d4be,0xcb3e42b6,0x597f299c,0xfc657e2a,0x5fcb6fab,0x3ad6faec,0x6c44198c,0x4a475817}local function s(t)a(1,t,\"string\")local u=#t*8;local v=-(#t+17)%128;t=t..\"\\x80\"..(\"\\0\"):rep(v)..h(i,u)local w,x=0x6a09e667,0xf3bcc908;local y,z=0xbb67ae85,0x84caa73b;local A,B=0x3c6ef372,0xfe94f82b;local C,D=0xa54ff53a,0x5f1d36f1;local E,F=0x510e527f,0xade682d1;local G,H=0x9b05688c,0x2b3e6c1f;local I,J=0x1f83d9ab,0xfb41bd6b;local K,L=0x5be0cd19,0x137e2179;for M=1,#t,128 do local N={l(m,t,M)}for O=33,160,2 do local P,Q=N[O-30],N[O-29]local R=d(P,1)+c(Q,31)local S=d(Q,1)+c(P,31)local T=d(P,8)+c(Q,24)local U=d(Q,8)+c(P,24)local V=d(P,7)local W=d(Q,7)+c(P,25)local X,Y=N[O-4],N[O-3]local Z=d(X,19)+c(Y,13)local _=d(Y,19)+c(X,13)local a0=d(X,29)+c(Y,3)local a1=d(Y,29)+c(X,3)local a2=d(X,6)local a3=d(Y,6)+c(X,26)local a4,q=N[O-32]+e(R,T,V)+N[O-14]+e(Z,a1,a2),N[O-31]+e(S,U,W)+N[O-13]+e(_,a0,a3)N[O],N[O+1]=n(a4,q)end;local o,p=w,x;local a5,a6=y,z;local a7,a8=A,B;local a9,aa=C,D;local ab,ac=E,F;local ad,ae=G,H;local af,ag=I,J;local ah,ai=K,L;for O=1,160,2 do local R=d(ab,14)+c(ac,18)local S=d(ac,14)+c(ab,18)local T=d(ab,18)+c(ac,14)local U=d(ac,18)+c(ab,14)local W=d(ab,9)+c(ac,23)local V=d(ac,9)+c(ab,23)local aj=e(R,T,V)local ak=e(S,U,W)local al=e(g(ab,ad),g(f(ab),af))local am=e(g(ac,ae),g(f(ac),ag))local an=ah+aj+al+r[O]+N[O]local ao=ai+ak+am+r[O+1]+N[O+1]local Z=d(o,28)+c(p,4)local _=d(p,28)+c(o,4)local a0=d(o,2)+c(p,30)local a1=d(p,2)+c(o,30)local a3=d(o,7)+c(p,25)local a2=d(p,7)+c(o,25)local ap=e(Z,a1,a2)local aq=e(_,a0,a3)local ar=e(g(o,a5),g(o,a7),g(a5,a7))local as=e(g(p,a6),g(p,a8),g(a6,a8))local at=ap+ar;local au=aq+as;ah=af;ai=ag;af=ad;ag=ae;ad=ab;ae=ac;ab,ac=n(a9+an,aa+ao)a9=a7;aa=a8;a7=a5;a8=a6;a5=o;a6=p;o,p=n(an+at,ao+au)end;w,x=n(w+o,x+p)y,z=n(y+a5,z+a6)A,B=n(A+a7,B+a8)C,D=n(C+a9,D+aa)E,F=n(E+ab,F+ac)G,H=n(G+ad,H+ae)I,J=n(I+af,J+ag)K,L=n(K+ah,L+ai)end;return j(k,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L)end;return{digest=s}\n\n/95             1722465588  0     0     775     538       `\nlocal function a(b,c,d)if not b then error(c,d+1)end;return b end;local function e(f,g,h)local i={}local j=1;local k=0;local l=1;for m=1,#f do k=k+f[m]*l;l=l*g;while l>=h do local n=k%h;k=(k-n)/h;l=l/h;i[j]=n;j=j+1 end end;if l>0 then i[j]=k end;return i end;local function o(p)local q={p:byte(1,32)}local i={}for m=1,32 do local r=q[m]for s=-7,0 do local t=r%2;i[8*m+s]=t;r=(r-t)/2 end end;i[1]=0;i[2]=0;i[3]=0;i[255]=1;i[256]=0;return i end;local function u(p)return{table.unpack(o(p),4)}end;return{lassert=a,rebaseLE=e,bits=o,bits8=u}\n",setuser=false,size=43338,modified=1757997040008,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},dpkg={permissions={root={write=true,read=true,execute=true}},created=1757997040428,contents={["query.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040427,data="local a=require\"system.filesystem\"local b=require\"control\"local function c(d)return string.match(d,'^()[%s%z]*$')and''or string.match(d,'^[%s%z]*(.*[^%s%z])')end;local e={status={not_installed=1,config_files=2,half_installed=3,unpacked=4,half_configured=5,triggers_awaited=6,triggers_pending=7,installed=8}}e.admindir=\"/var/lib/dpkg\"if not a.isDir(e.admindir)then a.mkdir(e.admindir)end;function e.readDatabase()local f=io.open(a.combine(e.admindir,\"status\"),\"r\")if f==nil then error(\"Couldn't find status file\")end;local g={{}}local h=nil;local d=1;for i in f:lines()do if i==\"\"then d=d+1;g[d]={}h=nil else if string.sub(i,1,1)==\" \"and h~=nil then if h==\"Description\"then if type(g[d][h])==\"string\"then g[d][h]={Short=g[d][h],Long=\"\"}end;g[d][h].Long=g[d][h].Long..(string.sub(i,2)==\".\"and\"\\n\\n\"or string.sub(i,2))else g[d][h]=g[d][h]..(string.sub(i,2)==\".\"and\"\\n\\n\"or string.sub(i,2))end else h=string.sub(i,1,(string.find(i,\":\")or 0)-1)g[d][h]=c(string.sub(i,(string.find(i,\":\")or-1)+1))end end end;f:close()local j={}for k,l in pairs(g)do if l.Package then j[l.Package]=l end end;return j end;function e.writeDatabase(m)a.copy(a.combine(e.admindir,\"status\"),a.combine(e.admindir,\"status-old\"))local f=a.open(a.combine(e.admindir,\"status\"),\"w\")if f==nil then error(\"Couldn't find status file\")end;local function n(l)if type(l)==\"table\"then return(l.Short or\"\")..\"\\n \"..string.gsub(l.Long or\"\",\"\\n\\n\",\"\\n .\\n\")else return l end end;for k,l in pairs(m)do if not(string.match(l.Status,\"(%S+) %S+ %S+\")==\"unknown\"and string.match(l.Status,\"%S+ %S+ (%S+)\")==\"not-installed\")then f.writeLine(\"Package: \"..k)for o,p in pairs(l)do if o~=\"Package\"and o~=\"Description\"then f.writeLine(o..\": \"..n(p))end end;if l.Description then f.writeLine(\"Description: \"..n(l.Description))end;f.writeLine(\"\")end end;f.close()end;function e.findPackage(q,r)r=r or e.readDatabase()for k,l in pairs(r)do if q==k then return l,r end end;return nil,r end;function e.readFileLists()local g={duplicates={}}local s=0;for t,l in ipairs(a.find(a.combine(e.admindir,\"info/*.list\")))do local u=string.match(l,\"info/(.+)%.list$\")local f=assert(io.open(l,\"r\"))for i in f:lines()do if g[i]~=nil and not a.isDir(i)then g.duplicates[i]=g.duplicates[i]or{}table.insert(g.duplicates[i],u)else g[i]=u;s=s+1 end end end;return g,s end;function e.status.configured(v)return v==\"triggers-pending\"or v==\"installed\"end;function e.status.present(v)return v~=\"not-installed\"and v~=\"config-files\"and v~=\"half-installed\"end;function e.status.needs_configure(v)return v==\"config-failed\"or v==\"half-configured\"or v==\"unpacked\"end;function e.status.get_number(v)for k,l in ipairs({\"not-installed\",\"config-files\",\"half-installed\",\"unpacked\",\"half-configured\",\"triggers-awaited\",\"triggers-pending\",\"installed\"})do if l==v then return k end end;return nil end;return e\n",setuser=false,size=2813,modified=1757997040404,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["deb.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040425,data="local a=require\"ar\"local b=require\"tar\"local c=require\"control\"local d=require\"LibDeflate\"local e=require\"muxzcat\"local f={verbose=false}function f.load(g,h,i)if f.verbose then print(\"Loading package...\")end;local j=a.load(g)if j==nil then error(\"Invalid deb file\",2)end;if#j<3 or j[1].name~=\"debian-binary\"or j[1].data~=\"2.0\\n\"then error(\"Invalid deb file\",2)end;local k,l,m;if f.verbose then print(\"Extracting control...\")end;if j[2].name==\"control.tar.gz\"then k,m=d:DecompressGzip(j[2].data)elseif j[2].name==\"control.tar.xz\"then k,m=e.DecompressXzOrLzmaString(j[2].data)else error(\"Unsupported compression format: \"..j[2].name)end;if k==nil then error(\"Could not decompress control file: \"..m)end;local n=b.load(k,false,true)if n[\".\"]~=nil then n=n[\".\"]end;if f.verbose then print(\"Extracting data...\")end;if j[3].name==\"data.tar.gz\"then l,m=d:DecompressGzip(j[3].data)elseif j[3].name==\"data.tar.xz\"or j[3].name==\"data.tar.lzma\"then l,m=e.DecompressXzOrLzmaString(j[3].data)else error(\"Unsupported compression format: \"..j[2].name)end;if l==nil then error(\"Could not decompress data file: \"..m)end;if i then return{k,l}end;local o=b.load(l,h,true)if o[\".\"]~=nil and not h then o=o[\".\"]end;local p={}p.control_size=string.len(j[2].data)p.data_size=string.len(j[3].data)p.control_archive=n;p.control=c.parseControl(n.control.data)p.name=p.control.Package;p.version=p.control.Version;p.section=p.control.Section;p.priority=p.control.Priority;if p.control[\"Pre-Depends\"]~=nil then p.predepends=c.parseDependencies(p.control[\"Pre-Depends\"])end;if p.control.Depends~=nil then p.depends=c.parseDependencies(p.control.Depends)end;if p.control.Recommends~=nil then p.recommends=c.parseDependencies(p.control.Recommends)end;if p.control.Suggests~=nil then p.suggests=c.parseDependencies(p.control.Suggests)end;if p.control.Enhances~=nil then p.enhances=c.parseDependencies(p.control.Enhances)end;if p.control.Breaks~=nil then p.breaks=c.parseDependencies(p.control.Breaks)end;if p.control.Conflicts~=nil then p.conflicts=c.parseDependencies(p.control.Conflicts)end;if p.control.Provides~=nil then p.provides=c.parseDependencies(p.control.Provides)end;if p.control.Replaces~=nil then p.replaces=c.parseDependencies(p.control.Replaces)end;p.conffiles={}if n.conffiles~=nil then for q in string.gmatch(n.conffiles.data,\"[^\\n]+\")do table.insert(p.conffiles,q)end end;p.md5sums={}if n.md5sums~=nil then for q in string.gmatch(n.md5sums.data,\"[^\\n]+\")do local r,s=q:match(\"^(%x+)  (.+)$\")if r then p.md5sums[\"/\"..s]=r end end end;if n.preinst~=nil then p.preinst=n.preinst.data end;if n.prerm~=nil then p.prerm=n.prerm.data end;if n.postinst~=nil then p.postinst=n.postinst.data end;if n.postrm~=nil then p.postrm=n.postrm.data end;if n.config~=nil then p.config=n.config.data end;if n.triggers~=nil then p.triggers=n.triggers.data end;if n.templates~=nil then p.templates=c.parseControlList(n.templates.data)for r,s in pairs(p.templates)do local t={}for u,v in pairs(s)do if string.match(u,\"%a+%-[%a@_]+%.UTF%-8\")then table.insert(t,u)end end;for u,v in pairs(t)do s[v]=nil end end end;p.data=o;return p end;return f\n",setuser=false,size=3107,modified=1757997040401,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["trigger.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040428,data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=require\"query\"local d={}d.admindir=\"/var/lib/dpkg\"d.log=function(e)end;local f={}local function g(h)return a.combine(d.admindir,h)end;local function i(j,k)local l={}for m in string.gmatch(j,\"([^\"..(k or\"%s\")..\"]+)\")do table.insert(l,m)end;return l end;function d.list()return a.list(g(\"triggers\"))end;function d.lock()while a.exists(g(\"triggers/Lock\"))do coroutine.yield()end;local n=a.open(g(\"triggers/Lock\"),\"w\")n.write(\"Lock\")n.flush()return function()n.close()a.remove(g(\"triggers/Lock\"))if a.exists(g(\"triggers/Lock\"))then error(\"Lock still exists!\")end end end;function d.readDatabase()local n=io.open(g(\"triggers/File\"),\"r\")if not n then error(\"Missing trigger file\")end;local o=d.lock()local p={}for q in n:lines()do local r,s=string.match(q,\"([^ ]+) ([^ ]+)\")if r then p[r]={package=s,await=true}if string.find(s,\"/noawait\")then p[r].await=false end end end;n:close()o()return p end;function d.register(t,s,u)if u==nil then u=true end;local o=d.lock()if string.find(t,\"/\")then local n=a.open(g(\"triggers/File\"),a.exists(g(\"triggers/File\"))and\"a\"or\"w\")n.writeLine(t..\" \"..s..(not u and\"/noawait\"or\"\"))n.close()else local n=a.open(g(\"triggers/\"..t),\"w\")n.writeLine(s..(not u and\"/noawait\"or\"\"))n.close()end;o()end;function d.deregister(t)if string.find(t,\"/\")then local o=d.lock()local n=io.open(g(\"triggers/File\"),\"r\")if not n then return o()end;local p=\"\"for q in n:lines()do if not string.match(q,\"^\"..t..\" \")then p=p..q..\"\\n\"end end;n:close()n=a.open(g(\"triggers/File\"),\"w\")n.write(p)n.close()o()else a.remove(g(\"triggers/\"..t))end end;function d.activate(t,s,u,v,w)if u==nil then u=true end;if string.find(t,\"/\")then v=v or d.readDatabase()local x=false;for y,z in pairs(v)do if string.match(t,\"^\"..y)then x=z end end;if not x then return false end;u=u and x.await;w=w or c.readDatabase()local A,B,C=string.match(w[x.package].Status,\"([^ ]+) ([^ ]+) ([^ ]+)\")if C~=\"triggers-awaited\"then w[x.package].Status=A..\" \"..B..\" triggers-pending\"end;A,B,C=string.match(w[s].Status,\"([^ ]+) ([^ ]+) ([^ ]+)\")if u then w[s].Status=A..\" \"..B..\" triggers-awaited\"w[s][\"Triggers-Awaited\"]=(w[s][\"Triggers-Awaited\"]or\"\")..(w[s][\"Triggers-Awaited\"]and\" \"or\"\")..x.package end;w[x.package][\"Triggers-Pending\"]=(w[x.package][\"Triggers-Pending\"]or\"\")..(w[x.package][\"Triggers-Pending\"]and\" \"or\"\")..t;local o=d.lock()local n=assert(io.open(g(\"triggers/Unincorp\"),\"r\"))local D=a.open(g(\"triggers/Unincorp.new\"),\"w\")local E=false;for z in n:lines()do if not E and string.match(z,\"^\"..t..\" \")then E=true;if u then if string.match(z,\"[^ ]+ (.+)\")==\"-\"then z=t end;z=z..\" \"..s end end;D.writeLine(z)end;if not E then D.writeLine(t..\" \"..(u and s or\"-\"))end;n:close()D.close()a.remove(g(\"triggers/Unincorp\"))a.move(g(\"triggers/Unincorp.new\"),g(\"triggers/Unincorp\"))o()return true,v,w else if not a.exists(g(\"triggers/\"..t))then error(\"Invalid trigger \"..t,2)end;local n=io.open(g(\"triggers/\"..t),\"r\")if n==nil then error(\"Could not open trigger file\")end;w=w or c.readDatabase()local F;for q in n:lines()do if w[q]==nil then d.log(\"Package \"..q..\" is interested in trigger \"..t..\" but is not installed\")else local A,B,C=string.match(w[q].Status,\"([^ ]+) ([^ ]+) ([^ ]+)\")w[q].Status=A..\" \"..B..\" triggers-pending\"w[q][\"Triggers-Pending\"]=(w[q][\"Triggers-Pending\"]or\"\")..(w[q][\"Triggers-Pending\"]and\" \"or\"\")..t;A,B,C=string.match(w[s].Status,\"([^ ]+) ([^ ]+) ([^ ]+)\")if u then w[s].Status=A..\" \"..B..\" triggers-awaited\"w[s][\"Triggers-Awaited\"]=(w[s][\"Triggers-Awaited\"]or\"\")..(w[s][\"Triggers-Awaited\"]and\" \"or\"\")..q end;F=(F or\"\")..(F and\" \"or\"\")..q end end;n:close()local o=d.lock()n=io.open(g(\"triggers/Unincorp\"),\"r\")local D=a.open(g(\"triggers/Unincorp.new\"),\"w\")local E=false;for z in n:lines()do if not E and string.match(z,\"^\"..t..\" \")then E=true;if u then if string.match(z,\"[^ ]+ (.+)\")==\"-\"then z=t end;z=z..\" \"..s end end;D.writeLine(z)end;if not E then D.writeLine(t..\" \"..(u and s or\"-\"))end;n:close()D.close()a.remove(g(\"triggers/Unincorp\"))a.move(g(\"triggers/Unincorp.new\"),g(\"triggers/Unincorp\"))o()return true,v,w end end;function d.commit(s,v,w)w=w or c.readDatabase()if w[s]==nil then error(\"Package \"..s..\" not found\")end;local A,B,C=string.match(w[s].Status,\"([^ ]+) ([^ ]+) ([^ ]+)\")if w[s][\"Triggers-Pending\"]==nil or not c.status.configured(C)then return false,v,w end;local G=w[s][\"Triggers-Pending\"]w[s][\"Triggers-Pending\"]=nil;local H=b.run(g(\"info/\"..s..\".postinst\"),\"triggered\",G)w[s].Status=A..\" \"..B..(H and(w[s][\"Triggers-Awaited\"]and\" triggers-awaited\"or\" installed\")or\" config-failed\")local o=d.lock()local I=a.open(g(\"triggers/Unincorp.new\"),\"w\")for J in io.lines(g(\"triggers/Unincorp\"))do local K=string.match(J,\"^([^ ]+)\")if K then local L=string.gsub(G,K:gsub(\"([%+%-%.])\",\"%%%1\"),\"\")if L then for M,z in ipairs(i(string.match(J,\"^[^ ]+ (.+)\")))do if w[z]~=nil and w[z][\"Triggers-Awaited\"]~=nil then w[z][\"Triggers-Awaited\"]=string.gsub(string.gsub(w[z][\"Triggers-Awaited\"],\"( ?)\"..s..\"( ?)\",\"%1\"),\" $\",\"\")if w[z][\"Triggers-Awaited\"]==\"\"then w[z][\"Triggers-Awaited\"]=nil;w[z].Status=string.gsub(w[z].Status,\"triggers%-awaited\",\"installed\")end end end else I.writeLine(J)end end end;I.close()a.remove(g(\"triggers/Unincorp\"))a.move(g(\"triggers/Unincorp.new\"),g(\"triggers/Unincorp\"))o()return H and 1 or 0,v,w end;return d\n",setuser=false,size=5316,modified=1757997040405,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["init.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040426,data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=(function()local d={__add=true,__sub=true,__mul=true,__div=true,__mod=true,__pow=true,__unm=true,__concat=true,__len=true,__eq=true,__lt=true,__le=true,__newindex=true,__call=true,__metatable=true}local function e(f,g,...)local h=getfenv(g)h.self=f;h.super=setmetatable({},{__index=getmetatable(f).__index})setfenv(g,h)return g(...)end;local function i(j,k,l)local m,n={__class=j},{}if l.static then for o,p in pairs(l.static)do if d[o]then n[o]=p else m[o]=p end end end;l.static=nil;if k.extends then if k.extends[1]then n.__index=function(self,j)for q,p in ipairs(k.extends)do if p[j]then return p[j]end end end else n.__index=k.extends end end;local r=l.__init;l.__init=nil;n.__call=function(self,...)local s,t={},{}local f=setmetatable({__class=j},s)if k.extends and not r then if k.extends[1]then for q,p in ipairs(k.extends)do t[q]=p()end;s.__index=function(self,j)for q,p in ipairs(t)do if p[j]then return p[j]end end end else s.__index=k.extends(...)end end;for o,p in pairs(l)do if type(p)==\"function\"then f[o]=function(...)return e(f,p,...)end elseif o~=\"__class\"then f[o]=p end;if d[o]then s[o]=f[o]f[o]=nil end end;if r then local h=getfenv(r)h.self=f;h.super=setmetatable({},{__index=s.__index})if k.extends then if k.extends[1]then s.__index=function(self,j)if#t<#k.extends then for q,p in ipairs(k.extends)do t[q]=p()end end;for q,p in ipairs(t)do if p[j]then return p[j]end end end;for q,p in ipairs(k.extends)do h[p.__class]=function(...)t[q]=p(...)end end else s.__index=function(self,j)s.__index=k.extends()return s.__index[j]end;h[k.extends.__class]=function(...)s.__index=k.extends(...)end end end;setfenv(r,h)r(...)if k.extends and k.extends[1]then s.__index=function(self,j)for q,p in ipairs(t)do if p[j]then return p[j]end end end end end;return f end;setmetatable(m,n)return m end;return setmetatable({},{__call=function(self,j)return function(u)if u.extends or u.implements then return function(v)return i(j,u,v)end else return i(j,{},u)end end end})end)()local w=require\"diff\"local x=require\"control\"local y=require\"deb\"local z=require\"divert\"local A=require\"query\"local B=require\"trigger\"local C=require\"sha2\"local D=require\"tar\"local E={}E.admindir=\"/var/lib/dpkg\"E.rootdir=\"/\"E.write=io.write;E.print=print;E.read=io.read;E.warn=function(F)print(\"dpkg: warning: \"..F)end;E.error=function(F)print(\"dpkg: \\x1b[31merror:\\x1b[0m \"..F)end;E.debug=function(F)end;local function G(H)return a.combine(E.admindir,H)end;local function I(H)return a.combine(E.rootdir,H)end;local function J(K)return string.match(K,'^()[%s%z]*$')and''or string.match(K,'^[%s%z]*(.*[^%s%z])')end;local function L(M)local N=a.open(M,\"r\")local O=N.readAll()N.close()return O end;local function P(M)local O={}for Q in io.lines(M)do table.insert(O,Q)end;return O end;local function R(M,S)local N=a.open(M,\"w\")N.write(S)N.close()end;local function T(M,U)local N=a.open(M,\"w\")for V,p in ipairs(U)do N.writeLine(p)end;N.close()end;local function W(X,Y)return({string.match(X.Status,\"(%S+) (%S+) (%S+)\")})[Y]end;local function Z(X,Y,_)local a0={string.match(X.Status,\"(%S+) (%S+) (%S+)\")}a0[Y]=_;X.Status=table.concat(a0,\" \")return X.Status end;local function a1(a2,a3)local a4={}for K in string.gmatch(a2,\"([^\"..(a3 or\"%s\")..\"]+)\")do table.insert(a4,K)end;return a4 end;local function a5(F)local b=io.popen(\"/bin/less\",\"w\")b:write(F)b:close()end;local a6={preinst=\"postrm\",prerm=\"postinst\",postrm=\"preinst\"}self={}E.options={triggers=true,pager=true,auto_deconfigure=false,skip_same_version=false,dry_run=false,ignore_depends={}}E.force={downgrade=false,configure_any=false,hold=false,remove_reinstreq=false,remove_essential=false,depends=false,depends_version=false,breaks=false,conflicts=false,confmiss=false,confmode=nil,overwrite=false,overwrite_dir=false,overwrite_diverted=false,statoverride_add=false,statoverride_remove=false,architecture=false,bad_version=false,bad_verify=false}local a7=_G.package;E.package=c\"package\"{static={packagedb=nil,triggerdb=nil,filedb=nil,filecount=0,scriptCallStack={},setPackageDB=function(a8)E.package.packagedb=a8 or A.readDatabase()end,setTriggerDB=function(a8)E.package.triggerdb=a8 or B.readDatabase()end,setFileDB=function(a8,a9)if a8 then E.package.filedb,E.package.filecount=a8,a9 else E.package.filedb,E.package.filecount=A.readFileLists()end end,unwindScriptErrors=function(aa)local O=true;while#E.package.scriptCallStack>0 do local ab=table.remove(E.package.scriptCallStack)if a6[ab.script]then local ac=ab.pkg.callMaintainerScript(a6[ab.script],\"abort-\"..ab.args[1],table.unpack(ab.args,2,ab.args.n))if aa then aa(ab.pkg,ac,ab.script,table.unpack(ab.args,1,ab.args.n))end;if not ac then O=false end end end;return O end,clearScriptErrors=function()E.package.scriptCallStack={}end},__init=function(M)if a.exists(M)then local ad=y.load(M,true)self.isUnpacked=false;self.name=ad.name;self.path=a.basename(M)self.files=ad.data;self.filelist=nil;self.control=ad.control;self.controlArchive=ad.control_archive;self.conffiles=ad.conffiles;self.md5sums=ad.md5sums;self.preinst=ad.preinst;self.postinst=ad.postinst;self.prerm=ad.prerm;self.postrm=ad.postrm;self.triggers=ad.triggers elseif E.package.packagedb~=nil and E.package.packagedb[M]~=nil then self.isUnpacked=true;self.name=M;self.path=nil;self.files=nil;self.filelist=a.exists(G(\"info/\"..M..\".list\"))and P(G(\"info/\"..M..\".list\"))or nil;self.control=E.package.packagedb[M]self.controlArchive=nil;self.conffiles=a.exists(G(\"info/\"..M..\".conffiles\"))and P(G(\"info/\"..M..\".conffiles\"))or nil;if a.exists(G(\"info/\"..M..\".md5sums\"))then local ae=L(G(\"info/\"..M..\".md5sums\"))self.md5sums={}for af in string.gmatch(ae,\"[^\\n]+\")do local o,p=af:match(\"^(%x+)  (.+)$\")if o then self.md5sums[\"/\"..p]=o end end end;self.preinst=a.exists(G(\"info/\"..M..\".preinst\"))and L(G(\"info/\"..M..\".preinst\"))or nil;self.postinst=a.exists(G(\"info/\"..M..\".postinst\"))and L(G(\"info/\"..M..\".postinst\"))or nil;self.prerm=a.exists(G(\"info/\"..M..\".prerm\"))and L(G(\"info/\"..M..\".prerm\"))or nil;self.postrm=a.exists(G(\"info/\"..M..\".postrm\"))and L(G(\"info/\"..M..\".postrm\"))or nil;self.triggers=a.exists(G(\"info/\"..M..\".triggers\"))and L(G(\"info/\"..M..\".triggers\"))or nil else error(\"Could not find package \"..M)end end,callMaintainerScript=function(ag,...)local M,ah=nil,false;if string.sub(ag,#ag)=='!'then ah=true end;ag=ag:gsub(\"!$\",\"\")if self.isUnpacked or string.sub(ag,1,1)=='.'then M=G(\"info/\"..self.name..\".\"..string.gsub(ag,\"^%.\",\"\"))else M=G(\"tmp.ci/\"..ag)end;local ai=...if not ah and ai:find(\"abort\")==nil then table.insert(E.package.scriptCallStack,{pkg=self,script=ag,args=table.pack(...)})end;ag=ag:gsub(\"^%.\",\"\")if not a.exists(M)then return true end;return b.run(M,...)end,unpack=function()local self=self;if self.isUnpacked then E.error(\"internal error: attempted to unpack package without archive\")return false end;if E.package.packagedb[self.name]~=nil and W(E.package.packagedb[self.name],1)==\"hold\"then if E.force.hold then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package is currently held\")else E.error(\"package is currently held\")return false end end;if self.control.Architecture~=\"phoenix\"and self.control.Architecture~=\"all\"then if E.force.architecture then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package architecture (\"..self.control.Architecture..\") does not match the system (phoenix)\")else E.error(\"package architecture (\"..self.control.Architecture..\") does not match the system (phoenix)\")return false end end;if a.isDir(G(\"tmp.ci\"))then a.remove(G(\"tmp.ci\"))end;D.extract(self.controlArchive,G(\"tmp.ci\"))E.print(\"Preparing to unpack \"..self.path..\" ...\")local aj=false;if E.package.packagedb[self.name]~=nil and W(E.package.packagedb[self.name],3)==\"installed\"and E.compareVersions(self.control.Version,E.package.packagedb[self.name].Version)==-1 then if E.force.downgrade then E.warn(\"overriding problem because --force enabled:\")E.warn(\"downgrading \"..self.name..\" from \"..E.package.packagedb[self.name].Version..\" to \"..self.control.Version)aj=true else E.error(\"attempted to downgrade \"..self.name..\" from \"..E.package.packagedb[self.name].Version..\" to \"..self.control.Version)return false end end;local ak={}if self.control[\"Pre-Depends\"]~=nil and not aj then for V,p in ipairs(a1(self.control[\"Pre-Depends\"],\",\"))do local al,j=E.checkDependency(p,function(am,X)return A.status.configured(am)or X[\"Config-Version\"]~=nil and A.status.present(am)end)if not al and not E.options.ignore_depends[j]then table.insert(ak,{j,J(p)})end end end;if#ak>0 then if E.force.depends then E.warn(\"overriding problem because --force enabled:\")E.warn(\"dependency problems prevent unpacking of \"..self.name..\":\")for V,p in ipairs(ak)do E.print(\" \"..self.name..\" pre-depends on \"..p[2]..\"; however:\\n  Package \"..p[1]..\" is not installed.\\n\")end else E.error(\"dependency problems prevent unpacking of \"..self.name..\":\")for V,p in ipairs(ak)do E.print(\" \"..self.name..\" pre-depends on \"..p[2]..\"; however:\\n  Package \"..p[1]..\" is not installed.\\n\")end;return false end end;local an={}for o,p in pairs(E.package.packagedb)do if p.Conflicts and A.status.present(W(p,3))and E.findRelationship(self.name,self.control.Version,p.Conflicts)then table.insert(an,o)end end;if#an>0 then if E.force.conflicts then E.warn(\"overriding problem because --force enabled:\")E.warn(\"conflicting packages prevent unpacking of \"..self.name..\":\")for V,p in ipairs(an)do E.print(\" \"..p..\" conflicts with \"..self.name..\", however:\\n  Package \"..self.name..\" (\"..self.control.Version..\") is being installed.\\n\")end else E.error(\"conflicting packages prevent unpacking of \"..self.name..\":\")for V,p in ipairs(an)do E.print(\" \"..p..\" conflicts with \"..self.name..\", however:\\n  Package \"..self.name..\" (\"..self.control.Version..\") is being installed.\\n\")end;return false end end;if E.package.packagedb[self.name]~=nil and W(E.package.packagedb[self.name],3)==\"installed\"then E.debug(\"Upgrading pre-existing package (\"..E.package.packagedb[self.name].Version..\" => \"..self.control.Version..\")\")if not self.callMaintainerScript(\".prerm\",\"upgrade\",self.control.Version)then E.debug(\"Old package's prerm upgrade failed\")if not self.callMaintainerScript(\"prerm!\",\"failed-upgrade\",E.package.packagedb[self.name].Version)then E.debug(\"New package's prerm failed-upgrade failed\")if E.package.unwindScriptErrors()then E.error(\"package pre-upgrade script failed to run\")Z(E.package.packagedb[self.name],3,\"installed\")else E.debug(\"Old package's postinst abort-upgrade failed\")E.error(\"package pre-upgrade script failed to run, and old package failed to revert changes\")Z(E.package.packagedb[self.name],3,\"half-configured\")end;a.remove(G(\"tmp.ci\"))return false end end end;local ao={}do local ap,j;if self.control.Breaks~=nil then for V,p in ipairs(a1(self.control.Breaks,\",\"))do ap,j=E.checkDependency(p)if ap then ao[j]=0 end end end;if self.control.Conflicts~=nil then for V,p in ipairs(a1(self.control.Conflicts,\",\"))do ap,j=E.checkDependency(p,true)if ap then ao[j]=1 end end end end;if not E.options.auto_deconfigure and next(ao)~=nil then if E.force.conflicts then E.warn(\"dependency problems, but unpacking \"..self.name..\" anyway as you requested:\")else E.error(\"dependency problems prevent unpacking of \"..self.name..\":\")end;for p,V in ipairs(ao)do E.print(\" \"..p..\" conflicts with \"..self.name..\".\")end;if not E.force.conflicts then E.unwindScriptErrors()a.remove(G(\"tmp.ci\"))return false end end;local aq,ar=next(ao)and true or false,ao;while aq do local as,at={},{}aq=false;for o,p in pairs(E.package.packagedb)do for Q,au in pairs(ar)do if p.Depends and E.findRelationship(Q,E.package.packagedb[Q].Version,p.Depends)or p[\"Pre-Depends\"]and E.findRelationship(Q,E.package.packagedb[Q].Version,p[\"Pre-Depends\"])then aq=true;at[o]=p[\"Pre-Depends\"]and E.findRelationship(Q,E.package.packagedb[Q].Version,p[\"Pre-Depends\"])and 1 or 0;local av=E.package(o)E.debug(\"Deconfiguring \"..o..\" since it depends on conflicting package \"..Q)if av.prerm then if av.callMaintainerScript(\"prerm\",\"deconfigure\",\"in-favour\",self.name,self.control.Version,\"removing\",Q,E.package.packagedb[Q].Version)then p[\"Config-Version\"]=p.Version;Z(p,3,\"unpacked\")else E.debug(\"Deconfigure failed.\")table.insert(as,{o,Q})end else p[\"Config-Version\"]=p.Version;Z(p,3,\"unpacked\")end end end end;if#as>0 then if E.force.depends and E.force.conflicts then E.warn(\"overriding problem because --force enabled:\")E.warn(\"dependency problems prevent unpacking of \"..self.name..\":\")else E.error(\"dependency problems prevent unpacking of \"..self.name..\":\")end;for V,p in ipairs(as)do E.print(\" \"..p[1]..\" depends on \"..p[2]..\" which conflicts with \"..self.name..\", however:\")E.print(\"  deconfiguring \"..p[1]..\" failed\\n\")end;if not(E.force.depends and E.force.conflicts)then E.package.unwindScriptErrors(function(aw,ac,ag)if aw.name~=self.name and ag==\"prerm\"then if ac then Z(E.package.packagedb[aw.name],3,\"installed\")else Z(E.package.packagedb[aw.name],3,\"half-configured\")end end end)a.remove(G(\"tmp.ci\"))return false end end;ar=at end;local ax={}for o,p in pairs(ao)do if o~=self.name then local av=E.package(o)E.debug(\"Deconfiguring \"..o..\" since it conflicts with the current package\")if av.callMaintainerScript(\"prerm\",\"deconfigure\",\"in-favour\",self.name,self.control.Version)then E.package.packagedb[o][\"Config-Version\"]=E.package.packagedb[o].Version;Z(E.package.packagedb[o],3,\"unpacked\")if p==1 then Z(E.package.packagedb[o],3,\"half-installed\")if not av.callMaintainerScript(\"prerm\",\"remove\",\"in-favour\",self.name,self.control.Version)then E.debug(\"Pre-remove failed, aborting.\")table.insert(ax,o)end end else E.debug(\"Deconfigure failed, aborting.\")table.insert(ax,o)end end end;if#ax>0 then if E.force.conflicts then E.warn(\"overriding problem because --force enabled:\")E.warn(\"dependency problems prevent unpacking of \"..self.name..\":\")else E.error(\"dependency problems prevent unpacking of \"..self.name..\":\")end;for V,p in ipairs(ax)do E.print(\" \"..p..\" conflicts with \"..self.name..\", however:\")E.print(\"  deconfiguring \"..p..\" failed\\n\")end;if not E.force.conflicts then E.unwindScriptErrors(function(aw,ac,ag,...)if aw.name~=self.name and ag==\"prerm\"then if...==\"remove\"then if ac then Z(E.package.packagedb[aw.name],3,\"unpacked\")end elseif...==\"deconfigure\"then if ac then Z(E.package.packagedb[aw.name],3,\"installed\")else Z(E.package.packagedb[aw.name],3,\"half-configured\")end end end end)a.remove(G(\"tmp.ci\"))return false end end;local ay;if E.package.packagedb[self.name]~=nil and W(E.package.packagedb[self.name],3)~=\"not-installed\"then ay=E.package.packagedb[self.name].Version;if W(E.package.packagedb[self.name],3)~=\"config-files\"then E.debug(\"Upgrading from \"..E.package.packagedb[self.name].Version..\" to \"..self.control.Version)if not self.callMaintainerScript(\"preinst!\",\"upgrade\",E.package.packagedb[self.name].Version)then E.debug(\"New preinst upgrade failed\")if self.callMaintainerScript(\"postrm\",\"abort-upgrade\",E.package.packagedb[self.name].Version)then if self.callMaintainerScript(\".postinst\",\"abort-upgrade\",self.control.Version)then E.debug(\"Leaving package as-is\")E.error(\"package pre-install script failed to upgrade, leaving old version installed\")Z(E.package.packagedb[self.name],3,\"installed\")E.package.unwindScriptErrors()return false else E.debug(\"Old postinst abort-upgrade failed\")E.error(\"package pre-install script failed to upgrade, and previous version failed to revert changes\")Z(E.package.packagedb[self.name],3,\"unpacked\")E.package.unwindScriptErrors()return false end else E.debug(\"New postrm abort-upgrade failed\")E.error(\"package pre-install script failed to run\")Z(E.package.packagedb[self.name],3,\"half-installed\")E.package.unwindScriptErrors()return false end end else E.debug(\"Installing with config files\")if not self.callMaintainerScript(\"preinst\",\"install\",E.package.packagedb[self.name][\"Config-Version\"])then E.debug(\"Preinst install failed\")if E.package.unwindScriptErrors()then E.error(\"package pre-install script failed to install\")Z(E.package.packagedb[self.name],3,\"config-files\")return false else E.error(\"package pre-install script failed to run, reinstallation required\")Z(E.package.packagedb[self.name],2,\"reinstreq\")Z(E.package.packagedb[self.name],3,\"half-installed\")return false end end end else E.debug(\"Installing new\")if not self.callMaintainerScript(\"preinst\",\"install\")then E.debug(\"Preinst install failed\")if E.package.unwindScriptErrors()then E.error(\"package pre-install script failed to install\")Z(E.package.packagedb[self.name],3,\"not-installed\")return false else E.error(\"package pre-install script failed to run, reinstallation required\")Z(E.package.packagedb[self.name],2,\"reinstreq\")Z(E.package.packagedb[self.name],3,\"half-installed\")return false end end end;if ay then E.print(\"Unpacking \"..self.name..\" (\"..self.control.Version..\") over (\"..ay..\") ...\")else E.print(\"Unpacking \"..self.name..\" (\"..self.control.Version..\") ...\")end;self.filelist={}local az={}local function aA()for V,p in ipairs(self.filelist)do if not a.isDir(I(p))then a.remove(I(p..\".dpkg-new\"))if a.exists(I(p..\".dpkg-old\"))then a.rename(I(p..\".dpkg-old\"),I(p))end end end;self.filelist=nil;if E.package.packagedb[self.name]~=nil and W(E.package.packagedb[self.name],3)~=\"not-installed\"then if W(E.package.packagedb[self.name],3)~=\"config-files\"then if self.callMaintainerScript(\"postrm\",\"abort-upgrade\",E.package.packagedb[self.name].Version)then if self.callMaintainerScript(\".postinst\",\"abort-upgrade\",self.control.Version)then Z(E.package.packagedb[self.name],3,\"installed\")E.package.unwindScriptErrors()return false else E.error(\"previous version failed to revert changes\")Z(E.package.packagedb[self.name],3,\"unpacked\")E.package.unwindScriptErrors()return false end else E.error(\"package post-removal script failed to run\")Z(E.package.packagedb[self.name],3,\"half-installed\")E.package.unwindScriptErrors()return false end else if E.package.unwindScriptErrors()then Z(E.package.packagedb[self.name],3,\"config-files\")return false else E.error(\"package post-remove script failed to run, reinstallation required\")Z(E.package.packagedb[self.name],2,\"reinstreq\")Z(E.package.packagedb[self.name],3,\"half-installed\")return false end end else if E.package.unwindScriptErrors()then Z(E.package.packagedb[self.name],3,\"not-installed\")return false else E.error(\"package post-removal script failed to run, reinstallation required\")Z(E.package.packagedb[self.name],2,\"reinstreq\")Z(E.package.packagedb[self.name],3,\"half-installed\")return false end end end;local aB={}for V,p in ipairs(self.files)do local o=p.name:gsub(\"^./+\",\"/\"):gsub(\"^[^/]\",\"/%1\")E.debug(\"Writing \"..o)if E.package.filedb[o]~=nil and E.package.filedb[o]~=self.name and p.type==0 then if not(self.control.Replaces and E.findRelationship(E.package.filedb[o],E.package.packagedb[E.package.filedb[o]].Version,self.control.Replaces))then if E.force.overwrite_dir and a.isDir(I(o))or E.force.overwrite and not a.isDir(I(o))then E.warn(\"overriding problem because --force enabled:\")E.print((\"dpkg: error processing archive %s:\\n trying to overwrite '%s', which is also in package %s %s\"):format(self.path,o,E.package.filedb[o],E.package.packagedb[E.package.filedb[o]].Version))else E.print((\"dpkg: error processing archive %s:\\n trying to overwrite '%s', which is also in package %s %s\"):format(self.path,o,E.package.filedb[o],E.package.packagedb[E.package.filedb[o]].Version))return aA()end else az[E.package.filedb[o]]=az[E.package.filedb[o]]or{}table.insert(az[E.package.filedb[o]],o)end end;if p.type==5 then a.mkdir(I(o))elseif p.type==2 then a.link(I(o..\".dpkg-new\"),p.link)if a.stat(I(o),true)then a.rename(I(o),I(o..\".dpkg-old\"))end elseif p.type==0 then if self.md5sums and self.md5sums[o:gsub(\"^/+\",\"\")]and C.md5(p.data)~=self.md5sums[o:gsub(\"^/+\",\"\")]then E.debug((\"Invalid checksum for file %s (expected %s, got %s)\"):format(o,self.md5sums[o:gsub(\"^/+\",\"\")],C.md5(p.data)))if E.force.bad_verify then E.warn(\"overriding problem because --force enabled:\")E.warn(\"invalid checksum for file \"..o)else E.error(\"invalid checksum for file \"..o)return aA()end end;local N=a.open(I(o..\".dpkg-new\"),\"wb\")if not N then E.print((\"dpkg: error processing archive %s:\\n could not open destination file %s.dpkg-new for writing\"):format(self.path,o))return aA()end;N.write(p.data or\"\")N.close()a.chmod(I(o..\".dpkg-new\"),nil,bit32.band(p.mode,7))a.chmod(I(o..\".dpkg-new\"),p.ownerName or\"root\",bit32.rshift(bit32.band(p.mode,0x1C0),6))a.chown(I(o..\".dpkg-new\"),p.ownerName or\"root\")if bit32.btest(p.mode,0x800)then a.chmod(I(o..\".dpkg-new\"),p.ownerName or\"root\",\"+s\")end;local aC=false;if self.conffiles and self.md5sums and E.package.packagedb[self.name]~=nil and W(E.package.packagedb[self.name],3)~=\"not-installed\"then for V,au in ipairs(self.conffiles)do if au==o then if self.md5sums[o]==E.package(self.name).md5sums[o]then if a.exists(I(o))then a.remove(I(o..\".dpkg-new\"))aC=true end elseif a.exists(I(o))and p.data~=L(o)or not a.exists(I(o))then local aD=a.exists(I(o))and E.force.confmode or(E.force.confmiss and 0 or nil)E.print(\"Configuration file `\"..o..[['\n==> Modified (by you or by a script) since installation.\n==> Package distributor has shipped an updated version.\nWhat would you like to do about it? Your options are:\n    Y or I  : install the package maintainer's version\n    N or O  : keep your currently-installed version\n    D     : show the differences between the versions\n    Z     : start a shell to examine the situation\nThe default action is to keep your current version.]])while aD==nil do E.write(\"*** \"..a.basename(o)..\" (Y/I/N/O/D/Z) [default=N] ? \")local aE=E.read()if aE==\"Y\"or aE==\"y\"or aE==\"I\"or aE==\"i\"then aD=0 elseif aE==\"N\"or aE==\"n\"or aE==\"O\"or aE==\"o\"then aD=1 elseif aE==\"D\"or aE==\"d\"then local U={}local aF=w.diff(L(o),p.data,\"\\n\")for V,aG in ipairs(aF)do if aG[2]==\"in\"then table.insert(U,\"+++ \"..aG[1])elseif aG[2]==\"out\"then table.insert(U,\"--- \"..aG[1])else table.insert(U,\"    \"..aG[1])end end;if E.options.pager then a5(table.concat(U,\"\\n\"))else E.print(table.concat(U,\"\\n\"))end elseif aE==\"Z\"or aE==\"z\"then b.run(\"/bin/sh\")elseif aE==\"\"then aD=2 end end;if aD==0 then aB[o]=true else aC=true;a.remove(I(o..\".dpkg-dist\"))a.rename(I(o..\".dpkg-new\"),I(o..\".dpkg-dist\"))end end end end end;if not aC and a.exists(I(o))then a.rename(I(o),I(o..\".dpkg-old\"))end else E.debug(\"Unknown type \"..p.type..\" for path \"..o)end;table.insert(self.filelist,o)B.activate(o,self.name,false,E.package.triggerdb,E.package.packagedb)end;if E.package.packagedb[self.name]~=nil and W(E.package.packagedb[self.name],3)~=\"not-installed\"then if not self.callMaintainerScript(\".postrm!\",\"upgrade\",self.control.Version)and not self.callMaintainerScript(\"postrm\",\"failed-upgrade\",E.package.packagedb[self.name].Version)then E.debug(\"postrm upgrade failed\")if self.callMaintainerScript(\".preinst\",\"abort-upgrade\",self.control.Version)then E.debug(\"Reverting changes\")for V,p in ipairs(self.filelist)do if not a.isDir(I(p))then a.remove(I(p..\".dpkg-new\"))if a.exists(I(p..\".dpkg-old\"))then a.rename(I(p..\".dpkg-old\"),I(p))end end end;self.filelist=nil;if not self.callMaintainerScript(\"postrm\",\"abort-upgrade\",E.package.packagedb[self.name].Version)or not self.callMaintainerScript(\".postinst\",\"abort-upgrade\",self.control.Version)then E.debug(\"postrm/.postinst abort-upgrade failed\")E.error(\"package postrm script failed to finish upgrade, and upgrade failed to abort\")Z(self.name,3,\"half-installed\")E.package.unwindScriptErrors()return false end;E.error(\"package upgrade failed to finish\")Z(self.name,3,\"unpacked\")E.package.unwindScriptErrors()return false else E.debug(\"preinst abort-upgrade failed\")E.error(\"package postrm script failed to finish upgrade, and preinst script failed to abort upgrade\")Z(self.name,3,\"half-installed\")E.package.unwindScriptErrors()return false end end;local aH=P(G(\"info/\"..self.name..\".list\"))for V,p in pairs(aH)do local aq=false;for V,au in ipairs(self.filelist)do if a.combine(p)==a.combine(au)then aq=true;break end end;if not aq then if a.isDir(I(p))then if#a.list(I(p))==0 then E.debug(\"Deleting removed directory \"..p)a.remove(I(p))end else E.debug(\"Deleting removed file \"..p)a.remove(I(p))end end end end;T(G(\"info/\"..self.name..\".list\"),self.filelist)if self.conffiles then T(G(\"info/\"..self.name..\".conffiles\"),self.conffiles)end;if self.md5sums then local N=a.open(G(\"info/\"..self.name..\".md5sums\"),\"w\")for o,p in pairs(self.md5sums)do N.writeLine(p..\"  \"..o:sub(2))end;N.close()end;if self.triggers then local U=a1(self.triggers,'\\n')for V,p in ipairs(U)do p=J(p:gsub(\"#.+$\",\"\"))if string.find(p,\"interest\")==1 then local aI=a1(p)if aI[1]==\"interest\"or aI[1]==\"interest-await\"then B.register(aI[2],self.name,true)elseif aI[1]==\"interest-noawait\"then B.register(aI[2],self.name,false)end end end;E.package.setTriggerDB()end;for V,p in ipairs{\"postinst\",\"postrm\",\"preinst\",\"prerm\",\"triggers\"}do if self[p]then R(G(\"info/\"..self.name..\".\"..p),self[p])end end;for o,p in pairs(az)do local aJ=P(G(\"info/\"..o..\".list\"))for V,au in ipairs(p)do for q,aG in ipairs(aJ)do if au==aG then table.remove(aJ,q)break end end end;if#aJ==0 then E.package(o).callMaintainerScript(\"postrm\",\"disappear\",self.name,self.control.Version)for V,au in ipairs{\"conffiles\",\"md5sums\",\"postinst\",\"postrm\",\"preinst\",\"prerm\",\"triggers\"}do a.remove(G(\"info/\"..o..\".\"..au))end;E.package.packagedb[o].Status=\"purge ok not-installed\"else T(G(\"info/\"..o..\".list\"),aJ)end end;for V,p in ipairs(self.filelist)do E.package.filedb[p]=self.name;if a.exists(I(p..\".dpkg-old\"))and not aB[p]then a.remove(I(p..\".dpkg-old\"))end;if a.exists(I(p..\".dpkg-new\"))then local aK=a.stat(I(p..\".dpkg-new\"),true)a.rename(I(p..\".dpkg-new\"),I(p))if aK.setuser then a.chmod(I(p),aK.owner,\"+s\")end end end;a.remove(G(\"tmp.ci\"))E.package.packagedb[self.name]=E.package.packagedb[self.name]or{}for o,p in pairs(self.control)do E.package.packagedb[self.name][o]=p end;E.package.packagedb[self.name].Status=\"install ok unpacked\"self.isUnpacked=true;for o,p in pairs(ao)do if p==1 then E.package(o).remove()end end;E.package.clearScriptErrors()return true end,configure=function()if not self.isUnpacked then E.error(\"internal error: package is not unpacked\")return false end;if W(E.package.packagedb[self.name],1)==\"hold\"then if E.force.hold then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package is currently held\")else E.error(\"package is currently held\")return false end end;if not A.status.needs_configure(W(E.package.packagedb[self.name],3))then E.error(\"package is already configured\")return false end;local aL={}if self.control.Depends~=nil then for V,p in ipairs(a1(self.control.Depends,\",\"))do local al,j=E.checkDependency(p,function(am,X)return A.status.configured(am)or X[\"Config-Version\"]~=nil and A.status.present(am)end)if not al and not E.options.ignore_depends[j]then table.insert(aL,{j,J(p)})end end end;if#aL>0 then if E.force.depends then E.warn(\"overriding problem because --force enabled:\")E.warn(\"dependency problems prevent configuration of \"..self.name..\":\")for V,p in ipairs(aL)do E.print(\" \"..self.name..\" depends on \"..p[2]..\"; however:\\n  Package \"..p[1]..\" is not installed.\\n\")end else E.error(\"dependency problems prevent configuration of \"..self.name..\":\")for V,p in ipairs(aL)do E.print(\" \"..self.name..\" depends on \"..p[2]..\"; however:\\n  Package \"..p[1]..\" is not installed.\\n\")end;return false end end;local an={}for o,p in pairs(E.package.packagedb)do if p.Breaks and A.status.get_number(W(p,3))>=A.status.unpacked and E.findRelationship(self.name,self.control.Version,p.Breaks)then table.insert(an,o)end end;if#an>0 then if E.force.breaks then E.warn(\"overriding problem because --force enabled:\")E.warn(\"conflicting packages prevent unpacking of \"..self.name..\":\")for V,p in ipairs(an)do E.print(\" \"..p..\" breaks \"..self.name..\", however:\\n  Package \"..self.name..\" (\"..self.control.Version..\") is being configured.\\n\")end else E.error(\"conflicting packages prevent unpacking of \"..self.name..\":\")for V,p in ipairs(an)do E.print(\" \"..p..\" breaks \"..self.name..\", however:\\n  Package \"..self.name..\" (\"..self.control.Version..\") is being configured.\\n\")end;return false end end;E.print(\"Setting up \"..self.name..\" (\"..self.control.Version..\") ...\")if not self.callMaintainerScript(\"postinst!\",\"configure\",self.control[\"Config-Version\"])then E.print(\"dpkg: an error occurred while configuring \"..self.name)Z(E.package.packagedb[self.name],3,\"half-configured\")return false end;if self.triggers then local U=a1(self.triggers,'\\n')for V,p in ipairs(U)do p=J(p:gsub(\"#.+$\",\"\"))if string.find(p,\"activate\")==1 then local aI=a1(p)if aI[1]==\"activate\"or aI[1]==\"activate-await\"then B.activate(aI[2],self.name,true,E.package.triggerdb,E.package.packagedb)elseif aI[1]==\"activate-noawait\"then B.activate(aI[2],self.name,false,E.package.triggerdb,E.package.packagedb)end end end end;if E.package.packagedb[self.name][\"Triggers-Pending\"]and E.options.triggers then E.print(\"Processing triggers for \"..self.name..\" (\"..self.control.Version..\") ...\")B.commit(self.name,E.package.triggerdb,E.package.packagedb)else Z(E.package.packagedb[self.name],3,\"installed\")end;E.package.clearScriptErrors()return true end,remove=function(aM)if not self.isUnpacked then E.error(\"internal error: package is not unpacked\")return false end;if W(E.package.packagedb[self.name],1)==\"hold\"then if E.force.hold then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package is currently held\")else E.error(\"package is currently held\")return false end end;if not A.status.present(W(E.package.packagedb[self.name],3))then if aM then return self.purge()end;E.error(\"cannot remove package: package is not installed\")return false end;if W(E.package.packagedb[self.name],2)==\"reinstreq\"then if E.force.remove_reinstreq then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package requires reinstallation\")else E.error(\"package requires reinstallation\")return false end end;if E.package.packagedb[self.name].Essential==\"yes\"then if E.force.remove_essential then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package is marked as essential\")else E.error(\"package is marked as essential\")return false end end;do local as={}for o,p in pairs(E.package.packagedb)do if p.Depends and E.findRelationship(self.name,self.control.Version,p.Depends)then table.insert(as,o)end end;if#as>0 then if E.force.depends then E.print(\"dpkg: \"..self.name..\": dependency problems, but removing anyway as you requested:\")else E.error(\"dependency problems prevent removal of \"..self.name..\":\")end;for V,p in ipairs(as)do E.print(\" \"..p[1]..\" depends on \"..self.name..\".\")end;if not E.force.depends then return false end end end;if not self.callMaintainerScript(\"prerm\",\"remove\")then E.debug(\"Prerm failed\")if E.package.unwindScriptErrors()then E.error(\"prerm failed, leaving installed\")Z(E.package.packagedb[self.name],3,\"installed\")return false else E.error(\"prerm failed to run\")Z(E.package.packagedb[self.name],3,\"half-configured\")return false end end;E.print(\"Removing \"..self.name..\" (\"..self.control.Version..\") ...\")local aN={}for V,p in ipairs(self.conffiles)do aN[p]=true end;local aO={}local aP={}for q,p in ipairs(self.filelist)do if p~=\"/\"then E.debug(\"Removing \"..p)if not aN[p]then table.insert(aP,q)if a.isDir(I(p))then table.insert(aO,p)else a.remove(I(p))end end end end;table.sort(aO,function(ai,aQ)return#ai>#aQ end)for V,p in ipairs(aO)do if#a.list(I(p))==0 then a.remove(I(p))end end;for V,p in ipairs(aP)do self.filelist[p]=nil end;if not self.callMaintainerScript(\"postrm\",\"remove\")then E.error(\"postrm failed to run\")E.package.clearScriptErrors()Z(E.package.packagedb[self.name],3,\"half-installed\")return false end;if self.triggers then local U=a1(self.triggers,'\\n')for V,p in ipairs(U)do p=J(p:gsub(\"#.+$\",\"\"))if string.find(p,\"interest\")==1 then local aI=a1(p)B.deregister(aI[2])end end;E.package.setTriggerDB()end;for V,p in ipairs(a.find(G(\"info/\"..self.name..\".*\")))do local aR=p:match(\"[^.]+$\")if not(aR==\"postrm\"or aR==\"conffiles\"or aR==\"list\"or aR==\"md5sums\")then a.remove(I(p))end end;T(G(\"info/\"..self.name..\".list\"),self.filelist)Z(E.package.packagedb[self.name],3,\"config-files\")if not a.exists(G(\"info/\"..self.name..\".postrm\"))and not a.exists(G(\"info/\"..self.name..\".conffiles\"))then a.remove(G(\"info/\"..self.name..\".list\"))Z(E.package.packagedb[self.name],3,\"not-installed\")return true elseif aM then return self.purge()else return true end end,purge=function()if not self.isUnpacked then E.error(\"internal error: package is not unpacked\")return false end;if W(E.package.packagedb[self.name],1)==\"hold\"then if E.force.hold then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package is currently held\")else E.error(\"package is currently held\")return false end end;if W(E.package.packagedb[self.name],3)~=\"config-files\"then E.error(\"cannot purge package: package is\"..(W(E.package.packagedb[self.name],3)==\"not-installed\"and\" not \"or\" \")..\"installed\")return false end;E.print(\"Removing config files for \"..self.name..\" (\"..self.control.Version..\") ...\")for V,p in ipairs(self.conffiles)do a.remove(I(p))end;if not self.callMaintainerScript(\"postrm\",\"purge\")then E.error(\"postrm failed to run\")E.package.clearScriptErrors()Z(E.package.packagedb[self.name],3,\"config-files\")return false end;if a.exists(G(\"info/\"..self.name..\".postrm\"))then a.remove(G(\"info/\"..self.name..\".postrm\"))end;if a.exists(G(\"info/\"..self.name..\".conffiles\"))then a.remove(G(\"info/\"..self.name..\".conffiles\"))end;Z(E.package.packagedb[self.name],3,\"not-installed\")return true end,verify=function()if not self.isUnpacked then E.error(\"internal error: package is not unpacked\")return false end;if W(E.package.packagedb[self.name],1)==\"hold\"then if E.force.hold then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package is currently held\")else E.error(\"package is currently held\")return false end end;if not self.md5sums then E.error(\"cannot verify package: no md5 sums are available\")return false end;local aS=true;for o,p in pairs(self.md5sums)do if C.md5(L(o))~=p then E.print(\"dpkg: \"..self.name..\": checksum failed for file \"..o)aS=false end end;return aS end}_G.package=a7;local function aT(aU,aV)if aU=='~'and aV~='~'then return 1 elseif aU~='~'and aV=='~'then return-1 elseif aU==''and aV~=''then return 1 elseif aU~=''and aV==''then return-1 elseif string.match(aU,\"%a\")and not string.match(aV,\"%a\")then return 1 elseif not string.match(aU,\"%a\")and string.match(aV,\"%a\")then return-1 elseif aU>aV then return 1 elseif aU<aV then return-1 else return 0 end end;local function aW(ai,aQ)if ai==aQ then return 0 end;while ai~=\"\"or aQ~=\"\"do local aX,aY;aX,ai=string.match(ai,\"^(%D*)(.*)$\")aY,aQ=string.match(aQ,\"^(%D*)(.*)$\")while aX~=\"\"or aY~=\"\"do local aZ,a_;aZ,aX=string.match(aX,\"^(.?)(.*)$\")a_,aY=string.match(aY,\"^(.?)(.*)$\")local ac=aT(aZ,a_)if ac~=0 then return ac end end;if ai==\"\"and aQ==\"\"then break end;aX,ai=string.match(ai,\"^(%d*)(.*)$\")aY,aQ=string.match(aQ,\"^(%d*)(.*)$\")local b0,b1=tonumber(aX),tonumber(aY)if not b1 or b0 and b0>b1 then return 1 elseif not b0 or b1 and b0<b1 then return-1 end end;return 0 end;function E.compareVersions(ai,aQ)if string.match(ai,\"^%d+:\")or string.match(aQ,\"^%d+:\")then local b2=tonumber(string.match(ai,\"^(%d+):\")or 0)local b3=tonumber(string.match(aQ,\"^(%d+):\")or 0)ai,aQ=string.match(ai,\"^%d+:(.*)\")or ai,string.match(aQ,\"^%d+:(.*)\")or aQ;if b2<b3 then return-1 elseif b2>b3 then return 1 end end;local b4=string.match(ai,\"^([%w%.+-~]-)%-?[%w%.+~]*$\")local b5=string.match(aQ,\"^([%w%.+-~]-)%-?[%w%.+~]*$\")if b4==nil or b5==nil then return nil end;local ac=aW(b4,b5)if ac~=0 then return ac end;if string.match(ai,\"%-[%w%.+~]+$\")or string.match(aQ,\"%-[%w%.+~]+$\")then return aW(string.match(ai,\"%-([%w%.+~]+)$\")or\"0\",string.match(aQ,\"%-([%w%.+~]+)$\")or\"0\")end;return 0 end;function E.findRelationship(X,b6,b7)local b8,b9;b7=string.match(J(b7),\"^(\"..X..\"%s+%([<=>][<=>]?%s*[^ )]+%))\")or string.match(J(b7),\"[, ](\"..X..\"%s+%([<=>][<=>]?%s*[^ )]+%))\")or string.match(J(b7),\"^(\"..X..\")%s*,\")or string.match(J(b7),\"[, ](\"..X..\")%s*,\")or string.match(J(b7),\"^(\"..X..\")$\")or string.match(J(b7),\"[, ](\"..X..\")$\")if b7==nil then return false end;if string.match(b7,\"%S+%s+%([<=>][<=>]?%s*[^ )]+%)\")then b7,b9,b8=string.match(b7,\"(%S+)%s+%(([<=>][<=>]?)%s*([^ )]+)%)\")if not({[\"<<\"]=true,[\"<=\"]=true,[\"=\"]=true,[\">=\"]=true,[\">>\"]=true})[b9]then return nil end end;if b8 and b9 then local ac=E.compareVersions(b6,b8)return b9==\"<<\"and ac==-1 or b9==\"<=\"and ac~=1 or b9==\"=\"and ac==0 or b9==\">=\"and ac~=-1 or b9==\">>\"and ac==1 else return true end end;function E.checkDependency(ba,bb)local b8,b9;ba=J(ba)if string.match(ba,\"%S+%s+%([<=>][<=>]?%s*[^ )]+%)\")then ba,b9,b8=string.match(ba,\"(%S+)%s+%(([<=>][<=>]?)%s*([^ )]+)%)\")if not({[\"<<\"]=true,[\"<=\"]=true,[\"=\"]=true,[\">=\"]=true,[\">>\"]=true})[b9]then return nil end end;local bc={}if E.package.packagedb[ba]~=nil then table.insert(bc,{E.package.packagedb[ba],E.package.packagedb[ba].Version})end;for V,p in pairs(E.package.packagedb)do if p.Provides and string.find(p.Provides,\"[, ]\"..ba..\"[(, ]\")then if b8 and string.match(p.Provides,\"[, ]\"..ba..\"%s+%(=%s*[^ )]+%)\")then table.insert(bc,{p,string.match(p.Provides,\"[, ]\"..ba..\"%s+%(=%s*([^ )]+)%)\")})elseif not b8 then table.insert(bc,{p,p.Version})end end end;for V,bd in ipairs(bc)do if A.status.configured(W(bd[1],3))or bb==true and A.status.present(W(bd[1],3))or type(bb)==\"function\"and bb(W(bd[1],3),bd[1])then if b8 and b9 and not E.force.depends_version then local ac=E.compareVersions(bd[2],b8)if b9==\"<<\"and ac==-1 or b9==\"<=\"and ac~=1 or b9==\"=\"and ac==0 or b9==\">=\"and ac~=-1 or b9==\">>\"and ac==1 then return true,bd[1].Package end else return true,bd[1].Package end end end;return false,ba end;function E.readDatabase()E.write(\"(Reading database ...\")E.package.setPackageDB()E.package.setTriggerDB()E.package.setFileDB()E.print(\" \"..E.package.filecount..\" files and directories installed.)\")end;return E\n",setuser=false,size=37972,modified=1757997040403,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["divert.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040426,data="local a=require\"system.filesystem\"local b={}b.admindir=\"/var/lib/dpkg\"function b.parse()local c=io.open(a.combine(b.admindir,\"diversions\"),\"r\")local d=1;local e={}local f;for g in c:lines()do if d==1 then e[g]={}f=g elseif d==2 then e[f].name=g elseif d==3 then e[f].package=g end;d=d+1;if d>3 then d=1 end end;c:close()return e end;function b.get(c,h,i)i=i or b.parse()local e=i[c]if not e or e.package==h then return nil end;return e end;local function j(k)a.copy(a.combine(b.admindir,\"diversions\"),a.combine(b.admindir,\"diversions-old\"))local c=a.open(a.combine(b.admindir,\"diversions\"),\"w\")for l,m in pairs(k)do c.writeLine(l)c.writeLine(m.name)c.writeLine(m.package)end;c.close()end;function b.add(n,o,h)local p=b.parse()p[n]={name=o or n..\".distrib\",package=h or\":\"}j(p)end;function b.remove(n)local p=b.parse()p[n]=nil;j(p)end;return b\n",setuser=false,size=843,modified=1757997040402,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["control.lua"]={permissions={root={write=true,read=true,execute=false}},created=1757997040424,data="local function a(b)return string.match(b,'^()[%s%z]*$')and''or string.match(b,'^[%s%z]*(.*[^%s%z])')end;local c={}function c.parseControl(d)local e={}local f=nil;for g in string.gmatch(d,\"[^\\n]+\")do if string.sub(g,1,1)==\" \"and f~=nil then if f==\"Description\"then if type(e[f])==\"string\"then e[f]={Short=e[f],Long=\"\"}end;e[f].Long=e[f].Long..(string.sub(g,2)==\".\"and\"\\n\\n\"or string.sub(g,2))else e[f]=e[f]..\"\\n\"..(string.sub(g,2)==\".\"and\"\\n\"or string.sub(g,2))end else f=string.sub(g,1,(string.find(g,\":\")or 0)-1)e[f]=a(string.sub(g,(string.find(g,\":\")or-1)+1))end end;return e end;function c.parseControlList(d,h)local e={}local i={}local j={}local b=1;for k,g in string.gmatch(d,\"()([^\\n]*\\n)\")do if g==\"\\n\"or g==\"\"then b=b+1 else j[b]=j[b]or k;i[b]=(i[b]or\"\")..g end end;for l,m in pairs(i)do local n=c.parseControl(m)if h then n.__pos=j[l]end;table.insert(e,n)end;return e end;function c.parseDependencies(o)local e={}for p in string.gmatch(o,\"[^,]+\")do p=a(p)local q={}if string.find(p,\"|\")then q.multiple=true;q.names={}for r in string.gmatch(p,\"[^|]+\")do r=a(r)local s={}s.name=string.match(r,\"%S+\")if string.match(r,\"%([<>=]+ [%w.%-%+%~]+%)\")then s.rel=string.match(r,\"%(([<>=]+) [%w.%-%+%~]+%)\")s.version=string.match(r,\"%([<>=]+ ([%w.%-%+%~]+)%)\")end;table.insert(q.names,s)end else q.name=string.match(p,\"%S+\")if string.match(p,\"%([<>=]+ [%w%.%-%+%~]+%)\")then q.rel=string.match(p,\"%(([<>=]+) [%w.%-%+%~]+%)\")q.version=string.match(p,\"%([<>=]+ ([%w.%-%+%~]+)%)\")end end;table.insert(e,q)end;return e end;return c\n",setuser=false,size=1524,modified=1757997040400,worldPermissions={write=false,read=true,execute=false},type="file",owner="root"}},setuser=false,size=0,modified=1757997040428,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},["deflateans.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040105,data="local a,b,c,d,e,f,g,h,i,j,k=bit32.band,bit32.rshift,bit32.lshift,bit32.bor,math.frexp,math.max,math.min,math.floor,table.sort,table.concat,string.char;local function l(m)local n,o=e(m)return o-1 end;local function p(m)return m==0 and 0 or 2^(m-1)end;local function q(...)end;local function r(...)end;local s,t,u={R=9},{R=5},{16,17,18}for v=0,143 do s[v+1]={v,2}end;for v=144,255 do s[v+1]={v,1}end;for v=256,279 do s[v+1]={v,4}end;for v=280,287 do s[v+1]={v,2}end;for v=0,31 do t[v+1]={v,1}end;for v=0,7 do u[#u+1],u[#u+2]=(8-v)%8,8+v end;local function w(x)local y,z,A=0,0,1;local function B(m)if not m then m=z%8 end;if m<=0 then return 0 end;while z<m do assert(A<=#x)A,z,y=A+1,z+8,c(y,8)+x:byte(A)end;local C=a(b(y,z-m),2^m-1)z=z-m;return C end;return B end;local function D(E)local F,G=E.R,2^E.R;local H,I,J,K,L=0,G<16 and 3 or 0.625*G+3,{R=F},{},{}if F<0 then return J end;for v=1,#E do local M=E[v]K[M[1]]=M[2]for n=1,M[2]do while L[H]do H=(H+1)%G end;H,L[H]=(H+I)%G,M[1]end end;for H=0,G-1 do local N=L[H]local O={s=N,n=F-l(K[N])}O.X,J[H],K[N]=c(K[N],O.n)-G,O,1+K[N]end;return J end;local function P(B,Q,J,R)local H,S,v,C=B(J.R),R and B(R.R),1,{}while v<=Q do local O=J[H]local N=O.s;if N==256 then return C elseif N>256 then local T=N-257;local U=f(h(T/4)-1,0)if U>0 then T=2+d(B(U),c(a(T,3)+4,U))else T=T+2 end;local V=R[S]local W=V.s;U=f(h(W/2)-1,0)if U>0 then W=1+d(B(U),c(a(W,1)+2,U))else W=W+1 end;for X=0,T do C[v+X]=C[v+X-W]end;v,S=v+T+1,V.X+B(V.n)elseif not R and N>15 then local Y;if N==16 then N,Y=C[v-1],3+B(2)elseif N==17 then N,Y=0,3+B(3)else N,Y=0,11+B(7)end;for X=0,Y-1 do C[v+X]=N end;v=v+Y else C[v],v=N,v+1 end;H=O.X+B(O.n)end;return C end;local function Z(_)local a0,C=w(_),\"\"repeat local a1,a2=a0(1)==1,a0(2)if a2==0 then a0()local a3=a0(16)assert(bit32.bxor(a0(16),a3)==0xFFFF,\"invalid chunk\")for n=1,a3 do C=C..k(a0(8))end elseif a2==1 or a2==2 then local E,a4;if a2==1 then E,a4=s,t else local a5,a6,a7,a8=a0(5)+257,a0(5)+1,a0(4)+4,{R=0}for v=1,a7 do local a9=p(a0(3))a8.R,a8[v]=a8.R+a9,{u[v],a9}end;a8.R=l(a8.R)i(a8,function(aa,ab)return aa[1]<ab[1]end)local ac=P(a0,a5+a6,D(a8))E,a4={R=0},{R=0}for v=1,a5 do E[v]={v-1,p(ac[v])}end;for v=1,a6 do a4[v]={v-1,p(ac[v+a5])}end;for v=1,a5 do E.R=E.R+E[v][2]end;for v=1,a6 do a4.R=a4.R+a4[v][2]end;E.R,a4.R=l(E.R),l(a4.R)end;local ad=P(a0,1e10,D(E),D(a4))for v=1,#ad do ad[v]=k(ad[v])end;C=C..j(ad)elseif a2==3 then local ae={}while true do local Y=a0(9)if Y==511 then break elseif Y>=256 then Y=Y-253;local af=a0(15)for n=1,Y do ae[#ae+1]=ae[#ae-af]end else ae[#ae+1]=string.char(Y)end end;C=C..table.concat(ae)else error(\"invalid chunk\")end until a1;return C end;local function ag()return setmetatable({data=\"\",partial=0,len=0},{__call=function(self,z,Y)if not z then z,Y=0,8-self.len end;assert(z<2^Y,debug.traceback())self.partial=bit32.bor(bit32.lshift(self.partial,Y),z)self.len=self.len+Y;while self.len>=8 do local ah=bit32.extract(self.partial,self.len-8,8)self.data=self.data..string.char(ah)self.len=self.len-8 end end})end;local function ai(E,aj)local F=E.R;if F==0 then if aj then return 0 end;while coroutine.yield(0,0)do end;return 0,0 end;local G=2^F;local ak,al,am,K,L,an={},{},{},{},{},{}local H,I=0,G<16 and 3 or 0.625*G+3;local ao=0;for n,M in ipairs(E)do local N,ap=M[1],M[2]ak[N]=F-l(ap)al[N]=c(ak[N],F+1)-c(ap,ak[N])am[N]=ao-ap;K[N]=ap;an[#an+1]=N;for n=1,ap do while L[H]~=nil do H=(H+1)%G end;L[H]=N;H=(H+I)%G end;ao=ao+ap end;local aq={}for ar=G,2*G-1 do local N=L[ar-G]aq[am[N]+K[N]]=ar;K[N]=K[N]+1 end;local ar=G;local as,at=0,0;local au;if aj then local A=#aj;function au()local N=aj[A]A=A-1;return N end else au=coroutine.yield end;local N=au()while N do local av=b(ar+al[N],F+1)local aw=au(a(ar,2^av-1),av)as=as+av;at=at+1;ar=aq[am[N]+b(ar,av)]N=aw end;if not aj then q(\"Size of block:\",as+F,at)return ar-G,F else return as+F end end;local function ax(ay,...)local az=table.pack(coroutine.resume(ay,...))if not az[1]then error(debug.traceback(ay,az[2]),2)end;return table.unpack(az,1,az.n)end;local function aA(aj,E,a4,aB)local aC={}local aD=coroutine.create(ai)ax(aD,E)local aE=coroutine.create(ai)ax(aE,a4)for v=#aj,1,-1 do local N=aj[v]if type(N)==\"table\"then aC[#aC+1]={select(2,ax(aD,N[1].code+257))}aC[#aC+1]={select(2,ax(aE,N[2].code))}aC[#aC+1]={N[2].extra,N[2].bits}aC[#aC+1]={N[1].extra,N[1].bits}else aC[#aC+1]={select(2,ax(aD,N))}end end;aC[#aC+1]={select(2,ax(aE))}aC[#aC+1]={select(2,ax(aD))}for v=#aC,2,-1 do aB(aC[v][1],aC[v][2])end end;local function aF(aj,E,a4)if not E or not a4 then return math.huge end;local aG,aH={},{}local z=0;for v,N in ipairs(aj)do if type(N)==\"table\"then aG[v]=N[1].code+257;aH[#aH+1]=N[2].code;z=z+N[1].bits+N[2].bits else aG[v]=N end end;return z+ai(E,aG)+ai(a4,aH)end;local function aI(aj,E,aB)local aC={}local aD=coroutine.create(ai)coroutine.resume(aD,E)for v=#aj,1,-1 do local N=aj[v]if type(N)==\"table\"then aC[#aC+1]={select(2,coroutine.resume(aD,N[1]))}if N[1]==16 then aC[#aC+1]={N[2],2}elseif N[1]==17 then aC[#aC+1]={N[2],3}elseif N[1]==18 then aC[#aC+1]={N[2],7}end else aC[#aC+1]={select(2,coroutine.resume(aD,N))}end end;aC[#aC+1]={select(2,coroutine.resume(aD))}for v=#aC,1,-1 do aB(aC[v][1],aC[v][2])end end;local function aJ(aj,E)if not E then return math.huge end;local aG={}local z=0;for v,N in ipairs(aj)do if type(N)==\"table\"then aG[v]=N[1]if N[1]==16 then z=z+2 elseif N[1]==17 then z=z+3 elseif N[1]==18 then z=z+7 end else aG[v]=N end end;return z+ai(E,aG)end;local function W(v)if v==0 or v==1 then return{code=v,extra=0,bits=0,raw=v}end;local U=math.max(select(2,math.frexp(v))-2,0)local aK=2^U;return{code=U*2+(bit32.btest(v,aK)and 3 or 2),extra=bit32.band(v,aK-1),bits=U,raw=v}end;local function T(v)if v>=0 and v<4 then return{code=v,extra=0,bits=0,raw=v}end;local U=math.max(select(2,math.frexp(v))-3,0)local aK=2^U;return{code=U*4+(bit32.btest(v,aK)and 5 or 4)+(bit32.btest(v,aK*2)and 2 or 0),extra=bit32.band(v,aK-1),bits=U,raw=v}end;local function aL(aM,aN)aN=g(aN or 1024,32768)local C={}local aO={}local v=1;while v<=#aM do local ap=aM[v]if aO[ap]then local aP=aO[ap]local aQ,A=0;for m=#aP,1,-1 do local aR=aP[m]if v-aR>aN then break end;for X=1,g(#aM-v,129)do local aS=(X-1)%(v-aR)+1;if aM[v+X]==aM[aR+aS]then if X>aQ then aQ,A=X,aR end else break end end end;if aQ>=2 then local Y=T(aQ-2)local af=W(v-A-1)C[#C+1]={Y,af}for X=0,aQ do ap=aM[v+X]aO[ap][#aO[ap]+1]=v+X end;v=v+aQ+1;ap=nil end end;if ap then C[#C+1]=ap;aO[ap]=aO[ap]or{}aO[ap][#aO[ap]+1]=v;v=v+1 end end;return C end;local function aT(aU)return function(aa,ab)if aa.height>aU then return true end;if ab.height>aU then return false end;return aa.weight>ab.weight end end;local function aV(aW)if aW then return function(aa,ab)if aa.bits==ab.bits then return aW[aa.symbol]<aW[ab.symbol]else return aa.bits<ab.bits end end else return function(aa,ab)if aa.bits==ab.bits then return aa.symbol<ab.symbol else return aa.bits<ab.bits end end end end;local function aX(aY,aZ,a_,y)if aY.data then y.symbol=aY.data;a_[aY.data]=y;aZ[#aZ+1]=y else aX(aY[1],aZ,a_,{bits=y.bits+1,code=y.code*2})aX(aY[2],aZ,a_,{bits=y.bits+1,code=y.code*2+1})end end;local function b0(b1,b2)b2=b2 or 15;local E={R=0}for ak,ap in pairs(b1)do E[#E+1]={ak,ap}end;i(E,function(aa,ab)return aa[1]<ab[1]end)local b3={}for v,ap in ipairs(E)do if ap[2]>0 then b3[#b3+1]={data=ap[1],weight=ap[2],height=1}end end;if#b3<2 then local C={R=0}for v,ap in ipairs(E)do if ap[1]==b3[1].data then C[v]={ap[1],1,0}end end;return C end;local b4=aT(b2-1)i(b3,b4)while#b3>1 do local aa,ab=b3[#b3-1],b3[#b3]local m={weight=aa.weight+ab.weight,height=f(aa.height+1,ab.height+1),aa,ab}b3[#b3]=nil;b3[#b3]=m;i(b3,b4)end;local aZ,a_={},{}aX(b3[1],aZ,a_,{bits=0,code=0})i(aZ,aV())aZ[1].code=0;for v=2,#aZ do aZ[v].code=bit32.lshift(aZ[v-1].code+1,aZ[v].bits-aZ[v-1].bits)end;local b5={}for v,ap in ipairs(E)do b5[v]=a_[ap[1]]and a_[ap[1]].bits or 0;E.R=f(E.R,b5[v])end;local b6={}local b7=0;for v,ap in ipairs(b5)do assert(ap>0 and ap<=b2)b6[v]={E[v][1],2^(E.R-ap),E.R-ap}b7=b7+2^(E.R-ap)end;b6.R=select(2,math.frexp(b7))-1;return b6 end;local function b8(_,b9,ba)if _==\"\"then return\"\\x80\\x00\\x00\\xFF\\xFF\"end;b9=b9 or 5;local aB=ag()for v=1,#_,65536 do q(#aB.data,aB.len)local a1=v+65536>#_;local bb={}for X=0,g(#_-v,65535)do bb[X+1]=_:byte(v+X)end;bb[#bb+1]=256;local bc=b9==0 and bb or aL(bb,2^(b9+6))local b1,bd={},{}for n,ap in ipairs(bc)do if type(ap)==\"table\"then local N=ap[1].code+257;b1[N]=(b1[N]or 0)+1;bd[ap[2].code]=(bd[ap[2].code]or 0)+1 else b1[ap]=(b1[ap]or 0)+1 end end;local be=b0(b1)local bf=b0(bd)local b5={}for X=0,285 do local bg=false;for n,ap in ipairs(be)do if ap[1]==X then bg=true;b5[X]=ap[3]+1;break end end;if not bg then b5[X]=0 end end;while#b5>256 and b5[#b5]==0 do b5[#b5]=nil end;local a5=#b5-256;for X=0,31 do local bg=false;for n,ap in ipairs(bf)do if ap[1]==X then bg=true;b5[#b5+1]=ap[3]+1;break end end;if not bg then b5[#b5+1]=0 end end;while#b5>257 and b5[#b5]==0 do b5[#b5]=nil end;local a6=#b5-a5-257;local bh={}do local X=0;while X<=#b5 do if b5[X]==b5[X+1]and b5[X+1]==b5[X+2]then if b5[X]==0 then local Y=3;while b5[X+Y]==0 and Y<138 do Y=Y+1 end;if Y>=11 then bh[#bh+1]={18,Y-11}else bh[#bh+1]={17,Y-3}end;X=X+Y elseif b5[X+2]==b5[X+3]then local Y=4;while b5[X+Y]==b5[X]and Y<7 do Y=Y+1 end;bh[#bh+1]=b5[X]bh[#bh+1]={16,Y-4}X=X+Y else bh[#bh+1]=b5[X]bh[#bh+1]=b5[X]bh[#bh+1]=b5[X]X=X+3 end else bh[#bh+1]=b5[X]X=X+1 end end end;b1={}for n,ap in ipairs(bh)do if type(ap)==\"table\"then b1[ap[1]]=(b1[ap[1]]or 0)+1 else b1[ap]=(b1[ap]or 0)+1 end end;local bi=b0(b1,7)local bj={}for X,ap in ipairs(u)do local aR=0;for n,bk in ipairs(bi)do if bk[1]==ap then aR=bk[3]+1;break end end;r(aR..\" \")bj[X]=aR end;q()while#bj>4 and bj[#bj]==0 do bj[#bj]=nil end;local bl=#bb*8+8;local bm=#bc*9;for n,ap in ipairs(bc)do if type(ap)==\"table\"then bm=bm+15 end end;local bn=aF(bc,s,t)local bo=ba and math.huge or aF(bc,be,bf)+aJ(bh,bi)+#bj*3;local bp=g(bl,bm,bn,bo)q(\"Sizes:\",bl,bm,bn,bo)aB(a1 and 1 or 0,1)if bp==bl then q(\"Writing uncompressed block\",bl)aB(0,2)aB()aB(#bb-1,16)aB(bit32.band(bit32.bnot(#bb-1),0xFFFF),16)aB.data=aB.data.._:sub(v,v+65535)elseif bp==bm then q(\"Writing LZSS block\",bm)aB(3,2)for n,N in ipairs(bc)do if type(N)==\"table\"then aB(N[1].raw+256,9)aB(N[2].raw,15)elseif N==256 then aB(511,9)else aB(N,9)end end else local E,a4;if bp==bn then q(\"Writing static block\",bn)aB(1,2)E,a4=s,t else q(\"Writing dynamic block\",bo)aB(2,2)E,a4=be,bf;aB(a5,5)aB(a6,5)aB(#bj-4,4)for n,ap in ipairs(bj)do aB(ap,3)end;aI(bh,bi,aB)end;aA(bc,E,a4,aB)end end;aB()return aB.data end;return{deflate=b8,inflate=Z}\n",setuser=false,size=10537,modified=1757997040103,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},cert={permissions={root={write=true,read=true,execute=true}},created=1757997040943,contents={["crypto.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040940,data="local a=require\"container\"local b=require\"cert.util\"local c=require\"ccryptolib.chacha20\"local d=require\"ccryptolib.poly1305\"local e=require\"ccryptolib.random\"local f=require\"ccryptolib.x25519\"local g=require\"aes\"local h=require\"sha2\"local i={}function i.exchangedKey(j,k,l)local m=j.privateKeyAlgorithm.type.string or j.privateKeyAlgorithm.type;local n=k.toBeSigned.subjectPublicKeyInfo.algorithm.type.string or k.toBeSigned.subjectPublicKeyInfo.algorithm.type;local o=l.toBeSigned.subjectPublicKeyInfo.algorithm.type.string or l.toBeSigned.subjectPublicKeyInfo.algorithm.type;assert(m==a.publicKeyAlgorithmOIDs.ED25519 or m==a.publicKeyAlgorithmOIDs.X25519,\"Unsupported originator private key type\")assert(n==a.publicKeyAlgorithmOIDs.X25519,\"Unsupported originator public key type\")assert(o==a.publicKeyAlgorithmOIDs.X25519,\"Unsupported receiver public key type\")return{encrypt=function(p)local q=e.random(16)local r=f.exchange(j.privateKey,l.toBeSigned.subjectPublicKeyInfo.subjectPublicKey.data)local s={kari={version=3,originator={issuerAndSerialNumber={issuer=k.toBeSigned.issuer,serialNumber=k.toBeSigned.serialNumber}},keyEncryptionAlgorithm={type=a.encryptionAlgorithmOIDs.AES256_CBC,iv=q},recipientEncryptedKeys={{encryptedKey=g.TableToString(g.EncryptCBC(b.pkcs7pad(g.StringToTable(p),16),g.StringToTable(r),g.StringToTable(q))),rid={issuerAndSerialNumber={issuer=l.toBeSigned.issuer,serialNumber=l.toBeSigned.serialNumber}}}}}}return s end,decrypt=function(t)if not t.kari or t.kari.version~=3 then return nil end;if not t.kari.originator.issuerAndSerialNumber then return nil end;if not b.compareNames(t.kari.originator.issuerAndSerialNumber.issuer,k.toBeSigned.issuer)then return nil end;if t.kari.originator.issuerAndSerialNumber.serialNumber~=k.toBeSigned.serialNumber then return nil end;local u=t.kari.keyEncryptionAlgorithm.type.string or t.kari.keyEncryptionAlgorithm.type;if u~=a.encryptionAlgorithmOIDs.AES128_CBC and u~=a.encryptionAlgorithmOIDs.AES192_CBC and u~=a.encryptionAlgorithmOIDs.AES256_CBC then return nil end;for v,w in ipairs(t.kari.recipientEncryptedKeys)do if w.rid.issuerAndSerialNumber and b.compareNames(w.rid.issuerAndSerialNumber.issuer,l.toBeSigned.issuer)and w.rid.issuerAndSerialNumber.serialNumber==l.toBeSigned.serialNumber then local r=f.exchange(j.privateKey,k.toBeSigned.subjectPublicKeyInfo.subjectPublicKey.data)local x,y=pcall(g.DecryptCBC,g.StringToTable(w.encryptedKey),g.StringToTable(r),g.StringToTable(t.kari.keyEncryptionAlgorithm.iv))if x and y and y[#y]>0 and y[#y]<17 then return g.TableToString(b.pkcs7unpad(y))end end end;return nil end}end;function i.sharedKey(z,A)local B;if#z==16 then B=a.encryptionAlgorithmOIDs.AES128_CBC elseif#z==24 then B=a.encryptionAlgorithmOIDs.AES192_CBC elseif#z==32 then B=a.encryptionAlgorithmOIDs.AES256_CBC else error(\"Invalid key length\",2)end;return{encrypt=function(p)local q=e.random(16)local s={kekri={version=4,kekid={subjectKeyIdentifier=A},keyEncryptionAlgorithm={type=B,iv=q},encryptedKey=g.TableToString(g.EncryptCBC(b.pkcs7pad(g.StringToTable(p),16),g.StringToTable(z),g.StringToTable(q)))}}return s end,decrypt=function(t)if not t.kekri or t.kekri.version~=4 then return nil end;if t.kekri.kekid.subjectKeyIdentifier~=A then return nil end;local u=t.kekri.keyEncryptionAlgorithm.type.string or t.kekri.keyEncryptionAlgorithm.type;if u~=B then return nil end;local x,y=pcall(g.DecryptCBC,g.StringToTable(t.kekri.encryptedKey),g.StringToTable(z),g.StringToTable(t.kekri.keyEncryptionAlgorithm.iv))if x and y and y[#y]>0 and y[#y]<17 then return g.TableToString(b.pkcs7unpad(y))end;return nil end}end;function i.passwordKey(C,D,E)D=D or h.sha256;local F,G;if D==h.sha1 then F=a.pseudoRandomFunctionOIDs.HMAC_SHA1;G=20 elseif D==h.sha224 then F=a.pseudoRandomFunctionOIDs.HMAC_SHA224;G=28 elseif D==h.sha256 then F=a.pseudoRandomFunctionOIDs.HMAC_SHA256;G=32 elseif D==h.sha384 then F=a.pseudoRandomFunctionOIDs.HMAC_SHA384;G=48 elseif D==h.sha512 then F=a.pseudoRandomFunctionOIDs.HMAC_SHA512;G=64 elseif D==h.sha512_224 then F=a.pseudoRandomFunctionOIDs.HMAC_SHA512_224;G=28 elseif D==h.sha512_256 then F=a.pseudoRandomFunctionOIDs.HMAC_SHA512_256;G=32 else error(\"Unknown hashing algorithm\",2)end;return{encrypt=function(p)local s={pwri={version=0,keyDerivationAlgorithm={type=a.keyDerivationAlgorithmOIDs.PBKDF2,pbkdf2Parameters={iterationCount=E or 4096,salt={specified=e.random(16)},keyLength=32,prf={type=F}}},keyEncryptionAlgorithm={type=a.encryptionAlgorithmOIDs.AES256_CBC,iv=e.random(16)},encryptedKey=\"\"}}local H=b.pbkdf2(function(I,J)return{h.hmac(D,J,string.char(table.unpack(I))):byte(1,-1)}end,G,C,s.pwri.keyDerivationAlgorithm.pbkdf2Parameters.salt.specified,E or 4096,32)s.pwri.encryptedKey=g.TableToString(g.EncryptCBC(b.pkcs7pad(g.StringToTable(p),16),g.StringToTable(H),g.StringToTable(s.pwri.keyEncryptionAlgorithm.iv)))return s end,decrypt=function(t)if not t.pwri or t.pwri.version~=0 then return nil end;if not t.pwri.keyDerivationAlgorithm or(t.pwri.keyDerivationAlgorithm.type.string or t.pwri.keyDerivationAlgorithm.type)~=a.keyDerivationAlgorithmOIDs.PBKDF2 then return nil end;if not t.pwri.keyDerivationAlgorithm.pbkdf2Parameters.prf then return nil end;local K=t.pwri.keyDerivationAlgorithm.pbkdf2Parameters.prf.type.string or t.pwri.keyDerivationAlgorithm.pbkdf2Parameters.prf.type;if K~=F then return nil end;local u=t.pwri.keyEncryptionAlgorithm.type.string or t.pwri.keyEncryptionAlgorithm.type;local L;if u==a.encryptionAlgorithmOIDs.AES128_CBC then L=16 elseif u==a.encryptionAlgorithmOIDs.AES192_CBC then L=24 elseif u==a.encryptionAlgorithmOIDs.AES256_CBC then L=32 else return nil end;local H=b.pbkdf2(function(I,J)return{h.hmac(D,J,string.char(table.unpack(I))):byte(1,-1)}end,G,C,t.pwri.keyDerivationAlgorithm.pbkdf2Parameters.salt.specified,t.pwri.keyDerivationAlgorithm.pbkdf2Parameters.iterationCount,L)local x,y=pcall(g.DecryptCBC,g.StringToTable(t.pwri.encryptedKey),g.StringToTable(H),g.StringToTable(t.pwri.keyEncryptionAlgorithm.iv))if x and y and y[#y]>0 and y[#y]<17 then return g.TableToString(b.pkcs7unpad(y))end;return nil end}end;function i.encrypt(M,...)local N=a.pkcs7ContentTypeOIDs.data;if type(M)==\"table\"then N=M.type.string or M.type;M=a.savePKCS7(M)end;local p=e.random(32)local O=e.random(12)local P={type=a.pkcs7ContentTypeOIDs.authEnvelopedData,content={version=0,recipientInfos={},authEncryptedContentInfo={contentEncryptionAlgorithm={type=a.encryptionAlgorithmOIDs.ChaCha20_Poly1305,nonce=O},contentType=N,encryptedContent=c.crypt(p,O,M)},mac=d.mac(p,M)}}for Q,w in ipairs{...}do P.content.recipientInfos[Q]=w.encrypt(p)if not P.content.recipientInfos[Q].pwri then P.content.version=2 end end;return P end;function i.decrypt(P,...)if(P.type.string or P.type)~=a.pkcs7ContentTypeOIDs.authEnvelopedData then error(\"Not an authenticated data object\",2)end;if(P.content.authEncryptedContentInfo.contentEncryptionAlgorithm.type.string or P.content.authEncryptedContentInfo.contentEncryptionAlgorithm.type)~=a.encryptionAlgorithmOIDs.ChaCha20_Poly1305 then error(\"Unsupported algorithm\",2)end;local p;for v,t in ipairs{...}do for v,s in ipairs(P.content.recipientInfos)do p=t.decrypt(s)if p then break end end;if p then break end end;if not p then error(\"Could not find valid key encryptor\",2)end;local M=c.crypt(p,P.content.authEncryptedContentInfo.contentEncryptionAlgorithm.nonce,P.content.authEncryptedContentInfo.encryptedContent)if d.mac(p,M)~=P.content.mac then error(\"Could not authenticate data\",2)end;if(P.content.authEncryptedContentInfo.contentType.string or P.content.authEncryptedContentInfo.contentType)==a.pkcs7ContentTypeOIDs.data then return M end;return a.loadPKCS7(M)end;function i.encryptKey(j,C,D,E)D=D or h.sha256;local M=a.savePKCS8(j)local R={encryptionAlgorithm={type=a.passwordBasedEncryptionSchemeOIDs.PBES2,pbes2Parameters={encryptionScheme={type=a.encryptionAlgorithmOIDs.AES256_CBC,iv=e.random(16)},keyDerivationFunc={type=a.keyDerivationAlgorithmOIDs.PBKDF2,pbkdf2Parameters={salt={specified=e.random(16)},iterationCount=E or 4096,prf={type=\"\"}}}}},encryptedData=\"\"}local G;if D==h.sha1 then R.encryptionAlgorithm.pbes2Parameters.keyDerivationFunc.pbkdf2Parameters.prf.type=a.pseudoRandomFunctionOIDs.HMAC_SHA1;G=20 elseif D==h.sha224 then R.encryptionAlgorithm.pbes2Parameters.keyDerivationFunc.pbkdf2Parameters.prf.type=a.pseudoRandomFunctionOIDs.HMAC_SHA224;G=28 elseif D==h.sha256 then R.encryptionAlgorithm.pbes2Parameters.keyDerivationFunc.pbkdf2Parameters.prf.type=a.pseudoRandomFunctionOIDs.HMAC_SHA256;G=32 elseif D==h.sha384 then R.encryptionAlgorithm.pbes2Parameters.keyDerivationFunc.pbkdf2Parameters.prf.type=a.pseudoRandomFunctionOIDs.HMAC_SHA384;G=48 elseif D==h.sha512 then R.encryptionAlgorithm.pbes2Parameters.keyDerivationFunc.pbkdf2Parameters.prf.type=a.pseudoRandomFunctionOIDs.HMAC_SHA512;G=64 elseif D==h.sha512_224 then R.encryptionAlgorithm.pbes2Parameters.keyDerivationFunc.pbkdf2Parameters.prf.type=a.pseudoRandomFunctionOIDs.HMAC_SHA512_224;G=28 elseif D==h.sha512_256 then R.encryptionAlgorithm.pbes2Parameters.keyDerivationFunc.pbkdf2Parameters.prf.type=a.pseudoRandomFunctionOIDs.HMAC_SHA512_256;G=32 else error(\"Unknown hashing algorithm\",2)end;local p=b.pbkdf2(function(I,J)return{h.hmac(D,J,string.char(table.unpack(I))):byte(1,-1)}end,G,C,R.encryptionAlgorithm.pbes2Parameters.keyDerivationFunc.pbkdf2Parameters.salt.specified,E or 4096,32)R.encryptedData=g.TableToString(g.EncryptCBC(b.pkcs7pad(g.StringToTable(M),16),g.StringToTable(p),g.StringToTable(R.encryptionAlgorithm.pbes2Parameters.encryptionScheme.iv)))return R end;function i.decryptKey(R,C)local G,D,L;local S=R.encryptionAlgorithm.pbes2Parameters.keyDerivationFunc.pbkdf2Parameters.prf.type;local T=R.encryptionAlgorithm.pbes2Parameters.encryptionScheme.type;if type(S)==\"table\"then S=S.string end;if type(T)==\"table\"then T=T.string end;if S==a.pseudoRandomFunctionOIDs.HMAC_SHA1 then D=h.sha1;G=20 elseif S==a.pseudoRandomFunctionOIDs.HMAC_SHA224 then D=h.sha224;G=28 elseif S==a.pseudoRandomFunctionOIDs.HMAC_SHA256 then D=h.sha256;G=32 elseif S==a.pseudoRandomFunctionOIDs.HMAC_SHA384 then D=h.sha384;G=48 elseif S==a.pseudoRandomFunctionOIDs.HMAC_SHA512 then D=h.sha512;G=64 elseif S==a.pseudoRandomFunctionOIDs.HMAC_SHA512_224 then D=h.sha512_224;G=28 elseif S==a.pseudoRandomFunctionOIDs.HMAC_SHA512_256 then D=h.sha512_256;G=32 else error(\"Unknown hashing algorithm\",2)end;if T==a.encryptionAlgorithmOIDs.AES128_CBC then L=16 elseif T==a.encryptionAlgorithmOIDs.AES192_CBC then L=24 elseif T==a.encryptionAlgorithmOIDs.AES256_CBC then L=32 else error(\"Unknown encryption algorithm\",2)end;local p=b.pbkdf2(function(I,J)return{h.hmac(D,J,string.char(table.unpack(I))):byte(1,-1)}end,G,C,R.encryptionAlgorithm.pbes2Parameters.keyDerivationFunc.pbkdf2Parameters.salt.specified,R.encryptionAlgorithm.pbes2Parameters.keyDerivationFunc.pbkdf2Parameters.iterationCount,L)return a.loadPKCS8(g.TableToString(b.pkcs7unpad(g.DecryptCBC(g.StringToTable(R.encryptedData),g.StringToTable(p),g.StringToTable(R.encryptionAlgorithm.pbes2Parameters.encryptionScheme.iv)))))end;return i\n",setuser=false,size=11075,modified=1757997040933,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["csr.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040941,data="local a=require\"system.expect\"local b=require\"container\"local c=require\"ccryptolib.ed25519\"local d=require\"ccryptolib.x25519\"local e={}function e.generate(f,g,h)a(1,f,\"table\")a(2,g,\"table\")a(3,h,\"table\",\"nil\")local i=f.privateKeyAlgorithm.type.string or f.privateKeyAlgorithm.type;local j;if i==b.signatureAlgorithmOIDs.ED25519 then j=c.publicKey(f.privateKey)elseif i==b.publicKeyAlgorithmOIDs.X25519 then j=d.publicKey(f.privateKey)else error(\"Unsupported private key algorithm\",2)end;local k={toBeSigned={version=0,subject=g,subjectPKInfo={algorithm=f.privateKeyAlgorithm,subjectPublicKey={type=\"BIT STRING\",data=j,unused=0}},attributes=h or{}},signatureAlgorithm={type=b.signatureAlgorithmOIDs.ED25519},signature={type=\"BIT STRING\",data=\"\",unused=0}}k.signature.data=c.sign(f.privateKey,c.publicKey(f.privateKey),b.encodePKCS10InnerInfo(k))return k end;function e.sign(k,l,f,m,n,o)a(1,k,\"table\")a(2,l,\"table\")a(3,f,\"table\")a(4,m,\"number\",\"table\")a(5,n,\"number\")local i=f.privateKeyAlgorithm.type.string or f.privateKeyAlgorithm.type;if i~=b.signatureAlgorithmOIDs.ED25519 and i~=b.publicKeyAlgorithmOIDs.X25519 then error(\"Unsupported private key algorithm\",2)end;i=l.toBeSigned.subjectPublicKeyInfo.algorithm.type.string or l.toBeSigned.subjectPublicKeyInfo.algorithm.type;if i~=b.signatureAlgorithmOIDs.ED25519 then error(\"Unsupported certificate public key algorithm\",2)end;i=k.signatureAlgorithm.type.string or k.signatureAlgorithm.type;if i~=b.signatureAlgorithmOIDs.ED25519 then error(\"Unsupported request signature algorithm\",2)end;if not c.verify(o or k.toBeSigned.subjectPKInfo.subjectPublicKey.data,b.encodePKCS10InnerInfo(k),k.signature.data)then error(\"Unable to verify request signature\",2)end;local p=os.date(\"!*t\")local q=os.date(\"!*t\",os.time()+n*86400)local r={toBeSigned={version=1,issuer=l.toBeSigned.subject,serialNumber=m,signature={type=b.signatureAlgorithmOIDs.ED25519},subject=k.toBeSigned.subject,subjectPublicKeyInfo=k.toBeSigned.subjectPKInfo,validity={notBefore={generalTime=p},notAfter={generalTime=q}}},signatureAlgorithm={type=b.signatureAlgorithmOIDs.ED25519},signature={type=\"BIT STRING\",data=\"\",unused=0}}for s,t in ipairs(k.toBeSigned.attributes)do if(t.type.string or t.type)==b.pkcs9AttributeOIDs.extensionRequest then r.toBeSigned.version=3;r.toBeSigned.extensions=t.values.extensionRequest end end;r.signature.data=c.sign(f.privateKey,l.toBeSigned.subjectPublicKeyInfo.subjectPublicKey.data,b.encodeX509InnerCertificate(r))return r end;function e.selfSign(k,f,m,n)a(1,k,\"table\")a(2,f,\"table\")a(3,m,\"number\",\"table\")a(4,n,\"number\")local i=f.privateKeyAlgorithm.type.string or f.privateKeyAlgorithm.type;if i~=b.signatureAlgorithmOIDs.ED25519 and i~=b.publicKeyAlgorithmOIDs.X25519 then error(\"Unsupported private key algorithm\",2)end;i=k.signatureAlgorithm.type.string or k.signatureAlgorithm.type;if i~=b.signatureAlgorithmOIDs.ED25519 then error(\"Unsupported request signature algorithm\",2)end;if not c.verify(c.publicKey(f.privateKey),b.encodePKCS10InnerInfo(k),k.signature.data)then error(\"Unable to verify request signature\",2)end;local p=os.date(\"!*t\")local q=os.date(\"!*t\",os.time()+n*86400)local r={toBeSigned={version=1,issuer=k.toBeSigned.subject,serialNumber=m,signature={type=b.signatureAlgorithmOIDs.ED25519},subject=k.toBeSigned.subject,subjectPublicKeyInfo=k.toBeSigned.subjectPKInfo,validity={notBefore={generalTime=p},notAfter={generalTime=q}}},signatureAlgorithm={type=b.signatureAlgorithmOIDs.ED25519},signature={type=\"BIT STRING\",data=\"\",unused=0}}for s,t in ipairs(k.toBeSigned.attributes)do if(t.type.string or t.type)==b.pkcs9AttributeOIDs.extensionRequest then r.toBeSigned.version=3;r.toBeSigned.extensions=t.values.extensionRequest end end;r.signature.data=c.sign(f.privateKey,c.publicKey(f.privateKey),b.encodeX509InnerCertificate(r))return r end;return e\n",setuser=false,size=3825,modified=1757997040934,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["signature.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040942,data="local a=require\"container\"local b=require\"chain\"local c=require\"cert.util\"local d=require\"sha2\"local e=require\"ccryptolib.ed25519\"local f={}function f.sign(g,h,i,j)local k=a.pkcs7ContentTypeOIDs.data;if type(i)==\"table\"then k=i.type;i=a.savePKCS7(i)end;assert(h.privateKeyAlgorithm.type.string==a.signatureAlgorithmOIDs.ED25519,\"Private key must be Ed25519\")assert(g.toBeSigned.subjectPublicKeyInfo.algorithm.type.string==a.signatureAlgorithmOIDs.ED25519,\"Certificate must be Ed25519\")local l=os.date(\"!*t\")l.type=\"UTCTime\"local m={{type=a.pkcs9AttributeOIDs.contentType,values={contentType=k}},{type=a.pkcs9AttributeOIDs.messageDigest,values={messageDigest=d.hex_to_bin(d.sha3_512(i))}},{type=a.pkcs9AttributeOIDs.signingTime,values={signingTime={utcTime=l}}}}local n={g}if j then for o,p in ipairs(j)do n[#n+1]=p end end;local q={type=a.pkcs7ContentTypeOIDs.signedData,content={version=1,digestAlgorithms={{type=a.digestAlgorithmOIDs.SHA3_512}},encapContentInfo={eContentType=k,eContent=nil},certificates=n,crls=nil,signerInfos={{version=1,sid={issuerAndSerialNumber={issuer=g.toBeSigned.issuer,serialNumber=g.toBeSigned.serialNumber}},digestAlgorithm={type=a.digestAlgorithmOIDs.SHA3_512},signedAttrs=m,signatureAlgorithm={type=a.signatureAlgorithmOIDs.ED25519},signature=e.sign(h.privateKey,g.toBeSigned.subjectPublicKeyInfo.subjectPublicKey.data,a.encodePKCS7SignedAttrs(m))}}}}return q end;function f.getCertificate(q,r)local s=c.reduceName(q.content.signerInfos[r].sid.issuerAndSerialNumber.issuer)for o,t in ipairs(q.content.certificates)do local u=c.reduceName(t.toBeSigned.issuer)local v=true;for w,x in pairs(s)do if u[w]~=x then v=false;break end end;if v and t.toBeSigned.serialNumber.data==q.content.signerInfos[1].sid.issuerAndSerialNumber.serialNumber.data then return t end end;return nil end;function f.verify(q,i,y)y=y or 1;if q.type.string~=a.pkcs7ContentTypeOIDs.signedData then return false,\"PKCS#7 block is not signed data\"end;if q.content.digestAlgorithms[1].type.string~=a.digestAlgorithmOIDs.SHA3_512 then return false,\"Unsupported digest algorithm\"end;if q.content.signerInfos[y].digestAlgorithm.type.string~=a.digestAlgorithmOIDs.SHA3_512 then return false,\"Unsupported digest algorithm\"end;if q.content.signerInfos[y].signatureAlgorithm.type.string~=a.signatureAlgorithmOIDs.ED25519 then return false,\"Unsupported signature algorithm\"end;local g=f.getCertificate(q,y)if not g then return false,\"Could not find certificate in signature\"end;local z=a.encodePKCS7SignedAttrs(q.content.signerInfos[y].signedAttrs)if not e.verify(g.toBeSigned.subjectPublicKeyInfo.subjectPublicKey.data,z,q.content.signerInfos[y].signature)then return false,\"Failed to validate signature\"end;local A;for o,p in ipairs(q.content.signerInfos[y].signedAttrs)do if p.type.string==a.pkcs9AttributeOIDs.messageDigest then A=p.values.messageDigest;break end end;if d.hex_to_bin(d.sha3_512(i))~=A then return false,\"Failed to validate digest\"end;return true end;return f\n",setuser=false,size=2970,modified=1757997040935,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["util.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040943,data="local a={}local b=bit32.band;local c=bit32.bxor;local d=bit32.rshift;local e=unpack or table.unpack;function a.reduceName(f)local g={}for h,i in ipairs(f.rdnSequence)do local j=i[1].value;if type(j)==\"table\"then j=select(2,next(j))end;g[i[1].type.string]=j end;return g end;function a.compareNames(k,l)local m=a.reduceName(k)local n=a.reduceName(l)for o,i in pairs(m)do if n[o]~=i then return false end end;for o,i in pairs(n)do if m[o]~=i then return false end end;return true end;function a.pbkdf2(p,q,r,s,t,u)s=type(s)==\"table\"and s or{tostring(s):byte(1,-1)}u=u or 32;local v=1;local w={}while u>0 do local x={}local y={e(s)}local z=u>q and q or u;y[#y+1]=b(d(v,24),0xFF)y[#y+1]=b(d(v,16),0xFF)y[#y+1]=b(d(v,8),0xFF)y[#y+1]=b(v,0xFF)for A=1,t do y=p(y,r)for o=1,z do x[o]=c(y[o],x[o]or 0)end end;u=u-z;v=v+1;for o=1,z do w[#w+1]=x[o]end end;return string.char(e(w))end;function a.pkcs7pad(B,C)local D=C-#B%C;for h=1,D do B[#B+1]=D end;return B end;function a.pkcs7unpad(B)local D=B[#B]for h=1,D do B[#B]=nil end;return B end;return a\n",setuser=false,size=1038,modified=1757997040936,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["container.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040940,data="local a=require\"system.expect\"local b=require\"system.serialization\"local c=require\"asn1\"local d={}d.nameOIDs={commonName=\"2.5.4.3\",countryName=\"2.5.4.6\",localityName=\"2.5.4.7\",stateOrProvinceName=\"2.5.4.8\",streetAddress=\"2.5.4.9\",organizationIdentifier=\"2.5.4.97\",organizationName=\"2.5.4.10\",organizationalUnitName=\"2.5.4.11\",serialNumber=\"2.5.4.5\",surname=\"2.5.4.4\",givenName=\"2.5.4.42\",title=\"2.5.4.12\",initials=\"2.5.4.43\",generationQualifier=\"2.5.4.44\",uniqueIdentifier=\"2.5.4.45\",dnQualifier=\"2.5.4.46\",pseudonym=\"2.5.4.65\",userID=\"0.9.2342.19200300.100.1.1\",domainComponent=\"0.9.2342.19200300.100.1.25\",emailAddress=\"1.2.840.113549.1.9.1\",jurisdictionLocalityName=\"1.3.6.1.4.1.311.60.2.1.1\",jurisdictionStateOrProvinceName=\"1.3.6.1.4.1.311.60.2.1.2\",jurisdictionCountryName=\"1.3.6.1.4.1.311.60.2.1.3\",businessCategory=\"2.5.4.15\",postalAddress=\"1.5.4.16\",postalCode=\"1.5.4.17\",unstructuredName=\"1.2.840.113549.1.9.2\"}d.signatureAlgorithmOIDs={RSA_MD5=\"1.2.840.113549.1.1.4\",RSA_SHA1=\"1.2.840.113549.1.1.5\",RSA_SHA224=\"1.2.840.113549.1.1.14\",RSA_SHA256=\"1.2.840.113549.1.1.11\",RSA_SHA384=\"1.2.840.113549.1.1.12\",RSA_SHA512=\"1.2.840.113549.1.1.13\",RSA_SHA3_224=\"2.16.840.1.101.3.4.3.13\",RSA_SHA3_256=\"2.16.840.1.101.3.4.3.14\",RSA_SHA3_384=\"2.16.840.1.101.3.4.3.15\",RSA_SHA3_512=\"2.16.840.1.101.3.4.3.16\",RSASSA_PSS=\"1.2.840.113549.1.1.10\",ECDSA_SHA1=\"1.2.840.10045.4.1\",ECDSA_SHA224=\"1.2.840.10045.4.3.1\",ECDSA_SHA256=\"1.2.840.10045.4.3.2\",ECDSA_SHA384=\"1.2.840.10045.4.3.3\",ECDSA_SHA512=\"1.2.840.10045.4.3.4\",ECDSA_SHA3_224=\"2.16.840.1.101.3.4.3.9\",ECDSA_SHA3_256=\"2.16.840.1.101.3.4.3.10\",ECDSA_SHA3_384=\"2.16.840.1.101.3.4.3.11\",ECDSA_SHA3_512=\"2.16.840.1.101.3.4.3.12\",DSA_SHA1=\"1.2.840.10040.4.3\",DSA_SHA224=\"2.16.840.1.101.3.4.3.1\",DSA_SHA256=\"2.16.840.1.101.3.4.3.2\",DSA_SHA384=\"2.16.840.1.101.3.4.3.3\",DSA_SHA512=\"2.16.840.1.101.3.4.3.4\",ED25519=\"1.3.101.112\",ED448=\"1.3.101.113\"}d.extendedKeyUsageOIDs={serverAuth=\"1.3.6.1.5.5.7.3.1\",clientAuth=\"1.3.6.1.5.5.7.3.2\",codeSigning=\"1.3.6.1.5.5.7.3.3\",emailProtection=\"1.3.6.1.5.5.7.3.4\",timeStamping=\"1.3.6.1.5.5.7.3.8\",ocspSigning=\"1.3.6.1.5.5.7.3.9\",anyExtendedKeyUsage=\"2.5.29.37.0\",smartcardLogon=\"1.3.6.1.4.1.311.20.2.2\",kerberosPKInitKDC=\"1.3.6.1.5.2.3.5\",IPSec_IKE=\"1.3.6.1.5.5.7.3.17\",certificateTransparency=\"1.3.6.1.4.1.11129.2.4.4\"}d.extensionOIDs={basicConstraints=\"2.5.29.19\",keyUsage=\"2.5.29.15\",subjectAlternativeName=\"2.5.29.17\",issuerAlternativeName=\"2.5.29.18\",subjectKeyIdentifier=\"2.5.29.14\",nameConstraints=\"2.5.29.30\",crlDistributionPoints=\"2.5.29.31\"}d.publicKeyAlgorithmOIDs={DSA=\"1.2.840.10040.4.1\",EC_PUBLIC_KEY=\"1.2.840.10045.2.1\",RSAES_PKCS1v15=\"1.2.840.113549.1.1.1\",RSASSA_PSS=\"1.2.840.113549.1.1.10\",X25519=\"1.3.101.110\",X448=\"1.3.101.111\",ED25519=\"1.3.101.112\",ED448=\"1.3.101.113\"}d.digestAlgorithmOIDs={SHA1=\"1.3.14.3.2.26\",SHA224=\"2.16.840.1.101.3.4.2.4\",SHA256=\"2.16.840.1.101.3.4.2.1\",SHA384=\"2.16.840.1.101.3.4.2.2\",SHA512=\"2.16.840.1.101.3.4.2.3\",SHA3_224=\"2.16.840.1.101.3.4.2.7\",SHA3_256=\"2.16.840.1.101.3.4.2.8\",SHA3_384=\"2.16.840.1.101.3.4.2.9\",SHA3_512=\"2.16.840.1.101.3.4.2.10\"}d.encryptionAlgorithmOIDs={AES128_CBC=\"2.16.840.1.101.3.4.1.2\",AES192_CBC=\"2.16.840.1.101.3.4.1.22\",AES256_CBC=\"2.16.840.1.101.3.4.1.42\",ChaCha20_Poly1305=\"1.2.840.113549.1.9.16.0.66\"}d.keyDerivationAlgorithmOIDs={PBKDF2=\"1.2.840.113549.1.5.12\"}d.passwordBasedEncryptionSchemeOIDs={PBES2=\"1.2.840.113549.1.5.13\"}d.pseudoRandomFunctionOIDs={HMAC_SHA1=\"1.2.840.113549.2.7\",HMAC_SHA224=\"1.2.840.113549.2.8\",HMAC_SHA256=\"1.2.840.113549.2.9\",HMAC_SHA384=\"1.2.840.113549.2.10\",HMAC_SHA512=\"1.2.840.113549.2.11\",HMAC_SHA512_224=\"1.2.840.113549.2.12\",HMAC_SHA512_256=\"1.2.840.113549.2.13\"}local e=c.sequence{{\"fieldType\",c.oid},{\"parameters\",c.optional(c.any)}}local f=c.sequence{{\"a\",c.octet_string},{\"b\",c.octet_string},{\"seed\",c.optional(c.bit_string)}}local g=c.sequence{{\"version\",c.integer},{\"fieldID\",e},{\"curve\",f},{\"base\",c.octet_string},{\"order\",c.integer},{\"cofactor\",c.optional(c.integer)}}local h=c.choice{{\"ecParameters\",g},{\"namedCurve\",c.oid},{\"implicitlyCA\",c.null}}local i={[d.publicKeyAlgorithmOIDs.EC_PUBLIC_KEY]={{\"ecParameters\",h}},[d.signatureAlgorithmOIDs.ECDSA_SHA1]={},[d.signatureAlgorithmOIDs.ECDSA_SHA224]={},[d.signatureAlgorithmOIDs.ECDSA_SHA256]={},[d.signatureAlgorithmOIDs.ECDSA_SHA384]={},[d.signatureAlgorithmOIDs.ECDSA_SHA512]={},[d.signatureAlgorithmOIDs.ECDSA_SHA3_224]={},[d.signatureAlgorithmOIDs.ECDSA_SHA3_256]={},[d.signatureAlgorithmOIDs.ECDSA_SHA3_384]={},[d.signatureAlgorithmOIDs.ECDSA_SHA3_512]={},[d.signatureAlgorithmOIDs.ED25519]={},[d.publicKeyAlgorithmOIDs.X25519]={},[d.digestAlgorithmOIDs.SHA1]={},[d.digestAlgorithmOIDs.SHA224]={},[d.digestAlgorithmOIDs.SHA256]={},[d.digestAlgorithmOIDs.SHA384]={},[d.digestAlgorithmOIDs.SHA512]={},[d.digestAlgorithmOIDs.SHA3_224]={},[d.digestAlgorithmOIDs.SHA3_256]={},[d.digestAlgorithmOIDs.SHA3_384]={},[d.digestAlgorithmOIDs.SHA3_512]={},[d.encryptionAlgorithmOIDs.AES128_CBC]={{\"iv\",c.octet_string}},[d.encryptionAlgorithmOIDs.AES192_CBC]={{\"iv\",c.octet_string}},[d.encryptionAlgorithmOIDs.AES256_CBC]={{\"iv\",c.octet_string}},[d.encryptionAlgorithmOIDs.ChaCha20_Poly1305]={{\"nonce\",c.octet_string}},[d.pseudoRandomFunctionOIDs.HMAC_SHA1]={},[d.pseudoRandomFunctionOIDs.HMAC_SHA224]={},[d.pseudoRandomFunctionOIDs.HMAC_SHA256]={},[d.pseudoRandomFunctionOIDs.HMAC_SHA384]={},[d.pseudoRandomFunctionOIDs.HMAC_SHA512]={},[d.pseudoRandomFunctionOIDs.HMAC_SHA512_224]={},[d.pseudoRandomFunctionOIDs.HMAC_SHA512_256]={}}local j=c.class(i)local function k(l)return c.sequence{{\"toBeSigned\",l},{\"signatureAlgorithm\",j},{\"signature\",c.bit_string}}end;local m=c.choice{{\"teletexString\",c.teletex_string},{\"printableString\",c.printable_string},{\"bmpString\",c.bmp_string},{\"universalString\",c.universal_string},{\"uTF8String\",c.utf8string}}local n=c.class{[d.nameOIDs.commonName]={{\"value\",m}},[d.nameOIDs.surname]={{\"value\",m}},[d.nameOIDs.givenName]={{\"value\",m}},[d.nameOIDs.initials]={{\"value\",m}},[d.nameOIDs.generationQualifier]={{\"value\",m}},[d.nameOIDs.uniqueIdentifier]={{\"value\",c.octet_string}},[d.nameOIDs.dnQualifier]={{\"value\",c.printable_string}},[d.nameOIDs.serialNumber]={{\"value\",c.printable_string}},[d.nameOIDs.pseudonym]={{\"value\",m}},[d.nameOIDs.countryName]={{\"value\",c.printable_string}},[d.nameOIDs.localityName]={{\"value\",m}},[d.nameOIDs.jurisdictionLocalityName]={{\"value\",m}},[d.nameOIDs.stateOrProvinceName]={{\"value\",m}},[d.nameOIDs.jurisdictionStateOrProvinceName]={{\"value\",m}},[d.nameOIDs.streetAddress]={{\"value\",m}},[d.nameOIDs.organizationName]={{\"value\",m}},[d.nameOIDs.organizationalUnitName]={{\"value\",m}},[d.nameOIDs.title]={{\"value\",m}},[d.nameOIDs.organizationIdentifier]={{\"value\",m}},[d.nameOIDs.businessCategory]={{\"value\",m}},[d.nameOIDs.postalAddress]={{\"value\",m}},[d.nameOIDs.postalCode]={{\"value\",m}}}local o=c.set_of(n)local p=c.sequence_of(o)local q=c.choice{{\"rdnSequence\",p}}local r=c.choice{{\"utcTime\",c.utc_time},{\"generalTime\",c.generalized_time}}local s=c.sequence{{\"notBefore\",r},{\"notAfter\",r}}local t=c.sequence{{\"algorithm\",j},{\"subjectPublicKey\",c.bit_string}}local u=c.sequence{{\"extnId\",c.oid},{\"critical\",c.optional(c.boolean)},{\"extnValue\",c.octet_string}}local v=c.sequence{{\"version\",c.default(c.explicit(0,c.integer),1)},{\"serialNumber\",c.integer},{\"signature\",j},{\"issuer\",q},{\"validity\",s},{\"subject\",q},{\"subjectPublicKeyInfo\",t},{\"issuerUniqueID\",c.optional(c.implicit(1,c.bit_string))},{\"subjectUniqueID\",c.optional(c.implicit(2,c.bit_string))},{\"extensions\",c.optional(c.explicit(3,c.sequence_of(u)))}}local w=k(v)local x=c.sequence{{\"version\",c.optional(c.integer)},{\"signature\",j},{\"issuer\",q},{\"thisUpdate\",r},{\"nextUpdate\",c.optional(r)},{\"revokedCertificates\",c.optional(c.sequence_of(c.sequence{{\"serialNumber\",c.integer},{\"revocationDate\",r},{\"crlEntryExtensions\",c.optional(c.sequence_of(u))}}))},{\"crlExtensions\",c.optional(c.explicit(0,c.sequence_of(u)))}}local y=k(x)d.pkcs9AttributeOIDs={emailAddress=\"1.2.840.113549.1.9.1\",unstructuredName=\"1.2.840.113549.1.9.2\",contentType=\"1.2.840.113549.1.9.3\",messageDigest=\"1.2.840.113549.1.9.4\",signingTime=\"1.2.840.113549.1.9.5\",countersignature=\"1.2.840.113549.1.9.6\",challengePassword=\"1.2.840.113549.1.9.7\",unstructuredAddress=\"1.2.840.113549.1.9.8\",extendedCertificateAttributes=\"1.2.840.113549.1.9.9\",signingDescription=\"1.2.840.113549.1.9.13\",extensionRequest=\"1.2.840.113549.1.9.14\",smimeCapabilities=\"1.2.840.113549.1.9.15\",friendlyName=\"1.2.840.113549.1.9.20\",localKeyId=\"1.2.840.113549.1.9.21\",userPKCS12=\"2.16.840.1.113730.3.1.216\",pkcs15Token=\"1.2.840.113549.1.9.25.1\",encryptedPrivateKeyInfo=\"1.2.840.113549.1.9.25.2\",randomNonce=\"1.2.840.113549.1.9.25.3\",sequenceNumber=\"1.2.840.113549.1.9.25.4\",pkcs7PDU=\"1.2.840.113549.1.9.25.5\",dateOfBirth=\"1.3.6.1.5.5.7.9.1\",placeOfBirth=\"1.3.6.1.5.5.7.9.2\",gender=\"1.3.6.1.5.5.7.9.3\",countryOfCitizenship=\"1.3.6.1.5.5.7.9.4\",countryOfResidence=\"1.3.6.1.5.5.7.9.5\",pseudonym=\"2.5.4.65\"}local z=c.choice{{\"ia5string\",c.ia5string},{\"directoryString\",m}}local A={[d.pkcs9AttributeOIDs.emailAddress]={{\"values\",c.set{{\"emailAddress\",c.ia5string}}}},[d.pkcs9AttributeOIDs.unstructuredName]={{\"values\",c.set{{\"unstructuredName\",z}}}},[d.pkcs9AttributeOIDs.unstructuredAddress]={{\"values\",c.set{{\"unstructuredAddress\",m}}}},[d.pkcs9AttributeOIDs.dateOfBirth]={{\"values\",c.set{{\"dateOfBirth\",c.generalized_time}}}},[d.pkcs9AttributeOIDs.placeOfBirth]={{\"values\",c.set{{\"placeOfBirth\",m}}}},[d.pkcs9AttributeOIDs.gender]={{\"values\",c.set{{\"gender\",c.printable_string}}}},[d.pkcs9AttributeOIDs.countryOfCitizenship]={{\"values\",c.set{{\"countryOfCitizenship\",c.printable_string}}}},[d.pkcs9AttributeOIDs.countryOfResidence]={{\"values\",c.set{{\"countryOfResidence\",c.printable_string}}}},[d.pkcs9AttributeOIDs.pseudonym]={{\"values\",c.set{{\"pseudonym\",m}}}},[d.pkcs9AttributeOIDs.contentType]={{\"values\",c.set{{\"contentType\",c.oid}}}},[d.pkcs9AttributeOIDs.messageDigest]={{\"values\",c.set{{\"messageDigest\",c.octet_string}}}},[d.pkcs9AttributeOIDs.signingTime]={{\"values\",c.set{{\"signingTime\",r}}}},[d.pkcs9AttributeOIDs.randomNonce]={{\"values\",c.set{{\"randomNonce\",c.octet_string}}}},[d.pkcs9AttributeOIDs.sequenceNumber]={{\"values\",c.set{{\"sequenceNumber\",c.integer}}}},[d.pkcs9AttributeOIDs.challengePassword]={{\"values\",c.set{{\"challengePassword\",m}}}},[d.pkcs9AttributeOIDs.extensionRequest]={{\"values\",c.set{{\"extensionRequest\",c.sequence_of(u)}}}},[d.pkcs9AttributeOIDs.friendlyName]={{\"values\",c.set{{\"friendlyName\",c.bmp_string}}}},[d.pkcs9AttributeOIDs.localKeyId]={{\"values\",c.set{{\"localKeyId\",c.octet_string}}}},[d.pkcs9AttributeOIDs.signingDescription]={{\"values\",c.set{{\"signingDescription\",m}}}},[d.pkcs9AttributeOIDs.smimeCapabilities]={{\"values\",c.set{{\"smimeCapabilities\",c.sequence_of(j)}}}}}local B=c.class(A)A[d.pkcs9AttributeOIDs.extendedCertificateAttributes]={{\"values\",c.set{{\"extendedCertificateAttributes\",c.set_of(B)}}}}local C=c.sequence{{\"version\",c.integer},{\"subject\",q},{\"subjectPKInfo\",t},{\"attributes\",c.explicit(0,c.set_of(B))}}local D=k(C)local E=c.sequence{{\"encryptionAlgorithm\",j},{\"encryptedData\",c.octet_string}}A[d.pkcs9AttributeOIDs.encryptedPrivateKeyInfo]={{\"values\",c.set{{\"encryptedPrivateKeyInfo\",E}}}}local F=c.sequence{{\"version\",c.integer},{\"privateKeyAlgorithm\",j},{\"privateKey\",c.octet_string},{\"attributes\",c.optional(c.set_of(B))}}d.pkcs7ContentTypeOIDs={data=\"1.2.840.113549.1.7.1\",signedData=\"1.2.840.113549.1.7.2\",envelopedData=\"1.2.840.113549.1.7.3\",digestedData=\"1.2.840.113549.1.7.5\",encryptedData=\"1.2.840.113549.1.7.6\",authData=\"1.2.840.113549.1.9.16.1.2\",authEnvelopedData=\"1.2.840.113549.1.9.16.1.23\"}local G=c.sequence{{\"eContentType\",c.oid},{\"eContent\",c.optional(c.explicit(0,c.octet_string))}}local H=c.sequence{{\"issuer\",q},{\"serialNumber\",c.integer}}local I=c.choice{{\"issuerAndSerialNumber\",H},{\"subjectKeyIdentifier\",c.explicit(0,c.octet_string)}}local J=c.sequence{{\"version\",c.integer},{\"sid\",I},{\"digestAlgorithm\",j},{\"signedAttrs\",c.optional(c.implicit(0,c.set_of(B)))},{\"signatureAlgorithm\",j},{\"signature\",c.octet_string},{\"unsignedAttrs\",c.optional(c.implicit(1,c.set_of(B)))}}A[d.pkcs9AttributeOIDs.countersignature]={{\"countersignature\",J}}local K=c.sequence{{\"version\",c.integer},{\"digestAlgorithms\",c.set_of(j)},{\"encapContentInfo\",G},{\"certificates\",c.optional(c.implicit(0,c.set_of(w)))},{\"crls\",c.optional(c.implicit(1,c.set_of(y)))},{\"signerInfos\",c.set_of(J)}}local L=c.sequence{{\"certs\",c.optional(c.implicit(0,c.set_of(w)))},{\"crls\",c.optional(c.implicit(1,c.set_of(y)))}}local M=c.sequence{{\"version\",c.integer},{\"rid\",I},{\"keyEncryptionAlgorithm\",j},{\"encryptedKey\",c.octet_string}}local N=c.choice{{\"issuerAndSerialNumber\",H},{\"subjectKeyIdentifier\",c.explicit(0,c.integer)},{\"originatorKey\",c.explicit(1,c.sequence{{\"algorithm\",j},{\"publicKey\",c.bit_string}})}}local O=c.sequence{{\"type\",c.oid},{\"value\",c.any}}local P=c.sequence{{\"subjectKeyIdentifier\",c.octet_string},{\"date\",c.optional(c.generalized_time)},{\"other\",c.optional(O)}}local Q=c.choice{{\"issuerAndSerialNumber\",H},{\"rKeyId\",c.implicit(0,P)}}local R=c.sequence{{\"rid\",Q},{\"encryptedKey\",c.octet_string}}local S=c.sequence{{\"version\",c.integer},{\"originator\",c.explicit(0,N)},{\"ukm\",c.optional(c.explicit(1,c.octet_string))},{\"keyEncryptionAlgorithm\",j},{\"recipientEncryptedKeys\",c.sequence_of(R)}}local T=c.sequence{{\"version\",c.integer},{\"kekid\",P},{\"keyEncryptionAlgorithm\",j},{\"encryptedKey\",c.octet_string}}local U=c.sequence{{\"version\",c.integer},{\"keyDerivationAlgorithm\",c.optional(c.explicit(0,j))},{\"keyEncryptionAlgorithm\",j},{\"encryptedKey\",c.octet_string}}local V=c.sequence{{\"type\",c.oid},{\"value\",c.any}}local W=c.choice{{\"ktri\",M},{\"kari\",c.explicit(1,S)},{\"kekri\",c.explicit(2,T)},{\"pwri\",c.explicit(3,U)},{\"ori\",c.explicit(4,V)}}local X=c.sequence{{\"contentType\",c.oid},{\"contentEncryptionAlgorithm\",j},{\"encryptedContent\",c.optional(c.implicit(0,c.octet_string))}}local Y=c.sequence{{\"version\",c.integer},{\"originatorInfo\",c.optional(c.implicit(0,L))},{\"recipientInfos\",c.set_of(W)},{\"encryptedContentInfo\",X},{\"unprotectedAttrs\",c.optional(c.explicit(1,c.set_of(B)))}}local Z=c.sequence{{\"version\",c.integer},{\"digestAlgorithm\",j},{\"encapContentInfo\",G},{\"digest\",c.octet_string}}local _=c.sequence{{\"version\",c.integer},{\"encryptedContentInfo\",X},{\"unprotectedAttrs\",c.optional(c.implicit(1,c.set_of(B)))}}local a0=c.sequence{{\"version\",c.integer},{\"originatorInfo\",c.optional(c.implicit(0,L))},{\"recipientInfos\",c.set_of(W)},{\"macAlgorithm\",j},{\"digestAlgorithm\",c.optional(c.explicit(1,j))},{\"encapContentInfo\",G},{\"authAttrs\",c.optional(c.implicit(2,c.set_of(B)))},{\"mac\",c.octet_string},{\"unauthAttrs\",c.optional(c.implicit(3,c.set_of(B)))}}local a1=c.sequence{{\"version\",c.integer},{\"originatorInfo\",c.optional(c.implicit(0,L))},{\"recipientInfos\",c.set_of(W)},{\"authEncryptedContentInfo\",X},{\"authAttrs\",c.optional(c.implicit(2,c.set_of(B)))},{\"mac\",c.octet_string},{\"unauthAttrs\",c.optional(c.implicit(3,c.set_of(B)))}}local a2=c.class{[d.pkcs7ContentTypeOIDs.data]={{\"content\",c.explicit(0,c.octet_string)}},[d.pkcs7ContentTypeOIDs.signedData]={{\"content\",c.explicit(0,K)}},[d.pkcs7ContentTypeOIDs.envelopedData]={{\"content\",c.explicit(0,Y)}},[d.pkcs7ContentTypeOIDs.digestedData]={{\"content\",c.explicit(0,Z)}},[d.pkcs7ContentTypeOIDs.encryptedData]={{\"content\",c.explicit(0,_)}},[d.pkcs7ContentTypeOIDs.authData]={{\"content\",c.explicit(0,a0)}},[d.pkcs7ContentTypeOIDs.authEnvelopedData]={{\"content\",c.explicit(0,a1)}}}A[d.pkcs9AttributeOIDs.pkcs7PDU]={{\"values\",c.set{{\"contentInfo\",a2}}}}local a3=c.sequence{{\"salt\",c.choice{{\"specified\",c.octet_string},{\"otherSource\",j}}},{\"iterationCount\",c.integer},{\"keyLength\",c.optional(c.integer)},{\"prf\",c.optional(j)}}local a4=c.sequence{{\"keyDerivationFunc\",j},{\"encryptionScheme\",j}}i[d.keyDerivationAlgorithmOIDs.PBKDF2]={{\"pbkdf2Parameters\",a3}}i[d.passwordBasedEncryptionSchemeOIDs.PBES2]={{\"pbes2Parameters\",a4}}function d.decodePEM(a5)local type=a5:match(\"^%-%-%-%-%-BEGIN ([^%-]+)\")local a6=b.base64.decode(a5:match(\"%-%-%-%-%-BEGIN [^%-]+%-%-%-%-%-\\n(.+)\\n%-%-%-%-%-END [^%-]+%-%-%-%-%-\"):gsub(\"[^A-Za-z0-9/+=]\",\"\"))return a6,type end;function d.encodePEM(a5,type)return([[-----BEGIN %s-----\n%s\n-----END %s-----\n]]):format(type,b.base64.encode(a5):gsub((\".\"):rep(64),\"%0\\n\"),type)end;function d.loadPKCS7(a5)local a7=a2.decode(a5)return a7 end;function d.loadPKCS8(a5)local a8=F.decode(a5)if a8.privateKeyAlgorithm.type.string==d.publicKeyAlgorithmOIDs.ED25519 then a8.privateKey=c.octet_string.decode(a8.privateKey)end;return a8 end;function d.loadPKCS8Encrypted(a5)return E.decode(a5)end;function d.loadPKCS10(a5)return D.decode(a5)end;function d.loadPKCS12(a5)end;function d.loadX509(a5)local a9=w.decode(a5)return a9 end;function d.savePKCS7(a7)return a2.encode(a7)end;function d.encodePKCS7SignedAttrs(aa)return c.set_of(B).encode(aa)end;function d.savePKCS8(a8)if(a8.privateKeyAlgorithm.type.string or a8.privateKeyAlgorithm.type)==d.publicKeyAlgorithmOIDs.ED25519 then return F.encode{version=a8.version,privateKeyAlgorithm=a8.privateKeyAlgorithm,privateKey=c.octet_string.encode(a8.privateKey),attributes=a8.attributes}end;return F.encode(a8)end;function d.savePKCS8Encrypted(a8)return E.encode(a8)end;function d.encodePKCS10InnerInfo(ab)return C.encode(ab.toBeSigned)end;function d.savePKCS10(ab)return D.encode(ab)end;function d.savePKCS12(ac)end;function d.encodeX509InnerCertificate(a9)return v.encode(a9.toBeSigned)end;function d.saveX509(a9)return w.encode(a9)end;function d.print(a9,ad)ad=ad or 0;for ae,af in pairs(a9)do io.write((\"  \"):rep(ad)..(type(ae)==\"string\"and ae:gsub(\"%f[A-Z]([A-Z])\",\" %1\"):gsub(\"^%w\",string.upper)or ae)..\": \")if type(af)==\"table\"and type(af.type)~=\"string\"then io.write(\"\\n\")d.print(af,ad+1)elseif type(af)==\"table\"then if af.type==\"INTEGER\"then io.write(af.data:gsub(\".\",function(ag)return(\"%02X \"):format(string.byte(ag))end)..\"\\n\")elseif af.type==\"BIT STRING\"then io.write(af.data:gsub(\".\",function(ag)return(\"%02X \"):format(string.byte(ag))end)..\"\\n\")elseif af.type==\"OBJECT IDENTIFIER\"then io.write(af.string)for ah,ai in pairs(d)do if type(ai)==\"table\"then for aj,ak in pairs(ai)do if ak==af.string then io.write(\" (\"..aj..\")\")break end end end end;io.write(\"\\n\")elseif af.type==\"UTCTime\"then io.write(os.date(\"%c\\n\",os.time(af)))else io.write(\" (\"..af.type..\")\\n\")end elseif type(af)==\"string\"or type(af)==\"number\"then if string.match(af,\"[^\\32-\\126]\")then io.write(string.gsub(af,\".\",function(ag)return(\"%02X \"):format(string.byte(ag))end)..\"\\n\")else io.write(af..\"\\n\")end else io.write(\"\\n\")end end end;return d\n",setuser=false,size=18528,modified=1757997040933,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["chain.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040939,data="local a=require\"system.expect\"local b=require\"system.filesystem\"local c=require\"ccryptolib.ed25519\"local d=require\"container\"local e=require\"cert.util\"local f={}local function g(h,i,j,k)for l,m in ipairs(k)do if h.toBeSigned.serialNumber==m or type(h.toBeSigned.serialNumber)==\"table\"and type(m)==\"table\"and h.toBeSigned.serialNumber.data==m.data then return false,\"Certificate was revoked\"end end;local n,o;for l,m in ipairs(i)do if e.compareNames(m.toBeSigned.subject,h.toBeSigned.issuer)then n,o=m,false end end;for l,m in ipairs(j)do if e.compareNames(m.toBeSigned.subject,h.toBeSigned.issuer)then n,o=m,true end end;if not n then return false,\"Could not find path to root\"end;local p=d.encodeX509InnerCertificate(h)if n.toBeSigned.subjectPublicKeyInfo.algorithm.type.string~=d.signatureAlgorithmOIDs.ED25519 then return false,\"Certificate has unsupported signature type\"end;if not c.verify(n.toBeSigned.subjectPublicKeyInfo.subjectPublicKey.data,p,h.signature.data)then return false,\"Could not verify signature of certificate\"end;if o then return true end;if e.compareNames(h.toBeSigned.subject,h.toBeSigned.issuer)then return false,\"Chain certificate is self-signed\"end;return g(n,i,j,k)end;function f.validate(h,i,q,r)a(1,h,\"table\")a(2,i,\"table\",\"nil\")q=a(3,q,\"string\",\"nil\")or\"/etc/certs\"a(4,r,\"table\",\"nil\")local j,k={},{}if r then for l,m in ipairs(r)do j[#j+1]=m end end;if q~=\"\"and b.isDir(q)then for l,s in ipairs(b.list(q))do if b.isFile(b.combine(q,s))then local t=io.open(b.combine(q,s),\"rb\")if t then local u=t:read(\"*a\")t:close()local type=\"CERTIFICATE\"if u:match(\"^%-%-%-%-%-BEGIN\")then u,type=d.decodePEM(u)end;if type==\"CERTIFICATE\"then local v,w=pcall(d.loadX509,u)if v then j[#j+1]=w end elseif type==\"X509 CRL\"then local v,w=pcall(d.loadX509CRL,u)if v and w.toBeSigned.revokedCertificates then for l,m in ipairs(w.toBeSigned.revokedCertificates)do k[#k+1]=m.serialNumber end end end end end end end;return g(h,i or{},j,k)end;return f\n",setuser=false,size=1958,modified=1757997040932,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["init.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040942,data="local a=require\"system.expect\"local b=require\"chain\"local c=require\"container\"local d=require\"crypto\"local e=require\"csr\"local f=require\"signature\"local g=require\"cert.util\"local h=require\"ccryptolib.random\"local i={chain=b,container=c,crypto=d,csr=e,signature=f}function i.generatePrivateKeyForSigning(j)a(1,j,\"string\",\"nil\")local k=h.random(32)local l={version=1,privateKeyAlgorithm={type=c.signatureAlgorithmOIDs.ED25519},privateKey=k}if j then return k,c.encodePEM(c.savePKCS8Encrypted(d.encryptKey(l,j)),\"ENCRYPTED PRIVATE KEY\")else return k,c.encodePEM(c.savePKCS8(l),\"PRIVATE KEY\")end end;function i.generatePrivateKeyForEncryption(j)a(1,j,\"string\",\"nil\")local k=h.random(32)local l={version=1,privateKeyAlgorithm={type=c.publicKeyAlgorithmOIDs.X25519},privateKey=k}if j then return k,c.encodePEM(c.savePKCS8Encrypted(d.encryptKey(l,j)),\"ENCRYPTED PRIVATE KEY\")else return k,c.encodePEM(c.savePKCS8(l),\"PRIVATE KEY\")end end;local m={[c.nameOIDs.uniqueIdentifier]=true,[c.nameOIDs.dnQualifier]=true,[c.nameOIDs.serialNumber]=true,[c.nameOIDs.countryName]=true}function i.generateCSR(l,n,j)a(1,l,\"string\")a(2,n,\"table\")a(3,j,\"string\",\"nil\")local o,p=c.decodePEM(l)if p==\"ENCRYPTED PRIVATE KEY\"then if not j then error(\"Private key is encrypted, but no password was provided\",2)end;l=d.decryptKey(c.loadPKCS8Encrypted(o),j)else l=c.loadPKCS8(o)end;local q={rdnSequence={}}for r,s in pairs(n)do if not m[r]then s={uTF8String=s}end;q.rdnSequence[#q.rdnSequence+1]={{type=r,value=s}}end;return c.encodePEM(c.savePKCS10(e.generate(l,q)),\"CERTIFICATE REQUEST\")end;function i.signCSR(t,u,l,v,w,j)a(1,t,\"string\")a(2,u,\"string\")a(3,l,\"string\")a(4,v,\"number\",\"string\")a(5,w,\"number\")a(6,j,\"string\",\"nil\")local o,p=c.decodePEM(l)if p==\"ENCRYPTED PRIVATE KEY\"then if not j then error(\"Private key is encrypted, but no password was provided\",2)end;l=d.decryptKey(c.loadPKCS8Encrypted(o),j)else l=c.loadPKCS8(o)end;if type(v)==\"string\"then v={type=\"INTEGER\",data=v}end;return c.encodePEM(c.saveX509(e.sign(c.loadPKCS10(c.decodePEM(t)),c.loadX509(c.decodePEM(u)),l,v,w)),\"CERTIFICATE\")end;function i.selfSignCSR(t,l,v,w,j)a(1,t,\"string\")a(2,l,\"string\")a(3,v,\"number\",\"string\")a(4,w,\"number\")a(5,j,\"string\",\"nil\")local o,p=c.decodePEM(l)if p==\"ENCRYPTED PRIVATE KEY\"then if not j then error(\"Private key is encrypted, but no password was provided\",2)end;l=d.decryptKey(c.loadPKCS8Encrypted(o),j)else l=c.loadPKCS8(o)end;if type(v)==\"string\"then v={type=\"INTEGER\",data=v}end;return c.encodePEM(c.saveX509(e.selfSign(c.loadPKCS10(c.decodePEM(t)),l,v,w)),\"CERTIFICATE\")end;function i.encrypt(x,j)a(1,x,\"string\")a(2,j,\"string\")return c.encodePEM(c.savePKCS7(d.encrypt(x,d.passwordKey(j))),\"CMS\")end;function i.decrypt(x,j)a(1,x,\"string\")a(2,j,\"string\")return d.decrypt(c.loadPKCS7(c.decodePEM(x)),d.passwordKey(j))end;function i.encryptExchange(x,y,z,A,j)a(1,x,\"string\")a(2,y,\"string\")a(3,z,\"string\")a(4,A,\"string\")a(5,j,\"string\",\"nil\")local l,p=c.decodePEM(y)if p==\"ENCRYPTED PRIVATE KEY\"then if not j then error(\"Private key is encrypted, but no password was provided\",2)end;l=d.decryptKey(c.loadPKCS8Encrypted(l),j)else l=c.loadPKCS8(l)end;return c.encodePEM(c.savePKCS7(d.encrypt(x,d.exchangedKey(l,c.loadX509(c.decodePEM(z)),c.loadX509(c.decodePEM(A))))),\"CMS\")end;function i.decryptExchange(x,y,z,A,j)a(1,x,\"string\")a(2,y,\"string\")a(3,z,\"string\")a(4,A,\"string\")a(5,j,\"string\",\"nil\")local l,p=c.decodePEM(y)if p==\"ENCRYPTED PRIVATE KEY\"then if not j then error(\"Private key is encrypted, but no password was provided\",2)end;l=d.decryptKey(c.loadPKCS8Encrypted(l),j)else l=c.loadPKCS8(l)end;return d.decrypt(c.loadPKCS7(c.decodePEM(x)),d.exchangedKey(l,c.loadX509(c.decodePEM(A)),c.loadX509(c.decodePEM(z))))end;function i.sign(u,k,x,B,j)a(1,u,\"string\",\"table\")a(2,k,\"string\",\"table\")a(3,x,\"string\")a(4,B,\"table\",\"nil\")a(5,j,\"string\",\"nil\")if B then for C,s in ipairs(B)do B[C]=c.loadX509(c.decodePEM(s))end end;if type(u)==\"string\"then u=c.loadX509(c.decodePEM(u))end;if type(k)==\"string\"then local l,p=c.decodePEM(k)if p==\"ENCRYPTED PRIVATE KEY\"then if not j then error(\"Private key is encrypted, but no password was provided\",2)end;l=d.decryptKey(c.loadPKCS8Encrypted(l),j)else l=c.loadPKCS8(l)end;k=l end;return c.encodePEM(c.savePKCS7(f.sign(u,k,x,B)),\"PKCS7\")end;function i.verify(D,x,E,F,G)if E==nil then E=true end;a(1,D,\"string\",\"table\")a(2,x,\"string\")a(3,E,\"boolean\")a(4,F,\"string\",\"nil\")a(5,G,\"table\",\"nil\")if type(D)==\"string\"then D=c.loadPKCS7(c.decodePEM(D))end;local H,I=f.verify(D,x)if not H then return false,I end;if E then if G then for C,s in ipairs(G)do if type(s)==\"string\"then G[C]=c.loadX509(c.decodePEM(s))end end end;return b.validate(f.getCertificate(D,1),D.content.certificates,F,G)end;return true end;function i.validate(u,J,F,G)a(1,u,\"string\",\"table\")a(2,J,\"table\",\"nil\")a(3,F,\"string\",\"nil\")a(4,G,\"string\",\"nil\")if type(u)==\"string\"then u=c.loadX509(c.decodePEM(u))end;if J then for C,s in ipairs(J)do if type(s)==\"string\"then J[C]=c.loadX509(c.decodePEM(s))end end end;if G then for C,s in ipairs(G)do if type(s)==\"string\"then G[C]=c.loadX509(c.decodePEM(s))end end end;return b.validate(u,J,F,G)end;function i.print(x)local o,p=c.decodePEM(x)local K;if p==\"CERTIFICATE\"then K=c.loadX509(o)elseif p==\"PKCS#7\"or p==\"CMS\"then K=c.loadPKCS7(o)elseif p==\"PRIVATE KEY\"then K=c.loadPKCS8(o)elseif p==\"ENCRYPTED PRIVATE KEY\"then K=c.loadPKCS8Encrypted(o)elseif p==\"CERTIFICATE REQUEST\"then K=c.loadPKCS10(o)else error(\"Unknown PEM data type\",2)end;return c.print(K)end;return i\n",setuser=false,size=5492,modified=1757997040934,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997040943,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},["muxzcat.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997041461,data="local a=bit32;local b={}local c={}local d={}local e={}local f={}local g={}setmetatable(b,{__sub=function(h)local i={h,__sub=function(self,j)return a.band(self[1],j)end}return setmetatable(i,i)end})setmetatable(c,{__sub=function(h)local i={h,__sub=function(self,j)return a.bor(self[1],j)end}return setmetatable(i,i)end})setmetatable(d,{__sub=function(h)local i={h,__sub=function(self,j)return a.bxor(self[1],j)end}return setmetatable(i,i)end})setmetatable(f,{__sub=function(h)local i={h,__sub=function(self,j)return a.lshift(self[1],j)end}return setmetatable(i,i)end})setmetatable(g,{__sub=function(h)local i={h,__sub=function(self,j)return a.rshift(self[1],j)end}return setmetatable(i,i)end})setmetatable(e,{__sub=function(k,l)return a.bnot(l)end})local m,n;local function o(p,q,r,...)if r~=nil then p[q]=r;return o(p,q+1,...)end end;local function s(t,u,v)local w;if m then w,m=m:sub(1,v),m:sub(v+1)for q=1,#w,256 do o(t,u+q-1,w:byte(q,q+256))end;return#w else w=io.input():read(v)for q=1,#w,256 do o(t,u+q-1,w:byte(q,q+256))end;return#w end end;local function x(p,q,y)if q==y then return p[q]elseif q>y then return nil else return p[q],x(p,q+1,y)end end;local function z(t,u,v)if n then for q=u,u+v-1,256 do n=n..string.char(x(t,q,math.min(u+v-1,q+255)))end;return v else for q=1,v,256 do io.output():write(string.char(x(t,q+u-1,math.min(u+v-1,q+u+254))))end;return v end end;local A=0;local B=0;local C=0;local D=0;local E=0;local F=0;local G=0;local H=0;local I=0;local J=1;local K=1;local L=1;local M=1;local N=0;local O=0;local P=0;local Q=0;local R=0;local S=0;local T=0;local U=0;local V=0;local W=0;local X=0;local Y=0;local Z=0;local _={}local a0=setmetatable({},{__index=function(k,a1)return _[a1]end,__newindex=function(k,a1,a2)_[a1]=a2-b-0xFFFF end})local a3={}local a4=setmetatable({},{__index=function(k,a1)return a3[a1]end,__newindex=function(k,a1,a2)a3[a1]=a2-b-0xFF end})local a5={}local a6=setmetatable({},{__index=function(k,a1)return a5[a1]end,__newindex=function(k,a1,a2)a5[a1]=a2-b-0xFF end})local function a7()A=0;B=0;C=0;D=0;E=0;F=0;G=0;H=0;I=0;J=1;K=1;L=1;M=1;N=0;O=0;P=0;Q=0;R=0;S=0;T=0;U=0;V=0;W=0;X=0;Y=0;Z=0;_={}a3={}a5={}end;local function a8(a9)if N~=0 and N<274 then local aa=N;if a9-E<aa then aa=a9-E end;if H==0 and B-G<=aa then H=B end;G=G+aa;N=N-aa;while aa~=0 do aa=aa-1;a6[E]=a6[E-J+(E<J and F or 0)]-b-0xFF;E=E+1 end end end;local function ab(ac,ad)local ae=1-f-Y-1;local af=1-f-X-1;local ag=0;local ah;repeat local ai=H==0 and B-G<ac-E and E+B-G or ac;N=0;repeat local aj=0;local ak=0;local al=0;local am=0;local an=G-b-ae;aj=0+I-f-4+an;al=a0[aj]if C<16777216 then C=C-f-8;D=D-f-8-c-a4[A]A=A+1 end;ak=a.rshift(C,11)*al;if D<ak then local ao=0;assert(al<=0x7fffffff and al<=2048)C=ak;a0[aj]=al+a.rshift(2048-al,5)aj=1846;if H~=0 or G~=0 then aj=aj+768*(G-b-af-f-W+a.rshift(a6[(E==0 and F or E)-1],Z))end;if I<7 then I=I-(I<4 and I or 3)ao=1;repeat al=a0[aj+ao]if C<16777216 then C=C-f-8;D=D-f-8-c-a4[A]A=A+1 end;ak=a.rshift(C,11)*al;if D<ak then C=ak;a0[aj+ao]=al+a.rshift(2048-al,5)ao=ao+ao else C=C-ak;D=D-ak;a0[aj+ao]=al-a.rshift(al,5)ao=ao+ao+1 end until not(ao<0x100)else local ap=a6[E-J+(E<J and F or 0)]local aq=0x100;I=I-(I<10 and 3 or 6)ao=1;repeat local ar;local as;assert(aq==0 or aq==0x100)ap=ap-f-1;ar=ap-b-aq;as=aj+aq+ar+ao;al=a0[as]if C<16777216 then C=C-f-8;D=D-f-8-c-a4[A]A=A+1 end;ak=a.rshift(C,11)*al;if D<ak then C=ak;a0[as]=al+a.rshift(2048-al,5)ao=ao+ao;aq=aq-b-(e-ar)else C=C-ak;D=D-ak;a0[as]=al-a.rshift(al,5)ao=ao+ao+1;aq=aq-b-ar end until not(ao<0x100)end;a6[E]=ao-b-0xFF;E=E+1;G=G+1 else C=C-ak;D=D-ak;a0[aj]=al-a.rshift(al,5)aj=192+I;al=a0[aj]if C<16777216 then C=C-f-8;D=D-f-8-c-a4[A]A=A+1 end;ak=a.rshift(C,11)*al;local at=true;if D<ak then assert(al<=0x7fffffff and al<=2048)C=ak;a0[aj]=al+a.rshift(2048-al,5)I=I+12;aj=818 else C=C-ak;D=D-ak;a0[aj]=al-a.rshift(al,5)if H==0 and G==0 then return 1 end;aj=204+I;al=a0[aj]if C<16777216 then C=C-f-8;D=D-f-8-c-a4[A]A=A+1 end;ak=a.rshift(C,11)*al;if D<ak then assert(al<=0x7fffffff and al<=2048)C=ak;a0[aj]=al+a.rshift(2048-al,5)aj=240+I-f-4+an;al=a0[aj]if C<16777216 then C=C-f-8;D=D-f-8-c-a4[A]A=A+1 end;ak=a.rshift(C,11)*al;if D<ak then C=ak;a0[aj]=al+a.rshift(2048-al,5)a6[E]=a6[E-J+(E<J and F or 0)]-b-0xFF;E=E+1;G=G+1;I=I<7 and 9 or 11;at=false end;if at then C=C-ak;D=D-ak;a0[aj]=al-a.rshift(al,5)end else C=C-ak;D=D-ak;a0[aj]=al-a.rshift(al,5)aj=216+I;al=a0[aj]if C<16777216 then C=C-f-8;D=D-f-8-c-a4[A]A=A+1 end;ak=a.rshift(C,11)*al;if D<ak then C=ak;a0[aj]=al+a.rshift(2048-al,5)am=K else C=C-ak;D=D-ak;a0[aj]=al-a.rshift(al,5)aj=228+I;al=a0[aj]if C<16777216 then C=C-f-8;D=D-f-8-c-a4[A]A=A+1 end;ak=a.rshift(C,11)*al;if D<ak then C=ak;a0[aj]=al+a.rshift(2048-al,5)am=L else C=C-ak;D=D-ak;a0[aj]=al-a.rshift(al,5)am=M;M=L end;L=K end;K=J;J=am end;if at then I=I<7 and 8 or 11;aj=1332 end end;if at then do local au;local av;local aw=aj+0;al=a0[aw]if C<16777216 then C=C-f-8;D=D-f-8-c-a4[A]A=A+1 end;ak=a.rshift(C,11)*al;if D<ak then assert(al<=0x7fffffff and al<=2048)C=ak;a0[aw]=al+a.rshift(2048-al,5)aw=aj+2+an-f-3;av=0;au=8 else C=C-ak;D=D-ak;a0[aw]=al-a.rshift(al,5)aw=aj+1;al=a0[aw]if C<16777216 then C=C-f-8;D=D-f-8-c-a4[A]A=A+1 end;ak=a.rshift(C,11)*al;if D<ak then assert(al<=0x7fffffff and al<=2048)C=ak;a0[aw]=al+a.rshift(2048-al,5)aw=aj+130+an-f-3;av=8;au=8 else C=C-ak;D=D-ak;a0[aw]=al-a.rshift(al,5)aw=aj+258;av=8+8;au=256 end end;do N=1;repeat al=a0[aw+N]if C<16777216 then C=C-f-8;D=D-f-8-c-a4[A]A=A+1 end;ak=a.rshift(C,11)*al;if D<ak then C=ak;a0[aw+N]=al+a.rshift(2048-al,5)N=N+N else C=C-ak;D=D-ak;a0[aw+N]=al-a.rshift(al,5)N=N+N+1 end until not(N<au)N=N-au end;N=N+av end;if I>=12 then aj=432+(N<4 and N or 4-1)-f-6;do am=1;repeat al=a0[aj+am]if C<16777216 then C=C-f-8;D=D-f-8-c-a4[A]A=A+1 end;ak=a.rshift(C,11)*al;if D<ak then C=ak;a0[aj+am]=al+a.rshift(2048-al,5)am=am+am else C=C-ak;D=D-ak;a0[aj+am]=al-a.rshift(al,5)am=am+am+1 end until not(am<64)am=am-64 end;assert(am<=0x7fffffff and am<64)if am>=4 then local ax=am;local ay=a.rshift(am,1)-1;am=2-c-(am-b-1)if ax<14 then am=am-f-ay;aj=688+am-ax-1;do local az=1;ag=1;repeat al=a0[aj+ag]if C<16777216 then C=C-f-8;D=D-f-8-c-a4[A]A=A+1 end;ak=a.rshift(C,11)*al;if D<ak then C=ak;a0[aj+ag]=al+a.rshift(2048-al,5)ag=ag+ag else C=C-ak;D=D-ak;a0[aj+ag]=al-a.rshift(al,5)ag=ag+ag+1;am=am-c-az end;az=az-f-1;ay=ay-1 until not(ay~=0)end else ay=ay-4;repeat if C<16777216 then C=C-f-8;D=D-f-8-c-a4[A]A=A+1 end;C=a.rshift(C,1)if D-C-b-0x80000000~=0 then am=am-f-1 else D=D-C;am=am-f-1+1 end;ay=ay-1 until not(ay~=0)aj=802;am=am-f-4;do ag=1;al=a0[aj+ag]assert(al<=0x7fffffff and al<=2048)if C<16777216 then C=C-f-8;D=D-f-8-c-a4[A]A=A+1 end;ak=a.rshift(C,11)*al;if D<ak then C=ak;a0[aj+ag]=al+a.rshift(2048-al,5)ag=ag+ag else C=C-ak;D=D-ak;a0[aj+ag]=al-a.rshift(al,5)ag=ag+ag+1;am=am-c-1 end;al=a0[aj+ag]assert(al<=0x7fffffff and al<=2048)if C<16777216 then C=C-f-8;D=D-f-8-c-a4[A]A=A+1 end;ak=a.rshift(C,11)*al;if D<ak then C=ak;a0[aj+ag]=al+a.rshift(2048-al,5)ag=ag+ag else C=C-ak;D=D-ak;a0[aj+ag]=al-a.rshift(al,5)ag=ag+ag+1;am=am-c-2 end;al=a0[aj+ag]assert(al<=0x7fffffff and al<=2048)if C<16777216 then C=C-f-8;D=D-f-8-c-a4[A]A=A+1 end;ak=a.rshift(C,11)*al;if D<ak then C=ak;a0[aj+ag]=al+a.rshift(2048-al,5)ag=ag+ag else C=C-ak;D=D-ak;a0[aj+ag]=al-a.rshift(al,5)ag=ag+ag+1;am=am-c-4 end;al=a0[aj+ag]assert(al<=0x7fffffff and al<=2048)if C<16777216 then C=C-f-8;D=D-f-8-c-a4[A]A=A+1 end;ak=a.rshift(C,11)*al;if D<ak then C=ak;a0[aj+ag]=al+a.rshift(2048-al,5)ag=ag+ag else C=C-ak;D=D-ak;a0[aj+ag]=al-a.rshift(al,5)ag=ag+ag+1;am=am-c-8 end end;if e-am==0 then N=N+274;I=I-12;break end end end;assert(am<=0x7fffffff and am<=1610612736)M=L;L=K;K=J;J=am+1;if H==0 then if am>=G then return 1 end else if am>=H then return 1 end end;I=I<12+7 and 7 or 7+3 end;N=N+2;if ai==E then return 1 end;do local aA=ai-E;local aB=aA<N and aA or N;local aC=E-J+(E<J and F or 0)G=G+aB;N=N-aB;if aC+aB<=F then assert(E>aC)assert(aB>0)repeat a6[E]=a6[aC]-b-0xFF;E=E+1;aC=aC+1;aB=aB-1 until not(aB~=0)else repeat a6[E]=a6[aC]-b-0xFF;E=E+1;aC=aC+1;if aC==F then aC=0 end until not(aB~=0)end end end end until not(E<ai and A<ad)if C<16777216 then C=C-f-8;D=D-f-8-c-a4[A]A=A+1 end;if G>=B then H=B end;a8(ac)until not(E<ac and A<ad and N<274)if N>274 then N=274 end;return 0 end;local function aD(aE,aF)local aG=C;local aH=D;local aI=I;local aJ;local aK;local aL;local aM;local aN=G-b-(1-f-Y-1)aK=0+aI-f-4+aN;aM=a0[aK]if aG<16777216 then if aE>=aF then return 0 end;aG=aG-f-8;aH=aH-f-8-c-a4[aE]aE=aE+1 end;aL=a.rshift(aG,11)*aM;if aH<aL then local aO=1;aG=aL;aK=1846;if H~=0 or G~=0 then aK=aK+768*(G-b-(1-f-X-1)-f-W+a.rshift(a6[(E==0 and F or E)-1],Z))end;if aI<7 then repeat aM=a0[aK+aO]if aG<16777216 then if aE>=aF then return 0 end;aG=aG-f-8;aH=aH-f-8-c-a4[aE]aE=aE+1 end;aL=a.rshift(aG,11)*aM;if aH<aL then aG=aL;aO=aO+aO else aG=aG-aL;aH=aH-aL;aO=aO+aO+1 end until not(aO<0x100)else local aP=a6[E-J+(E<J and F or 0)]local aQ=0x100;repeat local aR;local aS;assert(aQ==0 or aQ==0x100)aP=aP-f-1;aR=aP-b-aQ;aS=aK+aQ+aR+aO;aM=a0[aS]if aG<16777216 then if aE>=aF then return 0 end;aG=aG-f-8;aH=aH-f-8-c-a4[aE]aE=aE+1 end;aL=a.rshift(aG,11)*aM;if aH<aL then aG=aL;aO=aO+aO;aQ=aQ-b-(e-aR)else aG=aG-aL;aH=aH-aL;aO=aO+aO+1;aQ=aQ-b-aR end until not(aO<0x100)end;aJ=1 else local aT;aG=aG-aL;aH=aH-aL;aK=192+aI;aM=a0[aK]if aG<16777216 then if aE>=aF then return 0 end;aG=aG-f-8;aH=aH-f-8-c-a4[aE]aE=aE+1 end;aL=a.rshift(aG,11)*aM;if aH<aL then aG=aL;aI=0;aK=818;aJ=2 else aG=aG-aL;aH=aH-aL;aJ=3;aK=204+aI;aM=a0[aK]if aG<16777216 then if aE>=aF then return 0 end;aG=aG-f-8;aH=aH-f-8-c-a4[aE]aE=aE+1 end;aL=a.rshift(aG,11)*aM;if aH<aL then aG=aL;aK=240+aI-f-4+aN;aM=a0[aK]if aG<16777216 then if aE>=aF then return 0 end;aG=aG-f-8;aH=aH-f-8-c-a4[aE]aE=aE+1 end;aL=a.rshift(aG,11)*aM;if aH<aL then aG=aL;if aG<16777216 then if aE>=aF then return 0 end;aG=aG-f-8;aH=aH-f-8-c-a4[aE]aE=aE+1 end;return 3 else aG=aG-aL;aH=aH-aL end else aG=aG-aL;aH=aH-aL;aK=216+aI;aM=a0[aK]if aG<16777216 then if aE>=aF then return 0 end;aG=aG-f-8;aH=aH-f-8-c-a4[aE]aE=aE+1 end;aL=a.rshift(aG,11)*aM;if aH<aL then aG=aL else aG=aG-aL;aH=aH-aL;aK=228+aI;aM=a0[aK]if aG<16777216 then if aE>=aF then return 0 end;aG=aG-f-8;aH=aH-f-8-c-a4[aE]aE=aE+1 end;aL=a.rshift(aG,11)*aM;if aH<aL then aG=aL else aG=aG-aL;aH=aH-aL end end end;aI=12;aK=1332 end;do local aU;local aV;local aW=aK+0;aM=a0[aW]if aG<16777216 then if aE>=aF then return 0 end;aG=aG-f-8;aH=aH-f-8-c-a4[aE]aE=aE+1 end;aL=a.rshift(aG,11)*aM;if aH<aL then aG=aL;aW=aK+2+aN-f-3;aV=0;aU=8 else aG=aG-aL;aH=aH-aL;aW=aK+1;aM=a0[aW]if aG<16777216 then if aE>=aF then return 0 end;aG=aG-f-8;aH=aH-f-8-c-a4[aE]aE=aE+1 end;aL=a.rshift(aG,11)*aM;if aH<aL then aG=aL;aW=aK+130+aN-f-3;aV=8;aU=8 else aG=aG-aL;aH=aH-aL;aW=aK+258;aV=8+8;aU=256 end end;do aT=1;repeat aM=a0[aW+aT]if aG<16777216 then if aE>=aF then return 0 end;aG=aG-f-8;aH=aH-f-8-c-a4[aE]aE=aE+1 end;aL=a.rshift(aG,11)*aM;if aH<aL then aG=aL;aT=aT+aT else aG=aG-aL;aH=aH-aL;aT=aT+aT+1 end until not(aT<aU)aT=aT-aU end;aT=aT+aV end;if aI<4 then local aX;aK=432+(aT<4 and aT or 4-1)-f-6;do aX=1;repeat aM=a0[aK+aX]if aG<16777216 then if aE>=aF then return 0 end;aG=aG-f-8;aH=aH-f-8-c-a4[aE]aE=aE+1 end;aL=a.rshift(aG,11)*aM;if aH<aL then aG=aL;aX=aX+aX else aG=aG-aL;aH=aH-aL;aX=aX+aX+1 end until not(aX<64)aX=aX-64 end;assert(aX<=0x7fffffff and aX<64)if aX>=4 then local aY=a.rshift(aX,1)-1;if aX<14 then aK=688+2-c-(aX-b-1)-f-aY-aX-1 else aY=aY-4;repeat if aG<16777216 then if aE>=aF then return 0 end;aG=aG-f-8;aH=aH-f-8-c-a4[aE]aE=aE+1 end;aG=a.rshift(aG,1)if aH-aG-b-0x80000000==0 then aH=aH-aG end;aY=aY-1 until not(aY~=0)aK=802;aY=4 end;do local aZ=1;repeat aM=a0[aK+aZ]if aG<16777216 then if aE>=aF then return 0 end;aG=aG-f-8;aH=aH-f-8-c-a4[aE]aE=aE+1 end;aL=a.rshift(aG,11)*aM;if aH<aL then aG=aL;aZ=aZ+aZ else aG=aG-aL;aH=aH-aL;aZ=aZ+aZ+1 end;aY=aY-1 until not(aY~=0)end end end end;if aG<16777216 then if aE>=aF then return 0 end;aG=aG-f-8;aH=aH-f-8-c-a4[aE]aE=aE+1 end;return aJ end;local function a_(b0,b1)R=1;N=0;O=0;if b0~=0 then G=0;H=0;S=1 end;if b1~=0 then S=1 end end;local function b2(b3)local b4=P+b3;local b5;local b6;a8(F)while N~=274 do if R~=0 then while b4>P and O<5 do a4[6+65536+6+O]=a4[P]O=O+1;P=P+1 end;if O<5 then end;if a4[6+65536+6]~=0 then return 1 end;D=a4[6+65536+6+1]-f-24-c-(a4[6+65536+6+2]-f-16)-c-(a4[6+65536+6+3]-f-8)-c-a4[6+65536+6+4]C=0xffffffff;R=0;O=0 end;b5=0;if E>=F then if N==0 and D==0 then if P~=b4 then return 18 end;return 0 end;if N~=0 then return 16 end;b5=1 end;if S~=0 then local b7=1846+768-f-(W+X)for b8=0,b7-1,1 do a0[b8]=a.rshift(2048,1)end;M=1;L=M;K=L;J=K;I=0;S=0 end;if O==0 then local b9;if b4-P<20 or b5~=0 then b6=aD(P,b4)if b6==0 then O=0;while P~=b4 do a4[6+65536+6+O]=a4[P]O=O+1;P=P+1 end;if P~=b4 then return 17 end;return 17 end;if b5~=0 and b6~=2 then return 16 end;b9=P else b9=b4-20 end;A=P;if ab(F,b9)~=0 then return 1 end;P=A else local ba=O;local bb=0;while ba<20 and bb<b4-P do a4[6+65536+6+ba]=a4[P+bb]ba=ba+1;bb=bb+1 end;O=ba;if ba<20 or b5~=0 then b6=aD(6+65536+6,6+65536+6+ba)if b6==0 then P=P+bb;if P~=b4 then return 17 end;return 17 end;if b5~=0 and b6~=2 then return 16 end end;A=6+65536+6;if ab(0,6+65536+6)~=0 then return 1 end;bb=bb-ba-(A-(6+65536+6))P=P+bb;O=0 end end;if D~=0 then return 1 end;return 15 end;local function bc(bd)local be=Q-P;local bf;assert(bd<=6+65536+6)if be<bd then if 6+65536+6-P<bd then Q=0;while Q<be do a4[Q]=a4[P+Q]Q=Q+1 end;P=0 end;while be<bd do bf=s(a4,Q,bd-be)if bf+1<=1 then break end;Q=Q+bf;be=be+bf end end;return be end;local function bg()while a4[P]>=0x80 do P=P+1 end;P=P+1 end;local function bh(bi)while bi~=0 do P=P+1;if a4[P-1]~=0 then return 57 end;bi=bi-1 end;return 0 end;local function bj(bk)return a.band(a4[bk],0xff)+a.blshift(a.band(a4[bk+1],0xff),8)+a.blshift(a.band(a4[bk+2],0xff),16)+a.blshift(a.band(a4[bk+3],0xff),24)end;local function bl()F=0;T=1;U=1;V=1;E=0;a_(1,1)end;local function bm(bn)if bn>=9*5*5 then return 68 end;W=bn%9;Z=8-W;bn=math.floor(bn/9)Y=math.floor(bn/5)X=bn%5;if W+X>4 then return 68 end;V=0;return 0 end;local function bo(bp)while bp~=E do local bq=z(a6,bp,E-bp)if bq-b-0x80000000~=0 then return 9 end;bp=bp+bq end;return 0 end;local function br()local bs;local bt;local bu;if bc(12+12+6)<12+12+6 then return 6 end;if a4[0]==0xfd and a4[1]==0x37 and a4[2]==0x7a and a4[3]==0x58 and a4[4]==0x5a and a4[5]==0 and a4[6]==0 then elseif a4[P]<=225 and a4[P+13]==0 and((function()bt=bj(P+9)return bt end)()==0 or e-bt==0)and(function()B=bj(P+1)return B end)()>=4096 and B<a.band(1610612736+1,0x7fffffff)then local bv;local bw;local bx;bl()if(function()bu=bm(a4[P])return bu end)()~=0 then return bu end;if bt==0 then bv=bj(P+5)F=bv;if not(bv<a.band(1610612736+1,0x7fffffff))then return 2 end else bv=bt;F=1610612736 end;P=P+13;while(function()bw=bc(6+65536+6)return bw end)()~=0 do bx=E;bu=b2(bw)if bv<E then E=bv end;if(function()bu=bo(bx)return bu end)()~=0 then return bu end;if bu==15 then break end;if bu~=17 and bu~=0 then return bu end;if E-bv==0 then break end end;return 0 else return 51 end;bs=a4[P+7]if bs==0 then bs=1 elseif bs==1 then bs=4 elseif bs==4 then bs=8 elseif bs==10 then bs=32 else return 60 end;P=P+12;while true do local by=3;local bz;local bA;local bB;local bC;assert(Q-P>=12)bC=P;P=P+1;if(function()bz=a4[P-1]return bz end)()==0 then break end;bz=bz+1-f-2;if bc(bz)<bz then return 6 end;bC=P;bt=a4[P]P=P+1;if bt-b-2~=0 then return 53 end;if bt-b-20~=0 then return 54 end;if bt-b-64~=0 then bg()end;if bt-b-128~=0 then bg()end;if a4[P]~=0x21 then return 55 end;P=P+1;if a4[P]~=1 then return 56 end;P=P+1;bB=a4[P]P=P+1;if bB>40 then return 61 end;if bB>37 then return 62 end;B=2-c-(bB-b-1)-f-(math.floor(bB/2)+11)assert(B>=4096)bA=P-bC+5;if bA>bz then return 58 end;if(function()bu=bh(bz-bA)return bu end)()~=0 then return bu end;P=P+4;do local bD;local bE;local bF;bl()while true do local bG;assert(E==F)if bc(6)<6 then return 6 end;bG=a4[P]if bG==0 then P=P+1;break elseif a.band(bG-3,0xff)<0x80-3 then return 59 end;bD=a4[P+1]-f-8+a4[P+2]+1;if bG<3 then bF=bG==1 and 1 or 0;bE=bD;P=P+3;by=by-3;if bF~=0 then U=1;V=U;T=0 elseif T~=0 then return 1 end;a_(bF,0)else local bH=a.rshift(bG,5)-b-3;local bI=bH~=0 and 1 or 0;local bJ=bG-b-64~=0 and 1 or 0;bF=bH==3 and 1 or 0;bD=bD+bG-b-31-f-16;bE=a4[P+3]-f-8+a4[P+4]+1;if bJ~=0 then if(function()bu=bm(a4[P+5])return bu end)()~=0 then return bu end;P=P+1;by=by-1 else if V~=0 then return 67 end end;P=P+5;by=by-5;if bF==0 and T~=0 or bI==0 and U~=0 then return 1 end;a_(bF,bI)T=0;U=0 end;assert(E==F)F=F+bD;if F>1610612736 then return 2 end;if bc(bE+6)<bE then return 6 end;if bG<0x80 then while E~=F do a6[E]=a4[P]-b-0xFF;E=E+1;P=P+1 end;if H==0 and B-G<=bD then H=B end;G=G+bD else if(function()bu=b2(bE)return bu end)()~=0 then return bu end end;if E~=F then return 65 end;if(function()bu=bo(E-bD)return bu end)()~=0 then return bu end;by=by-bE end end;if bc(7+12+6)<7+12+6 then return 6 end;if(function()bu=bh(by-b-3)return bu end)()~=0 then return bu end;P=P+bs end;return 0 end;local bK={UNKNOWN_ERROR=-1,OK=0,ERROR_DATA=1,ERROR_MEM=2,ERROR_CRC=3,ERROR_UNSUPPORTED=4,ERROR_PARAM=5,ERROR_INPUT_EOF=6,ERROR_OUTPUT_EOF=7,ERROR_READ=8,ERROR_WRITE=9,ERROR_FINISHED_WITH_MARK=15,ERROR_NOT_FINISHED=16,ERROR_NEEDS_MORE_INPUT=17,ERROR_CHUNK_NOT_CONSUMED=18,ERROR_NEEDS_MORE_INPUT_PARTIAL=17,ERROR_BAD_MAGIC=51,ERROR_BAD_STREAM_FLAGS=52,ERROR_UNSUPPORTED_FILTER_COUNT=53,ERROR_BAD_BLOCK_FLAGS=54,ERROR_UNSUPPORTED_FILTER_ID=55,ERROR_UNSUPPORTED_FILTER_PROPERTIES_SIZE=56,ERROR_BAD_PADDING=57,ERROR_BLOCK_HEADER_TOO_LONG=58,ERROR_BAD_CHUNK_CONTROL_BYTE=59,ERROR_BAD_CHECKSUM_TYPE=60,ERROR_BAD_DICTIONARY_SIZE=61,ERROR_UNSUPPORTED_DICTIONARY_SIZE=62,ERROR_FEED_CHUNK=63,ERROR_NOT_FINISHED_WITH_MARK=64,ERROR_BAD_DICPOS=65,ERROR_MISSING_INITPROP=67,ERROR_BAD_LCLPPB_PROP=68}return{DecompressXzOrLzmaFile=function(bL,bM)if type(bL)~=\"userdata\"and type(bL)~=\"table\"and type(bL)~=\"string\"then error(\"bad argument #1 (expected string or file, got \"..type(bL)..\")\",2)end;if type(bM)~=\"userdata\"and type(bM)~=\"table\"and type(bM)~=\"string\"then error(\"bad argument #2 (expected string or file, got \"..type(bM)..\")\",2)end;m=nil;n=nil;local bN=io.input()local bO=io.output()if type(bL)==\"string\"then bL=io.open(bL,\"rb\")if bL==nil then return false,-1 end end;if type(bM)==\"string\"then bM=io.open(bM,\"wb\")if bM==nil then return false,-1 end end;io.input(bL)io.output(bM)a7()local bP,bQ=pcall(br)io.input(bN)io.output(bO)bL:close()bM:close()if not bP then if bQ then io.stderr:write(bQ..\"\\n\")end;return false,-1 else return bQ==0,bQ end end,DecompressXzOrLzmaString=function(bL)if type(bL)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(bL)..\")\",2)end;m=bL;n=\"\"a7()local bP,bQ=pcall(br)if not bP then if bQ then io.stderr:write(bQ..\"\\n\")end;return-1 elseif bQ==0 then return n elseif bQ==53 and#n>0 then return n,bQ else return nil,bQ end end,GetError=function(D)for bR,bS in pairs(bK)do if bS==D then return bR end end;return nil end,Errors=bK}\n",setuser=false,size=18923,modified=1757997041458,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["mpi.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997041391,data="local a={}a.__mt={__index=a,__name=\"MultiPrecisionInteger\"}local b=math.floor;a.zero=setmetatable({0},a.__mt)a.one=setmetatable({1},a.__mt)function a:new(c)if type(c)==\"number\"then c=b(c)if c==0 then return self.zero end;local d=setmetatable({sign=c<0},self.__mt)if c<0 then c=-c end;while c>0 do d[#d+1]=c%0x10000;c=b(c/0x10000)end;return d end;if#c%2==1 then c=\"\\0\"..c end;local e=#c/2;local d=setmetatable({},self.__mt)local f={(\">I2\"):rep(#c/2):unpack(c)}table.remove(f)for g,h in ipairs(f)do d[e-g+1]=h end;return d end;function a:add(i)if self.sign and not i.sign then return i:sub(self:unm())elseif not self.sign and i.sign then return self:sub(i:unm())end;local e=math.max(#self,#i)local j=setmetatable({sign=self.sign},self.__mt)local k=0;for g=1,e do local l=(self[g]or 0)+(i[g]or 0)+k;if l>0xFFFF then j[g],k=l-0x10000,1 else j[g],k=l,0 end end;if k~=0 then j[e+1]=1 end;return j end;a.__mt.__add=a.add;function a:sub(i)if i.sign then return self:add(i:unm())end;if self.sign then local e=i:add(self:unm())e.sign=true;return e end;if self:lt(i)then local e=i:sub(self)e.sign=not e.sign;return e end;local e=math.max(#self,#i)local m=setmetatable({},self.__mt)local k=0;for g=1,e do local l=(self[g]or 0)-(i[g]or 0)-k;if l<0 then m[g],k=l+0x10000,1 else m[g],k=l,0 end end;if k~=0 then error(\"Signed number not caught properly\",2)end;return m end;a.__mt.__sub=a.sub;function a:mul(i)local n=setmetatable({sign=not self.sign~=not i.sign},self.__mt)for g=1,#self+#i do n[g]=0 end;for g=1,#self do local k=0;for o=1,#i do local h=self[g]*i[o]+k;k,h=b(h/0x10000),h%0x10000;local l=n[g+o-1]+h;if l>0xFFFF then local p=g+o;while n[p]==0xFFFF do n[p]=0;p=p+1 end;n[p]=n[p]+1;l=l-0x10000 end;n[g+o-1]=l end;n[g+#i]=n[g+#i]+k end;return n end;a.__mt.__mul=a.mul;function a:rdiv(i)local q,e=#self,#i;while self[q]==0 do q=q-1 end;while i[e]==0 do e=e-1 end;if e==1 then local r=setmetatable({sign=not self.sign~=not i.sign},self.__mt)local k=0;i=i[1]for g=q,1,-1 do r[g]=b((k+self[g])/i)k=(k+self[g])%i*0x10000 end;return r,setmetatable({k/0x10000},self.__mt)end;local s={[0]=0}for g=1,q do s[g]=self[q-g+1]end;local t=i[e]*0x10000+i[e-1]for g=0,q-e do local u=s[g]*0x100000000+s[g+1]*0x10000+s[g+2]local v=b(u/t)for o=1,e do s[g+o]=s[g+o]-v*i[e-o+1]end;s[g+1]=s[g]*0x10000+s[g+1]s[g]=v end;local w,x,y=false,{},nil;for g=0,q do x[g]=s[g]end;for g=q,1,-1 do local k=0;if x[g]<0 then k=b((-x[g]-1)/0x10000)+1 elseif x[g]>=0x10000 then k=-b(x[g]/0x10000)end;x[g]=x[g]+k*0x10000;x[g-1]=x[g-1]-k;if k~=0 and g==q-e+1 then y=k;w=true end end;if w then for g=q,q-e+1,-1 do s[g]=s[g]+y*i[e-g+1]end;for g=q-e,0,-1 do s[g]=x[g]end;for g=q,1,-1 do local k=0;if s[g]<0 then k=b((-s[g]-1)/0x10000)+1 elseif s[g]>=0x10000 then k=-b(s[g]/0x10000)end;s[g]=s[g]+k*0x10000;s[g-1]=s[g-1]-k end else for g=0,q do s[g]=x[g]end end;local r,z=setmetatable({sign=not self.sign~=not i.sign},self.__mt),setmetatable({},self.__mt)local A=q-e+1;for g=0,A-1 do r[A-g]=s[g]end;for g=A,q do z[q-g+1]=s[g]end;return r,z end;function a:div(i)local r=self:rdiv(i)return r end;a.__mt.__div=a.div;function a:mod(i)local B,z=self:rdiv(i)return z end;a.__mt.__mod=a.mod;function a:unm()local e=setmetatable({sign=not self.sign},self.__mt)for g=1,#self do e[g]=self[g]end;return e end;a.__mt.__unm=a.unm;function a:eq(i)if not not self.sign~=not not i.sign then return false end;for g=1,math.max(#self,#i)do if(self[g]or 0)~=(i[g]or 0)then return false end end;return true end;a.__mt.__eq=a.eq;function a:lt(i)if self.sign and not i.sign then return true elseif not self.sign and i.sign then return false end;for g=math.max(#self,#i),1,-1 do if(self[g]or 0)<(i[g]or 0)then return not self.sign elseif(self[g]or 0)>(i[g]or 0)then return not not self.sign end end;return false end;a.__mt.__lt=a.lt;function a:le(i)if self.sign and not i.sign then return true elseif not self.sign and i.sign then return false end;for g=math.max(#self,#i),1,-1 do if(self[g]or 0)<(i[g]or 0)then return not self.sign elseif(self[g]or 0)>(i[g]or 0)then return not not self.sign end end;return true end;a.__mt.__le=a.le;function a:trim()local e=setmetatable({sign=self.sign},self.__mt)for g=1,#self do e[g]=self[g]end;for g=#e,1,-1 do if e[g]==0 then e[g]=nil else break end end;return e end;function a:redc(z,e,C)local h=#e;local D={}for g=1,#self do D[g-1]=self[g]end;for g=#self,z+h do D[g]=0 end;for g=0,z-1 do local k=0;local q=D[g]*C%0x10000;for o=0,h-1 do local E=D[g+o]+q*e[o+1]+k;D[g+o],k=E%0x10000,b(E/0x10000)end;for o=h,z+h-g do local E=D[g+o]+k;D[g+o],k=E%0x10000,b(E/0x10000)end end;local l=setmetatable({},self.__mt)for g=0,h do l[g+1]=D[g+z]end;if l>=e then return l-e else return l end end;function a:exteuclid()local i=setmetatable({},self.__mt)for g=1,#self do i[g]=0 end;i[#i+1]=1;local F,G,H,I,J,K=i,self,a.one,a.zero,a.zero,a.one;while G~=a.zero do local r,z=F:rdiv(G)G,I,K,F,H,J=z,H-(r*I):trim(),J-(r*K):trim(),G,I,K end;assert(F==a.one)return H,J[1]end;function a:modexp(L,e)local M=a.one;for h=1,#self*32 do M=M+M;if M>=e then M=M-e end end;local B,C=e:exteuclid()local q=(self*M):redc(#self,e,C)local N=(a.one*M):redc(#self,e,C)for g=1,#L do for o=0,15 do if bit32.btest(L[g],2^o)then N=(N*q):redc(#self,e,C)end;q=(q*q):redc(#self,e,C)end end;return N:redc(#self,e,C)end;function a:tonumber()local d=0;for g=1,#self do d=d+2^(16*(g-1))*self[g]end;return d end;function a:tostring()local O=\"\"for g=#self,1,-1 do O=O..(\">I2\"):pack(self[g])end;return O end;a.__mt.__tostring=a.tostring;return a\n",setuser=false,size=5457,modified=1757997041389,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["pgp.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997041725,data="local a=require\"system.expect\"local b=require\"system.serialization\"local c=require\"ccryptolib.ed25519\"local d=require\"mpi\"local e=require\"sha2\"local f={}local function g(h)local i=0xB704CE;for j in h:gmatch\".\"do i=bit32.bxor(i,j:byte()*0x10000)for _=1,8 do i=i*2;if i>0xFFFFFF then i=bit32.bxor(bit32.band(i,0xFFFFFF),0x864CFB)end end end;return bit32.band(i,0xFFFFFF)end;local k={e.md5,e.sha1,nil,nil,nil,nil,nil,e.sha256,e.sha384,e.sha512,e.sha224,e.sha3_256,nil,e.sha3_512}function f.decodeASC(l)a(1,l,\"string\")local m,n,o,p=l:match(\"%-%-%-%-%-BEGIN ([^%-]+)%-%-%-%-%-(.*)\\n\\n(.+)\\n%-%-%-%-%-END %1%-%-%-%-%-\")if not m then error(\"Invalid ASCII armor data\",2)end;o=o:gsub(\"%s+$\",\"\")if o:match(\"\\n=....$\")then p,o=o:sub(-4),o:sub(1,-7)end;local q=b.base64.decode(o:gsub(\"[^A-Za-z0-9/+=]\",\"\"))if p then local r=(\">I3\"):unpack(b.base64.decode(p))local s=g(q)if r~=s then error(\"Checksum failed\",2)end end;return q,m end;function f.encodeASC(h,m)a(1,h,\"string\")return(\"-----BEGIN %s-----\\n\\n%s\\n=%s\\n-----END %s-----\\n\"):format(m,b.base64.encode(h):gsub((\".\"):rep(76),\"%0\\n\"),b.base64.encode((\">I3\"):pack(g(h))),m)end;function f.readKeys(h)a(1,h,\"string\")local t=1;local u={}while t<=#h do local v=h:byte(t)if v<0x80 then error(\"Invalid packet data\",2)end;local w,x;if v>=0xC0 then w=bit32.band(v,0x3F)if h:byte(t+1)<0xC0 then x,t=h:byte(t+1),t+2 elseif h:byte(t+1)~=0xFF then x,t=(h:byte(t+1)-192)*256+h:byte(t+2)+192,t+3 else x,t=(\">I4\"):unpack(h,t+1)end else local y=bit32.band(v,3)if y==3 then error(\"Unsupported packet length\",2)end;w,x,t=bit32.band(bit32.rshift(v,2),0x0F),(\">I\"..2^y):unpack(h,t+1)end;if w==5 or w==6 or w==7 or w==14 then local z=t;local A=h:byte(t)if A==4 then local B,C;B,C,t=(\">I4B\"):unpack(h,t+1)if C==0x16 then local D;D,t=(\">s1\"):unpack(h,t)if D==\"\\x2B\\x06\\x01\\x04\\x01\\xDA\\x47\\x0F\\x01\"then local E;E,t=(\">I2\"):unpack(h,t)if E~=0x0107 or h:byte(t)~=0x40 then error(\"Invalid key in data stream\",2)end;local F=h:sub(t+1,t+32)t=t+33;local G=e.sha1(\"\\x99\"..(\">I2\"):pack(t-z)..h:sub(z,t-1))u[#u+1]={algorithm=\"ed25519\",public=F,creationTime=B,fingerprint=G,keyID=G:sub(25,40)}else error(\"Unsupported algorithm encountered; cannot determine key length\",2)end elseif C==0x1B then local F=h:sub(t,t+31)t=t+32;local G=e.sha1(\"\\x99\"..(\">I2\"):pack(t-z)..h:sub(z,t-1))u[#u+1]={algorithm=\"ed25519\",public=F,creationTime=B,fingerprint=G,keyID=G:sub(25,40)}elseif C==0x12 then local E;_,E,t=(\">s1I2\"):unpack(h,t)t=t+math.ceil(E/8)_,t=(\">s1\"):unpack(h,t)elseif C==0x19 then t=t+32 elseif C==1 or C==2 or C==3 then if w==6 or w==14 then local H,I,J,K;H,t=(\">I2\"):unpack(h,t)I=d:new(h:sub(t,t+math.ceil(H/8)-1))t=t+math.ceil(H/8)J,t=(\">I2\"):unpack(h,t)K=d:new(h:sub(t,t+math.ceil(J/8)-1))t=t+math.ceil(J/8)local G=e.sha1(\"\\x99\"..(\">I2\"):pack(t-z)..h:sub(z,t-1))u[#u+1]={algorithm=\"rsa\",public={n=I,e=K},creationTime=B,fingerprint=G,keyID=G:sub(25,40)}else end else error(\"Unsupported algorithm encountered; cannot determine key length\",2)end elseif A==6 then local B,C,L;B,C,L,t=(\">I4Bs4\"):unpack(h,t+1)if C==0x16 then local D,M=(\">s1\"):unpack(L)if D==\"\\x2B\\x06\\x01\\x04\\x01\\xDA\\x47\\x0F\\x01\"then local E;E,M=(\">I2\"):unpack(L,M)if E~=0x0107 or L:byte(M)~=0x40 then error(\"Invalid key in data stream\",2)end;local F=L:sub(M+1,M+32)local G=e.sha256(\"\\x9B\"..(\">I2\"):pack(t-z)..h:sub(z,t-1))u[#u+1]={algorithm=\"ed25519\",public=F,creationTime=B,fingerprint=G,keyID=G:sub(1,16)}end elseif C==0x1B then local G=e.sha256(\"\\x9B\"..(\">I2\"):pack(t-z)..h:sub(z,t-1))u[#u+1]={algorithm=\"ed25519\",public=L,creationTime=B,fingerprint=G,keyID=G:sub(1,16)}elseif C==1 or C==2 or C==3 then if w==6 or w==14 then local H,I,J,K;H,t=(\">I2\"):unpack(h,t)I=d:new(h:sub(t,t+math.ceil(H/8)-1))t=t+math.ceil(H/8)J,t=(\">I2\"):unpack(h,t)K=d:new(h:sub(t,t+math.ceil(J/8)-1))t=t+math.ceil(J/8)local G=e.sha256(\"\\x9B\"..(\">I2\"):pack(t-z)..h:sub(z,t-1))u[#u+1]={algorithm=\"rsa\",public={n=I,e=K},creationTime=B,fingerprint=G,keyID=G:sub(1,16)}else end end else t=t+x end else t=t+x end end;return u end;function f.verify(h,N,u)a(1,h,\"string\")a(2,N,\"string\")a(3,u,\"table\")local t=1;local v=N:byte(t)if v<0x80 then error(\"Invalid packet data\",2)end;local w,x;if v>=0xC0 then w=bit32.band(v,0x3F)if N:byte(t+1)<0xC0 then x,t=N:byte(t+1),t+2 elseif N:byte(t+1)~=0xFF then x,t=(N:byte(t+1)-192)*256+N:byte(t+2)+192,t+3 else x,t=(\">I4\"):unpack(N,t+1)end else local y=bit32.band(v,3)if y==3 then error(\"Unsupported packet length\",2)end;w,x,t=bit32.band(bit32.rshift(v,2),0x0F),(\">I\"..2^y):unpack(N,t+1)end;if w~=2 then error(\"Not a valid signature\",2)end;local z=t;local A=N:byte(t)if A==4 or A==6 then local O={(A==4 and\">BBBs2s2I2\"or\">BBBs4s4I2s1\"):unpack(N,t+1)}t=table.remove(O)if O[1]==1 then h=h:gsub(\"([^\\r])\\n\",\"%1\\r\\n\"):gsub(\"^\\n\",\"\\r\\n\")end;local P=(O[7]or\"\")..h..(A==4 and\">BBBBs2\"or\">BBBBs4  \"):pack(A,O[1],O[2],O[3],O[4])..string.char(A)..\"\\xFF\"..(\">I4\"):pack(#O[4]+(A==4 and 6 or 8))local Q=e.hex_to_bin(assert(k[O[3]],\"Unsupported hashing algorithm\")(P))if(\">I2\"):unpack(Q:sub(1,2))~=O[6]then return false end;if O[2]==0x16 then local R,S,T,U;R,S,T,U,t=(\">I2c32I2c32\"):unpack(N,t)for _,V in ipairs(u)do if V.algorithm==\"ed25519\"and c.verify(V.public,Q,S..U)then return true end end;return false elseif O[2]==0x1B then local W=N:sub(t,t+63)for _,V in ipairs(u)do if V.algorithm==\"ed25519\"and c.verify(V.public,Q,W)then return true end end;return false elseif O[2]==1 or O[2]==2 then local X,W;X,t=(\">I2\"):unpack(N,t)W=d:new(N:sub(t,t+math.ceil(X/8)-1))t=t+math.ceil(X/8)for _,V in ipairs(u)do if V.algorithm==\"rsa\"then local Y=W:modexp(V.public.e,V.public.n):trim():tostring()local Z=Y:match\"^%z+\\x01\\xFF+%z(.*)$\"if Z then assert(Z:byte(1)==0x30,\"Invalid signature data\")local a0=Z:byte(2)local a1=3;if a0>=0x80 then local a2=a0-0x80;a0,a1=(\">I\"..a2):unpack(Z,a1)end;assert(Z:byte(a1)==0x30,\"Invalid signature data\")a0=Z:byte(a1+1)a1=a1+2;if a0>=0x80 then local a2=a0-0x80;a0,a1=(\">I\"..a2):unpack(Z,a1)end;a1=a1+a0;assert(Z:byte(a1)==0x04,\"Invalid signature data\")a0=Z:byte(a1+1)a1=a1+2;if a0>=0x80 then local a2=a0-0x80;a0,a1=(\">I\"..a2):unpack(Z,a1)end;local a3=Z:sub(a1,a1+a0-1)if a3==Q then return true end end end end;return false else error(\"Unsupported signature algorithm\",2)end else error(\"Unsupported signature version\")end end;function f.verifyMessage(a4,u)a(1,a4,\"string\")a(2,u,\"table\")local n,h,N=a4:match(\"%-%-%-%-%-BEGIN PGP SIGNED MESSAGE%-%-%-%-%-(.*)\\n\\n(.-)\\n(%-%-%-%-%-BEGIN PGP SIGNATURE%-%-%-%-%-\\n.-\\n%-%-%-%-%-END PGP SIGNATURE%-%-%-%-%-)\")if not n then error(\"Invalid message format\",2)end;return f.verify(h:gsub(\"\\n%- \",\"\\n-\"):gsub(\"^%- \",\"-\"),f.decodeASC(N),u),h end;return f\n",setuser=false,size=6580,modified=1757997041721,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},apt={permissions={root={write=true,read=true,execute=true}},created=1757997039618,contents={["get.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997039614,data="local a=require\"system.filesystem\"local b=require\"apt.config\"local c=require\"apt.cache\"local d=require\"apt.repo\"local e=require\"dpkg.query\"local f=require\"dpkg.trigger\"local g=require\"dpkg\"local h=require\"sha2\"local i=require\"LibDeflate\"local j={}local k=1;local l=0;local m=os.time()function j.update()local n={}local o=d.readSources()for p,q in ipairs(o)do if n[q.suite]==nil then local r=a.combine(q.url:gsub(\"^.-://\",\"\"),\"dists\",q.suite):gsub(\"[/:]\",\"_\")local s=a.combine(b:getPath(\"State\",\"lists\"),r)local t=require(\"apt.methods.\"..q.url:match(\"^[^:]+\"))local u,v=t(q.url..\"dists/\"..q.suite..\"/InRelease\")if u then local w=true;local x=io.open(s..\"_InRelease\",\"r\")if x then local y=x:read(\"*a\")x:close()w=y~=u end;if w then x=assert(io.open(s..\"_InRelease\",\"w\"))x:write(u)x:close()n[q.suite]=true;print(\"Get:\"..k..\" \"..q.url..\" \"..q.suite..\" InRelease [\"..math.floor(#u/1024)..\" kB]\")k=k+1;l=l+#u else n[q.suite]=false;print(\"Hit:\"..k..\" \"..q.url..\" \"..q.suite..\" InRelease\")k=k+1 end else print(\"Err:\"..k..\" \"..q.url..\" \"..q.suite..\" InRelease (\"..v..\")\")k=k+1;local z,v=t(q.url..\"dists/\"..q.suite..\"/Release\")if z then local w=true;local x=io.open(s..\"_Release\",\"r\")if x then local y=x:read(\"*a\")x:close()w=y~=z end;if w then x=assert(io.open(s..\"_Release\",\"w\"))x:write(z)x:close()print(\"Get:\"..k..\" \"..q.url..\" \"..q.suite..\" Release [\"..math.floor(#z/1024)..\" kB]\")k=k+1;l=l+#z;local A,v=t(q.url..\"dists/\"..q.suite..\"/Release.gpg\",{encoding=\"binary\"})if A then x=assert(io.open(s..\"_Release.gpg\",\"wb\"))x:write(A)x:close()n[q.suite]=true;print(\"Get:\"..k..\" \"..q.url..\" \"..q.suite..\" Release.gpg [\"..math.floor(#A/1024)..\" kB]\")k=k+1;l=l+#A else n[q.suite]=false;print(\"Err:\"..k..\" \"..q.url..\" \"..q.suite..\" Release.gpg (\"..v..\")\")k=k+1 end else n[q.suite]=false;print(\"Hit:\"..k..\" \"..q.url..\" \"..q.suite..\" Release\")k=k+1 end else n[q.suite]=false;print(\"Err:\"..k..\" \"..q.url..\" \"..q.suite..\" Release (\"..v..\")\")k=k+1 end end end end;for p,q in ipairs(o)do if n[q.suite]then local t=require(\"apt.methods.\"..q.url:match(\"^[^:]+\"))for p,B in ipairs(q.options.arch or b.apt.architectures)do for C,D in pairs(b.acquire.indextargets[q.type])do local E={[\"$(RELEASE)\"]=q.suite,[\"$(COMPONENT)\"]=q.component,[\"$(LANGUAGE)\"]=\"en\",[\"$(ARCHITECTURE)\"]=B,[\"$(NATIVE_ARCHITECTURE)\"]=b.apt.architecture}local F=D.metakey:gsub(\"%$%b()\",E)local r=a.combine(q.url:gsub(\"^.-://\",\"\"),\"dists\",q.suite,F):gsub(\"[/:]\",\"_\")local s=a.combine(b:getPath(\"State\",\"lists\"),r)local G,v=t(q.url..\"dists/\"..q.suite..\"/\"..F)if G then local x=assert(io.open(s,\"wb\"))x:write(G)x:close()print(\"Get:\"..k..\" \"..q.url..\" \"..D.description:gsub(\"%$%b()\",E)..\" [\"..math.floor(#G/1024)..\" kB]\")k=k+1;l=l+#G else G,v=t(q.url..\"dists/\"..q.suite..\"/\"..F..\".gz\")if G then local x=assert(io.open(s,\"wb\"))x:write(i:DecompressGzip(G))x:close()print(\"Get:\"..k..\" \"..q.url..\" \"..D.description:gsub(\"%$%b()\",E)..\" [\"..math.floor(#G/1024)..\" kB]\")k=k+1;l=l+#G else print(\"Err:\"..k..\" \"..q.url..\" \"..D.description:gsub(\"%$%b()\",E)..\" (\"..v..\")\")k=k+1 end end end end end end end;function j.download(H)if not c.db then c:load()end;local I=c:get(H)if not I then return nil end;local q=assert(c:getRepo(I.repoIndex),\"Invalid info in cache\")local r=I.name..\"_\"..I.version..\"_\"..q.architecture..\".deb\"local s=a.combine(b:getPath(\"Cache\",\"archives\"),r)if a.exists(s)then local x=assert(io.open(s,\"rb\"))local y=x:read(\"*a\")x:close()if h.sha256(y)==h.bin_to_hex(I.sha256)then return s end end;local t=require(\"apt.methods.\"..q.url:match(\"^[^:]+\"))local G,v=t(q.url..I.filename)if G and h.sha256(G)~=h.bin_to_hex(I.sha256)then G,v=nil,\"Failed to verify package integrity\"end;if G then local x=assert(io.open(s,\"wb\"))x:write(G)x:close()print(\"Get:\"..k..\" \"..q.url..\" \"..q.suite..\"/\"..q.component..\" \"..q.architecture..\" \"..I.name..\" \"..q.architecture..\" \"..I.version..\" [\"..math.floor(#G/1024)..\" kB]\")k=k+1;l=l+#G;return s else print(\"Err:\"..k..\" \"..q.url..\" \"..q.suite..\"/\"..q.component..\" \"..q.architecture..\" \"..I.name..\" \"..q.architecture..\" \"..I.version..\" (\"..v..\")\")k=k+1;return nil end end;function j.showStats()if l==0 then return end;local J=os.difftime(os.time(),m)print(\"Fetched \"..math.ceil(l/1024)..\" kB in \"..J..\"s (\"..math.ceil(l/J/1024)..\" kB/s)\")end;function j.plan(K,L,M)io.write(\"Building dependency tree... \")local N;for p,s in ipairs(b:get(\"Dir\",\"Bin\",\"solvers\")or{})do for p,O in ipairs(a.list(s))do if O:match\"%.lua$\"then local P=dofile(a.combine(s,O))N=P(K,c,L,M)if N then break end end end;if N then break end end;io.write(\"Done.\\n\")if not N then return nil,\"Could not find a valid install strategy\"end;local Q;for p,s in ipairs(b:get(\"Dir\",\"Bin\",\"planners\")or{})do for p,O in ipairs(a.list(s))do if O:match\"%.lua$\"then local R=dofile(a.combine(s,O))Q=R(K,c,N,M)if Q then break end end end;if Q then break end end;if not Q then return nil,\"Failed to create plan for installation\"end;local S={}for C,D in pairs(N)do if D then S[#S+1]=C end end;return Q,N,S end;function j.planUpgrade(K,T,M)io.write(\"Calculating upgrade... \")local U={}for C,D in pairs(K)do local I=c:get(C)if I and g.compareVersions(I.version,D.Version)>0 then U[C]=true end end;if T then print(\"Done.\")return U,{},j.plan(K,U,M)end;local V={}while true do local N;for p,s in ipairs(b:get(\"Dir\",\"Bin\",\"solvers\")or{})do for p,O in ipairs(a.list(s))do if O:match\"%.lua$\"then local P=dofile(a.combine(s,O))N=P(K,c,U,M)if N then break end end end;if N then break end end;if not N then print(\"Done.\")return nil end;local W;for C,D in pairs(N)do if K[C]~=nil~=D then W=C;break end end;if not W then print(\"Done.\")return U,V,j.plan(K,U,M)end;local X=U;local Y=0;for p in pairs(U)do Y=Y+1 end;while Y>1 do local Z,_={},{}local a0=math.floor(Y/2)local a1=0;for C,D in pairs(X)do if a1>=a0 then _[C]=D else Z[C]=D end;a1=a1+1 end;local a2,a3;for p,s in ipairs(b:get(\"Dir\",\"Bin\",\"solvers\")or{})do for p,O in ipairs(a.list(s))do if O:match\"%.lua$\"then local P=dofile(a.combine(s,O))if not a2 then a2=P(K,c,Z,M)end;if not a3 then a3=P(K,c,_,M)end;if a2 and a3 then break end end end;if a2 and a3 then break end end;if not a2 or not a3 then error(\"Something went wrong while calculating the upgrade.\")end;if a2[W]~=nil then X,Y=Z,a0 elseif a3[W]~=nil then X,Y=_,math.ceil(Y/2)else error(\"Something went wrong while calculating the upgrade.\")end end;local C=next(X)U[C]=nil;V[C]=true end end;local function a4(H,a5,K)local a6={string.match(H.Status,\"(%S+) (%S+) (%S+)\")}a6[a5]=K;H.Status=table.concat(a6,\" \")return H.Status end;function j.execute(Q,a7,a8)local a9={}for p,aa in ipairs(Q)do local ab,O=aa:match\"^([^:]+):(.*)$\"if ab==\"install\"then if not a9[O]then a9[O]=g.package(a7[O])end;g.package.packagedb[O]=g.package.packagedb[O]or{Status=\"unknown ok not-installed\"}a4(g.package.packagedb[O],1,\"install\")a9[O].unpack()elseif ab==\"configure\"then if not a9[O]then a9[O]=g.package(O)end;a9[O].configure()elseif ab==\"deconfigure\"then elseif ab==\"remove\"then if not a9[O]then a9[O]=g.package(O)end;a9[O].remove()if a8 then a9[O].purge()a4(g.package.packagedb[O],1,\"purge\")else a4(g.package.packagedb[O],1,\"deinstall\")end else error(\"Unknown operation \"..ab..\" in plan\",2)end end;for C,D in pairs(g.package.packagedb)do if D[\"Triggers-Pending\"]then g.print(\"Processing triggers for \"..C..\" (\"..D.Version..\") ...\")f.commit(C,g.package.triggerdb,g.package.packagedb)end end;e.writeDatabase(g.package.packagedb)end;return j\n",setuser=false,size=7340,modified=1757997039602,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},planners={permissions={root={write=true,read=true,execute=true}},created=1757997039618,contents={["80-default.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997039618,data="return function(a,b,c)local d,e,f={},{},{}local g=0;for h,i in pairs(c)do local j=assert(b:get(h),\"Could not find package '\"..h..\"' in cache\")if i then local k,l={},{}l[\"install:\"..h]=true;for m,n in ipairs(j.preDepends)do if c[n.package]==true then k[\"configure:\"..n.package]=true end end;for m,n in ipairs(j.depends)do if c[n.package]==true then l[\"configure:\"..n.package]=true end end;for m,n in ipairs(j.conflicts)do if c[n.package]==false then k[\"remove:\"..n.package]=true end end;for m,n in ipairs(j.breaks)do if c[n.package]==false then l[\"deconfigure:\"..n.package]=true end end;e[\"install:\"..h]=k;e[\"configure:\"..h]=l;if not next(k)then d[#d+1]=\"install:\"..h end else local o,p={},{}p[\"deconfigure:\"..h]=true;for m,n in ipairs(j.preDepended)do if c[n.package]==false then o[\"remove:\"..n.package]=true end end;for m,n in ipairs(j.depended)do if c[n.package]==false then o[\"deconfigure:\"..n.package]=true end end;e[\"deconfigure:\"..h]=o;e[\"remove:\"..h]=p;if not next(o)then d[#d+1]=\"deconfigure:\"..h end end;g=g+2 end;while#d>0 do table.sort(d,function(q,r)local s,t=q:match\"([^:]+):(.+)\"local u,v=r:match\"([^:]+):(.+)\"if s==\"install\"and u==\"configure\"then return true elseif s==\"configure\"and u==\"install\"then return false elseif s==\"remove\"and u==\"deconfigure\"then return false elseif s==\"deconfigure\"and u==\"remove\"then return true else return t<v end end)local w=table.remove(d,1)f[#f+1]=w;for h,i in pairs(e)do if i[w]then i[w]=nil;if not next(i)then d[#d+1]=h end end end end;if#f<g then return nil,\"Cycle in dependency graph\"end;return f end\n",setuser=false,size=1554,modified=1757997039605,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997039618,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},["config.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997039614,data="local a=require\"system.filesystem\"local b=require\"system.process\"local c={apt={architecture=\"phoenix\",architectures={\"phoenix\"},compressor={[\".\"]={name=\".\",extension=\"\",library=\"\",method=\"\",cost=\"0\"},gzip={name=\"gzip\",extension=\".gz\",library=\"LibDeflate\",compressmethod=\"CompressGzip\",decompressmethod=\"DecompressGzip\",cost=\"100\",passself=\"1\"},xz={name=\"xz\",extension=\".xz\",library=\"muxzcat\",decompressmethod=\"DecompressXzOrLzmaString\",cost=\"200\",passself=\"0\"},lzma={name=\"lzma\",extension=\".lzma\",library=\"muxzcat\",decompressmethod=\"DecompressXzOrLzmaString\",cost=\"200\",passself=\"0\"}},[\"install-recommends\"]=\"1\",[\"install-suggests\"]=\"0\",sandbox={user=\"_apt\"}},dir={_=\"/\",state={_=\"var/lib/apt\",lists=\"lists/\",extended_states=\"extended_states\",status=\"/var/lib/dpkg/status\"},cache={_=\"var/cache/apt\",archives=\"archives/\",pkgcache=\"pkgcache.bin\"},etc={_=\"etc/apt\",sourcelist=\"sources.list\",sourceparts=\"sources.list.d\",main=\"apt.conf\",netrc=\"auth.conf\",netrcparts=\"auth.conf.d\",parts=\"apt.conf.d\",preferences=\"preferences\",preferencesparts=\"preferences.d\",trusted=\"trusted.gpg\",trustedparts=\"trusted.gpg.d\"},bin={methods=\"/usr/lib/apt/methods\",solvers={\"/usr/lib/apt/solvers\"},planners={\"/usr/lib/apt/planners\"},dpkg=\"/usr/bin/dpkg.lua\",gzip=\"/usr/bin/gzip.lua\",xz=\"/usr/bin/xz.lua\",lzma=\"/usr/bin/xz.lua\"},log={_=\"var/log/apt\",terminal=\"term.log\",history=\"history.log\",planner=\"eipp.log.xz\"},[\"ignore-files-silently\"]={\"~$\",\"%.disabled$\",\"%.bak$\",\"%.dpkg%-[a-z]+$\",\"%.ucf%-[a-z]+$\",\"%.save$\",\"%.orig$\",\"%.distUpgrade$\"}},acquire={allowinsecurerepositories=\"0\",allowweakrepositories=\"0\",allowdowngradetoinsecurerepositories=\"0\",indextargets={deb={packages={metakey=\"$(COMPONENT)/binary-$(ARCHITECTURE)/Packages\",flatmetakey=\"Packages\",shortdescription=\"Packages\",description=\"$(RELEASE)/$(COMPONENT) $(ARCHITECTURE)/Packages\",flatdescription=\"$(RELEASE) Packages\",optional=\"0\"}}},compressiontypes={xz=\"xz\",lzma=\"lzma\",gz=\"gzip\"}},dpkg={path=\"/usr/sbin:/usr/bin:/sbin:/bin\"},binary={apt={apt={color=\"1\",cache={show={version=\"2\"},allversions=\"0\",showvirtuals=\"1\",search={version=\"2\"},showdependencytype=\"1\",showversion=1},get={[\"upgrade-allow-new\"]=\"1\",update={interactivereleaseinfochanges=\"1\"}},cmd={[\"show-update-stats\"]=\"1\",[\"pattern-only\"]=\"1\"},[\"keep-downloaded-packages\"]=\"0\"},dpkg={[\"progress-fancy\"]=\"1\",lock={timeout=\"-1\"}}}}}local function d(...)local e,f=math.huge,nil;for g=1,select(\"#\",...)do local h=select(g,...)if h and h<e then f,e=g,h end end;return f end;local function i(j,k)local l=1;local m={}local n={}local o=true;local p=true;while true do local q=k:find(\"//\",l)local r=k:find(\"/%*\",l)local s=k:find(\"[A-Za-z0-9/%-%._+]\",l)local t=k:find(\"{\",l)local u=k:find(\"}\",l)local v=k:find(\"::\",l)local w=k:find('\"',l)local x=k:find(\"#\",l)local e=d(q,r,s,t,u,v,w,x)if e==nil then return elseif e==1 then local y=k:match(\"//.-\\n()\",l)if not y then return end;l=y elseif e==2 then local y=k:match(\"/%*.-%*/()\",l)if not y then return end;l=y elseif e==3 then if not o then error(\"Syntax error near \"..k:match(\"[A-Za-z0-9/%-%._+]+\",l))end;n[#n+1],l=k:match(\"([A-Za-z0-9/%-%._+]+)()\",l)o=false elseif e==4 then if#n==0 then error(\"Syntax error near {\")end;if o then error(\"Syntax error near \"..n[1]..\":: {\")end;for g=1,#n do m[#m+1]=n[g]end;n={}o=true;p=true;l=k:match(\"{()\",l)elseif e==5 then if#n>0 then error(\"Syntax error near \"..table.concat(n,\"::\")..\" }\")end;m[#m]=nil;p=false;l=k:match(\"}()\",l)elseif e==6 then if o then error(\"Syntax error near :: ::\")end;o=true;l=k:match(\"::()\",l)elseif e==7 then local z,A=k:match('\"([^\"]-)\"()',l)if not z then error(\"Syntax error: unfinished string\")end;if#n==0 and#m==0 then error(\"Syntax error near \\\"\"..z..\"\\\"\")end;local B=j;if#n==0 then for g=1,#m-1 do local C=m[g]:lower()if not B[C]then B[C]={}end;B=B[C]end;local C=m[#m]:lower()if p or not B[C]then B[C]={}end;B=B[C]B[#B+1]=z else for D,C in ipairs(m)do C=C:lower()if not B[C]then B[C]={}end;B=B[C]end;for g=1,#n-1 do local C=n[g]:lower()if not B[C]then B[C]={}end;B=B[C]end;if o then local C=n[#n]:lower()if not B[C]then B[C]={}end;B=B[C]B[#B+1]=z else B[n[#n]:lower()]=z end end;l=k:match(\"^%s*;()\",A)p=false;if not l then error(\"Syntax error: missing semicolon near \\\"\"..z..\"\\\"\")end elseif e==8 then local z,A=k:match(\"#(%a+);()\")if not z then error(\"Syntax error: malformed command\")end;if z==\"clear\"then else error(\"Syntax error: unknown command \"..z)end;l=A end end end;local function E(F,G)for C,h in pairs(G)do if type(h)==\"table\"then if not F[C]then F[C]={}end;E(F[C],h)else F[C]=h end end end;function c:load()self=self or c;local H=b.getenv().APT_CONFIG;if H then local I=io.open(H,\"r\")if I then local J=I:read(\"*a\")I:close()i(self,J)end end;local K=self:getPath(\"Etc\",\"Parts\")if a.isDir(K)then for D,y in ipairs(a.list(K))do local I=io.open(a.combine(K,y),\"r\")if I then local J=I:read(\"*a\")I:close()i(self,J)end end end;local I=io.open(self:getPath(\"Etc\",\"main\"),\"r\")if I then local J=I:read(\"*a\")I:close()i(self,J)end;local L=b.getname():match(\"[^/]+$\")if L then L=L:gsub(\"%.lua$\",\"\")self.binary._=L;if self.binary[L]then E(self,self.binary[L])end end end;function c:append(z)i(self,z)end;local function M(N,O,...)if type(N)==\"string\"then return N end;if not O then return N._ or\"\"end;return a.combine(N._ or\"\",M(N[O:lower()]or{},...))end;function c:getPath(...)return M(self.dir,...)end;function c:get(...)local C=...if not C then return self end;if not self[C:lower()]then return nil end;return c.get(self[C:lower()],select(2,...))end;return c\n",setuser=false,size=5468,modified=1757997039601,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["repo.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997039618,data="local a=require\"system.filesystem\"local b=require\"dpkg.control\"local c=require\"pgp\"local d=require\"apt.config\"local e={}function e.parseSources(f)local g={}for h in f:gmatch\"[^\\r\\n]+\"do h=h:gsub(\"#.*$\",\"\")if h:match\"^deb \"then local type,i,j,k,l=h:match\"^(deb)%s+(%b[])%s+(%S+)%s+(%S+)%s*(.*)$\"if not type then type,j,k,l=h:match\"^(deb)%s+(%S+)%s+(%S+)%s*(.*)$\"end;if not type then error(\"Malformed line in sources.list:\\n\"..h,2)end;local m={}if i then for n in i:gsub(\"^%[\",\"\"):gsub(\"%]$\",\"\"):gmatch\"%S+\"do local o,p=n:match(\"^([^=]+)=(.+)$\")if not o then error(\"Malformed option in sources.list: \"..n,2)end;m[o]=p end end;for q in l:gmatch\"%S+\"do local r={type=type,url=j,suite=k,component=q,options={}}g[#g+1]=r;if m.arch then r.options.arch={}for s in m.arch:gmatch\"[^,]+\"do r.options.arch[#r.options.arch+1]=s end end;if m.lang then r.options.lang={}for s in m.lang:gmatch\"[^,]+\"do r.options.lang[#r.options.lang+1]=s end end;if m.targets then r.options.targets={}for s in m.targets:gmatch\"[^,]+\"do r.options.targets[#r.options.targets+1]=s end end;if m.pdiffs then r.options.pdiffs=m.pdiffs==\"yes\"end;if m[\"by-hash\"]then if m[\"by-hash\"]==\"force\"then r.options.byHash=\"force\"else r.options.byHash=m[\"by-hash\"]==\"yes\"end end;if m[\"allow-insecure\"]then r.options.allowInsecure=m[\"allow-insecure\"]==\"yes\"end;if m[\"allow-weak\"]then r.options.allowWeak=m[\"allow-weak\"]==\"yes\"end;if m[\"allow-downgrade-to-insecure\"]then r.options.allowDowngradeToInsecure=m[\"allow-downgrade-to-insecure\"]==\"yes\"end;if m.trusted then r.options.trusted=m.trusted==\"yes\"end;if m[\"signed-by\"]then if m[\"signed-by\"]:match(\"%-%-%-%-%-BEGIN PGP PUBLIC KEY BLOCK%-%-%-%-%-\")then r.options.signedBy=c.readKeys(c.decodeASC(m[\"signed-by\"]))else r.options.signedBy={}for s in m[\"signed-by\"]:gmatch\"[^,]+\"do r.options.signedBy[#r.options.signedBy+1]=s end end end;if m[\"check-valid-until\"]then r.options.checkValidUntil=m[\"check-valid-until\"]==\"yes\"end;if m[\"valid-until-min\"]then r.options.validUntilMin=tonumber(m[\"valid-until-min\"])end;if m[\"valid-until-max\"]then r.options.validUntilMax=tonumber(m[\"valid-until-max\"])end;if m[\"check-date\"]then r.options.checkDate=m[\"check-date\"]==\"yes\"end;if m[\"date-max-future\"]then r.options.dateMaxFuture=tonumber(m[\"date-max-future\"])end;r.options.inreleasePath=m[\"inrelease-path\"]r.options.snapshot=m.snapshot end end end;return g end;function e.parseDeb822(f)local t=b.parseControlList(f)local g={}for u,m in ipairs(t)do for type in m.Types:gmatch\"%S+\"do for q in m.Components:gmatch\"%S+\"do local r={type=type,url=m.URIs,suite=m.Suites,component=q,options={}}g[#g+1]=r;if m.Architectures then r.options.arch={}for s in m.Architectures:gmatch\"%S+\"do r.options.arch[#r.options.arch+1]=s end end;if m.Languages then r.options.lang={}for s in m.Languages:gmatch\"%S+\"do r.options.lang[#r.options.lang+1]=s end end;if m.Targets then r.options.targets={}for s in m.Targets:gmatch\"%S+\"do r.options.targets[#r.options.targets+1]=s end end;if m.PDiffs then r.options.pdiffs=m.PDiffs==\"yes\"end;if m[\"By-Hash\"]then if m[\"By-Hash\"]==\"force\"then r.options.byHash=\"force\"else r.options.byHash=m[\"By-Hash\"]==\"yes\"end end;if m[\"Allow-Insecure\"]then r.options.allowInsecure=m[\"Allow-Insecure\"]==\"yes\"end;if m[\"Allow-Weak\"]then r.options.allowWeak=m[\"Allow-Weak\"]==\"yes\"end;if m[\"Allow-Downgrade-To-Insecure\"]then r.options.allowDowngradeToInsecure=m[\"Allow-Downgrade-To-Insecure\"]==\"yes\"end;if m.Trusted then r.options.trusted=m.Trusted==\"yes\"end;if m[\"Signed-By\"]then if m[\"Signed-By\"]:match(\"%-%-%-%-%-BEGIN PGP PUBLIC KEY BLOCK%-%-%-%-%-\")then r.options.signedBy=c.readKeys(c.decodeASC(m[\"Signed-By\"]))else r.options.signedBy={}for s in m[\"Signed-By\"]:gmatch\"%S+\"do r.options.signedBy[#r.options.signedBy+1]=s end end end;if m[\"Check-Valid-Until\"]then r.options.checkValidUntil=m[\"Check-Valid-Until\"]==\"yes\"end;if m[\"Valid-Until-Min\"]then r.options.validUntilMin=tonumber(m[\"Valid-Until-Min\"])end;if m[\"Valid-Until-Max\"]then r.options.validUntilMax=tonumber(m[\"Valid-Until-Max\"])end;if m[\"Check-Date\"]then r.options.checkDate=m[\"Check-Date\"]==\"yes\"end;if m[\"Date-Max-Future\"]then r.options.dateMaxFuture=tonumber(m[\"Date-Max-Future\"])end;r.options.inreleasePath=m[\"InRelease-Path\"]r.options.snapshot=m.Snapshot end end end;return g end;function e.readSources()local g={}local v=d:getPath(\"Etc\",\"sourcelist\")local w=io.open(v,\"r\")if w then local x=w:read(\"*a\")w:close()local t=e.parseSources(x)for u,p in ipairs(t)do g[#g+1]=p end end;local y=d:getPath(\"Etc\",\"sourceparts\")if a.isDir(y)then for u,z in ipairs(a.list(y))do w=io.open(a.combine(y,z),\"r\")if w then local x=w:read(\"*a\")w:close()local t=z:match\"%.sources$\"and e.parseDeb822(x)or e.parseSources(x)for u,p in ipairs(t)do g[#g+1]=p end end end end;return g end;function e.readTrustedKeys()local g={}local v=d:getPath(\"Etc\",\"trusted\")if a.exists(v)then local w=assert(io.open(v,\"rb\"))local x=w:read(\"*a\")w:close()g=c.readKeys(x)end;local y=d:getPath(\"Etc\",\"trustedparts\")if a.isDir(y)then for u,A in ipairs(a.list(y))do local w=assert(io.open(a.combine(y,A),\"rb\"))local x=w:read(\"*a\")w:close()local B=c.readKeys(x)for u,p in ipairs(B)do g[#g+1]=p end end end;return g end;function e.readRelease(r)local C=a.combine(r.url:gsub(\"^.-://\",\"\"),\"dists\",r.suite):gsub(\"[/:]\",\"_\")local v=a.combine(d:getPath(\"State\",\"lists\"),C)local B;if r.options.signedBy then if type(r.options.signedBy[1])==\"table\"then B=r.options.signedBy else B=e.readTrustedKeys()local D=1;while D<#B do local E=false;for u,p in ipairs(r.options.signedBy)do if B[D].fingerprint:lower()==p:lower()or B[D].keyID:lower()==p:lower()then E=true;break end end;if E then D=D+1 else table.remove(B,D)end end end else B=e.readTrustedKeys()end;local F;if r.options.inreleasePath then local w,G=io.open(v..\"_\"..a.combine(r.options.inreleasePath):gsub(\"[/:]\",\"_\"),\"r\")if not w then return nil,G end;local x=w:read(\"*a\")w:close()local H;H,F=c.verifyMessage(x,B)if not H then return nil,\"No valid keys found for InRelease\"end elseif a.exists(v..\"_InRelease\")then local w,G=io.open(v..\"_InRelease\",\"r\")if not w then return nil,G end;local x=w:read(\"*a\")w:close()local H;H,F=c.verifyMessage(x,B)if not H then return nil,\"No valid keys found for InRelease\"end elseif a.exists(v..\"_Release\")then local w,G=io.open(v..\"_Release\",\"r\")if not w then return nil,G end;F=w:read(\"*a\")w:close()w,G=io.open(v..\"_Release.gpg\",\"rb\")if w then local I=w:read(\"*a\")w:close()if I:match(\"^%-%-%-%-%-\")then I=c.decodeASC(I)end;if not c.verify(F,I,B)then return nil,\"No valid keys found for Release\"end elseif not r.options.allowInsecure then return nil,\"Could not find signed Release file\"end else return nil,\"No cached release file available\"end;local J=b.parseControl(F)local g={architectures={},origin=J.Origin,label=J.Label,suite=J.Suite,codename=J.Codename,version=J.Version,date=J.Date,validUntil=J[\"Valid-Until\"],components={},notAutomatic=J.NotAutomatic==\"yes\",butAutomaticUpgrades=J.ButAutomaticUpgrades==\"yes\",acquireByHash=(J[\"Acquire-By-Hash\"]==\"yes\"or r.options.byHash==\"force\")and r.options.byHash~=false,signedBy=J[\"Signed-By\"],packagesRequireAuthorization=J[\"Packages-Require-Authorization\"]==\"yes\",changelogs=J.Changelogs,snapshots=J.Snapshots}for s in J.Architectures:gmatch\"%S+\"do g.architectures[#g.architectures+1]=s end;for s in J.Components:gmatch\"%S+\"do g.components[#g.components+1]=s end;if J.MD5Sum then g.md5={}for h in J.MD5Sum:gmatch\"[^\\n]+\"do local K,L,M=h:match\"(%x+)%s+(%d+)%s+(.+)\"if K then g.md5[M]=K end end end;if J.SHA1 then g.sha1={}for h in J.SHA1:gmatch\"[^\\n]+\"do local K,L,M=h:match\"(%x+)%s+(%d+)%s+(.+)\"if K then g.sha1[M]=K end end end;if J.SHA256 then g.sha256={}for h in J.SHA256:gmatch\"[^\\n]+\"do local K,L,M=h:match\"(%x+)%s+(%d+)%s+(.+)\"if K then g.sha256[M]=K end end end;return g end;return e\n",setuser=false,size=7726,modified=1757997039606,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},solvers={permissions={root={write=true,read=true,execute=true}},created=1757997039619,contents={["80-default.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997039619,data="local a=require\"dpkg\"local function b(c)local d=1;while d<=#c do local e,f=1,false;while e<=#c[d]do if c[d][e]==true then table.remove(c,d)f=true;break elseif c[d][e]==false then table.remove(c[d],e)else e=e+1 end end;if not f then d=d+1 end end;return c end;local function g(c,h,i)for d,j in ipairs(c)do for e,k in ipairs(j)do if k==h then j[e]=i elseif k==\"!\"..h then j[e]=not i end end end;return b(c)end;local function l(c)local m={}for d,j in ipairs(c)do local n={}for e,k in ipairs(j)do n[e]=k end;m[d]=n end;return m end;local function o(c,p)local m,q={},{}repeat local r=false;for d,j in ipairs(c)do if#j==1 then local s,t=j[1]:match\"^(!?)(.*)$\"if t:sub(1,1)==\"*\"then local u,v,w=t:match\"%*(%S+) %(([<=>]+) ([^)]+)%)\"if q[u]then if v==\"<<\"then if q[u].lower and a.compareVersions(w,q[u].lower)<=0 then return nil end;if not q[u].upper or a.compareVersions(w,q[u].upper)<=0 then q[u].upper,q[u].upperTight=w,true end elseif v==\"<=\"then if q[u].lower and a.compareVersions(w,q[u].lower)<0 then return nil end;if not q[u].upper or a.compareVersions(w,q[u].upper)<0 then q[u].upper,q[u].upperTight=w,false end elseif v==\"=\"then if q[u].lower and a.compareVersions(w,q[u].lower)~=0 then return nil end;if q[u].upper and a.compareVersions(w,q[u].upper)~=0 then return nil end;q[u]={lower=w,lowerTight=false,upper=w,upperTight=false}elseif v==\">=\"then if q[u].upper and a.compareVersions(w,q[u].upper)>0 then return nil end;if not q[u].lower or a.compareVersions(w,q[u].lower)>0 then q[u].lower,q[u].lowerTight=w,false end elseif v==\">>\"then if q[u].upper and a.compareVersions(w,q[u].upper)>=0 then return nil end;if not q[u].lower or a.compareVersions(w,q[u].lower)>=0 then q[u].lower,q[u].lowerTight=w,true end else error(\"Invalid version relation \"..v)end else if v==\"<<\"then q[u]={upper=w,upperTight=true}elseif v==\"<=\"then q[u]={upper=w,upperTight=false}elseif v==\"=\"then q[u]={lower=w,lowerTight=false,upper=w,upperTight=false}elseif v==\">=\"then q[u]={lower=w,lowerTight=false}elseif v==\">>\"then q[u]={lower=w,lowerTight=true}else error(\"Invalid version relation \"..v)end end;table.remove(c,d)else m[t]=s==\"\"table.remove(c,d)g(c,t,s==\"\")end;r=true;break end end until not r;repeat local r=false;local x={}for y,j in ipairs(c)do for y,k in ipairs(j)do local z,A=k:match\"^(!?)%*?(%S*)\"x[A]=x[A]or{}if z==\"!\"then x[A][2]=true else x[A][1]=true end end end;for B,j in pairs(x)do if j[1]and not j[2]then g(c,B,true)r=true elseif not j[1]and j[2]then g(c,B,false)r=true end end until not r;if#c==0 then return m,q end;for y,j in ipairs(c)do if#j==0 then return nil end end;local C=c[1][1]:gsub(\"^!\",\"\")local D=p[C]~=nil;local E,F=o(g(l(c),C,D),p)if not E then D=not D;E,F=o(g(l(c),C,D),p)if not E then return nil end end;for B,j in pairs(E)do m[B]=j end;m[C]=D;for B,j in pairs(F)do if q[B]then if q[B].upper and j.upper then local G=a.compareVersions(j.upper,q[B].upper)if G<0 then q[B].upper,q[B].upperTight=j.upper,j.upperTight elseif G==0 then q[B].upperTight=q[B].upperTight or j.upperTight end else q[B].upper,q[B].upperTight=q[B].upper or j.upper,q[B].upperTight or j.upperTight end;if q[B].lower and j.lower then local G=a.compareVersions(j.lower,q[B].lower)if G>0 then q[B].lower,q[B].lowerTight=j.lower,j.lowerTight elseif G==0 then q[B].lowerTight=q[B].lowerTight or j.lowerTight end else q[B].lower,q[B].lowerTight=q[B].lower or j.lower,q[B].lowerTight or j.lowerTight end else q[B]=j end;if q[B].lower and q[B].upper and a.compareVersions(q[B].lower,q[B].upper)>((q[B].lowerTight or q[B].upperTight)and-1 or 0)then return nil end end;return m,q end;local function H(I,c,J)if c[J]then return end;c[J]=true;for y,j in ipairs(J.preDepends)do local z=I:get(j.package)if z then if j.alternate then c[#c][#c[#c]+1]=j.package else c[#c+1]={\"!\"..J.name,j.package}end;if j.version then c[#c+1]={\"!\"..j.package,\"*\"..j.package..\" (\"..j.relation..\" \"..j.version..\")\"}end;H(I,c,z)else if j.alternate then c[#c][#c[#c]+1]=false else c[#c+1]={\"!\"..J.name,false}end end end;for y,j in ipairs(J.depends)do local z=I:get(j.package)if z then if j.alternate then c[#c][#c[#c]+1]=j.package else c[#c+1]={\"!\"..J.name,j.package}end;if j.version then c[#c+1]={\"!\"..j.package,\"*\"..j.package..\" (\"..j.relation..\" \"..j.version..\")\"}end;H(I,c,z)else if j.alternate then c[#c][#c[#c]+1]=false else c[#c+1]={\"!\"..J.name,false}end end end;for y,j in ipairs(J.conflicts)do local z=I:get(j.package)if z then if j.alternate then c[#c][#c[#c]+1]=\"!\"..j.package else c[#c+1]={\"!\"..J.name,\"!\"..j.package}end;if j.version then c[#c+1]={\"!\"..j.package,\"!*\"..j.package..\" (\"..j.relation..\" \"..j.version..\")\"}end;H(I,c,z)else if j.alternate then c[#c][#c[#c]+1]=true else c[#c+1]={\"!\"..J.name,true}end end end;for y,j in ipairs(J.breaks)do local z=I:get(j.package)if z then if j.alternate then c[#c][#c[#c]+1]=\"!\"..j.package else c[#c+1]={\"!\"..J.name,\"!\"..j.package}end;if j.version then c[#c+1]={\"!\"..j.package,\"!*\"..j.package..\" (\"..j.relation..\" \"..j.version..\")\"}end;H(I,c,z)else if j.alternate then c[#c][#c[#c]+1]=true else c[#c+1]={\"!\"..J.name,true}end end end;for y,j in ipairs(J.preDepended)do H(I,c,assert(I:get(j.package),\"Could not find package '\"..j.package..\"' in cache\"))end;for y,j in ipairs(J.depended)do H(I,c,assert(I:get(j.package),\"Could not find package '\"..j.package..\"' in cache\"))end;for y,j in ipairs(J.conflicted)do H(I,c,assert(I:get(j.package),\"Could not find package '\"..j.package..\"' in cache\"))end;for y,j in ipairs(J.broken)do H(I,c,assert(I:get(j.package),\"Could not find package '\"..j.package..\"' in cache\"))end end;return function(p,I,K,L)local c={}for B,j in pairs(K)do c[#c+1]={(j and\"\"or\"!\")..B}H(I,c,assert(I:get(B),\"Could not find package '\"..B..\"' in cache\"))end;local M,q=o(c,p)if not M then return nil end;for B,j in pairs(q)do local J=assert(I:get(B),\"Could not find package '\"..B..\"' in cache\")if j.lower and a.compareVersions(j.lower,J.version)>(j.lowerTight and-1 or 0)or j.upper and a.compareVersions(j.upper,J.version)<(j.upperTight and 1 or 0)then return nil end end;local m={}for B,j in pairs(M)do if p[B]~=nil~=j or j and not p[B].Status:match\" installed$\"or K[B]and j and(L.reinstall or a.compareVersions(I:get(B).version,p[B].Version)~=0)or q[B]and(q[B].lower and a.compareVersions(q[B].lower,p[B].Version)>(q[B].lowerTight and-1 or 0)or q[B].upper and a.compareVersions(q[B].upper,p[B].Version)<(q[B].upperTight and 1 or 0))then m[B]=j end end;return m,q end\n",setuser=false,size=6389,modified=1757997039606,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997039619,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},methods={permissions={root={write=true,read=true,execute=true}},created=1757997039620,contents={["ftp.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997039616,data="local a=require\"system.network\"local b=require\"ftp\"return function(c)local d=a.parseURI(c)local e=b.client(d.host,d.port or 21)local f,g=e:open(d.path,\"rb\")if not f then e:close()return nil,g end;local h=f.readAll()f.close()e:close()return h end\n",setuser=false,size=246,modified=1757997039604,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["http.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997039617,data="local a=require\"system.network\"return function(b)local c,d=a.getData(b)if c and d==200 then return c elseif c then return nil,\"HTTP status \"..d else return nil,d end end\n",setuser=false,size=170,modified=1757997039604,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["https.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997039617,data="local a=require\"system.network\"return function(b)local c,d=a.getData(b)if c and d==200 then return c elseif c then return nil,\"HTTP status \"..d else return nil,d end end\n",setuser=false,size=170,modified=1757997039604,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["file.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997039615,data="return function(a)local b,c=io.open(a:gsub(\"^file://\",\"\"):gsub(\"^[^/]\",\"/%0\"),\"rb\")if not b then return nil,c end;local d=b:read(\"*a\")b:close()return d end\n",setuser=false,size=156,modified=1757997039603,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997039620,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},["cache.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997039613,data="local a=require\"system.expect\"local b=require\"system.filesystem\"local c=require\"dpkg.control\"local d=require\"dpkg\"local e=require\"apt.config\"local f=require\"apt.repo\"local g=require\"muxzcat\"local h=require\"LibDeflate\"local i=require\"sha2\"local j=1;local k={[0]=\"<<\",\"<=\",\"=\",\">=\",\">>\",[\"<<\"]=0,[\"<=\"]=1,[\"=\"]=2,[\">=\"]=3,[\">>\"]=4}local l={\"preDepends\",\"preDepended\",\"depends\",\"depended\",\"conflicts\",\"conflicted\",\"breaks\",\"broken\"}local m={}local n={}n.__mt={__name=\"Trie\",__index=n}function n:new(o)a(1,o,\"string\",\"nil\")return setmetatable({character=o,children={}},self.__mt)end;function n:isEmpty()return#self.children==0 end;function n:insert(p,q)a(1,p,\"string\")local r=p:byte(1)if not self.children[r or-1]then self.children[r or-1]=n:new(r and string.char(r)or\"\")end;if r then return self.children[r]:insert(p:sub(2),q)else self.children[-1].value=q end end;function n:remove(p)a(1,p,\"string\")local r=p:byte(1)or-1;if self.children[r]then self.children[r]:remove(p:sub(2))if next(self.children[r].children)==nil then self.children[r]=nil end end end;function n:find(p)a(1,p,\"string\")local r=p:byte(1)or-1;if self.character==\"\"and r==-1 then return true,self.value end;if not self.children[r]then return false end;return self.children[r]:find(p:sub(2))end;function n:complete(p)p=a(1,p,\"string\",\"nil\")or\"\"local r=p:byte(1)if r then if self.children[r]then return self.children[r]:complete(p:sub(2))else return{}end end;if self.character==\"\"then return{\"\"}end;local s={}for t,q in pairs(self.children)do local u=q:complete()for t,v in ipairs(u)do s[#s+1]=q.character..v end end;return s end;local function w(x,y,o)local z=x:byte(y)+1;y=y+1;local A=n:new(o)for t=1,z do local B=x:byte(y)if B>=0xC0 then A.children[-1]=n:new(\"\")A.children[-1].value={(\">\"..(\"I\"):rep(bit32.band(B,0x3F)+1)):unpack(x,y+1)}y=table.remove(A.children[-1].value)elseif B>=0x80 then local C;C,y=(\">I\"):unpack(x,y)A.children[-1]=n:new(\"\")A.children[-1].value=bit32.band(C,0x7FFFFFFF)else A.children[B],y=w(x,y+1,string.char(B))end end;return A,y end;local function D(A)local E=1;for F,q in pairs(A.children)do if F==-1 then if type(q.value)==\"table\"then E=E+#q.value*4+1 else E=E+4 end else E=E+D(q)+1 end end;return E end;local function G(A)local s,H=\"\",0;for F,q in pairs(A.children)do H=H+1;if F==-1 then if type(q.value)==\"table\"then s=s..(\">B\"..(\"I\"):rep(#q.value)):pack(#q.value+0xBF,table.unpack(q.value))else s=s..(\">I\"):pack(q.value+0x80000000)end else s=s..string.char(F)..G(q)end end;return string.char(H-1)..s end;local function I(J,y)local K;K,y=(\">H\"):unpack(J.fileData,y)local s={}for L=1,K do local M=J.fileData:byte(y)local N={}s[L]=N;if bit32.btest(M,0x80)then local C;C,y=(\">I\"):unpack(J.fileData,y)N.package=J.packagesByOffset[bit32.band(C,0x1FFFFFFF)].name else local O,P=bit32.band(M,0x1F)if O==0x1F then P,y=(\"z\"):unpack(J.fileData,y+1)else P=J.fileData:sub(y+1,y+O+1)y=y+O+2 end;N.package=P end;if bit32.btest(M,0x40)then local Q=J.fileData:byte(y)N.relation=k[bit32.extract(Q,5,3)]local O=bit32.band(Q,0x1F)if O==0x1F then N.version,y=(\"z\"):unpack(J.fileData,y+1)else N.version=J.fileData:sub(y+1,y+O+1)y=y+O+2 end end;N.alternate=bit32.btest(M,0x20)end;return s,y end;local function R(J,C)local P,S,T,U,V,W,X,Y,y=(\"zzzBBc16c20c32\"):unpack(J.fileData,C+1)local s={name=P,version=S,filename=T,repoIndex=U,essential=bit32.btest(V,1),installed=bit32.btest(V,2),md5=W,sha1=X,sha256=Y,preDepends={},preDepended={},depends={},depended={},conflicts={},conflicted={},breaks={},broken={},provides={}}if not rawget(J.packagesByOffset,C)then J.packagesByOffset[C]=s end;if rawget(J.packagesByName,P)then local Z=d.compareVersions(J.packagesByName[P].version,S)if Z==-1 then J.packagesByName[P..\"=\"..J.packagesByName[P].version]=J.packagesByName[P]J.packagesByName[P]=s elseif Z==1 then J.packagesByName[P..\"=\"..J.packagesByName[P].version]=s end else J.packagesByName[P]=s end;for t,F in ipairs(l)do s[F],y=I(J,y)end;return s,y end;function m:load(_)local a0=b.open(e:getPath(\"Cache\",\"pkgcache\"),\"rb\")if not a0 then if _ then self.db={repos={}}else self.db={fileData=\"\",nameTrie=n:new(),packagesByName={},packagesByOffset={}}end;return false end;local x=a0.readAll()a0.close()if x:sub(1,4)~=\"APTL\"then error(\"Package cache is corrupt\",2)end;if(\">H\"):unpack(x,5)~=j then return false end;local a1,a2=(\">HI\"):unpack(x,7)if _ then local a3=x:byte(a2+1)local y=a2+2;self.db={repos={}}local J;J={fileData=x,packagesByName={},packagesByOffset=setmetatable({},{__index=function(a4,a5)local a6=R(J,a5)a4[a5]=a6;return a6 end})}for L=1,a3 do local a7,a8,a9,aa,ab;a7,a8,a9,aa,ab,y=(\">zzzzI\"):unpack(x,y)local U={url=a7,suite=a8,component=a9,architecture=aa,packages={}}self.db.repos[L]=U;local ac=y+ab-1;while y<ac do local a6;local C=y-1;a6,y=R(J,C)U.packages[a6.name]=J.packagesByOffset[C]end end;self.db.packagesByName=J.packagesByName else self.db={fileData=x,nameTrie=w(x,a1+1,nil),packagesByName=setmetatable({},{__index=function(a4,a5)return self:get(a5)end}),packagesByOffset=setmetatable({},{__index=function(a4,a5)return R(self.db,a5)end})}end;return true end;function m:get(P)if not self.db then return nil end;if self.db.repos then for t,q in ipairs(self.db.repos)do if q.packages[P]then return q.packages[P]end end;return nil end;local a6=rawget(self.db.packagesByName,P)if a6 then return a6 end;local ad,ae=self.db.nameTrie:find(P)if not ad then return nil end;if type(ae)==\"table\"then return nil end;return self.db.packagesByOffset[ae]end;function m:getVirtual(P)if not self.db then error(\"Database not loaded\",2)end;if self.db.repos then return{}end;local ad,ae=self.db.nameTrie:find(P)if not ad then return{}end;if type(ae)~=\"table\"then return{P}end;local s={}for L,q in ipairs(ae)do s[L]=self.db.packagesByOffset[q].name end;return s end;function m:getRepo(af)if not self.db then return nil end;if self.db.repos then return self.db.repos[af]end;local y=(\">I4\"):unpack(self.db.fileData,9)+2;local ag=self.db.fileData:byte(y-1)if af<1 or af>ag then return nil end;while af>=1 do local a7,a8,a9,aa,ah;a7,a8,a9,aa,ah,y=(\">zzzzI4\"):unpack(self.db.fileData,y)if af==1 then return{url=a7,suite=a8,component=a9,architecture=aa,packages={}}end;y=y+ah;af=af-1 end end;local function ai(aj)if aj==nil then return{}end;local ak=c.parseDependencies(aj)local s={}for t,q in ipairs(ak)do if q.multiple then for L,al in ipairs(q.names)do s[#s+1]={package=al.name,alternate=L~=1,relation=al.rel,version=al.version}end else s[#s+1]={package=q.name,alternate=false,relation=q.rel,version=q.version}end end;return s end;function m:update(a7,a8,a9,aa,am)if not self.db or not self.db.repos then error(\"Database not fully loaded\",2)end;local a5=#self.db.repos+1;for L,U in ipairs(self.db.repos)do if U.url==a7 and U.suite==a8 and U.component==a9 and U.architecture==aa then a5=L;break end end;local U={url=a7,suite=a8,component=a9,architecture=aa,packages={}}local an=self.db.repos[a5]self.db.repos[a5]=U;local ao=c.parseControlList(am)for t,q in ipairs(ao)do local a6={name=q.Package,version=q.Version,filename=q.Filename,repoIndex=a5,essential=q.Essential==\"yes\",installed=an and an[q.Package]and an[q.Package].installed,md5=q.MD5sum and q.MD5sum:gsub(\"%x%x\",function(ap)return string.char(tonumber(ap,16))end),sha1=q.SHA1 and q.SHA1:gsub(\"%x%x\",function(ap)return string.char(tonumber(ap,16))end),sha256=q.SHA256 and q.SHA256:gsub(\"%x%x\",function(ap)return string.char(tonumber(ap,16))end),preDepends=ai(q[\"Pre-Depends\"]),preDepended={},depends=ai(q.Depends),depended={},conflicts=ai(q.Conflicts),conflicted={},breaks=ai(q.Breaks),broken={},provides=ai(q.Provides)}if U.packages[q.Package]then local Z=d.compareVersions(U.packages[q.Package].version,q.Version)if Z==-1 then U.packages[q.Package..\"=\"..U.packages[q.Package].version]=U.packages[q.Package]U.packages[q.Package]=a6 elseif Z==1 then U.packages[q.Package..\"=\"..U.packages[q.Package].version]=a6 end else U.packages[q.Package]=a6 end end end;local function aq(N,ar,as)local s,at=(\">H\"):pack(#N),{}for t,q in ipairs(N)do if ar[q.package]and not as[q.package]then at[#at+1]={#s,q.package}s=s..(\">I4\"):pack(0x80000000+(q.relation and 0x40000000 or 0)+(q.alternate and 0x20000000 or 0))else s=s..string.char(math.min(#q.package-1,0x1F)+(q.relation and 0x40 or 0)+(q.alternate and 0x20 or 0))..q.package;if#q.package>0x1F then s=s..\"\\0\"end end;if q.relation then s=s..string.char(math.min(#q.version-1,0x1F)+k[q.relation]*0x20)..q.version;if#q.version>0x1F then s=s..\"\\0\"end end end;return s,at end;function m:save()if not self.db or not self.db.repos then error(\"Database not fully loaded\",2)end;local ar,as={},{}for t,U in ipairs(self.db.repos)do for F,q in pairs(U.packages)do if ar[F]then local Z=d.compareVersions(ar[F].version,q.version)if Z==-1 then ar[F..\"=\"..ar[F].version]=ar[F]ar[F]=q elseif Z==1 then ar[F..\"=\"..ar[F].version]=q end else ar[F]=q end;for t,al in ipairs(q.provides)do as[al.package]=as[al.package]or{}as[al.package][#as[al.package]+1]=q end end end;for t,U in ipairs(self.db.repos)do for F,q in pairs(U.packages)do for L,au in ipairs(q.preDepends)do if ar[au.package]then ar[au.package].preDepended[#ar[au.package].preDepended+1]={package=q.name,alternate=au.alternate or q.depends[L+1]and q.depends[L+1].alternate,relation=q.relation,version=q.version}end end;for L,au in ipairs(q.depends)do if ar[au.package]then ar[au.package].depended[#ar[au.package].depended+1]={package=q.name,alternate=au.alternate or q.depends[L+1]and q.depends[L+1].alternate,relation=q.relation,version=q.version}end end;for L,au in ipairs(q.conflicts)do if ar[au.package]then ar[au.package].conflicted[#ar[au.package].conflicted+1]={package=q.name,alternate=au.alternate or q.depends[L+1]and q.depends[L+1].alternate,relation=q.relation,version=q.version}end end;for L,au in ipairs(q.breaks)do if ar[au.package]then ar[au.package].broken[#ar[au.package].broken+1]={package=q.name,alternate=au.alternate or q.depends[L+1]and q.depends[L+1].alternate,relation=q.relation,version=q.version}end end end end;if next(ar)==nil then return end;local av=n:new()for F,q in pairs(ar)do av:insert(F,0)end;for F,q in pairs(as)do if not ar[F]then local aw={}for L=1,math.min(#q,64)do aw[L]=0 end;av:insert(F,aw)end end;local ax=D(av)local ay=12;local az,aA,at=string.char(#self.db.repos),{},{}for L,U in ipairs(self.db.repos)do az=az..(\">zzzz\"):pack(U.url,U.suite,U.component,U.architecture)local aB=\"\"for F,q in pairs(U.packages)do aA[q]=ay+ax+#az+4+#aB;aB=aB..(\">zzzBBc16c20c32\"):pack(q.name,q.version,q.filename,L,(q.essential and 1 or 0)+(q.installed and 2 or 0)+(q.md5 and 4 or 0)+(q.sha1 and 8 or 0)+(q.sha256 and 16 or 0),q.md5 or(\"\\0\"):rep(16),q.sha1 or(\"\\0\"):rep(20),q.sha256 or(\"\\0\"):rep(32))for t,aC in ipairs(l)do local p,aD=aq(q[aC],ar,as)for t,au in ipairs(aD)do at[#at+1]={au[1]+#az+4+#aB,au[2]}end;aB=aB..p end end;az=az..(\">s4\"):pack(aB)end;for t,q in ipairs(at)do az=az:sub(1,q[1])..(\">I4\"):pack((\">I4\"):unpack(az,q[1]+1)+aA[ar[q[2]]])..az:sub(q[1]+5)end;for F,q in pairs(ar)do av:insert(F,aA[q])end;for F,q in pairs(as)do if not ar[F]then local aw={}for L,al in ipairs(q)do if L>64 then break end;aw[L]=aA[al]end;av:insert(F,aw)end end;local a0=assert(b.open(e:getPath(\"Cache\",\"pkgcache\"),\"wb\"))a0.write((\">c4HHI\"):pack(\"APTL\",j,ay,ay+ax))a0.write(G(av))a0.write(az)a0.close()end;function m:generate()io.write(\"Reading package lists... \")local aE=f.readSources()self.db={repos={}}for t,q in ipairs(aE)do local aF,aG=f.readRelease(q)if aF then for t,aa in ipairs(e:get(\"APT\",\"Architectures\"))do local aH=e:get(\"Acquire\",\"IndexTargets\",q.type,\"Packages\",\"MetaKey\"):gsub(\"%$%(COMPONENT%)\",q.component):gsub(\"%$%(ARCHITECTURE%)\",aa)local T=b.combine(q.url:gsub(\"^.-://\",\"\"),\"dists\",q.suite,aH):gsub(\"[/:]\",\"_\")local aI=b.combine(e:getPath(\"State\",\"lists\"),T)local x;local a0=io.open(aI,\"r\")if a0 then x=a0:read(\"*a\")a0:close()if aF.md5 and i.md5(x):lower()~=aF.md5[q.component..\"/binary-\"..aa..\"/Packages\"]or aF.sha1 and i.sha1(x):lower()~=aF.sha1[q.component..\"/binary-\"..aa..\"/Packages\"]or aF.sha256 and i.sha256(x):lower()~=aF.sha256[q.component..\"/binary-\"..aa..\"/Packages\"]then error(\"Validation failed on \"..aI)end else a0=io.open(aI..\".xz\",\"rb\")if a0 then local aJ=a0:read(\"*a\")a0:close()if aF.md5 and i.md5(aJ)~=aF.md5[q.component..\"/binary-\"..aa..\"/Packages.xz\"]or aF.sha1 and i.sha1(aJ)~=aF.sha1[q.component..\"/binary-\"..aa..\"/Packages.xz\"]or aF.sha256 and i.sha256(aJ)~=aF.sha256[q.component..\"/binary-\"..aa..\"/Packages.xz\"]then error(\"Validation failed on \"..aI..\".xz\")end;x=g.DecompressXzOrLzmaString(aJ)else a0=io.open(aI..\".gz\",\"rb\")if a0 then local aK=a0:read(\"*a\")a0:close()if aF.md5 and i.md5(aK)~=aF.md5[q.component..\"/binary-\"..aa..\"/Packages.gz\"]or aF.sha1 and i.sha1(aK)~=aF.sha1[q.component..\"/binary-\"..aa..\"/Packages.gz\"]or aF.sha256 and i.sha256(aK)~=aF.sha256[q.component..\"/binary-\"..aa..\"/Packages.gz\"]then error(\"Validation failed on \"..aI..\".gz\")end;x=h:DecompressGzip(aK)end end end;if x then self:update(q.url,q.suite,q.component,aa,x)end end elseif aG~=\"No cached release file available\"then error(q.url..\" \"..q.suite..\" \"..q.component..\": \"..aG,2)end end;self:save()io.write(\"Done.\\n\")end;return m\n",setuser=false,size=13072,modified=1757997039601,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["init.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997039615,data="\n",setuser=false,size=1,modified=1757997039602,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997039618,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},["aes.lua"]={permissions={root={write=true,read=true,execute=false}},created=1757997039496,data="local a={[0]=99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,71,240,173,212,162,175,156,164,114,192,183,253,147,38,54,63,247,204,52,165,229,241,113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,110,90,160,82,59,214,179,41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,50,58,10,73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105,217,142,148,155,30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22}local b={[0]=82,9,106,213,48,54,165,56,191,64,163,158,129,243,215,251,124,227,57,130,155,47,255,135,52,142,67,68,196,222,233,203,84,123,148,50,166,194,35,61,238,76,149,11,66,250,195,78,8,46,161,102,40,217,36,178,118,91,162,73,109,139,209,37,114,248,246,100,134,104,152,22,212,164,92,204,93,101,182,146,108,112,72,80,253,237,185,218,94,21,70,87,167,141,157,132,144,216,171,0,140,188,211,10,247,228,88,5,184,179,69,6,208,44,30,143,202,63,15,2,193,175,189,3,1,19,138,107,58,145,17,65,79,103,220,234,151,242,207,206,240,180,230,115,150,172,116,34,231,173,53,133,226,249,55,232,28,117,223,110,71,241,26,113,29,41,197,137,111,183,98,14,170,24,190,27,252,86,62,75,198,210,121,32,154,219,192,254,120,205,90,244,31,221,168,51,136,7,199,49,177,18,16,89,39,128,236,95,96,81,127,169,25,181,74,13,45,229,122,159,147,201,156,239,160,224,59,77,174,42,245,176,200,235,187,60,131,83,153,97,23,43,4,126,186,119,214,38,225,105,20,99,85,33,12,125}local c={[0]=0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,54,56,58,60,62,64,66,68,70,72,74,76,78,80,82,84,86,88,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,138,140,142,144,146,148,150,152,154,156,158,160,162,164,166,168,170,172,174,176,178,180,182,184,186,188,190,192,194,196,198,200,202,204,206,208,210,212,214,216,218,220,222,224,226,228,230,232,234,236,238,240,242,244,246,248,250,252,254,27,25,31,29,19,17,23,21,11,9,15,13,3,1,7,5,59,57,63,61,51,49,55,53,43,41,47,45,35,33,39,37,91,89,95,93,83,81,87,85,75,73,79,77,67,65,71,69,123,121,127,125,115,113,119,117,107,105,111,109,99,97,103,101,155,153,159,157,147,145,151,149,139,137,143,141,131,129,135,133,187,185,191,189,179,177,183,181,171,169,175,173,163,161,167,165,219,217,223,221,211,209,215,213,203,201,207,205,195,193,199,197,251,249,255,253,243,241,247,245,235,233,239,237,227,225,231,229}local d={[0]=0,3,6,5,12,15,10,9,24,27,30,29,20,23,18,17,48,51,54,53,60,63,58,57,40,43,46,45,36,39,34,33,96,99,102,101,108,111,106,105,120,123,126,125,116,119,114,113,80,83,86,85,92,95,90,89,72,75,78,77,68,71,66,65,192,195,198,197,204,207,202,201,216,219,222,221,212,215,210,209,240,243,246,245,252,255,250,249,232,235,238,237,228,231,226,225,160,163,166,165,172,175,170,169,184,187,190,189,180,183,178,177,144,147,150,149,156,159,154,153,136,139,142,141,132,135,130,129,155,152,157,158,151,148,145,146,131,128,133,134,143,140,137,138,171,168,173,174,167,164,161,162,179,176,181,182,191,188,185,186,251,248,253,254,247,244,241,242,227,224,229,230,239,236,233,234,203,200,205,206,199,196,193,194,211,208,213,214,223,220,217,218,91,88,93,94,87,84,81,82,67,64,69,70,79,76,73,74,107,104,109,110,103,100,97,98,115,112,117,118,127,124,121,122,59,56,61,62,55,52,49,50,35,32,37,38,47,44,41,42,11,8,13,14,7,4,1,2,19,16,21,22,31,28,25,26}local e={[0]=0,9,18,27,36,45,54,63,72,65,90,83,108,101,126,119,144,153,130,139,180,189,166,175,216,209,202,195,252,245,238,231,59,50,41,32,31,22,13,4,115,122,97,104,87,94,69,76,171,162,185,176,143,134,157,148,227,234,241,248,199,206,213,220,118,127,100,109,82,91,64,73,62,55,44,37,26,19,8,1,230,239,244,253,194,203,208,217,174,167,188,181,138,131,152,145,77,68,95,86,105,96,123,114,5,12,23,30,33,40,51,58,221,212,207,198,249,240,235,226,149,156,135,142,177,184,163,170,236,229,254,247,200,193,218,211,164,173,182,191,128,137,146,155,124,117,110,103,88,81,74,67,52,61,38,47,16,25,2,11,215,222,197,204,243,250,225,232,159,150,141,132,187,178,169,160,71,78,85,92,99,106,113,120,15,6,29,20,43,34,57,48,154,147,136,129,190,183,172,165,210,219,192,201,246,255,228,237,10,3,24,17,46,39,60,53,66,75,80,89,102,111,116,125,161,168,179,186,133,140,151,158,233,224,251,242,205,196,223,214,49,56,35,42,21,28,7,14,121,112,107,98,93,84,79,70}local f={[0]=0,11,22,29,44,39,58,49,88,83,78,69,116,127,98,105,176,187,166,173,156,151,138,129,232,227,254,245,196,207,210,217,123,112,109,102,87,92,65,74,35,40,53,62,15,4,25,18,203,192,221,214,231,236,241,250,147,152,133,142,191,180,169,162,246,253,224,235,218,209,204,199,174,165,184,179,130,137,148,159,70,77,80,91,106,97,124,119,30,21,8,3,50,57,36,47,141,134,155,144,161,170,183,188,213,222,195,200,249,242,239,228,61,54,43,32,17,26,7,12,101,110,115,120,73,66,95,84,247,252,225,234,219,208,205,198,175,164,185,178,131,136,149,158,71,76,81,90,107,96,125,118,31,20,9,2,51,56,37,46,140,135,154,145,160,171,182,189,212,223,194,201,248,243,238,229,60,55,42,33,16,27,6,13,100,111,114,121,72,67,94,85,1,10,23,28,45,38,59,48,89,82,79,68,117,126,99,104,177,186,167,172,157,150,139,128,233,226,255,244,197,206,211,216,122,113,108,103,86,93,64,75,34,41,52,63,14,5,24,19,202,193,220,215,230,237,240,251,146,153,132,143,190,181,168,163}local g={[0]=0,13,26,23,52,57,46,35,104,101,114,127,92,81,70,75,208,221,202,199,228,233,254,243,184,181,162,175,140,129,150,155,187,182,161,172,143,130,149,152,211,222,201,196,231,234,253,240,107,102,113,124,95,82,69,72,3,14,25,20,55,58,45,32,109,96,119,122,89,84,67,78,5,8,31,18,49,60,43,38,189,176,167,170,137,132,147,158,213,216,207,194,225,236,251,246,214,219,204,193,226,239,248,245,190,179,164,169,138,135,144,157,6,11,28,17,50,63,40,37,110,99,116,121,90,87,64,77,218,215,192,205,238,227,244,249,178,191,168,165,134,139,156,145,10,7,16,29,62,51,36,41,98,111,120,117,86,91,76,65,97,108,123,118,85,88,79,66,9,4,19,30,61,48,39,42,177,188,171,166,133,136,159,146,217,212,195,206,237,224,247,250,183,186,173,160,131,142,153,148,223,210,197,200,235,230,241,252,103,106,125,112,83,94,73,68,15,2,21,24,59,54,33,44,12,1,22,27,56,53,34,47,100,105,126,115,80,93,74,71,220,209,198,203,232,229,242,255,180,185,174,163,128,141,154,151}local h={[0]=0,14,28,18,56,54,36,42,112,126,108,98,72,70,84,90,224,238,252,242,216,214,196,202,144,158,140,130,168,166,180,186,219,213,199,201,227,237,255,241,171,165,183,185,147,157,143,129,59,53,39,41,3,13,31,17,75,69,87,89,115,125,111,97,173,163,177,191,149,155,137,135,221,211,193,207,229,235,249,247,77,67,81,95,117,123,105,103,61,51,33,47,5,11,25,23,118,120,106,100,78,64,82,92,6,8,26,20,62,48,34,44,150,152,138,132,174,160,178,188,230,232,250,244,222,208,194,204,65,79,93,83,121,119,101,107,49,63,45,35,9,7,21,27,161,175,189,179,153,151,133,139,209,223,205,195,233,231,245,251,154,148,134,136,162,172,190,176,234,228,246,248,210,220,206,192,122,116,102,104,66,76,94,80,10,4,22,24,50,60,46,32,236,226,240,254,212,218,200,198,156,146,128,142,164,170,184,182,12,2,16,30,52,58,40,38,124,114,96,110,68,74,88,86,55,57,43,37,15,1,19,29,71,73,91,85,127,113,99,109,215,217,203,197,239,225,243,253,167,169,187,181,159,145,131,141}local i={{0x01,0x00,0x00,0x00},{0x02,0x00,0x00,0x00},{0x04,0x00,0x00,0x00},{0x08,0x00,0x00,0x00},{0x10,0x00,0x00,0x00},{0x20,0x00,0x00,0x00},{0x40,0x00,0x00,0x00},{0x80,0x00,0x00,0x00},{0x1b,0x00,0x00,0x00},{0x36,0x00,0x00,0x00}}local function j(k,l)if l==nil then l=\"%s\"end;local m={}for n in string.gmatch(k,\"([^\"..l..\"]+)\")do table.insert(m,n)end;return m end;local o={[16]=4,[24]=6,[32]=8}local p=4;local q={[16]=10,[24]=12,[32]=14}local function r(s)local t={[\"0\"]=0,[\"1\"]=1,[\"2\"]=2,[\"3\"]=3,[\"4\"]=4,[\"5\"]=5,[\"6\"]=6,[\"7\"]=7,[\"8\"]=8,[\"9\"]=9,[\"a\"]=10,[\"b\"]=11,[\"c\"]=12,[\"d\"]=13,[\"e\"]=14,[\"f\"]=15}local u=0;for v=1,#s do u=u+t[s:sub(v,v)]*16^(#s-v)end;return u end;local function w(s)local t={[0]=\"0\",[1]=\"1\",[2]=\"2\",[3]=\"3\",[4]=\"4\",[5]=\"5\",[6]=\"6\",[7]=\"7\",[8]=\"8\",[9]=\"9\",[10]=\"a\",[11]=\"b\",[12]=\"c\",[13]=\"d\",[14]=\"e\",[15]=\"f\"}local u=\"\"while s>0 do u=t[s%16]..u;s=math.floor(s/16)end;return u end;local function x(n)local u={}for v=1,#n do table.insert(u,n:sub(v,v):byte())end;return u end;local function y(z)local u=\"\"for v=1,#z do u=u..string.char(z[v])end;return u end;local function A(z,B,C)local u={}for v=B,C do table.insert(u,z[v])end;return u end;local function D(E)local u={a[E[1]],a[E[2]],a[E[3]],a[E[4]]}return u end;local function F(E)local G={E[2],E[3],E[4],E[1]}return G end;local function H(E,I)local u={bit32.bxor(E[1],I[1]),bit32.bxor(E[2],I[2]),bit32.bxor(E[3],I[3]),bit32.bxor(E[4],I[4])}return u end;local function J(K,L,M)local N;local O={}for v=1,L do O[v]={K[4*(v-1)+1],K[4*(v-1)+2],K[4*(v-1)+3],K[4*(v-1)+4]}end;for v=L+1,p*(M+1)do N=O[v-1]if(v-1)%L==0 then N=H(D(F(N)),i[(v-1)/L])elseif L>6 and(v-1)%L==4 then N=D(N)end;O[v]=H(O[v-L],N)end;return O end;local function P(Q)local u={}for R,S in ipairs(Q)do u[R]=S end;return u end;local function T(Q)local U={{a[Q[1][1]],a[Q[1][2]],a[Q[1][3]],a[Q[1][4]]},{a[Q[2][1]],a[Q[2][2]],a[Q[2][3]],a[Q[2][4]]},{a[Q[3][1]],a[Q[3][2]],a[Q[3][3]],a[Q[3][4]]},{a[Q[4][1]],a[Q[4][2]],a[Q[4][3]],a[Q[4][4]]}}return U end;local function V(Q)local U={{Q[1][1],Q[1][2],Q[1][3],Q[1][4]},{Q[2][2],Q[2][3],Q[2][4],Q[2][1]},{Q[3][3],Q[3][4],Q[3][1],Q[3][2]},{Q[4][4],Q[4][1],Q[4][2],Q[4][3]}}return U end;local function W(...)local X={...}local Y=X[1]table.remove(X,1)for R,S in ipairs(X)do Y=bit32.bxor(Y,S)end;return Y end;local function Z(Q)local _={{Q[1][1],Q[2][1],Q[3][1],Q[4][1]},{Q[1][2],Q[2][2],Q[3][2],Q[4][2]},{Q[1][3],Q[2][3],Q[3][3],Q[4][3]},{Q[1][4],Q[2][4],Q[3][4],Q[4][4]}}local a0={}for R,S in ipairs(_)do table.insert(a0,{})a0[R][1]=W(c[S[1]],d[S[2]],S[3],S[4])a0[R][2]=W(S[1],c[S[2]],d[S[3]],S[4])a0[R][3]=W(S[1],S[2],c[S[3]],d[S[4]])a0[R][4]=W(d[S[1]],S[2],S[3],c[S[4]])end;local U={{a0[1][1],a0[2][1],a0[3][1],a0[4][1]},{a0[1][2],a0[2][2],a0[3][2],a0[4][2]},{a0[1][3],a0[2][3],a0[3][3],a0[4][3]},{a0[1][4],a0[2][4],a0[3][4],a0[4][4]}}return U end;local function a1(Q,O,a2)local _={{Q[1][1],Q[2][1],Q[3][1],Q[4][1]},{Q[1][2],Q[2][2],Q[3][2],Q[4][2]},{Q[1][3],Q[2][3],Q[3][3],Q[4][3]},{Q[1][4],Q[2][4],Q[3][4],Q[4][4]}}local a3={}for v=4*(a2-1)+1,4*a2 do table.insert(a3,O[v])end;for R,S in ipairs(_)do _[R]=H(S,a3[R])end;local U={{_[1][1],_[2][1],_[3][1],_[4][1]},{_[1][2],_[2][2],_[3][2],_[4][2]},{_[1][3],_[2][3],_[3][3],_[4][3]},{_[1][4],_[2][4],_[3][4],_[4][4]}}return U end;local function a4(Q,O,M)local a5=P(Q)a5=a1(a5,O,1)for a6=1,M-1 do a5=T(a5)a5=V(a5)a5=Z(a5)a5=a1(a5,O,a6+1)end;a5=T(a5)a5=V(a5)a5=a1(a5,O,M+1)return a5 end;local function a7(a8)local u={{},{},{},{}}for a9=1,4 do for aa=1,4 do u[aa][a9]=a8[(a9-1)*4+aa]end end;return u end;local function ab(ac,K)if type(ac)~=\"table\"then error(\"AES_Encrypt: bad argument #1 (expected table, got \"..type(ac)..\")\")end;for R,S in ipairs(ac)do if type(S)~=\"number\"then error(\"AES_Encrypt: Invalid plaintext at \"..R..\" (expected number (0-255), got \"..type(S)..\")\")end;if S<0 or S>255 then error(\"AES_Encrypt: Invalid plaintext at \"..R..\" (expected number (0-255), got \"..S..\")\")end end;if type(K)~=\"table\"then error(\"AES_Encrypt: bad argument #2 (expected table, got \"..type(K)..\")\")end;for R,S in ipairs(K)do if type(S)~=\"number\"then error(\"AES_Encrypt: Invalid key at \"..R..\" (expected number (0-255), got \"..type(S)..\")\")end;if S<0 or S>255 then error(\"AES_Encrypt: Invalid key at \"..R..\" (expected number (0-255), got \"..S..\")\")end end;if#K>32 then K=A(K,1,32)end;if o[#K]==nil then error(\"AES_Encrypt: Key must be 16, 24, 32 characters long\")end;local ad={}for v=1,math.ceil(#ac/16)do table.insert(ad,a7(A(ac,16*(v-1)+1,16*(v-1)+16)))end;local O=J(K,o[#K],q[#K])for R,S in ipairs(ad)do ad[R]=a4(S,O,q[#K])end;local u={}for R,S in ipairs(ad)do for a9=1,4 do for aa=1,4 do table.insert(u,S[aa][a9])end end end;return u end;local function ae(Q)local U={{Q[1][1],Q[1][2],Q[1][3],Q[1][4]},{Q[2][4],Q[2][1],Q[2][2],Q[2][3]},{Q[3][3],Q[3][4],Q[3][1],Q[3][2]},{Q[4][2],Q[4][3],Q[4][4],Q[4][1]}}return U end;local function af(Q)local U={{b[Q[1][1]],b[Q[1][2]],b[Q[1][3]],b[Q[1][4]]},{b[Q[2][1]],b[Q[2][2]],b[Q[2][3]],b[Q[2][4]]},{b[Q[3][1]],b[Q[3][2]],b[Q[3][3]],b[Q[3][4]]},{b[Q[4][1]],b[Q[4][2]],b[Q[4][3]],b[Q[4][4]]}}return U end;local function ag(Q)local _={{Q[1][1],Q[2][1],Q[3][1],Q[4][1]},{Q[1][2],Q[2][2],Q[3][2],Q[4][2]},{Q[1][3],Q[2][3],Q[3][3],Q[4][3]},{Q[1][4],Q[2][4],Q[3][4],Q[4][4]}}local a0={}for R,S in ipairs(_)do table.insert(a0,{})a0[R][1]=W(h[S[1]],f[S[2]],g[S[3]],e[S[4]])a0[R][2]=W(e[S[1]],h[S[2]],f[S[3]],g[S[4]])a0[R][3]=W(g[S[1]],e[S[2]],h[S[3]],f[S[4]])a0[R][4]=W(f[S[1]],g[S[2]],e[S[3]],h[S[4]])end;local U={{a0[1][1],a0[2][1],a0[3][1],a0[4][1]},{a0[1][2],a0[2][2],a0[3][2],a0[4][2]},{a0[1][3],a0[2][3],a0[3][3],a0[4][3]},{a0[1][4],a0[2][4],a0[3][4],a0[4][4]}}return U end;local function ah(Q,O,M)local a5=P(Q)a5=a1(a5,O,M+1)for a6=M-1,1,-1 do a5=ae(a5)a5=af(a5)a5=a1(a5,O,a6+1)a5=ag(a5)end;a5=ae(a5)a5=af(a5)a5=a1(a5,O,1)return a5 end;local function ai(aj,K)if type(aj)~=\"table\"then error(\"AES_Decrypt: bad argument #1 (expected table, got \"..type(aj)..\")\")end;for R,S in ipairs(aj)do if type(S)~=\"number\"then error(\"AES_Decrypt: Invalid ciphertext at \"..R..\" (expected number (0-255), got \"..type(S)..\")\")end;if S<0 or S>255 then error(\"AES_Decrypt: Invalid ciphertext at \"..R..\" (expected number (0-255), got \"..S..\")\")end end;if type(K)~=\"table\"then error(\"AES_Decrypt: bad argument #2 (expected table, got \"..type(K)..\")\")end;for R,S in ipairs(K)do if type(S)~=\"number\"then error(\"AES_Decrypt: Invalid key at \"..R..\" (expected number (0-255), got \"..type(S)..\")\")end;if S<0 or S>255 then error(\"AES_Decrypt: Invalid key at \"..R..\" (expected number (0-255), got \"..S..\")\")end end;if#K>32 then K=A(K,1,32)end;if o[#K]==nil then error(\"AES_Decrypt: Key must be 16, 24, 32 characters long\")end;local ad={}for v=1,math.ceil(#aj/16)do table.insert(ad,a7(A(aj,16*(v-1)+1,16*(v-1)+16)))end;local O=J(K,o[#K],q[#K])for R,S in ipairs(ad)do ad[R]=ah(S,O,q[#K])end;local u={}for R,S in ipairs(ad)do for a9=1,4 do for aa=1,4 do table.insert(u,S[aa][a9])end end end;return u end;local function ak(n)local u={}for v=1,#n do table.insert(u,n:sub(v,v):byte())end;return u end;local function al(n)local function am(an)local u=\"\"for v=#an,1,-1 do u=u..an:sub(v,v)end;return u end;if n:match(\"e\")==nil then return am(n)else local ao=\"[\"..j(n,\".\")[1]..\".]\"n=n:gsub(ao,\"\")local ap=\"[e\"..j(n,\"e\")[2]..\"]\"n=n:gsub(ap,\"\")n=am(n)n=ao:gsub(\"[[]\",\"\"):gsub(\"[]]\",\"\")..n..ap:gsub(\"[[]\",\"\"):gsub(\"[]]\",\"\")return n end end;local function aq(z)local u=\"\"for v=1,#z do u=u..w(z[v])end;return u end;local function ar(ac,as,at,au)ac=ak(ac)for a6=0,as-1 do if a6%2~=0 then for v=1,#ac do ac[v]=ac[v]+(ac[v+1]~=nil and ac[v+1]or ac[1])+at end else for v=1,#ac do ac[v]=math.floor(tonumber(al(tostring(ac[v]))))end;for v=#ac,1,-1 do ac[v]=ac[v]+(ac[v-1]~=nil and ac[v-1]or ac[#ac])+at end end end;local u=aq(ac)while#u<au do u=u..u end;if#u>au then u=u:sub(1,au)end;return u end;local function av(n,at)if type(n)~=\"string\"then error(\"StringToKey: bad argument #1 (expected string, got \"..type(n)..\")\")end;if type(at)~=\"number\"then error(\"StringToKey: bad argument #2 (expected number, got \"..type(at)..\")\")end;local aw=ar(n,32,at,32)local K={}for v=1,#aw do table.insert(K,aw:sub(v,v):byte())end;return K end;local function ax()local ay={}local K={}for v=1,32 do local az=0;while az==0 or ay[az]~=nil do az=math.random(1,255)end;ay[az]=true;table.insert(K,az)end;return K end;local function aA(aB,aC)local u=P(aB)for aa=1,4 do for a9=1,4 do u[aa][a9]=W(u[aa][a9],aC[aa][a9])end end;return u end;local function aD(ac,K,aE)if type(ac)~=\"table\"then error(\"AES_EncryptCBC: bad argument #1 (expected table, got \"..type(ac)..\")\")end;for R,S in ipairs(ac)do if type(S)~=\"number\"then error(\"AES_EncryptCBC: Invalid plaintext at \"..R..\" (expected number (0-255), got \"..type(S)..\")\")end;if S<0 or S>255 then error(\"AES_EncryptCBC: Invalid plaintext at \"..R..\" (expected number (0-255), got \"..S..\")\")end end;if type(K)~=\"table\"then error(\"AES_EncryptCBC: bad argument #2 (expected table, got \"..type(K)..\")\")end;for R,S in ipairs(K)do if type(S)~=\"number\"then error(\"AES_EncryptCBC: Invalid key at \"..R..\" (expected number (0-255), got \"..type(S)..\")\")end;if S<0 or S>255 then error(\"AES_EncryptCBC: Invalid key at \"..R..\" (expected number (0-255), got \"..S..\")\")end end;if#K>32 then K=A(K,1,32)end;if o[#K]==nil then error(\"AES_EncryptCBC: Key must be 16, 24, 32 characters long\")end;if type(aE)~=\"table\"then error(\"AES_EncryptCBC: bad argument #3 (expected table, got \"..type(aE)..\")\")end;for R,S in ipairs(aE)do if type(S)~=\"number\"then error(\"AES_EncryptCBC: Invalid iv at \"..R..\" (expected number (0-255), got \"..type(S)..\")\")end;if S<0 or S>255 then error(\"AES_EncryptCBC: Invalid iv at \"..R..\" (expected number (0-255), got \"..S..\")\")end end;if#aE>16 then aE=A(aE,1,16)end;if#aE~=16 then error(\"AES_EncryptCBC: Iv must be 16 characters long\")end;local ad={}table.insert(ad,a7(aE))for v=1,math.ceil(#ac/16)do table.insert(ad,a7(A(ac,16*(v-1)+1,16*(v-1)+16)))end;local O=J(K,o[#K],q[#K])for v=2,#ad do ad[v]=aA(ad[v],ad[v-1])ad[v]=a4(ad[v],O,q[#K])end;local u={}table.remove(ad,1)for R,S in ipairs(ad)do for a9=1,4 do for aa=1,4 do table.insert(u,S[aa][a9])end end end;return u end;local function aF(aj,K,aE)if type(aj)~=\"table\"then error(\"AES_DecryptCBC: bad argument #1 (expected table, got \"..type(aj)..\")\")end;for R,S in ipairs(aj)do if type(S)~=\"number\"then error(\"AES_DecryptCBC: Invalid ciphertext at \"..R..\" (expected number (0-255), got \"..type(S)..\")\")end;if S<0 or S>255 then error(\"AES_DecryptCBC: Invalid ciphertext at \"..R..\" (expected number (0-255), got \"..S..\")\")end end;if type(K)~=\"table\"then error(\"AES_DecryptCBC: bad argument #2 (expected table, got \"..type(K)..\")\")end;for R,S in ipairs(K)do if type(S)~=\"number\"then error(\"AES_DecryptCBC: Invalid key at \"..R..\" (expected number (0-255), got \"..type(S)..\")\")end;if S<0 or S>255 then error(\"AES_DecryptCBC: Invalid key at \"..R..\" (expected number (0-255), got \"..S..\")\")end end;if#K>32 then K=A(K,1,32)end;if o[#K]==nil then error(\"AES_DecryptCBC: Key must be 16, 24, 32 characters long\")end;if type(aE)~=\"table\"then error(\"AES_DecryptCBC: bad argument #3 (expected table, got \"..type(aE)..\")\")end;for R,S in ipairs(aE)do if type(S)~=\"number\"then error(\"AES_DecryptCBC: Invalid iv at \"..R..\" (expected number (0-255), got \"..type(S)..\")\")end;if S<0 or S>255 then error(\"AES_DecryptCBC: Invalid iv at \"..R..\" (expected number (0-255), got \"..S..\")\")end end;if#aE>16 then aE=A(aE,1,16)end;if#aE~=16 then error(\"AES_DecryptCBC: Iv must be 16 characters long\")end;local aG={}local ad={}table.insert(aG,a7(aE))table.insert(ad,a7(aE))for v=1,math.ceil(#aj/16)do table.insert(ad,a7(A(aj,16*(v-1)+1,16*(v-1)+16)))table.insert(aG,a7(A(aj,16*(v-1)+1,16*(v-1)+16)))end;local O=J(K,o[#K],q[#K])for v=2,#ad do ad[v]=ah(ad[v],O,q[#K])ad[v]=aA(ad[v],aG[v-1])end;local u={}table.remove(ad,1)for R,S in ipairs(ad)do for a9=1,4 do for aa=1,4 do table.insert(u,S[aa][a9])end end end;return u end;return{Encrypt=ab,Decrypt=ai,EncryptCBC=aD,DecryptCBC=aF,StringToKey=av,GenerateRandomKey=ax,StringToTable=x,TableToString=y}\n",setuser=false,size=19408,modified=1757997039493,worldPermissions={write=false,read=true,execute=false},type="file",owner="root"}},setuser=false,size=0,modified=1757997043165,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},libexec={permissions={root={write=true,read=true,execute=true}},created=1757997043165,contents={["dhcpmgr.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997040159,data="local a=require\"system.expect\"local b=require\"system.hardware\"local c=require\"system.log\"local d=require\"system.network\"local e=require\"system.serialization\"local f=require\"system.util\"local function g(h)if h:match\"^%d+$\"then return tonumber(h)elseif h:match\"^%d+%.%d+$\"then return tonumber(h:match\"^%d+\")*0x1000000+tonumber(h:match\"^%d+%.(%d+)\")elseif h:match\"^%d+%.%d+%.%d+$\"then return tonumber(h:match\"^(%d+)\")*0x1000000+tonumber(h:match\"^%d+%.(%d+)\")*0x10000+tonumber(h:match\"^%d+%.%d+%.(%d+)\")elseif h:match\"^%d+%.%d+%.%d+%.%d+$\"then return tonumber(h:match\"^(%d+)\")*0x1000000+tonumber(h:match\"^%d+%.(%d+)\")*0x10000+tonumber(h:match\"^%d+%.%d+%.(%d+)\")*0x100+tonumber(h:match\"^%d+%.%d+%.%d+%.(%d+)\")else error(\"Invalid IP address\",2)end end;local function i(j)if not j then return nil end;return(\"%d.%d.%d.%d\"):format(bit32.band(bit32.rshift(j,24),0xFF),bit32.band(bit32.rshift(j,16),0xFF),bit32.band(bit32.rshift(j,8),0xFF),bit32.band(j,0xFF))end;local function k(j)return bit32.bnot(2^(32-j)-1)end;local function l(m)local n=0;while bit32.btest(m,0x80000000)do m,n=bit32.lshift(m,1),n+1 end;return n end;local o=e.toml.load(\"/etc/dhcpmgr.conf\")a(0,o,a.struct{interface={\"string\",\"nil\"},firstaddr=a.match\"^[%d%.]+$\",lastaddr=a.match\"^[%d%.]+$\",netmask={a.match\"^[%d%.]+$\",\"number\",\"nil\"},gateway={a.match\"^[%d%.]+$\",\"nil\"},dns={a.array{a.match\"^[%d%.]+$\",\"number\"},\"nil\"},leasetime={\"number\",\"nil\"},allowrequests=\"boolean\",storeassignments=\"boolean\",forcereassign=\"boolean\",static=a.table{a.match\"^[%d%.]+$\"},options=\"table\"})local p={}for q,r in pairs(o.static)do p[tonumber(q)]=r end;o.static=p;o.firstaddr=g(o.firstaddr)o.lastaddr=g(o.lastaddr)if type(o.netmask)==\"string\"then o.netmask=g(o.netmask)elseif type(o.netmask)==\"number\"then o.netmask=k(o.netmask)else o.netmask=k(l(bit32.bnot(bit32.bxor(o.firstaddr,o.lastaddr))))end;o.options.dns=o.dns;o.options.gateway=o.gateway;o.options.netmask=i(o.netmask)local s=c.create(\"dhcpmgr\",true,\"/var/log/dhcpmgr.log\")local t;if o.interface then t=b.wrap(o.interface)else t=b.find(\"modem\")end;if not t or not b.hasType(t,\"modem\")then s.error(\"Requested interface does not exist or is not a modem:\")error(\"Requested interface does not exist or is not a modem:\")end;t:open(67)b.listen(t,true)local u=d.ipconfig(b.path(t))if not u or u.ip==\"\"then s.info(\"No IP set on interface, automatically assigning first IP in range\")u=d.ipconfig(b.path(t),{ip=bit32.band(o.firstaddr,o.netmask)+1,netmask=l(o.netmask),up=true})end;local v=b.info(\"/\").metadata.id;local w={}local x={}if o.storeassignments then local y=io.open(\"/var/lib/misc/dhcpmgr\",\"r\")if y then for z in y:lines()do local A,h,B=z:match\"^(%d+)%s+([%d%.]+)%s+(%d+)\"if A then w[tonumber(A)]={address=g(h),expires=tonumber(B)}x[g(h)]=tonumber(A)end end;y:close()end end;for q,r in pairs(o.static)do w[q]={address=g(r),expires=0}x[g(r)]=q end;local function C(A)if w[A]then if o.forcereassign then x[w[A].address]=nil;w[A]=nil else return w[A]end end;for h=o.firstaddr,o.lastaddr do if not x[h]then s.info(\"Assigning address \"..i(h)..\" to ID \"..A)x[h]=A;w[A]={address=h,expires=o.leasetime and math.floor(os.time()+o.leasetime)or 0,pending=true}return w[A]end end;s.warn(\"Could not allocate address for ID \"..A)return nil end;local function D()if o.storeassignments then local y,E=io.open(\"/var/lib/misc/dhcpmgr\",\"w\")if y then for q,r in pairs(w)do if not r.pending then y:write((\"%d %s %d\\n\"):format(q,i(r.address),r.expires))end end;y:close()else s.warn(\"Could not open address database for writing:\",E)end end end;local F=f.timer(60)while true do local G,H=coroutine.yield()if G==\"modem_message\"and H.channel==67 and H.replyChannel==68 and type(H.message)==\"table\"and H.message.dhcp==true and type(H.message.from)==\"number\"then local I=H.message.type;if I==\"discover\"then local h;if type(H.message.requestedIP)==\"string\"and o.allowrequests then local J,K=pcall(g,H.message.requestedIP)if J and K>=o.firstaddr and K<=o.lastaddr and not x[K]then h={address=K,expires=o.leasetime and math.floor(os.time()+o.leasetime)or 0,pending=true}x[K]=H.message.from;w[H.message.from]=h end end;if not h then h=C(H.message.from)end;if h then local L={dhcp=true,type=\"offer\",from=v,to=H.message.from,serverIP=u.ip,offeredIP=i(h.address),messageID=H.message.messageID,options={}}if type(H.message.options)==\"table\"then for q in pairs(H.message.options)do if o.options[q]then L.options[q]=o.options[q]end end end;t:transmit(68,67,L)end elseif I==\"request\"and w[H.message.from]then local h=w[H.message.from]if H.message.to==v then h.pending=nil;D()local L={dhcp=true,type=\"acknowledgement\",from=v,to=H.message.from,serverIP=u.ip,offeredIP=i(h.address),messageID=H.message.messageID,options={}}if type(H.message.options)==\"table\"then for q in pairs(H.message.options)do if o.options[q]then L.options[q]=o.options[q]end end end;t:transmit(68,67,L)else x[h.address]=nil;w[H.message.from]=nil end end elseif G==\"timer\"and H.id==F then local M=os.time()local N=false;for q,r in pairs(w)do if r.expires>0 and M>r.expires then w[q]=nil;x[r.address]=nil;N=true end end;if N then D()end;F=f.timer(60)end end\n",setuser=false,size=5085,modified=1757997040157,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["ftpmgr.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997040617,data="local a=require\"system.expect\"local b=require\"system.filesystem\"local c=require\"system.log\"local d=require\"system.network\"local e=require\"system.process\"local f=require\"system.serialization\"local g=require\"system.terminal\"local h=require\"ftp\"local i=require\"sha2\"local j;if e.getuser()~=\"root\"then error(\"This program must be run as root.\")end;local k=f.toml.load(\"/etc/ftpmgr.conf\")a(0,k,a.struct{ip=a.match\"^[%d%.]+$\",port=\"number\",passivePortRange=a.array\"number\",allUsers={\"boolean\",\"nil\"},users=a.table{a.struct{systemUser={\"string\",\"nil\"},password={\"string\",\"nil\"},passwordHash={\"string\",\"nil\"},passwordSalt={\"string\",\"nil\"},useSystemLogin={\"boolean\",\"nil\"},root={\"string\",\"nil\"}}}})local l=k.users;for m,n in pairs(k.users)do n.systemUser=n.systemUser or m;if n.passwordHash then a.field(n,\"passwordSalt\",\"string\")end;if n.useSystemLogin==nil then n.useSystemLogin=true end;if n.useSystemLogin and not j then j=require\"usermgr\"end;n.root=n.root or\"/\"end;local o=c.create(\"ftpmgr\",true,\"/var/log/ftpmgr.log\")local function p(q)if not l[q]then l[q]={systemUser=q,root=\"/\",useSystemLogin=true,allowWrite=true}end;o.info(\"Logging in as \"..q)b.chroot(l[q].root)e.setuser(l[q].systemUser)e.getenv().didAuthenticate=true;e.getenv().allowWrite=l[q].allowWrite end;local function r(q,s)if e.getenv().didAuthenticate then return true end;if q then local t=l[q]local u=false;if not t then u=k.allUsers and s and j.authenticate(q,s)elseif not t.password and not t.passwordHash and not t.useSystemLogin then u=true elseif s then if t.passwordHash then u=i.sha256(s..t.passwordSalt)==t.passwordHash elseif t.password then u=s==t.password elseif t.useSystemLogin then u=j.authenticate(t.systemUser,s)end end;if u then p(q)return true else o.info(\"Login attempt for user\",q,\"failed: Invalid password\")return false end elseif l.anonymous then p(\"anonymous\")return true else o.info(\"Login attempt for user\",q,\"failed: No anonymous user available\")return false end end;local v={}local function w(x)if x then o.info(\"Closed data port \"..x)v[x]=nil;return end;if not v[20]then o.info(\"Opened data port 20\")v[20]=true;return 20 end;for y=k.passivePortRange[1],k.passivePortRange[2]do if not v[y]then o.info(\"Opened data port \"..y)v[y]=true;return y end end;return nil end;local z=h.server(k.ip,k.port,r,w)local A,B,C,D,E,F,G,H=z.commands.STOR,z.commands.STOU,z.commands.APPE,z.commands.RNFR,z.commands.RNTO,z.commands.DELE,z.commands.RMD,z.commands.MKD;function z.commands.REIN(self,I)return\"502 Not supported\"end;function z.commands.STOR(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return A(...)end;function z.commands.STOU(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return B(...)end;function z.commands.APPE(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return C(...)end;function z.commands.RNFR(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return D(...)end;function z.commands.RNTO(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return E(...)end;function z.commands.DELE(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return F(...)end;function z.commands.RMD(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return G(...)end;function z.commands.MKD(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return H(...)end;local J=\"psp://\"..k.ip..\":\"..k.port;d.listen(J)while true do local K,L=coroutine.yield()if K==\"network_request\"and L.uri==J then o.info(\"Received connection from \"..L.ip)e.fork(function()g.stdin(nil)g.stdout(nil)g.stderr(nil)L.handle:transfer()z:run(L.handle)end,\"[ftpmgr] connection to \"..L.ip)d.listen(J)end end\n",setuser=false,size=3715,modified=1757997040591,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["netmgr.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997041536,data="local a=require\"system.expect\"local b=require\"system.hardware\"local c=require\"system.log\"local d=require\"system.network\"local e=require\"system.serialization\"local f=require\"system.util\"local g=e.toml.load(\"/etc/network.conf\")a(0,g,a.table{a.struct{acquire=\"string\",address={a.match\"^[%d%.]+/?%d*$\",\"number\",\"nil\"},netmask={a.match\"^[%d%.]+$\",\"number\",\"nil\"},gateway={a.match\"^[%d%.]+$\",\"number\",\"nil\"},dns={a.array{a.match\"^[%d%.]+$\",\"number\"},\"nil\"}}})local h=c.create(\"netmgr\",true,\"/var/log/netmgr.log\")local function i(j,k)local l=b.wrap(j)if not l or not b.hasType(l,\"modem\")then error(\"Device does not exist or is not a modem\")end;l:open(68)b.listen(l,true)local m=math.random(0,2^31-1)local n=b.info(\"/\").metadata.id;l:transmit(67,68,{dhcp=true,type=\"discover\",from=n,messageID=m,requestedIP=k,options={netmask=true,gateway=true,dns=true}})local o=f.timer(2)local p={}while true do local q,r=coroutine.yield()if q==\"modem_message\"and r.channel==68 and r.replyChannel==67 and type(r.message)==\"table\"and r.message.dhcp==true and r.message.to==n and r.message.messageID==m and r.message.type==\"offer\"then p[r.message.from]={ip=r.message.offeredIP,netmask=r.message.options.netmask,gateway=r.message.options.gateway,dns=r.message.options.dns,up=true}elseif q==\"timer\"and r.id==o then break end end;if#p==0 then b.listen(l,false)l:close(68)error(\"Could not get IP address: Timed out\")end;for s,t in pairs(p)do d.control(t.ip,\"ping\")f.sleep(2)if not d.arp.list(j)[t.ip]then l:transmit(67,68,{dhcp=true,type=\"request\",from=n,to=s,messageID=m,options={netmask=true}})o=f.timer(2)while true do local q,r=coroutine.yield()if q==\"modem_message\"and r.channel==68 and r.replyChannel==67 and type(r.message)==\"table\"and r.message.dhcp==true and r.message.to==n and r.message.messageID==m and r.message.type==\"acknowledgement\"then d.ipconfig(j,t)if t.gateway then d.route.add({source=\"0.0.0.0\",sourceNetmask=0,action=\"unicast\",destination=t.gateway,device=j})end;b.listen(l,false)l:close(68)f.cancel(o)return elseif q==\"timer\"and r.id==o then b.listen(l,false)l:close(68)error(\"Could not get IP address: No response from server\")end end end end;b.listen(l,false)l:close(68)error(\"Could not get IP address: No usable offers\")end;for u,v in ipairs{b.find(\"modem\")}do local s=b.path(v)local t=g[s]if not t then t=g[b.info(v).uuid]end;if not t then t=g.auto end;if not t then error(\"No config found for \"..s..\" (UUID \"..b.info(v).uuid..\"), and no auto fallback configured\")end;if t.acquire==\"dhcp\"then local w,x=pcall(i,s,nil)if not w then h.error(x)end elseif t.acquire==\"dhcp-static\"then local w,x=pcall(i,s,t.address)if not w then h.error(x)end elseif t.acquire==\"static\"then d.ipconfig(s,{ip=t.address,netmask=t.netmask,up=true})if t.gateway then d.route.add({source=\"0.0.0.0\",sourceNetmask=0,action=\"unicast\",destination=t.gateway,device=s})end end end\n",setuser=false,size=2847,modified=1757997041532,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["usermgr.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997043165,data="coroutine.yield(\"syscall\",\"debug_enable\",nil,false)local a=require\"system.ipc\"local b=require\"system.log\"local c=require\"system.serialization\".base64;local d=require\"system.util\"local e=require\"sha2\"local f={[\"1\"]=e.md5,[\"5\"]=e.sha256,[\"6\"]=e.sha512,[\"\"]=\"\",[\"!\"]=\"Password authentication disabled\",[\"*\"]=\"Password authentication disabled\",[\"*LK*\"]=\"User locked\",[\"*NP*\"]=\"No password set\",[\"!!\"]=\"No password set\"}local g={[e.md5]=\"1\",[e.sha256]=\"5\",[e.sha512]=\"6\",[\"Password authentication disabled\"]=\"!\",[\"User locked\"]=\"*LK*\",[\"No password set\"]=\"!!\"}local h=5000;assert(a.register(\"usermgr\"),\"Could not register usermgr service. Is another instance running?\")local i={}local function j()local k,l=io.open(\"/etc/passwd\",\"r\")if not k then b.warn(\"Could not open /etc/passwd:\",l)return end;for m in k:lines()do local n=d.split(m,\":\",true)if#n>=7 then local o=d.split(n[5],\",\",true)i[n[1]]={fullName=o[1],home=n[6],shell=n[7]}end end;k:close()k,l=io.open(\"/etc/shadow\",\"r\")if not k then b.warn(\"Could not open /etc/shadow:\",l)return end;for m in k:lines()do local n=d.split(m,\":\",true)if#n>=9 then local p=d.split(n[2],\"%$\")i[n[1]].password={hashType=f[p[1]],salt=p[2]and c.decode(p[2]),password=p[3]and c.decode(p[3]),lastChange=tonumber(n[3]),nextChange=tonumber(n[4]),expirationTime=tonumber(n[5]),expirationWarning=tonumber(n[6]),lockTime=tonumber(n[7]),expirationDate=tonumber(n[8])}end end;k:close()end;local function q()local r,l=io.open(\"/etc/passwd\",\"w\")if not r then b.warn(\"Could not open /etc/passwd:\",l)return end;local s,t=io.open(\"/etc/shadow\",\"w\")if not s then r:close()b.warn(\"Could not open /etc/shadow:\",t)return end;for u,v in pairs(i)do local p;if type(v.password.hashType)==\"string\"then p=g[v.password.hashType]else p=\"$\"..g[v.password.hashType]..\"$\"..c.encode(v.password.salt)..\"$\"..c.encode(v.password.password)end;r:write((\"%s:x:::%s:%s:%s\\n\"):format(u,v.fullName or\"\",v.home or\"\",v.shell or\"\"))s:write((\"%s:%s:%d:%s:%s:%s:%s:%s:\\n\"):format(u,p,v.password.lastChange,v.password.nextChange or\"\",v.password.expirationTime or\"\",v.password.expirationWarning or\"\",v.password.lockTime or\"\",v.password.expirationDate or\"\"))end;r:close()s:close()end;j()d.addEventListener(\"remote_event\",function(w,x)local y=d.syscall.getpinfo(x.sender)if x.type==\"usermgr.request.authenticate\"then if type(x.data)~=\"table\"or type(x.data.user)~=\"string\"or type(x.data.password)~=\"string\"then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{error=\"Invalid request\"})return end;if y.user~=\"root\"then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{error=\"Permission denied\"})return end;local z=i[x.data.user]local A;if not z then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{error=\"Unknown user\"})return end;if z.password.hashType==\"\"then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{result=true})return elseif type(z.password.hashType)==\"string\"then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{error=z.password.hashType})return end;if z.password.expirationTime then if z.password.lockTime and os.time()>=(z.password.lastChange+z.password.expirationTime+z.password.lockTime)*86400 then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{error=\"User locked\"})if not z.password.expirationDate then z.password.expirationDate=math.floor(os.time()/86400)end;z.password.hashType=\"User locked\"z.password.password=nil;z.password.salt=nil;q()return elseif os.time()>=(z.password.lastChange+z.password.expirationTime)*86400 then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{error=\"Password expired\"})if not z.password.expirationDate then z.password.expirationDate=math.floor(os.time()/86400)q()end;return elseif z.password.expirationWarning and os.time()>=(z.password.lastChange+z.password.expirationTime-z.password.expirationWarning)*86400 then A=\"Password expires in \"..math.floor(os.time()/86400)-(z.password.lastChange+z.password.expirationTime)..\" days\"end end;local B=x.data.password..z.password.salt;for C=1,h do B=z.password.hashType(B)end;if B==z.password.password then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{result=true,message=A})else a.sendEvent(x.sender,\"usermgr.response.authenticate\",{error=\"Incorrect password\"})end elseif x.type==\"usermgr.request.getUserInfo\"then if type(x.data)~=\"table\"or type(x.data.user)~=\"string\"then a.sendEvent(x.sender,\"usermgr.response.getUserInfo\",{error=\"Invalid request\"})return end;local z=i[x.data.user]a.sendEvent(x.sender,\"usermgr.response.getUserInfo\",{result=z and{name=x.data.user,fullName=z.fullName,home=z.home,shell=z.shell,lastChange=z.password.lastChange*86400,nextChange=z.password.nextChange and(z.password.lastChange+z.password.nextChange)*86400,expirationTime=z.password.expirationTime and(z.password.lastChange+z.password.expirationTime)*86400,expirationWarning=z.password.expirationTime and z.password.expirationWarning and(z.password.lastChange+z.password.expirationTime-z.password.expirationWarning)*86400,lockTime=z.password.expirationTime and z.password.lockTime and(z.password.lastChange+z.password.expirationTime+z.password.lockTime)*86400,isExpired=z.password.expirationDate~=nil,isLocked=z.password.hash and z.password.hash:match\"^!\",hasPassword=z.password.type~=\"No password set\"}})elseif x.type==\"usermgr.request.addUser\"then if type(x.data)~=\"table\"or type(x.data.user)~=\"string\"or x.data.password~=nil and type(x.data.password)~=\"string\"then a.sendEvent(x.sender,\"usermgr.response.addUser\",{error=\"Invalid request\"})return end;if y.user~=\"root\"then a.sendEvent(x.sender,\"usermgr.response.addUser\",{error=\"Permission denied\"})return end;if i[x.data.user]then a.sendEvent(x.sender,\"usermgr.response.addUser\",{error=\"User already exists\"})return end;local z={fullName=tostring(x.data.fullName or\"\"),home=tostring(x.data.home or\"\"),shell=tostring(x.data.shell or\"\"),password={lastChange=math.floor(os.time()/86400)}}if type(x.data.lockTime)==\"number\"then z.password.lockTime=x.data.lockTime end;if x.data.password==nil then z.password.hashType=\"No password set\"elseif x.data.password==\"\"then z.password.hashType=\"\"else local D=\"\"for C=1,16 do D=D..string.char(math.random(0,255))end;local B=x.data.password..D;z.password.hashType=e.sha256;for C=1,h do B=z.password.hashType(B)end;z.password.salt=D;z.password.password=B end;i[x.data.user]=z;q()a.sendEvent(x.sender,\"usermgr.response.addUser\",{result=true})elseif x.type==\"usermgr.request.editUser\"then if type(x.data)~=\"table\"or type(x.data.user)~=\"string\"then a.sendEvent(x.sender,\"usermgr.response.editUser\",{error=\"Invalid request\"})return end;if y.user~=\"root\"and y.user~=x.data.user then a.sendEvent(x.sender,\"usermgr.response.editUser\",{error=\"Permission denied\"})return end;local z=i[x.data.user]if not z then a.sendEvent(x.sender,\"usermgr.response.editUser\",{error=\"User does not exist\"})return end;if type(x.data.fullName)==\"string\"then z.fullName=x.data.fullName end;if type(x.data.home)==\"string\"then z.home=x.data.home end;if type(x.data.shell)==\"string\"then z.shell=x.data.shell end;q()a.sendEvent(x.sender,\"usermgr.response.editUser\",{result=true})elseif x.type==\"usermgr.request.removeUser\"then if type(x.data)~=\"table\"or type(x.data.user)~=\"string\"then a.sendEvent(x.sender,\"usermgr.response.removeUser\",{error=\"Invalid request\"})return end;if y.user~=\"root\"then a.sendEvent(x.sender,\"usermgr.response.removeUser\",{error=\"Permission denied\"})return end;if not i[x.data.user]then a.sendEvent(x.sender,\"usermgr.response.removeUser\",{error=\"User does not exist\"})return end;i[x.data.user]=nil;q()a.sendEvent(x.sender,\"usermgr.response.removeUser\",{result=true})elseif x.type==\"usermgr.request.setPassword\"then if type(x.data)~=\"table\"or type(x.data.user)~=\"string\"or x.data.password~=nil and type(x.data.password)~=\"string\"then a.sendEvent(x.sender,\"usermgr.response.setPassword\",{error=\"Invalid request\"})return end;if y.user~=\"root\"then a.sendEvent(x.sender,\"usermgr.response.setPassword\",{error=\"Permission denied\"})return end;local z=i[x.data.user]if not z then a.sendEvent(x.sender,\"usermgr.response.setPassword\",{error=\"Unknown user\"})return end;if x.data.password==nil then if x.data.isLocked==true then if z.password.password then z.password.password=\"!\"..z.password.password end elseif x.data.isLocked==false then if z.password.password then z.password.password=z.password.password:gsub(\"^!*\",\"\")end elseif x.data.expirationTime then z.password.expirationTime=z.password.lastChange+x.data.expirationTime else z.password.hashType=\"No password set\"z.password.salt,z.password.password=nil end else local D=\"\"for C=1,16 do D=D..string.char(math.random(0,255))end;local B=x.data.password..D;z.password.hashType=e.sha256;for C=1,h do B=z.password.hashType(B)end;z.password.salt=D;z.password.password=B;z.password.lastChange=math.floor(os.time()/86400)if type(x.data.nextChange)==\"number\"then z.password.nextChange=x.data.nextChange end;if type(x.data.expirationTime)==\"number\"then z.password.expirationTime=x.data.expirationTime end;if type(x.data.expirationWarning)==\"number\"then z.password.expirationWarning=x.data.expirationWarning end;if type(x.data.lockTime)==\"number\"then z.password.lockTime=x.data.lockTime end end;q()a.sendEvent(x.sender,\"usermgr.response.setPassword\",{result=true})elseif x.type:match(\"^usermgr%.request%.\")then a.sendEvent(x.sender,x.type:gsub(\"^usermgr%.request%.\",\"usermgr.response.\"),{error=\"Unknown request\"})end end)d.runEvents()\n",setuser=false,size=9356,modified=1757997043113,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["diskmgr.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997040257,data="local a=require\"system.filesystem\"local b=require\"system.hardware\"local c=require\"system.log\"local d=c.create(\"diskmgr\",true)local e={}local function f(g)local h=b.call(g,\"getState\")if h and h.id then local i=\"/media/\"if h.label then i=i..h.label else i=i..h.id end;local j,k=pcall(function()a.mkdir(i)a.mount(\"drivefs\",g,i,{})e[g]=i end)if j then d.info(\"Mounted drive \"..g..\" to \"..i)else d.error(\"Could not mount drive: \"..k)end end end;local function l(i,m)if b.hasType(i,\"drive\")or b.hasType(i,\"modem\")then b.listen(i)end;if m and b.hasType(i,\"drive\")then f(i)end;for n,o in ipairs(b.children(i))do l(i..\"/\"..o,m)end end;b.listen(\"/\")l(\"/\",true)while true do local p,q=coroutine.yield()if p==\"disk\"then f(q.device)elseif p==\"disk_eject\"and e[q.device]then a.unmount(e[q.device])a.remove(e[q.device])e[q.device]=nil elseif p==\"device_added\"then l(q.device,false)end end\n",setuser=false,size=874,modified=1757997040254,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"}},size=0,modified=1757997043165,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},share={permissions={root={write=true,read=true,execute=true}},created=1757997040406,contents={man={permissions={root={write=true,read=true,execute=true}},created=1757997043295,contents={[".mandb"]={permissions={root={read=true,write=true,execute=true}},created=1757997043451,data="craftos(1): run CraftOS programs under Phoenix\nlogger(1): view, post to, create, and delete logs\nlogin(1): \npasswd(1): \nshell(1): CraftOS shell wrapper for Phoenix\nshutdown(1): \nstartctl(1): \nstartmgr(1): \nsu(1): \nsudo(1): \ntar(1): \nyellowbox(1): access and administrate YellowBox boxes\n_template(2): \nacquiresemaphore(2): acquires a resource from a semaphore object\nalarm(2): sets an alarm\narplist(2): returns the list of known IP to computer ID mappings\narpset(2): sets the computer ID mapping for the specified IP\nattach(2): attaches a peripheral of the specified type to the computer\ncallmodule(2): calls a function on a kernel module\ncancel(2): cancels a previously set timer or alarm\ncchost(2): returns the value of the _HOST variable\ncheckuri(2): returns whether the specified URI is valid\nchmod(2): changes the permissions of a file or directory\nchown(2): changes the owner of a file or directory\nchroot(2): changes the root directory\ncombine(2): combines a set of path components into a valid path\nconnect(2): creates a connection to a remote resource\ndetach(2): detaches a peripheral from a side\ndevalias(2): sets or removes an alias for a device\ndevcall(2): calls the specified method on the device\ndevchildren(2): returns a list of names of all children of the current device\ndevfind(2): finds devices with a specific type\ndevinfo(2): returns a table with information describing a device node\ndevlisten(2): enables listening for events from this device\ndevlock(2): locks the specified device to this process\ndevlookup(2): returns all paths to devices that have the specified node name\ndevmethods(2): returns a list of methods that can be called on this device\ndevproperties(2): returns a list of properties on the device\ndevunlock(2): unlocks the specified device\nipconfig(2): queries or modifies the current PIP config\nkernargs(2): returns the arguments passed to the kernel\nkill(2): sends a signal to another process\nlink(2): creates a new symbolic link\nlist(2): returns a list of file names present in a directory\nlisten(2): starts listening for connections on the specified URI\nlistmodules(2): returns a list of currently loaded kernel module names\nloadCraftOSAPI(2): loads a CraftOS API or module from the ROM\nloadmodule(2): attempts to load a kernel module into memory\nlockmutex(2): locks the specified mutex\nmkdir(2): creates a new directory\nmkfifo(2): creates a new FIFO pipe file\nmount(2): mounts a disk device to a path\nmountlist(2): returns a list of mounts on the system\nnetcontrol(2): sends a control message to the specified IP address\nnetevent(2): returns or toggles the current state of network event reporting\nopen(2): opens a file for reading or writing\nqueueEvent(2): queues an arbitrary event to be sent back to the current process\nreleasesemaphore(2): releases a resource from a semaphore\nremove(2): deletes a file at a path\nrename(2): renames a file or directory from one path to another\nrouteadd(2): adds a new route to the specified route table\nroutedel(2): removes the specified route from the specified table\nroutelist(2): returns a list of route entries in the specified route table\nsendEvent(2): queues a remote event to be sent to another process\nsignal(2): registers a handler function to be called for a signal\nstat(2): returns a table with information about a file or directory\ntimeacquiresemaphore(2): acquires a resource from a semaphore object, waiting until available or timeout\ntimelockmutex(2): locks the specified mutex, waiting until the mutex is unlocked or timeout\ntimer(2): sets a timer\ntrylockmutex(2): attempts to lock the mutex\nunlisten(2): stops listening on a URI previously passed to listen\nunloadmodule(2): unloads a kernel module from memory\nunlockmutex(2): unlocks the specified mutex\nunmount(2): unmounts the mount at the specified path\nuptime(2): returns the amount of time the computer has been running\nversion(2): returns the Phoenix version or build number\nftp(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nusermgr(3): \nftpmgr(5): configuration file for ftpmgr\nmotd(5): \npasswd(5): \nshadow(5): \nyahtcc(6): Yahtzee clone for Phoenix\nfuse(7): filesystem in userspace kernel module\ngithubfs(7): GitHub read-only FUSE filesystem\nspanfs(7): RAID-like spanning filesystem across disk peripherals\nyellowbox(7): kernel level CraftOS virtualization\ncomponents(8): \ndpkg(8): \nftpmgr(8): \nmkspanfs(8): Create and format new spanfs disks\nspanadd(8): add drives to an existing span\nspaninfo(8): shows information about a span\nupdate-initrd(8): \nupdate(8): \nuseradd(8): \nuserdel(8): \nusermgr(8): \nusermod(8): \nkernel(9): \n",setuser=false,size=4716,modified=1757997043451,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},man3={permissions={root={write=true,read=true,execute=true}},created=1757997043168,contents={["system.keys.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042241,data="# system.keys\nThe keys module assigns names to the keycode constants that Phoenix sends in\n key events, and adds a few functions to make using them easier.  This module\n uses the same names as the CraftOS `keys` API, so porting programs should be\n trivial.\n\n\n## `getName(id: number): string|nil`\nReturns the name for the specified keycode.\n\n### Arguments\n1. `id`: The keycode to check\n\n### Return Values\nThe name (which is a key in `keys`), or `nil` if the code is invalid\n\n## `getCharacter(id: number): string|nil`\nReturns a printable representation of the keycode if available.\n\n### Arguments\n1. `id`: The keycode to check\n\n### Return Values\nThe keycode's character (in lowercase), or `nil` if the code doesn't have a printable representation\n\n",setuser=false,size=746,modified=1757997042159,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["system.graphics.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042239,data="# system.graphics\nThe graphics module provides functions to draw primitive geometry on a locked\n terminal object.  It supports both text and graphics mode terminals.\n The state of text terminals is preserved, so using these functions doesn't\n change the cursor position or colors.\n\n\n## `drawPixel(term: Terminal|GFXTerminal, x: number, y: number, color: number)`\nDraws a single pixel on screen.\n\n### Arguments\n1. `term`: The terminal to draw on\n2. `x`: The X coordinate to draw at\n3. `y`: The Y coordinate to draw at\n4. `color`: The color to draw with\n\n### Return Values\nThis function does not return anything.\n\n## `drawLine(term: Terminal|GFXTerminal, x1: number, y1: number, x2: number, y2: number, color: number)`\nDraws a line between two points.\n\n### Arguments\n1. `term`: The terminal to draw on\n2. `x1`: The start X coordinate to draw at\n3. `y1`: The start Y coordinate to draw at\n4. `x2`: The end X coordinate to draw at\n5. `y2`: The end Y coordinate to draw at\n6. `color`: The color to draw with\n\n### Return Values\nThis function does not return anything.\n\n## `drawBox(term: Terminal|GFXTerminal, x: number, y: number, width: number, height: number, color: number)`\nDraws an outlined rectangle on screen.\n\n### Arguments\n1. `term`: The terminal to draw on\n2. `x`: The upper-left X coordinate to draw at\n3. `y`: The upper-left Y coordinate to draw at\n4. `width`: The width of the rectangle\n5. `height`: The height of the rectangle\n6. `color`: The color to draw with\n\n### Return Values\nThis function does not return anything.\n\n## `drawFilledBox(term: Terminal|GFXTerminal, x: number, y: number, width: number, height: number, color: number)`\nDraws a filled rectangle on screen.\n\n### Arguments\n1. `term`: The terminal to draw on\n2. `x`: The upper-left X coordinate to draw at\n3. `y`: The upper-left Y coordinate to draw at\n4. `width`: The width of the rectangle\n5. `height`: The height of the rectangle\n6. `color`: The color to draw with\n\n### Return Values\nThis function does not return anything.\n\n## `drawCircle(term: Terminal|GFXTerminal, x: number, y: number, width: number, height: number, color: number[, startAngle: number = 0][, arcCircumference: number = 2*math.pi])`\nDraws an outlined circle (or arc) on screen.\n\n### Arguments\n1. `term`: The terminal to draw on\n2. `x`: The upper-left X coordinate to draw at\n3. `y`: The upper-left Y coordinate to draw at\n4. `width`: The width of the circle\n5. `height`: The height of the circle\n6. `color`: The color to draw with\n7. `startAngle`: The angle to start from in radians (starting at the right side) (defaults to 0)\n8. `arcCircumference`: The amount of the arc to draw in radians (defaults to 2*math.pi)\n\n### Return Values\nThis function does not return anything.\n\n## `drawFilledTriangle(term: Terminal|GFXTerminal, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, color: number)`\nDraws a filled triangle on screen.\n\n### Arguments\n1. `term`: The terminal to draw on\n2. `x1`: The first X coordinate to draw at\n3. `y1`: The first Y coordinate to draw at\n4. `x2`: The second X coordinate to draw at\n5. `y2`: The second Y coordinate to draw at\n6. `x3`: The third X coordinate to draw at\n7. `y3`: The third Y coordinate to draw at\n8. `color`: The color to draw with\n\n### Return Values\nThis function does not return anything.\n\n## `drawImage(term: Terminal|GFXTerminal, x: number, y: number, image: table)`\nDraws an image on screen.  The image may be either a valid graphics mode\n pixel region (using either string or table rows), or a blit table with\n {text, text color, background color} table rows (text mode only).\n\n### Arguments\n1. `term`: The terminal to draw on\n2. `x`: The X coordinate to draw at\n3. `y`: The Y coordinate to draw at\n4. `image`: The image to draw\n\n### Return Values\nThis function does not return anything.\n\n",setuser=false,size=3803,modified=1757997042151,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["system.pretty.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042242,data="# system.pretty\nProvides a \"pretty printer\", for rendering data structures in an\naesthetically pleasing manner.\n\nIn order to display something using @{pretty}, you build up a series of\n@{Doc|documents}. These behave a little bit like strings; you can concatenate\nthem together and then print them to the screen.\n\nHowever, documents also allow you to control how they should be printed. There\nare several functions (such as @{nest} and @{group}) which allow you to control\nthe \"layout\" of the document. When you come to display the document, the 'best'\n(most compact) layout is used.\n\nThe structure of this module is based on [A Prettier Printer][prettier].\n\n[prettier]: https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf \"A Prettier Printer\"\n\n\n",setuser=false,size=760,modified=1757997042169,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["system.process.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042243,data="# system.process\nThe process module allows querying various properties about the current\n process, as well as creating, modifying, and searching other processes.\n\n## `getpid(): number`\nReturns the process ID of the current process.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe process ID of the current process\n\n## `getppid(): number`\nReturns the process ID of the parent process, if available.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe process ID of the parent process, if available\n\n## `getuser(): string`\nReturns the username the process is running under.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe username the process is running under\n\n## `setuser(user: string)`\nSets the user of the current process.  This can only be run by root.\n\n### Arguments\n1. `user`: The user to switch to\n\n### Return Values\nThis function does not return anything.\n\n## `clock(): number`\nReturns the amount of time this process has executed.  This may not be\n entirely accurate due to a lack of precision in the system clock.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe amount of time this process has executed\n\n## `getenv(): table`\nReturns the environment table for the current process.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe environment table for the current process\n\n## `getname(): string`\nReturns the name of the current process.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe name of the current process\n\n## `getcwd(): string`\nReturns the working directory of the current process.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe working directory of the current process\n\n## `chdir(dir: string)`\nSets the working directory of the current process.\n\n### Arguments\n1. `dir`: The new working directory, which must be absolute and existent.\n\n### Return Values\nThis function does not return anything.\n\n## `fork(func: function, name: string, ...: any): number`\nCreates a new process running the specified function with arguments.\n\n### Arguments\n1. `func`: The function to run in the new process. This will be the\n main function of the first thread, and will have its environment set to the\n new process's environment.\n2. `name`: ? The name of the new process.\n3. `...`: Any arguments to pass to the function.\n\n### Return Values\nThe PID of the new process.\n\n## `exec(path: string, ...: any)`\nReplaces the current process with the contents of the specified file.\n This function does not return - it can only throw an error.\n\n### Arguments\n1. `path`: The path to the file to execute.\n2. `...`: Any arguments to pass to the file.\n\n### Return Values\nThis function does not return anything.\n\n## `execp(command: string, ...: any)`\nReplaces the current process with the contents of the specified file or\n command, searching the PATH environment variable if necessary.\n This function does not return - it can only throw an error.\n\n### Arguments\n1. `command`: The command or file to execute.\n2. `...`: Any arguments to pass to the file.\n\n### Return Values\nThis function does not return anything.\n\n## `start(path: string, ...: any): number`\nStarts a new process from the specified path.\n\n### Arguments\n1. `path`: The path to the file to execute.\n2. `...`: Any arguments to pass to the file.\n\n### Return Values\nThe PID of the new process.\n\n## `run(path: string, ...: any): true, any / false, string`\nRuns a program from the specified path in a new process, waiting until it completes.\n\n### Arguments\n1. `path`: The command or file to execute\n2. `...`: Any arguments to pass to the file\n\n### Return Values\nThis function may return the following values:\n1. When the process succeeded\n2. The return value from the process\n\nOr:\n1. When the process errored\n2. The error message from the process\n\n## `newthread(func: function, ...: any): number`\nCreates a new thread running the specified function with arguments.\n Threads in the same process share the same environment, event queue, and\n other properties.\n\n### Arguments\n1. `func`: The function to start\n2. `...`: Any arguments to pass to the function\n\n### Return Values\nThe ID of the new thread\n\n## `exit(code: number)`\nEnds the current process immediately, stopping all threads and sending the\n specified return value to the parent.  This function does not return.\n\n### Arguments\n1. `code`: ? The value to return.\n\n### Return Values\nThis function does not return anything.\n\n## `getplist(): table`\nReturns a list of all valid PIDs.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nA list of all valid PIDs\n\n## `getpinfo(pid: number): {id=number,name=string,user=string,parent?=number,dir=string,stdin?=number,stdout?=number,stderr?=number,cputime=number,systime=number,threads={[number]={id=number,name=string,status=string}}}|nil`\nReturns a table with various information about the specified process.\n\n### Arguments\n1. `pid`: The process ID to query.\n\n### Return Values\nThe process information, or nil if the process doesn't exist.\n\n",setuser=false,size=5130,modified=1757997042172,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["system.terminal.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042244,data="# system.terminal\nThe terminal module defines functions to allow interacting with the terminal\n and screen, as well as handling user input.\n\n## `toEscape(color: number[, background: boolean = false]): string`\nConverts a @{terminal.colors} constant to an ANSI escape code.\n\n### Arguments\n1. `color`: The color to convert\n2. `background`: Whether the escape should set the background (defaults to false)\n\n### Return Values\nThe escape code generated for the color\n\n## `write(...)`\nWrites text to the standard output stream.\n\n### Arguments\n1. `...`: The entries to write. Each one will be separated by tabs (`\\t`).\n\n### Return Values\nThis function does not return anything.\n\n## `writeerr(...)`\nWrites text to the standard error stream.\n\n### Arguments\n1. `...`: The entries to write. Each one will be separated by tabs (`\\t`).\n\n### Return Values\nThis function does not return anything.\n\n## `read(n: number): string|nil`\nReads a number of characters from the standard input stream.\n\n### Arguments\n1. `n`: The number of characters to read\n\n### Return Values\nThe text read, or nil if EOF was reached.\n\n## `readline(): string|nil`\nReads a single line of text from the standard input stream.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe text read, or nil if EOF was reached.\n\n## `termctl(flags: {cbreak?=boolean,delay?=boolean,echo?=boolean,keypad?=boolean,nlcr?=boolean,raw?=boolean}): {cbreak=boolean,delay=boolean,echo=boolean,keypad=boolean,nlcr=boolean,raw=boolean}|nil`\nSets certain terminal control flags on the current TTY if available.\n\n### Arguments\n1. `flags`: ? The flags to set, or nil to just query.\n\n### Return Values\nThe flags that are currently set on the TTY, or nil if no TTY is available.\n\n## `openterm(): Terminal / nil, string`\nOpens the current output TTY in exclusive text mode, allowing direct\n manipulation of the screen buffer.  Only one process may open the terminal at\n a time. Once opened, the screen will be cleared, and stdout will be sent to\n an off-screen buffer to be shown once the terminal is closed. The terminal\n will automatically be closed on process exit.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function may return the following values:\n1. A terminal object for the current TTY.\n\nOr:\n1. If the terminal could not be opened.\n2. An error message describing why the terminal couldn't be opened.\n\n## `opengfx(): GFXTerminal / nil, string`\nOpens the current output TTY in exclusive graphics mode, allowing direct\n manipulation of the pixels if available.  Only one process may open the terminal\n at a time. Once opened, the screen will be cleared, and stdout will be sent to\n an off-screen buffer to be shown once the terminal is closed. The terminal\n will automatically be closed on process exit. This only works on CraftOS-PC.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function may return the following values:\n1. A graphical terminal object for the current TTY.\n\nOr:\n1. If the terminal could not be opened.\n2. An error message describing why the terminal couldn't be opened.\n\n## `mktty(width: number, height: number): TTY`\nCreates a new virtual TTY with the specified size.  This can later be used in\n a call to stdin/stdout/stderr.\n\n### Arguments\n1. `width`: The width of the new TTY.\n2. `height`: The height of the new TTY.\n\n### Return Values\nA new TTY object which is registered with the kernel.\n\n## `stdin(handle: number|TTY|FileHandle|nil)`\nSets the standard input of the current process.\n\n### Arguments\n1. `handle`: The input handle to switch to, as\n either a physical TTY, a virtual TTY, a file, or nil.\n\n### Return Values\nThis function does not return anything.\n\n## `stdout(handle: number|TTY|FileHandle|nil)`\nSets the standard output of the current process.\n\n### Arguments\n1. `handle`: The output handle to switch to, as\n either a physical TTY, a virtual TTY, a file, or nil.\n\n### Return Values\nThis function does not return anything.\n\n## `stderr(handle: number|TTY|FileHandle|nil)`\nSets the standard error of the current process.\n\n### Arguments\n1. `handle`: The output handle to switch to, as\n either a physical TTY, a virtual TTY, a file, or nil.\n\n### Return Values\nThis function does not return anything.\n\n## `istty(): boolean, boolean`\nReturns whether the current stdio are linked to a TTY.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function may return the following values:\n1. Whether the current stdin is linked to a TTY.\n2. Whether the current stdout is linked to a TTY.\n\n## `termsize(): number, number / nil`\nReturns the current size of the TTY if available.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function may return the following values:\n1. The width of the screen.\n2. The height of the screen.\n\nOr:\n1. If the current stdout is not a screen.\n\n## `colors`\nConstants for colors.  This includes both normal and British spelling.\n\n### Fields\n- `white`:\n- `orange`:\n- `magenta`:\n- `lightBlue`:\n- `yellow`:\n- `lime`:\n- `pink`:\n- `gray`:\n- `grey`:\n- `lightGray`:\n- `lightGrey`:\n- `cyan`:\n- `purple`:\n- `blue`:\n- `brown`:\n- `green`:\n- `red`:\n- `black`:\n\n",setuser=false,size=5197,modified=1757997042185,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["usermgr.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997043168,data="",setuser=false,size=0,modified=1757997043130,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["ftp.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997040619,data="",setuser=false,size=0,modified=1757997040597,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["system.expect.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042237,data="# system.expect\nThe expect module provides error checking functions for other libraries.\n\n## `expect(index: number, value: any, ...: string): any`\nCheck that a numbered argument matches the expected type(s).  If the type\n doesn't match, throw an error.\n This function supports custom types by checking the __name metaproperty.\n\n### Arguments\n1. `index`: The index of the argument to check\n2. `value`: The value to check\n3. `...`: The types to check for\n\n### Return Values\n`value`\n\n## `field(tbl: any, key: any, ...: string): any`\nCheck that a key in a table matches the expected type(s).  If the type\n doesn't match, throw an error.\n This function supports custom types by checking the __name metaproperty.\n\n### Arguments\n1. `tbl`: The table (or other indexable value) to search through\n2. `key`: The key of the table to check\n3. `...`: The types to check for\n\n### Return Values\nThe indexed value in the table\n\n## `range(num: number[, min: number = -math.huge][, max: number = math.huge]): number`\nCheck that a number is between the specified minimum and maximum values.  If\n the number is out of bounds, throw an error.\n\n### Arguments\n1. `num`: The number to check\n2. `min`: The minimum value of the number (inclusive) (defaults to -math.huge)\n3. `max`: The maximum value of the number (inclusive) (defaults to math.huge)\n\n### Return Values\n`num`\n\n",setuser=false,size=1349,modified=1757997042139,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["system.network.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042242,data="# system.network\nThe network module implements functions for making and hosting connections\n with local and Internet-connected computers, as well as managing the network\n stack configuration.\n\n## `connect(options: string|table): Handle`\nCreates a new connection to a remote server.\n\n### Arguments\n1. `options`: The URI to connect with, or a table of options\n (see the connect syscall docs for more information)\n\n### Return Values\nA handle to the connection\n\n## `get(options: string|table): Handle / nil, string`\nConnects to an HTTP(S) server, sends a GET request and waits for a response.\n\n### Arguments\n1. `options`: The URL to connect to, or a table of options\n (see the connect syscall docs for more information)\n\n### Return Values\nThis function may return the following values:\n1. The handle to the response data\n\nOr:\n1. If the connection failed\n2. An error describing why the connection failed\n\n## `getData(url: string, headers: table?): string / nil, string`\nConnects to an HTTP(S) server, sends a GET request, waits for a response,\n and returns the data received after closing the connection.\n\n### Arguments\n1. `url`: The URL to connect to\n2. `headers`: Any headers to send in the request (optional)\n\n### Return Values\nThis function may return the following values:\n1. The response data sent from the server\n\nOr:\n1. If the connection failed\n2. An error describing why the connection failed\n\n## `head(options: string|table): Handle / nil, string`\nConnects to an HTTP(S) server, sends a HEAD request and waits for a response.\n\n### Arguments\n1. `options`: The URL to connect to, or a table of options\n (see the connect syscall docs for more information)\n\n### Return Values\nThis function may return the following values:\n1. The handle to the response data\n\nOr:\n1. If the connection failed\n2. An error describing why the connection failed\n\n## `options(options: string|table): Handle / nil, string`\nConnects to an HTTP(S) server, sends an OPTIONS request and waits for a response.\n\n### Arguments\n1. `options`: The URL to connect to, or a table of options\n (see the connect syscall docs for more information)\n\n### Return Values\nThis function may return the following values:\n1. The handle to the response data\n\nOr:\n1. If the connection failed\n2. An error describing why the connection failed\n\n## `post(options: string|table, data: string): Handle / nil, string`\nConnects to an HTTP(S) server, sends a POST request and waits for a response.\n\n### Arguments\n1. `options`: The URL to connect to, or a table of options\n (see the connect syscall docs for more information)\n2. `data`: The data to send to the server\n\n### Return Values\nThis function may return the following values:\n1. The handle to the response data\n\nOr:\n1. If the connection failed\n2. An error describing why the connection failed\n\n## `put(options: string|table, data: string): Handle / nil, string`\nConnects to an HTTP(S) server, sends a PUT request and waits for a response.\n\n### Arguments\n1. `options`: The URL to connect to, or a table of options\n (see the connect syscall docs for more information)\n2. `data`: The data to send to the server\n\n### Return Values\nThis function may return the following values:\n1. The handle to the response data\n\nOr:\n1. If the connection failed\n2. An error describing why the connection failed\n\n## `delete(options: string|table, data: string?): Handle / nil, string`\nConnects to an HTTP(S) server, sends a DELETE request and waits for a response.\n\n### Arguments\n1. `options`: The URL to connect to, or a table of options\n (see the connect syscall docs for more information)\n2. `data`: The data to send to the server, if required (optional)\n\n### Return Values\nThis function may return the following values:\n1. The handle to the response data\n\nOr:\n1. If the connection failed\n2. An error describing why the connection failed\n\n",setuser=false,size=3820,modified=1757997042166,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["system.filesystem.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042238,data="# system.filesystem\nThe filesystem module implements common operations for working with the\n filesystem, including wrappers for syscalls.\n\n## `open(path: string, mode: string): FileHandle / nil, string`\nOpens a file for reading or writing.\n\n### Arguments\n1. `path`: The path to the file to open\n2. `mode`: The mode to open the file in: [rwa]b?\n\n### Return Values\nThis function may return the following values:\n1. The file handle, which has the same functions as CraftOS file handles\n\nOr:\n1. If the file could not be opened\n2. An error message describing why the file couldn't be opened\n\n## `list(path: string): table`\nReturns a list of files in a directory.\n\n### Arguments\n1. `path`: The path to query\n\n### Return Values\nA list of files and folders in the directory\n\n## `stat(path: string[, nolink: boolean = false]): FileStat`\nReturns a table with various information about a file or directory.\n\n### Arguments\n1. `path`: The path to query\n2. `nolink`: Whether to not resolve links to the file (defaults to false)\n\n### Return Values\nA table with information about the path\n\n## `remove(path: string)`\nDeletes a file or directory at a path, removing any subentries if present.\n\n### Arguments\n1. `path`: The path to remove\n\n### Return Values\nThis function does not return anything.\n\n## `rename(from: string, to: string)`\nMoves a file or directory on the same filesystem.\n\n### Arguments\n1. `from`: The original file to move\n2. `to`: The new path for the file\n\n### Return Values\nThis function does not return anything.\n\n## `mkdir(path: string)`\nCreates a directory, making any parent paths that don't exist.\n\n### Arguments\n1. `path`: The directory to create\n\n### Return Values\nThis function does not return anything.\n\n## `link(path: string, location: string)`\nCreates a (symbolic) link to a file.\n\n### Arguments\n1. `path`: The path of the new link\n2. `location`: The location to point the link to\n\n### Return Values\nThis function does not return anything.\n\n## `mkfifo(path: string)`\nCreates a FIFO.\n\n### Arguments\n1. `path`: The FIFO to create\n\n### Return Values\nThis function does not return anything.\n\n## `chmod(path: string, user: string|nil, mode: number|string|{read?=boolean,write?=boolean,execute?=boolean})`\nChanges the permissions (mode) of the file at a path.\n\n### Arguments\n1. `path`: The path to modify\n2. `user`: The user to modify, or nil to modify world permissions\n3. `mode`: The new permissions, as either an octal bitmask, a string in the format \"[+-=][rwx]+\" or \"[r-][w-][x-]\", or a table with the permissions to set (any `nil` arguments are left unset).\n\n### Return Values\nThis function does not return anything.\n\n## `chown(path: string, user: string)`\nChanges the owner of a file or directory.\n\n### Arguments\n1. `path`: The path to modify\n2. `user`: The new owner of the file\n\n### Return Values\nThis function does not return anything.\n\n## `chroot(path: string)`\nChanges the root directory of the current and future child processes.\n This function requires root.\n\n### Arguments\n1. `path`: The new root path to change to\n\n### Return Values\nThis function does not return anything.\n\n## `mount(type: string, src: string, dest: string, options: table?)`\nMounts a filesystem of the specified type to a directory.\n\n### Arguments\n1. `type`: The type of filesystem to mount\n2. `src`: The source of the mount (depends on the FS type)\n3. `dest`: The destination directory to mount to\n4. `options`: A table of options to pass to the filesystem (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `unmount(path: string)`\nUnmounts a mounted filesystem.\n\n### Arguments\n1. `path`: The filesystem to unmount\n\n### Return Values\nThis function does not return anything.\n\n## `mountlist(): [{path:string,type:string,source:string,options:table}]`\nReturns a list of mounts currently available.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nA list of mounts and their properties.\n\n## `combine(...: string): string`\nCombines the specified path components into a single path, canonicalizing any links and ./..  paths.\n\n### Arguments\n1. `...`: The path components to combine\n\n### Return Values\nThe combined and canonicalized path\n\n## `copy(from: string, to: string, preserve: boolean?)`\nCopies a file or directory.\n\n### Arguments\n1. `from`: The path to copy from\n2. `to`: The path to copy to\n3. `preserve`: Whether to preserve permissions when copying (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `move(from: string, to: string)`\nMoves a file or directory, allowing cross-filesystem operations.\n\n### Arguments\n1. `from`: The path to move from\n2. `to`: The path to move to\n\n### Return Values\nThis function does not return anything.\n\n## `basename(path: string): string`\nReturns the file name for a path.\n\n### Arguments\n1. `path`: The path to use\n\n### Return Values\nThe file name of the path\n\n## `dirname(path: string): string`\nReturns the parent directory for a path.\n\n### Arguments\n1. `path`: The path to use\n\n### Return Values\nThe parent directory of the path\n\n## `find(wildcard: string): table`\nSearches the filesystem for paths matching a glob-style wildcard.\n\n### Arguments\n1. `wildcard`: The pathspec to match\n\n### Return Values\nA list of matching file paths\n\n## `exists(path: string): boolean`\nConvenience function for determining whether a file exists.\n This simply checks that @{stat} does not return `nil`.\n\n### Arguments\n1. `path`: The path to check\n\n### Return Values\nWhether the path exists\n\n## `isFile(path: string): boolean`\nReturns whether the path exists and is a file.\n\n### Arguments\n1. `path`: The path to check\n\n### Return Values\nWhether the path is a file\n\n## `isDir(path: string): boolean`\nReturns whether the path exists and is a directory.\n\n### Arguments\n1. `path`: The path to check\n\n### Return Values\nWhether the path is a directory\n\n## `isLink(path: string): boolean`\nReturns whether the path exists and is a link.\n\n### Arguments\n1. `path`: The path to check\n\n### Return Values\nWhether the path is a link\n\n## `effectivePermissions(file: string|FileStat, user: string?): {read:boolean,write:boolean,execute:boolean}|nil`\nReturns the effective permissions on a file or stat entry for the selected user.\n\n### Arguments\n1. `file`: The file path or stat to check\n2. `user`: The user to check for (defaults to the current user) (optional)\n\n### Return Values\nThe permissions for the user, or `nil` if the file doesn't exist\n\n# Class FileStat\nA table which stores file statistics.\n\n## `FileStat.type`\nStores the type of file: one of \"file\", \"directory\", \"link\", \"special\"\n\n### Fields\nThis function does not take any arguments.\n\n## `FileStat.size`\nThe size of the file\n\n### Fields\nThis function does not take any arguments.\n\n## `FileStat.created`\nThe creation date of the file, in milliseconds since January 1, 1970\n\n### Fields\nThis function does not take any arguments.\n\n## `FileStat.modified`\nThe modification date of the file, in milliseconds since January 1, 1970\n\n### Fields\nThis function does not take any arguments.\n\n## `FileStat.owner`\nThe owner of the file\n\n### Fields\nThis function does not take any arguments.\n\n## `FileStat.permissions`\nThe permissions of the file for each user, indexed by user name\n\n### Fields\n- `read`: Whether the file can be read\n- `write`: Whether the file can be written to\n- `execute`: Whether the file can be executed\n\n## `FileStat.worldPermissions`\nThe permissions of the file for all users not in @{FileStat.permissions}\n\n### Fields\n- `read`: Whether the file can be read\n- `write`: Whether the file can be written to\n- `execute`: Whether the file can be executed\n\n## `FileStat.special`\nAny additional data from the filesystem\n\n",setuser=false,size=7653,modified=1757997042143,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["system.ipc.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042240,data="# system.ipc\nThe IPC module provides functions for sending messages to other processes.\n\n## `kill(pid: number, signal: number)`\nSends a basic signal to a process.\n\n### Arguments\n1. `pid`: The PID of the process to send to\n2. `signal`: The signal to send to the process\n\n### Return Values\nThis function does not return anything.\n\n## `sigaction(signal: number, fn: function|nil)`\nSets the handler for a signal.\n\n### Arguments\n1. `signal`: The signal to modify\n2. `fn`: The function to call, or `nil` to remove\n\n### Return Values\nThis function does not return anything.\n\n## `sendEvent(pid: number, event: string, param: table): boolean`\nSends a remote event to a process.\n\n### Arguments\n1. `pid`: The PID of the process to send to\n2. `event`: The event name to send\n3. `param`: The parameter table to send with the event\n\n### Return Values\nWhether the event was sent\n\n## `register(name: string): boolean`\nRegisters the current process as the receiver of a service name.\n\n### Arguments\n1. `name`: The service name to register for\n\n### Return Values\nWhether the service was registered\n\n## `lookup(name: string): number|nil`\nReturns the ID of the process that receives a service name.\n\n### Arguments\n1. `name`: The service to lookup\n\n### Return Values\nThe PID of the process that owns it (if available)\n\n## `sendServiceEvent(name: string, event: string, param: table): boolean`\nSends an event to the owner of a service.\n\n### Arguments\n1. `name`: The service to send to\n2. `event`: The event name to send\n3. `param`: The parameter table to send with the event\n\n### Return Values\nWhether the event was sent\n\n## `receiveEvent(pid: number?, event: string?, timeout: number?): string, table / nil`\nWaits for a remote event, filtering for processes or event names, with an optional timeout.\n\n### Arguments\n1. `pid`: The PID to wait for an event from (optional)\n2. `event`: The event to filter for (optional)\n3. `timeout`: The maximum number of seconds to wait for (optional)\n\n### Return Values\nThis function may return the following values:\n1. The event name received\n2. The parameters for the event\n\nOr:\n1. If the function timed out\n\n## `signal`\nConstants for signal numbers\n\n### Fields\n- `SIGHUP`:\n- `SIGINT`:\n- `SIGQUIT`:\n- `SIGTRAP`:\n- `SIGABRT`:\n- `SIGKILL`:\n- `SIGPIPE`:\n- `SIGTERM`:\n- `SIGCONT`:\n- `SIGSTOP`:\n- `SIGTTIN`:\n- `SIGTTOU`:\n\n",setuser=false,size=2331,modified=1757997042156,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["system.sync.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042244,data="# system.sync\nThe sync library exposes interfaces for various synchronization structures.\n\n# Class mutex\nA mutex is an object that controls access to a variable across multiple threads.\n It ensures only one thread accesses a resource at a time by blocking other\n threads from locking the mutex until the current thread unlocks it.\n\n## `sync.mutex.new(recursive: boolean?): mutex`\nCreates a new mutex.\n\n### Arguments\n1. `recursive`: Whether to make the mutex recursive (optional)\n\n### Return Values\nThe new mutex object\n\n## `sync.mutex:lock()`\nLocks the mutex, waiting if it's currently owned by another thread.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.mutex:unlock()`\nUnlocks the mutex.  This is only valid from the thread that owns the lock.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.mutex:tryLock(): boolean`\nTries to lock the thread, returning false if it could not be locked.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nWhether the mutex is now locked\n\n## `sync.mutex:tryLockFor(timeout: number): boolean`\nLocks the mutex, waiting until it's unlocked or until the specified timeout.\n\n### Arguments\n1. `timeout`: The number of seconds to wait\n\n### Return Values\nWhether the mutex is now locked\n\n# Class semaphore\nA semaphore controls access to a limited number of resources.  A function may\n acquire a resource from the semaphore, decrementing its available count. If\n the count is zero, it waits until another function releases a resource, at\n which point it will acquire it and return.\n\n## `sync.semaphore.new([init: number = 1]): semaphore`\nCreates a new semaphore.\n\n### Arguments\n1. `init`: The initial count of the semaphore (defaults to 1)\n\n### Return Values\nThe new semaphore object\n\n## `sync.semaphore:acquire()`\nAcquires a resource from the semaphore, waiting until there is one available.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.semaphore:tryAcquireFor(timeout: number): boolean`\nAcquires a resource from the semaphore, waiting until there is one available or until a timeout.\n\n### Arguments\n1. `timeout`: The number of seconds to wait\n\n### Return Values\nWhether the resource was acquired\n\n## `sync.semaphore:release()`\nReleases a resource to the semaphore.  This can be called from any thread.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n# Class conditionVariable\nA condition variable allows threads to wait until another thread notifies\n them to resume.\n\n## `sync.conditionVariable.new(): conditionVariable`\nCreates a new condition variable.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe new condition variable.\n\n## `sync.conditionVariable:wait()`\nWaits for a notification from another thread.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.conditionVariable:waitFor(timeout: number): boolean`\nWaits for a notification from another thread, or until a timeout occurs.\n\n### Arguments\n1. `timeout`: The number of seconds to wait\n\n### Return Values\nWhether a notification occurred\n\n## `sync.conditionVariable:notifyOne()`\nNotifies a single (unspecified) thread to continue.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.conditionVariable:notifyAll()`\nNotifies all waiting threads to continue.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n# Class barrier\nA barrier is a lock that waits for a specific number of threads to wait on\n the object, at which point all threads will be released together.\n\n## `sync.barrier.new(count: number): barrier`\nCreates a new barrier object.\n\n### Arguments\n1. `count`: The number of threads to wait for\n\n### Return Values\nA new barrier object\n\n## `sync.barrier:wait(): boolean`\nAdds one to the thread wait count, and waits until it meets the limit.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nWhether this call directly resulted in the barrier being met\n\n# Class rwlock\nA readers-writer lock implements two related locks: a read lock, which can\n be held by multiple threads, and a write lock, which can only be held by one\n thread.  Multiple threads can hold a read lock, but a write lock blocks both\n read and write locks.\n\n## `sync.rwLock.new(): rwlock`\nCreates a new RW lock.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe new RW lock\n\n## `sync.rwLock:lockRead()`\nAcquires the lock for reading, waiting for the write lock to be released first.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.rwLock:unlockRead()`\nReleases the lock for reading.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.rwLock:lockWrite()`\nAcquires the lock for writing, waiting for the read and write locks to be released.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.rwLock:unlockWrite()`\nReleases the lock for writing.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `rwlock:lockGuard(mutex: mutex, fn: function, ...: any): any...`\nCalls a function, ensuring that the mutex is locked before calling and unlocked\n after calling, even if the function returns early or throws an error.\n\n### Arguments\n1. `mutex`: The mutex to lock\n2. `fn`: The function to call\n3. `...`: Any parameters to pass\n\n### Return Values\nThe return values from the function\n\n",setuser=false,size=5981,modified=1757997042182,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["system.framebuffer.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042238,data="# system.framebuffer\nThe framebuffer library provides functions to make \"window\" and \"framebuffer\"\n objects.  These objects imitate a Terminal object (as returned by\n @{system.terminal.openterm}) or GFXTerminal object (as returned by\n @{system.terminal.opengfx}) that may or may not draw to a parent object.\n Windows and framebuffers may be used as parents to other windows and\n framebuffers, in addition to the root terminal object.\n\n A framebuffer object holds its own state, can be redrawn onto the parent\n terminal even if the parent is changed, can be removed from the parent and\n used independently, and its contents can be accessed from code. A window\n object simply changes the coordinates of writing methods, and is entirely\n dependent on the parent.\n\n The type of object returned by each function is dependent on the parent\n passed in. If a Terminal object is passed, a Terminal object is created; if a\n GFXTerminal object is passed, a GFXTerminal object is created. When creating\n a framebuffer with no parent, the @{empty} fields are used to specify the type.\n\n\n## `window(parent: Terminal|GFXTerminal, x: number, y: number, width: number, height: number): Terminal|GFXTerminal`\nCreates a new window object.\n\n### Arguments\n1. `parent`: The parent object to render to\n2. `x`: The X coordinate in the parent to start at\n3. `y`: The Y coordinate in the parent to start at\n4. `width`: The width of the window\n5. `height`: The height of the window\n\n### Return Values\nThe new window object\n\n## `framebuffer(parent: Terminal|GFXTerminal, wx: number|nil, wy: number|nil, w: number, h: number, visible: boolean?): Terminal|GFXTerminal`\nCreates a new framebuffer object.\n\n### Arguments\n1. `parent`: The parent object to render to, or a member of <a href=\"framebuffer.html#empty\">empty</a> to not use a parent\n2. `wx`: The X coordinate in the parent to start at (`nil` if there's no parent)\n3. `wy`: The Y coordinate in the parent to start at (`nil` if there's no parent)\n4. `w`: The width of the framebuffer\n5. `h`: The height of the framebuffer\n6. `visible`: Whether the window should be visible upon creation (optional)\n\n### Return Values\nThe new framebuffer object\n\n## `empty`\nEmpty objects for use when creating framebuffers with no parents.\n\n### Fields\n- `text`: Used to create a text mode Terminal framebuffer\n- `graphics`: Used to create a graphics mode GFXTerminal framebuffer\n\n",setuser=false,size=2388,modified=1757997042146,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["system.serialization.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042243,data="# system.serialization\nThe serialization module provides functions for serializing and deserializing\n objects in multiple formats, as well as some miscellaneous encoding types.\n\n# serialization.base64\n\n\n## `serialization.base64.encode(str: string): string`\nEncodes a binary string into Base64.\n\n### Arguments\n1. `str`: The string to encode\n\n### Return Values\nThe string's representation in Base64\n\n## `serialization.base64.decode(str: string): string`\nDecodes a Base64 string to binary.\n\n### Arguments\n1. `str`: The Base64 to decode\n\n### Return Values\nThe decoded data\n\n# serialization.json\n\n\n## `serialization.json.encode(val: any): string`\nSerializes an arbitrary Lua object into a JSON string.\n\n### Arguments\n1. `val`: The value to encode\n\n### Return Values\nThe JSON representation of the object\n\n## `serialization.json.decode(str: string): any`\nParses a JSON string and returns a Lua value represented by the string.\n\n### Arguments\n1. `str`: The JSON string to decode\n\n### Return Values\nThe Lua value from the JSON\n\n## `serialization.json.save(val: any, path: string)`\nSaves a Lua value to a JSON file.\n\n### Arguments\n1. `val`: The value to save\n2. `path`: The path to the file to save\n\n### Return Values\nThis function does not return anything.\n\n## `serialization.json.load(path: string): any`\nLoads a JSON file into a Lua value.\n\n### Arguments\n1. `path`: The path to the file to load\n\n### Return Values\nThe loaded value\n\n# serialization.lua\n\n\n## `serialization.lua.encode(val: any, opts: {minified=boolean,allow_functions=boolean}?): string`\nSerializes an arbitrary Lua object into a serialized Lua string.\n\n### Arguments\n1. `val`: The value to encode\n2. `opts`: Any options to specify while encoding (optional)\n\n### Return Values\nThe serialized Lua representation of the object\n\n## `serialization.lua.decode(str: string, opts: {allow_functions=boolean}?): any`\nParses a serialized Lua string and returns a Lua value represented by the string.\n\n### Arguments\n1. `str`: The serialized Lua string to decode\n2. `opts`: Any options to specify while decoding (optional)\n\n### Return Values\nThe Lua value from the serialized Lua\n\n## `serialization.lua.save(val: any, path: string, opts: {minified=boolean,allow_functions=boolean}?)`\nSaves a Lua value to a serialized Lua file.\n\n### Arguments\n1. `val`: The value to save\n2. `path`: The path to the file to save\n3. `opts`: Any options to specify while encoding (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `serialization.lua.load(path: string, opts: {allow_functions=boolean}?): any`\nLoads a serialized Lua file into a Lua value.\n\n### Arguments\n1. `path`: The path to the file to load\n2. `opts`: Any options to specify while decoding (optional)\n\n### Return Values\nThe loaded value\n\n",setuser=false,size=2757,modified=1757997042176,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["system.hardware.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042240,data="# system.hardware\nThe hardware module implements functions for operating on peripherals and\n other hardware devices.\n\n## `wrap(device: string): device`\nWraps a device into an indexable object, allowing accessing properties and\n methods of the device by indexing the table.\n If an object is passed, this simply re-wraps the device in a new object.\n\n### Arguments\n1. `device`: The device specifier or object to wrap\n\n### Return Values\nThe wrapped device\n\n## `find(type: string): device...`\nReturns a list of wrapped devices that implement the specified type.\n\n### Arguments\n1. `type`: The type to search for\n\n### Return Values\nThe devices found, or `nil` if none were found\n\n## `path(device: string|device): string...`\nReturns a list of device paths that match the device specifier or object.\n If an absolute path is specified, this returns the same path back.\n If a device object is specified, this returns the path to the device.\n\n### Arguments\n1. `device`: The device specifier or object to read\n\n### Return Values\nThe paths that match the specifier or device object.\n\n## `hasType(device: string|device, type: string): boolean`\nReturns whether the device implements the specified type.\n\n### Arguments\n1. `device`: The device specifier or object to query\n2. `type`: The type to check for\n\n### Return Values\nWhether the device implements the type\n\n## `info(device: string|device): HWInfo|nil`\nReturns a table of information about the specified device.\n\n### Arguments\n1. `device`: The device specifier or object to query\n\n### Return Values\nThe hardware info table, or `nil` if no device was found\n\n## `methods(device: string|device): {string...}`\nReturns a list of methods implemented by this device.\n\n### Arguments\n1. `device`: The device specifier or object to query\n\n### Return Values\nThe methods available to call on this device\n\n## `properties(device: string|device): {string...}`\nReturns a list of properties implemented by this device.\n\n### Arguments\n1. `device`: The device specifier or object to query\n\n### Return Values\nThe properties available on this device\n\n## `children(device: string|device): {string...}`\nReturns a list of children of this device.\n\n### Arguments\n1. `device`: The device specifier or object to query\n\n### Return Values\nThe names of children of the device\n\n## `call(device: string|device, method: string, ...: any): any...`\nCalls a method on a device.\n\n### Arguments\n1. `device`: The device specifier or object to call on\n2. `method`: The method to call\n3. `...`: Any arguments to pass to the method\n\n### Return Values\nThe return values from the method\n\n## `listen(device: string|device[, state: boolean = true])`\nToggles whether this process should receive events from the device.\n\n### Arguments\n1. `device`: The device specifier or object to modify\n2. `state`: Whether to allow events (defaults to true)\n\n### Return Values\nThis function does not return anything.\n\n## `lock(device: string|device[, wait: boolean = true]): boolean`\nLocks the device from being called on or listened to by other processes.\n\n### Arguments\n1. `device`: The device specifier or object to modify\n2. `wait`: Whether to wait for the device to unlock if\n it's currently locked by another process (defaults to true)\n\n### Return Values\nWhether the current process now owns the lock\n\n## `unlock(device: string|device)`\nUnlocks the device after previously locking it.\n\n### Arguments\n1. `device`: The device specifier or object to modify\n\n### Return Values\nThis function does not return anything.\n\n## `tree`\nA table that allows accessing device object pointers in a tree.  This is\n simply syntax sugar for real paths.\n\n### Fields\nThis function does not take any arguments.\n\n",setuser=false,size=3673,modified=1757997042153,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["system.log.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042241,data="# system.log\nThe log module exposes functions for interacting with the logging subsystem.\n The default system log is available under the root `log` table. Other logs\n created through @{log.create} can be accessed by indexing the `log` table with\n the name of the log, e.g. `log.mylog.info(\"hello\")`. Both the main and\n subtables may also be called directly, e.g. `log(\"test\")` or `log.mylog(\"hello\")`.\n\n\n## `log(options: table?, ...: any)`\nWrites a message to the log.\n\n### Arguments\n1. `options`: A table of options to supply. See the documentation\n for the syslog syscall for more information. (optional)\n2. `...`: The values to print to the log, which will be concatenated as\n strings with \\t.\n\n### Return Values\nThis function does not return anything.\n\n## `debug(options: table?, ...: any)`\nWrites a debug message to the log.\n\n### Arguments\n1. `options`: A table of options to supply. See the documentation\n for the syslog syscall for more information. (optional)\n2. `...`: The values to print to the log, which will be concatenated as\n strings with \\t.\n\n### Return Values\nThis function does not return anything.\n\n## `info(options: table?, ...: any)`\nWrites an info message to the log.\n\n### Arguments\n1. `options`: A table of options to supply. See the documentation\n for the syslog syscall for more information. (optional)\n2. `...`: The values to print to the log, which will be concatenated as\n strings with \\t.\n\n### Return Values\nThis function does not return anything.\n\n## `notice(options: table?, ...: any)`\nWrites a notice message to the log.\n\n### Arguments\n1. `options`: A table of options to supply. See the documentation\n for the syslog syscall for more information. (optional)\n2. `...`: The values to print to the log, which will be concatenated as\n strings with \\t.\n\n### Return Values\nThis function does not return anything.\n\n## `warning(options: table?, ...: any)`\nWrites a warning message to the log.\n\n### Arguments\n1. `options`: A table of options to supply. See the documentation\n for the syslog syscall for more information. (optional)\n2. `...`: The values to print to the log, which will be concatenated as\n strings with \\t.\n\n### Return Values\nThis function does not return anything.\n\n## `error(options: table?, ...: any)`\nWrites an error message to the log.\n\n### Arguments\n1. `options`: A table of options to supply. See the documentation\n for the syslog syscall for more information. (optional)\n2. `...`: The values to print to the log, which will be concatenated as\n strings with \\t.\n\n### Return Values\nThis function does not return anything.\n\n## `critical(options: table?, ...: any)`\nWrites a critical error message to the log.\n\n### Arguments\n1. `options`: A table of options to supply. See the documentation\n for the syslog syscall for more information. (optional)\n2. `...`: The values to print to the log, which will be concatenated as\n strings with \\t.\n\n### Return Values\nThis function does not return anything.\n\n## `traceback(message: string?)`\nWrites a traceback error message to the log.\n\n### Arguments\n1. `message`: A message to attach to the traceback (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `create(name: string, streamed: boolean?, file: string?): table`\nCreates a new log.\n\n### Arguments\n1. `name`: The name of the log to create\n2. `streamed`: Whether to make the log available for streaming (optional)\n3. `file`: The path to the file to write the log to (optional)\n\n### Return Values\nA logger object from `log.*`\n\n## `remove(name: string)`\nRemoves a previously created log.\n\n### Arguments\n1. `name`: The log to remove\n\n### Return Values\nThis function does not return anything.\n\n## `open(name: string, filter: string?): number`\nOpens a log for listening to messages.\n\n### Arguments\n1. `name`: The name of the log to listen to\n2. `filter`: A filter command to filter messages with (see the\n openlog syscall docs for more info) (optional)\n\n### Return Values\nAn ID to identify the logged messages with\n\n## `close(name: string|number)`\nCloses a log or stream for listening.\n\n### Arguments\n1. `name`: The log name to close (closes all streams), or an\n ID returned by <a href=\"log.html#open\">log.open</a>.\n\n### Return Values\nThis function does not return anything.\n\n## `setTTY(name: string, tty: TTY|nil, level: number?)`\nSets the TTY to output a log to.  (Requires root)\n\n### Arguments\n1. `name`: The log to set the TTY of\n2. `tty`: The TTY to use, or `nil` to disable\n3. `level`: The minimum log level to show messages (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `levels`\nConstants for log levels.\n\n### Fields\n- `debug`:\n- `info`:\n- `notice`:\n- `warning`:\n- `error`:\n- `critical`:\n\n",setuser=false,size=4678,modified=1757997042162,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["system.util.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042245,data="# system.util\nThe util module contains various functions that don't have any specific\n system function, or help improve the usability of the general system.\n\n## `argparse(arguments: {[string]=string|boolean|nil}, ...: string): {[string]=string|number|boolean|nil,string...} / nil, string`\nTakes a list of valid arguments + the arguments to a program, and returns a\n table with the extracted arguments (and values if requested).\n If an argument with all `-`s is passed, processing of arguments stops, and\n all subsequent arguments are added to the list.\n\n### Arguments\n1. `arguments`: A list of arguments that\n the program accepts. Single-character arguments are handled through `-a`, and\n longer arguments are handled through `--argument`. The value of the entry\n specifies how the argument is handled:\n * If the value is a truthy value, this argument requires a parameter.\n * If the value is `\"number\"`, the argument requires a number parameter.\n * If the value is `\"multiple\"`, the argument can be specified multiple times,\n   and will require a parameter. The values returned will be in a table.\n * If the value is `\"multiple number\"`, the argument can be specified multiple\n   times, and will require a number parameter. These are also in a table.\n * If the value is `false`, the argument does not take a parameter.\n * If the value is `nil`, the argument does not exist and will throw an error\n   if passed.\n * If the value starts with `@`, the parameter is an alias and will be stored\n   in that argument instead, following the same rules as that argument as well.\n Special parameters to the parser can be added in a `[\"\"]` table. The following\n parameters are specified:\n * `stopProcessingOnPositionalArgument` [boolean]: Whether to stop processing\n   arguments when a positional argument is passed, e.g. `myprog -s arg -i` will\n   return `args.s = true`, but `args.i = nil`.\n2. `...`: The arguments as passed to the program.\n\n### Return Values\nThis function may return the following values:\n1.  The arguments\n as parsed from the arguments table as key-value entries, plus positional\n arguments as list entries.\n\nOr:\n1. If the arguments passed are invalid.\n2. An error string describing what was invalid, which can be\n printed for the user.\n\n## `timer(time: number): number`\nStarts a timer that will run for the specified number of seconds.\n A timer event will be queued on completion.\n\n### Arguments\n1. `time`: The number of seconds to wait until sending the event\n\n### Return Values\nThe ID of the newly created timer\n\n## `alarm(time: number): number`\nStarts an alarm that will run until the specified time.\n A timer event will be queued on completion.\n\n### Arguments\n1. `time`: The time to send the event at\n\n### Return Values\nThe ID of the newly created alarm\n\n## `cancel(id: number)`\nCancels a timer or alarm.  This prevents the event from triggering.\n\n### Arguments\n1. `id`: The ID of the timer or alarm to cancel\n\n### Return Values\nThis function does not return anything.\n\n## `sleep(time: number)`\nPauses the process for a certain amount of time.\n\n### Arguments\n1. `time`: The amount of time to wait for, in seconds\n\n### Return Values\nThis function does not return anything.\n\n## `pullEvent(): string, table`\nReturns the next event from the event queue.  This is intended to make it more\n clear when events are being pulled, and also has the benefit of supporting\n libsystem-craftos better.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function may return the following values:\n1. The event pulled\n2. The parameters for the event\n\n## `filterEvent(...: string): string, table`\nWaits until an event of the specified type(s) occurs.\n\n### Arguments\n1. `...`: The event names to filter for\n\n### Return Values\nThis function may return the following values:\n1. The event type that was matched\n2. The parameters for the event\n\n## `queueEvent(event: string, param: table)`\nQueues an event to loop back to the process.\n\n### Arguments\n1. `event`: The event name to send\n2. `param`: The parameter table to send with the event\n\n### Return Values\nThis function does not return anything.\n\n## `split(str: string[, sep: string = \"%s\"][, includeEmpty: boolean = false]): {string...}`\nSplits a string into components.\n\n### Arguments\n1. `str`: The string to split\n2. `sep`: The delimiter match class to split by (defaults to \"%s\")\n3. `includeEmpty`: Whether to include empty matches (defaults to false)\n\n### Return Values\nThe components of the string\n\n## `copy(value: any): any`\nCopies a value recursively, including all its keys and values.\n\n### Arguments\n1. `value`: The value to copy\n\n### Return Values\nA copy of the value, with all keys, values, and metatables duplicated.\n\n## `addEventListener(event: string, callback: function(string,table):boolean)`\nAdds an event listener to the listening module.\n\n### Arguments\n1. `event`: The event to listen for\n2. `callback`: The function to call when\n the event is queued. If the function returns a truthy value, processing for\n the current event will stop. If the function throws an error, the loop will\n stop.\n\n### Return Values\nThis function does not return anything.\n\n## `removeEventListener(event: string, callback: function(string,table))`\nRemoves an event listener from the listening module.\n\n### Arguments\n1. `event`: The event to listen for\n2. `callback`: The function to remove\n\n### Return Values\nThis function does not return anything.\n\n## `runEvents(): string`\nRuns the event listening loop on the current thread, blocking forever.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe error that caused the function to stop\n\n## `startEvents(): number`\nRuns the event listening loop on a new thread, allowing code to run after.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe ID of the new thread\n\n## `type(value: any): string`\nReturns the type of the parameter, with the ability to check the __name\n metamethod for custom types.\n\n### Arguments\n1. `value`: The value to check\n\n### Return Values\nThe type of the value\n\n## `crc32(str: string[, polynomial: table|number = 0xEDB88320][, crc: number = 0xFFFFFFFF]): number`\nCalculates the CRC-32 checksum of the specified data.\n\n### Arguments\n1. `str`: The data to checksum\n2. `polynomial`: The polynomial for the CRC, or the lookup table to use (defaults to 0xEDB88320)\n3. `crc`: The initial CRC value (defaults to 0xFFFFFFFF)\n\n### Return Values\nThe calculated CRC checksum\n\n## `syscall`\nutil.syscall wraps all available syscalls into a table of functions, making\n it possible to call syscalls using direct function calls instead of manually\n yielding and managing the return values.\n\n### Fields\nThis function does not take any arguments.\n\n",setuser=false,size=6732,modified=1757997042189,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997043168,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},man8={permissions={root={write=true,read=true,execute=true}},created=1757997043173,contents={["update-initrd.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997040842,data="",setuser=false,size=0,modified=1757997040832,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["ftpmgr.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997040620,data="",setuser=false,size=0,modified=1757997040609,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["userdel.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997043172,data="",setuser=false,size=0,modified=1757997043148,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["spanadd.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042639,data="<summary>add drives to an existing span</summary>\n# NAME\n    spanadd - add drives to an existing span\n\n# SYNOPSIS\n    **spanadd** *mount point* *drives ...*\n\n# DESCRIPTION\n**spanadd** adds one or more disk drives to an existing span filesystem. This\nallows effectively resizing the span.\n\nThe first argument points to the span to resize. The span must be mounted to be\nable to add drives.\n\nEach remaining argument is the device name of the drive to add. This can be a\ndevice ID, UUID, or path, as would be used with hardware APIs. **The disk in the drives will be erased.**\n\nThe filesystem must be remounted for the changes to take effect.\n\n# HISTORY\nIntroduced in spanfs 0.1.\n\n# SEE ALSO\n**mkspanfs**(8)\n",setuser=false,size=705,modified=1757997042625,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["mkspanfs.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042638,data="<summary>Create and format new spanfs disks</summary>\n# NAME\nmkspanfs - Create and format new spanfs disks\n\n# SYNOPSIS\n**mkspanfs** *volume name* *index drive* *data drive* ...\n\n# DESCRIPTION\n**mkspanfs** creates a new *spanfs* filesystem across the drives specified,\nusing the volume name given as the first argument to name the volume. The command\nwill first verify that all drives provided are valid, and prompts the user to\nconfirm that these drives are correct. Once confirmed, all disks are erased and\nformatted with a new *spanfs* filesystem with the specified name and a random\nUUID. After creation, the disk usage stats are reported.\n\n# EXAMPLE\nCreate a new volume named *Span Volume* on four disks, using `drive_0` to store\nthe index.\n\n`mkspanfs \"Span Volume\" drive_0 drive_1 drive_2 drive_3`\n\n# SEE ALSO\n**spanfs**(7)",setuser=false,size=828,modified=1757997042622,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["update.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997040430,data="",setuser=false,size=0,modified=1757997040416,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["usermod.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997043173,data="",setuser=false,size=0,modified=1757997043153,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["usermgr.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997043173,data="",setuser=false,size=0,modified=1757997043150,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["dpkg.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997040429,data="",setuser=false,size=0,modified=1757997040414,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["useradd.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997043172,data="",setuser=false,size=0,modified=1757997043145,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["spaninfo.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042640,data="<summary>shows information about a span</summary>\n# NAME\n    spaninfo - shows information about a span\n\n# SYNOPSIS\n    **spaninfo** *mount path*\n\n# DESCRIPTION\n**spaninfo** shows various information about a mounted span, including UUID, name,\ncapacity, free space, and space info on individual disks.\n\n# HISTORY\nIntroduced in spanfs 0.1.\n",setuser=false,size=338,modified=1757997042628,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["components.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997040429,data="",setuser=false,size=0,modified=1757997040410,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997043173,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},man2={permissions={root={write=true,read=true,execute=true}},created=1757997042237,contents={["checkuri.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042205,data="<summary>returns whether the specified URI is valid</summary>\n# NAME\ncheckuri - returns whether the specified URI is valid\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**checkuri**(*uri*: string): boolean\n\n# DESCRIPTION\nReturns whether the specified URI is valid and the scheme is supported.\n\n# PARAMETERS\n1. `uri`: The URI to check\n\n# RETURN VALUE\nWhether the URI is valid. This will always return `false` for an unsupported URI scheme. For HTTP and WebSocket URLs, this will check that the URL can be connected to as well.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=665,modified=1757997041959,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["chroot.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042206,data="<summary>changes the root directory</summary>\n# NAME\nchroot - changes the root directory\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**chroot**(*path*: string)\n\n# DESCRIPTION\nChanges the root directory of the current and future child processes. This syscall requires root.\n\n# PARAMETERS\n1. `path`: The path to the new root directory.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user is not root.\n* The new root directory does not exist.\n\n# HISTORY\nIntroduced in Phoenix 0.0.3.\n",setuser=false,size=605,modified=1757997041969,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["signal.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042229,data="<summary>registers a handler function to be called for a signal</summary>\n# NAME\nsignal - registers a handler function to be called for a signal\n\n# LIBRARY\nStandard system library, IPC module (*libsystem*, `system.ipc`)\n\n# SYNOPSIS\n**signal**(*signal*: number, *handler*: function(signal: number))\n\n# DESCRIPTION\nRegisters a handler function to be called for a signal.\n\n# PARAMETERS\n1. `signal`: The signal ID to register for.\n2. `handler`: The handler function to call, which takes the signal ID as its only argument.\n\n# RETURN VALUES\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**kill**(2)\n",setuser=false,size=685,modified=1757997042098,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["version.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042237,data="<summary>returns the Phoenix version or build number</summary>\n# NAME\nversion - returns the Phoenix version or build number\n\n# SYNOPSIS\n**version**(*buildnum*: boolean?): string\n\n# DESCRIPTION\nReturns the Phoenix version or build number.\n\n# PARAMETERS\n1. `buildnum`: `true` to return the minor build string/information, `false` to return the version number\n\n# RETURN VALUE\nThe version number of the current Phoenix kernel.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**cchost**(2)\n",setuser=false,size=539,modified=1757997042133,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["uptime.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042236,data="<summary>returns the amount of time the computer has been running</summary>\n# NAME\nuptime - returns the amount of time the computer has been running\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**uptime**(): number\n\n# DESCRIPTION\nReturns the amount of time the computer has been running.\n\n# PARAMETERS\nThis syscall does not take any arguments.\n\n# RETURN VALUE\nThe amount of time the computer has been running in seconds.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=563,modified=1757997042131,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["timeacquiresemaphore.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042231,data="<summary>acquires a resource from a semaphore object, waiting until available or timeout</summary>\n# NAME\ntimeacquiresemaphore - acquires a resource from a semaphore object, waiting until available or timeout\n\n# LIBRARY\nStandard system library, synchronization module (*libsystem*, `system.sync`)\n\n# SYNOPSIS\n**timeacquiresemaphore**(*sem*: semaphore, *timeout*: number): boolean\n\n# DESCRIPTION\nAcquires a resource from a semaphore object, waiting if none are available, until the specified timeout passes.\n\n# PARAMETERS\n1. `sem`: The semaphore to acquire.\n2. `timeout`: The amount of time to wait in seconds.\n\n# RETURN VALUE\nWhether a resource was successfully acquired.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**acquiresemaphore**(2), **releasesemaphore**(2)\n",setuser=false,size=823,modified=1757997042104,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["unlockmutex.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042235,data="<summary>unlocks the specified mutex</summary>\n# NAME\nunlockmutex - unlocks the specified mutex\n\n# LIBRARY\nStandard system library, synchronization module (*libsystem*, `system.sync`)\n\n# SYNOPSIS\n**unlockmutex**(*mtx*: mutex)\n\n# DESCRIPTION\nUnlocks the specified mutex.\n\n# PARAMETERS\n1. `mtx`: The mutex to unlock.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The mutex is already unlocked.\n* The mutex is currently locked by a different thread.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**lockmutex**(2)\n",setuser=false,size=573,modified=1757997042125,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["devfind.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042210,data="<summary>finds devices with a specific type</summary>\n# NAME\ndevfind - finds devices with a specific type\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devfind**(*type*: string): string...\n\n# DESCRIPTION\nReturns all paths to devices that have the specified type implemented.\n\n# PARAMETERS\n1. `name`: The device type to search for\n\n# RETURN VALUE\nThe path to each node in the device tree that has the specified type.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**devlookup**(2)\n",setuser=false,size=588,modified=1757997041987,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["unloadmodule.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042234,data="<summary>unloads a kernel module from memory</summary>\n# NAME\nunloadmodule - unloads a kernel module from memory\n\n# SYNOPSIS\n**unloadmodule**(*path*: string)\n\n# DESCRIPTION\nUnloads a kernel module from memory. This syscall requires root.\n\n# PARAMETERS\n1. `name`: The name of the module to unload\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The user is not root.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**loadmodule**(2)\n",setuser=false,size=491,modified=1757997042122,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["releasesemaphore.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042225,data="<summary>releases a resource from a semaphore</summary>\n# NAME\nreleasesemaphore - releases a resource from a semaphore\n\n# LIBRARY\nStandard system library, synchronization module (*libsystem*, `system.sync`)\n\n# SYNOPSIS\n**releasesemaphore**(*sem*: semaphore)\n\n# DESCRIPTION\nReleases a resource from a semaphore. This is a guaranteed atomic alternative to `sem.count = sem.count + 1`, and should be preferred.\n\n# PARAMETERS\n1. `sem`: The semaphore to release.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**acquiresemaphore**(2)\n",setuser=false,size=639,modified=1757997042070,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["listen.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042217,data="<summary>starts listening for connections on the specified URI</summary>\n# NAME\nlisten - starts listening for connections on the specified URI\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**listen**(*uri*: string)\n\n# DESCRIPTION\nStarts listening for connections on the specified URI, using the protocol, IP, and port indicated in the URI. For PSP connections, the IP is used to determine the device to listen on - if this is `0.0.0.0`, then all connections are accepted.\n\nWhen a request is received, a `network_request` event is sent with the URI of the listener, the IP of the other computer (if available), and a handle to the connection. Listening will continue until `unlisten` is called with the same URI. (Note: PSP can only handle one connection at once per port.)\n\nThe following URI schemes are built-in:\n* `http`: Internet HTTP requests (CraftOS-PC only)\n* `ws`: Internet WebSocket connections (CraftOS-PC only)\n* `psp`: Phoenix Socket Protocol connections\n\nOther schemes may be implemented in kernel modules.\n\n# PARAMETERS\n1. `uri`: The URI to listen on. The path portion is ignored.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The URI specified is malformed.\n* The scheme in the URI is not supported.\n* The computer does not own the IP in the URI.\n* The computer is already using the IP/port specified.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**unlisten**(2)\n",setuser=false,size=1491,modified=1757997042029,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["ipconfig.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042214,data="<summary>queries or modifies the current PIP config</summary>\n# NAME\nipconfig - queries or modifies the current PIP config\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**ipconfig**(*device*: string, *info*: table?): table?\n\n# DESCRIPTION\nReturns a table with information about the current PIP configuration for the specified modem, and optionally sets new options (requires root).\n\nIf no configuration is present, then both the IP and netmask must be specified if `info` is set.\n\n# PARAMETERS\n1. `device`: The path to the modem to operate on\n2. `info`: If provided, a table of configuration options to set on the device, in the same format as the returned table\n\n# RETURN VALUE\nA table of PIP configuration entries. These are the currently used members:\n* `ip: string`: The IP address of the modem. No IP is indicated with an empty string. (When setting, this may also be a 32-bit number representing the IP in big-endian format.)\n* `netmask: number`: The subnet mask expressed as a number of bits, as in CIDR notation. No subnet mask is indicated with a value of `0`. (When setting, this may also be an IP-formatted address string.)\n* `up: boolean`: Whether the link is currently up. If a link is down, no Phoenix networking protocols will be serviced on this device. (This allows user applications to manually manage the protocols instead, if required.)\n\nIf the device does not have any IP configuration, returns `nil`.\n\n# ERRORS\nThis syscall may throw an error if:\n* The device is not present.\n* The device is not a valid modem.\n* A non-root user attempted to set configurations.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=1673,modified=1757997042014,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["routedel.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042227,data="<summary>removes the specified route from the specified table</summary>\n# NAME\nroutedel - removes the specified route from the specified table\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**routedel**(*source*: string, *mask*: number, *num*: number?)\n\n# DESCRIPTION\nRemoves the specified route from the specified table.\n\n# PARAMETERS\n1. `source`: The source IP address to remove in CIDR notation (e.g. `192.168.0.0/16`)\n2. `mask`: The netmask prefix length of the IP to remove\n3. `num`: The table number to modify as an integer starting at 1 (default 1)\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* A non-root user attempted to remove routes.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**routeadd**(2)\n",setuser=false,size=819,modified=1757997042087,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["devinfo.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042211,data="<summary>returns a table with information describing a device node</summary>\n# NAME\ndevinfo - returns a table with information describing a device node\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devinfo**(*device*: string): HWInfo?\n\n# DESCRIPTION\nReturns a table with information describing a device node.\n\n# PARAMETERS\n1. `device`: The device path or UUID to look up\n\n# RETURN VALUE\nA table with the following information:\n```ts\ntype HWInfo = {\n    id: string,                // Device hardware ID\n    uuid: string,              // Assigned UUID\n    alias: string?,            // User-specified alias\n    parent: string,            // Path to parent device\n    displayName: string,       // Display name for users\n    types: {[string]: string}, // Types of devices implemented: type = driver name\n    metadata: Object           // Extra static metadata provided by drivers\n}\n```\nIf the device does not exist, this returns `nil`.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**devmethods**(2), **devproperties**(2)\n",setuser=false,size=1128,modified=1757997041991,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["timer.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042232,data="<summary>sets a timer</summary>\n# NAME\ntimer - sets a timer\n\n# LIBRARY\nStandard system library, utility module (*libsystem*, `system.util`)\n\n# SYNOPSIS\n**timer**(*timeout*: number): number\n\n# DESCRIPTION\nSets a timer that will send a `timer` event after the specified number of seconds.\n\n# PARAMETERS\n1. `timeout`: The amount of time to set the timer for.\n\n# RETURN VALUE\nThe ID of the new timer created.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**alarm**(2), **cancel**(2)\n",setuser=false,size=531,modified=1757997042111,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["timelockmutex.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042231,data="<summary>locks the specified mutex, waiting until the mutex is unlocked or timeout</summary>\n# NAME\ntimelockmutex - locks the specified mutex, waiting until the mutex is unlocked or timeout\n\n# LIBRARY\nStandard system library, synchronization module (*libsystem*, `system.sync`)\n\n# SYNOPSIS\n**timelockmutex**(*mtx*: mutex, *timeout*: number): boolean\n\n# DESCRIPTION\nLocks the specified mutex, waiting for the resource to be freed before claiming it. If the mutex isn't unlocked after the specified timeout, the syscall returns without locking.\n\n# PARAMETERS\n1. `mtx`: The mutex to lock.\n2. `timeout`: The amount of time to wait in seconds.\n\n# RETURN VALUE\nWhether the mutex could be locked.\n\n# ERRORS\nThis syscall may throw an error if:\n* The mutex is already claimed by the current thread and is not recursive.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**lockmutex**(2), **unlockmutex**(2)\n",setuser=false,size=900,modified=1757997042108,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["unmount.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042235,data="<summary>unmounts the mount at the specified path</summary>\n# NAME\nunmount - unmounts the mount at the specified path\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**unmount**(*path*: string)\n\n# DESCRIPTION\nUnmounts the mount at the specified path.\n\n# PARAMETERS\n1. `path`: The path to the mount.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The path does not exist.\n* The path specified is not a mount.\n* The user does not have permission to write to the path.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**mount**(2), **mountlist**(2)\n",setuser=false,size=658,modified=1757997042127,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["cancel.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042204,data="<summary>cancels a previously set timer or alarm</summary>\n# NAME\ncancel - cancels a previously set timer or alarm\n\n# LIBRARY\nStandard system library, utility module (*libsystem*, `system.util`)\n\n# SYNOPSIS\n**cancel**(*tm*: number)\n\n# DESCRIPTION\nCancels a previously set timer or alarm.\n\n# PARAMETERS\n1. `tm`: The ID of the timer or alarm to cancel.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**alarm**(2), **timer**(2)\n",setuser=false,size=531,modified=1757997041952,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["devchildren.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042210,data="<summary>returns a list of names of all children of the current device</summary>\n# NAME\ndevchildren - returns a list of names of all children of the current device\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\ndevchildren(device: string): string[]\n\n# DESCRIPTION\nReturns a list of names of all children of the current device.\n\n# PARAMETERS\n1. `device`: The device path or UUID to look up\n\n# RETURN VALUE\nA list of child names, in an unspecified order. This table may be empty.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=653,modified=1757997041985,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["devalias.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042208,data="<summary>sets or removes an alias for a device</summary>\n# NAME\ndevalias - sets or removes an alias for a device\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devalias**(*device*: string, *alias*: string?)\n\n# DESCRIPTION\nSets or removes an alias for a device.\n\n# PARAMETERS\n1. `device`: The device path or UUID to modify\n2. `alias`: The new alias to set (`nil` to remove)\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=605,modified=1757997041979,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["netevent.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042224,data="<summary>returns or toggles the current state of network event reporting</summary>\n# NAME\nnetevent - returns or toggles the current state of network event reporting\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**netevent**(*state*: boolean?): boolean\n\n# DESCRIPTION\nReturns the current state of network event reporting in the current process, and toggles it if desired. This allows listening to events such as control messages, PSP messages, send failures, etc.\n\n# PARAMETERS\n1. `state`: If specified, whether to send general network events to the current process\n\n# RETURN VALUE\nThe current state of network event reporting.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user is not root.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=794,modified=1757997042059,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["mkfifo.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042222,data="<summary>creates a new FIFO pipe file</summary>\n# NAME\nmkfifo - creates a new FIFO pipe file\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**mkfifo**(*path*: string)\n\n# DESCRIPTION\nCreates a new FIFO (first in first out) pipe file at a path, creating any parent directories if they don't exist.\n\n# PARAMETERS\n1. `path`: The path to the FIFO to create.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user does not have permission to write the parent directory of the first directory created.\n* The path already exists.\n\n# HISTORY\nIntroduced in Phoenix 0.0.3.\n",setuser=false,size=681,modified=1757997042046,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["sendEvent.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042228,data="<summary>queues a remote event to be sent to another process</summary>\n# NAME\nsendEvent - queues a remote event to be sent to another process\n\n# LIBRARY\nStandard system library, IPC module (*libsystem*, `system.ipc`)\n\n# SYNOPSIS\n**sendEvent**(*pid*: number, *name*: string, *params*: any)\n\n# DESCRIPTION\nQueues a remote event to be sent to another process. This creates an event called `remote_event` with the name and parameters passed as parameters. It does *not* allow sending arbitrary events to a process.\n\n# PARAMETERS\n1. `pid`: The ID of the process to send to.\n2. `name`: The name of the remote event to send.\n3. `params`: The data to send with the event.\n\n# RETURN VALUES\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=806,modified=1757997042094,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["devunlock.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042214,data="<summary>unlocks the specified device</summary>\n# NAME\ndevunlock - unlocks the specified device\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devunlock**(*device*: string)\n\n# DESCRIPTION\nUnlocks the specified device, allowing access to the device in other processes. This syscall does nothing if the device is not locked.\n\n# PARAMETERS\n1. `device`: The device path or UUID to operate on\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n* Another process has locked this device.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**devlock**(2)\n",setuser=false,size=689,modified=1757997042009,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["cchost.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042204,data="<summary>returns the value of the _HOST variable</summary>\n# NAME\ncchost - returns the value of the _HOST variable\n\n# SYNOPSIS\n**cchost**(): string\n\n# DESCRIPTION\nReturns the value of the `_HOST` variable.\n\n# PARAMETERS\nThis syscall does not take any arguments.\n\n# RETURN VALUE\nThe value of `_HOST`, which is in the format `ComputerCraft [0-9%.]+ %b()`.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**version**(2)\n",setuser=false,size=471,modified=1757997041956,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["trylockmutex.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042233,data="<summary>attempts to lock the mutex</summary>\n# NAME\ntrylockmutex - attempts to lock the mutex\n\n# LIBRARY\nStandard system library, synchronization module (*libsystem*, `system.sync`)\n\n# SYNOPSIS\n**trylockmutex**(*mtx*: mutex): boolean\n\n# DESCRIPTION\nAttempts to lock the mutex, returning immediately if the mutex could not be locked.\n\n# PARAMETERS\n1. `mtx`: The mutex to lock.\n\n# RETURN VALUE\nWhether the mutex could be locked.\n\n# ERRORS\nThis syscall may throw an error if:\n* The mutex is already claimed by the current thread and is not recursive.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**lockmutex**(2), **unlockmutex**(2)\n",setuser=false,size=638,modified=1757997042115,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["listmodules.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042218,data="<summary>returns a list of currently loaded kernel module names</summary>\n# NAME\nlistmodules - returns a list of currently loaded kernel module names\n\n# SYNOPSIS\n**listmodules**(): string[]\n\n# DESCRIPTION\nReturns a list of currently loaded kernel module names.\n\n# PARAMETERS\nThis syscall does not take any arguments.\n\n# RETURN VALUE\nA list of currently loaded kernel module names.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=471,modified=1757997042033,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["routeadd.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042227,data="<summary>adds a new route to the specified route table</summary>\n# NAME\nrouteadd - adds a new route to the specified route table\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**routeadd**(*options*: table)\n\n# DESCRIPTION\nAdds a new route to the specified route table. If the table does not exist, it will be created.\n\n# PARAMETERS\n1. `options`: A table with options for the route entry, with the following fields:\n  * `source: string`: The bottom end of the source IP range.\n  * `sourceNetmask: number`: The source subnet mask. For a single IP, this is 32. For all IPs (`default`), this is 0.\n  * `action: string`: The action to take on the message. Valid values:\n    * `\"unicast\"`: Send all messages to the specified destination.\n    * `\"broadcast\"`: Broadcast the message to all destinations on the device.\n    * `\"local\"`: Send the message to a known destination on a local network.\n    * `\"unreachable\"`: Send a Destination Unreachable message back to the sender.\n    * `\"prohibit\"`: Send a Prohibit message back to the sender.\n    * `\"blackhole\"`: Ignore the message altogether.\n  * `device: string?`: The device path to send the message to.\n  * `destination: string?`: The destination IP to forward to.\n  * `table: number?`: A number specifying the table index to insert into (integer starting at 1; defaults to 1).\n\nThe actions `\"local\"`, `\"unicast\"` and `\"broadcast\"` require `device`; `\"unicast\"` also requires `destination`.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* A non-root user attempted to add routes.\n* A route already exists with the same IP and netmask.\n* The device (if specified) is not present.\n* The device (if specified) is not a valid modem.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**routedel**(2)\n",setuser=false,size=1845,modified=1757997042083,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["routelist.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042228,data="<summary>returns a list of route entries in the specified route table</summary>\n# NAME\nroutelist - returns a list of route entries in the specified route table\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**routelist**(*num*: number?): table?\n\n# DESCRIPTION\nReturns a list of route entries in the specified route table.\n\n# PARAMETERS\n1. `num`: The table number to check as an integer starting at 0 (default 1)\n\n# RETURN VALUE\nA list of route entries with the following fields:\n* `source: string`: The bottom end of the source IP range.\n* `sourceNetmask: number`: The source subnet mask. For a single IP, this is 32. For all IPs (`default`), this is 0.\n* `action: string`: The action to take on the message. Valid values:\n  * `\"unicast\"`: Send all messages to the specified destination.\n  * `\"broadcast\"`: Broadcast the message to all destinations on the device.\n  * `\"local\"`: Send the message to a known destination on a local network.\n  * `\"unreachable\"`: Send a Destination Unreachable message back to the sender.\n  * `\"prohibit\"`: Send a Prohibit message back to the sender.\n  * `\"blackhole\"`: Ignore the message altogether.\n* `device: string?`: The device path to send the message to.\n* `destination: string?`: The destination IP to forward to.\n\nIf the specified table does not exist, this will return `nil`.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**routeadd**(2), **routedel**(2)\n",setuser=false,size=1499,modified=1757997042090,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["link.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042216,data="<summary>creates a new symbolic link</summary>\n# NAME\nlink - creates a new symbolic link\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**link**(*path*: string, *location*: string)\n\n# DESCRIPTION\nCreates a new symbolic link at a path, creating any parent directories if they don't exist.\n\n# PARAMETERS\n1. `path`: The path to the link to create.\n2. `location`: The location the link should point to. This may be on another filesystem, as the link is symbolic.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user does not have permission to write the parent directory of the first directory created.\n* The path already exists.\n\n# HISTORY\nIntroduced in Phoenix 0.0.3.\n",setuser=false,size=787,modified=1757997042022,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["remove.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042226,data="<summary>deletes a file at a path</summary>\n# NAME\nremove - deletes a file at a path\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**remove**(*path*: string)\n\n# DESCRIPTION\nDeletes a file at a path. If the file is a directory, this also removes all files and directories contained within it. If the file does not exist, this does nothing and returns successfully.\n\n# PARAMETERS\n1. `path`: The path to the file to delete.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user does not have permission to write the file.\n* The current user does not have permission to write child subfiles and subdirectories.\n* The current user does not have permission to write the parent directory.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=843,modified=1757997042074,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["callmodule.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042203,data="<summary>calls a function on a kernel module</summary>\n# NAME\ncallmodule - calls a function on a kernel module\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**callmodule**(*name*: string, *func*: string, *args...*: any): any...\n\n# DESCRIPTION\nCalls a function on a kernel module, if the module exposes an API.\n\n# PARAMETERS\n1. `name`: The name of the module to call on\n2. `func`: The name of the function to call\n3. `args...`: Any arguments to pass to the function\n\n# RETURN VALUE\nAny values returned from the function call.\n\n# ERRORS\nThis syscall may throw an error if:\n* The module requested is not loaded.\n* The module does not have an exported API.\n* The module does not have the requested function.\n* The function throws an error.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=827,modified=1757997041947,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["devmethods.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042213,data="<summary>returns a list of methods that can be called on this device</summary>\n# NAME\ndevmethods - returns a list of methods that can be called on this device\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devmethods**(*device*: string): string[]\n\n# DESCRIPTION\nReturns a list of methods that can be called on this device.\n\n# PARAMETERS\n1. `device`: The device path or UUID to look up\n\n# RETURN VALUE\nA list of valid methods that can be called.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=622,modified=1757997042002,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["devlock.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042212,data="<summary>locks the specified device to this process</summary>\n# NAME\ndevlock - locks the specified device to this process\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devlock**(*device*: string, *wait*: boolean = true): boolean\n\n# DESCRIPTION\nLocks the specified device to this process. This prevents any calls to the device from other processes, and will suppress events from being sent to other processes. If the current process already owns the lock, this syscall returns `true` immediately. (It does not act like a recursive mutex in this case - only one unlock is required no matter how many times it's locked.)\n\n# PARAMETERS\n1. `device`: The device path or UUID to operate on\n2. `wait`: `true` to wait for the lock to be released before returning; `false` to return immediately if the lock is already owned by another process\n\n# RETURN VALUE\n`true` if the current process now owns the lock; `false` otherwise.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**devunlock**(2)\n",setuser=false,size=1124,modified=1757997041996,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["netcontrol.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042223,data="<summary>sends a control message to the specified IP address</summary>\n# NAME\nnetcontrol - sends a control message to the specified IP address\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**netcontrol**(*ip*: string, *type*: string, *err*: string?)\n\n# DESCRIPTION\nSends a control message to the specified IP address.\n\n# PARAMETERS\n1. `ip`: The IP address to send to\n2. `type`: The message type to send. See **network**(5) for more information.\n3. `err`: An optional error message to send if necessary.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user is not root.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=725,modified=1757997042056,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["rename.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042226,data="<summary>renames a file or directory from one path to another</summary>\n# NAME\nrename - renames a file or directory from one path to another\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**rename**(*from*: string, *to*: string)\n\n# DESCRIPTION\nRenames (moves) a file or directory from one path to another. The source and destination must be on the same filesystem.\n\n# PARAMETERS\n1. `from`: The file to move.\n2. `to`: The new destination path for the file.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The original file does not exist.\n* The new file already exists.\n* The current user does not have permission to read the original file.\n* The current user does not have permission to write the new file.\n* The current user does not have permission to write the parent directory of the new file.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=947,modified=1757997042079,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["stat.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042230,data="<summary>returns a table with information about a file or directory</summary>\n# NAME\nstat - returns a table with information about a file or directory\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**stat**(*path*: string): StatInfo | **nil**, string\n\n# DESCRIPTION\nReturns a table with information about a file or directory. If the file does not exist, this returns `nil` and an error message.\n\n# PARAMETERS\n1. `path`: The path to the file or directory to inspect.\n\n# RETURN VALUE\nA table with the following contents:\n* `size: number`: The total size of the file in bytes\n* `type: string`: The type of file, which can be `\"file\"`, `\"directory\"`, `\"link\"`, `\"fifo\"`, or `\"special\"`\n* `created: number`: The time the file was created, in milliseconds since the UNIX epoch\n* `modified: number`: The time the file was last modified, in milliseconds since the UNIX epoch\n* `owner: string`: The owner of the file\n* `mountpoint: string`: The path to the mountpoint the file is on\n* `link: string?`: If the file is a link, the path it links to\n* `capacity: number`: The total number of bytes the mount can store\n* `freeSpace: number`: The total number of bytes available on the mount\n* `permissions: table`: The permissions for each user/group\n  * `<string>: table`: The permissions for each user/group who has manual permissions\n    * `read: boolean`: Whether the user can read the file\n    * `write: boolean`: Whether the user can write to the file\n    * `execute: boolean`: Whether the user can execute the file\n* `worldPermissions: table`: The permissions for all other users\n  * `read: boolean`: Whether everyone else can read the file\n  * `write: boolean`: Whether everyone else can write to the file\n  * `execute: boolean`: Whether everyone else can execute the file\n* `setuser: boolean`: Whether executing the file will set the user to the owner\n* `special: table?`: A table that can contain mount-specific data.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=2054,modified=1757997042101,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["loadCraftOSAPI.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042218,data="<summary>loads a CraftOS API or module from the ROM</summary>\n# NAME\nloadCraftOSAPI - loads a CraftOS API or module from the ROM\n\n# SYNOPSIS\n**loadCraftOSAPI**(*apiName*: string): table\n\n# DESCRIPTION\nLoads a CraftOS API or module from the ROM. This can be used to get access to certain functions without having to mount the entire ROM.\n\nThis uses the current process's environment as the parent environment. This means the API will use the process's globals. If the API you need requires certain globals (like `colors`), load these in as globals first.\n\n# PARAMETERS\n1. `apiName`: The name of the API or module to load. If this starts with `cc.`, it loads a module from `rom/modules/main`. Otherwise, it loads an API from `rom/apis`.\n\n# RETURN VALUE\nA table with the loaded API or module.\n\n# ERRORS\nThis syscall may throw an error if:\n* The API name is malformed.\n* The API does not exist.\n* An error occurred while loading the API.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=974,modified=1757997042036,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["combine.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042207,data="<summary>combines a set of path components into a valid path</summary>\n# NAME\ncombine - combines a set of path components into a valid path\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**combine**(*components...*: string): string\n\n# DESCRIPTION\nCombines a set of path components into a valid path.\n\n# PARAMETERS\n1. `components...`: The components in the path\n\n# RETURN VALUE\nThe final path composed of the passed components.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=567,modified=1757997041972,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["mount.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042222,data="<summary>mounts a disk device to a path</summary>\n# NAME\nmount - mounts a disk device to a path\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**mount**(*type*: string, *src*: string, *dest*: string, *options*: table?)\n\n# DESCRIPTION\nMounts a disk device to a path using the specified filesystem and options.\n\n# PARAMETERS\n1. `type`: The filesystem type to use when mounting.\n2. `src`: The source device to mount. This argument's meaning depends on the filesystem type.\n3. `dest`: The directory to mount the new filesystem to.\n4. `options`: A table of options to pass to the filesystem mounter. The available options are specified by each individual filesystem.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The filesystem type does not exist.\n* The source device is invalid for the specified filesystem type.\n* The destination path does not exist.\n* The options passed to the mounter are invalid for the specified filesystem type.\n* The current user does not have permission to access to the source device.\n* The current user does not have permission to write to to the destination path.\n* The mounter ran into an issue while mounting the device.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**mountlist**(2), **unmount**(2)\n",setuser=false,size=1344,modified=1757997042049,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["mkdir.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042221,data="<summary>creates a new directory</summary>\n# NAME\nmkdir - creates a new directory\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**mkdir**(*path*: string)\n\n# DESCRIPTION\nCreates a new directory at a path, creating any parent directories if they don't exist. If the directory already exists, this function does nothing and exits successfully.\n\n# PARAMETERS\n1. `path`: The path of the directory to create.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user does not have permission to write the parent directory of the first directory created.\n* A path component already exists and is a file.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=754,modified=1757997042043,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["arplist.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042202,data="<summary>returns the list of known IP to computer ID mappings</summary>\n# NAME\narplist - returns the list of known IP to computer ID mappings\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**arplist**(*device*: string): {[string] = number}\n\n# DESCRIPTION\nReturns the list of known IP to computer ID mappings for the specified device.\n\n# PARAMETERS\n1. `device`: The path to the modem to query for.\n\n# RETURN VALUE\nA key-value table of mappings from IP addresses to computer IDs.\n\n# ERRORS\nThis syscall may throw an error if:\n* The device is not present.\n* The device is not a valid modem.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**arpset**(2)\n",setuser=false,size=702,modified=1757997041937,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["lockmutex.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042220,data="<summary>locks the specified mutex</summary>\n# NAME\nlockmutex - locks the specified mutex\n\n# LIBRARY\nStandard system library, synchronization module (*libsystem*, `system.sync`)\n\n# SYNOPSIS\n**lockmutex**(*mtx*: mutex)\n\n# DESCRIPTION\nLocks the specified mutex, waiting for the resource to be freed before claiming it.\n\n# PARAMETERS\n1. `mtx`: The mutex to lock.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The mutex is already claimed by the current thread and is not recursive.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**timelockmutex**(2) **trylockmutex**(2), **unlockmutex**(2)\n",setuser=false,size=649,modified=1757997042041,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["loadmodule.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042219,data="<summary>attempts to load a kernel module into memory</summary>\n# NAME\nloadmodule - attempts to load a kernel module into memory\n\n# SYNOPSIS\n**loadmodule**(*path*: string)\n\n# DESCRIPTION\nAttempts to load a kernel module into memory. This syscall requires root.\n\n# PARAMETERS\n1. `path`: The path to the module to load.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The user is not root.\n* The path refers to a directory.\n* The module is either not owned by root or world-writable.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**unloadmodule**(2)\n",setuser=false,size=609,modified=1757997042038,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["list.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042217,data="<summary>returns a list of file names present in a directory</summary>\n# NAME\nlist - returns a list of file names present in a directory\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**list**(*path*: string): string[]\n\n# DESCRIPTION\nReturns a list of file names present in a directory.\n\n# PARAMETERS\n1. `path`: The path to the directory to list.\n\n# RETURN VALUE\nA list of file names. This may or may not be sorted.\n\n# ERRORS\nThis syscall may throw an error if:\n* The path does not exist.\n* The path is not directory.\n* The current user does not have permission to access the directory.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=681,modified=1757997042025,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["chmod.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042205,data="<summary>changes the permissions of a file or directory</summary>\n# NAME\nchmod - changes the permissions of a file or directory\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**chmod**(*path*: string, *user*: string?, *mode*: number|string|table)\n\n# DESCRIPTION\nChanges the permissions (mode) of a file or directory for the specified user. If any setuser bit is specified, this will be applied for all users.\n\n# PARAMETERS\n1. `path`: The path to the file to modify.\n2. `user`: The user to set the permissions for. If this is `nil`, sets the permissions for all users.\n3. `mode`: A value representing the permissions. This may be:\n  * A UNIX-style octal mode (e.g. `5`) - setuid bit is bit 4 (010)\n  * A UNIX-style mode modification string, without the user specifier (e.g. `\"+rx\"`) (this does not work with `\"-wx\"` - use `\"-xw\"` instead)\n  * A 3-character string with \"r\", \"w\", and \"x\" or \"s\" (or \"-\") (e.g. `\"r-s\"`)\n  * A table with `read: boolean?`, `write: boolean?`, `execute: boolean?`, and `setuser: boolean?` fields (if a field is `nil`, it uses the previous value)\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The file does not exist.\n* The current user is not the owner of the file or root.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**chown**(2)\n",setuser=false,size=1377,modified=1757997041962,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["devlisten.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042211,data="<summary>enables listening for events from this device</summary>\n# NAME\ndevlisten - enables listening for events from this device\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devlisten**(*device*: string, *state*: boolean = true)\n\n# DESCRIPTION\nEnables (or disables) listening for events from this device.\n\n# PARAMETERS\n1. `device`: The device path or UUID to operate on\n2. `state`: `true` to allow events to be passed to this process; `false` to stop events from being sent\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=709,modified=1757997041994,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["kernargs.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042215,data="<summary>returns the arguments passed to the kernel</summary>\n# NAME\nkernargs - Returns the arguments passed to the kernel\n\n# SYNOPSIS\n**kernargs**(): table\n\n# DESCRIPTION\nReturns the arguments passed to the kernel in a key-value table.\n\n# PARAMETERS\nThis syscall does not take any arguments.\n\n# RETURN VALUE\nA key-value table of all arguments passed to the kernel.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.4.\n",setuser=false,size=456,modified=1757997042017,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["queueEvent.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042225,data="<summary>queues an arbitrary event to be sent back to the current process</summary>\n# NAME\nqueueEvent - queues an arbitrary event to be sent back to the current process\n\n# LIBRARY\nStandard system library, IPC module (*libsystem*, `system.ipc`)\n\n# SYNOPSIS\n**queueEvent**(*name*: string, *params*: table)\n\n# DESCRIPTION\nQueues an arbitrary event to be sent back to the current process.\n\n# PARAMETERS\n1. `name`: The name of the event to send.\n2. `params`: The parameter list to send in the event.\n\n# RETURN VALUES\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=637,modified=1757997042066,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["kill.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042216,data="<summary>sends a signal to another process</summary>\n# NAME\nkill - sends a signal to another process\n\n# LIBRARY\nStandard system library, IPC module (*libsystem*, `system.ipc`)\n\n# SYNOPSIS\n**kill**(*pid*: number, *signal*: number)\n\n# DESCRIPTION\nSends a signal to another process. The signal may be any numerical value, though the system will only respond to certain values.\n\n# PARAMETERS\n1. `pid`: The ID of the process to send to\n2. `signal`: The signal ID to send\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The target process ID does not exist.\n* The current user does not have permission to send a signal to the target.\n  * The target process must be under the same user as the current one.\n  * If the current process is running as root, it may send a signal to any process.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**signal**(2)\n",setuser=false,size=904,modified=1757997042019,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["unlisten.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042233,data="<summary>stops listening on a URI previously passed to listen</summary>\n# NAME\nunlisten - stops listening on a URI previously passed to listen\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**unlisten**(*uri*: string)\n\n# DESCRIPTION\nStops listening on a URI previously passed to `listen`. This does not close any handles that are in use.\n\n# PARAMETERS\n1. `uri`: The URI to listen on. The path portion is ignored.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The computer is not listening on the specified URI.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**listen**(2)\n",setuser=false,size=682,modified=1757997042119,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["mountlist.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042223,data="<summary>returns a list of mounts on the system</summary>\n# NAME\nmountlist - returns a list of mounts on the system\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**mountlist**(): [{*path*: string, *type*: string, *source*: string, *options*: table}]\n\n# DESCRIPTION\nReturns a list of mounts on the system.\n\n# PARAMETERS\nThis syscall does not take any arguments.\n\n# RETURN VALUE\nA list of tables containing the mount path, the filesystem type, the source path, and any options stored in the mount.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**mount**(2)\n",setuser=false,size=666,modified=1757997042053,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["connect.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042207,data="<summary>creates a connection to a remote resource</summary>\n# NAME\nconnect - creates a connection to a remote resource\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**connect**(*options*: table|string): Handle?\n\n# DESCRIPTION\nCreates a connection to a remote resource using the specified options table or URI.\n\n# PARAMETERS\n1. `options`: Either a string with a URI (no options), or a table with any of the following elements:\n  * `url: string`: The URI to connect to (required)\n  * `encoding: \"utf8\" | \"utf-8\" | \"binary\"`: HTTP/WS: Encoding to use when transferring data (defaults to `\"binary\"`)\n  * `headers: {[string] = string}`: HTTP/WS: Any headers to send in the request\n  * `method: string`: HTTP: The method to use when connecting (defaults to `\"GET\"`)\n  * `redirect: boolean`: HTTP: Whether to automatically redirect responses that indicate a redirect (defaults to `true`)\n  * `device: string`: Rednet/PSP: The path to the device to use to establish the connection (usually a modem), or `nil` to use all modems (note: if this path points to multiple devices, all are used)\n\n# RETURN VALUE\nA handle object that can be used to send/receive data, or `nil` + an error if the handle could not be created. The handle is not guaranteed to be ready to send/receive data immediately, however, so the `status` method should be checked before using.\n\n# ERRORS\nThis syscall may throw an error if:\n* The URI specified is malformed.\n* The scheme in the URI is not supported.\n* The device is not present.\n* The device is not a valid modem.\n\n# NOTES\nThe **connect** syscall returns a handle object for the specific protocol that was requested. These handles all contain a common set of methods, as well as some special methods that are specific to each protocol.\n\nAll handles have an `id` field, which is a number that uniquely identifies the connection. This ID is used in `handle_status_change` events to indicate which handle has changed status.\n\n`status(): \"ready\"|\"connecting\"|\"error\"|\"open\"|\"closed\", string?`  \nReturns the current status of the handle/connection.\n\n*Arguments*  \nThis method does not take any arguments.\n\n*Return Values*  \nThe current status of the handle/connection. These are the currently assigned statuses:\n* `ready`: Indicates the handle is ready to send data, but a connection has not yet been established.\n* `connecting`: Indicates the handle sent a connection request, and is currently awaiting a response. The handle is not ready to send or receive data.\n* `error`: Indicates an error has occurred while connecting to the server, and no data has been sent or received. This handle may no longer be used. More information may be supplied in a second return value.\n* `open`: Indicates the connection has been established, and data can be received (and possibly sent).\n* `closed`: Indicates the connection has been closed, and no data may be sent or received. This handle may no longer be used.\n\n*Errors*  \nThis method does not throw any errors.\n\n`read(mode...: string|number): string|number|nil...`  \nRead one or more values from the connection in a manner similar to `io.file:read`.\n\n*Arguments*  \n1. `mode...`: The read mode to use. This may be one of the following options:\n  * `*a`: Read all data available in the connection.\n  * `*l`: Read a line, excluding the final newline.\n  * `*L`: Read a line, including the final newline.\n  * `*n`: Read a number value if available.\n  * (any number): Read the specified number of characters/bytes.\n  If no arguments are specified, this defaults to `read(\"*l\")`.\n\n*Return Values*  \nThe values extracted from the connection. If one of the modes could not be read, the value returned for that parameter and all ones after are `nil`.\n\n*Errors*  \nThis method may throw an error if:\n* The handle is not currently open.\n\n`write(data...: any)`  \nWrites the supplied values to the connection.\n\n*Arguments*  \n1. `data...`: The values to write. Values that are not strings will be converted with `tostring`, unless otherwise specified by the handle type.\n\n*Return Values*  \nThis method does not return anything.\n\n*Errors*  \nThis method may throw an error if:\n* The handle is not currently open or ready.\n\n`close()`  \nCloses the connection.\n\n*Arguments*  \nThis method does not take any arguments.\n\n*Return Values*  \nThis method does not return anything.\n\n*Errors*  \nThis method may throw an error if:\n* The connection is not currently open.\n\n## HTTP handles\nHTTP\\[S\\] handles have a special flow to work properly. Upon creating the handle, it will be set in the `ready` state, and no request is sent yet. The request is only sent once the `write` method is called once. After that, the `write` method will no longer function, so make sure to add all data in the request in that `write` call. Even if no data needs to be sent (e.g. `GET` method), `write` must be called exactly once, even if it's with no data.\n\nAfter calling `write`, the handle will shift into `connecting` status, awaiting a response from the server. The client must wait for `status` to change to `open` before attempting to read data. After that, the handle functions like a normal read-only handle.\n\nHTTP handles have the following additional methods:\n\n`responseHeaders(): {[string]: string}`  \nReturns the headers contained in the response.\n\n*Arguments*  \nThis method does not take any arguments.\n\n*Return Values*  \nA key-value table of headers sent back from the server.\n\n*Errors*  \nThis method may throw an error if:\n* The connection is not currently open.\n\n`responseCode(): number`  \nReturns the HTTP response code returned from the server.\n\n*Arguments*  \nThis method does not take any arguments.\n\n*Return Values*  \nThe response code sent from the server.\n\n*Errors*  \nThis method may throw an error if:\n* The connection is not currently open.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=5863,modified=1757997041974,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["arpset.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042202,data="<summary>sets the computer ID mapping for the specified IP</summary>\n# NAME\narpset - sets the computer ID mapping for the specified IP\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**arpset**(*device*: string, *ip*: string, *id*: number?)\n\n# DESCRIPTION\nSets the computer ID mapping for the specified IP on the requested device.\n\n# PARAMETERS\n1. `device`: The path to the modem to add for.\n2. `ip`: The IP address of the target computer.\n3. `id`: The computer ID of the target computer, or `nil` to remove the entry.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user is not root.\n* The device is not present.\n* The device is not a valid modem.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**arplist**(2)\n",setuser=false,size=830,modified=1757997041941,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["detach.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042208,data="<summary>detaches a peripheral from a side</summary>\n# NAME\ndetach - detaches a peripheral from a side\n\n# SYNOPSIS\n**detach**(*side*: string|number): boolean, string?\n\n# DESCRIPTION\nIf using an emulator, detaches a peripheral from a side. This syscall requires root.\n\n# PARAMETERS\n1. `side`: The side or ID to detach\n\n# RETURN VALUE\n1. Whether the detachment succeeded\n2. If it failed, an optional error message (this may be `nil`!)\n\n# ERRORS\nThis syscall may throw an error if:\n* The user is not root.\n\n# HISTORY\nIntroduced in Phoenix 0.0.2.\n\n# SEE ALSO\n**attach**(2)\n",setuser=false,size=569,modified=1757997041977,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["attach.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042203,data="<summary>attaches a peripheral of the specified type to the computer</summary>\n# NAME\nattach - attaches a peripheral of the specified type to the computer\n\n# SYNOPSIS\n**attach**(*side*: string|number, *type*: string, *args...*: any): boolean, string?\n\n# DESCRIPTION\nIf using an emulator, attaches a peripheral of the specified type to the computer. This syscall requires root.\n\n# PARAMETERS\n1. `side`: The side to attach to, or an ID to attach as\n2. `type`: The type of peripheral to attach. The peripherals use standard CC/CraftOS-PC naming.\n3. `args...`: Any arguments to pass to the peripheral constructor\n\n# RETURN VALUE\n1. Whether the attachment succeeded\n2. If it failed, an optional error message (this may be `nil`!)\n\n# ERRORS\nThis syscall may throw an error if:\n* The user is not root.\n\n# HISTORY\nIntroduced in Phoenix 0.0.2.\n\n# SEE ALSO\n**detach**(2)\n",setuser=false,size=861,modified=1757997041944,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["devcall.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042209,data="<summary>calls the specified method on the device</summary>\n# NAME\ndevcall - calls the specified method on the device\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devcall**(*device*: string, *method*: string, *args...*: any): any...\n\n# DESCRIPTION\nCalls the specified method on the device with arguments.\n\n# PARAMETERS\n1. `device`: The device path or UUID to operate on\n2. `method`: The name of the method to call\n3. `args...`: Any arguments to pass to the method\n\n# RETURN VALUE\nAll values returned from the method.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n* Another process has locked this device.\n* The specified method does not exist on the device.\n* The method threw an error while executing.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=836,modified=1757997041982,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["chown.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042206,data="<summary>changes the owner of a file or directory</summary>\n# NAME\nchown - changes the owner of a file or directory\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**chown**(*path*: string, *user*: string)\n\n# DESCRIPTION\nChanges the owner of a file or directory, clearing the `setuser` bit if it's set.\n\n# PARAMETERS\n1. `path`: The path to the file to modify.\n2. `user`: The user who will own the file.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The file does not exist.\n* The current user is not the owner of the file or root.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**chmod**(2)\n",setuser=false,size=706,modified=1757997041965,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["acquiresemaphore.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042201,data="<summary>acquires a resource from a semaphore object</summary>\n# NAME\nacquiresemaphore - acquires a resource from a semaphore object\n\n# LIBRARY\nStandard system library, synchronization module (*libsystem*, `system.sync`)\n\n# SYNOPSIS\n**acquiresemaphore**(*sem*: semaphore)\n\n# DESCRIPTION\nAcquires a resource from a semaphore object, waiting if none are available.\n\n# PARAMETERS\n1. `sem`: The semaphore to acquire.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**timeacquiresemaphore**(2), **releasesemaphore**(2)\n",setuser=false,size=623,modified=1757997041931,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["devlookup.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042212,data="<summary>returns all paths to devices that have the specified node name</summary>\n# NAME\ndevlookup - returns all paths to devices that have the specified node name\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devlookup**(*name*: string): string...\n\n# DESCRIPTION\nReturns all paths to devices that have the specified node name. If a path or UUID is specified, returns the path of the singular device node.\n\n# PARAMETERS\n1. `name`: The device name to search for\n\n# RETURN VALUE\nThe path to each node in the device tree that has the specified name.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**devfind**(2)\n",setuser=false,size=717,modified=1757997041999,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["alarm.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042201,data="<summary>sets an alarm</summary>\n# NAME\nalarm - sets an alarm\n\n# LIBRARY\nStandard system library, utility module (*libsystem*, `system.util`)\n\n# SYNOPSIS\n**alarm**(*timeout*: number): number\n\n# DESCRIPTION\nSets an alarm that will send an `alarm` event at the specified time.\n\n# PARAMETERS\n1. `timeout`: The time to set the alarm to.\n\n# RETURN VALUE\nThe ID of the new alarm created.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**cancel**(2), **timer**(2)\n",setuser=false,size=508,modified=1757997041934,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["open.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042224,data="<summary>opens a file for reading or writing</summary>\n# NAME\nopen - opens a file for reading or writing\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**open**(*path*: string, *mode*: string): file\n\n# DESCRIPTION\nOpens a file for reading or writing.\n\n# PARAMETERS\n1. `path`: The path to the file to open. This may be a relative path to the current working directory, or an absolute path relative to the root.\n2. `mode`: The mode to open the file in. This may be `r`, `w`, or `a`, with an additional `b` at the end to open in binary mode.\n\n# RETURN VALUE\nA file handle object.\n\n# ERRORS\nThis syscall may throw an error if:\n* The mode argument is invalid.\n* The file was opened in read mode and it does not exist.\n* The parent directory of the file does not exist.\n* The file is a directory.\n* The current user does not have permission to access the file.\n* If creating a new file and the current user does not have permission to write the parent directory.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=1051,modified=1757997042063,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["_template.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042200,data="<summary></summary>\n# NAME\n - \n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n\n\n# DESCRIPTION\n\n\n# PARAMETERS\n\n\n# RETURN VALUE\n\n\n# ERRORS\n\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n\n",setuser=false,size=239,modified=1757997041927,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["devproperties.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042213,data="<summary>returns a list of properties on the device</summary>\n# NAME\ndevproperties - returns a list of properties on the device\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devproperties**(*device*: string): string[]\n\n# DESCRIPTION\nReturns a list of properties on the device.\n\nProperties are intended for use by wrapper APIs (such as `libsystem.hardware`), and specify an alternate name for a corresponding `get<Property>` method. To retrieve the property, capitalize the first character of the property name, prepend `get` to the name, and call that method on the device with no arguments. To set the property, first check for a `set<Property>` method in the same format as `get`, then call that method with one argument (the new value). If no `set` method is available, then that property is read-only.\n\n# PARAMETERS\n1. `device`: The device path or UUID to look up\n\n# RETURN VALUE\nA list of properties that are available. This table may be empty.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",setuser=false,size=1128,modified=1757997042005,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997042237,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},man7={permissions={root={write=true,read=true,execute=true}},created=1757997043424,contents={["fuse.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997040698,data="<summary>filesystem in userspace kernel module</summary>\n# NAME\nfuse - filesystem in userspace kernel module\n\n# DESCRIPTION\n**fuse** is a kernel module that implements an interface for filesystems written\nin userspace. This allows user programs to create and mount filesystem types\nwithout needing to load a kernel module. Filesystem operations are executed in a\nuser-mode process, with the results being sent back to the process that requested\nthe operation.\n\n# USAGE\nTo mount a **fuse**-based filesystem, simply use the **mount**(1) command with\nthe filesystem type **fuse**, and pass the filesystem to mount in the **fs**\noption. For example, an FTP filesystem could be mounted with the following command:\n\n```sh\nmount -t fuse -o fs=ftp,pasv ftp://user:password@10.0.1.1 /mnt/ftpshare\n```\n\nThis will mount the `ftp` filesystem (from `/lib/fuse/ftp.lua`) to `/mnt/ftpshare`,\nusing the mount source `ftp://user:password@10.0.1.1` and passing the `pasv`\noption to the filesystem.\n\nFilesystem modules are located in `/lib/fuse` by default. Filesystems located in\nother locations may be loaded by passing the path as the `fs` option.\n\n# WRITING FILESYSTEMS\nA **fuse** filesystem is simply a Lua library which returns a table with the\nrequired filesystem methods. The library is run with two parameters: the path to\nthe filesystem to mount, and a key-value table with the mount options. It is run\nin a thread under the process that called **mount**(2) (usually **mount**(1)).\n\nEach method in the filesystem is called with at least two arguments: the table\nreturned (as in `:` methods), and a process table filled from **getpinfo**(2).\nMost methods also have at least one path argument as a string. There is no need\nto do argument type checking: this is done in the kernel before calling the\nfilesystem methods.\n\nThe following methods are expected to be exported by the filesystem:\n\n```ts\ninterface Filesystem {\n    open(self: table, process: ProcessInfo, path: string, mode: string): table | string | ((data: string, reset: boolean): void);\n    list(self: table, process: ProcessInfo, path: string): string[];\n    stat(self: table, process: ProcessInfo, path: string, nolink?: boolean): Stat?;\n    remove(self: table, process: ProcessInfo, path: string): void;\n    rename(self: table, process: ProcessInfo, path: string, to: string): void;\n    mkdir(self: table, process: ProcessInfo, path: string): void;\n    link(self: table, process: ProcessInfo, path: string, location: string): void;\n    mkfifo(self: table, process: ProcessInfo, path: string): void;\n    chmod(self: table, process: ProcessInfo, path: string, user: string | nil, mode: string | number | table): void;\n    chown(self: table, process: ProcessInfo, path: string, owner: string): void;\n    unmount?(self: table, process: ProcessInfo): void;\n    init?(self: table, process: ProcessInfo): void;\n}\n```\n\nAll functions are optional, but calls on unimplemented functions will throw an\nerror to the caller. A minimal filesystem should implement at least `open`,\n`list`, and `stat`. The `unmount` method is called when the filesystem is about\nto be unmounted, and can be used to clean up resources before unmounting. If it\nis not present, no error is emitted, and the filesystem is removed as usual. The\n`init` method is called right after the filesystem is mounted, and can be used\nto initialize certain things that have to run on the client process.\n\nMost methods function the same as their respective syscalls. However, the `open`\nmethod has extra functionality: if it returns a string, then a read file handle\nwill be synthesized automatically (with a second boolean return value indicating\nwhether it should be binary). Likewise, if it returns a function, it'll return\na write file handle which will call the function to flush data to the file. This\ncan be used to simplify basic file open operations, reducing code duplication in\nthe process.\n\nEach mounted filesystem is given its own process to run as, which is forked from\nthe initial mount process, and is disconnected from TTYs. Methods are called in\nnew threads under that process. When the filesystem is unmounted, the main\nthread exits, which will cause the process to exit once the last remaining\nfilesystem method returns.\n\n# EXAMPLES\nHere is an example of a minimal filesystem:\n\n```lua\nlocal fs = {}\n\nfunction fs:open(process, path, mode)\n    if path == \"\" then return nil, \"Is a directory\"\n    elseif path == \"zero\" then\n        if mode:find \"[wa]\" then\n            return {\n                close = function() end,\n                seek = function() end,\n                write = function() end,\n                writeLine = function() end,\n                flush = function() end\n            }\n        end\n        return {\n            close = function() end,\n            seek = function() end,\n            read = function(n)\n                if not n then return 0\n                else return (\"\\0\"):rep(n) end\n            end,\n            readLine = function() return \"\" end,\n            readAll = function() return \"\" end\n        }\n    elseif path == \"random\" then\n        if mode:find \"[wa]\" then\n            return {\n                close = function() end,\n                seek = function() end,\n                write = function() end,\n                writeLine = function() end,\n                flush = function() end\n            }\n        end\n        return {\n            close = function() end,\n            seek = function() end,\n            read = function(n)\n                if not n then return math.random(0, 255)\n                else\n                    local s = \"\"\n                    for i = 1, n do s = s .. string.char(math.random(0, 255)) end\n                    return s\n                end\n            end,\n            readLine = function() return \"\" end,\n            readAll = function() return \"\" end\n        }\n    else return nil, \"No such file\" end\nend\n\nfunction fs:list(process, path)\n    if path == \"\" then\n        return {\"zero\", \"random\"}\n    else\n        error(\"No such directory\")\n    end\nend\n\nfunction fs:stat(process, path)\n    if path == \"zero\" then\n        return {\n            size = 0,\n            type = \"file\",\n            created = 0,\n            modified = 0,\n            owner = \"root\",\n            permissions = {},\n            worldPermissions = {read = true, write = false, execute = false},\n            setuser = false,\n            capacity = 0,\n            freeSpace = 0,\n            special = {}\n        }\n    elseif path == \"random\" then\n        return {\n            size = 0,\n            type = \"file\",\n            created = 0,\n            modified = 0,\n            owner = \"root\",\n            permissions = {},\n            worldPermissions = {read = true, write = false, execute = false},\n            setuser = false,\n            capacity = 0,\n            freeSpace = 0,\n            special = {}\n        }\n    elseif path == \"\" then\n        return {\n            size = 0,\n            type = \"directory\",\n            created = 0,\n            modified = 0,\n            owner = \"root\",\n            permissions = {},\n            worldPermissions = {read = true, write = false, execute = true},\n            setuser = false,\n            capacity = 0,\n            freeSpace = 0,\n            special = {}\n        }\n    else return nil end\nend\n\nreturn fs\n```\n\n# SEE ALSO\n**mount**(1)\n\n# AUTHORS\n**fuse** was written by JackMacWindows, based on the concepts of FUSE/libfuse\nfor *nix.\n",setuser=false,size=7444,modified=1757997040693,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["githubfs.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997040759,data="<summary>GitHub read-only FUSE filesystem</summary>\n# NAME\ngithubfs - GitHub read-only FUSE filesystem\n\n# DESCRIPTION\n**githubfs** is a FUSE filesystem that allows mounting GitHub repositories to\nthe local filesystem. It allows read-only access to public repositories, as well\nas private repositories with a personal access key.\n\n# USAGE\nSimply mount the repo URL using a **fuse**(7) mount:\n\n```sh\nmount -t fuse -o fs=githubfs https://github.com/username/repo /mnt/path\n```\n\nThe URL must be in the form `http[s]://github.com/<username>/<repo>[/|.git]`.\n\nThe following extra options are available:\n- **token**: The PAK to use for authorization, if desired. This is required for\n  private repositories.\n- **branch**: The branch to access (defaults to the repo's default branch).\n\n# SEE ALSO\n**mount**(1), **fuse**(7)\n\n# AUTHORS\n**githubfs** was written by JackMacWindows for Phoenix.\n",setuser=false,size=882,modified=1757997040754,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["yellowbox.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997043424,data="<summary>kernel level CraftOS virtualization</summary>\n# NAME\nYellowBox - kernel level CraftOS virtualization\n\n# DESCRIPTION\n**yellowbox** is a kernel module which implements a ComputerCraft virtual machine for running CraftOS programs on Phoenix. It acts as a more robust alternative to **libcraftos**, which is a simple translation layer from CraftOS APIs to Phoenix syscalls - instead, it runs a full CraftOS machine, which avoids the quirks that come from call translation.\n\nYellowBox operates on constructs known as *boxes*. A box holds an entire CraftOS runtime, and is represented by a numerical ID (which corresponds to the user process for the box). Boxes have a main coroutine, a TTY, and a process associated with them, among other things. The TTY holds the contents of the computer's terminal, which can be read to display the screen elsewhere. The box's process represents the box in userspace, and it sends events coming from Phoenix programs into the machine, as well as triggering the machine to continue running.\n\nTo ensure compatibility with CraftOS programs, YellowBox runs as a kernel service, which avoids issues caused by yielding for preemption or system calls. The ComputerCraft APIs directly call the respective underlying kernel routines, which means that no yielding is required (though some filesystems which yield internally may cause spurious yields - this is mitigated through some hacks). This also means that Phoenix programs will not run while the box is running - avoid running heavy programs inside the box.\n\nWhile YellowBox runs directly in the kernel instead of userspace, the APIs exposed still call out to Phoenix syscalls and functions. The box has an associated root directory and user, and filesystem calls go through the Phoenix VFS layer, allowing permissions and mounts to be used from CraftOS. \n\n# INTERFACING WITH BOXES\nThe **yellowbox** kernel module exposes a module API (i.e. the `callmodule` syscall) which allows programs to interact with boxes. To create a box, call the **create** method, which takes a single table argument with options for the box, and returns the ID of the box. Creating a box requires root privileges, as boxes run at a higher privilege level. The options available include:\n- *bios*: The contents of the BIOS program to use (required)\n- *root*: The root directory for the box\n- *user*: The user to run as\n- *peripherals*: A key-value mapping of peripherals to expose to the machine (key is CraftOS name, value is Phoenix hardware node path/UUID)\n- *http*: A boolean specifying whether to expose the `http` API\n\nThe box will start executing directly after calling this method. To access the TTY with the box's terminal contents, call the **getTTY** method with the ID of the box. This will return a TTY object like `mktty` does. It will also assign the calling process to the TTY, meaning that it will get `tty_redraw` events when the box writes to the screen. Note that the box only uses the exclusive-text-mode buffer (`tty.textBuffer`), so the main buffer will always be empty.\n\nEvents that are requested by CraftOS APIs, as well as peripheral events for devices that are forwarded, will be sent to the machine automatically. However, user-interactive events like `key` aren't handled by YellowBox itself. To send events to the box, including user-interactive events, send a remote event to the userspace program (whose PID is the box ID). The remote event name should be the event to queue, and the parameter should be a list of parameters for the event, with an optional `n` field for the number of parameters. The event will be queued into the box with no modification. Because of this, for `key` events, make sure to convert the key ID to a proper CraftOS key code. The included library contains a routine to convert Phoenix keycodes into CraftOS keycodes using a `keys` API loaded from the CraftOS ROM.\n\nThe box can be restarted or shut down using the `reboot` and `shutdown` methods, respectively. The box can also be stopped entirely by calling the `stop` method, which requires root privileges.\n\n# SEE ALSO\n**yellowbox**(1)",setuser=false,size=4110,modified=1757997043415,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["spanfs.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042638,data="<summary>RAID-like spanning filesystem across disk peripherals</summary>\n# NAME\nspanfs - RAID-like spanning filesystem across disk peripherals\n\n# DESCRIPTION\nspanfs is a kernel module that implements a spanning filesystem layer across a\nnumber of disk peripherals. It concatenates the contents of the disks together\ninto a single drive, which can store large files across multiple disks.\n\nspanfs stores file information using a single index disk, which holds the\nentire filesystem structure, plus up to 65535 of disks to store file\ncontents. Each disk has a file called \".spanfs\", which contains three lines:\nthe user-friendly name of the filesystem, a UUID identifying it, and the ID\nof the disk in the array. The ID is used to identify the disk's position in\nthe array regardless of mountpoint.\n\nDisk ID 0 is the index disk. This disk contains only one file called \"index\"\nwhich is a binary file that stores the entire filesystem tree, including\nfile names, metadata, and directory contents. A directory entry consists of\nthe following data (all integers are little-endian):\n\n| Format | Size | Description       |\n|--------|------|-------------------|\n| `I`    | 4    | Directory entry length (excluding contents) |\n| `I`    | 4    | File size         |\n| `I8`   | 8    | Creation date     |\n| `I8`   | 8    | Modification date |\n| `B`    | 1    | Type (using TAR file types) |\n| `B`    | 1    | Bits 0-2: world permissions, bit 7: set user |\n| `s2`   | 2+x  | File name         |\n| `s2`   | 2+x  | Owner name        |\n| `B`    | 1    | Number of permission entries |\n| `s2B`* | (3+x)*y | List of permissions - each entry is a name followed by a 3-bit mode |\n\nThe index file consists of one directory entry for the root of the\nfilesystem, which is always of type \"directory\".\n\nIf the entry points to a file, it is followed by a 16-byte string containing\nthe UUID of the file data, then a 2-byte integer indicating the number of\ndisks the file is split across, and then a list of 2-byte integers holding\nthe IDs of the disks which hold the data, in sequence, and finally a CRC-32\nchecksum of the file (4 bytes).\n\nIf the entry is a directory, it is followed by a 4-byte integer with the\nnumber of files in the directory, followed by each entry in sequence. If the\nentry is a link, it is followed by a 2-byte length string with the path that\nthe link points to. If the entry is a FIFO there is no data after the entry.\n\nNote that the entry length does not include the length of the contents -\nthis is to allow the format to be extended for more metadata in the future.\nSkip over the entire entry length to get to the contents - do not rely on\nthe contents being at the end of the above table! The order of the above\nfields will not change in the future - fields will only be added at the end.\n\nFile data is stored by a random UUID assigned to the file. Each part of a\nfile is distributed across independent chunks on each disk, with each chunk\nnamed with the file's UUID. The file can be reconstructed by concatenating\nthe contents of each chunk in the order specified in the ID list in the file\nentry.\n\nThe default allocation algorithm will first attempt to store the entire file\non a single disk, finding the disk with the least amount of free space that\ncan still fit the whole file. If there are no disks that can store the\nentire file, then the file will be split across as few disks as possible,\nusing the disks with the largest free space in order. If two disks have the\nsame amount of free space, the disk with the lowest ID is preferred.\n\n# CONFIGURATION\n**spanfs** can be installed by dropping the `spanfs.lua` kernel module into\n`/lib/modules`. Ensure the file is not world-writable, and is executable by root.\n\nUse the **mkspanfs**(8) program to create new spanfs volumes across disks.\n\n# SEE ALSO\n**mkspanfs**(8), **spaninfo**(8)",setuser=false,size=3841,modified=1757997042617,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997043424,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},man6={permissions={root={write=true,read=true,execute=true}},created=1757997043302,contents={["yahtcc.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997043302,data="<summary>Yahtzee clone for Phoenix</summary>\n# NAME\n    yahtcc - Yahtzee clone for Phoenix\n\n# SYNOPSIS\n    **yahtcc**\n\n# DESCRIPTION\n**yahtcc** is a clone of the popular dice game \"Yahtzee\". Players roll a set of\nfive dice up to three times per round, trying to get the dice to roll in\ncertain patterns. Each pattern grants a number of points, and the goal of the\ngame is to achieve the highest number of points.\n\nThe main screen shows a scorecard with the available categories and the number\nof points already scored or available to score. Locked scores are colored white,\npossible scores are colored blue, and possible scores worth 0 points are colored\ngray. Below that, the current set of dice is displayed. Locked dice are colored\nyellow, while unlocked dice are colored white. The roll cup shows whether\nanother roll is available. The current total score and number of available rolls\nis displayed above the scorecard.\n\nTo roll the dice, press the **R** key or click on the roll cup. The unlocked\ndice will be rolled fresh, leaving the locked dice in-place. Dice may then be\nlocked or unlocked by pressing the **1**-**5** keys, or by clicking on any of\nthe dice. To lock a score, use the arrow keys to select the category to score,\nand press **Enter** to score it. Alternatively, double-click on any of the\nunscored categories.\n\n# GAMEPLAY\nA game of **yahtcc** consists of 13 rounds, with each round having three dice\nrolls, and ends when the player selects a pattern to score the current set of\ndice on. Between rolls, the player may lock any of the five dice, which will\nprevent them from being changed in the next roll. The player may score during\nany roll, but they must score after the third roll. Once a pattern is scored, it\ncannot be changed later.\n\nSix of the patterns are scored based on the number of dice in the set that match\nthe number for the score. The score is calculated by summing the values of those\ndice. For example, the *Threes* pattern will sum the value of all of the dice\nwith a value of 3.\n\nSix of the patterns are all-or-nothing based on whether the set of dice contains\ndice matching a pattern. If the pattern matches, the category gets the full score; otherwise, it is worth 0 points. The patterns in this category are scored as follows:\n\n- *Three of a Kind*: Matches when any three dice have the same value. Worth\nthe sum of all dice in the set.\n- *Four of a Kind*: Matches when any four dive have the same value. Worth\nthe sum of all dice in the set.\n- *Full House*: Matches when three dice have the same value, and two differently-valued dice are equal. Worth 25 points.\n- *Small Straight*: Matches when four dice have sequential values (i.e. 1-2-3-4,\n2-3-4-5, 3-4-5-6). Worth 30 points.\n- *Large Straight*: Matches when five dice have sequential values (i.e.\n1-2-3-4-5, 2-3-4-5-6). Worth 40 points.\n- *Yahtzee*: Matches when all five dice have the same value. Worth 50 points.\n\nThe last pattern, *Chance*, is a wildcard pattern that is always worth points.\nIts value is equal to the sum of the values of all dice.\n\nTwo bonuses can be triggered during the game. The *Bonus* score on the left is\nactivated when the sum of all of the numbered scores is greater than or equal to\n63, which corresponds to at least 3 dice in each category. When activated, it is\nworth 35 points. The *Yahtzee Bonus* score on the right is automatically\nactivated when all five dice rolled have the same value and the *Yahtzee*\ncategory has been scored with 50 points. It is worth 100 points.\n\nOnce all 13 categories have been scored, the game ends, and the final score is\nsimply the sum of all points awarded in each category. The final score is\nprinted to the console after the game ends.\n\n# AUTHORS\nYahtCC was written by JackMacWindows in 2020, and ported to Phoenix in 2022. It is licensed under the GPL license.\n\n*Yahtzee* is a registered trademark of Hasbro, Inc.\n",setuser=false,size=3884,modified=1757997043297,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997043302,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},man5={permissions={root={write=true,read=true,execute=true}},created=1757997043171,contents={["passwd.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997043170,data="",setuser=false,size=0,modified=1757997043138,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["ftpmgr.conf.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997040619,data="<summary>configuration file for ftpmgr</summary>\n\n# NAME\n    **ftpmgr.conf** - configuration file for ftpmgr\n\n# SYNOPSIS\n    /etc/ftpmgr.conf\n\n# DESCRIPTION\nThe /etc/ftpmgr.conf file configures settings for the **ftpmgr(8)** FTP server.\n\nThe file uses a code-like syntax, with comments using `#`. Options are set using *key* **=** *value* **;** syntax, and users are defined using **user \"** *name* **\" {** *options* **}**. Strings may be delimited with **\"** or **'**. `#` characters in strings are not recommended, as they may be mistaken for comments while parsing.\n\n# GLOBAL OPTIONS\n* **ip =** *string*: The IP address to serve on. \"0.0.0.0\" indicates any IP/interface.\n* **port =** *number*: The port to serve the command stream on. FTP standard is 21.\n* **passivePortRange = {** *number* **,** *number* **}**: The range of ports to reserve for passive connections.\n* **allUsers =** *boolean*: Whether to allow all users on the system to log in. These users will use their system username and password for login, and have access to the full system root with their permissions. This requires **usermgr(8)** to be installed.\n\n# USER OPTIONS\nThere are three methods of authentication available:\n* No authentication: No password is required for the user. This is used when `useSystemLogin` is false, and no password or hash is set.\n* Password authentication: A password for the user is supplied in the config file. This is used when `password` or `passwordHash` is set for a user.\n* System authentication: The user's password is stored in the system database (i.e. **passwd(5)**), and authentication is done through **usermgr(8)**, which must be installed. This is used when `useSystemLogin` is true (default) and no `password` is set.\n\nA user named `anonymous` is used when no username or password is entered. It is disabled by default for security, but can be configured to provide, for example, public read-only access to a certain folder on the system.\n\nThe following options may be configured in each user directive:\n* **systemUser =** *string*: The Phoenix username to run the server as. Defaults to the name of the FTP user.\n* **password =** *string*: The password for the user in plaintext.\n* **passwordHash =** *string*: The hex SHA-256 hash of the password + hash.\n* **useSystemLogin =** *boolean*: Whether to use system credentials for the user (requires **usermgr(8)**). Defaults to true. Overridden by `password` and `passwordHash`.\n* **allowWrite =** *boolean*: Whether to allow writing files, irrespective of the system user's permissions. Defaults to true.\n* **root =** *string*: The root of the filesystem to expose to the share. Defaults to `/`.\n\n# SEE ALSO\n**ftpmgr(8)**\n",setuser=false,size=2691,modified=1757997040604,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["motd.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997043169,data="",setuser=false,size=0,modified=1757997043136,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["shadow.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997043171,data="",setuser=false,size=0,modified=1757997043141,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997043171,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},man9={permissions={root={write=true,read=true,execute=true}},created=1757997042246,contents={["kernel.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042246,data="---\nlayout: default\ntitle: Kernel API\n---\n\n# Kernel API\nThis page contains documentation for the public kernel module API.\n\nThis is a work-in-progress! Some parts may be broken or don't make sense.\n\n## `version: string`\nVersion number of Phoenix.\n\n## `do_syscall(call: string, ...: any): any...`\nSmall function to execute a syscall and error if it fails.\n\n### Arguments\n1. `call`: The syscall to execute\n2. `...`: The arguments to pass to the syscall\n\n### Return Values\nThe values returned from the syscall\n\n## `deepcopy(tab: any): any`\nCopies a value.  If the value is a table, copies all of its contents too.\n\n### Arguments\n1. `tab`: The value to copy\n\n### Return Values\nThe new copied value\n\n## `split(str: string[, sep: string = \"%s\"]): {string}`\nSplits a string by a separator.\n\n### Arguments\n1. `str`: The string to split\n2. `sep`: The separator pattern to split by (defaults to \"%s\")\n\n### Return Values\nA list of items in the string\n\n## `executeThread(process: Process, thread: Thread, ev: table, dead: boolean, allWaiting: boolean): boolean, boolean`\nResumes a thread's coroutine, handling different yield types.\n\n### Arguments\n1. `process`: The process that owns the thread\n2. `thread`: The thread to resume\n3. `ev`: An event to pass to the thread, if present\n4. `dead`: Whether a thread in the current run cycle has died\n5. `allWaiting`: Whether all previous threads were waiting for an event\n\n### Return Values\nThis function may return the following values:\n1. Whether this thread or a previous thread has died\n2. Whether all threads (including this one) are waiting for an event\n\n## `userModeCallback(process: Process, func: function, ...: any): boolean, any`\nExecutes a function in user mode from kernel code.\n\n### Arguments\n1. `process`: The process to execute as\n2. `func`: The function to execute\n3. `...`: Any parameters to pass to the function\n\n### Return Values\nThis function may return the following values:\n1. Whether the function returned successfully\n2. The value that the function returned.\n\n## `make_ENV(env: table): table`\nCreates a new _ENV shadow environment for a table.  The resulting table can\n have its environment set through `t._ENV = val`.\n\n### Arguments\n1. `env`: The environment table to use\n\n### Return Values\nA new _ENV-ized table\n\n## `args`\nStores all kernel arguments passed on the command line.\n\n### Fields\n- `init`:\n- `root`:\n- `rootfstype`:\n- `preemptive`:\n- `quantum`:\n- `splitkernpath`:\n- `loglevel`:\n- `console`:\n- `traceback`:\n\n## `syscalls`\nContains every syscall defined in the kernel.\n\n## `processes`\nStores all currently running processes.\n\n### Fields\n- `[0]`:\n- `id`:\n- `user`:\n- `dir`:\n- `dependents`:\n\n## `modules`\nStores all currently loaded kernel modules.\n\n## `eventHooks`\nStores a list of hooks to call on certain CraftOS events.  Each entry has the\n event name as a key, and a list of functions to call as the value. The\n functions are called with a single table parameter with the event parameters.\n\n## `process`\nProcess API\n\n## `filesystem`\nFilesystem API\n\n## `terminal`\nTerminal API\n\n## `user`\nUser API\n\n## `syslog`\nSystem logger API\n\n## `hardware`\nHardware API\n\n## `PHOENIX_BUILD`\nBuild string of Phoenix.\n\n### Fields\nThis function does not take any arguments.\n\n## `systemStartTime`\nStores the start time of the kernel.\n\n### Fields\nThis function does not take any arguments.\n\n## `KERNEL`\nStores a quick reference to the kernel process object.\n\n### Fields\nThis function does not take any arguments.\n\n# filesystem\n\n\n## `mounts`\nStores the current mounts as a key-value table of paths to filesystem objects.\n\n## `filesystems`\nThis table contains all filesystem types.  Use this to insert more filesystem\n types into the system.\n\n A filesystem type has to implement one method for each function in the\n filesystem API, with the exception of mounting-related functions and `combine`,\n as well as a `new` method that is called with the process, the source device,\n and the options table (if present). Paths passed to these methods (outside\n `new`) take a relative path to the mountpoint, NOT the absolute path.\n\n### Fields\n- `craftos`:\n- `owner`:\n- `permissions`:\n- `write`:\n- `execute`:\n\n## `filesystem.open(process: Process, path: string, mode: string): Handle / nil, string`\nOpens a file for reading or writing.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The file path to open, which may be absolute or relative\n to the process's working directory\n3. `mode`: The mode to open the file as\n\n### Return Values\nThis function may return the following values:\n1. The new file handle\n\nOr:\n1. If an error occurred\n2. An error message describing why the file couldn't be opened\n\n## `filesystem.list(process: Process, path: string): {string}`\nReturns a list of file names in the directory.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The file path to list, which may be absolute or relative\n to the process's working directory\n\n### Return Values\nA list of file names present in the directory\n\n## `filesystem.stat(process: Process, path: string): table / nil, string`\nReturns a table with information about the selected path.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The file path to stat, which may be absolute or relative\n to the process's working directory\n\n### Return Values\nThis function may return the following values:\n1. A table with information about the path (see the docs for\n the `stat` syscall for more info)\n\nOr:\n1. If an error occurred\n2. An error message describing why the file couldn't be opened\n\n## `filesystem.remove(process: Process, path: string)`\nRemoves a file or directory.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The file path to remove, which may be absolute or relative\n to the process's working directory\n\n### Return Values\nThis function does not return anything.\n\n## `filesystem.rename(process: Process, path: string, new: The)`\nRenames (moves) a file or directory.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The file path to rename, which may be absolute or relative\n to the process's working directory\n3. `new`: path the file will be at, which may be in another directory\n but must be on the same mountpoint\n\n### Return Values\nThis function does not return anything.\n\n## `filesystem.mkdir(process: Process, path: string)`\nCreates a new directory and any parent directories.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The directory to create, which may be absolute or relative\n to the process's working directory\n\n### Return Values\nThis function does not return anything.\n\n## `filesystem.chmod(process: Process, path: string, user: string|nil, boolean: number|string|{read)`\nChanges the permissions (mode) of a file or directory for the specified user.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The file path to modify, which may be absolute or relative\n to the process's working directory\n3. `user`: The user to change the permissions for, or `nil` for all users\n4. `boolean`: ?, write = boolean?, execute = boolean?} mode The\n new permissions for the user (see the docs for the `chmod` syscall for more info)\n\n### Return Values\nThis function does not return anything.\n\n## `filesystem.chown(process: Process, path: string, user: string)`\nChanges the owner of a file or directory.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The file path to modify, which may be absolute or relative\n to the process's working directory\n3. `user`: The user that will own the file\n\n### Return Values\nThis function does not return anything.\n\n## `filesystem.mount(process: Process, type: string, src: string, dest: string, options: table?)`\nMounts a disk device to a path using the specified filesystem and options.\n\n### Arguments\n1. `process`: The process to operate as\n2. `type`: The type of filesystem to mount\n3. `src`: The source device to mount\n4. `dest`: The destination mountpoint\n5. `options`: Any options to pass to the mounter (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `filesystem.unmount(process: Process, path: string)`\nUnmounts a filesystem at a mountpoint.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The mountpoint to remove, which may be absolute or relative\n to the process's working directory\n\n### Return Values\nThis function does not return anything.\n\n## `filesystem.combine(first: string, ...: string): string`\nCombines the specified path components into a single path.\n\n### Arguments\n1. `first`: The first path component\n2. `...`: Any additional path components to add\n\n### Return Values\nThe final combined path\n\n## `createLuaLib(process: Process): _G`\nCreates a new global table with a Lua 5.2 standard library installed.\n\n### Arguments\n1. `process`: The process to generate for\n\n### Return Values\nA new global table for the process\n\n# terminal\n\n\n## `terminal.makeTTY(term: table, width: number, height: number): TTY`\nReturns a new TTY object.\n\n### Arguments\n1. `term`: The CraftOS terminal object to render on\n2. `width`: The width of the TTY\n3. `height`: The height of the TTY\n\n### Return Values\nThe new TTY object\n\n## `TTY`\nStores all virtual TTYs for the main screen.\n\n### Fields\n- `terminal`:\n- `terminal`:\n- `terminal`:\n- `terminal`:\n- `terminal`:\n- `terminal`:\n- `terminal`:\n- `terminal`:\n\n## `currentTTY`\nStores the TTY that is currently shown on screen.\n\n### Fields\nThis function does not take any arguments.\n\n## `terminal.userTTYs`\nStores all TTYs that have been created in user mode.\n\n## `keysHeld`\nStores what modifier keys are currently being held.\n\n### Fields\n- `ctrl`:\n- `alt`:\n- `shift`:\n\n## `terminal.redraw(tty: TTY, full: boolean)`\nRedraws the specified TTY if on-screen.\n\n### Arguments\n1. `tty`: The TTY to redraw\n2. `full`: Whether to draw the full screen, or just the changed regions\n\n### Return Values\nThis function does not return anything.\n\n## `terminal.resize(tty: TTY, width: number, height: number)`\nResizes the TTY.\n\n### Arguments\n1. `tty`: The TTY to resize\n2. `width`: The new width\n3. `height`: The new height\n\n### Return Values\nThis function does not return anything.\n\n## `terminal.write(tty: TTY, text: string)`\nWrites some text to a TTY's text buffer, allowing ANSI escapes.\n\n### Arguments\n1. `tty`: The TTY to write to\n2. `text`: The text to write\n\n### Return Values\nThis function does not return anything.\n\n# syslog\n\n\n## `syslogs`\nStores all open system logs.\n\n### Fields\n- `default`: file = filesystem.open(KERNEL, \"/var/log/default.log\", \"a\"),\n\n## `panic(message: any?)`\nImmediately halts the system and shows an error message on screen.\n This function can be called either standalone or from within xpcall.\n This function never returns.\n\n### Arguments\n1. `message`: A message to display on screen (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `createRequire(process: Process, G: _G)`\nCreates a new `package` and `require` set in a global table for the specified process.\n\n### Arguments\n1. `process`: The process to make the functions for\n2. `G`: The global environment to install in\n\n### Return Values\nThis function does not return anything.\n\n## `timerMap`\nStores a list of used timers.\n\n## `alarmMap`\nStores a list of used alarms.\n\n## `reap_process(process: Process)`\nFinishes a process's resources so it can be removed cleanly.\n\n### Arguments\n1. `process`: The process to reap\n\n### Return Values\nThis function does not return anything.\n\n# hardware\n\n\n## `deviceTreeRoot`\nStores the root device for hardware.\n\n### Fields\n- `id`:\n- `uuid`:\n- `parent`:\n- `displayName`:\n- `drivers`:\n\n## `hardware.get(path: string): Device...`\nReturns all devices that match a path specifier.\n\n### Arguments\n1. `path`: The path to query\n\n### Return Values\nThe device objects that match\n\n## `hardware.find(type: string): Device...`\nReturns all devices that match a type.\n\n### Arguments\n1. `type`: The type to find\n\n### Return Values\nThe device objects that match\n\n## `hardware.path(node: Device): string`\nReturns the absolute path to a device node.\n\n### Arguments\n1. `node`: The node to lookup\n\n### Return Values\nThe path to the node\n\n## `hardware.add(parent: Device, name: string): Device`\nAdds a new child to the specified node.\n\n### Arguments\n1. `parent`: The parent of the new node\n2. `name`: The name of the new node\n\n### Return Values\nThe newly added node\n\n## `hardware.remove(node: Device): boolean, string?`\nRemoves a node from its parent and the device tree.  The device node should\n no longer be used.\n\n### Arguments\n1. `node`: The node to remove\n\n### Return Values\nThis function may return the following values:\n1. Whether the operation succeeded\n2. An error message if it failed\n\n## `hardware.register(node: Device, driver: Driver): boolean, string?`\nRegisters a device driver on a node.\n\n### Arguments\n1. `node`: The node to modify\n2. `driver`: The driver to add\n\n### Return Values\nThis function may return the following values:\n1. Whether the operation succeeded\n2. An error message if it failed\n\n## `hardware.register_callback(driver: Driver): function`\nReturns a function that automatically attaches a driver to a node.\n\n### Arguments\n1. `driver`: The driver to use\n\n### Return Values\nA function that takes a node and registers the driver on it\n\n## `hardware.deregister(node: Device, driver: Driver): boolean, string?`\nDeregisters a driver from a node.\n\n### Arguments\n1. `node`: The node to modify\n2. `driver`: The driver to remove\n\n### Return Values\nThis function may return the following values:\n1. Whether the operation succeeded\n2. An error message if it failed\n\n## `hardware.listen(callback: function, parent: Device?, pattern: string?)`\nAdds a function that is called when either a parent node or pattern matches on a new node.\n\n### Arguments\n1. `callback`: A function that is called with a node when the pattern matches\n2. `parent`: A parent node to watch on (optional)\n3. `pattern`: A Lua pattern to match on the device name (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `hardware.unlisten(callback: function)`\nRemoves a listener callback from the listener list.\n\n### Arguments\n1. `callback`: The function to remove\n\n### Return Values\nThis function does not return anything.\n\n## `hardware.broadcast(node: Device, event: string, param: table)`\nBroadcasts an event to all processes listening to events on a node.\n\n### Arguments\n1. `node`: The node to broadcast for\n2. `event`: The event to broadcast\n3. `param`: The parameters to pass for the event\n\n### Return Values\nThis function does not return anything.\n\n## `hardware.call(process: Process, node: Device, method: string, ...: any): any...`\nCalls a method on a device.\n\n### Arguments\n1. `process`: The process to run as\n2. `node`: The node to call on\n3. `method`: The method to call\n4. `...`: Any arguments to pass\n\n### Return Values\nAny return values from the method\n\n## `uriSchemes`\nStores all URI scheme handlers using Lua patterns as keys.\n\n### Fields\n- `[https?]`:\n- `[wss?]`:\n- `[rednet]`:\n- `[rednet%+%a+]`:\n- `[psp]`:\n\n",setuser=false,size=15004,modified=1757997042194,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997042246,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},man1={permissions={root={write=true,read=true,execute=true}},created=1757997043423,contents={["tar.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042895,data="",setuser=false,size=0,modified=1757997042887,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["startctl.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042779,data="",setuser=false,size=0,modified=1757997042763,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["shell.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997041056,data="<summary>CraftOS shell wrapper for Phoenix</summary>\n# NAME\n    shell - CraftOS shell wrapper for Phoenix\n\n# SYNOPSIS\n    **shell**\n\n# DESCRIPTION\n**shell** executes the CraftOS shell program using libcraftos. It requires the\nROM to be mounted at `/rom` - if run as root, it will automatically mount the\nROM as needed.\n\nThe filesystem is the same as the Phoenix filesystem, so all Phoenix files will\nstill be present in the shell. Compatibility caveats with libcraftos still apply,\nbut the `shell`, `package`, and `require` APIs will be replaced with the\noriginal CraftOS versions, so issues relating to those will no longer apply.\n\nPhoenix programs will still be executable in the CraftOS shell. However, the\nprograms will execute in the same process context as the shell. This means that\ncalls that affect global process state, such as **exit**(2) or **stdin**(2),\nwill also affect the shell, as well as other programs run in the shell (e.g.\ncalling **exit**(2) will quit the entire shell).\n\n# HISTORY\nIntroduced in libcraftos 0.2.\n\n# SEE ALSO\n**craftos**(1)\n",setuser=false,size=1061,modified=1757997041049,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["startmgr.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042779,data="",setuser=false,size=0,modified=1757997042766,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["craftos.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997041056,data="<summary>run CraftOS programs under Phoenix</summary>\n# NAME\n    craftos - run CraftOS programs under Phoenix\n\n# SYNOPSIS\n    **craftos** *program path* [*arguments ...*]\n\n# DESCRIPTION\n**craftos** allows running programs written for CraftOS on top of Phoenix. It\nuses *libcraftos* to implement a compatibility layer between CraftOS APIs and\nPhoenix system calls. It loads all of the CraftOS APIs into the program's global\ntable, and then executes the program with the specified arguments.\n\n**craftos** functions as if the program was called from the CraftOS shell, or\nusing `shell.run`. It should be compatible with many programs, but some that\nrequire specific details of CraftOS's inner workings may not be compatible.\n\n# HISTORY\nIntroduced in libcraftos 0.1.\n\n# SEE ALSO\n**shell**(1)\n",setuser=false,size=788,modified=1757997041045,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["su.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997043167,data="",setuser=false,size=0,modified=1757997043122,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["login.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997043166,data="",setuser=false,size=0,modified=1757997043117,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["yellowbox.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997043423,data="<summary>access and administrate YellowBox boxes</summary>\n# NAME\nyellowbox - access and administrate YellowBox boxes\n\n# SYNOPSIS\n**yellowbox status**  \n**yellowbox start** [*options*] ...\n**yellowbox stop** *id*\n**yellowbox view** *id*\n**yellowbox get-bios** [*version*]\n\n# DESCRIPTION\n**yellowbox** \n\n# EXAMPLE\n\n\n# SEE ALSO\n**yellowbox**(7)",setuser=false,size=342,modified=1757997043411,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["passwd.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997043167,data="",setuser=false,size=0,modified=1757997043120,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["sudo.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997043168,data="",setuser=false,size=0,modified=1757997043125,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["logger.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042199,data="<summary>view, post to, create, and delete logs</summary>\n# NAME\nlogger - view, post to, create, and delete logs\n\n# SYNOPSIS\n**logger log** [**-n** *log name*] [**-c** *category*] [**-l** **debug**|**info**|**notice**|**warning**|**error**|**critical**] [**-m** *module*] *message* ...\n**logger create** [**-F** *path*] [**-s**] *log name*\n**logger delete** [**-p**] *log name*\n**logger view** *log name*\n**logger follow** [**-f** *filter*] *log name*\n\n# DESCRIPTION\n**logger** provides a simple command-line interface to the system logger module. It allows viewing logs (including streaming), posting messages to a log, and creating and deleting logs.\n\n# PARAMETERS\nFor the **log** subcommand:\n\n**-c** *category*  \n    Sets the category for the message.\n\n**-l** **debug**|**info**|**notice**|**warning**|**error**|**critical**  \n    Sets the level of the log messgae.\n\n**-m** *module*  \n    Sets the name of the module for the message.\n\n**-n** *log name*  \n    Sets the name of the log to write to.\n\nFor the **create** subcommand:\n\n**-F** *path*  \n    Sets the file to write logs to.\n\n**-s**  \n    Specifies that the log should be streamable.\n\nFor the **delete** subcommand:\n\n**-p**  \n    Purges all logs on disk.\n\nFor the **follow** subcommand:\n\n**-f** *filter*  \n    Specifies a filter expression to apply to the listener.\n    \n    A filter consists of a series of clauses separated by semicolons. Each clause consists of a name, operator, and one or more values separated by bars (`|`). String values may be surrounded with double quotes to allow semicolons, bars, and leading spaces. If multiple values are specified, any value matching will cause the clause to resolve to true. All clauses must be true for the filter to match.\n    \n    Available operators: `==`, `!=`/`~=`, `=%` (match), `!%`/`~%` (not match), `<`, `<=`, `>=`, `>` (numbers only).\n    \n    Example: `level == 3 | 4 | 5; category != filesystem; process > 0; message =% \"Unexpected error\"`\n\n# HISTORY\nIntroduced in baseutils 0.2.\n\n# SEE ALSO\n**syslog**(2), **system.log**(3)\n",setuser=false,size=2047,modified=1757997041921,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["shutdown.md"]={permissions={root={read=true,write=true,execute=false}},created=1757997042778,data="",setuser=false,size=0,modified=1757997042759,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997043423,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"}},size=0,modified=1757997043295,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"}},size=0,modified=1757997040406,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},bin={permissions={root={write=true,read=true,execute=true}},created=1757997043301,contents={["apt.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039613,data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=require\"apt.config\"local d=require\"apt.cache\"local e=require\"apt.get\"local f=require\"dpkg\"local g=require\"muxzcat\"local h=require\"LibDeflate\"local i=assert(b.argparse({},...))c:load()local function j(k,l,m,n,o,p)if not n then error(\"Some packages could not be installed. This may mean that you have requested an impossible situation.\")end;local q,r,s,t=0,0,0,0;for u,v in pairs(o)do if v then if f.package.packagedb[u]and f.package.packagedb[u].Status:match\" installed$\"then s=s+1 else q=q+1 end else r=r+1 end end;for u,v in pairs(f.package.packagedb)do local w=d:get(u)if w and f.compareVersions(w.version,v.Version)>0 and o[u]==nil then t=t+1 end end;if m and next(m)then print(\"The following packages have been kept back:\")io.write(\"  \")for u in pairs(m)do io.write(u..\" \")end;print(\"\")end;if s>0 then print(\"The following packages will be upgraded:\")io.write(\"  \")for u,v in pairs(o)do if v and f.package.packagedb[u]then io.write(u..\" \")end end;print(\"\")end;if q>#i-1 then print(\"The following additional packages will be installed:\")io.write(\"  \")for u,v in pairs(o)do if v and not l[u]then io.write(u..\" \")end end;print(\"\")end;if q>0 then print(\"The following packages will be installed:\")io.write(\"  \")for u,v in pairs(o)do if v then io.write(u..\" \")end end;print(\"\")end;if r>0 then print(\"The following packages will be REMOVED:\")io.write(\"  \")for u,v in pairs(o)do if not v then io.write(u..\" \")end end;print(\"\")end;print((\"%d upgraded, %d newly installed, %d to remove and %d not upgraded.\"):format(s,q,r,t))if#n==0 then return end;io.write(\"Do you want to continue? [Y/n] \")local x=io.read()if not x or x~=\"\"and x:lower()~=\"y\"then print(\"Abort.\")return end;local y={}for z,v in ipairs(p)do y[v]=e.download(v)end;e.execute(n,y,k)end;if i[1]==\"update\"then e.update()e.showStats()d:generate()elseif i[1]==\"download\"then d:load()for A=2,#i do local B=e.download(i[A])if B then a.copy(B,a.basename(B))end end;e.showStats()elseif i[1]==\"install\"then local l={}for A=2,#i do l[i[A]]=true end;io.write(\"Reading state information... \")f.package.setPackageDB()f.package.setTriggerDB()f.package.setFileDB()d:load()print(\"Done.\")j(false,l,nil,e.plan(f.package.packagedb,l,{}))elseif i[1]==\"remove\"or i[1]==\"purge\"then local l={}for A=2,#i do l[i[A]]=false end;io.write(\"Reading state information... \")f.package.setPackageDB()f.package.setTriggerDB()f.package.setFileDB()d:load()print(\"Done.\")j(i[1]==\"purge\",l,nil,e.plan(f.package.packagedb,l,{}))elseif i[1]==\"upgrade\"or i[1]==\"dist-upgrade\"or i[1]==\"full-upgrade\"then io.write(\"Reading state information... \")f.package.setPackageDB()f.package.setTriggerDB()f.package.setFileDB()d:load()print(\"Done.\")j(false,e.planUpgrade(f.package.packagedb,i[1]==\"dist-upgrade\"or i[1]==\"full-upgrade\",{}))elseif i[1]==\"autoremove\"then elseif i[1]==\"satisfy\"then elseif i[1]==\"search\"then d:load(true)local C={}for u,v in pairs(d.db.packagesByName)do if u:find(i[2],1,true)then local D=d:getRepo(v.repoIndex)C[#C+1]=u..\"/\"..D.suite..\" \"..v.version..\" \"..D.architecture end end;table.sort(C)for z,v in ipairs(C)do print(v)end elseif i[1]==\"show\"then d:load()for A=2,#i do local w=d:get(i[A])if w then local D=assert(d:getRepo(w.repoIndex))local E=c:get(\"Acquire\",\"IndexTargets\",\"deb\",\"Packages\",\"MetaKey\"):gsub(\"%$%(COMPONENT%)\",D.component):gsub(\"%$%(ARCHITECTURE%)\",D.architecture)local F=a.combine(D.url:gsub(\"^.-://\",\"\"),\"dists\",D.suite,E):gsub(\"[/:]\",\"_\")local B=a.combine(c:getPath(\"State\",\"lists\"),F)local G;local H=io.open(B,\"r\")if H then G=H:read(\"*a\")H:close()else H=io.open(B..\".xz\",\"rb\")if H then local I=H:read(\"*a\")H:close()G=g.DecompressXzOrLzmaString(I)else H=io.open(B..\".gz\",\"rb\")if H then local J=H:read(\"*a\")H:close()G=h:DecompressGzip(J)end end end;if G then print(G:match(\"(Package: \"..w.name..\".-)\\n\\n\")or G:match(\"(Package: \"..w.name..\".-)$\")or\"Could not find package in Packages list.\")else error(\"Could not find Packages file for owner repository.\")end end end elseif i[1]==\"list\"then else error(\"Unknown command '\"..i[1]..\"'\")end\n",setuser=false,size=4063,modified=1757997039600,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["dpkg-divert.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997040421,data="local a=require\"system.filesystem\"local b=require\"dpkg.divert\"local c={}local d=0;local e=\"/\"local f=nil;local g=\":\"local h=false;local i=nil;local j=false;local k=nil;for l,m in pairs({...})do if k then if k==0 then b.admindir=m elseif k==1 then e=m elseif k==2 then e=m;b.admindir=a.combine(m,\"var/lib/dpkg\")elseif k==3 then f=m elseif k==4 then g=m end;k=nil elseif m==\"--add\"then d=0 elseif m==\"--remove\"then d=1 elseif m==\"--list\"then d=2 elseif m==\"--listpackage\"then d=3 elseif m==\"--truename\"then d=4 elseif m==\"--admindir\"then k=0 elseif m==\"--instdir\"then k=1 elseif m==\"--root\"then k=2 elseif m==\"--divert\"then k=3 elseif m==\"--local\"then g=\":\"elseif m==\"--package\"then k=4 elseif m==\"--quiet\"then h=true elseif m==\"--rename\"then i=true elseif m==\"--no-rename\"then i=false elseif m==\"--test\"then j=true elseif m==\"-?\"or m==\"--help\"then print([[Usage: dpkg-divert [<option> ...] <command>\nCommands:\n  [--add] <file>           add a diversion.\n  --remove <file>          remove the diversion.\n  --list [<glob-pattern>]  show file diversions.\n  --listpackage <file>     show what package diverts the file.\n  --truename <file>        return the diverted file.]])return 2 elseif m==\"--version\"then print(\"dpkg-divert v1.0\\nPart of apt-lua for Phoenix\\nCopyright (c) 2019-2022 JackMacWindows.\")return 2 else table.insert(c,m)end end;if d==0 then if#c<1 then error(\"Usage: dpkg-divert [options...] [--add] <file>\")end;f=f or c[1]..\".distrib\"if g==\":\"and not h then print(\"Adding 'local diversion of \"..c[1]..\" to \"..f..\"'\")elseif not h then print(\"Adding 'diversion of \"..c[1]..\" to \"..f..\" by \"..g..\"'\")end;if not j then b.add(c[1],f,g)end;if i then a.move(c[1],f)end elseif d==1 then if#c<1 then error(\"Usage: dpkg-divert [options...] --remove <file>\")end;local n=b.parse()if n[c[1]]==nil then return end;if g==\":\"and not h then print(\"Removing 'local diversion of \"..c[1]..\" to \"..n[c[1]].name..\"'\")elseif not h then print(\"Removing 'diversion of \"..c[1]..\" to \"..n[c[1]].name..\" by \"..n[c[1]].package..\"'\")end;if not j then b.remove(c[1])end;if i then a.move(n[c[1]].name,c[1])end elseif d==2 then if h then return end;if#c<1 then error(\"Usage: dpkg-divert [options...] --list <glob>\")end;c[1]=string.gsub(c[1],\"%*\",\"%.%*\")for l,m in pairs(b.parse())do if string.match(l,c[1])then if m.package==\":\"then print(\"local diversion of \"..l..\" to \"..m.name)else print(\"diversion of \"..l..\" to \"..m.name..\" by \"..m.package)end end end elseif d==3 then if h then return end;if#c<1 then error(\"Usage: dpkg-divert [options...] --listpackage <file>\")end;local o=b.parse()[c[1]]if o~=nil then if o.package==\":\"then print(\"LOCAL\")else print(o.package)end end elseif d==4 then if h then return end;if#c<1 then error(\"Usage: dpkg-divert [options...] --truename <file>\")end;local o=b.parse()[c[1]]if o==nil then print(c[1])else print(o.name)end end\n",setuser=false,size=2840,modified=1757997040396,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["sha384sum.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997042487,data="return coroutine.yield(\"syscall\",\"exec\",\"/usr/bin/shasum\",\"-a\",\"384\",...)\n",setuser=false,size=74,modified=1757997042480,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["arp.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997041598,data="local a=require\"system.hardware\"local b=require\"system.network\"local c=require\"system.util\"local d=assert(c.argparse({s=false,set=\"@s\",d=false,delete=\"@d\",f=true,file=\"@f\",i=true,device=\"@i\"},...))local e;if d.i then e={a.get(d.i)}else e={a.find(\"modem\")}end;if d.s then local f,g=d[1],tonumber(d[2])if not g or not f or not f:match\"^%d+%.%d+%.%d+%.%d+$\"then error(\"Usage: arp [options] -s <ip> <id>\")end;for h,i in ipairs(e)do local j=a.path(i)b.arp.set(j,f,g)end elseif d.d then local f=d[1]if not f or not f:match\"^%d+%.%d+%.%d+%.%d+$\"then error(\"Usage: arp [options] -d <ip>\")end;for h,i in ipairs(e)do local j=a.path(i)b.arp.set(j,f,nil)end elseif d.f then for k in io.lines(d.f)do local f,g=k:match(\"^(%S+)%s+(%d+)\")if f and g then for h,i in ipairs(e)do local j=a.path(i)b.arp.set(j,f,tonumber(g))end end end else print(\"Address\\t\\tID\\tDevice\")for h,i in ipairs(e)do local j=a.path(i)local l=b.arp.list(j)for m,n in pairs(l)do print(m,n,j)end end end\n",setuser=false,size=958,modified=1757997041593,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["sha512sum.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997042488,data="return coroutine.yield(\"syscall\",\"exec\",\"/usr/bin/shasum\",\"-a\",\"512\",...)\n",setuser=false,size=74,modified=1757997042481,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["update.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997040423,data="local a=\"https://phoenix.madefor.cc/packages/\"local b=require\"system.filesystem\"local c=require\"system.network\"local d=require\"system.process\"local e=require\"dpkg.control\"local f=require\"dpkg.query\"if d.getuser()~=\"root\"then error(\"This program must be run as root.\")end;print(\"Checking for updates...\")local g,h=c.get(a..\"Packages\")if not g then error(\"Could not download package list: \"..h)elseif g:responseCode()~=200 then local i=g:responseCode()g:close()error(\"Could not download package list: HTTP \"..i)end;local j=e.parseControlList(g:read(\"*a\"))g:close()local k={}for l,m in ipairs(j)do k[m.Package]=m end;local n=f.readDatabase()local o={}for p,m in pairs(n)do if not m.Status:match\"^deinstall \"and k[p]and k[p].Version~=m.Version then o[#o+1]=p end end;if#o==0 then print(\"No updates available.\")return true end;table.sort(o,function(q,r)if q==\"dpkg\"then return true elseif r==\"dpkg\"then return false else return q<r end end)print(\"The following package updates are available:\")for l,m in ipairs(o)do print(\"  \"..m..\": \"..n[m].Version..\" -> \"..k[m].Version)end;io.write(\"Install these updates? (y/N) \")local s=io.read()if not s or s:lower()~=\"y\"then return false end;b.mkdir(\"/tmp/pkgcache\")b.mount(\"tmpfs\",\"tmpfs\",\"/tmp/pkgcache\",{})for l,m in ipairs(o)do print(\"Downloading \"..m..\" (\"..math.floor(k[m].Size/1024)..\" kiB)\")g,h=c.get{url=a..m..\".deb\",encoding=\"binary\"}if not g then b.unmount(\"/tmp/pkgcache\")error(\"Failed to download package: \"..h)elseif g:responseCode()~=200 then b.unmount(\"/tmp/pkgcache\")local i=g:responseCode()g:close()error(\"Failed to download package: HTTP \"..i)end;local t,h=b.open(\"/tmp/pkgcache/\"..m..\".deb\",\"wb\")if not t then g:close()b.unmount(\"/tmp/pkgcache\")error(\"Failed to write package: \"..h)end;t.write(g:read(\"*a\"))t.close()g:close()end;local u=true;for l,m in ipairs(o)do u=d.run(\"/usr/bin/dpkg\",\"-i\",\"/tmp/pkgcache/\"..m..\".deb\")and u end;b.unmount(\"/tmp/pkgcache\")print(\"Update complete. It may be necessary to reboot your computer to use the new software.\")return u\n",setuser=false,size=2016,modified=1757997040399,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["gzip.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997041135,data="local a=require\"LibDeflate\"local b={...}local c=0;local d;local e;local f=false;local g=false;local h;local i=false;for j,k in pairs(b)do if k==\"-c\"or k==\"--stdout\"then e=\"stdout\"elseif k==\"-d\"or k==\"--decompress\"then c=1 elseif k==\"-f\"or k==\"--force\"then g=true elseif k==\"-h\"or k==\"--help\"then print([[Usage: gzip [OPTION]... [FILE]\nCompress or uncompress FILEs (by default, compress FILES in-place).\n\n    -c, --stdout      write on standard output, keep original files unchanged\n    -d, --decompress  decompress\n    -f, --force       force overwrite of output file\n    -h, --help        give this help\n    -k, --keep        keep (don't delete) input files\n    -l, --list        list compressed file contents\n    -t, --test        test compressed file integrity\n    -v, --verbose     verbose mode\n    -V, --version     display version number\n    -1, --fast        compress faster\n    -9, --best        compress better\n\nWith no FILE, or when FILE is -, read standard input.]])return elseif k==\"-k\"or k==\"--keep\"then f=true elseif k==\"-l\"or k==\"--list\"then c=2 elseif k==\"-t\"or k==\"--test\"then c=3 elseif k==\"-v\"or k==\"--verbose\"then i=true elseif k==\"-V\"or k==\"--version\"then print(\"gzip v1.0\")return elseif k==\"-1\"or k==\"--fast\"then h=1 elseif k==\"-9\"or k==\"--best\"then h=9 elseif d==nil then if k==\"-\"then d=\"stdin\"e=\"stdout\"else d=k end end end;if d==nil then d=\"stdin\"end;if e==nil then if c==0 and d~=\"stdin\"then e=d..\".gz\"elseif c==1 and d~=\"stdin\"then e=string.gsub(d,\".gz\",\"\")else e=\"stdout\"end end;local function l()if d==\"stdin\"then return io.stdin:read(\"*a\")else local m=assert(io.open(d,\"rb\"))local n=m:read(\"*a\")m:close()return n end end;local function o(p)if p==nil then error(d..\": not in gzip format\",2)end;if e==\"stdout\"then io.stdout:write(p)else local m=assert(io.open(e,\"wb\"))m:write(p)m:close()end;if i and e~=\"stdout\"then print(\"Wrote \"..string.len(p)..\" bytes\")end end;if e~=\"stdout\"and not g then local m=io.open(e,\"r\")if m then m:close()error(e..\": File exists\")end end;if c==0 then o(a:CompressGzip(l(),{level=h}))elseif c==1 then o(a:DecompressGzip(l()))elseif c==2 then local q=a.internal.GetGzipInfo(l())if q==nil then error(d..\": not in gzip format\")end;for j,k in pairs(q)do print(j,k)end elseif c==3 then local r,s=a:DecompressGzip(l())if r==nil then if s==-2 then error(d..\": invalid compressed data--crc error\")elseif s==-1 then error(d..\": not in gzip format\")elseif s==-3 then error(d..\" has unsupported flags\")elseif s==-4 then error(d..\": unknown method -- not supported\")else error(d..\": unknown error\")end end;if i then print(d..\":    OK\")end else error(\"This should never happen.\")end;if not f and d~=\"stdin\"and e~=\"stdout\"then os.remove(d)end\n",setuser=false,size=2686,modified=1757997041132,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["sha256sum.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997042487,data="return coroutine.yield(\"syscall\",\"exec\",\"/usr/bin/shasum\",\"-a\",\"256\",...)\n",setuser=false,size=74,modified=1757997042480,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["md5sum.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997042485,data="local a=require\"sha2\"local b=require\"system.util\"local c=assert(b.argparse({b=false,binary=\"@b\",c=false,check=\"@c\",tag=false,t=false,text=\"@t\",z=false,zero=\"@z\",[\"ignore-missing\"]=false,quiet=false,status=false,strict=false,w=false,warn=\"@w\",h=false,help=\"@h\",v=false,version=\"@v\"},...))if c.h then print[[\nUsage: md5sum [OPTION]... [FILE]...\nPrint or check MD5 (128-bit) checksums.\n\nWith no FILE, or when FILE is -, read standard input.\n  -b, --binary          read in binary mode\n  -c, --check           read checksums from the FILEs and check them\n      --tag             create a BSD-style checksum\n  -t, --text            read in text mode (default)\n  -z, --zero            end each output line with NUL, not newline,\n                          and disable file name escaping\n\nThe following five options are useful only when verifying checksums:\n      --ignore-missing  don't fail or report status for missing files\n      --quiet           don't print OK for each successfully verified file\n      --status          don't output anything, status code shows success\n      --strict          exit non-zero for improperly formatted checksum lines\n  -w, --warn            warn about improperly formatted checksum lines\n\n      --help        display this help and exit\n      --version     output version information and exit\n\nThe sums are computed as described in RFC 1321.\nWhen checking, the input should be a former output of this program.\nThe default mode is to print a line with: checksum, a space,\na character indicating input mode ('*' for binary, ' ' for text\nor where binary is insignificant), and name for each FILE.\n]]return elseif c.v then print(\"1.0\")return end;c[1]=c[1]or\"-\"for d,e in ipairs(c)do local f=e==\"-\"and io.stdin or assert(io.open(e,c.b and not c.t and\"rb\"or\"r\"))local g=a.md5()local h;repeat local i=f:read(\"*L\")h=g(i)until not i;if f~=io.stdin then f:close()end;local j;if c.tag then j=\"MD5 (\"..e..\") = \"..h else j=h..\"  \"..e end;if c.z then io.stdout:write(j..\"\\0\")else print(j)end end\n",setuser=false,size=2010,modified=1757997042477,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["components.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997040420,data="local a=require\"system.filesystem\"local b=require\"system.framebuffer\"local c=require\"system.ipc\"local d=require\"system.keys\"local e=require\"system.log\"local f=require\"system.network\"local g=require\"system.process\"local h=require\"system.terminal\"local i=require\"system.util\"local j=require\"dpkg.query\"if g.getuser()~=\"root\"then error(\"This program must be run as root.\")end;local k=\"https://phoenix.madefor.cc/packages/\"local l=h.openterm()local m=h.colors;l.setPaletteColor(m.orange,0xD06018)l.setPaletteColor(m.white,0xD8D8D8)local n,o=l.getSize()local p;local q={}local r;local s=true;local t={}local function u(v,w)local x={}local y=\"\"for z in v:gmatch\"%w*%W*\"do while z:find\"\\n\"do local A;A,z=z:match\"([^\\n]*)\\n(.*)\"if#y+#A<w then x[#x+1],y=y..A,\"\"else x[#x+1],y=y,A end end;if#y+#z<w then y=y..z else x[#x+1],y=y,z end end;x[#x+1]=y;return x end;local function B(C)l.setCursorPos(3,o)l.setBackgroundColor(m.white)l.setTextColor(m.black)l.clearLine()l.write(C)end;local function D(C)l.setBackgroundColor(m.orange)l.setTextColor(m.white)l.clear()l.setCursorBlink(false)l.setCursorPos(2,2)l.write(\"Phoenix Setup\")l.setCursorPos(1,3)l.write((\"\\x8C\"):rep(15))B(C)p=5;q={}r=nil end;local function E(v)local F=b.window(l,3,p,n-4,o-p)F.setBackgroundColor(m.orange)F.setTextColor(m.white)F.clear()local G=0;for H,I in ipairs(u(v:gsub(\"* \",\"\\7 \"),n-4))do F.setCursorPos(1,H)F.write(I)G=H end;F.reposition(3,p,n-4,G)p=p+G+1 end;local function J(K,L,M,N)K=K or o-p-3;local O=0;for P in pairs(L)do O=O+1 end;l.setBackgroundColor(m.orange)l.setTextColor(m.white)l.setCursorPos(3,p)l.write(\"\\x9C\"..(\"\\x8C\"):rep(n-6))l.setBackgroundColor(m.white)l.setTextColor(m.orange)l.write(\"\\x93\")for Q=1,K do l.setCursorPos(l.getCursorPos()-1,p+Q)l.write(\"\\x95\")end;l.setBackgroundColor(m.orange)l.setTextColor(m.white)for Q=1,K do l.setCursorPos(3,p+Q)l.write(\"\\x95\")end;l.setCursorPos(3,p+K+1)l.write(\"\\x8D\"..(\"\\x8C\"):rep(n-6)..\"\\x8E\")local H,w=p+1,n-7;local R=b.window(l,4,H,w,K)R.setBackgroundColor(m.orange)R.clear()local S=b.framebuffer(R,1,1,w,O)S.setBackgroundColor(m.orange)S.setTextColor(m.white)S.clear()local x={}local T,U=1,1;for V,W in pairs(L)do S.setCursorPos(1,T)S.write((W and(W==\"R\"and\"[-] \"or\"[\\xD7] \")or\"[ ] \")..V)x[T]={V,not not W}T=T+1 end;l.setCursorPos(w+4,H+K-1)l.blit(1<O-K+1 and\"\\31\"or\" \",\"0\",\"1\")S.setCursorPos(2,U)S.setCursorBlink(true)r=S.restoreCursor;q[#q+1]=coroutine.create(function()local X=1;while true do local Y,Z=coroutine.yield()local _;if Y==\"key\"then if Z.keycode==d.up then _=-1 elseif Z.keycode==d.down then _=1 elseif Z.keycode==d.space and L[x[U][1]]~=\"R\"then x[U][2]=not x[U][2]S.setCursorPos(2,U)S.write(x[U][2]and\"\\xD7\"or\" \")if N and N(x[U][1],x[U][2])then for Q,W in ipairs(x)do local a0=L[W[1]]==\"R\"and\"R\"or W[2]S.setCursorPos(2,Q)S.write(a0 and(a0==\"R\"and\"-\"or\"\\xD7\")or\" \")end end;S.setCursorPos(2,U)elseif Z.keycode==d.enter then local a1={}for P,W in ipairs(x)do a1[W[1]]=L[W[1]]==\"R\"or W[2]end;M(a1)end elseif Y==\"mouse_scroll\"and Z.x>=4 and Z.x<4+w and Z.y>=H and Z.y<H+K then _=Z.direction end;if _ and(U+_>=1 and U+_<=O)then U=U+_;if U-X<0 or U-X>=K then X=X+_;S.reposition(1,2-X)end;S.setCursorPos(2,U)end;l.setCursorPos(w+4,H)l.blit(X>1 and\"\\30\"or\" \",\"0\",\"1\")l.setCursorPos(w+4,H+K-1)l.blit(X<O-K+1 and\"\\31\"or\" \",\"0\",\"1\")S.restoreCursor()end end)p=p+K+2 end;local function a2()l.setBackgroundColor(m.orange)l.setTextColor(m.white)l.setCursorPos(3,p)l.write(\"\\x9C\"..(\"\\x8C\"):rep(n-6))l.setBackgroundColor(m.white)l.setTextColor(m.orange)l.write(\"\\x93\")l.setCursorPos(l.getCursorPos()-1,p+1)l.write(\"\\x95\")l.setBackgroundColor(m.orange)l.setTextColor(m.white)l.setCursorPos(3,p+1)l.write(\"\\x95\")l.setCursorPos(3,p+2)l.write(\"\\x8D\"..(\"\\x8C\"):rep(n-6)..\"\\x8E\")local F=b.window(l,4,p+1,n-6,1)F.setBackgroundColor(m.orange)F.setTextColor(m.white)F.clear()p=p+4;return function(a3)F.setCursorPos(1,1)F.setBackgroundColor(m.orange)F.clearLine()F.setBackgroundColor(m.white)F.write((\" \"):rep(a3*(n-6)))end end;local function a4(a5)q[#q+1]=coroutine.create(function()while true do local Y,Z=coroutine.yield()if Y==\"key\"and a5[Z.keycode]then a5[Z.keycode](Z.keycode)end end end)end;local function a6()s=true;for P,W in ipairs(q)do coroutine.resume(W)end;while s do if r then r()end;local Y,Z=coroutine.yield()for P,W in ipairs(q)do local a7=table.pack(coroutine.resume(W,Y,Z))while a7[1]and a7[2]~=nil do a7=table.pack(coroutine.resume(W,coroutine.yield(table.unpack(a7,1,a7.n))))end end end end;local a8={}function a8.message(a9,aa,ab)D(\"ENTER=Back\")E(aa)a4{[d.enter]=function()s=false end}a6()return ab(a9)end;function a8.loading(a9)D(\"Downloading package list...\")E(\"Please wait while Setup initializes.\")local ac,ad=f.get(k..\"Packages\")if not ac or ac:status()==\"error\"or ac:responseCode()~=200 then return a8.message(a9,\"An error occurred while initializing Setup: Could not download package list: \"..(ad or select(2,ac:status())or ac:responseCode())..\"\\n\\nSetup cannot continue. Press ENTER to exit.\",function()end)end;local ae;for I in function()return ac:read(\"*l\")end do local V,W=I:match(\"^([%w%-]+):%s*(.+)$\")if V then if V==\"Package\"then ae=W;t[ae]={}elseif V==\"Size\"then t[ae].pkgsize=tonumber(W)elseif V==\"Installed-Size\"then t[ae].filesize=tonumber(W)*1024 elseif V==\"Priority\"then t[ae].priority=W elseif V==\"Essential\"then t[ae].essential=true elseif V==\"Depends\"then local af={}for A in W:gmatch\"[^,]+\"do af[A:match\"[%w%-]+\"]=true end;t[ae].depends=af end end end;ac:close()B(\"Checking installed packages...\")a9.installed=j.readDatabase()return a8.components(a9)end;function a8.components(a9)local ab;D(\"ENTER=Continue  SPACE=Toggle  TAB=Quit\")E(\"Select the components to install from the list below.\\n[-] = required, [\\xD7] = selected\")local L={}for V,W in pairs(t)do if V~=\"stage2-tarball\"then if V==\"phoenix\"or V==\"phoenix-luz\"then if a9.installed[\"phoenix-luz\"]and V==\"phoenix-luz\"or a9.installed[\"phoenix\"]and V==\"phoenix\"then L[V]=\"R\"end elseif W.essential or W.priority==\"required\"or a9.spanfs_disks and(V==\"initrd-utils\"or V==\"spanfs\")then L[V]=\"R\"elseif W.priority==\"optional\"then L[V]=false else L[V]=true end end end;local function ag()local function ah(ae)if L[ae]and t[ae].depends then for V in pairs(t[ae].depends)do L[V]=\"R\"ah(V)end end end;for V,W in pairs(L)do L[V]=(t[V].essential or t[V].priority==\"required\")and\"R\"or not not W end;for V in pairs(L)do ah(V)end end;ag()J(nil,L,function(ai)a9.components={}local a1,aj={},{}for V,W in pairs(ai)do if W then local af={}for ak,w in pairs(t[V].depends or{})do af[ak]=w end;aj[V]=af;if not _G.next(af)then a1[#a1+1]=V end end end;while#a1>0 do local al=table.remove(a1)a9.components[#a9.components+1]=al;for V,W in pairs(aj)do if W[al]then W[al]=nil;if not _G.next(W)then a1[#a1+1]=V end end end end;ab,s=true,false end,function(V,W)L[V]=W;ag()return true end)a4{[d.tab]=function()s=false end}a6()if ab then return a8.confirm(a9)else return false end end;function a8.confirm(a9)D(\"Calculating packages to install...\")a9.install,a9.remove={},{}local ai={}local am={}for P,W in ipairs(a9.components)do am[W]=true;if not a9.installed[W]or a9.installed[W].Status:match\"^deinstall \"then a9.install[#a9.install+1]=W end end;for V,W in pairs(t)do if not am[V]and(a9.installed[V]and not a9.installed[V].Status:match\"^deinstall \")then ai[V]=true end end;local a1,aj={},{}for V in pairs(ai)do local af={}for ak,w in pairs(t[V].depends or{})do af[ak]=w end;aj[V]=af;if not _G.next(af)then a1[#a1+1]=V end end;while#a1>0 do local al=table.remove(a1)a9.remove[#a9.remove+1]=al;for V,W in pairs(aj)do if W[al]then W[al]=nil;if not _G.next(W)then a1[#a1+1]=V end end end end;local ab;B(\"ENTER=Install  TAB=Back  Q=Quit\")E(\"The following changes will be made:\\nTo install: \"..table.concat(a9.install,\", \")..\"\\nTo remove: \"..table.concat(a9.remove,\", \")..\"\\n\\nPress ENTER to install.\")a4{[d.enter]=function()ab,s=true,false end,[d.tab]=function()ab,s=false,false end,[d.q]=function()s=false end}a6()if ab then return a8.download(a9)elseif ab==false then return a8.components(a9)else return false end end;function a8.download(a9)pcall(e.create,\"install\",false,\"/var/log/install.log\")if#a9.install==0 then return a8.remove(a9)end;D(\"\")E\"Downloading components...\"local a3=a2()local an=0;for P in pairs(a9.install)do an=an+1 end;local al=0;a.mkdir(\"/tmp/pkg\")a.mount(\"tmpfs\",\"tmpfs\",\"/tmp/pkg\",{})for P,V in ipairs(a9.install)do B(\"Downloading: \"..V)local ac,ad=f.get{url=k..V..\".deb\",encoding=\"binary\"}if not ac then return a8.message(a9,\"An error occurred while downloading the \"..V..\" component. Installation cannot continue.\\n\\nPress ENTER to exit.\\n\\nError message: \"..ad,function()return false end)end;local ao,ad=io.open(\"/tmp/pkg/\"..V..\".deb\",\"wb\")if not ao then ac:close()return a8.message(a9,\"An error occurred while saving the \"..V..\" component. Installation cannot continue.\\n\\nPress ENTER to exit.\\n\\nError message: \"..ad,function()return false end)end;ao:write(ac:read(\"*a\"))ac:close()ao:close()al=al+1;a3(al/an)end;return a8.install(a9)end;function a8.install(a9)D(\"\")E\"Please wait while Phoenix installs the requested components.\"l.setCursorPos(3,p)l.write(\"\\x9C\"..(\"\\x8C\"):rep(n-6))l.setBackgroundColor(m.white)l.setTextColor(m.orange)l.write(\"\\x93\")for Q=p+1,o-2 do l.setCursorPos(l.getCursorPos()-1,Q)l.write(\"\\x95\")end;l.setBackgroundColor(m.orange)l.setTextColor(m.white)for Q=p+1,o-2 do l.setCursorPos(3,Q)l.write(\"\\x95\")end;l.setCursorPos(3,o-1)l.write(\"\\x8D\"..(\"\\x8C\"):rep(n-6)..\"\\x8E\")local ap=h.mktty(n-6,o-9)local aq=g.fork(function()h.stdout(ap)while true do local Y,Z=coroutine.yield()if Y==\"remote_event\"then if Z.type==\"write\"then e.install.log(Z.data.data)io.stdout:write(Z.data.data)elseif Z.type==\"exit\"then break end end end end,\"tty helper\")g.newthread(function()while s do for H=1,ap.size.height do l.setCursorPos(4,H+7)l.blit(table.unpack(ap[H]))end;i.sleep(0.2)end end)local function ar(...)local as=g.fork(function(...)h.stdout({write=function(at)c.sendEvent(aq,\"write\",{data=at})end})g.exec(...)end,\"\",...)while true do local Y,Z=coroutine.yield()if Y==\"process_complete\"and Z.id==as then if Z.error or Z.traceback then s=false;c.sendEvent(aq,\"exit\",{})D(\"ENTER=Exit\")E[[\nAn error occurred while installing the specified components.\n\nPress ENTER to exit.]]B(\"ENTER=Reboot\")repeat local Y,Z=coroutine.yield()until Y==\"key\"and Z.keycode==10;return false end;break end end end;for P,V in ipairs(a9.install)do B(\"Installing: \"..V)e.install.log(\"Installing:\",V)ar(\"/usr/bin/dpkg.lua\",\"-i\",\"/tmp/pkg/\"..V..\".deb\")end;pcall(c.kill,aq,c.signal.SIGTERM)a.unmount(\"/tmp/pkg\")a.remove(\"/tmp/pkg\")return a8.remove(a9)end;function a8.remove(a9)if#a9.remove==0 then return a8.complete(a9)end;D(\"\")E\"Please wait while Phoenix removes the requested components.\"l.setCursorPos(3,p)l.write(\"\\x9C\"..(\"\\x8C\"):rep(n-6))l.setBackgroundColor(m.white)l.setTextColor(m.orange)l.write(\"\\x93\")for Q=p+1,o-2 do l.setCursorPos(l.getCursorPos()-1,Q)l.write(\"\\x95\")end;l.setBackgroundColor(m.orange)l.setTextColor(m.white)for Q=p+1,o-2 do l.setCursorPos(3,Q)l.write(\"\\x95\")end;l.setCursorPos(3,o-1)l.write(\"\\x8D\"..(\"\\x8C\"):rep(n-6)..\"\\x8E\")local ap=h.mktty(n-6,o-9)local aq=g.fork(function()h.stdout(ap)while true do local Y,Z=coroutine.yield()if Y==\"remote_event\"then if Z.type==\"write\"then e.install.log(Z.data.data)io.stdout:write(Z.data.data)elseif Z.type==\"exit\"then break end end end end,\"tty helper\")g.newthread(function()while s do for H=1,ap.size.height do l.setCursorPos(4,H+7)l.blit(table.unpack(ap[H]))end;i.sleep(0.2)end end)local function ar(...)local as=g.fork(function(...)h.stdout({write=function(at)c.sendEvent(aq,\"write\",{data=at})end})g.exec(...)end,\"\",...)while true do local Y,Z=coroutine.yield()if Y==\"process_complete\"and Z.id==as then if Z.error or Z.traceback then s=false;c.sendEvent(aq,\"exit\",{})D(\"ENTER=Exit\")E[[\nAn error occurred while removing the specified components.\n\nPress ENTER to exit.]]B(\"ENTER=Reboot\")repeat local Y,Z=coroutine.yield()until Y==\"key\"and Z.keycode==10;return false end;break end end end;for Q=#a9.remove,1,-1 do local V=a9.remove[Q]B(\"Removing: \"..V)e.install.log(\"Removing:\",V)ar(\"/usr/bin/dpkg.lua\",\"-r\",V)end;pcall(c.kill,aq,c.signal.SIGTERM)return a8.complete(a9)end;function a8.complete(a9)local ab;D(\"ENTER=Exit  R=Reboot\")E[[\nThe selected components have successfully been installed or removed. It is recommended to reboot your system to ensure all components were installed properly.\n\n* Press R to reboot your system now.\n* Press ENTER to exit without rebooting.]]a4{[d.enter]=function()ab,s=false,false end,[d.r]=function()ab,s=true,false end}a6()e.remove(\"install\")if ab then local as=c.lookup(\"ServiceManager\")if as then c.sendEvent(as,\"startmgr.request\",{func=\"reboot\"})else i.syscall.devcall(\"/\",\"reboot\")end else return true end end;return a8.loading{}\n",setuser=false,size=12722,modified=1757997040394,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["apt-mark.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039612,data="\n",setuser=false,size=1,modified=1757997039599,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["apt-get.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039611,data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=require\"apt.config\"local d=require\"apt.cache\"local e=require\"apt.get\"local f=require\"dpkg\"local g=assert(b.argparse({},...))c:load()local function h(i,j,k,l,m,n)if not l then error(\"Some packages could not be installed. This may mean that you have requested an impossible situation.\")end;local o,p,q,r=0,0,0,0;for s,t in pairs(m)do if t then if f.package.packagedb[s]and f.package.packagedb[s].Status:match\" installed$\"then q=q+1 else o=o+1 end else p=p+1 end end;for s,t in pairs(f.package.packagedb)do local u=d:get(s)if u and f.compareVersions(u.version,t.Version)>0 and m[s]==nil then r=r+1 end end;if k and next(k)then print(\"The following packages have been kept back:\")io.write(\"  \")for s in pairs(k)do io.write(s..\" \")end;print(\"\")end;if q>0 then print(\"The following packages will be upgraded:\")io.write(\"  \")for s,t in pairs(m)do if t and f.package.packagedb[s]then io.write(s..\" \")end end;print(\"\")end;if o>#g-1 then print(\"The following additional packages will be installed:\")io.write(\"  \")for s,t in pairs(m)do if t and not j[s]then io.write(s..\" \")end end;print(\"\")end;if o>0 then print(\"The following packages will be installed:\")io.write(\"  \")for s,t in pairs(m)do if t then io.write(s..\" \")end end;print(\"\")end;if p>0 then print(\"The following packages will be REMOVED:\")io.write(\"  \")for s,t in pairs(m)do if not t then io.write(s..\" \")end end;print(\"\")end;print((\"%d upgraded, %d newly installed, %d to remove and %d not upgraded.\"):format(q,o,p,r))if#l==0 then return end;io.write(\"Do you want to continue? [Y/n] \")local v=io.read()if not v or v:lower()~=\"y\"then print(\"Abort.\")return end;local w={}for x,t in ipairs(n)do w[t]=e.download(t)end;e.execute(l,w,i)end;if g[1]==\"update\"then e.update()e.showStats()d:generate()elseif g[1]==\"download\"then d:load()for y=2,#g do local z=e.download(g[y])if z then a.copy(z,a.basename(z))end end;e.showStats()elseif g[1]==\"install\"then local j={}for y=2,#g do j[g[y]]=true end;io.write(\"Reading state information... \")f.package.setPackageDB()f.package.setTriggerDB()f.package.setFileDB()d:load()print(\"Done.\")h(false,j,nil,e.plan(f.package.packagedb,j,{}))elseif g[1]==\"remove\"or g[1]==\"purge\"then local j={}for y=2,#g do j[g[y]]=false end;io.write(\"Reading state information... \")f.package.setPackageDB()f.package.setTriggerDB()f.package.setFileDB()d:load()print(\"Done.\")h(g[1]==\"purge\",j,nil,e.plan(f.package.packagedb,j,{}))elseif g[1]==\"upgrade\"or g[1]==\"dist-upgrade\"or g[1]==\"full-upgrade\"then io.write(\"Reading state information... \")f.package.setPackageDB()f.package.setTriggerDB()f.package.setFileDB()d:load()print(\"Done.\")h(false,e.planUpgrade(f.package.packagedb,g[1]==\"dist-upgrade\"or g[1]==\"full-upgrade\",{}))elseif g[1]==\"autoremove\"then elseif g[1]==\"satisfy\"then else error(\"Unknown command '\"..g[1]..\"'\")end\n",setuser=false,size=2856,modified=1757997039598,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["dpkg-deb.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997040420,data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=require\"ar\"local d=require\"dpkg.deb\"local e=require\"tar\"local function f(g)return string.match(g,'^()[%s%z]*$')and''or string.match(g,'^[%s%z]*(.*[^%s%z])')end;local function h(i,j,k)return string.len(i)<j and string.sub(i,1,j)..string.rep(k or\" \",j-string.len(i))or i end;local function l(i,j,k)return string.len(i)<j and string.rep(k or\" \",j-string.len(i))..string.sub(i,1,j)or i end;local function m(n,o,p)a.mkdir(o)local q={}for r,s in pairs(n)do if r~=\"//\"and type(r)==\"string\"then local t=a.combine(o,r)if s[\"//\"]~=nil then local u=m(s,t,true)for v,w in pairs(u)do table.insert(q,w)end elseif s.type==1 or s.type==2 then table.insert(q,s)elseif s.type==0 or s.type==7 then local x=a.open(t,\"wb\")for g in string.gmatch(s.data,\".\")do x.write(string.byte(g))end;x.close()if s.owner~=nil then a.chmod(t,nil,bit32.band(s.mode,7))if s.ownerName~=nil and s.ownerName~=\"\"then a.chmod(t,s.ownerName,bit32.band(bit32.rshift(s.mode,3),7))a.chown(t,s.ownerName)elseif s.owner==0 then a.chmod(t,\"root\",bit32.band(bit32.rshift(s.mode,3),7))a.chown(t,\"root\")end end elseif s.type~=nil then print(\"Unimplemented type \"..s.type)end;if d.verbose then print((s[\"//\"]and s[\"//\"].name or s.name or\"?\")..\" => \"..(t or\"?\"))end end end;if p then return q else for r,s in pairs(q)do end end end;local function y(z,i,k)local A=\"\"for B=1,string.len(i)do A=A..(bit32.band(z,bit32.lshift(1,string.len(i)-B))==0 and k or string.sub(i,B,B))end;return A end;local C=nil;local D=false;local E=5;local F=\"${Package}\\t${Version}\\n\"local G=true;local H=true;local I={}for r,s in pairs({...})do if s==\"-b\"or s==\"--build\"then C=0 elseif s==\"-I\"or s==\"--info\"then C=1 elseif s==\"-W\"or s==\"--show\"then C=2 elseif s==\"-f\"or s==\"--field\"then C=3 elseif s==\"-c\"or s==\"--contents\"then C=4 elseif s==\"-x\"or s==\"--extract\"then C=5 elseif s==\"-X\"or s==\"--vextract\"then C=5;d.verbose=true elseif s=='-R'or s==\"--raw-extract\"then C=7 elseif s==\"--ctrl-tarfile\"then C=5;D=true elseif s==\"--fsys-tarfile\"then C=6;D=true elseif s==\"-e\"or s==\"--control\"then C=6 elseif s==\"-?\"or s==\"--help\"then print([[Usage: dpkg-deb [<option> ...] <command>\nCommands:\n  -b|--build <directory> [<deb>]     Build an archive.\n  -c|--contents <deb>                List contents.\n  -I|--info <deb> [<cfile> ...]      Show info to stdout.\n  -W|--show <deb>                    Show information on package(s)\n  -f|--field <deb> [<cfield> ...]    Show field(s) to stdout.\n  -e|--control <deb> [<directory>]   Extract control info.\n  -x|--extract <deb> <directory>     Extract files.\n  -X|--vextract <deb> <directory>    Extract & list files.\n  -R|--raw-extract <deb> <directory> Extract control info and files.\n  --ctrl-tarfile <deb>               Output control tarfile.\n  --fsys-tarfile <deb>               Output filesystem tarfile.\n  -?, --help                         Show this help message.\n      --version                      Show the version.]])return 2 elseif s==\"--version\"then print(\"dpkg-deb v1.0\\nPart of apt-lua for Phoenix\\nCopyright (c) 2019-2022 JackMacWindows.\")return 2 elseif string.find(s,\"--showformat=\")==1 then F=string.sub(s,14)elseif string.sub(s,1,2)==\"-z\"then E=tonumber(string.sub(s,3))elseif s==\"--no-uniform-compression\"then G=false elseif s==\"--uniform-compression\"then G=true elseif s==\"--nocheck\"then H=false elseif s==\"-v\"or s==\"--verbose\"then d.verbose=true else table.insert(I,s)end end;F=string.gsub(string.gsub(F,\"\\\\n\",\"\\n\"),\"\\\\t\",\"\\t\")if C==0 then if#I<1 then error(\"Usage: dpkg-deb [options...] --build <binary-directory> [archive|directory]\")end;local J=I[1]local K=I[2]or J..\".deb\"if not a.isDir(J)then error(J..\" is not a directory\")elseif not a.isDir(a.combine(J,\"DEBIAN\"))then error(\"A subdirectory named DEBIAN is required.\")end;if d.verbose and a.isDir(K)then print(\"Output is a directory, forcing check\")end;if H or a.isDir(K)then local x=a.open(a.combine(J,\"DEBIAN/control\"),\"r\")if not x then error(\"Control file not found.\")end;local A={}local L=nil;local M=x.readLine()local B=1;while M~=nil do if string.sub(M,1,1)==\" \"and L~=nil then if L==\"Description\"then if type(A[L])==\"string\"then A[L]={Short=A[L],Long=\"\"}end;A[L].Long=A[L].Long..(string.sub(M,2)==\".\"and\"\\n\\n\"or string.sub(M,2))else A[L]=A[L]..(string.sub(M,2)==\".\"and\"\\n\"or string.sub(M,2))end else if string.find(M,\":\")==nil then x.close()error(\"Error while checking control (line \"..B..\"): Missing separator\\n    \"..M)end;L=string.sub(M,1,string.find(M,\":\")-1)A[L]=f(string.sub(M,string.find(M,\":\")+1))end;M=x.readLine()B=B+1 end;x.close()if A.Package==nil then error(\"Error while checking control: Missing \\\"Package\\\" field\")end;if A.Version==nil then error(\"Error while checking control: Missing \\\"Version\\\" field\")end;if A.Architecture==nil then error(\"Error while checking control: Missing \\\"Architecture\\\" field\")end;if A.Maintainer==nil then error(\"Error while checking control: Missing \\\"Maintainer\\\" field\")end;if A.Description==nil then error(\"Error while checking control: Missing \\\"Description\\\" field\")end;if a.isDir(K)then K=a.combine(K,A.Package..\"_\"..A.Version..\"_\"..A.Architecture..\".deb\")end;print(\"Successfully checked package \\\"\"..A.Package..\"\\\".\")end;if d.verbose then print(\"Creating control archive...\")end;local N=e.save(e.pack(a.combine(J,\"DEBIAN\")))if d.verbose then print(\"Creating data archive...\")end;local n=e.pack(J)n.DEBIAN=nil;local O=e.save(n)if d.verbose then print(\"Compressing archives...\")end;local P=LibDeflate:CompressGzip(N,{level=G and E or 5})local Q=LibDeflate:CompressGzip(O,{level=E})if d.verbose then print(\"Writing package...\")end;c.save({{name=\"debian-binary\",timestamp=os.time(),owner=0,group=0,mode=0x1FF,data=\"2.0\\n\"},{name=\"control.tar.gz\",timestamp=os.time(),owner=0,group=0,mode=0x1FF,data=P},{name=\"data.tar.gz\",timestamp=os.time(),owner=0,group=0,mode=0x1FF,data=Q}},K)elseif C==1 then if#I<1 then error(\"Usage: dpkg-deb [options...] --info <archive> [control-file-name...]\")end;local R=d.load(I[1])print(\"new Debian package, version 2.0.\")print(\"size \"..R.data_size..\" bytes: control archive=\"..R.control_size..\" bytes.\")local S={}local T={0,0,0}for r,s in pairs(R.control_archive)do if r~=\"//\"then local U=0;for u in string.gmatch(s.data or\"\",\"[^\\n]+\")do U=U+1 end;local t={tostring(string.len(s.data or\"\")),tostring(U),r}for u,w in pairs(t)do if string.len(w)+2>T[u]then T[u]=string.len(w)+2 end end;table.insert(S,t)end end;for r,s in pairs(S)do print(l(s[1],T[1])..\" bytes,\"..l(s[2],T[2])..\" lines   \"..h(s[3],T[3]))end;print(R.control_archive.control.data)elseif C==2 then if#I<1 then error(\"Usage: dpkg-deb [options...] --show <archive>\")end;local R=d.load(I[1])io.write(({string.gsub(F,\"%${(.-)}\",R.control)})[1])elseif C==3 then if#I<1 then error(\"Usage: dpkg-deb [options...] --field <archive> [control-field-name...]\")end;local R=d.load(I[1])local function H(s)if type(s)==\"table\"then return s.Short..\"\\n\"..s.Long else return s end end;for r,s in pairs(R.control)do if#I>1 then for u,w in pairs(I)do if r==w then print(r..\": \"..H(s))break end end else print(r..\": \"..H(s))end end elseif C==4 then if#I<1 then error(\"Usage: dpkg-deb [options...] --contents <archive>\")end;local R=d.load(I[1],true)local V={}local T={0,0,0,0,0}for r,s in pairs(R.data)do local W=os.date(\"%F %R\",s.timestamp or 0)local t={y(s.mode+(s.type==5 and 0x200 or 0),\"drwxrwxrwx\",\"-\"),(s.ownerName or s.owner or 0)..\"/\"..(s.groupName or s.group or 0),string.len(s.data or\"\"),W,s.name..(s.link and s.link~=\"\"and\" -> \"..s.link or\"\")}for u,w in pairs(t)do if string.len(w)+1>T[u]then T[u]=string.len(w)+1 end end;table.insert(V,t)end;for r,s in pairs(V)do for u,w in pairs(s)do io.write((u==3 and l or h)(w,T[u])..(u==3 and\" \"or\"\"))end;print(\"\")end elseif C~=nil and C>=5 and C<=7 then if#I<1 or not D and C~=6 and#I<2 then error(\"Usage: dpkg-deb [options...] --extract <archive> <directory>\")end;local R=d.load(I[1],false,D)local X=I[2]or(C==6 and\"DEBIAN\"or b.getcwd())if not D then a.mkdir(X)end;if C~=6 then if D then print(R[2])else m(R.data,X)end end;if C~=5 then if D then print(R[1])else m(R.control_archive,C==7 and a.combine(X,\"DEBIAN\")or X)end end else error(\"Usage: dpkg-deb [options...] <command>\")end\n",setuser=false,size=8167,modified=1757997040395,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["sha1sum.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997042486,data="return coroutine.yield(\"syscall\",\"exec\",\"/usr/bin/shasum\",\"-a\",\"1\",...)\n",setuser=false,size=72,modified=1757997042478,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["sudo.lua"]={permissions={root={write=true,read=true,execute=true}},created=1757997043163,data="coroutine.yield(\"syscall\",\"debug_enable\",nil,false)local a=require\"usermgr\"local b=require\"system.ipc\"local c=require\"system.process\"local d=require\"system.terminal\"local e=require\"system.util\"if not d.istty()then return false end;local f=assert(e.argparse({[\"\"]={stopProcessingOnPositionalArgument=true},D=true,chdir=\"@D\",E=false,[\"preserve-env\"]=\"@E\",H=false,[\"set-home\"]=\"@H\",i=false,login=\"@i\",K=false,[\"remove-timestamp\"]=\"@K\",k=false,[\"reset-timestamp\"]=\"@k\",l=false,list=\"@l\",n=false,[\"non-interactive\"]=\"@n\",p=true,prompt=\"@p\",R=true,chroot=\"@R\",s=false,shell=\"@s\",U=true,[\"other-user\"]=\"@U\",T=\"number\",[\"command-timeout\"]=\"@T\",u=true,user=\"@u\",v=false,validate=\"@v\",V=false,version=\"@V\",h=false,help=\"@h\"},...))local g,h=c.getuser()if g~=\"root\"then error(\"This program must be run as root. Make sure the setuser bit is set.\")end;if not f[1]or f.h then print(\":help\")return end;local i=f.u or f.user or\"root\"io.stdout:write(\"Password: \")d.termctl({echo=false})local j=io.stdin:read()d.termctl({echo=true})print()local k,l=a.authenticate(h,j)if l then print(l)end;if k then local m=a.getUserInfo(i)local n=c.fork(function()c.setuser(i)if m and m.home then c.getenv().HOME=m.home;c.chdir(m.home)end;c.execp(table.unpack(f))end)for o,p in pairs(b.signal)do b.sigaction(p,function()b.kill(n,p)end)end;repeat local q,r=coroutine.yield()until q==\"process_complete\"and r.id==n else print(\"sudo: Sorry\")end\n",setuser=true,size=1407,modified=1757997043110,worldPermissions={write=false,read=true,execute=true},type="file",owner="root"},["apt-cache.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039610,data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=require\"apt.config\"local d=require\"apt.cache\"local e=require\"muxzcat\"local f=require\"LibDeflate\"local g=assert(b.argparse({p=true,[\"pkg-cache\"]=\"@p\",s=true,[\"src-cache\"]=\"@s\",q=false,quiet=\"@q\",i=false,important=\"@i\",[\"no-pre-depends\"]=false,[\"no-depends\"]=false,[\"no-recommends\"]=false,[\"no-suggests\"]=false,[\"no-conflictss\"]=false,[\"no-breaks\"]=false,[\"no-replaces\"]=false,[\"no-enhances\"]=false,implicit=false,f=false,full=\"@f\",a=false,[\"all-versions\"]=\"@a\",g=false,generate=\"@g\",[\"no-generate\"]=false,n=false,[\"names-only\"]=\"@n\",[\"all-names\"]=false,recurse=false,installed=false,[\"with-source\"]=true,h=false,help=\"@h\",v=false,version=\"@v\",c=true,[\"config-file\"]=\"@c\",o=\"multiple\",option=\"@o\"},...))if g.v then print(\"apt-cache 1.0\")return end;if not g[1]or g.h then print[[\nUsage: apt-cache [options] command\n       apt-cache [options] show pkg1 [pkg2 ...]\n\napt-cache queries and displays available information about installed\nand installable packages. It works exclusively on the data acquired\ninto the local cache via the 'update' command of e.g. apt-get. The\ndisplayed information may therefore be outdated if the last update was\ntoo long ago, but in exchange apt-cache works independently of the\navailability of the configured sources (e.g. offline).\n\nMost used commands:\n  showsrc - Show source records\n  search - Search the package list for a regex pattern\n  depends - Show raw dependency information for a package\n  rdepends - Show reverse dependency information for a package\n  show - Show a readable record for the package\n  pkgnames - List the names of all packages in the system\n  policy - Show policy settings\n\nSee apt-cache(8) for more information about the available commands.\nConfiguration options and syntax is detailed in apt.conf(5).\nInformation about how to configure sources can be found in sources.list(5).\nPackage and version choices can be expressed via apt_preferences(5).\nSecurity details are available in apt-secure(8).\n]]return end;c:load()if g.c then local h=assert(io.open(g.c,\"r\"))local i=h:read(\"*a\")h:close()c:append(i)end;if g.o then for j,k in ipairs(g.o)do local l,m=k:match(\"^([A-Za-z0-9/%-:%._+])=(.*)$\")if not l then error(\"Invalid option: \"..k)end;local n={}for o in l:match(\"[^:]+\")do n[#n+1]=o end;local p=c;for q=1,#n-1 do local o=n[q]:lower()if not p[o]then p[o]={}end;p=p[o]end;p[n[#n]]=m end end;if g[1]==\"gencaches\"then d:generate()elseif g[1]==\"showpkg\"then if not g[\"no-generate\"]then d:generate()end;d:load()for q=2,#g do local r=d:get(g[q])if r then print(\"Package: \"..r.name)print(\"Versions:\")print(r.version)print(\"Reverse Depends:\")for j,k in ipairs(r.depended)do print(\"  \"..k.package..\",\"..r.name..\" \"..(k.version or\"\"))end;print(\"Dependencies:\")io.write(r.version..\" - \")for j,k in ipairs(r.depends)do io.write(k.package..\" (\"..(k.relation or\"0\")..\" \"..(k.version or\"(null)\")..\") \")end;print()print(\"Provides:\")io.write(r.version..\" - \")for j,k in ipairs(r.provides)do io.write(k.package..\"(= \"..(k.version or\"(null)\")..\") \")end;print()end end elseif g[1]==\"stats\"then elseif g[1]==\"showsrc\"then elseif g[1]==\"dump\"then elseif g[1]==\"dumpavail\"then elseif g[1]==\"unmet\"then elseif g[1]==\"show\"then if not g[\"no-generate\"]then d:generate()end;d:load()for q=2,#g do local r=d:get(g[q])if r then local s=assert(d:getRepo(r.repoIndex))local t=c:get(\"Acquire\",\"IndexTargets\",\"deb\",\"Packages\",\"MetaKey\"):gsub(\"%$%(COMPONENT%)\",s.component):gsub(\"%$%(ARCHITECTURE%)\",s.architecture)local u=a.combine(s.url:gsub(\"^.-://\",\"\"),\"dists\",s.suite,t):gsub(\"[/:]\",\"_\")local v=a.combine(c:getPath(\"State\",\"lists\"),u)local i;local h=io.open(v,\"r\")if h then i=h:read(\"*a\")h:close()else h=io.open(v..\".xz\",\"rb\")if h then local w=h:read(\"*a\")h:close()i=e.DecompressXzOrLzmaString(w)else h=io.open(v..\".gz\",\"rb\")if h then local x=h:read(\"*a\")h:close()i=f:DecompressGzip(x)end end end;if i then print(i:match(\"(Package: \"..r.name..\".-)\\n\\n\")or i:match(\"(Package: \"..r.name..\".-)$\")or\"Could not find package in Packages list.\")else error(\"Could not find Packages file for owner repository.\")end end end elseif g[1]==\"search\"then if not g[\"no-generate\"]then d:generate()end;d:load(true)local y={}for o,k in pairs(d.db.packagesByName)do if o:find(g[2],1,true)then local s=d:getRepo(k.repoIndex)y[#y+1]=o..\"/\"..s.suite..\" \"..k.version..\" \"..s.architecture end end;table.sort(y)for j,k in ipairs(y)do print(k)end elseif g[1]==\"depends\"then elseif g[1]==\"rdepends\"then elseif g[1]==\"pkgnames\"then else error(\"Unknown command '\"..g[1]..\"'\")end\n",setuser=false,size=4543,modified=1757997039597,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["apt-config.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039611,data="local a=require\"system.util\"local b=require\"apt.config\"local c=assert(a.argparse({empty=false,[\"no-empty\"]=false,format=true,h=false,help=\"@h\",v=false,version=\"@v\",c=true,[\"config-file\"]=\"@c\",o=\"multiple\",option=\"@o\"},...))if c.v then print(\"apt-config 1.0\")return end;if not c[1]or c.h then print[[\nUsage: apt-config [options] command\n\napt-config is an interface to the configuration settings used by\nall APT tools, mainly intended for debugging and shell scripting.\n\nMost used commands:\n  shell - get configuration values via shell evaluation\n  dump - show the active configuration setting\n\nSee apt-config(8) for more information about the available commands.\nConfiguration options and syntax is detailed in apt.conf(5).\nInformation about how to configure sources can be found in sources.list(5).\nPackage and version choices can be expressed via apt_preferences(5).\nSecurity details are available in apt-secure(8).\n]]return end;b:load()if c.c then local d=assert(io.open(c.c,\"r\"))local e=d:read(\"*a\")d:close()b:append(e)end;if c.o then for f,g in ipairs(c.o)do local h,i=g:match(\"^([A-Za-z0-9/%-:%._+])=(.*)$\")if not h then error(\"Invalid option: \"..g)end;local j={}for k in h:match(\"[^:]+\")do j[#j+1]=k end;local l=b;for m=1,#j-1 do local k=j[m]:lower()if not l[k]then l[k]={}end;l=l[k]end;l[j[#j]]=i end end;if c[1]==\"dump\"then local n=c.f or'%f \"%v\";%n'local function o(p,h,i)return{[\"%f\"]=p..h,[\"%t\"]=h,[\"%v\"]=i,[\"%n\"]=\"\\n\",[\"%%\"]=\"%\"}end;local function q(p,r)for k,g in pairs(r)do if type(g)==\"table\"then local s=g._ or\"\"if not c[\"no-empty\"]or s~=\"\"then local t=n:gsub(\"%%%a\",o(p,k,s))io.write(t)end;q(p..k..\"::\",g)elseif type(g)==\"string\"and(not c[\"no-empty\"]or g~=\"\")then local t=n:gsub(\"%%%a\",o(p,k,g))io.write(t)end end end;q(\"\",b)else error(\"Unknown command '\"..c[1]..\"'\")end\n",setuser=false,size=1788,modified=1757997039597,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["certutil.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997040937,data="\n",setuser=false,size=1,modified=1757997040930,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["yahtcc.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997043301,data="local a=require\"system.util\"local b=require\"system.keys\"local c=require\"system.terminal\"local d=require\"system.hardware\"local e,f=c.openterm()if not e then error(\"Could not open terminal: \"..f)end;local g={[0]={0xA0,0xA0,0xA0,0xA0,0xA0,0xA0},{0x20,0x10,0x95,0x8f,0x8f,0x85},{0x08,0x20,0x95,0x8f,0x8d,0x85},{0x08,0x10,0x95,0x8f,0x8d,0x85},{0x08,0x08,0x95,0x8d,0x8d,0x85},{0x08,0x18,0x95,0x8d,0x8d,0x85},{0x97,0x97,0x95,0x8d,0x8d,0x85}}local h={{0x2F,0x34,0x00,0x38,0x1F,0x00,0x00,0x28,0x14,0x00,0x00,0x3C,0x00,0x00,0x38,0x3C,0x14,0x20,0x3C,0x3C},{0x00,0x0B,0x3F,0x07,0x00,0x00,0x00,0x2A,0x15,0x00,0x0F,0x3F,0x0F,0x2A,0x17,0x00,0x00,0x3F,0x01,0x00},{0x00,0x00,0x3F,0x00,0x38,0x0F,0x3E,0x2A,0x1F,0x2F,0x14,0x3F,0x00,0x2A,0x15,0x00,0x00,0x3F,0x00,0x00},{0x00,0x00,0x3F,0x00,0x0B,0x3C,0x2F,0x2A,0x15,0x2A,0x15,0x3F,0x00,0x02,0x2F,0x3C,0x14,0x0B,0x3D,0x3C}}local i={{0x00,0x3C,0x30,0x30,0x38,0x14,0x00},{0x00,0x15,0x17,0x17,0x15,0x15,0x00},{0x00,0x15,0x15,0x15,0x15,0x15,0x00},{0x00,0x35,0x15,0x15,0x35,0x15,0x00},{0x00,0x03,0x0F,0x0F,0x07,0x01,0x00}}local j={{{name=\"\"},{name=\"Ones\",score=function(k)local l=0;for m,n in ipairs(k)do if n.value==1 then l=l+n.value end end;return l end},{name=\"Twos\",score=function(k)local l=0;for m,n in ipairs(k)do if n.value==2 then l=l+n.value end end;return l end},{name=\"Threes\",score=function(k)local l=0;for m,n in ipairs(k)do if n.value==3 then l=l+n.value end end;return l end},{name=\"Fours\",score=function(k)local l=0;for m,n in ipairs(k)do if n.value==4 then l=l+n.value end end;return l end},{name=\"Fives\",score=function(k)local l=0;for m,n in ipairs(k)do if n.value==5 then l=l+n.value end end;return l end},{name=\"Sixes\",score=function(k)local l=0;for m,n in ipairs(k)do if n.value==6 then l=l+n.value end end;return l end},{name=\"Bonus\"}},{{name=\"Three of a Kind\",score=function(k)local o={0,0,0,0,0,0}local p=false;local q=0;for m,n in ipairs(k)do o[n.value]=o[n.value]+1;q=q+n.value;if o[n.value]>=3 then p=true end end;return p and q or 0 end},{name=\"Four of a Kind\",score=function(k)local o={0,0,0,0,0,0}local p=false;local q=0;for m,n in ipairs(k)do o[n.value]=o[n.value]+1;q=q+n.value;if o[n.value]>=4 then p=true end end;return p and q or 0 end},{name=\"Full House\",score=function(k,r)local o={0,0,0,0,0,0}for m,n in ipairs(k)do o[n.value]=o[n.value]+1 end;local s,t,u=false,false,nil;for n=1,6 do if o[n]==3 then s=true elseif o[n]==2 then t=true elseif o[n]==5 then u=n end end;if u and r[2][6].locked and not r[1][u+1].locked then return 25 end;return s and t and 25 or 0 end},{name=\"Small Straight\",score=function(k,r)local o={0,0,0,0,0,0}local u=nil;for m,n in ipairs(k)do o[n.value]=o[n.value]+1;if o[n.value]==5 then u=n.value end end;if u and r[2][6].locked and not r[1][u+1].locked then return 30 end;if o[3]==0 or o[4]==0 then return 0 elseif o[1]~=0 and o[2]~=0 or o[2]~=0 and o[5]~=0 or o[5]~=0 and o[6]~=0 then return 30 end;return 0 end},{name=\"Large Straight\",score=function(k,r)local o={0,0,0,0,0,0}local u=nil;for m,n in ipairs(k)do o[n.value]=o[n.value]+1;if o[n.value]==5 then u=n.value end end;if u and r[2][6].locked and not r[1][u+1].locked then return 40 end;if o[2]==0 or o[3]==0 or o[4]==0 or o[5]==0 then return 0 end;return(o[1]~=0 or o[6]~=0)and 40 or 0 end},{name=\"Yahtzee\",score=function(k)local v=k[1].value;for m,n in ipairs(k)do if v~=n.value then return 0 end end;return 50 end},{name=\"Chance\",score=function(k)local q=0;for m,n in ipairs(k)do q=q+n.value end;return q end},{name=\"Yahtzee Bonus\"}}}local function w(x,y,z,A)A=A or'0'local B='f'local C=g[z]e.setCursorPos(x,y)for n=1,3 do local v=C[n]if v==0x20 then e.blit(' ',B,A)elseif v<0x80 then e.blit(string.char(v+0x80),B,A)else e.blit(string.char(v),A,B)end end;e.setCursorPos(x,y+1)for n=4,6 do local v=C[n]if v==0x20 then e.blit(' ',B,A)elseif v<0x80 then e.blit(string.char(v+0x80),B,A)else e.blit(string.char(v),A,B)end end;e.setBackgroundColor(c.colors.black)e.setTextColor(c.colors.white)end;local function D(x,y,k)for z,n in ipairs(k)do w(x+(z-1)*3,y,n.value,n.locked and'4'or'0')end end;local function E(F,G,H)H=H or'0'for y=1,4 do e.setCursorPos(F,G+y-1)for m,v in ipairs(h[y])do local B,A=H,'f'if bit32.btest(v,0x20)then B,A=A,B;v=bit32.band(bit32.bnot(v),0x1F)end;v=bit32.bor(v,0x80)if v==0x80 then v=0x20 end;e.blit(string.char(v),B,A)end end;e.setBackgroundColor(c.colors.black)e.setTextColor(c.colors.white)end;local function I(F,G,J,K)J=J or'b'for y=1,5 do e.setCursorPos(F-1,G+y-1)for x,v in ipairs(i[y])do local B,A;if y>1 and y<5 and x>1 and x<6 then B,A=J,'8'else B,A=J,'f'end;if bit32.btest(v,0x20)then B,A=A,B;v=bit32.band(bit32.bnot(v),0x1F)end;v=bit32.bor(v,0x80)if v==0x80 then v=0x20 end;e.blit(string.char(v),B,A)end end;e.setCursorPos(F-6,G+2)e.setBackgroundColor(c.colors.black)e.setTextColor(c.colors.white)e.write(K and\"      \"or\" Roll \")end;local function L(x,y,r,M,N)e.setBackgroundColor(c.colors.black)e.setCursorBlink(false)for O=1,2 do for n,P in ipairs(j[O])do local Q=O==M and n==N;e.setBackgroundColor(Q and c.colors.white or(n%2==1 and c.colors.black or c.colors.gray))e.setTextColor(Q and c.colors.black or c.colors.white)e.setCursorPos(x+(O-1)*20,y+n-1)e.write(P.name..(' '):rep(16-#P.name))if not r[O][n].locked and not P.bonus then if r[O][n].value==0 then e.setTextColor(c.colors.lightGray)else e.setTextColor(c.colors.lightBlue)end else e.setTextColor(Q and c.colors.black or c.colors.white)end;if r[O][n].value==nil then e.write(\"   \")elseif r[O][n].value<10 then e.write(\"  \"..r[O][n].value)else e.write(\" \"..r[O][n].value)end end end;e.setBackgroundColor(c.colors.black)e.setTextColor(c.colors.white)end;local function R(x,y,r,S)e.setCursorPos(x,y)e.write(\"Score: \")local q=0;for O=1,2 do for n,P in ipairs(r[O])do if P.value and P.locked then q=q+P.value end end end;e.write(q)e.setCursorPos(x,y+1)e.write(\"Rolls remaining: \"..S)e.setBackgroundColor(c.colors.black)e.setTextColor(c.colors.white)end;local function T(r,k)for O=1,2 do for n,P in ipairs(j[O])do if not r[O][n].locked and P.score then r[O][n].value=P.score(k,r)end end end;if r[2][6].locked and r[2][6].value==50 then local v=k[1].value;for m,n in ipairs(k)do if v~=n.value then return r end end;r[2][8].value=100;r[2][8].locked=true end;return r end;local function U(r,V,W)if V then r[V][W].locked=true end;for O=1,2 do for n,P in ipairs(r[O])do if not P.locked then P.value=nil end end end;if(r[1][2].locked and r[1][2].value or 0)+(r[1][3].locked and r[1][3].value or 0)+(r[1][4].locked and r[1][4].value or 0)+(r[1][5].locked and r[1][5].value or 0)+(r[1][6].locked and r[1][6].value or 0)+(r[1][7].locked and r[1][7].value or 0)>=63 then r[1][8].value=35;r[1][8].locked=true end;return r end;local X=d.find(\"speaker\")local function Y(k,Z,_,a0,a1,J,a2)for m,P in ipairs(k)do if not P.locked then P.value=0 end end;D(Z,_,k)for n=1,4 do I(a0,a1,J,true)if X then X:playNote(\"hat\",2,12)X:playNote(\"hat\",2,7)end;a.sleep(0.1)I(a0+1,a1,J,true)if X then X:playNote(\"hat\",2,11)X:playNote(\"hat\",2,6)end;a.sleep(0.1)I(a0,a1,J,true)if X then X:playNote(\"hat\",2,12)X:playNote(\"hat\",2,7)end;a.sleep(0.1)I(a0-1,a1,J,true)if X then X:playNote(\"hat\",2,11)X:playNote(\"hat\",2,6)end;a.sleep(0.1)end;if X then X:playNote(\"hat\",2,3)X:playNote(\"hat\",2,6)end;for m,P in ipairs(k)do if not P.locked then P.value=math.random(1,6)end end;I(a0,a1,J,a2)D(Z,_,k)return k end;local a3={dice={x=2,y=17},rollCup={x=36,y=15},logo={x=2,y=2},status={x=23,y=3},scores={x=2,y=7}}local k={{value=0},{value=0},{value=0},{value=0},{value=0}}local r={{{},{},{},{},{},{},{},{}},{{},{},{},{},{},{},{},{}}}local a4=3;local a5,a6=false,0;local a7=0;local a8=0xb;math.randomseed(os.time())e.clear()E(a3.logo.x,a3.logo.y)R(a3.status.x,a3.status.y,r,a4)L(a3.scores.x,a3.scores.y,r)D(a3.dice.x,a3.dice.y,k)I(a3.rollCup.x,a3.rollCup.y,('%x'):format(a8))while a7<13 do local a9,aa=coroutine.yield()if a9==\"key\"then if aa.keycode==b.r and a4>0 and not(k[1].locked and k[2].locked and k[3].locked and k[4].locked and k[5].locked)then a4=a4-1;U(r)L(a3.scores.x,a3.scores.y,r)R(a3.status.x,a3.status.y,r,a4)Y(k,a3.dice.x,a3.dice.y,a3.rollCup.x,a3.rollCup.y,('%x'):format(a8),a4<1)T(r,k)if a4==0 then a5=false;a6=2;while a6<=7 and r[1][a6].locked do a6=a6+1 end;if a6>7 then a5=true;a6=1;while a6<=7 and r[2][a6].locked do a6=a6+1 end;if a6>7 then a6=0 end end;L(a3.scores.x,a3.scores.y,r,a5 and 2 or 1,a6)else a5,a6=false,0;L(a3.scores.x,a3.scores.y,r)end elseif aa.keycode==b.one and a4<3 and a4>0 then k[1].locked=not k[1].locked;D(a3.dice.x,a3.dice.y,k)elseif aa.keycode==b.two and a4<3 and a4>0 then k[2].locked=not k[2].locked;D(a3.dice.x,a3.dice.y,k)elseif aa.keycode==b.three and a4<3 and a4>0 then k[3].locked=not k[3].locked;D(a3.dice.x,a3.dice.y,k)elseif aa.keycode==b.four and a4<3 and a4>0 then k[4].locked=not k[4].locked;D(a3.dice.x,a3.dice.y,k)elseif aa.keycode==b.five and a4<3 and a4>0 then k[5].locked=not k[5].locked;D(a3.dice.x,a3.dice.y,k)elseif aa.keycode==b.q then break elseif aa.keycode==b.up and a4<3 then if a6==0 then a5=false;a6=2;while a6<=7 and r[1][a6].locked do a6=a6+1 end;if a6>7 then a5=true;a6=1;while a6<=7 and r[2][a6].locked do a6=a6+1 end;if a6>7 then a6=0 end end end;if a6>(a5 and 1 or 2)then local ab=a6;repeat a6=a6-1 until a6<(a5 and 1 or 2)or not r[a5 and 2 or 1][a6].locked;if a6<(a5 and 1 or 2)then a6=ab end end;L(a3.scores.x,a3.scores.y,r,a5 and 2 or 1,a6)elseif aa.keycode==b.down and a4<3 then if a6==0 then a5=false;a6=7;while a6>=2 and r[1][a6].locked do a6=a6-1 end;if a6<2 then a5=true;a6=7;while a6>=1 and r[2][a6].locked do a6=a6-1 end;if a6<1 then a6=0 end end end;if a6>0 and a6<7 then local ab=a6;repeat a6=a6+1 until a6>7 or not r[a5 and 2 or 1][a6].locked;if a6>7 then a6=ab end end;L(a3.scores.x,a3.scores.y,r,a5 and 2 or 1,a6)elseif(aa.keycode==b.left or aa.keycode==b.right)and a4<3 and a6~=1 and(a6==0 or not r[a5 and 1 or 2][a6].locked)then if a6==0 then a5=aa.keycode==b.right;a6=a5 and 1 or 2;while a6<=7 and r[a5 and 2 or 1][a6].locked do a6=a6+1 end;if a6>7 then a5=not a5;a6=a5 and 1 or 2;while a6<=7 and r[a5 and 2 or 1][a6].locked do a6=a6+1 end;if a6>7 then a6=0 end end else a5=not a5 end;L(a3.scores.x,a3.scores.y,r,a5 and 2 or 1,a6)elseif aa.keycode==b.enter and a6~=0 and a4<3 and not r[a5 and 2 or 1][a6].locked then U(r,a5 and 2 or 1,a6)k={{value=0},{value=0},{value=0},{value=0},{value=0}}a4=3;R(a3.status.x,a3.status.y,r,a4)L(a3.scores.x,a3.scores.y,r)D(a3.dice.x,a3.dice.y,k)I(a3.rollCup.x,a3.rollCup.y,('%x'):format(a8))a7=a7+1 elseif aa.keycode==b.c then a8=a8+1;if a8>0xf then a8=0x0 end;I(a3.rollCup.x,a3.rollCup.y,('%x'):format(a8))end elseif a9==\"mouse_click\"and aa.button==1 then if(aa.x>=a3.rollCup.x and aa.x<a3.rollCup.x+5 and aa.y>=a3.rollCup.y and aa.y<a3.rollCup.y+5 or aa.x>=a3.rollCup.x-5 and aa.x<a3.rollCup.x-1 and aa.y==a3.rollCup.y+2)and a4>0 and not(k[1].locked and k[2].locked and k[3].locked and k[4].locked and k[5].locked)then a4=a4-1;U(r)L(a3.scores.x,a3.scores.y,r)R(a3.status.x,a3.status.y,r,a4)Y(k,a3.dice.x,a3.dice.y,a3.rollCup.x,a3.rollCup.y,('%x'):format(a8),a4<1)T(r,k)if a4==0 then a5=false;a6=2;while a6<=7 and r[1][a6].locked do a6=a6+1 end;if a6>7 then a5=true;a6=1;while a6<=7 and r[2][a6].locked do a6=a6+1 end;if a6>7 then a6=0 end end;L(a3.scores.x,a3.scores.y,r,a5 and 2 or 1,a6)else a5,a6=false,0;L(a3.scores.x,a3.scores.y,r)end elseif aa.x>=a3.dice.x and aa.x<a3.dice.x+15 and aa.y>=a3.dice.y and aa.y<a3.dice.y+2 and a4<3 and a4>0 then k[math.floor((aa.x-a3.dice.x)/3)+1].locked=not k[math.floor((aa.x-a3.dice.x)/3)+1].locked;D(a3.dice.x,a3.dice.y,k)elseif aa.x>=a3.scores.x and aa.x<a3.scores.x+40 and aa.y>=a3.scores.y and aa.y<a3.scores.y+7 and a4<3 then local V,W=aa.x-a3.scores.x>=20,aa.y-a3.scores.y+1;if a5==V and a6==W and not r[V and 2 or 1][W].locked then U(r,a5 and 2 or 1,a6)k={{value=0},{value=0},{value=0},{value=0},{value=0}}a4=3;R(a3.status.x,a3.status.y,r,a4)L(a3.scores.x,a3.scores.y,r)D(a3.dice.x,a3.dice.y,k)I(a3.rollCup.x,a3.rollCup.y,('%x'):format(a8))a7=a7+1 elseif(V or W>1)and not r[V and 2 or 1][W].locked then a5=V;a6=W;L(a3.scores.x,a3.scores.y,r,a5 and 2 or 1,a6)end end end end;if a7==13 then for n=1,3 do E(a3.logo.x,a3.logo.y,'5')a.sleep(0.5)E(a3.logo.x,a3.logo.y,'0')a.sleep(0.5)end;E(a3.logo.x,a3.logo.y,'5')a.sleep(1)end;e.close()local q=0;for O=1,2 do for n,P in ipairs(r[O])do if P.value and P.locked then q=q+P.value end end end;print(\"Final score: \"..q)print(\"Thanks for playing YahtCC!\")\n",setuser=false,size=12358,modified=1757997043293,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["pdb.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997041666,data="local a=require\"system.filesystem\"local b=require\"system.ipc\"local c=require\"system.pretty\"local d=require\"system.process\"local e=require\"system.terminal\"local f=require\"system.util\"local g,h,i,j,k,l,m;local n={[\"nil\"]=function()return\"nil\"end,[\"boolean\"]=function(o)return o and\"true\"or\"false\"end,[\"number\"]=tostring,[\"string\"]=function(p)return(\"%q\"):format(p)end,[\"table\"]=function(q)return\"<\"..tostring(q)..\">\"end,[\"function\"]=function(q)return\"<\"..tostring(q)..\">\"end,[\"thread\"]=function(q)return\"<\"..tostring(q)..\">\"end,[\"userdata\"]=function(q)return\"<\"..tostring(q)..\">\"end}local function r()local s=d.debug.getinfo(g,h,i)if s then local t={}for u=1,s.nparams do local v,w=d.debug.getlocal(g,h,i,u)t[u]=(\"\\x1b[36m%s\\x1b[0m=%s\"):format(v,n[type(w)](w))end;print((\"\\x1b[94m0x%s\\x1b[0m in \\x1b[93m%s\\x1b[0m (%s) at \\x1b[32m%s\\x1b[0m:%d\"):format(tostring(s.func):gsub(\"^function: \",\"\"),s.name or s.what==\"main\"and\"<main chunk>\"or\"???\",table.concat(t,\", \"),s.short_src,s.currentline))if s.source and s.source:match(\"^@\")then local x=a.open(s.source:sub(2),\"r\")if x then local y;for z=1,s.currentline do y=x.readLine()end;x.close()if y then print(s.currentline,y)end end end end end;local function A()local B,C;repeat B,C=coroutine.yield()until B==\"debug_break\"and C.process==g or B==\"process_complete\"and C.id==g;if B==\"process_complete\"then print(\"Process exited: \"..g)g,h,j=nil,nil,false;return end;d.debug.brk(g)local s=d.getpinfo(g)if s.threads[C.thread].name==\"<user mode callback>\"or s.threads[C.thread].name==\"<signal handler:2>\"then C.thread=0;while not s.threads[C.thread]do C.thread=C.thread+1 end end;h=C.thread;i=1;if C.breakpoint then if C.breakpoint~=m then print(\"\\x1b[93mThread \"..h..\": Breakpoint \"..C.breakpoint..\"\\x1b[0m\")end elseif C.error then print(\"\\x1b[93mThread \"..h..\": Error: \"..n[type(C.error)](C.error)..\"\\x1b[0m\")else print(\"\\x1b[93mThread \"..h..\": Break\\x1b[0m\")end;if m then d.debug.unsetbreakpoint(g,m)m=nil end;r()end;local D={}function D.run(...)if j then print(\"Target is already running\")end;print(\"Starting process: \"..g)k=table.pack(...)j=true;d.debug.continue(g)A()end;D.r=D.run;D[\"break\"]=function(E)local F,y=E:match\"^(.+):(%d+)$\"if F then F=F:match\"^/.*$\"or a.combine(d.getcwd(),F)local G=d.debug.setbreakpoint(g,nil,\"call\",{source=\"@\"..F,currentline=tonumber(y)})print(\"Breakpoint \"..G..\": File \"..F..\", line \"..y)else local G=d.debug.setbreakpoint(g,nil,\"call\",{name=E})print(\"Breakpoint \"..G..\": Function \"..E)end end;D.brea=D[\"break\"]D.bre=D.brea;D.br=D.brea;D.b=D.brea;function D.delete(G)G=assert(tonumber(G),\"Invalid ID\")d.debug.unsetbreakpoint(g,G)end;D.del=D.delete;D.d=D.delete;function D.continue()print(\"Continuing.\")d.debug.continue(g)A()end;D.c=D.continue;function D.step()local s=d.debug.getinfo(g,h,i)m=d.debug.setbreakpoint(g,h,\"line\",{func=s.func})d.debug.continue(g)A()end;D.s=D.step;function D.next()m=d.debug.setbreakpoint(g,h,\"line\",nil)d.debug.continue(g)A()end;D.n=D.next;function D.stepi()local s=d.debug.getinfo(g,h,i)m=d.debug.setbreakpoint(g,h,1,{func=s.func})d.debug.continue(g)A()end;D.si=D.stepi;function D.nexti()m=d.debug.setbreakpoint(g,h,1,nil)d.debug.continue(g)A()end;D.ni=D.nexti;function D.backtrace()for H=1,math.huge do local s=d.debug.getinfo(g,h,H)if not s then break end;local t={}for u=1,s.nparams do local v,w=d.debug.getlocal(g,h,H,u)t[u]=(\"%s=%s\"):format(v,n[type(w)](w))end;print((\"#%-2d \\x1b[94m0x%s\\x1b[0m in \\x1b[93m%s\\x1b[0m (%s) at \\x1b[32m%s\\x1b[0m:%d\"):format(H,tostring(s.func):gsub(\"^function: \",\"\"),s.name or s.what==\"main\"and\"<main chunk>\"or\"???\",table.concat(t,\", \"),s.short_src,s.currentline))end end;D.bt=D.backtrace;D.where=D.backtrace;function D.catch(type,C)if type==\"catch\"or type==\"error\"then elseif type==\"exec\"then elseif type==\"fork\"then elseif type==\"load\"then elseif type==\"syscall\"then elseif type==\"throw\"then end end;function D.skip()end;function D.print(...)local I=table.concat({...},\" \")local J={}for H=1,math.huge do local K,q=d.debug.getupvalue(g,h,i,H)if not K then break end;J[K]=q end;for H=1,math.huge do local K,q=d.debug.getlocal(g,h,i,H)if not K then break end;J[K]=q end;local L,M=d.debug.exec(g,h,function()local N,O=load(\"return \"..I,\"=expr\",\"t\",setmetatable(J,{__index=_ENV,__newindex=function(z,K,q)_ENV[K]=q end}))if not N then return false,O end;return pcall(N)end)if L then c.pretty_print(M)else io.stderr:write(M..\"\\n\")end end;D.p=D.print;D.inspect=D.print;function D.advance(P)end;function D.detach()end;function D.finish()m=d.debug.setbreakpoint(g,h,\"return\",nil)d.debug.continue(g)A()end;D.fin=D.finish;function D.interrupt()d.debug.brk(g)A()end;function D.attach(G)if g then d.debug.enable(g,false)end;g=assert(tonumber(G),\"Invalid process ID\")d.debug.enable(g,true)d.debug.brk(g)b.sigaction(b.signal.SIGINT,function()d.debug.brk(g)end)j=true;l=true;A()end;function D.thread(Q)Q=assert(tonumber(Q),\"Invalid thread ID\")local s=d.getpinfo(g)if not s.threads[Q]then error(\"Invalid thread\")end;h=Q;i=1;r()end;D.t=D.thread;function D.frame(Q)Q=assert(tonumber(Q),\"Invalid frame ID\")local s=d.debug.getinfo(g,h,Q)if not s then error(\"Invalid frame\")end;i=Q;r()end;D.f=D.frame;function D.down(Q)local s=d.debug.getinfo(g,h,i-1)if not s then error(\"Invalid frame\")end;i=i-1;r()end;function D.up(Q)local s=d.debug.getinfo(g,h,i+1)if not s then error(\"Invalid frame\")end;i=i+1;r()end;D[\"return\"]=function()local s=d.debug.getinfo(g,h,i)m=d.debug.setbreakpoint(g,h,\"return\",{func=s.func})d.debug.continue(g)A()end;function D.info(type,C)if type==\"args\"then print(table.concat(k,\" \"))elseif type==\"breakpoints\"or type==\"b\"then elseif type==\"display\"then elseif type==\"files\"then elseif type==\"frame\"then c.pretty_print(d.debug.getinfo(g,h,i))elseif type==\"functions\"then elseif type==\"line\"then elseif type==\"locals\"then for H=1,math.huge do local K,q=d.debug.getlocal(g,h,i,H)if not K then break end;print(K..\" = \"..n[_G.type(q)](q))end elseif type==\"modules\"then elseif type==\"proc\"then elseif type==\"program\"then elseif type==\"registers\"then elseif type==\"scope\"then elseif type==\"source\"then elseif type==\"stack\"then elseif type==\"target\"then elseif type==\"threads\"then local R=d.getpinfo(g)for G,S in pairs(R.threads)do local s=d.debug.getinfo(g,G,1)print((\"%s %-2d %q - %s at %s:%d\"):format(G==h and\"*\"or\" \",G,S.name,s.name or(s.what==\"main\"and\"<main chunk>\"or\"???\"),s.source or\"???\",s.currentline or\"???\"))end elseif type==\"variables\"then end end;D.i=D.info;D.inf=D.info;local function T(F)local U=false;g=d.fork(function()b.sigaction(b.signal.SIGINT,function()d.debug.brk()end)repeat d.debug.brk()until U;d.exec(F,table.unpack(k or{}))end,F)d.debug.enable(g,true)repeat local B,C=coroutine.yield()until B==\"debug_break\"and C.process==g;U=true;j=false;l=false end;print(\"Phoenix Debugger\")local F=...if F then T(F)end;local V={}while true do io.write(\"\\x1b[93m(pdb) \\x1b[0m\")local y=e.readline2(V)if y~=V[1]then table.insert(V,1,y)end;local W=f.split(y)if W[1]==\"quit\"or W[1]==\"q\"or W[1]==\"exit\"then if not j then return end;d.debug.enable(g,false)if not l then b.kill(g,b.signal.SIGTERM)end;return elseif W[1]then local X=D[W[1]]if X then local L,O=pcall(X,table.unpack(W,2,W.n))if not L then io.stderr:write(tostring(O)..\"\\n\")end end end end\n",setuser=false,size=7185,modified=1757997041664,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["sha224sum.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997042486,data="return coroutine.yield(\"syscall\",\"exec\",\"/usr/bin/shasum\",\"-a\",\"224\",...)\n",setuser=false,size=74,modified=1757997042479,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["usermod.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997043164,data="local a=require\"usermgr\"local b=require\"system.filesystem\"local c=require\"system.process\"local d=require\"system.util\"local e=[[\nUsage: useradd [options] LOGIN\n       useradd -D\n       useradd -D [options]\nOptions:\n  -c, --comment COMMENT    new full name of the account\n  -d, --home HOME_DIR      new home directory of the account\n  -h, --help               display this help message and exit\n  -m, --move-home          move the user's home directory\n  -s, --shell SHELL        new login shell of the account\n]]local f=assert(d.argparse({c=true,comment=\"@c\",d=true,home=\"@d\",h=false,help=\"@h\",m=false,[\"move-home\"]=\"@m\",s=true,shell=\"@s\"},...))if f.h then print(e)return end;if not f[1]then io.stderr:write(e..\"\\n\")return false end;local g=c.getuser()if g~=\"root\"and g~=f[1]then error(\"usermod: Permission denied.\")end;local h=a.getUserInfo(f[1])if not h then error(\"usermod: User does not exist.\")end;if f.s==\"\"then f.s=\"/bin/cash\"end;assert(a.editUser(f[1],{fullName=f.c,home=f.d,shell=f.s}),\"usermod: Could not modify user.\")if f.m and f.d and h.home~=f.d then b.move(h.home,f.d)end\n",setuser=false,size=1086,modified=1757997043112,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["userdel.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997043164,data="local a=require\"usermgr\"local b=require\"system.filesystem\"local c=require\"system.process\"local d=require\"system.util\"local e=[[\nUsage: userdel [options] LOGIN\nOptions:\n  -f, --force   force some actions that would fail otherwise\n                e.g. removal of user still logged in\n                or files, even if not owned by the user\n  -h, --help    display this help message and exit\n  -r, --remove  remove home directory\n]]local f=assert(d.argparse({f=false,force=\"@f\",h=false,help=\"@h\",r=false,remove=\"@r\"},...))if f.h then print(e)return end;if not f[1]then io.stdout:write(e..\"\\n\")return false end;if c.getuser()~=\"root\"then error(\"userdel: Permission denied.\")end;local g=a.getUserInfo(f[1])if not g then error(\"userdel: User does not exist.\")end;if not f.f then local h=c.getplist()for i,j in ipairs(h)do if c.getpinfo(j).user==f[1]then error(\"userdel: User is currently logged in.\")end end end;assert(a.removeUser(f[1]),\"userdel: Could not delete user.\")if f.r and g.home then b.remove(g.home)end\n",setuser=false,size=1009,modified=1757997043111,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["mktablefs.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997040840,data="local a=require\"system.filesystem\"local b=require\"system.serialization\"local function c(d)local e=a.stat(d)if not e then return nil end;e.freeSpace,e.capacity,e.special,e.mountpoint=nil;if e.type==\"file\"then local f=assert(io.open(d,\"rb\"))e.data=f:read(\"*a\")f:close()elseif e.type==\"directory\"then e.contents={}for g,h in ipairs(a.list(d))do e.contents[h]=c(a.combine(d,h))end end;return e end;local i,j=...if not j then error(\"Usage: mktablefs <input directory> <output file>\")end;local e=c(i)b.lua.save(e,j,{minified=true})\n",setuser=false,size=526,modified=1757997040827,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["useradd.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997043163,data="local a=require\"usermgr\"local b=require\"system.filesystem\"local c=require\"system.process\"local d=require\"system.util\"local e=[[\nUsage: useradd [options] LOGIN\n       useradd -D\n       useradd -D [options]\nOptions:\n  -b, --base-dir BASE_DIR  base directory for the home directory of the new account\n  -c, --comment COMMENT    full name of the new account\n  -d, --home-dir HOME_DIR  home directory of the new account\n  -D, --defaults           print or change default useradd configuration\n  -f, --inactive INACTIVE  password inactivity period of the new account\n  -h, --help               display this help message and exit\n  -k, --skel SKEL_DIR      use this alternative skeleton directory\n  -K, --key KEY=VALUE      override /etc/login.defs defaults\n  -m, --create-home        create the user's home directory\n  -M, --no-create-home     do not create the user's home directory\n  -p, --password PASSWORD  password of the new account\n  -s, --shell SHELL        login shell of the new account\n]]local f=assert(d.argparse({b=true,[\"base-dir\"]=\"@b\",c=true,comment=\"@c\",d=true,[\"home-dir\"]=\"@d\",D=false,defaults=\"@D\",f=\"number\",inactive=\"@f\",h=false,help=\"@h\",k=true,skel=\"@k\",K=\"multiple\",key=\"@K\",m=false,[\"create-home\"]=\"@m\",M=false,[\"no-create-home\"]=\"@M\",p=true,password=\"@p\",s=true,shell=\"@s\"},...))if f.h then print(e)return end;local g={HOME=\"/home\",INACTIVE=-1,SHELL=\"/bin/cash\",SKEL=\"/etc/skel\"}do local h=io.open(\"/etc/default/useradd\",\"r\")if h then for i in h:lines()do local j,k=i:gsub(\"#.*$\",\"\"):match\"^([^=]+)=(.*)$\"if j and k then g[j]=type(g[j])==\"number\"and tonumber(k)or k end end;h:close()end end;for l,i in ipairs(f.K or{})do local j,k=i:match\"^([^=]+)=(.*)$\"if j and k then g[j]=type(g[j])==\"number\"and tonumber(k)or k end end;if f.D then if f.b or f.f or f.s then if c.getuser()~=\"root\"then error(\"useradd: Permission denied.\")end;if f.b then g.HOME=f.b end;if f.f then g.INACTIVE=f.f end;if f.s then g.SHELL=f.s end;local h=assert(io.open(\"/etc/default/useradd\",\"w\"))for m,n in pairs(g)do h:write(m..\"=\"..n..\"\\n\")end;h:close()else for m,n in pairs(g)do print(m..\"=\"..n)end end;return end;if not f[1]then io.stderr:write(e..\"\\n\")return false end;if c.getuser()~=\"root\"then error(\"useradd: Permission denied.\")end;local o=f.d or b.combine(f.b or g.HOME,f[1])local p=f.f or g.INACTIVE;if p<0 then p=nil end;assert(a.addUser(f[1],f.p,{fullName=f.c,home=o,shell=f.s or g.SHELL,lockTime=p}))if f.m and not f.M then b.mkdir(o)b.chmod(o,f[1],\"rwx\")b.chmod(o,nil,\"r-x\")b.chown(o,f[1])local q=f.k or g.SKEL;if q and b.isDir(q)then local function r(s)local t=b.stat(s,true)if t.permissions[t.owner]then b.chmod(s,f[1],t.permissions[t.owner])end;b.chown(s,f[1])if t.type==\"directory\"then for l,n in ipairs(b.list(s))do r(b.combine(s,n))end end end;for l,n in ipairs(b.list(q))do b.copy(b.combine(q,n),b.combine(o,n),true)r(b.combine(o,n))end end end\n",setuser=false,size=2857,modified=1757997043111,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["passwd.lua"]={permissions={root={write=true,read=true,execute=true}},created=1757997043162,data="coroutine.yield(\"syscall\",\"debug_enable\",nil,false)local a=require\"usermgr\"local b=require\"system.process\"local c=require\"system.terminal\"local d=require\"system.util\"if not c.istty()then return false end;local e,f=b.getuser()f=f or e;if e~=\"root\"then error(\"This program must be run as root. Make sure the setuser bit is set.\")end;local g=assert(d.argparse({a=false,all=\"@a\",d=false,delete=\"@d\",e=false,expire=\"@e\",h=false,help=\"@h\",i=\"number\",inactive=\"@i\",k=false,[\"keep-tokens\"]=\"@k\",l=false,lock=\"@l\",n=\"number\",mindays=\"@n\",q=false,quiet=\"@q\",S=false,status=\"@S\",u=false,unlock=\"@u\",w=\"number\",warndays=\"@w\",x=\"number\",maxdays=\"@x\"},...))if g.h then print[[\nUsage: passwd [options] [LOGIN]\nOptions:\n  -a, --all                 report password status on all accounts\n  -d, --delete              delete the password for the named account\n  -e, --expire              force expire the password for the named account\n  -h, --help                display this help message and exit\n  -k, --keep-tokens         change password only if expired\n  -i, --inactive INACTIVE   set password inactive after expiration to INACTIVE\n  -l, --lock                lock the password of the named account\n  -n, --mindays MIN_DAYS    set minimum number of days before password change to MIN_DAYS\n  -q, --quiet               quiet mode\n  -S, --status              report password status on the named account\n  -u, --unlock              unlock the password of the named account\n  -w, --warndays WARN_DAYS  set expiration warning days to WARN_DAYS\n  -x, --maxdays MAX_DAYS    set maximum number of days before password change to MAX_DAYS \n]]return elseif g.S then local function h(i)local j=a.getUserInfo(i)if not j then print(\"passwd: could not find user\")return end;print(i,j.hasPassword and(j.isLocked and\"L\"or\"P\")or\"NP\",os.date(\"%F\",j.lastChange),j.nextChange and(j.nextChange-j.lastChange)/86400 or 0,j.expirationTime and(j.expirationTime-j.lastChange)/86400 or 0,j.expirationWarning and(j.expirationTime-j.expirationWarning)/86400 or 0,-1)end;if g.a then if f~=\"root\"then error(\"passwd: Permission denied.\")end;for k in io.lines(\"/etc/passwd\")do h(k:match(\"^[^:]+\"))end else h(f)end;return end;local i=g[1]or f;if g.d then assert(f==\"root\",\"passwd: Permission denied.\")return a.setPassword(i,nil)elseif g.e then assert(f==\"root\",\"passwd: Permission denied.\")return a.setPassword(i,nil,{expirationTime=0})elseif g.l then assert(f==\"root\",\"passwd: Permission denied.\")return a.setPassword(i,nil,{isLocked=true})elseif g.u then assert(f==\"root\",\"passwd: Permission denied.\")return a.setPassword(i,nil,{isLocked=false})else local j=a.getUserInfo(i)if not j then io.stderr:write(\"passwd: User not found.\\n\")return false end;if j.isLocked then io.stderr:write(\"passwd: User is locked.\\n\")return false end;if not g.q then print(\"Changing password for \"..i..\".\")end;local l;if f~=\"root\"then if not g.q then io.stdout:write(\"Old password: \")end;c.termctl({echo=false})l=io.stdin:read()c.termctl({echo=true})print()end;if not g.q then io.stdout:write(\"New password: \")end;c.termctl({echo=false})local m=io.stdin:read()c.termctl({echo=true})print()if not g.q then io.stdout:write(\"Confirm password: \")end;c.termctl({echo=false})local n=io.stdin:read()c.termctl({echo=true})print()if l and not a.authenticate(i,l)then if not g.q then io.stderr:write(\"passwd: Incorrect old password.\\n\")end;return false elseif m==n then return a.setPassword(i,m,{nextChange=g.n,expirationTime=g.x,expirationWarning=g.w,lockTime=g.i})else if not g.q then io.stderr:write(\"passwd: Passwords do not match.\\n\")end;return false end end\n",setuser=true,size=3585,modified=1757997043108,worldPermissions={write=false,read=true,execute=true},type="file",owner="root"},["nc.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997041601,data="\n",setuser=false,size=1,modified=1757997041595,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["apt-key.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039612,data="\n",setuser=false,size=1,modified=1757997039599,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["unxz.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997041460,data="local a=require\"muxzcat\"local b=setmetatable({},{__index=function(self,c)return function(...)local d=table.pack(coroutine.yield(\"syscall\",c,...))if d[1]then return table.unpack(d,2,d.n)else error(d[2],2)end end end,__newindex=function()end})local function e()print([[Usage: unxz [OPTION]... [FILE]...\nDecompress FILEs in the .xz format.\n\n  -k, --keep         keep (don't delete) input files\n  -f, --force        force overwrite of output file\n  -c, --stdout       write to standard output and don't delete input files\n  -h, --help         display this help and exit\n  -V, --version      display the version number and exit\n\nReport bugs to https://github.com/MCJack123/CC-Archive/issues.\nUses JackMacWindows's Lua port of muxzcat. Licensed under GPL v2.0.]])end;local f={}local g=false;local h=false;local i=false;local j=false;for k,l in ipairs({...})do if#l==2 then if l==\"-z\"or l==\"-t\"or l==\"-l\"then error(\"unxz: This program only supports decompression.\")elseif l==\"-k\"then g=true elseif l==\"-f\"then h=true elseif l==\"-c\"then i=true;g=true elseif l==\"-h\"then return e()elseif l==\"-V\"then print(\"unxz 0.9 for Phoenix\")return end elseif l:sub(1,2)==\"--\"then if l==\"--compress\"or l==\"--test\"or l==\"--list\"then error(\"unxz: This program only supports decompression.\")elseif l==\"--keep\"then g=true elseif l==\"--force\"then h=true elseif l==\"--stdout\"or l==\"--to-stdout\"then i=true elseif l==\"--ignore-check\"then j=true elseif l==\"--help\"then return e()elseif l==\"--version\"then print(\"unxz 0.9 for Phoenix\")return end else table.insert(f,l)end end;local m=true;if#f==0 then error(\"unxz: Missing input. Type --help for help.\")end;for k,l in ipairs(f)do if not b.stat(l)then io.stderr:write(\"unxz: Could not open \"..l..\": File not found\\n\")elseif b.stat(l).type==\"directory\"then io.stderr:write(\"unxz: Could not open \"..l..\": Is a directory\\n\")elseif l:sub(-3)~=\".xz\"then io.stderr:write(\"unxz: \"..l..\": Filename has an unknown suffix, skipping\\n\")elseif not h and b.stat(l:sub(1,-4))then io.stderr:write(\"unxz: \"..l:sub(1,-4)..\": File exists\\n\")elseif i then local n=assert(io.open(l,\"rb\"))local o=n:read(\"*a\")n:close()local p,q=a.DecompressXzOrLzmaString(o)if p==nil then io.stderr:write(\"unxz: \"..l..\": Could not decompress: \"..a.GetError(q)..\"\\n\")m=false else io.stdout:write(p)end else local r,q=a.DecompressXzOrLzmaFile(l,l:sub(1,-4))if not r then io.stderr:write(\"unxz: \"..l..\": Could not decompress: \"..a.GetError(q)..\"\\n\")m=false elseif not g then os.remove(l)end end end;return m\n",setuser=false,size=2485,modified=1757997041458,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["su.lua"]={permissions={root={write=true,read=true,execute=true}},created=1757997043162,data="coroutine.yield(\"syscall\",\"debug_enable\",nil,false)local a=require\"usermgr\"local b=require\"system.ipc\"local c=require\"system.process\"local d=require\"system.terminal\"local e=require\"system.util\"if not d.istty()then return false end;local f=assert(e.argparse({[\"\"]={stopProcessingOnPositionalArgument=true},s=true,shell=\"@s\"},...))local g=f.s or f.shell;local h=f[1]or\"root\"io.stdout:write(\"Password: \")d.termctl({echo=false})local i=io.stdin:read()d.termctl({echo=true})print()local j,k=a.authenticate(h,i)if k then print(k)end;if j then local l=a.getUserInfo(h)local m=c.fork(function()c.setuser(h)if l and l.home then c.getenv().HOME=l.home;c.chdir(l.home)end;if g then c.exec(g,table.unpack(f,2))elseif l and l.shell then c.exec(l.shell,table.unpack(f,2))else c.exec(\"/bin/sh\",table.unpack(f,2))end end)for n,o in pairs(b.signal)do b.sigaction(o,function()b.kill(m,o)end)end;repeat local p,q=coroutine.yield()until p==\"process_complete\"and q.id==m else print(\"su: Sorry\")end\n",setuser=true,size=977,modified=1757997043109,worldPermissions={write=false,read=true,execute=true},type="file",owner="root"},["dpkg.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997040423,data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=require\"dpkg\"local d=require\"dpkg.divert\"local e=require\"dpkg.query\"local f=require\"dpkg.trigger\"local function g(h)return a.combine(c.admindir,h)end;local function i(j,k)local l=a.open(j,\"w\")l.write(k)l.close()end;local function m(n,o)return({string.match(n.Status,\"(%S+) (%S+) (%S+)\")})[o]end;local function p(n,o,q)local r={string.match(n.Status,\"(%S+) (%S+) (%S+)\")}r[o]=q;n.Status=table.concat(r,\" \")return n.Status end;local function s(t)local b=io.popen(\"/bin/less\",\"w\")b:write(t)b:close()end;local u=[[Usage: dpkg [<option> ...] <command>\n\nCommands:\n    -i|--install       <.deb file name> ... | -R|--recursive <directory> ...\n    --unpack           <.deb file name> ... | -R|--recursive <directory> ...\n    -A|--record-avail  <.deb file name> ... | -R|--recursive <directory> ...\n    --configure        <package> ... | -a|--pending\n    --triggers-only    <package> ... | -a|--pending\n    -r|--remove        <package> ... | -a|--pending\n    -P|--purge         <package> ... | -a|--pending\n    -V|--verify <package> ...        Verify the integrity of package(s).\n    --get-selections [<pattern> ...] Get list of selections to stdout.\n    --set-selections                 Set package selections from stdin.\n    --clear-selections               Deselect every non-essential package.\n    --update-avail [<Packages-file>] Replace available packages info.\n    --merge-avail [<Packages-file>]  Merge with info from file.\n    --clear-avail                    Erase existing available info.\n    --forget-old-unavail             Forget uninstalled unavailable pkgs.\n    -s|--status <package> ...        Display package status details.\n    -p|--print-avail <package> ...   Display available version details.\n    -L|--listfiles <package> ...     List files 'owned' by package(s).\n    -l|--list [<pattern> ...]        List packages concisely.\n    -S|--search <pattern> ...        Find package(s) owning file(s).\n    -C|--audit [<package> ...]       Check for broken package(s).\n    --yet-to-unpack                  Print packages selected for installation.\n    --predep-package                 Print pre-dependencies to unpack.\n    --add-architecture <arch>        Add <arch> to the list of architectures.\n    --remove-architecture <arch>     Remove <arch> from the list of architectures.\n    --print-architecture             Print dpkg architecture.\n    --print-foreign-architectures    Print allowed foreign architectures.\n    --assert-<feature>               Assert support for the specified feature.\n    --validate-<thing> <string>      Validate a <thing>'s <string>.\n    --compare-versions <a> <op> <b>  Compare version numbers - see below.\n    --force-help                     Show help on forcing.\n    -Dh|--debug=help                 Show help on debugging.\n\n    -?, --help                       Show this help message.\n        --version                    Show the version.\n\nAssertable features: support-predepends, working-epoch, long-filenames,\n    multi-conrep, multi-arch, versioned-provides.\n\nValidatable things: pkgname, archname, trigname, version.\n\nUse dpkg with -b, --build, -c, --contents, -e, --control, -I, --info,\n    -f, --field, -x, --extract, -X, --vextract, --ctrl-tarfile, --fsys-tarfile\non archives (type dpkg-deb --help).\n\nOptions:\n    --admindir=<directory>     Use <directory> instead of /var/lib/dpkg.\n    --root=<directory>         Install on a different root directory.\n    --instdir=<directory>      Change installation dir without changing admin dir.\n    --path-exclude=<pattern>   Do not install paths which match a shell pattern.\n    --path-include=<pattern>   Re-include a pattern after a previous exclusion.\n    -O|--selected-only         Skip packages not selected for install/upgrade.\n    -E|--skip-same-version     Skip packages whose same version is installed.\n    -G|--refuse-downgrade      Skip packages with earlier version than installed.\n    -B|--auto-deconfigure      Install even if it would break some other package.\n    --[no-]triggers            Skip or force consequential trigger processing.\n    --verify-format=<format>   Verify output format (supported: 'rpm').\n    --no-debsig                Do not try to verify package signatures.\n    --no-act|--dry-run|--simulate\n                               Just say what we would do - don't do it.\n    -D|--debug=<octal>         Enable debugging (see -Dhelp or --debug=help).\n    --status-fd <n>            Send status change updates to file descriptor <n>.\n    --status-logger=<command>  Send status change updates to <command>'s stdin.\n    --log=<filename>           Log status changes and actions to <filename>.\n    --ignore-depends=<package>,...\n                               Ignore dependencies involving <package>.\n    --force-...                Override problems (see --force-help).\n    --no-force-...|--refuse-...\n                               Stop when problems encountered.\n    --abort-after <n>          Abort after encountering <n> errors.\n\nComparison operators for --compare-versions are:\n    lt le eq ne ge gt       (treat empty version as earlier than any version);\n    lt-nl le-nl ge-nl gt-nl (treat empty version as later than any version);\n    < << <= = >= >> >       (only for compatibility with control file syntax).\n\nUse 'apt' or 'aptitude' for user-friendly package management.]]local v={}local w=nil;local x=false;local y=false;local z=nil;local A,B;local C,D;for E,F in ipairs({...})do if w~=nil then table.insert(v,F)elseif string.match(F,\"^%-[^-]\")then local G=string.sub(F,2,2)if G=='i'then w=0 elseif G=='r'then w=4 elseif G=='P'then w=5 elseif G=='V'then w=6 elseif G=='C'then w=7 elseif G=='?'then if c.options.pager then s(u)else print(u)end;return elseif G=='D'then elseif G=='b'or G=='c'or G=='e'or G=='x'or G=='X'or G=='f'or G=='I'then w=13 elseif G=='l'or G=='s'or G=='L'or G=='S'or G=='p'then w=14 elseif G=='B'then c.options.auto_deconfigure=true elseif G=='R'then x=true elseif G=='G'then c.force.downgrade=false elseif G=='O'then y=true elseif G=='E'then c.options.skip_same_version=true end else local H;if string.find(F,\"=\")then F,H=string.match(F,\"^(.+)=(.+)$\")end;if F==\"--install\"then w=0 elseif F==\"--unpack\"then w=1 elseif F==\"--configure\"then w=2 elseif F==\"--triggers-only\"then w=3 elseif F==\"--remove\"then w=4 elseif F==\"--purge\"then w=5 elseif F==\"--verify\"then w=6 elseif F==\"--audit\"then w=7 elseif F==\"--get-selections\"then w=8 elseif F==\"--set-selections\"then w=9 elseif F==\"--clear-selections\"then w=10 elseif F==\"--print-architecture\"then print(\"phoenix\")return elseif string.match(F,\"^%-%-assert%-\")then if F==\"--assert-support-predepends\"then return 0 elseif F==\"--assert-working-epoch\"then return 0 elseif F==\"--assert-long-filenames\"then return 0 elseif F==\"--assert-multi-conrep\"then return 1 elseif F==\"--assert-multi-arch\"then return 1 elseif F==\"--assert-versioned-provides\"then return 0 else return 2 end elseif string.match(F,\"^%-%-validate%-\")then w=11;z=string.match(F,\"^%-%-validate%-(.+)\")elseif F==\"--compare-verisons\"then w=12 elseif F==\"--help\"then if c.options.pager then s(u)else print(u)end;return elseif F==\"--force-help\"then(c.options.pager and s or print)([[dpkg forcing options - control behaviour when problems found:\nwarn but continue:  --force-<thing>,<thing>,...\nstop with error:    --refuse-<thing>,<thing>,... | --no-force-<thing>,...\nForcing things:\n[!] all                Set all force options\n[*] downgrade          Replace a package with a lower version\n    configure-any      Configure any package which may help this one\n    hold               Process incidental packages even when on hold\n    bad-verify         Install a package even if it fails authenticity check\n    bad-version        Process even packages with wrong versions\n    overwrite          Overwrite a file from one package with another\n    overwrite-diverted Overwrite a diverted file with an undiverted version\n[!] overwrite-dir      Overwrite one package's directory with another's file\n[!] confnew            Always use the new config files, don't prompt\n[!] confold            Always use the old config files, don't prompt\n[!] confdef            Use the default option for new config files if one\n                        is available, don't prompt. If no default can be found,\n                        you will be prompted unless one of the confold or\n                        confnew options is also given\n[!] confmiss           Always install missing config files\n[!] confask            Offer to replace config files with no new versions\n[!] architecture       Process even packages with wrong or no architecture\n[!] breaks             Install even if it would break another package\n[!] conflicts          Allow installation of conflicting packages\n[!] depends            Turn all dependency problems into warnings\n[!] depends-version    Turn dependency version problems into warnings\n[!] remove-reinstreq   Remove packages which require installation\n[!] remove-essential   Remove an essential package\n\nWARNING - use of options marked [!] can seriously damage your installation.\nForcing options marked [*] are enabled by default.]])return elseif F==\"--build\"or F==\"--contents\"or F==\"--control\"or F==\"--extract\"or F==\"--vextract\"or F==\"--field\"or F==\"--ctrl-tarfile\"or F==\"--fsys-tarfile\"or F==\"--info\"then w=13 elseif F==\"--list\"or F==\"--status\"or F==\"--listfiles\"or F==\"--search\"or F==\"--print-avail\"then w=14 elseif F==\"--auto-deconfigure\"then c.options.auto_deconfigure=true elseif F==\"--debug\"then elseif string.match(F,\"^%-%-force%-\")or string.match(F,\"^%-%-no%-force%-\")or string.match(F,\"^%-%-refuse%-\")then local I=string.match(F,\"^%-%-force%-\")~=nil;local J=F:gsub(\"^%-%-force%-\",\"\"):gsub(\"^%-%-no%-force%-\",\"\"):gsub(\"^%-%-refuse%-\",\"\")if J==\"downgrade\"then c.force.downgrade=I elseif J==\"configure-any\"then c.force.configure_any=I elseif J==\"hold\"then c.force.hold=I elseif J==\"remove-reinstreq\"then c.force.remove_reinstreq=I elseif J==\"remove-essential\"then c.force.remove_essential=I elseif J==\"depends\"then c.force.depends=I elseif J==\"depends-version\"then c.force.depends_version=I elseif J==\"breaks\"then c.force.breaks=I elseif J==\"conflicts\"then c.force.conflicts=I elseif J==\"confmiss\"then c.force.confmiss=I elseif J==\"confnew\"and c.force.confmode~=2 then c.force.confmode=0 elseif J==\"confold\"and c.force.confmode~=2 then c.force.confmode=1 elseif J==\"confdef\"then c.force.confmode=2 elseif J==\"confask\"and c.force.confmode==nil then c.force.confmode=nil elseif J==\"overwrite\"then c.force.overwrite=I elseif J==\"overwrite-dir\"then c.force.overwrite_dir=I elseif J==\"overwrite-diverted\"then c.force.overwrite_diverted=I elseif J==\"architecture\"then c.force.architecture=I elseif J==\"bad-version\"then c.force.bad_version=I elseif J==\"bad-verify\"then c.force.bad_verify=I end elseif F==\"--ignore-depends\"then for E,F in ipairs(split(H,\",\"))do c.options.ignore_depends[F]=true end elseif F==\"--no-act\"or F==\"--dry-run\"or F==\"--simulate\"then c.options.dry_run=true elseif F==\"--recursive\"then x=true elseif F==\"--admindir\"then c.admindir,d.admindir,e.admindir,f.admindir=H,H,H,H elseif F==\"--root\"then c.rootdir=H elseif F==\"--selected-only\"then y=true elseif F==\"--skip-same-verison\"then c.options.skip_same_version=true elseif F==\"--pre-invoke\"then A=H elseif F==\"--post-invoke\"then B=H elseif F==\"--path-exclude\"then C=H elseif F==\"--path-include\"then D=H elseif F==\"--no-pager\"then c.options.pager=false elseif F==\"--no-triggers\"then c.options.triggers=false elseif F==\"--triggers\"then c.options.triggers=true end end end;local function K(t)c.error(t)print([[\n\nType dpkg --help for help about installing and deinstalling packages [*];\nUse 'apt' or 'aptitude' for user-friendly package management;\nType dpkg -Dhelp for a list of dpkg debug flag values;\nType dpkg --force-help for a list of forcing options;\nType dpkg-deb --help for help about manipulating *.deb files;\n\nOptions marked [*] produce a lot of output !]])return 2 end;if w==nil then K(\"need an action option\")end;if not a.exists(g(\"\"))then a.mkdir(g(\"info\"))a.mkdir(g(\"triggers\"))i(g(\"status\"),\"\")i(g(\"triggers/Unincorp\"),\"\")i(g(\"triggers/File\"),\"\")end;if w==0 or w==1 then if#v==0 then K((w==0 and\"--install\"or\"--unpack\")..\" needs at least one package archive file argument\")end;local L={}for E,F in ipairs(v)do if not a.exists(F)then c.error(\"cannot access archive '\"..F..\"': No such file or directory\")return 2 end;if x then if not a.isDir(F)then c.error(\"cannot access directory '\"..F..\"': Not a directory\")return 2 end;local function M(g)for E,N in ipairs(a.list(g))do if a.isDir(a.combine(g,N))then M(a.combine(g,N))elseif N:match(\"^.*%.deb$\")then c.print(\"Loading \"..F..\" (this may take a while) ...\")local O,P=pcall(c.package,N)if not O then c.error(\"cannot access archive '\"..a.combine(g,N)..\"': \"..P)return 2 end;table.insert(L,P)end end end;M(F)else c.print(\"Loading \"..F..\" (this may take a while) ...\")local O,P=pcall(c.package,F)if not O then c.error(\"cannot access archive '\"..F..\"': \"..P)return 2 end;table.insert(L,P)end end;if#L==0 then c.error(\"searched, but found no packages (files matching *.deb)\")return 2 end;local Q={}for E,F in ipairs(L)do c.print(\"Selecting previously unselected package \"..F.name..\".\")if c.package.packagedb==nil then c.readDatabase()end;c.package.packagedb[F.name]=c.package.packagedb[F.name]or{Status=\"unknown ok not-installed\"}p(c.package.packagedb[F.name],1,\"install\")if not F.unpack()or w==0 and not F.configure()then table.insert(Q,F.name)end end;if c.options.triggers then for R,F in pairs(c.package.packagedb)do if F[\"Triggers-Pending\"]then c.print(\"Processing triggers for \"..R..\" (\"..F.Version..\") ...\")f.commit(R,c.package.triggerdb,c.package.packagedb)end end end;e.writeDatabase(c.package.packagedb)if#Q>0 then c.print(\"dpkg: error processing \"..table.concat(Q,\", \"))return 2 else return 0 end elseif w==2 then if x then c.warn(\"--recursive specified, but this flag is ineffective with --configure\")end;if#v==0 then K(\"--configure needs at least one package name argument\")end;c.readDatabase()local Q={}if v[1]==\"--pending\"or v[1]==\"-a\"then for R,F in pairs(c.package.packagedb)do if e.status.needs_configure(m(F,3))then local O,P=pcall(c.package,R)if not O or not P.configure()then table.insert(Q,R)end end end else for E,R in ipairs(v)do if e.status.needs_configure(m(c.package.packagedb[R],3))then local O,P=pcall(c.package,R)if not O or not P.configure()then table.insert(Q,R)end end end end;e.writeDatabase(c.package.packagedb)if#Q>0 then c.print(\"dpkg: error processing \"..table.concat(Q,\", \"))return 2 else return 0 end elseif w==3 then if x then c.warn(\"--recursive specified, but this flag is ineffective with --triggers-only\")end;if#v==0 then K(\"--triggers-only needs at least one package name argument\")end;c.readDatabase()local Q={}if v[1]==\"--pending\"or v[1]==\"-a\"then if c.options.triggers then for R,F in pairs(c.package.packagedb)do if F[\"Triggers-Pending\"]then c.print(\"Processing triggers for \"..R..\" (\"..F.Version..\") ...\")f.commit(R,c.package.triggerdb,c.package.packagedb)end end end else if c.options.triggers then for E,R in ipairs(v)do if c.package.packagedb[R][\"Triggers-Pending\"]then c.print(\"Processing triggers for \"..R..\" (\"..c.package.packagedb[R].Version..\") ...\")f.commit(R,c.package.triggerdb,c.package.packagedb)end end end end;e.writeDatabase(c.package.packagedb)if#Q>0 then c.print(\"dpkg: error processing \"..table.concat(Q,\", \"))return 2 else return 0 end elseif w==4 then if x then c.warn(\"--recursive specified, but this flag is ineffective with --remove\")end;if#v==0 then K(\"--remove needs at least one package name argument\")end;c.readDatabase()local Q={}for E,R in ipairs(v)do local O,P=pcall(c.package,R)if O then p(c.package.packagedb[R],1,\"deinstall\")end;if not O or not P.remove(false)then table.insert(Q,R)end end;e.writeDatabase(c.package.packagedb)if#Q>0 then c.print(\"dpkg: error processing \"..table.concat(Q,\", \"))return 2 else return 0 end elseif w==5 then if x then c.warn(\"--recursive specified, but this flag is ineffective with --purge\")end;if#v==0 then K(\"--purge needs at least one package name argument\")end;c.readDatabase()local Q={}for E,R in ipairs(v)do local O,P=pcall(c.package,R)if O then p(c.package.packagedb[R],1,\"purge\")end;if not O or not P.remove(true)then table.insert(Q,R)end end;e.writeDatabase(c.package.packagedb)if#Q>0 then c.print(\"dpkg: error processing \"..table.concat(Q,\", \"))return 2 else return 0 end elseif w==6 then if x then c.warn(\"--recursive specified, but this flag is ineffective with --verify\")end;c.readDatabase()local Q={}if#v==0 then for R in pairs(c.package.packagedb)do local O,P=pcall(c.package,R)if not O or not P.verify()then table.insert(Q,R)end end else for E,R in ipairs(v)do local O,P=pcall(c.package,R)if not O or not P.verify()then table.insert(Q,R)end end end;e.writeDatabase(c.package.packagedb)if#Q>0 then c.print(\"dpkg: error verifying \"..table.concat(Q,\", \"))return 2 else return 0 end elseif w==7 then c.readDatabase()if#v==0 then for R,F in pairs(c.package.packagedb)do if not a.exists(g(\"info/\"..R..\".list\"))then c.warn(\"package \"..R..\" is missing a file list\\nTo fix this issue: reinstall the package\")end;if not a.exists(g(\"info/\"..R..\".md5sums\"))then c.warn(\"package \"..R..\" is missing an md5sum list\\nTo fix this issue: reinstall the package\")end;if m(F,1)==\"install\"then if m(F,3)==\"half-installed\"or m(F,2)==\"reinstreq\"then c.warn(\"package \"..R..\" is not installed properly\\nTo fix this issue: reinstall the package\")elseif m(F,3)==\"not-installed\"or m(F,3)==\"config-files\"then c.warn(\"package \"..R..\" is marked for installation, but it is not installed\\nTo fix this issue: install the package\")elseif m(F,3)~=\"installed\"then c.warn(\"package \"..R..\" is not configured\\nTo fix this issue: configure the package\")end elseif m(F,1)==\"deinstall\"then if m(F,3)==\"not-installed\"then c.warn(\"package \"..R..\" is marked for removal of non-config files, but config files are not installed\\nTo fix this issue: reinstall package then remove properly\")elseif m(F,3)==\"installed\"or m(F,3)==\"triggers-pending\"or m(F,3)==\"triggers-awaited\"then c.warn(\"package \"..R..\" is marked for removal, but the package hasn't been removed\\nTo fix this issue: remove the package\")elseif m(F,3)~=\"config-files\"then c.warn(\"package \"..R..\" was not removed properly\\nTo fix this issue: remove the package\")end elseif m(F,1)==\"purge\"then if m(F,3)==\"config-files\"then c.warn(\"package \"..R..\" is marked for purge, but config files are still installed\\nTo fix this issue: purge the package\")elseif m(F,3)==\"installed\"or m(F,3)==\"triggers-pending\"or m(F,3)==\"triggers-awaited\"then c.warn(\"package \"..R..\" is marked for purge, but the package hasn't been removed\\nTo fix this issue: remove the package\")elseif m(F,3)~=\"config-files\"then c.warn(\"package \"..R..\" was not purged properly\\nTo fix this issue: remove the package\")end elseif m(F,1)==\"unknown\"then c.warn(\"package \"..R..\" is in an unknown status\\nTo fix this issue: (re)install the package\")end end else for E,R in ipairs(v)do local F=c.package.packagedb[R]if not F then c.warn(\"package \"..R..\" not found\")else if not a.exists(g(\"info/\"..R..\".list\"))then c.warn(\"package \"..R..\" is missing a file list\\nTo fix this issue: reinstall the package\")end;if not a.exists(g(\"info/\"..R..\".md5sums\"))then c.warn(\"package \"..R..\" is missing an md5sum list\\nTo fix this issue: reinstall the package\")end;if m(F,1)==\"install\"then if m(F,3)==\"half-installed\"or m(F,2)==\"reinstreq\"then c.warn(\"package \"..R..\" is not installed properly\\nTo fix this issue: reinstall the package\")elseif m(F,3)==\"not-installed\"or m(F,3)==\"config-files\"then c.warn(\"package \"..R..\" is marked for installation, but it is not installed\\nTo fix this issue: install the package\")elseif m(F,3)~=\"installed\"then c.warn(\"package \"..R..\" is not configured\\nTo fix this issue: configure the package\")end elseif m(F,1)==\"deinstall\"then if m(F,3)==\"not-installed\"then c.warn(\"package \"..R..\" is marked for removal of non-config files, but config files are not installed\\nTo fix this issue: reinstall package then remove properly\")elseif m(F,3)==\"installed\"or m(F,3)==\"triggers-pending\"or m(F,3)==\"triggers-awaited\"then c.warn(\"package \"..R..\" is marked for removal, but the package hasn't been removed\\nTo fix this issue: remove the package\")elseif m(F,3)~=\"config-files\"then c.warn(\"package \"..R..\" was not removed properly\\nTo fix this issue: remove the package\")end elseif m(F,1)==\"purge\"then if m(F,3)==\"config-files\"then c.warn(\"package \"..R..\" is marked for purge, but config files are still installed\\nTo fix this issue: purge the package\")elseif m(F,3)==\"installed\"or m(F,3)==\"triggers-pending\"or m(F,3)==\"triggers-awaited\"then c.warn(\"package \"..R..\" is marked for purge, but the package hasn't been removed\\nTo fix this issue: remove the package\")elseif m(F,3)~=\"config-files\"then c.warn(\"package \"..R..\" was not purged properly\\nTo fix this issue: remove the package\")end elseif m(F,1)==\"unknown\"then c.warn(\"package \"..R..\" is in an unknown status\\nTo fix this issue: (re)install the package\")end end end end elseif w==8 then c.readDatabase()local S={}if#v==0 then for R,F in pairs(c.package.packagedb)do if m(F,3)~=\"not-installed\"then table.insert(S,{R,m(F,1)})end end else for E,R in ipairs(v)do table.insert(S,{R,m(c.package.packagedb[R],1)})end end;textutils.tabulate(table.unpack(S))elseif w==9 then elseif w==10 then c.readDatabase()for R,F in pairs(c.package.packagedb)do if F.Priority~=\"essential\"and F.Priority~=\"required\"then p(F,1,\"deinstall\")end end;e.writeDatabase(c.package.packagedb)return 0 elseif w==11 then if z==\"pkgname\"then return string.match(v[1],\"^%w[%w+-.]+$\")and 0 or 2 elseif z==\"trigname\"then return string.match(v[1],\"^%w[%w+-.]+$\")and 0 or 2 elseif z==\"archname\"then return(v[1]==\"all\"or v[1]==\"any\"or v[1]==\"phoenix\"or v[1]==\"source\")and 0 or((v[1]==\"i386\"or v[1]==\"amd64\"or v[1]==\"powerpc\"or v[1]==\"armv7h\"or v[1]==\"aarch64\"or v[1]==\"ppc64el\"or v[1]==\"ia64\"or v[1]==\"s390x\"or v[1]==\"mips\"or v[1]==\"mipsel\"or v[1]==\"mips64el\"or v[1]==\"armv7el\")and 1 or 2)elseif z==\"version\"then return c.compareVersions(v[1],\"1\")and 0 or 2 else K(\"unknown option --validate-\"..z)end elseif w==12 then if#v<3 then K(\"--compare-versions takes three arguments: <version> <relation> <version>\")end;local T=c.findRelationship(\"a\",v[1],\"a (\"..v[2]..\" \"..v[3]..\")\")if T==nil then return 2 elseif T==true then return 0 else return 1 end elseif w==13 then return b.run(\"/usr/bin/dpkg-deb\",...)elseif w==14 then return b.run(\"/usr/bin/dpkg-query\",...)end\n",setuser=false,size=22540,modified=1757997040398,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["signtool.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997040938,data="\n",setuser=false,size=1,modified=1757997040931,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["dpkg-query.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997040421,data="local a=require\"system.filesystem\"local b=require\"dpkg.query\"local function c(d)return string.match(d,'^()[%s%z]*$')and''or string.match(d,'^[%s%z]*(.*[^%s%z])')end;local function e(f,g,h)return string.len(f)<g and string.sub(f,1,g)..string.rep(h or\" \",g-string.len(f))or string.sub(f,1,g)end;local function i()local j=io.open(a.combine(b.admindir,\"available\"),\"r\")if j==nil then error(\"Couldn't find status file\")end;local k={{}}local l=nil;local d=1;for m in j:lines()do if m==\"\"then d=d+1;k[d]={}l=nil else if string.sub(m,1,1)==\" \"and l~=nil then if l==\"Description\"then if type(k[d][l])==\"string\"then k[d][l]={Short=k[d][l],Long=\"\"}end;k[d][l].Long=k[d][l].Long..(string.sub(m,2)==\".\"and\"\\n\\n\"or string.sub(m,2))else k[d][l]=k[d][l]..(string.sub(m,2)==\".\"and\"\\n\\n\"or string.sub(m,2))end else l=string.sub(m,1,(string.find(m,\":\")or 0)-1)k[d][l]=c(string.sub(m,(string.find(m,\":\")or-1)+1))end end end;j:close()local n={}for o,p in pairs(k)do if p.Package then n[p.Package]=p end end;return n end;local q={}local r=nil;local s=\"${Package}\\t${Version}\\n\"local t=false;local u;for o,p in pairs({...})do if u then if u==0 then s=p elseif u==1 then b.admindir=p elseif u==2 then s=p end;u=nil elseif p==\"-l\"or p==\"--list\"then r=0 elseif p==\"-W\"or p==\"--show\"then r=1 elseif p==\"-s\"or p==\"--status\"then r=2 elseif p==\"-L\"or p==\"--listfiles\"then r=3 elseif p==\"--control-list\"then r=4 elseif p==\"--control-show\"then r=5 elseif p==\"-c\"or p==\"--control-path\"then r=6 elseif p==\"-S\"or p==\"--search\"then r=7 elseif p==\"-p\"or p==\"--print-avail\"then r=8 elseif p==\"-?\"or p==\"--help\"then print([[Usage: dpkg-query [<option> ...] <command>\nCommands:\n  -s|--status <package> ...        Display package status details.\n  -p|--print-avail <package> ...   Display available version details.\n  -L|--listfiles <package> ...     List files 'owned' by package(s).\n  -l|--list [<pattern> ...]        List packages concisely.\n  -W|--show [<pattern> ...]        Show information on package(s).\n  -S|--search <pattern> ...        Find package(s) owning file(s).\n      --control-list <package>     Print the package control file list.\n      --control-show <package> <file>\n                                   Show the package control file.\n  -c|--control-path <package> [<file>]\n                                   Print path for package control file.\n  -?, --help                       Show this help message.\n      --version                    Show the version.]])return 2 elseif p==\"--version\"then print(\"dpkg-query v1.0\\nPart of apt-lua for Phoenix\\nCopyright (c) 2019-2022 JackMacWindows.\")return 2 elseif string.find(p,\"--admindir=\")==1 then b.admindir=string.sub(p,12)elseif p==\"--admindir\"then u=1 elseif p==\"--load-avail\"then t=true elseif string.find(p,\"--showformat=\")==1 then s=string.sub(p,14)elseif p==\"--showformat\"then u=2 elseif p==\"-f\"then u=0 else table.insert(q,p)end end;s=string.gsub(string.gsub(s,\"\\\\n\",\"\\n\"),\"\\\\t\",\"\\t\")if r==0 then local v=nil;if q[1]~=nil then v=string.gsub(q[1],\"%*\",\".+\")end;local w=b.readDatabase()local function x(p)local y=\"\"if string.find(p.Status,\"^install \")then y=\"i\"elseif string.find(p.Status,\" hold\")then y=\"h\"elseif string.find(p.Status,\" deinstall\")then y=\"r\"elseif string.find(p.Status,\" purge\")then y=\"p\"else y=\"u\"end;if string.find(p.Status,\" not-installed\")then y=y..\"n\"elseif string.find(p.Status,\" config-files\")then y=y..\"c\"elseif string.find(p.Status,\" half-installed\")then y=y..\"H\"elseif string.find(p.Status,\" unpacked\")then y=y..\"U\"elseif string.find(p.Status,\" half-configured\")then y=y..\"F\"elseif string.find(p.Status,\" triggers-awaited\")then y=y..\"W\"elseif string.find(p.Status,\" triggers-pending\")then y=y..\"t\"elseif string.find(p.Status,\" installed\")then y=y..\"i\"else y=y..\"u\"end;if string.find(p.Status,\" reinst-required\")then y=y..\"R\"else y=y..\" \"end;local z=select(2,coroutine.yield(\"syscall\",\"termsize\"))-4;io.write(string.format(\"%3s %s %s %s\",y,e(p.Package,z/4),e(p.Version,z/4),e(p.Description.Short,z/2)))end;if v then for o,p in pairs(w)do if string.match(p.Package,v)then x(p)end end else for o,p in pairs(w)do if string.find(p.Status,\" config-files\")==nil and string.find(p.Status,\" not-installed\")==nil then x(p)end end end elseif r==1 then local v=nil;if q[1]~=nil then v=string.gsub(q[1],\"%*\",\".+\")end;local w=b.readDatabase()local function x(p)local y=\"\"if string.find(p.Status,\"^install \")then y=\"i\"elseif string.find(p.Status,\"hold\")then y=\"h\"elseif string.find(p.Status,\"deinstall\")then y=\"r\"elseif string.find(p.Status,\"purge\")then y=\"p\"else y=\"u\"end;if string.find(p.Status,\"not-installed\")then y=y..\"n\"elseif string.find(p.Status,\"config-files\")then y=y..\"c\"elseif string.find(p.Status,\"half-installed\")then y=y..\"H\"elseif string.find(p.Status,\"unpacked\")then y=y..\"U\"elseif string.find(p.Status,\"half-configured\")then y=y..\"F\"elseif string.find(p.Status,\"triggers-awaited\")then y=y..\"W\"elseif string.find(p.Status,\"triggers-pending\")then y=y..\"t\"elseif string.find(p.Status,\" installed\")then y=y..\"i\"else y=y..\"u\"end;if string.find(p.Status,\" reinst-required\")then y=y..\"R\"else y=y..\" \"end;local function A(B,C)return C~=\"\"and e(p[B],tonumber(string.sub(C,2)))or p[B]end;io.write(string.gsub(s,\"%${(.-)(;?%d*)}\",A))end;if v then for o,p in pairs(w)do if string.match(p.Package,v)then x(p)end end else for o,p in pairs(w)do if string.find(p.Status,\" config-files\")==nil and string.find(p.Status,\" not-installed\")==nil then x(p)end end end elseif r==2 then if#q<1 then error(\"Usage: dpkg-query [options...] --status <package-name...>\")end;local w=b.readDatabase()local function D(p)if type(p)==\"table\"then return p.Short..\"\\n\"..string.gsub(p.Long,\"\\n\\n\",\"\\n .\\n\")else return p end end;for E,F in pairs(q)do for o,p in pairs(w)do if o==F then for G,z in pairs(p)do print(G..\": \"..D(z))end;break end end;print(\"\")end elseif r==3 then if#q<1 then error(\"Usage: dpkg-query [options...] --listfiles <package-name...>\")end;local w=b.readDatabase()for E,F in pairs(q)do local H;if a.exists(a.combine(b.admindir,\"info/\"..F..\".list\"))then H=a.combine(b.admindir,\"info/\"..F..\".list\")else for o,p in pairs(w)do if o==F then if not a.exists(a.combine(b.admindir,\"info/\"..F..\"!\"..p.Architecture..\".list\"))then error(\"Could not find list of files for \"..F)end;H=a.combine(b.admindir,\"info/\"..F..\"!\"..p.Architecture..\".list\")break end end end;local j=a.open(H,\"r\")print(j.readAll())j.close()end elseif r==4 then if#q<1 then error(\"Usage: dpkg-query [options...] --control-list <package-name>\")end;local I={}for o,p in pairs(a.list(a.combine(b.admindir,\"info\")))do if string.match(p,\"^\"..string.gsub(q[1],\"%-\",\"%%-\")..\"%..+\")then table.insert(I,a.combine(b.admindir,\"info/\"..p))end;if o%1000==0 then os.queueEvent(\"nosleep\")os.pullEvent()end end;if#I==0 then local w=b.readDatabase()for o,p in pairs(w)do if o==q[1]then local J=\"^\"..string.gsub(q[1],\"%-\",\"%%-\")..\"!\"..p.Architecture..\"%.(.+)\"for G,z in pairs(a.list(a.combine(b.admindir,\"info\")))do if string.match(z,J)then table.insert(I,string.match(z,J))end;if G%1000==0 then os.queueEvent(\"nosleep\")os.pullEvent()end end;break end end end;for o,p in pairs(I)do if p~=\"list\"then print(p)end end elseif r==5 then if#q<2 then error(\"Usage: dpkg-query [options...] --control-show <package-name> <control-file>\")end;if a.exists(a.combine(b.admindir,\"info/\"..q[1]..\".\"..q[2]))then local j=a.open(a.combine(b.admindir,\"info/\"..q[1]..\".\"..q[2]),\"r\")print(j.readAll())j.close()else local w=b.readDatabase()for o,p in pairs(w)do if o==q[1]then if a.exists(a.combine(b.admindir,\"info/\"..q[1]..\"!\"..p.Architecture..\".\"..q[2]))then local j=a.open(a.combine(b.admindir,\"info/\"..q[1]..\"!\"..p.Architecture..\".\"..q[2]),\"r\")print(j.readAll())j.close()end;break end end end elseif r==6 then error(\"This command is deprecated upstream, therefore it will remain unimplemented here.\")elseif r==7 then if#q<1 then error(\"Usage: dpkg-query [options...] --search <pattern>\")end;local K=false;local L=false;local v=string.gsub(string.gsub(q[1],\"([^\\\\])%*\",\"%1%.%*\"),\"([^\\\\])%?\",\"%1%.%-\")if string.find(q[1],\"[%*%[%?/]\")~=1 then v=\".*\"..v..\".*\"elseif string.find(q[1],\"[%*%[%?/]\")==nil then K=true else v=\"^\"..v..\"$\"end;local I=a.find(a.combine(b.admindir,\"info/*.list\"))print(\"Searching...\")for o,p in pairs(I)do local j=assert(io.open(p,\"r\"))for m in j:lines()do if string.find(m,v,1,K)then print(string.sub(a.basename(p),1,string.find(a.basename(p),\"[!.]\")-1)..\": \"..m)L=true end end;j:close()os.queueEvent(\"nosleep\")os.pullEvent()end;if not L then error(\"no pattern matching \"..q[1])end elseif r==8 then if#q<1 then error(\"Usage: dpkg-query [options...] --print-avail <package-name...>\")end;local w=i()local function D(p)if type(p)==\"table\"then return p.Short..\"\\n\"..string.gsub(p.Long,\"\\n\\n\",\"\\n .\\n\")else return p end end;for E,F in pairs(q)do for o,p in pairs(w)do if o==F then for G,z in pairs(p)do print(G..\": \"..D(z))end;break end end;print(\"\")end else error(\"Usage: dpkg-query [options...] <command>\")end\n",setuser=false,size=8892,modified=1757997040396,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["shasum.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997042488,data="local a=require\"sha2\"local b=require\"system.util\"local c=assert(b.argparse({a=true,algorithm=\"@a\",b=false,binary=\"@b\",c=false,check=\"@c\",tag=false,t=false,text=\"@t\",U=false,UNIVERSAL=\"@U\",[\"0\"]=false,[\"01\"]=\"@0\",[\"ignore-missing\"]=false,q=false,quiet=\"@q\",s=false,status=\"@s\",strict=false,w=false,warn=\"@w\",h=false,help=\"@h\",v=false,version=\"@v\"},...))if c.h then print[[\nUsage: shasum [OPTION]... [FILE]...\nPrint or check SHA checksums.\nWith no FILE, or when FILE is -, read standard input.\n\n    -a, --algorithm   1 (default), 224, 256, 384, 512, 512224, 512256\n    -b, --binary      read in binary mode\n    -c, --check       read SHA sums from the FILEs and check them\n        --tag         create a BSD-style checksum\n    -t, --text        read in text mode (default)\n    -U, --UNIVERSAL   read in Universal Newlines mode\n                        produces same digest on Windows/Unix/Mac\n    -0, --01          read in BITS mode\n                        ASCII '0' interpreted as 0-bit,\n                        ASCII '1' interpreted as 1-bit,\n                        all other characters ignored\n\nThe following five options are useful only when verifying checksums:\n        --ignore-missing  don't fail or report status for missing files\n    -q, --quiet           don't print OK for each successfully verified file\n    -s, --status          don't output anything, status code shows success\n        --strict          exit non-zero for improperly formatted checksum lines\n    -w, --warn            warn about improperly formatted checksum lines\n\n    -h, --help        display this help and exit\n    -v, --version     output version information and exit\n\nWhen verifying SHA-512/224 or SHA-512/256 checksums, indicate the\nalgorithm explicitly using the -a option, e.g.\n\n    shasum -a 512224 -c checksumfile\n\nThe sums are computed as described in FIPS PUB 180-4.  When checking,\nthe input should be a former output of this program.  The default\nmode is to print a line with checksum, a character indicating type\n(`*' for binary, ` ' for text, `U' for UNIVERSAL, `^' for BITS),\nand name for each FILE.  The line starts with a `\\' character if the\nFILE name contains either newlines or backslashes, which are then\nreplaced by the two-character sequences `\\n' and `\\\\' respectively.\n]]return elseif c.v then print(\"1.0\")return end;c[1]=c[1]or\"-\"for d,e in ipairs(c)do local f=e==\"-\"and io.stdin or assert(io.open(e,c.b and not c.t and\"rb\"or\"r\"))local g;if c.a==\"1\"or not c.a then g=a.sha1()elseif c.a==\"224\"then g=a.sha224()elseif c.a==\"256\"then g=a.sha256()elseif c.a==\"384\"then g=a.sha384()elseif c.a==\"512\"then g=a.sha512()elseif c.a==\"512224\"then g=a.sha512_224()elseif c.a==\"512256\"then g=a.sha512_256()else error(\"shasum: invalid algorithm \"..c.a)end;local h;repeat local i=f:read(\"*L\")if i and c[\"0\"]then i=i:gsub(\"[^01]\",\"\"):gsub(\"........\",function(j)return string.char(tonumber(j,2))end)end;h=g(i)until not i;if f~=io.stdin then f:close()end;if c.tag then print(\"SHA\"..(c.a or\"1\"):gsub(\"(...)(...)\",\"%1/%2\")..\" (\"..e..\") = \"..h)else print(h..\"  \"..e)end end\n",setuser=false,size=3059,modified=1757997042482,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["b2sum.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997042485,data="local a=require\"sha2\"local b=require\"system.util\"local c=assert(b.argparse({b=false,binary=\"@b\",c=false,check=\"@c\",l=\"number\",length=\"@l\",tag=false,t=false,text=\"@t\",z=false,zero=\"@z\",[\"ignore-missing\"]=false,quiet=false,status=false,strict=false,w=false,warn=\"@w\",h=false,help=\"@h\",v=false,version=\"@v\"},...))if c.h then print[[\nUsage: b2sum [OPTION]... [FILE]...\nPrint or check BLAKE2b (512-bit) checksums.\n\nWith no FILE, or when FILE is -, read standard input.\n  -b, --binary          read in binary mode\n  -c, --check           read checksums from the FILEs and check them\n  -l, --length=BITS     digest length in bits; must not exceed the max for\n                          the blake2 algorithm and must be a multiple of 8\n      --tag             create a BSD-style checksum\n  -t, --text            read in text mode (default)\n  -z, --zero            end each output line with NUL, not newline,\n                          and disable file name escaping\n\nThe following five options are useful only when verifying checksums:\n      --ignore-missing  don't fail or report status for missing files\n      --quiet           don't print OK for each successfully verified file\n      --status          don't output anything, status code shows success\n      --strict          exit non-zero for improperly formatted checksum lines\n  -w, --warn            warn about improperly formatted checksum lines\n\n      --help        display this help and exit\n      --version     output version information and exit\n\nThe sums are computed as described in RFC 7693.\nWhen checking, the input should be a former output of this program.\nThe default mode is to print a line with: checksum, a space,\na character indicating input mode ('*' for binary, ' ' for text\nor where binary is insignificant), and name for each FILE.\n]]return elseif c.v then print(\"1.0\")return end;c[1]=c[1]or\"-\"for d,e in ipairs(c)do local f=e==\"-\"and io.stdin or assert(io.open(e,c.b and not c.t and\"rb\"or\"r\"))local g=a.blake2b(nil,nil,nil,c.l and c.l/8)local h;repeat local i=f:read(\"*L\")h=g(i)until not i;if f~=io.stdin then f:close()end;local j;if c.tag then j=\"BLAKE2b\"..(c.l and\"-\"..c.l or\"\")..\" (\"..e..\") = \"..h else j=h..\"  \"..e end;if c.z then io.stdout:write(j..\"\\0\")else print(j)end end\n",setuser=false,size=2247,modified=1757997042476,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["login.lua"]={permissions={root={write=true,read=true,execute=true}},created=1757997043161,data="coroutine.yield(\"syscall\",\"debug_enable\",nil,false)local a=require\"usermgr\"local b=require\"system.ipc\"local c=require\"system.process\"local d=require\"system.terminal\"local e=require\"system.util\"if not d.istty()then return false end;print()while b.lookup(\"usermgr\")==nil do e.sleep(0.1)end;if c.getuser()~=\"root\"then error(\"This program must be run as root. Make sure the setuser bit is set.\")end;for f,g in pairs(b.signal)do b.sigaction(g,nil)end;b.sigaction(b.signal.SIGHUP,function()return c.exit(-1)end)while true do print(\"Phoenix \"..e.syscall.version()..\"\\n\")io.stdout:write(\"login: \")local h=io.stdin:read()for i=1,3 do io.stdout:write(\"Password: \")d.termctl({echo=false})local j=io.stdin:read()d.termctl({echo=true})print()local k,l=a.authenticate(h,j)if l then print(l)end;if not k and(l==\"No password set\"or l==\"Password expired\")then repeat until c.run(\"/usr/bin/passwd.lua\",h)end;if k then local m=io.open(\"/etc/motd\",\"r\")if m then print(m:read(\"*a\"))m:close()end;local n=a.getUserInfo(h)local o=c.fork(function()c.setuser(h)if n and n.home then c.getenv().HOME=n.home;c.chdir(n.home)end;if n and n.shell then c.exec(n.shell)else c.exec(\"/bin/sh\")end end)for f,g in pairs(b.signal)do b.sigaction(g,function()b.kill(o,g)end)end;b.sigaction(b.signal.SIGHUP,function()b.kill(o,b.signal.SIGHUP)return c.exit(-1)end)repeat local p,q=coroutine.yield()until p==\"process_complete\"and q.id==o;for f,g in pairs(b.signal)do b.sigaction(g,nil)end;b.sigaction(b.signal.SIGHUP,function()return c.exit(-1)end)break else if i==3 then print(\"login: 3 incorrect password attempts\\n\")e.sleep(2)end end end end\n",setuser=true,size=1601,modified=1757997043107,worldPermissions={write=false,read=true,execute=true},type="file",owner="root"},["add-apt-repository.lua"]={permissions={root={write=true,read=true,execute=true}},created=1757997039610,data="local a=require\"system.filesystem\"local b=require\"system.network\"local c=require\"system.serialization\"local d=require\"system.util\"local e=require\"pgp\"local f=require\"apt.repo\"local g=assert(d.argparse({h=false,help=\"@h\",d=false,debug=\"@d\",r=false,remove=\"@r\",s=false,[\"enable-source\"]=\"@s\",c=\"multiple\",component=\"@c\",p=true,pocket=\"@p\",y=false,yes=\"@y\",l=false,login=\"@l\",[\"dry-run\"]=false,L=false,list=\"@L\",P=true,ppa=\"@P\",C=true,cloud=\"@C\",U=true,uri=\"@U\",S=false,sourceslist=\"@S\"},...))if g.L then local h=f.readSources()local i={}for j,k in ipairs(h)do i[k.url]=i[k.url]or{}i[k.url][k.suite]=i[k.url][k.suite]or{}i[k.url][k.suite][#i[k.url][k.suite]+1]=k.component end;for l,m in pairs(i)do for n,o in pairs(m)do print(\"deb \"..l..\" \"..n..\" \"..table.concat(o,\" \"))end end;return end;local l,p,q=nil,g.p or\"release\",g.c and table.concat(g.c,\" \")or\"main\"local function r(s,t)l=\"https://ppa.launchpadcontent.net/\"..s..\"/\"..t..\"/ubuntu/\"print(\"Querying Launchpad for PPA information...\")local u=assert(b.getData(\"https://api.launchpad.net/1.0/~\"..s..\"/+archive/\"..t,{Accept=\"application/json\"}))local v=assert(c.json.decode(u))print(v.displayname..\": \"..v.description)io.write(\"Continue adding PPA? (Y/n) \")if g.y then print(\"y\")else local w=io.read()if not w:lower():find(\"y\")then print(\"Abort.\")return end end;local x=assert(v.signing_key_fingerprint)print(\"Adding key ID \"..x..\" to trusted.gpg.d...\")local y=assert(b.getData(\"https://keyserver.ubuntu.com/pks/lookup?op=get&search=0x\"..x))local z=e.decodeASC(y)if not g[\"dry-run\"]then local A=assert(io.open(\"/etc/apt/trusted.gpg.d/ppa-\"..s..\"-\"..t..\".gpg\",\"wb\"))A:write(z)A:close()end end;if g.P then local s,t=g.P:match\"^ppa:(%w+)/(%w+)$\"if not s then s,t=g.P:match\"^(%w+)/(%w+)$\"if not s then s,t=g.P:match\"^%w+$\",\"ppa\"if not s then error(\"Invalid PPA specification\")end end end;r(s,t)elseif g.C then error(\"Unsupported option -C\")elseif g.U then if g.U:match\"^ppa:\"then local s,t=g.U:match\"^ppa:(%w+)/(%w+)$\"if not s then s,t=g.U:match\"^(%w+)/(%w+)$\"if not s then s,t=g.U:match\"^%w+$\",\"ppa\"if not s then error(\"Invalid PPA specification\")end end end;r(s,t)elseif g.U:match\"^https?://ppa%.launchpadc?o?n?t?e?n?t?%.net/[^/]+/[^/]+/ubuntu\"then r(g.U:match\"^https?://ppa%.launchpadc?o?n?t?e?n?t?%.net/([^/]+)/([^/]+)/ubuntu\")else l=g.U end elseif g.S then local B=assert(f.parseSources(g.S)[1],\"No deb source line found.\")l,p,q=B.url,B.suite,B.component else assert(g[1],\"Not enough arguments\")if g[1]==\"-\"then g[1]=assert(io.read())end;if g[1]:match\"^ppa:\"then local s,t=g[1]:match\"^ppa:(%w+)/(%w+)$\"if not s then s,t=g[1]:match\"^(%w+)/(%w+)$\"if not s then s,t=g[1]:match\"^%w+$\",\"ppa\"if not s then error(\"Invalid PPA specification\")end end end;r(s,t)elseif g[1]:match\"^https?://ppa%.launchpadc?o?n?t?e?n?t?%.net/[^/]+/[^/]+/ubuntu\"then r(g[1]:match\"^https?://ppa%.launchpadc?o?n?t?e?n?t?%.net/([^/]+)/([^/]+)/ubuntu\")elseif g[1]:match\"^deb \"then local B=assert(f.parseSources(g[1])[1],\"No deb source line found.\")l,p,q=B.url,B.suite,B.component else l=g[1]if g[2]then q=table.concat(g,\" \",2)end end end;if g.r then local function C(D)local A=io.open(D,\"r\")if A then local E={}for B in A:lines()do if B:match(\"^deb \"..l..\" \"..p)then local F=B;for G in q:gmatch\"%S+\"do B=B:gsub(G..\"%s?\",\"\")end;if not B:match(\"^deb \"..l..\" \"..p..\"%s*$\")then E[#E+1]=B;if g[\"dry-run\"]then print(\"Modified source line: \"..F..\" -> \"..B)end elseif g[\"dry-run\"]then print(\"Removed source line: \"..F)end else E[#E+1]=B end end;A:close()if not g[\"dry-run\"]then A=assert(io.open(D,\"w\"))for j,B in ipairs(E)do A:write(B..\"\\n\")end;A:close()end end end;C(\"/etc/apt/sources.list\")if a.isDir(\"/etc/apt/sources.list.d\")then for j,H in ipairs(a.list(\"/etc/apt/sources.list.d\"))do C(\"/etc/apt/sources.list.d/\"..H)end end else local function I(D)local A=assert(io.open(D,\"r\"))local E={}local J=false;for B in A:lines()do if B:match(\"^deb \"..l..\" \"..p)then local F=B;for G in q:gmatch\"%S+\"do if not B:match(G)then B=B..\" \"..G end end;J=true;if g[\"dry-run\"]then print(\"Modified source line: \"..F..\" -> \"..B)end end;E[#E+1]=B end;A:close()if not J then E[#E+1]=\"deb \"..l..\" \"..p..\" \"..q..\"\\n\"if g[\"dry-run\"]then print(\"Added source line: \"..E[#E])end end;if not g[\"dry-run\"]then A=assert(io.open(D,\"w\"))for j,B in ipairs(E)do A:write(B..\"\\n\")end;A:close()end end;if a.isDir(\"/etc/apt/sources.list.d\")then local K=\"/etc/apt/sources.list.d/\"..l:gsub(\"^https?://\",\"\"):gsub(\"[/\\\\<>:\\\"|?*]\",\"-\")..\".list\"if a.isFile(K)then I(K)else if g[\"dry-run\"]then print(\"Creating file \"..K)else local A=assert(io.open(K,\"w\"))A:write(\"deb \"..l..\" \"..p..\" \"..q..\"\\n\")A:close()end end else I(\"/etc/apt/sources.list\")end end;if not g.n then require\"apt.config\":load()local L=require\"apt.get\"L.update()L.showStats()require\"apt.cache\":generate()end\n",setuser=false,size=4740,modified=1757997039596,worldPermissions={write=false,read=true,execute=true},type="file",owner="root"},["apt-add-repository.lua"]={permissions={root={write=true,read=true,execute=true}},created=1757997039610,data="local a=require\"system.filesystem\"local b=require\"system.network\"local c=require\"system.serialization\"local d=require\"system.util\"local e=require\"pgp\"local f=require\"apt.repo\"local g=assert(d.argparse({h=false,help=\"@h\",d=false,debug=\"@d\",r=false,remove=\"@r\",s=false,[\"enable-source\"]=\"@s\",c=\"multiple\",component=\"@c\",p=true,pocket=\"@p\",y=false,yes=\"@y\",l=false,login=\"@l\",[\"dry-run\"]=false,L=false,list=\"@L\",P=true,ppa=\"@P\",C=true,cloud=\"@C\",U=true,uri=\"@U\",S=false,sourceslist=\"@S\"},...))if g.L then local h=f.readSources()local i={}for j,k in ipairs(h)do i[k.url]=i[k.url]or{}i[k.url][k.suite]=i[k.url][k.suite]or{}i[k.url][k.suite][#i[k.url][k.suite]+1]=k.component end;for l,m in pairs(i)do for n,o in pairs(m)do print(\"deb \"..l..\" \"..n..\" \"..table.concat(o,\" \"))end end;return end;local l,p,q=nil,g.p or\"release\",g.c and table.concat(g.c,\" \")or\"main\"local function r(s,t)l=\"https://ppa.launchpadcontent.net/\"..s..\"/\"..t..\"/ubuntu/\"print(\"Querying Launchpad for PPA information...\")local u=assert(b.getData(\"https://api.launchpad.net/1.0/~\"..s..\"/+archive/\"..t,{Accept=\"application/json\"}))local v=assert(c.json.decode(u))print(v.displayname..\": \"..v.description)io.write(\"Continue adding PPA? (Y/n) \")if g.y then print(\"y\")else local w=io.read()if not w:lower():find(\"y\")then print(\"Abort.\")return end end;local x=assert(v.signing_key_fingerprint)print(\"Adding key ID \"..x..\" to trusted.gpg.d...\")local y=assert(b.getData(\"https://keyserver.ubuntu.com/pks/lookup?op=get&search=0x\"..x))local z=e.decodeASC(y)if not g[\"dry-run\"]then local A=assert(io.open(\"/etc/apt/trusted.gpg.d/ppa-\"..s..\"-\"..t..\".gpg\",\"wb\"))A:write(z)A:close()end end;if g.P then local s,t=g.P:match\"^ppa:(%w+)/(%w+)$\"if not s then s,t=g.P:match\"^(%w+)/(%w+)$\"if not s then s,t=g.P:match\"^%w+$\",\"ppa\"if not s then error(\"Invalid PPA specification\")end end end;r(s,t)elseif g.C then error(\"Unsupported option -C\")elseif g.U then if g.U:match\"^ppa:\"then local s,t=g.U:match\"^ppa:(%w+)/(%w+)$\"if not s then s,t=g.U:match\"^(%w+)/(%w+)$\"if not s then s,t=g.U:match\"^%w+$\",\"ppa\"if not s then error(\"Invalid PPA specification\")end end end;r(s,t)elseif g.U:match\"^https?://ppa%.launchpadc?o?n?t?e?n?t?%.net/[^/]+/[^/]+/ubuntu\"then r(g.U:match\"^https?://ppa%.launchpadc?o?n?t?e?n?t?%.net/([^/]+)/([^/]+)/ubuntu\")else l=g.U end elseif g.S then local B=assert(f.parseSources(g.S)[1],\"No deb source line found.\")l,p,q=B.url,B.suite,B.component else assert(g[1],\"Not enough arguments\")if g[1]==\"-\"then g[1]=assert(io.read())end;if g[1]:match\"^ppa:\"then local s,t=g[1]:match\"^ppa:(%w+)/(%w+)$\"if not s then s,t=g[1]:match\"^(%w+)/(%w+)$\"if not s then s,t=g[1]:match\"^%w+$\",\"ppa\"if not s then error(\"Invalid PPA specification\")end end end;r(s,t)elseif g[1]:match\"^https?://ppa%.launchpadc?o?n?t?e?n?t?%.net/[^/]+/[^/]+/ubuntu\"then r(g[1]:match\"^https?://ppa%.launchpadc?o?n?t?e?n?t?%.net/([^/]+)/([^/]+)/ubuntu\")elseif g[1]:match\"^deb \"then local B=assert(f.parseSources(g[1])[1],\"No deb source line found.\")l,p,q=B.url,B.suite,B.component else l=g[1]if g[2]then q=table.concat(g,\" \",2)end end end;if g.r then local function C(D)local A=io.open(D,\"r\")if A then local E={}for B in A:lines()do if B:match(\"^deb \"..l..\" \"..p)then local F=B;for G in q:gmatch\"%S+\"do B=B:gsub(G..\"%s?\",\"\")end;if not B:match(\"^deb \"..l..\" \"..p..\"%s*$\")then E[#E+1]=B;if g[\"dry-run\"]then print(\"Modified source line: \"..F..\" -> \"..B)end elseif g[\"dry-run\"]then print(\"Removed source line: \"..F)end else E[#E+1]=B end end;A:close()if not g[\"dry-run\"]then A=assert(io.open(D,\"w\"))for j,B in ipairs(E)do A:write(B..\"\\n\")end;A:close()end end end;C(\"/etc/apt/sources.list\")if a.isDir(\"/etc/apt/sources.list.d\")then for j,H in ipairs(a.list(\"/etc/apt/sources.list.d\"))do C(\"/etc/apt/sources.list.d/\"..H)end end else local function I(D)local A=assert(io.open(D,\"r\"))local E={}local J=false;for B in A:lines()do if B:match(\"^deb \"..l..\" \"..p)then local F=B;for G in q:gmatch\"%S+\"do if not B:match(G)then B=B..\" \"..G end end;J=true;if g[\"dry-run\"]then print(\"Modified source line: \"..F..\" -> \"..B)end end;E[#E+1]=B end;A:close()if not J then E[#E+1]=\"deb \"..l..\" \"..p..\" \"..q..\"\\n\"if g[\"dry-run\"]then print(\"Added source line: \"..E[#E])end end;if not g[\"dry-run\"]then A=assert(io.open(D,\"w\"))for j,B in ipairs(E)do A:write(B..\"\\n\")end;A:close()end end;if a.isDir(\"/etc/apt/sources.list.d\")then local K=\"/etc/apt/sources.list.d/\"..l:gsub(\"^https?://\",\"\"):gsub(\"[/\\\\<>:\\\"|?*]\",\"-\")..\".list\"if a.isFile(K)then I(K)else if g[\"dry-run\"]then print(\"Creating file \"..K)else local A=assert(io.open(K,\"w\"))A:write(\"deb \"..l..\" \"..p..\" \"..q..\"\\n\")A:close()end end else I(\"/etc/apt/sources.list\")end end;if not g.n then require\"apt.config\":load()local L=require\"apt.get\"L.update()L.showStats()require\"apt.cache\":generate()end\n",setuser=false,size=4740,modified=1757997039596,worldPermissions={write=false,read=true,execute=true},type="file",owner="root"},["route.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997041602,data="local a=require\"system.hardware\"local b=require\"system.network\"local function c(d)if d:match\"^%d+$\"then return tonumber(d)elseif d:match\"^%d+%.%d+$\"then return tonumber(d:match\"^%d+\")*0x1000000+tonumber(d:match\"^%d+%.(%d+)\")elseif d:match\"^%d+%.%d+%.%d+$\"then return tonumber(d:match\"^(%d+)\")*0x1000000+tonumber(d:match\"^%d+%.(%d+)\")*0x10000+tonumber(d:match\"^%d+%.%d+%.(%d+)\")elseif d:match\"^%d+%.%d+%.%d+%.%d+$\"then return tonumber(d:match\"^(%d+)\")*0x1000000+tonumber(d:match\"^%d+%.(%d+)\")*0x10000+tonumber(d:match\"^%d+%.%d+%.(%d+)\")*0x100+tonumber(d:match\"^%d+%.%d+%.%d+%.(%d+)\")else error(\"Invalid IP address\",2)end end;local function e(f)if not f then return nil end;return(\"%d.%d.%d.%d\"):format(bit32.band(bit32.rshift(f,24),0xFF),bit32.band(bit32.rshift(f,16),0xFF),bit32.band(bit32.rshift(f,8),0xFF),bit32.band(f,0xFF))end;local function g(f)return bit32.bnot(2^(32-f)-1)end;local function h(i)local j=0;while bit32.btest(i,0x80000000)do i,j=bit32.lshift(i,1),j+1 end;return j end;local function k(f)return e(g(f))end;local l={...}if l[1]==\"add\"then local m={}local n=2;while n<=#l do if l[n]==\"netmask\"then m.sourceNetmask=l[n+1]n=n+2 elseif l[n]==\"gw\"then m.action=\"unicast\"m.destination=l[n+1]n=n+2 elseif l[n]==\"dev\"then m.device=l[n+1]n=n+2 elseif l[n]==\"table\"then m.table=tonumber(l[n+1])n=n+2 elseif l[n]==\"reject\"then m.action=\"prohibit\"n=n+1 elseif l[n]==\"default\"then m.source=\"0.0.0.0\"m.sourceNetmask=0;n=n+1 elseif l[n]==\"-host\"then m.action=\"local\"m.sourceNetmask=32;n=n+1 elseif l[n]==\"-net\"then m.action=\"local\"n=n+1 else m.source=l[n]if m.source:match\"^[%d%.]+/%d+$\"then m.source,m.sourceNetmask=m.source:match\"^([%d%.]+)/(%d+)$\"m.sourceNetmask=tonumber(m.sourceNetmask)end;n=n+1 end end;if not m.device then if m.action==\"local\"then for o,p in ipairs{a.find(\"modem\")}do local q=a.path(p)local d=b.ipconfig(q)if d then local r=c(d.ip)local s=g(d.netmask)local t=c(m.source)if bit32.band(t,s)==bit32.band(r,s)then m.device=q;break end end end;if not m.device then error(\"Could not find suitable device; please specify 'dev <device>'\")end elseif m.action==\"unicast\"then for o,p in ipairs{a.find(\"modem\")}do local q=a.path(p)local d=b.ipconfig(q)if d then local r=c(d.ip)local s=g(d.netmask)local t=c(m.destination)if bit32.band(t,s)==bit32.band(r,s)then m.device=q;break end end end;if not m.device then error(\"Could not find suitable device; please specify 'dev <device>'\")end end end;b.route.add(m)elseif l[1]==\"del\"then local u,i,f;local n=2;while n<=#l do if l[n]==\"netmask\"then i=l[n+1]n=n+2 elseif l[n]==\"table\"then f=tonumber(l[n+1])n=n+2 elseif l[n]==\"default\"then u=\"0.0.0.0\"i=0;n=n+1 elseif l[n]==\"-host\"then i=32;n=n+1 elseif l[n]==\"-net\"or l[n]==\"reject\"then n=n+1 elseif l[n]==\"gw\"or l[n]==\"table\"then n=n+2 else u=l[n]if u:match\"^[%d%.]+/%d+$\"then u,i=u:match\"^([%d%.]+)/(%d+)$\"i=tonumber(i)end;n=n+1 end end;b.route.remove(u,i,f)elseif l[1]==nil then print(\"Destination\\tGateway \\tNetmask \\tFlags\\tTable\\tDevice\")for n=0,1024 do local v=b.route.list(n)if not v then break end;for o,w in ipairs(v)do local x=\"U\"if w.sourceNetmask==32 then x=x..\"H\"end;if w.action==\"unicast\"then x=x..\"G\"end;if w.action==\"unreachable\"or w.action==\"prohibit\"then x=x..\"!\"end;print(w.source,w.destination or\"0.0.0.0 \",k(w.sourceNetmask),x,n,w.device or\"*\")end end else error(\"Usage: route [add|del] [options...]\")end\n",setuser=false,size=3334,modified=1757997041596,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["ping.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997041601,data="local a=require\"system.util\"local b=require\"system.process\"local c=assert(...)print(\"Pinging \"..c..\"...\")a.syscall.netevent(true)local d={}b.newthread(function()while true do local e,f=coroutine.yield()if e==\"network_event\"and f.type==\"control\"and f.sender==c then if f.messageType==\"pong\"then local g=tonumber(f.payload.payload.error)local h=(os.time()-d[g][1])*1000;print(\"Response from \"..c..\": seq=\"..g..\" time=\"..(h>=1000 and\"%d\"or\"%.3g\"):format(h)..\" ms\")d[g]=nil elseif f.messageType==\"unreachable\"then print(f.error or\"Destination unreachable\")end elseif e==\"timer\"then for i,j in pairs(d)do if j[2]==f.id then print(\"Host is down\")d[i]=nil end end end end end)local i=1;while true do d[i]={os.time(),a.syscall.timer(2)}a.syscall.netcontrol(c,\"ping\",tostring(i))i=i+1;a.sleep(1)end\n",setuser=true,size=790,modified=1757997041596,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["update-initrd.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997040841,data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=assert(io.open(\"/etc/initrd/initrd.conf\",\"r\"))local d=c:read(\"*a\"):gsub(\"#\",\"--\")c:close()config={}assert(load(d,\"@/etc/initrd/initrd.conf\",\"t\",config))()if a.isDir(\"/etc/initrd/initrd.conf.d\")then for e,f in ipairs(a.list(\"/etc/initrd/initrd.conf.d\"))do c=assert(io.open(\"/etc/initrd/initrd.conf.d/\"..f,\"r\"))d=c:read(\"*a\"):gsub(\"#\",\"--\")c:close()assert(load(d,\"@/etc/initrd/initrd.conf.d/\"..f,\"t\",config))()end end;rootDirectory=os.tmpname()a.mkdir(rootDirectory)for e,f in ipairs(a.list(\"/etc/initrd/hooks.d\"))do print(\"--> Running hook \"..f)dofile(\"/etc/initrd/hooks.d/\"..f)end;print(\"--> Creating initrd\")b.run(\"/usr/bin/mktablefs.lua\",rootDirectory,config.output_path or\"/boot/initrd.img\")print(\"=>  Finished creating initrd at \"..(config.output_path or\"/boot/initrd.img\"))\n",setuser=false,size=852,modified=1757997040827,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["ifconfig.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997041600,data="local a=require\"system.hardware\"local b=require\"system.network\"local c={...}local d=table.remove(c,1)if not d then for e,f in ipairs{a.find(\"modem\")}do local g=a.path(f)local h=b.ipconfig(g)if h then print(g..\": \"..(h.up and\"up\"or\"down\")..\", ip \"..h.ip..\", netmask \"..h.netmask)else print(g..\": down, no ip\")end end;return end;local f=a.wrap(d)if not f then error(\"No such device\")end;if not a.hasType(f,\"modem\")then error(\"Interface is not a modem\")end;local i=1;local j={}while i<=#c do if c[i]==\"up\"then j.up=true;i=i+1 elseif c[i]==\"down\"then j.up=false;i=i+1 elseif c[i]==\"netmask\"then j.netmask=tonumber(c[i+1])or c[i+1]i=i+2 else if c[i]:match(\"([^/]+)/%d+$\")then j.ip,j.netmask=c[i]:match(\"([^/]+)/(%d+)$\")j.netmask=tonumber(j.netmask)else j.ip=c[i]end;i=i+1 end end;b.ipconfig(d,j)\n",setuser=false,size=791,modified=1757997041594,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["dhclient.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997041599,data="local a=require\"system.hardware\"local b=require\"system.network\"local c=require\"system.util\"local d=...if not d then error(\"Usage: dhclient <interface>\")end;local e=a.wrap(d)if not e or not a.hasType(e,\"modem\")then error(\"Device does not exist or is not a modem\")end;e:open(68)a.listen(e,true)local f=math.random(0,2^31-1)local g=a.info(\"/\").metadata.id;e:transmit(67,68,{dhcp=true,type=\"discover\",from=g,messageID=f,options={netmask=true}})local h=c.timer(2)local i={}while true do local j,k=coroutine.yield()if j==\"modem_message\"and k.channel==68 and k.replyChannel==67 and type(k.message)==\"table\"and k.message.dhcp==true and k.message.to==g and k.message.messageID==f and k.message.type==\"offer\"then i[k.message.from]={ip=k.message.offeredIP,netmask=k.message.options.netmask,up=true}elseif j==\"timer\"and k.id==h then break end end;if next(i)==nil then a.listen(e,false)e:close(68)error(\"Could not get IP address: Timed out\")end;for l,m in pairs(i)do b.control(m.ip,\"ping\")c.sleep(2)if not b.arp.list(d)[m.ip]then e:transmit(67,68,{dhcp=true,type=\"request\",from=g,to=l,messageID=f,options={netmask=true}})h=c.timer(2)while true do local j,k=coroutine.yield()if j==\"modem_message\"and k.channel==68 and k.replyChannel==67 and type(k.message)==\"table\"and k.message.dhcp==true and k.message.to==g and k.message.messageID==f and k.message.type==\"acknowledgement\"then b.ipconfig(d,m)a.listen(e,false)e:close(68)c.cancel(h)return elseif j==\"timer\"and k.id==h then a.listen(e,false)e:close(68)error(\"Could not get IP address: No response from server\")end end end end;a.listen(e,false)e:close(68)error(\"Could not get IP address: No usable offers\")\n",setuser=false,size=1642,modified=1757997041594,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["dpkg-trigger.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997040422,data="local a=require\"dpkg.query\"local b=require\"dpkg.trigger\"local c={}local d=_ENV.DPKG_MAINTSCRIPT_PACKAGE;local e=true;local f=true;local g;for h,i in ipairs({...})do if g then if g==0 then b.admindir=i;a.admindir=i elseif g==1 then d=i end;g=nil elseif i==\"--check-supported\"then return 0 elseif i==\"-?\"or i==\"--help\"then print([[Usage: dpkg-trigger [<options> ...] <trigger-name>\n       dpkg-trigger [<options> ...] <command>\n\nCommands:\n  --check-supported                Check if the running dpkg supports triggers.\n\n  -?, --help                       Show this help message.\n      --version                    Show the version.\n\nOptions:\n  --admindir=<directory>           Use <directory> instead of /var/lib/dpkg.\n  --by-package=<package>           Override trigger awaiter (normally set\n                                   by dpkg).\n  --await                          Package needs to await the processing.\n  --no-await                       No package needs to await the processing.\n  --no-act                         Just test - don't actually change anything.\n ]])return 0 elseif i==\"--version\"then print([[Debian dpkg-trigger package trigger utility version 1.19.0.5 (Phoenix).]])return 0 elseif i==\"--admindir\"then g=0 elseif string.match(i,\"^--admindir=\")then b.admindir=string.sub(i,12)a.admindir=string.sub(i,12)elseif i==\"--by-package\"then g=1 elseif string.match(i,\"^--by-package=\")then d=string.sub(i,14)elseif i==\"--await\"then e=true elseif i==\"--no-await\"then e=false elseif i==\"--no-act\"then f=false else table.insert(c,i)end end;if c[1]==nil then error([[error: takes one argument, the trigger name\n\nType dpkg-trigger --help for help about this utility.]])end;if d==nil then error([[error: must be called from a maintainer script (or with a --by-package option)\n\nType dpkg-trigger --help for help about this utility.]])end;b.log=function(j)print(\"\\x1b[31m\"..j..\"\\x1b[0m\")end;if f then b.activate(c[1],d,e)end;return 0\n",setuser=false,size=1936,modified=1757997040397,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"}},setuser=false,size=0,modified=1757997043301,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"}},setuser=false,size=0,modified=1757997040406,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},tmp={permissions={root={write=true,read=true,execute=true}},created=1757997043457,contents={},size=0,modified=1757997043457,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},home={permissions={root={write=true,read=true,execute=true}},created=1757997043457,contents={phoenix={permissions={root={write=true,read=true,execute=true},phoenix={read=true,write=true,execute=true}},created=1757997043457,contents={[".cashrc"]={permissions={root={write=true,read=true,execute=true}},created=1757997043457,data="PS1=\"\\033[1;32m\\u@\\h\\033[39m:\\033[34m\\W\\033[0m\\$ \"",setuser=false,size=50,modified=1757997043457,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"}},setuser=false,size=0,modified=1757997043457,worldPermissions={write=false,read=true,execute=true},type="directory",owner="phoenix"}},size=0,modified=1757997043457,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},lib={permissions={root={write=true,read=true,execute=true}},created=1757997043456,contents={modules={permissions={root={write=true,read=true,execute=true}},created=1757997043421,contents={["fuse.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040697,data="local a={}function a:new(b,c,d)if type(d.fs)~=\"string\"then error(\"Missing filesystem type (fs option)\")end;local e;if d.fs:find\"/\"then e=d.fs else e=\"/lib/fuse/\"..d.fs..\".lua\"end;d.fs=nil;local f,g=userModeCallback(b,function()return assert(loadfile(e))(c,d)end)if not f then error(\"Could not create filesystem: \"..g)end;if type(g)~=\"table\"then error(\"Error creating filesystem\")end;local h={}local i=debug.getmetatable(g)if i and type(i.__index)==\"table\"then h={open=rawget(i.__index,\"open\"),list=rawget(i.__index,\"list\"),stat=rawget(i.__index,\"stat\"),remove=rawget(i.__index,\"remove\"),rename=rawget(i.__index,\"rename\"),mkdir=rawget(i.__index,\"mkdir\"),link=rawget(i.__index,\"link\"),mkfifo=rawget(i.__index,\"mkfifo\"),chmod=rawget(i.__index,\"chmod\"),chown=rawget(i.__index,\"chown\"),unmount=rawget(i.__index,\"unmount\"),init=rawget(i.__index,\"init\")}end;h.open=rawget(g,\"open\")or h.open;h.list=rawget(g,\"list\")or h.list;h.stat=rawget(g,\"stat\")or h.stat;h.remove=rawget(g,\"remove\")or h.remove;h.rename=rawget(g,\"rename\")or h.rename;h.mkdir=rawget(g,\"mkdir\")or h.mkdir;h.link=rawget(g,\"link\")or h.link;h.mkfifo=rawget(g,\"mkfifo\")or h.mkfifo;h.chmod=rawget(g,\"chmod\")or h.chmod;h.chown=rawget(g,\"chown\")or h.chown;h.unmount=rawget(g,\"unmount\")or h.unmount;h.init=rawget(g,\"init\")or h.init;local j=setmetatable({origin=e,path=c,fs=g,methods=h,options=d,running=true},{__index=self})j.process=processes[syscalls.fork(b,nil,function()while j.running do coroutine.yield()end end,\"[fuse \"..e..\"]\")]j.process.threads[0].status=\"paused\"syscalls.stdin(j.process,nil,nil)syscalls.stdout(j.process,nil,nil)syscalls.stderr(j.process,nil,nil)if h.init then userModeCallback(j.process,h.init,g,syscalls.getpinfo(j.process,nil,b.id))end;return j end;function a:open(b,c,k)if not self.methods.open then error(\"Filesystem is missing method 'open'\")end;local l,m;assert(userModeCallback(self.process,function(n)l,m=self.methods.open(self.fs,n,c,k)end,syscalls.getpinfo(self.process,nil,b.id)))if type(l)==\"string\"then return filesystem.readhandle(b,l,m)elseif type(l)==\"function\"then return filesystem.writehandle(b,l,m)else return l,m end end;function a:list(b,c)if not self.methods.list then error(\"Filesystem is missing method 'list'\")end;return select(2,assert(userModeCallback(self.process,self.methods.list,self.fs,syscalls.getpinfo(self.process,nil,b.id),c)))end;function a:stat(b,c,o)if not self.methods.stat then error(\"Filesystem is missing method 'stat'\")end;return select(2,assert(userModeCallback(self.process,self.methods.stat,self.fs,syscalls.getpinfo(self.process,nil,b.id),c,o)))end;function a:remove(b,c)if not self.methods.remove then error(\"Filesystem is missing method 'remove'\")end;assert(userModeCallback(self.process,self.methods.remove,self.fs,syscalls.getpinfo(self.process,nil,b.id),c))end;function a:rename(b,c,p)if not self.methods.rename then error(\"Filesystem is missing method 'rename'\")end;assert(userModeCallback(self.process,self.methods.rename,self.fs,syscalls.getpinfo(self.process,nil,b.id),c,p))end;function a:mkdir(b,c)if not self.methods.mkdir then error(\"Filesystem is missing method 'mkdir'\")end;assert(userModeCallback(self.process,self.methods.mkdir,self.fs,syscalls.getpinfo(self.process,nil,b.id),c))end;function a:link(b,c,q)if not self.methods.link then error(\"Filesystem is missing method 'link'\")end;assert(userModeCallback(self.process,self.methods.link,self.fs,syscalls.getpinfo(self.process,nil,b.id),c,q))end;function a:mkfifo(b,c)if not self.methods.mkfifo then error(\"Filesystem is missing method 'mkfifo'\")end;assert(userModeCallback(self.process,self.methods.mkfifo,self.fs,syscalls.getpinfo(self.process,nil,b.id),c))end;function a:chmod(b,c,r,k)if not self.methods.chmod then error(\"Filesystem is missing method 'chmod'\")end;assert(userModeCallback(self.process,self.methods.chmod,self.fs,syscalls.getpinfo(self.process,nil,b.id),c,r,k))end;function a:chown(b,c,s)if not self.methods.chown then error(\"Filesystem is missing method 'chown'\")end;assert(userModeCallback(self.process,self.methods.chown,self.fs,syscalls.getpinfo(self.process,nil,b.id),c,s))end;function a:info()return self.origin:match\"[^/]*$\":gsub(\"%.lua$\",\"\"),self.path,self.options end;function a:unmount(b)if self.methods.unmount then userModeCallback(self.process,self.methods.unmount,syscalls.getpinfo(self.process,nil,b.id))end;self.running=false;self.process.threads[0].status=\"suspended\"self.process.eventQueue[#self.process.eventQueue+1]={\"resume\",{}}end;filesystems.fuse=a;syslog.log({module=\"fuse\"},\"FUSE is now loaded\")return{unload=function()filesystems.fuse=nil end}\n",setuser=false,size=4584,modified=1757997040688,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["spanfs.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997042633,data="if not PHOENIX_VERSION then error(\"This file must be loaded as a kernel module.\")end;if not filesystem.readhandle then error(\"This module requires Phoenix 0.0.4 or later.\")end;do local _={disks={[0]=\"/disk\",\"/disk2\",\"/disk1\",\"/disk3\"},uuid=\"7f747493-a515-4dbd-bc63-b74070882b24\",name=\"Test span\",index={meta={size=0,created=0,modified=0,type=\"directory\",owner=\"root\",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={[\"test.txt\"]={meta={size=13,created=0,modified=0,type=\"file\",owner=\"root\",permissions={root={read=true,write=true,execute=false}},worldPermissions={read=true,write=false,execute=false},setuser=false},uuid=\"0de93ec6-2cf9-491c-bc59-04a9977606f9\",ids={2,1},checksum=\"6b72b48f\"}}}}end;local a={[0]=0x00000000,0x77073096,0xee0e612c,0x990951ba,0x076dc419,0x706af48f,0xe963a535,0x9e6495a3,0x0edb8832,0x79dcb8a4,0xe0d5e91e,0x97d2d988,0x09b64c2b,0x7eb17cbd,0xe7b82d07,0x90bf1d91,0x1db71064,0x6ab020f2,0xf3b97148,0x84be41de,0x1adad47d,0x6ddde4eb,0xf4d4b551,0x83d385c7,0x136c9856,0x646ba8c0,0xfd62f97a,0x8a65c9ec,0x14015c4f,0x63066cd9,0xfa0f3d63,0x8d080df5,0x3b6e20c8,0x4c69105e,0xd56041e4,0xa2677172,0x3c03e4d1,0x4b04d447,0xd20d85fd,0xa50ab56b,0x35b5a8fa,0x42b2986c,0xdbbbc9d6,0xacbcf940,0x32d86ce3,0x45df5c75,0xdcd60dcf,0xabd13d59,0x26d930ac,0x51de003a,0xc8d75180,0xbfd06116,0x21b4f4b5,0x56b3c423,0xcfba9599,0xb8bda50f,0x2802b89e,0x5f058808,0xc60cd9b2,0xb10be924,0x2f6f7c87,0x58684c11,0xc1611dab,0xb6662d3d,0x76dc4190,0x01db7106,0x98d220bc,0xefd5102a,0x71b18589,0x06b6b51f,0x9fbfe4a5,0xe8b8d433,0x7807c9a2,0x0f00f934,0x9609a88e,0xe10e9818,0x7f6a0dbb,0x086d3d2d,0x91646c97,0xe6635c01,0x6b6b51f4,0x1c6c6162,0x856530d8,0xf262004e,0x6c0695ed,0x1b01a57b,0x8208f4c1,0xf50fc457,0x65b0d9c6,0x12b7e950,0x8bbeb8ea,0xfcb9887c,0x62dd1ddf,0x15da2d49,0x8cd37cf3,0xfbd44c65,0x4db26158,0x3ab551ce,0xa3bc0074,0xd4bb30e2,0x4adfa541,0x3dd895d7,0xa4d1c46d,0xd3d6f4fb,0x4369e96a,0x346ed9fc,0xad678846,0xda60b8d0,0x44042d73,0x33031de5,0xaa0a4c5f,0xdd0d7cc9,0x5005713c,0x270241aa,0xbe0b1010,0xc90c2086,0x5768b525,0x206f85b3,0xb966d409,0xce61e49f,0x5edef90e,0x29d9c998,0xb0d09822,0xc7d7a8b4,0x59b33d17,0x2eb40d81,0xb7bd5c3b,0xc0ba6cad,0xedb88320,0x9abfb3b6,0x03b6e20c,0x74b1d29a,0xead54739,0x9dd277af,0x04db2615,0x73dc1683,0xe3630b12,0x94643b84,0x0d6d6a3e,0x7a6a5aa8,0xe40ecf0b,0x9309ff9d,0x0a00ae27,0x7d079eb1,0xf00f9344,0x8708a3d2,0x1e01f268,0x6906c2fe,0xf762575d,0x806567cb,0x196c3671,0x6e6b06e7,0xfed41b76,0x89d32be0,0x10da7a5a,0x67dd4acc,0xf9b9df6f,0x8ebeeff9,0x17b7be43,0x60b08ed5,0xd6d6a3e8,0xa1d1937e,0x38d8c2c4,0x4fdff252,0xd1bb67f1,0xa6bc5767,0x3fb506dd,0x48b2364b,0xd80d2bda,0xaf0a1b4c,0x36034af6,0x41047a60,0xdf60efc3,0xa867df55,0x316e8eef,0x4669be79,0xcb61b38c,0xbc66831a,0x256fd2a0,0x5268e236,0xcc0c7795,0xbb0b4703,0x220216b9,0x5505262f,0xc5ba3bbe,0xb2bd0b28,0x2bb45a92,0x5cb36a04,0xc2d7ffa7,0xb5d0cf31,0x2cd99e8b,0x5bdeae1d,0x9b64c2b0,0xec63f226,0x756aa39c,0x026d930a,0x9c0906a9,0xeb0e363f,0x72076785,0x05005713,0x95bf4a82,0xe2b87a14,0x7bb12bae,0x0cb61b38,0x92d28e9b,0xe5d5be0d,0x7cdcefb7,0x0bdbdf21,0x86d3d2d4,0xf1d4e242,0x68ddb3f8,0x1fda836e,0x81be16cd,0xf6b9265b,0x6fb077e1,0x18b74777,0x88085ae6,0xff0f6a70,0x66063bca,0x11010b5c,0x8f659eff,0xf862ae69,0x616bffd3,0x166ccf45,0xa00ae278,0xd70dd2ee,0x4e048354,0x3903b3c2,0xa7672661,0xd06016f7,0x4969474d,0x3e6e77db,0xaed16a4a,0xd9d65adc,0x40df0b66,0x37d83bf0,0xa9bcae53,0xdebb9ec5,0x47b2cf7f,0x30b5ffe9,0xbdbdf21c,0xcabac28a,0x53b39330,0x24b4a3a6,0xbad03605,0xcdd70693,0x54de5729,0x23d967bf,0xb3667a2e,0xc4614ab8,0x5d681b02,0x2a6f2b94,0xb40bbe37,0xc30c8ea1,0x5a05df1b,0x2d02ef8d}local function b(c,d)d=d and bit32.bnot(d)or 0xFFFFFFFF;for e=1,#c do d=bit32.bxor(a[bit32.band(bit32.bxor(c:byte(e),bit32.band(d,0xFF)))],bit32.rshift(d,8))end;return bit32.bnot(d)end;local function f()return('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'):gsub('[xy]',function(g)local h=g=='x'and math.random(0,0xf)or math.random(8,0xb)return('%x'):format(h)end)end;local function i(j,k)local l=fs.combine(j.root,k:sub(1,1)==\"/\"and\"\"or j.dir,k)if\"/\"..l..\"/\"~=j.root and l:find(j.root:sub(2),1,true)~=1 then error(k..\": No such file or directory\",4)end;return l end;local m={}local n={file=0,link=2,directory=5,fifo=6,[0]=\"file\",[2]=\"link\",[5]=\"directory\",[6]=\"fifo\"}local function o(p)local q=(\"<I\"):unpack(p.read(4))local r=p.read(q)local s={meta={permissions={}}}local type,t,u,v,w;s.meta.size,s.meta.created,s.meta.modified,type,t,u,s.meta.owner,v,w=(\"<II8I8BBs2s2B\"):unpack(r)s.meta.type=n[type]s.meta.setuser=bit32.btest(t,0x80)s.meta.worldPermissions={read=bit32.btest(t,4),write=bit32.btest(t,2),execute=bit32.btest(t,1)}for _=1,v do local x,y;x,y,w=(\"<s2B\"):unpack(r,w)s.meta.permissions[x]={read=bit32.btest(y,4),write=bit32.btest(y,2),execute=bit32.btest(y,1)}end;if type==0 then local z=p.read(16)s.uuid=z:gsub(\".\",function(g)return(\"%02x\"):format(g:byte())end):gsub(\"(%x%x%x%x%x%x%x%x)(%x%x%x%x)(%x%x%x%x)(%x%x%x%x)(%x%x%x%x%x%x%x%x%x%x%x%x)\",\"%1-%2-%3-%4-%5\")local A=(\"<H\"):unpack(p.read(2))s.ids={(\"<\"..(\"H\"):rep(A)):unpack(p.read(A*2))}s.ids[#s.ids]=nil;s.checksum=(\"<I\"):unpack(p.read(4))elseif type==2 then local B=(\"<H\"):unpack(p.read(2))s.link=p.read(B)elseif type==5 then local C=(\"<I\"):unpack(p.read(4))s.contents={}for _=1,C do local D,E=o(p)s.contents[D]=E end end;return u,s end;local function F(p,s,u)local G=\"\"local v=0;for H,h in pairs(s.meta.permissions)do v=v+1;G=G..(\"<s2B\"):pack(H,(h.read and 4 or 0)+(h.write and 2 or 0)+(h.execute and 1 or 0))end;local I=(\"<II8I8BBs2s2B\"):pack(s.meta.size,s.meta.created,s.meta.modified,n[s.meta.type],(s.meta.setuser and 128 or 0)+(s.meta.worldPermissions.read and 4 or 0)+(s.meta.worldPermissions.write and 2 or 0)+(s.meta.worldPermissions.execute and 1 or 0),u or\"\",s.meta.owner,v)..G;p.write((\"<I\"):pack(#I)..I)if s.meta.type==\"file\"then p.write(s.uuid:gsub(\"%-\",\"\"):gsub(\"%x%x\",function(J)return string.char(tonumber(J,16))end)..(\"<\"..(\"H\"):rep(#s.ids+1)):pack(#s.ids,table.unpack(s.ids))..(\"<I\"):pack(s.checksum))elseif s.meta.type==\"link\"then p.write((\"<s2\"):pack(s.link))elseif s.meta.type==\"directory\"then local D=0;for _ in pairs(s.contents)do D=D+1 end;p.write((\"<I4\"):pack(D))for H,h in pairs(s.contents)do F(p,h,H)end end end;local function K(q,L,M)q=math.max(q,500)local N,O={},{}for _,h in ipairs(M)do O[h]=true end;for _,h in ipairs(L)do if not O[h]and h.space>=500 then N[#N+1]=h end end;table.sort(N,function(P,Q)if P.space==Q.space then return P.id>Q.id else return P.space>Q.space end end)local R={}while q>N[1].space do R[N[1].id]=N[1].space;q=q-N[1].space;table.remove(N,1)if#N==0 then return nil end end;if q==0 then return R end;table.sort(N,function(P,Q)if P.space==Q.space then return P.id>Q.id else return P.space>Q.space end end)for e=#N,1,-1 do if q<N[e].space then R[N[e].id]=q;return R end end;return nil end;function m:_write_meta()local p=assert(fs.open(fs.combine(self.disks[0],\"index\"),\"wb\"))F(p,self.index,self.name)p.close()end;function m:getpath(x,k,S)local T=self.index;local U=split(fs.combine(k),\"/\\\\\")for e,l in ipairs(U)do if not T then return nil elseif T.meta.type~=\"directory\"then error(\"Not a directory\",2)elseif T.meta.permissions[x]then if not T.meta.permissions[x].execute then error(\"Permission denied\",2)end elseif not T.meta.worldPermissions.execute then error(\"Permission denied\",2)end;T=T.contents[l]if T and T.meta.type==\"link\"and not(S and e==#U)then error{link=true,path=filesystem.combine(T.link,table.unpack(U,e+1)),orig=k}end end;return T end;function m:setpath(x,k,r,S)local T=self.index;local E=split(k,\"/\\\\\")local V=E[#E]E[#E]=nil;for e,l in ipairs(E)do if T.meta.type~=\"directory\"then error(\"Not a directory\",2)elseif T.meta.permissions[x]then if not T.meta.permissions[x].execute then error(\"Permission denied\",2)end elseif not T.meta.worldPermissions.execute then error(\"Permission denied\",2)end;if not T.contents[l]then T.contents[l]={meta={type=\"directory\",owner=T.meta.owner,permissions=deepcopy(T.meta.permissions),worldPermissions=deepcopy(T.meta.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\"},contents={}}end;T=T.contents[l]if T and T.meta.type==\"link\"then error{link=true,path=filesystem.combine(T.link,table.unpack(E,e+1)),orig=k}end end;if T.meta.type~=\"directory\"then error(\"Not a directory\",2)elseif x~=\"root\"then if T.meta.permissions[x]then if not T.meta.permissions[x].execute then error(\"Permission denied\",2)end elseif not T.meta.worldPermissions.execute then error(\"Permission denied\",2)end end;if not S and T.contents[V]and T.contents[V].type==\"link\"then error{link=true,path=T.contents[V].link,orig=k}end;T.contents[V]=r;self:_write_meta()end;function m:new(j,k,W)if k:match\"^/\"then k=k:gsub(\"/%.spanfs$\",\"\"):gsub(\"/index$\",\"\")local p=assert(fs.open(fs.combine(k,\".spanfs\"),\"r\"))p.readLine()k=p.readLine()p.close()end;local X=setmetatable({disks={},index={},id={}},{__index=self})local z,u=false,false;if k:match\"^%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x$\"then z=k else u=k end;for _,Y in ipairs{hardware.find(\"drive\")}do local Z=hardware.call(j,Y,\"getMountPath\")if Z then local p=fs.open(fs.combine(Z,\".spanfs\"),\"r\")if p then local D,a0,a1=p.readLine(),p.readLine(),p.readLine()if D==u or a0==z then X.name,X.uuid,X.disks[tonumber(a1)]=D,a0,Z end;p.close()end end end;if#X.disks==0 then error(\"Could not find span '\"..(u or z)..\"'\",2)end;if not X.disks[0]then error(\"Could not find index disk for span '\"..(u or z)..\"'\",2)end;local p,a2=fs.open(fs.combine(X.disks[0],\"index\"),\"rb\")if p then _,X.index=o(p)else syslog.log({level=\"warning\",module=\"spanfs\"},\"Could not open index file for reading on span '\"..(u or z)..\"':\",a2,\". Initializing empty span.\")X.index={meta={size=0,created=os.epoch\"utc\",modified=os.epoch\"utc\",type=\"directory\",owner=j.user,permissions={[j.user]={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}}end;return X end;function m:_open_internal(j,k,a3)local a4,fs,do_syscall,ipairs,assert,pairs,a5=os.epoch,fs,do_syscall,ipairs,assert,pairs,string.sub;local s=self:getpath(j.user,k)if not s then return nil,\"No such file\"end;if a3==\"r\"or a3==\"rb\"then local r=\"\"for _,h in ipairs(s.ids)do if not self.disks[h]then return nil,\"Disk ID \"..h..\" is required by file but not available\"end;local p,a2=fs.open(fs.combine(self.disks[h],s.uuid),\"rb\")if not p then return nil,\"Could not open part on disk ID \"..h..\" (\"..self.disks[h]..\"): \"..a2 end;r=r..(p.readAll()or\"\")p.close()end;local a6=b(r)if a6~=s.checksum then return nil,\"Checksum failed\"end;return filesystem.readhandle(j,r,a3==\"rb\")elseif a3==\"w\"or a3==\"wb\"or#s.ids==0 and(a3==\"a\"or a3==\"ab\")then for _,h in ipairs(s.ids)do fs.delete(fs.combine(self.disks[h],s.uuid))end;s.uuid=f()s.ids={}s.checksum=0;s.meta.modified=a4\"utc\"local a7={}local a8,a9=self.id,self.disks;return filesystem.writehandle(j,function(aa,ab)local a6=b(aa,ab and 0 or s.checksum)if#aa==0 then if ab then s.meta.size=0 end;s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)return end;if#a7~=0 then if ab then for _,h in ipairs(a7)do local a1=a5(aa,1,#h.data)if a1~=h.data then local p=assert(fs.open(fs.combine(a9[h.id],s.uuid),\"wb\"))p.write(a1)p.close()h.data=a1 end;aa=a5(aa,#h.data+1)end;if#aa==0 then if ab then s.meta.size=#aa else s.meta.size=s.meta.size+#aa end;s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)return end end;local ac=fs.getFreeSpace(a9[s.ids[#s.ids]])if ac>0 then local a1=a5(aa,1,ac)local p=assert(fs.open(fs.combine(a9[s.ids[#s.ids]],s.uuid),\"ab\"))p.write(a1)p.close()a7[#a7].data=a7[#a7].data..a1;if ac>#aa then if ab then s.meta.size=#aa else s.meta.size=s.meta.size+#aa end;s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)return end;aa=a5(aa,ac+1)end end;local N={}for e,h in pairs(a9)do if e~=0 then N[#N+1]={id=e,space=fs.getFreeSpace(h)}end end;local ad=K(#aa,N,s.ids)if not ad then if not ab then ab=true;local I=\"\"for _,h in ipairs(a7)do I=I..h.data;for _,ae in ipairs(N)do if ae==h.id then ae.space=ae.space-#h.data end end end;aa=I..aa end;ad=K(#aa,N,{})if not ad then error(\"Out of space\",2)end;for _,h in ipairs(s.ids)do fs.delete(fs.combine(a9[h],s.uuid))end;a7={}s.ids={}end;for e,h in pairs(ad)do local a1=a5(aa,1,h)local p=assert(fs.open(fs.combine(a9[e],s.uuid),\"wb\"))p.write(a1)p.close()a7[#a7+1]={data=a1,id=e}s.ids[#s.ids+1]=e;aa=a5(aa,h+1)end;if ab then s.meta.size=#aa else s.meta.size=s.meta.size+#aa end;s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)end,a3==\"wb\")elseif a3==\"a\"or a3==\"ab\"then local af;do local p=fs.open(fs.combine(self.disks[s.ids[#s.ids]],s.uuid),\"rb\")if p then af=p.readAll()or\"\"p.close()else af=\"\"end end;local a7={{id=s.ids[#s.ids],data=af,offset=#af}}local ag=s.checksum;local ah=s.meta.size;local a8,a9=self.id,self.disks;return filesystem.writehandle(j,function(aa,ab)local a6=b(aa,ab and ag or s.checksum)if#aa==0 then s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)return end;if ab then for _,h in ipairs(a7)do local a1=h.offset and h.data:sub(1,h.offset)..a5(aa,1,#h.data-h.offset)or a5(aa,1,#h.data)if a1~=h.data then local p=assert(fs.open(fs.combine(a9[h.id],s.uuid),\"wb\"))p.write(a1)p.close()h.data=a1 end;aa=a5(aa,#h.data-(h.offset or 0)+1)end;if#aa==0 then if ab then s.meta.size=ah+#aa else s.meta.size=s.meta.size+#aa end;s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)return end end;local ac=fs.getFreeSpace(a9[s.ids[#s.ids]])if ac>0 then local a1=a5(aa,1,ac)local p=assert(fs.open(fs.combine(a9[s.ids[#s.ids]],s.uuid),\"ab\"))p.write(a1)p.close()a7[#a7].data=a7[#a7].data..a1;if ac>#aa then if ab then s.meta.size=ah+#aa else s.meta.size=s.meta.size+#aa end;s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)return end;aa=a5(aa,ac+1)end;local N={}for e,h in pairs(a9)do if e~=0 then N[#N+1]={id=e,space=fs.getFreeSpace(h)}end end;local ad=K(#aa,N,s.ids)if not ad then local ai=\"\"for _,h in ipairs(s.ids)do local aj=false;for _,ae in ipairs(a7)do if ae.id==h then aj=true;break end end;if aj then break end;local p=assert(fs.open(fs.combine(a9[h],s.uuid),\"rb\"))ai=ai..(p.readAll()or\"\")p.close()end;if ab then aa=ai..a5(a7[1].data,1,a7[1].offset)..aa else ab=true;local I=\"\"for _,h in ipairs(a7)do I=I..h.data;for _,ae in ipairs(N)do if ae==h.id then ae.space=ae.space-#h.data end end end;aa=ai..I..aa end;ad=K(#aa,N,{})if not ad then error(\"Out of space\",2)end;for _,h in ipairs(s.ids)do fs.delete(fs.combine(a9[h],s.uuid))end;a7={}s.ids={}ah=0 end;for e,h in pairs(ad)do local a1=a5(aa,1,h)local p=assert(fs.open(fs.combine(a9[e],s.uuid),\"wb\"))p.write(a1)p.close()a7[#a7+1]={data=a1,id=e}aa=a5(aa,h+1)end;if ab then s.meta.size=ah+#aa else s.meta.size=s.meta.size+#aa end;s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)end,a3==\"ab\")else return nil,\"Invalid mode\"end end;function m:open(j,k,a3)local ak,al=pcall(self.stat,self,j,k)if not ak then if type(al)==\"table\"then error(al)end;return nil,al elseif not al then if a3:sub(1,1)==\"w\"or a3:sub(1,1)==\"a\"then local am,an=pcall(self.stat,self,j,fs.getDir(k))if not am or not an then if type(an)==\"table\"then error(an)end;local ao,a2=pcall(self.mkdir,self,j,fs.getDir(k))if not ao then if type(a2)==\"table\"then error(a2)end;return nil,a2:gsub(\"kernel:%d: \",\"\")end;an=self:stat(j,fs.getDir(k))end;if j.user~=\"root\"then local G=an.permissions[j.user]or an.worldPermissions;if not G.write then return nil,\"Permission denied\"end end;local ap={type=\"file\",size=0,owner=j.user,permissions=deepcopy(an.permissions),worldPermissions=deepcopy(an.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\"}local T=ap.permissions[an.owner]ap.permissions[an.owner]=nil;ap.permissions[j.user]=T;self:setpath(j.user,k,{meta=ap,uuid=f(),ids={},checksum=0})return self:_open_internal(j,k,a3)else return nil,\"File not found\"end elseif al.type==\"directory\"then return nil,\"Is a directory\"end;if j.user~=\"root\"then local G=al.permissions[j.user]or al.worldPermissions;if a3:sub(1,1)==\"r\"and not G.read or(a3:sub(1,1)==\"w\"or a3:sub(1,1)==\"a\")and not G.write then return nil,\"Permission denied\"end end;if al.type==\"fifo\"then local ap=self:getpath(j.user,k)local aq=fifos[ap]if not aq then aq={data=\"\"}fifos[ap]=aq end;return filesystem.fifohandle(j,aq,a3)end;return self:_open_internal(j,k,a3)end;function m:list(j,k)local r=self:getpath(j.user,k)if not r or r.meta.type~=\"directory\"then error(k..\": Not a directory\",2)end;if j.user~=\"root\"then local G=r.meta.permissions[j.user]or r.meta.worldPermissions;if not G.read then error(k..\": Permission denied\",2)end end;local R={}for H in pairs(r.contents)do R[#R+1]=H end;table.sort(R)return R end;function m:stat(j,k,S)local r=self:getpath(j.user,k,S)if not r then return nil,\"No such file or directory\"end;local ar,as=0,0;for e,h in pairs(self.disks)do if e~=0 then ar,as=ar+fs.getCapacity(h),as+fs.getFreeSpace(h)end end;return{size=r.meta.size,type=r.meta.type,created=r.meta.created,modified=r.meta.modified,owner=r.meta.owner,permissions=deepcopy(r.meta.permissions),worldPermissions=deepcopy(r.meta.worldPermissions),setuser=r.meta.setuser,capacity=ar,freeSpace=as,link=r.link,special={}}end;function m:remove(j,k)local at=self:getpath(j.user,fs.getDir(k))local u=fs.getName(k)if not at or at.meta.type~=\"directory\"or not at.contents[u]then return end;if j.user~=\"root\"and not(at.meta.permissions[j.user]or at.meta.worldPermissions).write then error(k..\": Permission denied\",2)end;local r=at.contents[u]if j.user~=\"root\"and not(r.meta.permissions[j.user]or r.meta.worldPermissions).write then error(k..\": Permission denied\",2)end;local function au(I)local G=I.meta.permissions[j.user]or I.meta.worldPermissions;if j.user~=\"root\"and not G.write then error(k..\": Permission denied\",3)end;if I.meta.type==\"directory\"then if j.user~=\"root\"and not G.read then error(k..\": Permission denied\",3)end;for _,h in pairs(I.contents)do au(h)end end end;au(r)local function av(s)if s.meta.type==\"directory\"then for _,h in pairs(s.contents)do av(h)end elseif s.meta.type==\"file\"then for _,h in pairs(self.disks)do fs.delete(fs.combine(h,s.uuid))end end end;av(r)at.contents[u]=nil;at.meta.modified=os.epoch\"utc\"self:_write_meta()end;function m:rename(j,aw,ax)local ay=self:getpath(j.user,fs.getDir(aw))local az=fs.getName(aw)if not ay or ay.meta.type~=\"directory\"or not ay.contents[az]then error(aw..\": No such file or directory\",2)end;if j.user~=\"root\"and not(fparen.metat.permissions[j.user]or ay.meta.worldPermissions).write then error(aw..\": Permission denied\",2)end;local aA=ay.contents[az]if j.user~=\"root\"and not(aA.permissions[j.user]or aA.worldPermissions).write then error(aw..\": Permission denied\",2)end;local aB=self:getpath(j.user,fs.getDir(ax))local aC=fs.getName(ax)if not aB or aB.meta.type~=\"directory\"then error(ax..\": No such file or directory\",2)end;if j.user~=\"root\"and not(aB.meta.permissions[j.user]or aB.meta.worldPermissions).write then error(ax..\": Permission denied\",2)end;local aD=aB.contents[aC]if aD then error(ax..\": File already exists\",2)end;aB.contents[aC],ay.contents[az]=aA,nil;local aE=os.epoch\"utc\"ay.meta.modified,aB.meta.modified=aE,aE end;function m:mkdir(j,k)local T=self.index;for _,l in ipairs(split(k,\"/\\\\\"))do local G=T.meta.permissions[j.user]or T.meta.worldPermissions;if T.meta.type~=\"directory\"then error(k..\": File exists\",2)elseif j.user~=\"root\"and not G.execute then error(k..\": Permission denied\",2)end;if not T.contents[l]then if j.user~=\"root\"and not G.write then error(k..\": Permission denied\",2)end;T.contents[l]={meta={type=\"directory\",size=0,owner=T.meta.owner,permissions=deepcopy(T.meta.permissions),worldPermissions=deepcopy(T.meta.worldPermissions),created=os.epoch\"utc\",modified=os.epoch\"utc\"},contents={}}T.meta.modified=os.epoch\"utc\"end;T=T.contents[l]end;self:_write_meta()end;function m:link(j,k,aF)local al=self:stat(j,k)if al then error(k..\": File exists\",2)end;local am,an=pcall(self.stat,self,j,fs.getDir(k))if not am or not an then if type(an)==\"table\"then error(an)end;local ao,a2=pcall(self.mkdir,self,j,fs.getDir(k))if not ao then if type(a2)==\"table\"then error(a2)end;return nil,type(a2)==\"string\"and a2:gsub(\"kernel:%d: \",\"\")or a2 end;an=self:stat(j,fs.getDir(k))end;self:setpath(j.user,k,{meta={type=\"link\",size=0,owner=j.user,permissions=deepcopy(an.permissions),worldPermissions=deepcopy(an.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\"},link=aF},true)end;function m:mkfifo(j,k)local al=self:stat(j,k)if al then error(k..\": File exists\",2)end;local am,an=pcall(self.stat,self,j,fs.getDir(k))if not am or not an then if type(an)==\"table\"then error(an)end;local ao,a2=pcall(self.mkdir,self,j,fs.getDir(k))if not ao then if type(a2)==\"table\"then error(a2)end;return nil,type(a2)==\"string\"and a2:gsub(\"kernel:%d: \",\"\")or a2 end;an=self:stat(j,fs.getDir(k))end;self:setpath(j.user,k,{meta={type=\"fifo\",size=0,owner=j.user,permissions=deepcopy(an.permissions),worldPermissions=deepcopy(an.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\"}},true)end;function m:chmod(j,k,x,a3)local al=self:getpath(j.user,k,true)if not al then error(k..\": No such file or directory\",2)end;if not al.meta.owner or j.user~=\"root\"and j.user~=al.meta.owner then error(k..\": Permission denied\",2)end;local G;if x==nil then G=al.meta.worldPermissions else G=al.meta.permissions[x]if not G then G=deepcopy(al.meta.worldPermissions)al.meta.permissions[x]=G end end;if type(a3)==\"string\"then if a3:match\"^[%+%-=][rwxs]+$\"then local aG=a3:sub(1,1)local T={}for g in a3:gmatch(\"[rwxs]\")do if g==\"r\"then T.read=true elseif g==\"w\"then T.write=true elseif g==\"s\"then T.setuser=true else T.execute=true end end;if aG==\"+\"then if T.read then G.read=true end;if T.write then G.write=true end;if T.execute then G.execute=true end;if T.setuser then al.meta.setuser=true end elseif aG==\"-\"then if T.read then G.read=false end;if T.write then G.write=false end;if T.execute then G.execute=false end;if T.setuser then al.meta.setuser=false end else G.read=T.read or false;G.write=T.write or false;G.execute=T.execute or false;al.meta.setuser=T.setuser or false end else G.read=a3:sub(1,1)~=\"-\"G.write=a3:sub(2,2)~=\"-\"G.execute=a3:sub(3,3)~=\"-\"al.meta.setuser=a3:sub(3,3)==\"s\"end elseif type(a3)==\"number\"then al.meta.setuser=bit32.btest(a3,8)G.read=bit32.btest(a3,4)G.write=bit32.btest(a3,2)G.execute=bit32.btest(a3,1)else if a3.read~=nil then G.read=a3.read end;if a3.write~=nil then G.write=a3.write end;if a3.execute~=nil then G.execute=a3.execute end;if a3.setuser~=nil then al.meta.setuser=a3.setuser end end;self:_write_meta()end;function m:chown(j,k,aH)local al=self:getpath(j.user,k,true)if not al then error(k..\": No such file or directory\",2)end;if not al.meta.owner or j.user~=\"root\"and j.user~=al.meta.owner then error(k..\": Permission denied\",2)end;al.meta.owner=aH;al.meta.setuser=false;self:_write_meta()end;function m:info()return\"spanfs\",self.uuid,{}end;filesystems.spanfs=m;syslog.log({module=\"spanfs\"},\"spanfs is now loaded\")return{_write_meta=function(j,aI,a8)for _,h in pairs(mounts)do if h[1]then for _,ae in ipairs(h)do if ae.id==a8 then return m._write_meta(ae)end end elseif h.id==a8 then return m._write_meta(h)end end;error(\"Invalid mount handle\")end,info=function(j,aI,k)expect(1,k,\"string\")k=i(j,k)local aG=mounts[k]if not aG then error(k..\": No such mount\",2)end;if aG:info()~=\"spanfs\"then error(k..\": Not a spanfs filesystem\",2)end;local aJ={}for _,Y in ipairs{hardware.find(\"drive\")}do local l=hardware.call(j,Y,\"getMountPath\")if l then aJ[l]=Y.uuid end end;local R={disks={},name=aG.name,uuid=aG.uuid}R.freeindex=fs.getFreeSpace(aG.disks[0])for e,h in pairs(aG.disks)do if e~=0 then R.disks[e]={device=aJ[h],space=fs.getFreeSpace(h)}end end;return R end,unload=function()filesystems.spanfs=nil end}\n",setuser=false,size=23942,modified=1757997042609,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["compressfs.lua"]={permissions={root={write=true,read=true,execute=false}},created=1757997040055,data="local a,b=pcall(require,\"LibDeflate\")if not a then syslog.log({module=\"compressfs\",level=\"debug\"},\"Could not load libdeflate:\",b)end;local c,d=pcall(require,\"deflateans\")if not c then syslog.log({module=\"compressfs\",level=\"debug\"},\"Could not load deflateans:\",d)end;local e,f=pcall(require,\"luz\")if not e then syslog.log({module=\"compressfs\",level=\"debug\"},\"Could not load luz:\",f)end;local g={}if a then g[#g+1]=\"deflate\"end;if c then g[#g+1]=\"deflateans\"end;if e then g[#g+1]=\"luz\"end;syslog.log({module=\"compressfs\"},\"Supported compression types:\",table.concat(g,\", \"))local h={}function h:new(i,j,k)if not filesystems[k.compressfs_basefs or\"craftos\"]then error(\"Unknown base filesystem type '\"..k.compressfs_basefs..\"'\")end;local l=tonumber(k.compressfs_level)or 5;local m={}for n in(k.compressfs_type or\"deflate\"):gmatch\"[^;,:]+\"do m[n]=true end;local o={}for p,q in pairs(k)do if not string.match(p,\"^compressfs_\")then o[p]=q end end;return setmetatable({fs=filesystems[k.compressfs_basefs or\"craftos\"]:new(i,j,o),types=m,level=l},{__index=self})end;function h:readfile(r)if r.read(3)==\"Cfs\"then local s=r.read()if s==0 then if not a then r.close()return nil,\"Missing required library for compression type (libdeflate)\"end;r.read(4)local t=r.readAll()r.close()return b:DecompressDeflate(t)elseif s==1 then if not c then r.close()return nil,\"Missing required library for compression type (deflateans)\"end;r.read(4)local t=r.readAll()r.close()return d.inflate(t)elseif s==2 then if not e then r.close()return nil,\"Missing required library for compression type (luz)\"end;r.read(4)local t=r.readAll()r.close()return f.decompress(t)elseif s and s<32 then r.close()return nil,\"Unknown compression type\"end end;return nil end;function h:writefile(i,j,u)if#u<512 and not u:match\"^Cfs[\\0-\\31]\"then local r=assert(self.fs:open(i,j,\"wb\"))r.write(u)r.close()return end;local n,t;if self.types.luz and e and(function()local v;v,t=pcall(f.compress,u,self.level,false)return v end)()then n=2 elseif self.types.deflateans and c then t,n=d.deflate(u,self.level),1 elseif self.types.deflate and a then t,n=b:CompressDeflate(u,{level=self.level}),0 else error(\"No selected compression algorithms available\")end;local r=assert(self.fs:open(i,j,\"wb\"))r.write(\"Cfs\")r.write(n)r.write((\"<I\"):pack(#u))r.write(t)r.close()end;local w=setmetatable({},{__mode=\"k\"})local function x(i,y,z,A,B)local C=w[z]if not C then error(\"Invalid file handle\")end;if B then C.buf=A else C.buf=C.buf..A end;C.self:writefile(i,C.path,C.buf)end;function h:open(i,j,D)if D:sub(1,1)==\"r\"then local r,E=self.fs:open(i,j,\"rb\")if not r then return r,E end;local u,E=self:readfile(r)if u then return filesystem.readhandle(i,u,D:find\"b\")elseif E then return nil,E end;r.seek(\"set\",0)return r elseif D:sub(1,1)==\"w\"then local do_syscall=do_syscall;local C;C=filesystem.writehandle(i,function(A,B)do_syscall(\"callmodule\",\"compressfs\",\"_writefile\",C,A,B)end,D==\"wb\")w[C]={self=self,path=j,buf=\"\"}return C elseif D:sub(1,1)==\"a\"then local r,E=self.fs:open(i,j,\"rb\")if not r then return r,E end;local u,E=self:readfile(r)if u then return filesystem.readhandle(i,u,D:find\"b\")elseif E then return nil,E else r.seek(\"set\",0)u=r.readAll()r.close()end;local do_syscall=do_syscall;local C;C=filesystem.writehandle(i,function(A,B)do_syscall(\"callmodule\",\"compressfs\",\"_writefile\",C,A,B)end,D==\"ab\")w[C]={self=self,path=j,buf=u}return C else return nil,\"Unknown mode\"end end;function h:list(i,j)return self.fs:list(i,j)end;function h:stat(i,j,F)local G=self.fs:stat(i,j,F)if G and G.type==\"file\"then local r=self.fs:open(i,j,\"rb\")if r then if r.read(3)==\"Cfs\"then r.read()G.size=(\"<I\"):unpack(r.read(4))end;r.close()end end;return G end;function h:remove(i,j)return self.fs:remove(i,j)end;function h:rename(i,j,H)return self.fs:rename(i,j,H)end;function h:mkdir(i,j)return self.fs:mkdir(i,j)end;function h:link(i,j,I)return self.fs:link(i,j,I)end;function h:mkfifo(i,j)return self.fs:mkfifo(i,j)end;function h:chmod(i,j,J,D)return self.fs:chmod(i,j,J,D)end;function h:chown(i,j,K)return self.fs:chown(i,j,K)end;function h:info()local L,j,M=self.fs:info()local m={}for p in pairs(self.types)do m[#m+1]=p end;M.compressfs_type=table.concat(m,\",\")return L..\":compressfs\",j,M end;function h:unmount(i)if self.fs.unmount then self.fs:unmount(i)end end;filesystems.compressfs=h;syslog.log({module=\"compressfs\"},\"compressfs is now loaded\")return{unload=function()filesystems.compressfs=nil end,_writefile=x}\n",setuser=false,size=4443,modified=1757997040052,worldPermissions={write=false,read=true,execute=false},type="file",owner="root"},["luz.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997041339,data="if not PHOENIX_VERSION and not entries then error(\"This must be loaded as a kernel module.\")end;if entries then local a,b=...local c=dofile(fs.combine(fs.getDir(b),\"../luz/decompress.lua\"))function cmds.kernel(d)bootcfg.fn=unbios;bootcfg.args={d.path}local e=fs.open(d.path,\"rb\")if e then if e.read(5)==\"\\27LuzQ\"then local f=\"\\27LuzQ\"..e.readAll()e.close()print(\"Loading \"..d.path..\"...\")bootcfg.args={assert(load(c(f),\"@\"..d.path,\"t\",_G))}else e.close()end end end else local g=filesystem.stat(KERNEL,\"/lib/luz/decompress.lua\")if not g then error(\"Could not find Luz modules\")end;if g.worldPermissions.write then error(\"Unsafe permissions on /lib/luz/decompress.lua (must not be world-writable)\")end;for h,i in pairs(g.permissions)do if h~=\"root\"and i.write then error(\"Unsafe permissions on /lib/luz/decompress.lua (writable by non-root user)\")end end;local c=dofile(\"/lib/luz/decompress.lua\")local function j(f,k,l,m)if f:sub(1,5)~=\"\\27LuzQ\"then return nil end;return load(c(f),k,\"t\",m)end;addProcessLoader(j)syslog.log({module=\"luz\"},\"Registered Luz files as executable\")return{unload=function()removeProcessLoader(j)end}end\n",setuser=false,size=1129,modified=1757997041333,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["encryptfs.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040511,data="local a={}local b=require\"ccryptolib.aead\"local c=require\"ccryptolib.random\"local d=require\"ccryptolib.sha256\"if not c.isInit()then syslog.log({module=\"encryptfs\"},\"Initializing secure randomizer, this will take a second...\")c.initWithTiming()end;function a:getpath(e,f,g)local h=self.meta;if f==\"/\"or f==\"\"then return h end;local i=split(f,\"/\\\\\")for j,k in ipairs(i)do if not h then return nil elseif h.type~=\"directory\"then return nil,\"Not a directory\"elseif h.permissions[e]then if not h.permissions[e].execute then return nil,\"Permission denied\"end elseif not h.worldPermissions.execute then return nil,\"Permission denied\"end;h=h.contents[k]if h and h.type==\"link\"and not(g and j==#i)then error{link=true,path=filesystem.combine(h.link,table.unpack(i,j+1)),orig=f}end end;return h end;function a:setpath(l,f,m,g)local e=l.user;local h=self.meta;local n=split(f,\"/\\\\\")local o=n[#n]n[#n]=nil;for j,k in ipairs(n)do if h.type~=\"directory\"then error(\"Not a directory\",2)elseif h.permissions[e]then if not h.permissions[e].execute then error(\"Permission denied\",2)end elseif not h.worldPermissions.execute then error(\"Permission denied\",2)end;if not h.contents[k]then h.contents[k]={type=\"directory\",owner=h.owner,permissions=deepcopy(h.permissions),worldPermissions=deepcopy(h.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\",contents={}}end;h=h.contents[k]if h and h.type==\"link\"then error{link=true,path=filesystem.combine(h.link,table.unpack(n,j+1)),orig=f}end end;if h.type~=\"directory\"then error(\"Not a directory\",2)elseif e~=\"root\"then if h.permissions[e]then if not h.permissions[e].execute then error(\"Permission denied\",2)end elseif not h.worldPermissions.execute then error(\"Permission denied\",2)end end;if not g and h.contents[o]and h.contents[o].type==\"link\"then error{link=true,path=h.contents[o].link,orig=f}end;h.contents[o]=m;self:write_meta(l)end;function a:write_meta(l)if os.epoch\"utc\"-self.lastDispatch>1000 then self:write_encrypted(l,self.metapath,serialize(self.meta,{compact=true}))self.lastDispatch=os.epoch\"utc\"end end;function a:read_encrypted(l,p)local q,r=self.fs:open(l,p,\"rb\")if not q then return nil,r end;if q.read(4)~=\"Efs\\x01\"then q.close()return nil,\"Invalid file\"end;local s=q.read(12)local t=q.read(16)local u=q.readAll()q.close()local m=b.decrypt(self.key,s,t,u,s)if not m then return nil,\"Failed to decrypt\"end;return m end;function a:write_encrypted(l,p,m)local s=c.random(12)local u,t=b.encrypt(self.key,s,m,s)syslog.debug(p,#m)local q=assert(self.fs:open(l,p,\"wb\"))q.write(\"Efs\\x01\")q.write(s)q.write(t)q.write(u)q.close()end;function a:new(l,f,v)if type(v.encryptfs_password)~=\"string\"then error(\"Missing password (encryptfs_password option)\")end;if not filesystems[v.encryptfs_basefs or\"craftos\"]then error(\"Unknown base filesystem type '\"..v.encryptfs_basefs..\"'\")end;local w={}for x,y in pairs(v)do if not string.match(x,\"^encryptfs_\")then w[x]=y end end;local z=setmetatable({fs=filesystems[v.encryptfs_basefs or\"craftos\"]:new(l,f,w),lastDispatch=0},{__index=self})local q,r=z.fs:open(l,d.digest(v.encryptfs_password..\" encryptfs salt file \\x12\\x34\\x56\\x78\\x9A\\xBC\\xDE\\xF0\"):gsub(\".\",function(A)return(\"%02x\"):format(A:byte())end),\"rb\")if not q then if z.fs.unmount then z.fs:unmount(l)end;error(\"Could not open salt file: \"..r..\" - make sure the filesystem is properly formatted\")end;if q.read(4)~=\"Efs\\x00\"then q.close()if z.fs.unmount then z.fs:unmount(l)end;error(\"Invalid filesystem structure - make sure the filesystem is properly formatted\")end;local B=q.read(28)z.metapath=q.read(32):gsub(\".\",function(A)return(\"%02x\"):format(A:byte())end)q.close()syslog.log({module=\"encryptfs\"},\"Generating key, this will hang the system for a few seconds...\")z.key=d.pbkdf2(v.encryptfs_password,B,v.encryptfs_iter or 5000)z.meta,r=z:read_encrypted(l,z.metapath)if not z.meta then if z.fs.unmount then z.fs:unmount(l)end;error(\"Could not read meta file: \"..r..\" - make sure the filesystem is properly formatted\")end;z.meta=unserialize(z.meta)return z end;local C=setmetatable({},{__mode=\"k\"})local function D(l,E,F,G,H)local I=C[F]if not I then error(\"Invalid file handle\")end;if H then I.buf=G else I.buf=I.buf..G end;I.self:write_encrypted(l,I.key,I.buf)end;function a:_open_internal(l,f,J)local do_syscall=do_syscall;local K=self:getpath(l.user,f)if not K then return nil,\"No such file\"end;if J==\"r\"or J==\"rb\"then local m,r=self:read_encrypted(l,K.key)if not m then return nil,r end;return filesystem.readhandle(l,m,J==\"rb\")elseif J==\"w\"or J==\"wb\"then local q;q=filesystem.writehandle(l,function(G,H)do_syscall(\"callmodule\",\"encryptfs\",\"_writefile\",q,G,H)end,J==\"wb\")C[q]={self=self,key=K.key,buf=\"\"}return q elseif J==\"a\"or J==\"ab\"then local q;q=filesystem.writehandle(l,function(G,H)do_syscall(\"callmodule\",\"encryptfs\",\"_writefile\",q,G,H)end,J==\"ab\")C[q]={self=self,key=K.key,buf=self:read_encrypted(l,K.key)}return q else return nil,\"Invalid mode\"end end;function a:open(l,f,J)local L,M=pcall(self.stat,self,l,f)if not L then if type(M)==\"table\"then error(M)end;return nil,M elseif not M then if J:sub(1,1)==\"w\"or J:sub(1,1)==\"a\"then local N,O=pcall(self.stat,self,l,fs.getDir(f))if not N or not O then if type(O)==\"table\"then error(O)end;local P,r=pcall(self.mkdir,self,l,fs.getDir(f))if not P then if type(r)==\"table\"then error(r)end;return nil,r:gsub(\"kernel:%d: \",\"\")end;O=self:stat(l,fs.getDir(f))end;if l.user~=\"root\"then local Q=O.permissions[l.user]or O.worldPermissions;if not Q.write then return nil,\"Permission denied\"end end;local R={type=\"file\",owner=l.user,permissions=deepcopy(O.permissions),worldPermissions=deepcopy(O.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\",key=c.random(32):gsub(\".\",function(A)return(\"%02x\"):format(A:byte())end)}local h=R.permissions[O.owner]R.permissions[O.owner]=nil;R.permissions[l.user]=h;self:setpath(l,f,R)return self:_open_internal(l,f,J)else return nil,\"File not found\"end elseif M.type==\"directory\"then return nil,\"Is a directory\"end;if l.user~=\"root\"then local Q=M.permissions[l.user]or M.worldPermissions;if J:sub(1,1)==\"r\"and not Q.read or(J:sub(1,1)==\"w\"or J:sub(1,1)==\"a\")and not Q.write then return nil,\"Permission denied\"end end;if M.type==\"fifo\"then local R=self:getpath(l.user,f)local S=fifos[R]if not S then S={data=\"\"}fifos[R]=S end;return filesystem.fifohandle(l,S,J)end;return self:_open_internal(l,f,J)end;function a:list(l,f)local m=self:getpath(l.user,f)if not m or m.type~=\"directory\"then error(f..\": Not a directory\",2)end;if l.user~=\"root\"then local Q=m.permissions[l.user]or m.worldPermissions;if not Q.read then error(f..\": Permission denied\",2)end end;local T={}for x in pairs(m.contents)do T[#T+1]=x end;table.sort(T)return T end;function a:stat(l,f,g)local m,r=self:getpath(l.user,f,g)if not m then return nil,r or\"No such file\"end;if m.type==\"file\"then return self.fs:stat(l,m.key,g)end;local U=self.fs:stat(l,\"\")return{size=m.type==\"directory\"and#m.contents or 0,type=m.type,created=m.created,modified=m.modified,owner=m.owner,permissions=deepcopy(m.permissions),worldPermissions=deepcopy(m.worldPermissions),setuser=m.setuser,capacity=U.capacity,freeSpace=U.freeSpace,link=m.link,special={}}end;function a:remove(l,f)if self.readOnly then error(\"Read-only filesystem\",2)end;local V=self:getpath(l.user,fs.getDir(f))local p=fs.getName(f)if not V or V.type~=\"directory\"or not V.contents[p]then return end;if l.user~=\"root\"and not(V.permissions[l.user]or V.worldPermissions).write then error(f..\": Permission denied\",2)end;local m=V.contents[p]if l.user~=\"root\"and not(m.permissions[l.user]or m.worldPermissions).write then error(f..\": Permission denied\",2)end;local function W(X)local Q=X.permissions[l.user]or X.worldPermissions;if l.user~=\"root\"and not Q.write then error(f..\": Permission denied\",3)end;if X.type==\"directory\"then if l.user~=\"root\"and not Q.read then error(f..\": Permission denied\",3)end;for Y,y in pairs(X.contents)do W(y)end end end;W(m)local function Z(k,_)local a0=k.contents[_]if a0.type==\"file\"then self.fs:remove(l,a0.key)elseif a0.type==\"directory\"then for Y,y in ipairs(a0.contents)do Z(a0,y)end end;k.contents[_]=nil;k.modified=os.epoch\"utc\"end;Z(V,p)self:write_meta(l)end;function a:rename(l,a1,a2)if self.readOnly then error(\"Read-only filesystem\",2)end;local a3=self:getpath(l.user,fs.getDir(a1))local a4=fs.getName(a1)if not a3 or a3.type~=\"directory\"or not a3.contents[a4]then error(a1 ..\": No such file or directory\",2)end;if l.user~=\"root\"and not(a3.permissions[l.user]or a3.worldPermissions).write then error(a1 ..\": Permission denied\",2)end;local a5=a3.contents[a4]if l.user~=\"root\"and not(a5.permissions[l.user]or a5.worldPermissions).write then error(a1 ..\": Permission denied\",2)end;local a6=self:getpath(l.user,fs.getDir(a2))local a7=fs.getName(a2)if not a6 or a6.type~=\"directory\"then error(a2 ..\": No such file or directory\",2)end;if l.user~=\"root\"and not(a6.permissions[l.user]or a6.worldPermissions).write then error(a2 ..\": Permission denied\",2)end;local a8=a6.contents[a7]if a8 then error(a2 ..\": File already exists\",2)end;a6.contents[a7],a3.contents[a4]=a5,nil;local a9=os.epoch\"utc\"a3.modified,a6.modified=a9,a9;self:write_meta(l)end;function a:mkdir(l,f)local h=self.meta;for Y,k in ipairs(split(f,\"/\\\\\"))do local Q=h.permissions[l.user]or h.worldPermissions;if h.type~=\"directory\"then error(f..\": File exists\",2)elseif l.user~=\"root\"and not Q.execute then error(f..\": Permission denied\",2)end;if not h.contents[k]then if l.user~=\"root\"and not Q.write then error(f..\": Permission denied\",2)end;h.contents[k]={type=\"directory\",owner=h.owner,permissions=deepcopy(h.permissions),worldPermissions=deepcopy(h.worldPermissions),created=os.epoch\"utc\",modified=os.epoch\"utc\",contents={}}h.modified=os.epoch\"utc\"end;h=h.contents[k]end;self:write_meta(l)end;function a:link(l,f,aa)local M=self:stat(l,f)if M then error(f..\": File exists\",2)end;local N,O=pcall(self.stat,self,l,fs.getDir(f))if not N or not O then if type(O)==\"table\"then error(O)end;local P,r=pcall(self.mkdir,self,l,fs.getDir(f))if not P then if type(r)==\"table\"then error(r)end;return nil,type(r)==\"string\"and r:gsub(\"kernel:%d: \",\"\")or r end;O=self:stat(l,fs.getDir(f))end;self:setpath(l,f,{type=\"link\",owner=l.user,permissions=deepcopy(O.permissions),worldPermissions=deepcopy(O.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\",path=aa},true)end;function a:mkfifo(l,f)local M=self:stat(l,f)if M then error(f..\": File exists\",2)end;local N,O=pcall(self.stat,self,l,fs.getDir(f))if not N or not O then if type(O)==\"table\"then error(O)end;local P,r=pcall(self.mkdir,self,l,fs.getDir(f))if not P then if type(r)==\"table\"then error(r)end;return nil,type(r)==\"string\"and r:gsub(\"kernel:%d: \",\"\")or r end;O=self:stat(l,fs.getDir(f))end;self:setpath(l,f,{type=\"fifo\",owner=l.user,permissions=deepcopy(O.permissions),worldPermissions=deepcopy(O.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\"},true)end;function a:chmod(l,f,e,J)local M=self:getpath(l.user,f,true)if not M then error(f..\": No such file or directory\",2)end;if not M.owner or l.user~=\"root\"and l.user~=M.owner then error(f..\": Permission denied\",2)end;if M.type==\"file\"then self.fs:chmod(l,M.key,e,J)end;local Q;if e==nil then Q=M.worldPermissions else Q=M.permissions[e]if not Q then Q=deepcopy(M.worldPermissions)M.permissions[e]=Q end end;if type(J)==\"string\"then if J:match\"^[%+%-=][rwxs]+$\"then local ab=J:sub(1,1)local h={}for A in J:gmatch(\"[rwxs]\")do if A==\"r\"then h.read=true elseif A==\"w\"then h.write=true elseif A==\"s\"then h.setuser=true else h.execute=true end end;if ab==\"+\"then if h.read then Q.read=true end;if h.write then Q.write=true end;if h.execute then Q.execute=true end;if h.setuser then M.setuser=true end elseif ab==\"-\"then if h.read then Q.read=false end;if h.write then Q.write=false end;if h.execute then Q.execute=false end;if h.setuser then M.setuser=false end else Q.read=h.read or false;Q.write=h.write or false;Q.execute=h.execute or false;M.setuser=h.setuser or false end else Q.read=J:sub(1,1)~=\"-\"Q.write=J:sub(2,2)~=\"-\"Q.execute=J:sub(3,3)~=\"-\"M.setuser=J:sub(3,3)==\"s\"end elseif type(J)==\"number\"then M.setuser=bit32.btest(J,8)Q.read=bit32.btest(J,4)Q.write=bit32.btest(J,2)Q.execute=bit32.btest(J,1)else if J.read~=nil then Q.read=J.read end;if J.write~=nil then Q.write=J.write end;if J.execute~=nil then Q.execute=J.execute end;if J.setuser~=nil then M.setuser=J.setuser end end;self:write_meta(l)end;function a:chown(l,f,ac)if self.readOnly then error(\"Read-only filesystem\",2)end;local M=self:getpath(l.user,f,true)if not M then error(f..\": No such file or directory\",2)end;if not M.owner or l.user~=\"root\"and l.user~=M.owner then error(f..\": Permission denied\",2)end;if M.type==\"file\"then self.fs:chown(l,M.key,ac)end;M.owner=ac;M.setuser=false;self:write_meta(l)end;function a:info()local ad,ae,w=self.fs:info()return ad..\":encryptfs\",ae,w end;function a:unmount(l)self:write_encrypted(l,self.metapath,serialize(self.meta,{compact=true}))if self.fs.unmount then self.fs:unmount(l)end end;filesystems.encryptfs=a;syslog.log({module=\"encryptfs\"},\"encryptfs is now loaded\")return{unload=function()filesystems.encryptfs=nil end,_writefile=D}\n",setuser=false,size=13188,modified=1757997040505,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["yellowbox.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997043421,data="if not processes then error(\"This must be loaded as a kernel module.\")end;local a={}local b={}local c={}local d={}local e={}local function f()local g,h=coroutine.yield(\"syscall\",\"getpid\")local i=a[h]coroutine.yield(\"syscall\",\"callmodule\",\"yellowbox\",\"__tick\")local function j(k)for l,m in pairs(i.peripherals)do if m.uuid==k then return l else local g,n=coroutine.yield(\"syscall\",\"devinfo\",k)if m.uuid==n.uuid then return l end end end end;while i.running do local o,p=coroutine.yield()coroutine.yield(\"syscall\",\"syslog\",{module=\"yellowbox\",level=\"debug\"},\"Got event \"..o)if o==\"remote_event\"and type(p.data)==\"table\"then table.insert(p.data,1,p.type)if p.data.n then p.data.n=p.data.n+1 else p.data.n=#p.data end;i.eventQueue[#i.eventQueue+1]=p.data elseif o==\"timer\"then i.eventQueue[#i.eventQueue+1]={\"timer\",p.id,n=2}elseif o==\"alarm\"then i.eventQueue[#i.eventQueue+1]={\"alarm\",p.id,n=2}elseif o==\"disk\"or o==\"disk_eject\"or o==\"monitor_resize\"or o==\"speaker_audio_empty\"then local l=j(p.device)if l then i.eventQueue[#i.eventQueue+1]={o,l}end elseif o==\"mouse_click\"and p.device then local l=j(p.device)if l then i.eventQueue[#i.eventQueue+1]={\"monitor_touch\",l,p.x,p.y}end elseif o==\"modem_message\"then local l=j(p.device)if l then i.eventQueue[#i.eventQueue+1]={o,l,p.channel,p.replyChannel,p.message,p.distance}end end;while#i.eventQueue>0 do coroutine.yield(\"syscall\",\"callmodule\",\"yellowbox\",\"__tick\")end end end;function e.create(q,r,s)expect(1,s,\"table\")expect.field(s,\"bios\",\"string\")expect.field(s,\"root\",\"string\",\"nil\")expect.field(s,\"user\",\"string\",\"nil\")expect.field(s,\"peripherals\",\"table\",\"nil\")expect.field(s,\"http\",\"boolean\",\"nil\")if q.user~=\"root\"then error(\"This function requires root.\",0)end;local i={eventQueue={},peripherals={},redstone={top={input=0,output=0,bundledInput=0,bundledOutput=0},bottom={input=0,output=0,bundledInput=0,bundledOutput=0},left={input=0,output=0,bundledInput=0,bundledOutput=0},right={input=0,output=0,bundledInput=0,bundledOutput=0},front={input=0,output=0,bundledInput=0,bundledOutput=0},back={input=0,output=0,bundledInput=0,bundledOutput=0}},coro=false,running=true,bios=s.bios}local h=syscalls.fork(q,r,f,\"[yellowbox]\")i.pid=h;a[h]=i;local t=processes[h]local u=t.threads[0]t.dependents[#t.dependents+1]={type=\"yellowbox\",gc=function()a[h]=nil end}syscalls.chdir(t,u,\"/\")if s.root then syscalls.chroot(t,u,s.root)end;if s.user then syscalls.setuser(t,u,s.user)end;if s.peripherals then for l,v in pairs(s.peripherals)do local m=hardware.get(v)if not m then i.running=false;error(\"Device '\"..v..\"' does not exist\",0)end;if m.process then i.running=false;error(\"Could not lock device '\"..v..\"'\",0)end;m.process=t.id;m.listeners[t]=true;t.dependents[#t.dependents+1]={type=\"hardware lock\",node=m,gc=function()m.process=nil end}t.dependents[#t.dependents+1]={type=\"hardware listen\",node=m,gc=function()m.listeners[t]=nil end}i.peripherals[l]=m end end;i.tty=terminal.makeTTY(term,51,19)i.tty.id=math.random(0,0x7FFFFFFF)i.tty.process=t;terminal.userTTYs[i.tty]=i.tty;syscalls.stdin(t,u,i.tty)syscalls.stdout(t,u,i.tty)syscalls.stderr(t,u,i.tty)i.env=createLuaLib(t)i.env._G=i.env;i.env._HOST=_HOST:match(\"^[^%(]+\")..\"(YellowBox 1.0 under Phoenix \"..PHOENIX_VERSION..\")\"i.env._CC_DEFAULT_SETTINGS=\"\"i.env.os=nil;i.env.io=nil;i.env.dofile=nil;i.env.loadfile=nil;i.env.load=function(w,l,x,y)return load(w,l,x,y or i.env)end;i.env.loadstring=i.env.load;i.env.getfenv,i.env.setfenv=getfenv,setfenv;i.env.unpack=table.unpack;i.env.require=nil;i.env.package=nil;i.env.print=nil;local function z(A,...)local B=coroutine.create(A)local C=table.pack(B:resume(...))while B:status()==\"suspended\"do C=table.pack(B:resume(coroutine.yield(\"preempt\",...)))end;if not C[1]then error(debug.traceback(B,C[2]),3)end;return table.unpack(C,2,C.n)end;local expect=expect;local filesystem=filesystem;local hardware=hardware;local syscalls=syscalls;local D=terminal.redraw;i.env.fs={}function i.env.fs.list(v)expect(1,v,\"string\")return z(filesystem.list,t,v)end;i.env.fs.combine=fs.combine;i.env.fs.getName=fs.getName;i.env.fs.getDir=fs.getDir;function i.env.fs.getSize(v)expect(1,v,\"string\")local E=z(filesystem.stat,t,v)if not E then return 0 end;return E.size end;function i.env.fs.exists(v)expect(1,v,\"string\")return z(filesystem.stat,t,v)~=nil end;function i.env.fs.isDir(v)expect(1,v,\"string\")local E=z(filesystem.stat,t,v)return E and E.type==\"directory\"end;function i.env.fs.isReadOnly(v)expect(1,v,\"string\")local E=z(filesystem.stat,t,v)if not E then return fs.isReadOnly(fs.getDir(v))end;if E.permissions[t.user]then return not E.permissions[t.user].write else return not E.worldPermissions.write end end;function i.env.fs.makeDir(v)expect(1,v,\"string\")return z(filesystem.mkdir,t,v)end;function i.env.fs.move(F,G)expect(1,F,\"string\")expect(2,G,\"string\")local H=assert(z(filesystem.stat,t,F,true),\"File not found\")local I=z(filesystem.stat,t,G)if I then error(\"File already exists\",2)end;local v=fs.getDir(G)repeat I,v=z(filesystem.stat,t,v),fs.getDir(v)until I;if H.type==\"directory\"then local J=z(filesystem.list,t,F)z(filesystem.mkdir,t,G)for g,K in ipairs(J)do fs.move(fs.combine(F,K),fs.combine(G,K))end elseif H.mountpoint==I.mountpoint then z(filesystem.rename,t,F,G)else local L,M=z(filesystem.open,t,F,\"rb\")if not L then error(M,2)end;local N=L.readAll()L.close()local O,M=z(filesystem.open,t,G,\"wb\")if not O then error(M,2)end;z(filesystem.remove,t,F)if N then O.write(N)end;O.close()end;z(filesystem.chmod,t,G,nil,H.worldPermissions)for P,K in pairs(H.permissions)do z(filesystem.chmod,t,G,P,K)end;if H.owner then z(filesystem.chown,t,G,H.owner)end;if H.setuser then pcall(z,filesystem.chmod,G,H.owner,\"+s\")end end;function i.env.fs.copy(F,G)expect(1,F,\"string\")expect(2,G,\"string\")local E=assert(z(filesystem.stat,t,F),F..\": No such file or directory\")if E.type==\"directory\"then local J=z(filesystem.list,t,F)z(filesystem.mkdir,t,G)for g,K in ipairs(J)do fs.copy(fs.combine(F,K),fs.combine(G,K))end else local L,M=z(filesystem.open,t,F,\"rb\")if not L then error(M,2)end;local O,M=z(filesystem.open,t,G,\"wb\")if not O then L.close()error(M,2)end;repeat local Q=L.read(512)if Q then O.write(Q)end until not Q;O.close()L.close()end end;function i.env.fs.delete(v)expect(1,v,\"string\")return z(filesystem.remove,t,v)end;function i.env.fs.open(v,x)expect(1,v,\"string\")expect(2,x,\"string\")return z(filesystem.open,t,v,x)end;function i.env.fs.getDrive(v)expect(1,v,\"string\")local E=z(filesystem.stat,t,v)if not E then return fs.getFreeSpace(fs.getDir(v))end;return E.mountpoint end;function i.env.fs.getFreeSpace(v)expect(1,v,\"string\")local E=z(filesystem.stat,t,v)if not E then return fs.getFreeSpace(fs.getDir(v))end;return E.freeSpace end;function i.env.fs.getCapacity(v)expect(1,v,\"string\")local E=z(filesystem.stat,t,v)if not E then return fs.getFreeSpace(fs.getDir(v))end;return E.capacity end;function i.env.fs.attributes(v)expect(1,v,\"string\")local E=z(filesystem.stat,t,v)if not E then return nil end;local R;if E.permissions[t.user]then R=not E.permissions[t.user].write else R=not E.worldPermissions.write end;return{size=E.size,isDir=E.type==\"directory\",isReadOnly=R,created=E.created,modified=E.modified}end;i.env.os={}function i.env.os.startTimer(S)return syscalls.timer(t,u,S)end;function i.env.os.cancelTimer(T)return syscalls.cancel(t,u,T)end;function i.env.os.setAlarm(S)return syscalls.alarm(t,u,S)end;i.env.os.cancelAlarm=i.env.os.cancelTimer;function i.env.os.shutdown()i.coro=nil end;function i.env.os.reboot()i.coro=false end;function i.env.os.queueEvent(o,...)expect(1,o,\"string\")i.eventQueue[#i.eventQueue+1]={o,...,n=select(\"#\",...)+1}end;i.env.os.getComputerID=os.getComputerID;i.env.os.computerID=i.env.os.getComputerID;function i.env.os.getComputerLabel()return i.label end;i.env.os.computerLabel=i.env.os.getComputerLabel;function i.env.os.setComputerLabel(U)expect(1,U,\"string\",\"nil\")i.label=U end;function i.env.os.clock()return(os.epoch\"utc\"-i.start)/1000 end;i.env.os.time=os.time;i.env.os.day=os.day;i.env.os.epoch=os.epoch;i.env.os.date=os.date;i.env.peripheral={}function i.env.peripheral.isPresent(l)expect(1,l,\"string\")return i.peripherals[l]~=nil end;function i.env.peripheral.getType(l)expect(1,l,\"string\")local m=i.peripherals[l]if not m then return nil end;local V={}for g,K in ipairs(m.drivers)do V[#V+1]=K.type end;return table.unpack(V)end;function i.env.peripheral.hasType(l,type)expect(1,l,\"string\")expect(2,type,\"string\")local m=i.peripherals[l]if not m then error(\"No such peripheral\",2)end;for g,K in ipairs(m.drivers)do if K.type==type then return true end end;return false end;function i.env.peripheral.getMethods(l)expect(1,l,\"string\")local m=i.peripherals[l]if not m then error(\"No such peripheral\",2)end;if m.internalState.peripheral then return m.internalState.peripheral.getMethods(m.id)else local W={}for g,K in ipairs(m.drivers)do for P in pairs(K.methods)do W[#W+1]=P end end;return W end end;function i.env.peripheral.call(l,X,...)expect(1,l,\"string\")expect(2,X,\"string\")local m=i.peripherals[l]if not m then error(\"No such peripheral\",2)end;if m.internalState.peripheral then return m.internalState.peripheral.call(m.id,X,...)else return hardware.call(t,m,X,...)end end;i.env.redstone={}i.env.rs=i.env.redstone;function i.env.rs.getSides()return{\"top\",\"bottom\",\"left\",\"right\",\"front\",\"back\"}end;function i.env.rs.getInput(Y)expect(1,Y,\"string\")if not i.redstone[Y]then error(\"Invalid side\",2)end;return i.redstone[Y].input~=0 end;function i.env.rs.getOutput(Y)expect(1,Y,\"string\")if not i.redstone[Y]then error(\"Invalid side\",2)end;return i.redstone[Y].output~=0 end;function i.env.rs.setOutput(Y,Z)expect(1,Y,\"string\")expect(2,Z,\"boolean\")if not i.redstone[Y]then error(\"Invalid side\",2)end;i.redstone[Y].output=Z and 15 or 0 end;function i.env.rs.getAnalogInput(Y)expect(1,Y,\"string\")if not i.redstone[Y]then error(\"Invalid side\",2)end;return i.redstone[Y].input end;function i.env.rs.getAnalogOutput(Y)expect(1,Y,\"string\")if not i.redstone[Y]then error(\"Invalid side\",2)end;return i.redstone[Y].output end;function i.env.rs.setAnalogOutput(Y,Z)expect(1,Y,\"string\")expect(2,Z,\"number\")Z=math.floor(Z)expect.range(Z,0,15)if not i.redstone[Y]then error(\"Invalid side\",2)end;i.redstone[Y].output=Z end;i.env.rs.getAnalogueInput=i.env.rs.getAnalogInput;i.env.rs.getAnalogueOutput=i.env.rs.getAnalogOutput;i.env.rs.setAnalogueOutput=i.env.rs.setAnalogOutput;function i.env.rs.getBundledInput(Y)expect(1,Y,\"string\")if not i.redstone[Y]then error(\"Invalid side\",2)end;return i.redstone[Y].bundledInput end;function i.env.rs.getBundledOutput(Y)expect(1,Y,\"string\")if not i.redstone[Y]then error(\"Invalid side\",2)end;return i.redstone[Y].bundledOutput end;function i.env.rs.setBundledOutput(Y,Z)expect(1,Y,\"string\")expect(2,Z,\"number\")Z=math.floor(Z)expect.range(Z,0,65535)if not i.redstone[Y]then error(\"Invalid side\",2)end;i.redstone[Y].bundledOutput=Z end;function i.env.rs.testBundledInput(Y,_)expect(1,Y,\"string\")expect(2,_,\"number\")if not i.redstone[Y]then error(\"Invalid side\",2)end;return bit32.btest(i.redstone[Y].bundledInput,_)end;local a0=terminal.openterm(i.tty,t)i.env.term={}i.env.term.nativePaletteColor=term.nativePaletteColor;i.env.term.nativePaletteColour=term.nativePaletteColour;i.env.term.write=function(...)a0.write(...)D(i.tty)end;i.env.term.scroll=function(...)a0.scroll(...)D(i.tty)end;i.env.term.getCursorPos=a0.getCursorPos;i.env.term.setCursorPos=function(...)a0.setCursorPos(...)D(i.tty)end;i.env.term.getCursorBlink=a0.getCursorBlink;i.env.term.setCursorBlink=function(...)a0.setCursorBlink(...)D(i.tty)end;i.env.term.getSize=a0.getSize;i.env.term.clear=function(...)a0.clear(...)D(i.tty)end;i.env.term.clearLine=function(...)a0.clearLine(...)D(i.tty)end;i.env.term.isColor=a0.isColor;i.env.term.isColour=a0.isColour;i.env.term.blit=function(...)a0.blit(...)D(i.tty)end;function i.env.term.getBackgroundColor()return 2^a0.getBackgroundColor()end;function i.env.term.getTextColor()return 2^a0.getTextColor()end;function i.env.term.setBackgroundColor(a1)expect(1,a1,\"number\")a1=math.floor(a1)expect.range(a1,1,65535)return a0.setBackgroundColor(select(2,math.frexp(a1))-1)end;function i.env.term.setTextColor(a1)expect(1,a1,\"number\")a1=math.floor(a1)expect.range(a1,1,65535)return a0.setTextColor(select(2,math.frexp(a1))-1)end;function i.env.term.getPaletteColor(a1)expect(1,a1,\"number\")a1=math.floor(a1)expect.range(a1,1,65535)return a0.getPaletteColor(select(2,math.frexp(a1))-1)end;function i.env.term.setPaletteColor(a1,a2,a3,a4)expect(1,a1,\"number\")a1=math.floor(a1)expect.range(a1,1,65535)a0.setPaletteColor(select(2,math.frexp(a1))-1,a2,a3,a4)D(i.tty)end;i.env.term.getBackgroundColour=i.env.term.getBackgroundColor;i.env.term.setBackgroundColour=i.env.term.setBackgroundColor;i.env.term.getTextColour=i.env.term.getTextColor;i.env.term.setTextColour=i.env.term.setTextColor;i.env.term.setPaletteColour=i.env.term.setPaletteColor;i.env.term.getPaletteColour=i.env.term.getPaletteColor;for g,K in pairs(i.env.fs)do pcall(function()setfenv(K,i.env)debug.protect(K)end)end;for g,K in pairs(i.env.os)do pcall(function()setfenv(K,i.env)debug.protect(K)end)end;for g,K in pairs(i.env.peripheral)do pcall(function()setfenv(K,i.env)debug.protect(K)end)end;for g,K in pairs(i.env.rs)do pcall(function()setfenv(K,i.env)debug.protect(K)end)end;for g,K in pairs(i.env.term)do pcall(function()setfenv(K,i.env)debug.protect(K)end)end;if s.http~=false and http~=nil then i.env.http={}local a5,a6,a7=http.request,http.checkURL,http.websocket;function i.env.http.request(s,N,a8,a9)expect(1,s,\"table\",\"string\")if type(s)==\"string\"then s={url=s,body=N,headers=a8,binary=a9}end;local aa=a5(s)if aa then b[s.url]=i end;return aa end;function i.env.http.checkURL(ab)expect(1,ab,\"string\")local aa=a6(ab)if aa then c[ab]=i end;return aa end;function i.env.http.websocket(s,a8)expect(1,s,\"table\",\"string\")if type(s)==\"string\"then local aa=a7(s,a8)if aa then d[s]=i end;return aa else local aa=a7(s)if aa then d[s.url]=i end;return aa end end end;return h end;function e.getTTY(t,u,h)expect(1,h,\"number\")local i=a[h]if not i then return nil end;i.tty.process=t;local ac=setmetatable({},{__index=i.tty,__metatable={}})terminal.userTTYs[ac]=i.tty;return ac end;function e.shutdown(t,u,h)expect(1,h,\"number\")local i=a[h]if not i then error(\"Invalid PID\")end;i.coro=nil end;function e.reboot(t,u,h)expect(1,h,\"number\")local i=a[h]if not i then error(\"Invalid PID\")end;i.coro=false end;function e.stop(t,u,h)expect(1,h,\"number\")if t.user~=\"root\"then error(\"This function requires root.\",0)end;local i=a[h]if not i then error(\"Invalid PID\")end;i.running=false end;function e.__tick(t,u)local i=a[t.id]if not i then return end;if not i.coro then if i.coro==nil then i.eventQueue={}i.env.term.setBackgroundColor(32768)i.env.term.setTextColor(1)i.env.term.clear()i.env.term.setCursorPos(1,1)i.env.term.setCursorBlink(false)return end;local A,M=load(i.bios,\"@bios.lua\",\"t\",i.env)if not A then syslog.log({module=\"yellowbox\",process=t.id,level=\"error\"},\"Could not load BIOS:\",M)i.coro=nil;return end;i.coro=coroutine.create(A)i.start=os.epoch\"utc\"local C={n=0}while true do C=table.pack(i.coro:resume(table.unpack(C,1,C.n)))if not C[1]then syslog.log({module=\"yellowbox\",process=t.id,level=\"error\"},\"Error running BIOS:\",C[2])i.coro=nil;return end;if i.coro:status()~=\"suspended\"then syslog.log({module=\"yellowbox\",process=t.id,level=\"error\"},\"BIOS exited\")i.coro=nil;return end;if C[2]==\"preempt\"then C=table.pack(coroutine.yield(table.unpack(C,3,C.n)))else i.filter=C[2]break end end;return end;if#i.eventQueue==0 then return end;local ad=table.remove(i.eventQueue,1)syslog.debug(\"Sending event to box\",table.unpack(ad,1,ad.n))if i.filter==nil or i.filter==ad[1]or ad[1]==\"terminate\"then while true do ad=table.pack(i.coro:resume(table.unpack(ad,1,ad.n)))if not ad[1]then syslog.log({module=\"yellowbox\",process=t.id,level=\"error\"},\"Computer threw an error:\",ad[1])i.coro=nil;return end;if i.coro:status()~=\"suspended\"then syslog.log({module=\"yellowbox\",process=t.id,level=\"error\"},\"Computer exited\")i.coro=nil;return end;if ad[2]==\"preempt\"then ad=table.pack(coroutine.yield(table.unpack(ad,3,ad.n)))else i.filter=ad[2]break end end else syslog.debug(\"Event filtered\")end end;local function ae(ad)if b[ad[2]]then b[ad[2]].eventQueue[#b[ad[2]].eventQueue+1]=ad;processes[b[ad[2]].pid].eventQueue[#processes[b[ad[2]].pid].eventQueue+1]={\"resume\",{}}b[ad[2]]=nil;return true end end;local function af(ad)if d[ad[2]]then d[ad[2]].eventQueue[#d[ad[2]].eventQueue+1]=ad;processes[d[ad[2]].pid].eventQueue[#processes[d[ad[2]].pid].eventQueue+1]={\"resume\",{}}if ad[1]==\"websocket_closed\"or ad[1]==\"websocket_failure\"then d[ad[2]]=nil end;return true end end;eventHooks.http_failure=eventHooks.http_failure or{}eventHooks.http_success=eventHooks.http_success or{}eventHooks.http_check=eventHooks.http_check or{}eventHooks.websocket_closed=eventHooks.websocket_closed or{}eventHooks.websocket_failure=eventHooks.websocket_failure or{}eventHooks.websocket_message=eventHooks.websocket_message or{}eventHooks.websocket_success=eventHooks.websocket_success or{}local ag={http_failure=#eventHooks.http_failure+1,http_success=#eventHooks.http_success+1,http_check=#eventHooks.http_check+1,websocket_closed=#eventHooks.websocket_closed+1,websocket_failure=#eventHooks.websocket_failure+1,websocket_message=#eventHooks.websocket_message+1,websocket_success=#eventHooks.websocket_success+1}eventHooks.http_failure[ag.http_failure]=ae;eventHooks.http_success[ag.http_success]=ae;eventHooks.websocket_closed[ag.websocket_closed]=af;eventHooks.websocket_failure[ag.websocket_failure]=af;eventHooks.websocket_message[ag.websocket_message]=af;eventHooks.websocket_success[ag.websocket_success]=af;eventHooks.http_check[ag.http_check]=function(ad)if c[ad[2]]then c[ad[2]].eventQueue[#c[ad[2]].eventQueue+1]=ad;processes[c[ad[2]].pid].eventQueue[#processes[c[ad[2]].pid].eventQueue+1]={\"resume\",{}}c[ad[2]]=nil;return true end end;function e.unload()for h,i in pairs(a)do i.running=false end;table.remove(eventHooks.http_failure,ag.http_failure)table.remove(eventHooks.http_success,ag.http_success)table.remove(eventHooks.websocket_closed,ag.websocket_closed)table.remove(eventHooks.websocket_failure,ag.websocket_failure)table.remove(eventHooks.websocket_message,ag.websocket_message)table.remove(eventHooks.websocket_success,ag.websocket_success)end;syslog.log({module=\"yellowbox\"},\"YellowBox is now loaded\")return e\n",setuser=false,size=18392,modified=1757997043405,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},setuser=false,size=0,modified=1757997043421,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},luz={permissions={root={write=true,read=true,execute=true}},created=1757997041338,contents={["maketree.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997041337,data="local function a(b,c)return b.weight>c.weight end;local function d(b,c)if b.bits==c.bits then return b.symbol<c.symbol else return b.bits<c.bits end end;local function e(f,g,h,i)if f.data then i.symbol=f.data;h[f.data]=i;g[#g+1]=i else e(f[1],g,h,{bits=i.bits+1,code=i.code*2})e(f[2],g,h,{bits=i.bits+1,code=i.code*2+1})end end;local function j(k)local l={}for m,n in ipairs(k)do if n[2]>0 then l[#l+1]={data=n[1],weight=n[2]}end end;if#l==0 then return nil elseif#l==1 then for m,n in ipairs(k)do if n[1]==l[1].data then return false,m end end;return nil end;table.sort(l,a)while#l>1 do local b,c=l[#l-1],l[#l]local o={weight=b.weight+c.weight,b,c}l[#l]=nil;l[#l]=o;table.sort(l,a)end;local g,h={},{}e(l[1],g,h,{bits=0,code=0})table.sort(g,d)g[1].code=0;for m=2,#g do g[m].code=bit32.lshift(g[m-1].code+1,g[m].bits-g[m-1].bits)end;local p={}for m,n in ipairs(k)do p[m]=h[n[1]]and h[n[1]].bits or 0 end;local q={}for r,n in ipairs(g)do if n.bits==1 then q[n.code+1]=n.symbol else local f=q;for o=n.bits-1,1,-1 do local s=bit32.extract(n.code,o)+1;f[s]=f[s]or{}f=f[s]end;local s=bit32.extract(n.code,0)+1;f[s]=n.symbol end;n.symbol=nil end;return h,p,q end;return j\n",setuser=false,size=1165,modified=1757997041331,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["lz77.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997041337,data="local function a(b)if b==0 or b==1 then return{code=b,extra=0,bits=0}end;local c=math.max(select(2,math.frexp(b))-2,0)local d=2^c;return{code=c*2+(bit32.btest(b,d)and 3 or 2),extra=bit32.band(b,d-1),bits=c}end;local function e(f,g)g=math.min(g or 1024,32768)local h={}local i={}local b=1;while b<=#f do local j=f[b]if not j.names and i[j.type]and i[j.type][j.text]then local k=i[j.type][j.text]local l,m=0;for n=#k,1,-1 do local o=k[n]if b-o>g then break end;for p=1,math.min(#f-b,129)do local q=(p-1)%(b-o)+1;if f[b+p].type==f[o+q].type and f[b+p].text==f[o+q].text then if p>l then l,m=p,o end;if f[o+q].names then break end else break end end end;if l>=2 then local r=a(l-2)local s=a(b-m-1)h[#h+1]={type=\"repeat\"..r.code,text=\"\",dist=s,len=r}for p=0,l do j=f[b+p]i[j.type][j.text][#i[j.type][j.text]+1]=b+p end;if f[b+l].names then h[#h].names=f[b+l].names end;b=b+l+1;j=nil end end;if j then h[#h+1]=j;i[j.type]=i[j.type]or{}i[j.type][j.text]=i[j.type][j.text]or{}i[j.type][j.text][#i[j.type][j.text]+1]=b;b=b+1 end end;return h end;return e\n",setuser=false,size=1046,modified=1757997041331,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["token_encode_map.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997041338,data="return{string={code=494,bits=9},[\"-\"]={code=101,bits=7},table={code=1006,bits=10},[\"*\"]={code=229,bits=8},print={code=1004,bits=10},pairs={code=2031,bits=11},ipairs={code=2028,bits=11},getmetatable={code=4086,bits=12},setmetatable={code=2034,bits=11},[\";\"]={code=488,bits=9},os={code=1003,bits=10},unpack={code=2037,bits=11},select={code=4092,bits=12},tonumber={code=2035,bits=11},[\"..\"]={code=230,bits=8},_={code=2021,bits=11},pcall={code=4090,bits=12},open={code=2030,bits=11},load={code=8190,bits=13},[\"[\"]={code=107,bits=7},[\"%\"]={code=994,bits=10},[\"^\"]={code=4082,bits=12},[\"==\"]={code=106,bits=7},[\":repeat1\"]={code=18,bits=5},[\":repeat0\"]={code=5,bits=4},[\":repeat3\"]={code=46,bits=6},require={code=2033,bits=11},[\":repeat4\"]={code=47,bits=6},[\":repeat8\"]={code=234,bits=8},[\":repeat7\"]={code=233,bits=8},[\"\\\"table\\\"\"]={code=2018,bits=11},[\"{\"]={code=112,bits=7},sub={code=1005,bits=10},[\"/\"]={code=485,bits=9},[\"...\"]={code=996,bits=10},[\"and\"]={code=235,bits=8},type={code=496,bits=9},[\":repeat11\"]={code=997,bits=10},find={code=2027,bits=11},match={code=2029,bits=11},[\"or\"]={code=239,bits=8},gsub={code=4087,bits=12},[\"end\"]={code=21,bits=5},_G={code=2022,bits=11},math={code=1002,bits=10},[\".\"]={code=16,bits=5},[\"function\"]={code=110,bits=7},tostring={code=2036,bits=11},[\"}\"]={code=113,bits=7},[\"0\"]={code=102,bits=7},[\"<\"]={code=489,bits=9},close={code=2025,bits=11},[\"\\\"nil\\\"\"]={code=4079,bits=12},read={code=2032,bits=11},[\":name\"]={code=0,bits=2},[\"=\"]={code=6,bits=4},[\",\"]={code=4,bits=4},[\">=\"]={code=999,bits=10},[\":repeat2\"]={code=19,bits=5},[\"<=\"]={code=998,bits=10},[\"#\"]={code=228,bits=8},write={code=2038,bits=11},[\"~=\"]={code=241,bits=8},error={code=1000,bits=10},__index={code=4084,bits=12},[\":repeat13\"]={code=2020,bits=11},coroutine={code=2026,bits=11},[\">\"]={code=490,bits=9},_ENV={code=4083,bits=12},[\"\\\"\\\"\"]={code=484,bits=9},[\":repeat9\"]={code=487,bits=9},[\"\\\"r\\\"\"]={code=4080,bits=12},[\"\\\"w\\\"\"]={code=4081,bits=12},__call={code=16383,bits=14},[\"1\"]={code=103,bits=7},debug={code=4085,bits=12},[\"\\\"number\\\"\"]={code=2016,bits=11},[\"\\\"boolean\\\"\"]={code=8188,bits=13},[\"2\"]={code=231,bits=8},[\"\\\"function\\\"\"]={code=4078,bits=12},[\":string\"]={code=20,bits=5},[\"-1\"]={code=995,bits=10},self={code=240,bits=8},[\":number\"]={code=17,bits=5},[\":repeat5\"]={code=104,bits=7},[\":end\"]={code=16382,bits=14},[\":repeat12\"]={code=2019,bits=11},[\"break\"]={code=2024,bits=11},[\"do\"]={code=109,bits=7},[\"else\"]={code=236,bits=8},[\"elseif\"]={code=491,bits=9},[\":repeat10\"]={code=486,bits=9},[\"false\"]={code=492,bits=9},[\"for\"]={code=237,bits=8},bit32={code=2023,bits=11},[\"\\\"string\\\"\"]={code=2017,bits=11},[\"if\"]={code=48,bits=6},[\"in\"]={code=1001,bits=10},[\"local\"]={code=22,bits=5},[\"nil\"]={code=238,bits=8},[\"not\"]={code=493,bits=9},[\")\"]={code=15,bits=5},[\"repeat\"]={code=4091,bits=12},[\"return\"]={code=111,bits=7},[\"then\"]={code=49,bits=6},[\"true\"]={code=495,bits=9},[\"until\"]={code=4093,bits=12},[\"while\"]={code=1007,bits=10},[\"(\"]={code=14,bits=5},[\":repeat6\"]={code=105,bits=7},[\":\"]={code=232,bits=8},[\"]\"]={code=108,bits=7},package={code=4089,bits=12},io={code=4088,bits=12},__newindex={code=8189,bits=13},[\"+\"]={code=100,bits=7}}\n",setuser=false,size=3157,modified=1757997041332,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["lex.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997041337,data="local a={}function a.__tostring(self)return(self.src or\"unknown\")..\":\"..self.line..\": \"..self.text end;local function b(c,d,e)error(setmetatable({line=c,col=d,text=e},a),0)end;local f={operator=\"^([;:=%.,%[%]%(%)%{%}%+%-%*/%^%%<>~#&|][=%.]?%.?)()\",name=\"^([%a_][%w_]*)()\",number=\"^(%d+%.?%d*)()\",scinumber=\"^(%d+%.?%d*[eE][%+%-]?%d+)()\",hexnumber=\"^(0[xX]%x+%.?%x*)()\",scihexnumber=\"^(0[xX]%x+%.?%x*[pP][%+%-]?%x+)()\",linecomment=\"^(%-%-[^\\n]*)()\",blockcomment=\"^(%-%-%[(=*)%[.-%]%2%])()\",emptyblockcomment=\"^(%-%-%[(=*)%[%]%2%])()\",blockquote=\"^(%[(=*)%[.-%]%2%])()\",emptyblockquote=\"^(%[(=*)%[%]%2%])()\",dquote='^(\"[^\"]*\")()',squote=\"^('[^']*')()\",whitespace=\"^(%s+)()\",invalid=\"^([^%w%s_;:=%.,%[%]%(%)%{%}%+%-%*/%^%%<>~#&|]+)()\"}local g={\"name\",\"scihexnumber\",\"hexnumber\",\"scinumber\",\"number\",\"blockcomment\",\"emptyblockcomment\",\"linecomment\",\"blockquote\",\"emptyblockquote\",\"operator\",\"dquote\",\"squote\",\"whitespace\",\"invalid\"}local h={[\"break\"]=true,[\"do\"]=true,[\"else\"]=true,[\"elseif\"]=true,[\"end\"]=true,[\"for\"]=true,[\"function\"]=true,[\"if\"]=true,[\"in\"]=true,[\"local\"]=true,[\"repeat\"]=true,[\"return\"]=true,[\"then\"]=true,[\"until\"]=true,[\"while\"]=true}local i={[\"and\"]=true,[\"not\"]=true,[\"or\"]=true,[\"+\"]=true,[\"-\"]=true,[\"*\"]=true,[\"/\"]=true,[\"%\"]=true,[\"^\"]=true,[\"#\"]=true,[\"==\"]=true,[\"~=\"]=true,[\"<=\"]=true,[\">=\"]=true,[\"<\"]=true,[\">\"]=true,[\"=\"]=true,[\"(\"]=true,[\")\"]=true,[\"{\"]=true,[\"}\"]=true,[\"[\"]=true,[\"]\"]=true,[\"::\"]=true,[\";\"]=true,[\":\"]=true,[\",\"]=true,[\".\"]=true,[\"..\"]=true}local j={[\"&\"]=true,[\"~\"]=true,[\"|\"]=true,[\"<<\"]=true,[\">>\"]=true,[\"//\"]=true}local k={[\"true\"]=true,[\"false\"]=true,[\"nil\"]=true,[\"...\"]=true}local function l(m,e)local n=1;e=m.pending..e;m.pending=\"\"while true do local o=false;for p,q in ipairs(g)do local r,s,t=e:match(f[q],n)if r then if q==\"dquote\"or q==\"squote\"then local u=true;while not r:gsub(\"\\\\.\",\"\"):match(f[q])do local v;v,s=e:match(f[q],s-1)if not v then u=false;break end;r=r..v:sub(2)end;if not u then break end elseif q==\"operator\"and#r>1 then while not(i[r]or r==\"...\")and#r>1 do r,s=r:sub(1,-2),s-1 end end;if t then s=t end;o=true;m[#m+1]={type=q,text=r,line=m.line,col=m.col}n=s;local w=select(2,r:gsub(\"\\n\",\"\\n\"))if w==0 then m.col=m.col+#r else m.line=m.line+w;m.col=#r:match(\"[^\\n]*$\")end;break end end;if not o then m.pending=e:sub(n)break end end end;local function x(m,y,z)for A,q in ipairs(m)do if q.type==\"operator\"then if q.text==\"...\"then q.type=\"constant\"elseif not i[q.text]and(y<3 or not j[q.text])then b(q.line,q.col,\"invalid operator '\"..q.text..\"'\")end elseif q.type==\"name\"then if h[q.text]then q.type=\"keyword\"elseif i[q.text]then q.type=\"operator\"elseif k[q.text]then q.type=\"constant\"end elseif q.type==\"dquote\"or q.type==\"squote\"or q.type==\"blockquote\"or q.type==\"emptyblockquote\"then q.type=\"string\"elseif q.type==\"linecomment\"or q.type==\"blockcomment\"or q.type==\"emptyblockcomment\"then q.type=\"comment\"elseif q.type==\"hexnumber\"or q.type==\"scinumber\"or q.type==\"scihexnumber\"then q.type=\"number\"elseif q.type==\"invalid\"then b(q.line,q.col,\"invalid characters\")end end;if z then local B={}for A,q in ipairs(m)do if q.type==\"number\"and B[#B].type==\"operator\"and B[#B].text==\"-\"then local C=B[#B-1]if C.type==\"operator\"and C.text~=\"}\"and C.text~=\"]\"and C.text~=\")\"or C.type==\"keyword\"and C.text~=\"end\"then q.text=\"-\"..q.text;B[#B]=nil end end;if q.type~=\"whitespace\"and(z~=2 or q.type~=\"comment\")then B[#B+1]=q end end;return B end;m.pending,m.line,m.col=nil;return m end;local function D(E,y,z)if type(E)==\"string\"then local F=E;function E()local G=F;F=nil;return G end end;local m={pending=\"\",line=1,col=1}while true do local F=E()if not F then break end;l(m,F)end;if m.pending~=\"\"then b(m.line,m.col,\"unfinished string\")end;return x(m,y,z)end;return D\n",setuser=false,size=3737,modified=1757997041330,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["compress.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997041335,data="local a=require\"LibDeflate\"local b=require\"maketree\"local c=require\"lz77\"local d=require\"token_encode_map\"local e=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_\"local f={}for g,h in e:gmatch\"()(.)\"do f[h]=g-1 end;local function i(j)if j%1>=0.5 then return math.ceil(j)else return math.floor(j)end end;local function k(g)if g==0 or g==1 then return{code=g,extra=0,bits=0}end;local l=math.max(select(2,math.frexp(g))-2,0)local m=2^l;return{code=l*2+(bit32.btest(g,m)and 3 or 2),extra=bit32.band(g,m-1),bits=l}end;local function n()return setmetatable({data=\"\",partial=0,len=0},{__call=function(self,o,p)if not o then o,p=0,8-self.len end;if p==0 then return end;assert(o<2^p)self.partial=bit32.bor(bit32.lshift(self.partial,p),o)self.len=self.len+p;while self.len>=8 do local q=bit32.extract(self.partial,self.len-8,8)self.data=self.data..string.char(q)self.len=self.len-8 end end})end;local function r(s,t)local u={}while t>127 do u[#u+1],t=t%128,math.floor(t/128)end;u[#u+1]=t%128;if s then for g=#u,1,-1 do s(u[g]+(g==1 and 0 or 128),8)end end;return#u*8 end;local function v(s,t)if t%1==0 then if s then s(t<0 and 1 or 0,2)end;return r(s,math.abs(t))else local w,x=math.frexp(t)w=i((math.abs(w)-0.5)*0x20000000000000)if w>0xFFFFFFFFFFFFF then x=x+1 end;if s then s((t<0 and 6 or 4)+(x<0 and 1 or 0),3)end;x=math.abs(x)local y={}while x>7 do y[#y+1],x=x%8,math.floor(x/8)end;y[#y+1]=x%8;if s then for g=#y,1,-1 do s(y[g]+(g==1 and 0 or 8),4)end end;return r(s,w)+#y*4+3 end end;local function z(s,A)if not A or next(A)==nil then if s then s(0,5)end;return 5 elseif A.idx then if s then s(0,4)s(1,1)end;return r(s,A.idx-1)+5 end;local B=A.lengths;local C=select(2,math.frexp(A.maxlen))if s then s(C,4)end;local o=4;local h,j=B[1],0;local t,D=1,0;for E,F in ipairs(B)do if F~=h or j==85 then if j>21 then if s then s(3,2)s(j-22,6)end;o=o+8+C elseif j>5 then if s then s(2,2)s(j-6,4)end;o=o+6+C elseif j>1 then if s then s(1,2)s(j-2,2)end;o=o+4+C else if s then s(0,2)end;o=o+2+C end;if s then s(h,C)end;h,j=F,0;t=t+1;if h>1 then D=D+1 end end;j=j+1 end;if j>21 then if s then s(3,2)s(j-22,6)end;o=o+8+C elseif j>5 then if s then s(2,2)s(j-6,4)end;o=o+6+C elseif j>1 then if s then s(1,2)s(j-2,2)end;o=o+4+C else if s then s(0,2)end;o=o+2+C end;if s then s(h,C)end;if h>1 then D=D+1 end;return o end;local function G(H,I)local A={list={}}for g,J in pairs(I)do A.list[g]={J[1],H[J[1]]or 0}end;A.map,A.lengths=b(A.list)if not A.map then if A.map==nil then return nil elseif A.map==false then return{idx=A.lengths,map={[I[A.lengths][1]]={code=0,bits=0,extra=0}}}end end;A.maxlen=0;for E,J in pairs(A.lengths)do A.maxlen=math.max(A.maxlen,J)end;return A end;local function K(L,M)local N=M and(M==0 and 0 or 2^(M+6))local O,I,P,Q={},{},\"\",{}L=c(L,N)local R={}for E,F in ipairs(L)do if F.type:find\"^repeat\"then R[F.dist.code]=(R[F.dist.code]or 0)+1 end end;local S={}for g=0,29 do S[g+1]={g,R[g]or 0}end;local T={}T.map,T.lengths=b(S)if T.map then T.maxlen=0;for E,J in ipairs(T.lengths)do T.maxlen=math.max(T.maxlen,J)end elseif T.map==false then T={idx=T.lengths}end;for g,F in ipairs(L)do if F.type==\"name\"and not d[F.text]then local U;for V,J in ipairs(I)do if J==F.text then U=V;break end end;if U then F.code=k(U)O[F.code.code]=(O[F.code.code]or 0)+1;table.insert(I,1,table.remove(I,U))else F.code=k(0)O[0]=(O[0]or 0)+1;Q[#Q+1]=F.text;table.insert(I,1,F.text)end elseif F.type==\"string\"and not d[F.text]then F.str=load(\"return \"..F.text,\"=string\",\"t\",{})()P=P..F.str end end;local W={}for g=0,29 do W[#W+1]={g,O[g]or 0}end;local X=G(O,W)local H={[\":end\"]=1}for E,F in ipairs(L)do if d[F.text]then H[F.text]=(H[F.text]or 0)+1 else H[\":\"..F.type]=(H[\":\"..F.type]or 0)+1 end end;local Y={}for g=0,29 do if not d[\":repeat\"..g]then Y[#Y+1]={\":repeat\"..g,H[\":repeat\"..g]or 0}end end;for Z in pairs(d)do Y[#Y+1]={Z,H[Z]or 0}end;table.sort(Y,function(_,a0)return _[1]<a0[1]end)local a1=G(H,Y)local a2,a3=z(nil,a1),0;for E,F in ipairs(L)do if d[F.text]then a3=a3+d[F.text].bits;a2=a2+a1.map[F.text].bits elseif F.type==\"name\"then a3=a3+d[\":name\"].bits+X.map[F.code.code].bits+F.code.bits;a2=a2+a1.map[\":name\"].bits+X.map[F.code.code].bits+F.code.bits elseif F.type==\"string\"then a3=a3+d[\":string\"].bits+r(nil,#F.str)a2=a2+a1.map[\":string\"].bits+r(nil,#F.str)elseif F.type==\"number\"then a3=a3+d[\":number\"].bits+v(nil,tonumber(F.text))a2=a2+a1.map[\":number\"].bits+v(nil,tonumber(F.text))elseif F.type:find\"^repeat\"then a3=a3+d[\":\"..F.type].bits+F.len.bits+T.map[F.dist.code].bits+F.dist.bits;a2=a2+a1.map[\":\"..F.type].bits+F.len.bits+T.map[F.dist.code].bits+F.dist.bits else error(\"Could not find encoding for token \"..F.type..\"(\"..F.text..\")!\")end end;print(a3,a2)local s=n()s.data=\"\\27LuzQ\"..a:CompressDeflate(P,{level=M})local a4=#s.data-5;local a5=\"\"for E,F in ipairs(Q)do for h in F:gmatch\".\"do a5=a5 ..string.char(f[h])end;a5=a5 ..\"\\63\"end;local a6=a:CompressDeflate(a5,{level=M})s.data=s.data..a6;local a7=#s.data-a4-5;z(s,T)z(s,X)local a8;if a2<a3 then s(1,1)z(s,a1)a8=a1.map else s(0,1)a8=d end;print(a4,a7,#s.data-a7-a4-5,#I)local a9,aa,ab,ac,ad,ae,af=0,0,0,0,0,0,0;for E,F in ipairs(L)do if d[F.text]then s(a8[F.text].code,a8[F.text].bits)a9=a9+a8[F.text].bits elseif F.type==\"name\"then s(a8[\":name\"].code,a8[\":name\"].bits)a9=a9+a8[\":name\"].bits;s(X.map[F.code.code].code,X.map[F.code.code].bits)s(F.code.extra,F.code.bits)aa=aa+X.map[F.code.code].bits+F.code.bits elseif F.type==\"string\"then s(a8[\":string\"].code,a8[\":string\"].bits)a9=a9+a8[\":string\"].bits;ab=ab+r(s,#F.str)elseif F.type==\"number\"then s(a8[\":number\"].code,a8[\":number\"].bits)a9=a9+a8[\":number\"].bits;ac=ac+v(s,tonumber(F.text))elseif F.type:find\"^repeat\"then s(a8[\":\"..F.type].code,a8[\":\"..F.type].bits)a9=a9+a8[\":\"..F.type].bits;s(F.len.extra,F.len.bits)s(T.map[F.dist.code].code,T.map[F.dist.code].bits)s(F.dist.extra,F.dist.bits)ad=ad+F.len.bits+T.map[F.dist.code].bits+F.dist.bits;af=af+1 else error(\"Could not find encoding for token \"..F.type..\"(\"..F.text..\")!\")end end;s(a8[\":end\"].code,a8[\":end\"].bits)s()a9=a9+d[\":end\"].bits;print(a9/8,aa/8,ab/8,ac/8,ad/8,ae/8,af)return s.data end;return K\n",setuser=false,size=6084,modified=1757997041329,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["decompress.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997041336,data="local a={{\":name\",{{\",\",\":repeat0\"},{\"=\",{\"(\",\")\"}}}},{{{{\".\",\":number\"},{\":repeat1\",\":repeat2\"}},{{\":string\",\"end\"},{\"local\",{\":repeat3\",\":repeat4\"}}}},{{{{\"if\",\"then\"},{{\"+\",\"-\"},{\"0\",\"1\"}}},{{{\":repeat5\",\":repeat6\"},{\"==\",\"[\"}},{{\"]\",\"do\"},{\"function\",\"return\"}}}},{{{{\"{\",\"}\"},{{\"#\",\"*\"},{\"..\",\"2\"}}},{{{\":\",\":repeat7\"},{\":repeat8\",\"and\"}},{{\"else\",\"for\"},{\"nil\",\"or\"}}}},{{{{\"self\",\"~=\"},{{\"\\\"\\\"\",\"/\"},{\":repeat10\",\":repeat9\"}}},{{{\";\",\"<\"},{\">\",\"elseif\"}},{{\"false\",\"not\"},{\"string\",\"true\"}}}},{{{{\"type\",{\"%\",\"-1\"}},{{\"...\",\":repeat11\"},{\"<=\",\">=\"}}},{{{\"error\",\"in\"},{\"math\",\"os\"}},{{\"print\",\"sub\"},{\"table\",\"while\"}}}},{{{{{\"\\\"number\\\"\",\"\\\"string\\\"\"},{\"\\\"table\\\"\",\":repeat12\"}},{{\":repeat13\",\"_\"},{\"_G\",\"bit32\"}}},{{{\"break\",\"close\"},{\"coroutine\",\"find\"}},{{\"ipairs\",\"match\"},{\"open\",\"pairs\"}}}},{{{{\"read\",\"require\"},{\"setmetatable\",\"tonumber\"}},{{\"tostring\",\"unpack\"},{\"write\",{\"\\\"function\\\"\",\"\\\"nil\\\"\"}}}},{{{{\"\\\"r\\\"\",\"\\\"w\\\"\"},{\"^\",\"_ENV\"}},{{\"__index\",\"debug\"},{\"getmetatable\",\"gsub\"}}},{{{\"io\",\"package\"},{\"pcall\",\"repeat\"}},{{\"select\",\"until\"},{{\"\\\"boolean\\\"\",\"__newindex\"},{\"load\",{\":end\",\"__call\"}}}}}}}}}}}}}}local b,c,d=bit32.rshift,bit32.lshift,bit32.band;local e,f=string.byte,string.char;local g,unpack=table.concat,unpack or table.unpack;local h=math.min;local i={17,18,19,1,9,8,10,7,11,6,12,5,13,4,14,3,15,2,16}local j={2,3,7}local k={144,112,24,8}local l={8,9,7,8}local m={[0]=5,261,133,389,69,325,197,453,37,293,165,421,101,357,229,485,21,277,149,405,85,341,213,469,53,309,181,437,117,373,245,501}local n=5;local o=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_\"local p={}for q=1,#o do p[string.char(q-1)]=o:sub(q,q)end;local function r(s,t)s.bits=b(s.bits,t)s.count=s.count-t end;local function u(s,t)local v,w,x,y=s.buffer,s.bits,s.count,s.position;while x<t do if y>#v then return nil end;w=w+c(e(v,y),x)y=y+1;x=x+8 end;s.bits=w;s.position=y;s.count=x;return d(w,c(1,t)-1)end;local function z(s,t)local A=u(s,t)s.bits=b(s.bits,t)s.count=s.count-t;return A end;local function B(s,t)local v,w,x,y=s.buffer,s.bits,s.count,s.position;while x<t do if y>#v then return nil end;w=c(w,8)+e(v,y)y=y+1;x=x+8 end;s.bits=w;s.position=y;s.count=x;return d(b(w,x-t),c(1,t)-1)end;local function C(s,t)local A=B(s,t)s.count=s.count-t;return A end;local function D(s,E,t)local F=E[u(s,t)]if not F then return nil end;local G=d(F,15)local A=b(F,4)s.bits=b(s.bits,G)s.count=s.count-G;return A end;local function H(I)local J=#I;local K,L,E={[0]=0},{},{}local w,M=1,0;for q=1,J do local N=I[q]if N>w then w=N end;K[N]=(K[N]or 0)+1 end;for q=1,w do M=(M+(K[q-1]or 0))*2;L[q]=M end;for q=1,J do local N=I[q]if N>0 then local F=(q-1)*16+N;local O=0;for P=1,N do O=O+c(d(1,b(L[N],P-1)),N-P)end;for P=0,2^w-1,2^N do E[P+O]=F end;L[N]=L[N]+1 end end;return E,w end;local function Q(R,s,S,T,U,V)local W=#R+1;local X;repeat X=D(s,S,T)if not X then return nil end;if X<256 then R[W]=X;W=W+1 elseif X>256 then local w,J,Y=0,3,1;if X<265 then J=J+X-257 elseif X<285 then w=b(X-261,2)J=J+c(d(X-261,3)+4,w)else J=258 end;if w>0 then J=J+z(s,w)end;local F=D(s,U,V)if F<4 then Y=Y+F else w=b(F-2,1)Y=Y+c(d(F,1)+2,w)+z(s,w)end;local y=W-Y;repeat R[W]=R[y]or 0;W=W+1;y=y+1;J=J-1 until J==0 end until X==256 end;local function Z(R,s)local _=z(s,5)if not _ then return nil end;local X,Y,G=257+_,1+z(s,5),4+z(s,4)local I={}for q=1,G do I[i[q]]=z(s,3)end;for q=G+1,19 do I[i[q]]=0 end;local a0,a1=H(I)local q=1;local a2=X+Y+1;repeat local F=D(s,a0,a1)if F<16 then I[q]=F;q=q+1 elseif F<19 then local t=j[F-15]local x=0;local a3=3+z(s,t)if F==16 then x=I[q-1]elseif F==18 then a3=a3+8 end;for a4=1,a3 do I[q]=x;q=q+1 end end until q==a2;local a5,a6={},{}for P=1,X do a5[P]=I[P]end;for P=X+1,#I do a6[#a6+1]=I[P]end;local S,T=H(a5)local U,V=H(a6)Q(R,s,S,T,U,V)end;local function a7(R,s)local I={}for q=1,4 do local N=l[q]for a4=1,k[q]do I[#I+1]=N end end;local S,T=H(I)Q(R,s,S,T,m,n)end;local function a8(R,s)r(s,d(s.count,7))local G=z(s,16)z(s,16)if not G then return nil end;local v,y=s.buffer,s.position;for q=y,y+G-1 do R[#R+1]=e(v,q,q)end;s.position=y+G end;local function a9(s)local a3=0;repeat local _=C(s,8)a3=a3*128+_%128 until _<128;return a3 end;local function aa(s)local type=C(s,2)if type>=2 then local ab=C(s,1)local ac=0;repeat local _=C(s,4)ac=c(ac,3)+d(_,7)until _<8;if ab==1 then ac=-ac end;local ad=a9(s)/0x20000000000000+0.5;return math.ldexp(ad,ac)*(type==2 and 1 or-1)else return a9(s)*(type==0 and 1 or-1)end end;local ae={2,6,22}local function af(s,ag)local w=C(s,2)if w==0 then return 1,C(s,ag)end;local ah=C(s,w*2)+ae[w]return ah,C(s,ag)end;local function ai(s,aj)local ak=C(s,4)if ak==0 then if C(s,1)==0 then return nil else return a9(s)end end;local al={}local _,am=0;for q=1,#aj do if _==0 then _,am=af(s,ak)end;if am>0 then al[#al+1]={s=aj[q],l=am}end;_=_-1 end;assert(_==0,_)table.sort(al,function(an,ao)if an.l==ao.l then return an.s<ao.s else return an.l<ao.l end end)al[1].c=0;for P=2,#al do al[P].c=bit32.lshift(al[P-1].c+1,al[P].l-al[P-1].l)end;local ap={}for P=1,#al do local am=al[P].c;local aq=ap;for ar=al[P].l-1,1,-1 do local _=bit32.extract(am,ar,1)if not aq[_+1]then aq[_+1]={}end;aq=aq[_+1]end;local _=bit32.extract(am,0,1)aq[_+1]=al[P].s end;return ap end;local function as(at)if at:sub(1,5)~=\"\\27LuzQ\"then error(\"invalid format\",2)end;local self={buffer=at,position=6,bits=0,count=0}local au,av;do local R,v={},{}local aw,ax;repeat aw,ax=z(self,1),z(self,2)if not aw or not ax then break end;ax=ax==0 and a8(R,self)or ax==1 and a7(R,self)or ax==2 and Z(R,self)until aw==1;local J=#R;for q=1,J,4096 do v[#v+1]=f(unpack(R,q,h(q+4095,J)))end;au=g(v)if self.count%8>0 then r(self,self.count%8)end end;do local R,v={},{}local aw,ax;repeat aw,ax=z(self,1),z(self,2)if not aw or not ax then break end;ax=ax==0 and a8(R,self)or ax==1 and a7(R,self)or ax==2 and Z(R,self)until aw==1;local J=#R;for q=1,J,4096 do v[#v+1]=f(unpack(R,q,h(q+4095,J)))end;av=g(v)if self.count%8>0 then r(self,self.count%8)end end;local ay={}for az in av:gmatch\"([%z\\1-\\62]+)\\63\"do ay[#ay+1]=az:gsub(\".\",p)end;local aA=ai(self,{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29})local ap=ai(self,{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29})local aB;if C(self,1)==1 then local aC,ad={},{}local function aD(aq)if type(aq)==\"string\"then aC[#aC+1],ad[aq]=aq,true else aD(aq[1])aD(aq[2])end end;aD(a)for q=0,29 do if not ad[\":repeat\"..q]then aC[#aC+1]=\":repeat\"..q end end;table.sort(aC)aB=ai(self,aC)else aB=a end;local aE,aF=1,1;local aG={}local aH={}while true do local aq=aB;while type(aq)==\"table\"do aq=aq[C(self,1)+1]end;if aq==\":end\"then break elseif aq==\":name\"then aq=ap;while type(aq)==\"table\"do aq=aq[C(self,1)+1]end;local aI,aJ=math.max(math.floor(aq/2)-1,0)if aI>0 then local aK=C(self,aI)aJ=bit32.bor(aK,bit32.lshift(bit32.band(aq,1)+2,aI))else aJ=aq end;if aJ==0 then aG[#aG+1]=ay[aF]table.insert(aH,1,ay[aF])aF=aF+1 else local aL=table.remove(aH,aJ)aG[#aG+1]=aL;table.insert(aH,1,aL)end elseif aq==\":string\"then local ag=a9(self)aG[#aG+1]=(\"%q\"):format(au:sub(aE,aE+ag-1)):gsub(\"\\\\?\\n\",\"\\\\n\"):gsub(\"\\t\",\"\\\\t\"):gsub(\"[%z\\1-\\31\\127-\\255]\",function(_)return(\"\\\\%03d\"):format(_:byte())end)aE=aE+ag elseif aq==\":number\"then aG[#aG+1]=tostring(aa(self))elseif aq:find\"^:repeat\"then local aM=tonumber(aq:match\"^:repeat(%d+)\")local aI=math.max(math.floor(aM/2)-1,0)if aI>0 then local aK=C(self,aI)aM=bit32.bor(aK,bit32.lshift(bit32.band(aM,1)+2,aI))+3 else aM=aM+3 end;aq=aA;while type(aq)==\"table\"do aq=aq[C(self,1)+1]end;local aJ;aI=math.max(math.floor(aq/2)-1,0)if aI>0 then local aK=C(self,aI)aJ=bit32.bor(aK,bit32.lshift(bit32.band(aq,1)+2,aI))+1 else aJ=aq+1 end;for a4=1,aM do aG[#aG+1]=aG[#aG-aJ+1]end else aG[#aG+1]=aq end end;local aN=\"\"local aO,aP=false,false;for a4,aQ in ipairs(aG)do if aO and aQ:match\"^[A-Za-z0-9_]\"or aP and aQ:match\"^%.\"then aN=aN..\" \"end;aN=aN..aQ;aO,aP=aQ:match\"[A-Za-z0-9_]$\",aQ:match\"%.$\"end;return aN end;return as\n",setuser=false,size=7942,modified=1757997041329,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["minify.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997041338,data="local a=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"local function b(c)local d=\"\"while c>=52 do d,c=d..a:sub(c%52+1,c%52+1),math.floor(c/52)end;return a:sub(c%52+1,c%52+1)..d:reverse()end;local function e(f,g,h,i)error(\"Not implemented yet\")return i,h end;local function j(f,g,h,k)h=h or 1;k=k or 0;local l=setmetatable({},{__index=g or{}})local m=1;local i={}while h<=#f do local n=f[h]if m==1 then if n.type==\"keyword\"then i[h]=n;if n.text==\"do\"or n.text==\"then\"then local o,d=j(f,l,h+1,k)for p=h+1,d do i[p]=o[p]end;h=d elseif n.text==\"until\"then return e(f,l,h+1,i)elseif n.text==\"function\"then local q=k;if f[h+1].type==\"name\"then h=h+1;if l[f[h].text]then i[h]={col=n.col,line=n.line,type=\"name\",text=l[f[h].text]}else i[h]=f[h]end end;h=h+1;i[h]=f[h]h=h+1;n=f[h]local r=setmetatable({},{__index=l})while n.type~=\"operator\"or n.text~=\")\"do if n.type==\"name\"then r[n.text]=b(k)k=k+1;i[h]={col=n.col,line=n.line,type=\"name\",text=r[n.text]}else i[h]=n end;h=h+1;n=f[h]end;i[h]=n;local o,d=j(f,r,h+1,k)for p=h+1,d do i[p]=o[p]end;h=d;k=q elseif n.text==\"local\"or n.text==\"for\"then m=3 elseif n.text==\"end\"then return i,h end elseif n.type==\"name\"then if l[n.text]then i[h]={col=n.col,line=n.line,type=\"name\",text=l[n.text]}else i[h]=n end elseif n.type==\"operator\"then i[h]=n;if n.text==\".\"or n.text==\":\"then m=2 end else i[h]=n end elseif m==2 then i[h]=n;if not(n.type==\"operator\"and(n.text==\".\"or n.text==\":\")or n.type==\"name\")then m=1 end elseif m==3 then if n.type==\"keyword\"and n.text==\"function\"then n=i[h+1]l[n.text]=b(k)k=k+1;i[h]={col=n.col,line=n.line,type=\"name\",text=l[n.text]}local q=k;h=h+2;i[h]=f[h]h=h+1;n=f[h]local r=setmetatable({},{__index=l})while n.type~=\"operator\"or n.text~=\")\"do if n.type==\"name\"then r[n.text]=b(k)k=k+1;i[h]={col=n.col,line=n.line,type=\"name\",text=r[n.text]}else i[h]=n end;h=h+1;n=f[h]end;i[h]=n;local o,d=j(f,r,h+1,k)for p=h+1,d do i[p]=o[p]end;h=d;k=q elseif n.type==\"name\"then l[n.text]=b(k)k=k+1;i[h]={col=n.col,line=n.line,type=\"name\",text=l[n.text]}m=4 else error(\"invalid local statement\")end elseif m==4 then if n.type==\"operator\"and n.text==\",\"then m=3;i[h]=n else m=1;h=h-1 end end;h=h+1 end;return i,#f end;return j\n",setuser=false,size=2183,modified=1757997041332,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["init.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997041336,data="local a={compress_codes=require\"compress\",decompress=require\"decompress\",lex=require\"lex\",lz77=require\"lz77\",minify=require\"minify\"}function a.compress(b,c,d)assert(load(b))local e=a.lex(b,1,2)if d then e=a.minify(e)end;return a.compress_codes(e,c)end;return a\n",setuser=false,size=261,modified=1757997041330,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997041338,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},["libsystem.a"]={permissions={root={read=true,write=true,execute=false}},created=1757997041258,data="!<arch>\n//                                              20        `\nserialization.lua/\n\nexpect.lua/     0           0     0     644     3967      `\nlocal a={}local b={[\"nil\"]=true,boolean=true,number=true,string=true,table=true,[\"function\"]=true,userdata=true,thread=true}local function c(d)return type(d)==\"table\"and(getmetatable(d)or{}).__call or type(d)==\"function\"end;local function e(f,g,...)local h=type(g)local i;if h==\"table\"then local j=getmetatable(g)if j then i=j.__name end end;local k=table.pack(...)for l,m in ipairs(k)do if b[m]then if h==m then return g end elseif i==m then return g elseif c(m)and m(g)then return g end end;local n=debug.getinfo(2,\"n\")if n and n.name and n.name~=\"\"then f=f..\" to '\"..n.name..\"'\"end;local o;if#k==1 and c(k[1])then local l,p=k[1](g)error(f..\" (\"..p..\")\",3)else for q,d in ipairs(k)do k[q]=tostring(d)end;if k.n==1 then o=k[1]elseif k.n==2 then o=k[1]..\" or \"..k[2]else o=table.concat(k,\", \",1,k.n-1)..\", or \"..k[k.n]end;error(f..\" (expected \"..o..\", got \"..h..\")\",3)end end;function a.expect(r,g,...)return e(\"bad argument #\"..r,g,...)end;function a.field(s,t,...)local u,v=pcall(string.format,\"%q\",t)if not u then v=tostring(t)end;return e(\"bad field \"..v,s[t],...)end;function a.range(w,x,y)a.expect(1,w,\"number\")a.expect(2,x,\"number\",\"nil\")a.expect(3,y,\"number\",\"nil\")if y and x and y<x then error(\"bad argument #3 (min must be less than or equal to max)\",2)end;if w~=w or w<(x or-math.huge)or w>(y or math.huge)then error((\"number outside of range (expected %s to be within %s and %s)\"):format(w,x or-math.huge,y or math.huge),3)end;return w end;local z={__tostring=function()return\"table\"end,__call=function(self,A)if type(A)~=\"table\"then return false,\"field '' not a table\"end;for B,o in pairs(self.struct)do if type(o)==\"string\"or c(o)then o={o}end;local g=A[B]local h=type(g)local i;if h==\"table\"then local j=getmetatable(g)if j then i=j.__name end end;local u=false;for l,m in ipairs(o)do if b[m]then if h==m then u=true;break end elseif i==m then u=true;break elseif c(m)and m(g)then u=true;break end end;if not u then if#o==1 and c(o[1])then local l,p=o[1](g)if p then p=p:gsub(\"'([^']*)'\",\"'\"..B..\".%1'\")return false,p end end;return false,\"bad field '\"..B..\"'\"end end;return true end}function a.struct(C)a.expect(1,C,\"table\")return setmetatable({struct=C},z)end;local D={__tostring=function()return\"table\"end,__call=function(self,E)if type(E)~=\"table\"then return false,\"field '' not a table\"end;for q,g in ipairs(E)do local h=type(g)local i;if h==\"table\"then local j=getmetatable(g)if j then i=j.__name end end;local u=false;for l,m in ipairs(self.types)do if b[m]then if h==m then u=true;break end elseif i==m then u=true;break elseif c(m)and m(g)then u=true;break end end;if not u then if#self.types==1 and c(self.types[1])then local l,p=self.types[1](g)if p then p=p:gsub(\"'([^*]+)'\",\"'\"..q..\".%1'\")return false,p end end;return false,\"bad entry '\"..q..\"'\"end end;return true end}function a.array(o)a.expect(1,o,\"string\",\"table\")if type(o)==\"string\"or c(o)then o={o}end;return setmetatable({types=o},D)end;local F={__tostring=function()return\"table\"end,__call=function(self,E)if type(E)~=\"table\"then return false,\"field '' not a table\"end;for B,g in pairs(E)do local h=type(g)local i;if h==\"table\"then local j=getmetatable(g)if j then i=j.__name end end;local u=false;for l,m in ipairs(self.types)do if b[m]then if h==m then u=true;break end elseif i==m then u=true;break elseif c(m)and m(g)then u=true;break end end;if not u then if#self.types==1 and c(self.types[1])then local l,p=self.types[1](g)if p then p=p:gsub(\"'([^']*)'\",\"'\"..B..\".%1'\")return false,p end end;return false,\"bad field '\"..B..\"'\"end end;return true end}function a.table(o)a.expect(1,o,\"string\",\"table\")if type(o)==\"string\"then o={o}end;return setmetatable({types=o},F)end;local G={__tostring=function()return\"string\"end,__call=function(self,g)return type(g)==\"string\"and g:match(self.pattern)~=nil,\"pattern does not match\"end}function a.match(H)a.expect(1,H,\"string\")return setmetatable({pattern=H},G)end;return setmetatable(a,{__call=function(l,...)return a.expect(...)end})\n\nfilesystem.lua/ 0           0     0     644     4714      `\nlocal a=require\"util\"local b=require\"expect\"local c={}function c.open(d,e)b(1,d,\"string\")b(2,e,\"string\")return a.syscall.open(d,e)end;function c.list(d)b(1,d,\"string\")return a.syscall.list(d)end;function c.stat(d,f)b(1,d,\"string\")b(2,f,\"nil\",\"boolean\")return a.syscall.stat(d,f)end;function c.remove(d)b(1,d,\"string\")return a.syscall.remove(d)end;function c.rename(g,h)b(1,g,\"string\")b(2,h,\"string\")return a.syscall.rename(g,h)end;function c.mkdir(d)b(1,d,\"string\")return a.syscall.mkdir(d)end;function c.link(d,i)b(1,d,\"string\")b(2,i,\"string\")return a.syscall.link(d,i)end;function c.mkfifo(d)b(1,d,\"string\")return a.syscall.mkfifo(d)end;function c.chmod(d,j,e)b(1,d,\"string\")b(2,j,\"string\",\"nil\")b(3,e,\"number\",\"string\",\"table\")if type(e)==\"string\"and not e:match\"^[%+%-=][rwxs]+$\"and not e:match\"^[r%-][w%-][xs%-]$\"then error(\"bad argument #3 (invalid mode)\",2)elseif type(e)==\"table\"then b.field(e,\"read\",\"boolean\",\"nil\")b.field(e,\"write\",\"boolean\",\"nil\")b.field(e,\"execute\",\"boolean\",\"nil\")end;return a.syscall.chmod(d,j,e)end;function c.chown(d,j)b(1,d,\"string\")b(2,j,\"string\")return a.syscall.chown(d,j)end;function c.chroot(d)b(1,d,\"string\")return a.syscall.chroot(d)end;function c.mount(type,k,l,m)b(1,type,\"string\")b(2,k,\"string\")b(3,l,\"string\")b(4,m,\"table\",\"nil\")return a.syscall.mount(type,k,l,m)end;function c.unmount(d)b(1,d,\"string\")return a.syscall.unmount(d)end;function c.mountlist()return a.syscall.mountlist()end;function c.fsevent(d,n)b(1,d,\"string\")b(2,n,\"boolean\",\"nil\")return a.syscall.fsevent(d,n)end;function c.combine(...)return a.syscall.combine(...)end;function c.absolute(d)b(1,d,\"string\")d=c.combine(d)if d:sub(1,1)==\"/\"then return d end;return c.combine(a.syscall.getcwd(),d)end;function c.copy(g,h,o)b(1,g,\"string\")b(2,h,\"string\")local p=assert(c.stat(g),g..\": No such file or directory\")if p.type==\"directory\"then local q=c.list(g)c.mkdir(h)for r,s in ipairs(q)do c.copy(c.combine(g,s),c.combine(h,s))end else local t,u=c.open(g,\"rb\")if not t then error(u,2)end;local v,u=c.open(h,\"wb\")if not v then t.close()error(u,2)end;repeat local w=t.read(512)if w then v.write(w)end until not w;v.close()t.close()end;if o then c.chmod(h,nil,p.worldPermissions)for x,s in pairs(p.permissions)do c.chmod(h,x,s)end;if p.owner then c.chown(h,p.owner)end;if p.setuser then pcall(c.chmod,h,p.owner,\"+s\")end end end;function c.move(g,h)b(1,g,\"string\")b(2,h,\"string\")local y=assert(c.stat(g,true),\"File not found\")local z=c.stat(h)if z then error(\"File already exists\",2)end;local d=c.dirname(h)repeat z,d=c.stat(d),c.dirname(d)until z;if y.type==\"directory\"then local q=c.list(g)c.mkdir(h)for r,s in ipairs(q)do c.move(c.combine(g,s),c.combine(h,s))end elseif y.mountpoint==z.mountpoint then c.rename(g,h)else local t,u=c.open(g,\"rb\")if not t then error(u,2)end;local A=t.readAll()t.close()local v,u=c.open(h,\"wb\")if not v then error(u,2)end;c.remove(g)if A then v.write(A)end;v.close()end;c.chmod(h,nil,y.worldPermissions)for x,s in pairs(y.permissions)do c.chmod(h,x,s)end;if y.owner then c.chown(h,y.owner)end;if y.setuser then pcall(c.chmod,h,y.owner,\"+s\")end end;function c.basename(d)b(1,d,\"string\")return c.combine(d):match\"[^/]+$\"end;function c.dirname(d)b(1,d,\"string\")local B=c.combine(d):match\"^(.*)/[^/]*$\"if B==\"\"or B==nil then if d:sub(1,1)==\"/\"then return\"/\"else return\".\"end else return B end end;local function C(m,D,E)if E>#D then return{}end;local F=\"^\"..D[E]:gsub(\"[%^%$%(%)%%%.%+%-]\",\"%%%1\"):gsub(\"%*\",\".*\"):gsub(\"%?\",\".\"):gsub(\"%[!\",\"[^\")..\"$\"local G={}for r,H in ipairs(m)do local I,J=pcall(c.list,H)if I then for r,d in ipairs(J)do if d:match(F)then G[#G+1]=c.combine(H,d)end end end end;if E+1>#D then return G end;return C(G,D,E+1)end;function c.find(K)b(1,K,\"string\")local L={}for B in K:gmatch(\"[^/]+\")do L[#L+1]=B end;local M=C({K:sub(1,1)==\"/\"and\"/\"or\".\"},L,1)table.sort(M)return M end;function c.exists(d)b(1,d,\"string\")return c.stat(d)~=nil end;function c.isFile(d)b(1,d,\"string\")local N=c.stat(d)if not N then return false end;return N.type==\"file\"end;function c.isDir(d)b(1,d,\"string\")local N=c.stat(d)if not N then return false end;return N.type==\"directory\"end;function c.isLink(d)b(1,d,\"string\")local N=c.stat(d)if not N then return false end;return N.type==\"link\"end;function c.effectivePermissions(O,j)b(1,O,\"string\",\"table\")j=b(2,j,\"number\",\"nil\")or a.syscall.getpid()if type(O)==\"string\"then O=a.syscall.stat(O)if not O then return nil end end;b.field(O,\"permissions\",\"table\")b.field(O,\"worldPermissions\",\"table\")return O.permissions[j]or O.worldPermissions end;local P={}P.type=\"\"P.size=0;P.created=0;P.modified=0;P.owner=\"\"P.permissions={read=false,write=false,execute=false}P.worldPermissions={read=false,write=false,execute=false}P.special={}return c\nframebuffer.lua/0           0     0     644     18227     `\nlocal a=require\"expect\"local b=require\"util\"local c={}c.empty={text={},graphics={}}function c.window(d,e,f,g,h)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,e,\"number\")a(3,f,\"number\")a(4,g,\"number\")a(5,h,\"number\")local i=b.type(d)local j={}function j.close()end;function j.getSize()return g,h end;function j.getPosition()return e,f end;function j.getParent()return d end;function j.getPaletteColor(k)return d.getPaletteColor(k)end;function j.setPaletteColor(k,l,m,n)return d.setPaletteColor(k,l,m,n)end;j.getPaletteColour=j.getPaletteColor;j.setPaletteColour=j.setPaletteColor;function j.reposition(o,p,q,r,s)a(1,o,\"number\",\"nil\")a(2,p,\"number\",\"nil\")a(3,q,\"number\",\"nil\")a(4,r,\"number\",\"nil\")a(5,s,\"nil\",i)e=o or e;f=p or f;g=q or g;h=r or h;d=s or d end;function j.resize(q,r)a(1,q,\"number\",\"nil\")a(2,r,\"number\",\"nil\")g=q or g;h=r or h end;function j.reparent(s)a(1,s,\"nil\",i)d=s or d end;if i==\"Terminal\"then setmetatable(j,{__name=\"Terminal\"})local t,u,v=1,1,d.getCursorBlink()local w,x=d.getTextColor(),d.getBackgroundColor()function j.write(y)a(1,y,\"string\")if u<1 or u>h or t>g or#y==0 then return end;if t<1 then local z=math.min(1-t,#y)t=t+z;if z==#y then return end;y=y:sub(z)end;local z=math.min(g-t+1,#y)d.setCursorPos(e+t-1,f+u-1)d.setTextColor(w)d.setBackgroundColor(x)d.write(y:sub(1,z))t=t+z end;function j.blit(y,A,B)a(1,y,\"string\")a(2,A,\"string\")a(3,B,\"string\")if#y~=#A or#A~=#B then error(\"Arguments must be the same length\",2)end;if u<1 or u>h or t>g or#y==0 then return end;if t<1 then local z=math.min(1-t,#y)t=t+z;if z==#y then return end;y,A,B=y:sub(z),A:sub(z),B:sub(z)end;local z=math.min(g-t+1,#y)d.setCursorPos(e+t-1,f+u-1)d.blit(y:sub(1,z),A:sub(1,z),B:sub(1,z))w,x=d.getTextColor(),d.getBackgroundColor()t=t+z end;function j.clear()d.setTextColor(w)d.setBackgroundColor(x)for C=1,h do d.setCursorPos(e,f+C-1)d.write((\" \"):rep(g))end end;function j.clearLine()d.setTextColor(w)d.setBackgroundColor(x)d.setCursorPos(e,f+u-1)d.write((\" \"):rep(g))end;function j.getCursorPos()return t,u end;function j.setCursorPos(o,p)a(1,o,\"number\")a(2,p,\"number\")t,u=o,p;d.setCursorPos(e+t-1,f+u-1)end;function j.getCursorBlink()return v end;function j.setCursorBlink(D)a(1,D,\"boolean\")v=D;d.setCursorBlink(D)end;function j.isColor()return d.isColor()end;function j.scroll(E)a(1,E,\"number\")if math.abs(E)>=g then return j.clear()elseif E>0 then for F=E+1,h do d.setCursorPos(e,f+F-E-1)d.blit(j.getLine(F))end;for F=h-E+1,h do d.setCursorPos(e,f+F-1)d.setTextColor(w)d.setBackgroundColor(x)d.write((' '):rep(g))end elseif E<0 then for F=1,h+E do d.setCursorPos(e,f+F-E-1)d.blit(j.getLine(F))end;for F=1,-E do d.setCursorPos(e,f+F-1)d.setTextColor(w)d.setBackgroundColor(x)d.write((' '):rep(g))end else return end end;function j.getTextColor()return w end;function j.setTextColor(k)a(1,k,\"number\")w=k;d.setTextColor(k)end;function j.getBackgroundColor()return x end;function j.setBackgroundColor(k)a(1,k,\"number\")x=k;d.setBackgroundColor(k)end;function j.getLine(p)a(1,p,\"number\")local G,H,I=d.getLine(f+p-1)if not G then return nil end;return G:sub(e,e+g-1),H:sub(e,e+g-1),I:sub(e,e+g-1)end;function j.restoreCursor()d.setCursorPos(e+t-1,f+u-1)d.setCursorBlink(v)d.setTextColor(w)end;j.isColour=j.isColor;j.getTextColour=j.getTextColor;j.setTextColour=j.setTextColor;j.getBackgroundColour=j.getBackgroundColor;j.setBackgroundColour=j.setBackgroundColor else setmetatable(j,{__name=\"GFXTerminal\"})function j.clear()d.drawPixels(e,f,15,g,h)end;function j.getPixel(o,p)return d.getPixel(e+o,f+p)end;function j.setPixel(o,p,k)return d.setPixel(e+o,f+p,k)end;function j.getPixels(o,p,J,K,L)return d.getPixels(e+o,f+p,J,K,L)end;function j.drawPixels(o,p,M,J,K)return d.drawPixels(e+o,f+p,M,J,K)end;function j.getFrozen()return d.getFrozen()end;function j.setFrozen(N)return d.setFrozen(N)end end;return j end;function c.framebuffer(d,O,P,q,r,Q,R)local S;if d==c.empty.text or d==c.empty.graphics then O=a(2,O,\"number\",\"nil\")or 1;P=a(3,P,\"number\",\"nil\")or 1;S=d==c.empty.graphics;d=nil else a(1,d,\"Terminal\",\"GFXTerminal\")a(2,O,\"number\")a(3,P,\"number\")S=b.type(d)==\"GFXTerminal\"end;a(4,q,\"number\")a(5,r,\"number\")a(6,Q,\"boolean\",\"nil\")a(6,R,\"boolean\",\"nil\")if Q==nil then Q=true end;local T={width=q,height=r}if S then local U={palette={},dirtyRects={},dirtyPalette={},frozen=false}for f=1,T.height*9 do U[f]=('\\15'):rep(T.width*6)end;if d then for F=0,15 do U.palette[F]={d.getPaletteColor(F)}U.dirtyPalette[F]=true end else U.palette={[0]={0.94117647058824,0.94117647058824,0.94117647058824},{0.94901960784314,0.69803921568627,0.2},{0.89803921568627,0.49803921568627,0.84705882352941},{0.6,0.69803921568627,0.94901960784314},{0.87058823529412,0.87058823529412,0.42352941176471},{0.49803921568627,0.8,0.098039215686275},{0.94901960784314,0.69803921568627,0.8},{0.29803921568627,0.29803921568627,0.29803921568627},{0.6,0.6,0.6},{0.29803921568627,0.6,0.69803921568627},{0.69803921568627,0.4,0.89803921568627},{0.2,0.4,0.8},{0.49803921568627,0.4,0.29803921568627},{0.34117647058824,0.65098039215686,0.30588235294118},{0.8,0.29803921568627,0.29803921568627},{0.066666666666667,0.066666666666667,0.066666666666667}}for F=0,15 do U.dirtyPalette[F]=true end end;for F=16,255 do U.palette[F]={0,0,0}U.dirtyPalette[F]=true end;local j=setmetatable({},{__name=\"GFXTerminal\"})function j.close()end;function j.getSize()return T.width*6,T.height*9 end;function j.clear()for f=1,T.height*9 do U[f]=('\\15'):rep(T.width*6)end;j.redraw(true)end;function j.getPixel(e,f)a(1,e,\"number\")a(2,f,\"number\")a.range(e,0,T.width*6-1)a.range(f,0,T.height*9-1)e,f=math.floor(e),math.floor(f)return U[f+1]:byte(e+1)end;function j.setPixel(e,f,k)a(1,e,\"number\")a(2,f,\"number\")a(3,k,\"number\")a.range(e,0,T.width*6-1)a.range(f,0,T.height*9-1)a.range(k,0,255)e,f=math.floor(e),math.floor(f)U[f+1]=U[f+1]:sub(1,e)..string.char(k)..U[f+1]:sub(e+2)U.dirtyRects[#U.dirtyRects+1]={x=e,y=f,color=k}j.redraw()end;function j.getPixels(e,f,g,h,L)a(1,e,\"number\")a(2,f,\"number\")a(3,g,\"number\")a(4,h,\"number\")a(5,L,\"boolean\",\"nil\")a.range(g,0)a.range(h,0)e,f=math.floor(e),math.floor(f)local V={}for W=1,h do if L then V[W]=U[f+W]:sub(e+1,e+g)else V[W]={U[f+W]:sub(e+1,e+g):byte(1,-1)}end end;return V end;function j.drawPixels(e,f,M,g,h)a(1,e,\"number\")a(2,f,\"number\")a(3,M,\"table\",\"number\")local X=type(M)==\"number\"a(4,g,\"number\",not X and\"nil\"or nil)a(5,h,\"number\",not X and\"nil\"or nil)a.range(e,0,T.width*6-1)a.range(f,0,T.height*9-1)if g then a.range(g,0)end;if h then a.range(h,0)end;if X then a.range(M,0,255)end;if g==0 or h==0 then return end;e,f=math.floor(e),math.floor(f)if g and e+g>=T.width*6 then g=T.width*6-e end;h=h or#M;local Y={x=e,y=f,width=g,height=h}for W=1,h do if f+W>T.height*9 then break end;if X then local Z=string.char(M):rep(g)U[f+W]=U[f+W]:sub(1,e)..Z..U[f+W]:sub(e+g+1)Y[W]=Z elseif M[W]~=nil then if type(M[W])~=\"table\"and type(M[W])~=\"string\"then error(\"bad argument #3 to 'drawPixels' (invalid row \"..W..\")\",2)end;local g=g or#M[W]if e+g>=T.width*6 then g=T.width*6-e end;local Z;if type(M[W])==\"string\"then Z=M[W]if#Z<g then Z=Z..('\\15'):rep(g-#Z)elseif#Z>g then Z=Z:sub(1,g)end else Z=\"\"for _=1,g do Z=Z..string.char(M[W][_]or U[f+W]:byte(e+_))end end;U[f+W]=U[f+W]:sub(1,e)..Z..U[f+W]:sub(e+g+1)Y[W]=Z end end;U.dirtyRects[#U.dirtyRects+1]=Y;j.redraw()end;function j.getFrozen()return U.frozen end;function j.setFrozen(a0)a(1,a0,\"boolean\")U.frozen=a0;j.redraw()end;function j.getPaletteColor(k)a(1,k,\"number\")a.range(k,0,255)return table.unpack(U.palette[k])end;function j.setPaletteColor(k,l,m,n)a(1,k,\"number\")a(2,l,\"number\")if m==nil and n==nil then l,m,n=bit32.band(bit32.rshift(l,16),0xFF)/255,bit32.band(bit32.rshift(l,8),0xFF)/255,bit32.band(l,0xFF)/255 end;a(3,m,\"number\")a(4,n,\"number\")a.range(l,0,1)a.range(m,0,1)a.range(n,0,1)a.range(k,0,255)U.palette[k]={l,m,n}U.dirtyPalette[k]=true;j.redraw()end;function j.getPosition()return O,P end;function j.getParent()return d end;function j.reposition(e,f,q,r,s)a(1,e,\"number\",\"nil\")a(2,f,\"number\",\"nil\")O=e or O;P=f or P;if s then j.reparent(s)end;if q or r then return j.resize(q,r)end end;function j.resize(g,h)a(1,g,\"number\",\"nil\")a(2,h,\"number\",\"nil\")if g>T.width then for f=1,T.height*9 do U[f]=U[f]..('\\15'):rep((g-T.width)*6)end;U.dirtyRects[#U.dirtyRects+1]={x=T.width*6+1,y=1,width=(g-T.width)*6,height=T.height*9}elseif g<T.width then for f=1,T.height*9 do U[f]=U[f]:sub(1,g*6)end end;T.width=g;if h>T.height then for f=T.height*9+1,h*9 do U[f]=('\\15'):rep(g*6)end;U.dirtyRects[#U.dirtyRects+1]={x=1,y=T.height*9+1,width=T.width*6,height=(h-T.height)*9}elseif h<T.height then for f=h*9+1,T.height*9 do U[f]=nil end end;T.height=h end;function j.reparent(s)a(1,s,\"GFXTerminal\",\"nil\")d=s;j.redraw()end;function j.redraw(a1)if not d or not Q then return end;if d.setFrozen then d.setFrozen(true)end;if a1 then d.clear()d.drawPixels(0,0,U)for F=0,255 do d.setPaletteColor(F,U.palette[F][1],U.palette[F][2],U.palette[F][3])end else if U.frozen then if d.setFrozen then d.setFrozen(false)end;return end;for a2,a3 in ipairs(U.dirtyRects)do if a3.color then d.setPixel(a3.x,a3.y,a3.color,a3.width,a3.height)else d.drawPixels(a3.x,a3.y,a3)end end;for F in pairs(U.dirtyPalette)do d.setPaletteColor(F,U.palette[F][1],U.palette[F][2],U.palette[F][3])end end;if d.setFrozen then d.setFrozen(false)end;U.dirtyRects,U.dirtyPalette={},{}end;function j.isVisible()return Q end;function j.setVisible(a3)a(1,a3,\"boolean\")Q=a3;j.redraw()end;j.getPaletteColour=j.getPaletteColor;j.setPaletteColour=j.setPaletteColor;j.redraw()return j else local U={cursor={x=1,y=1},cursorBlink=false,colors={fg='0',bg='f'},palette={},dirtyLines={},dirtyPalette={}}for f=1,T.height do U[f]={(' '):rep(T.width),('0'):rep(T.width),('f'):rep(T.width)}U.dirtyLines[f]=true end;if d then for F=0,15 do U.palette[F]={d.getPaletteColor(F)}U.dirtyPalette[F]=true end else U.palette={[0]={0.94117647058824,0.94117647058824,0.94117647058824},{0.94901960784314,0.69803921568627,0.2},{0.89803921568627,0.49803921568627,0.84705882352941},{0.6,0.69803921568627,0.94901960784314},{0.87058823529412,0.87058823529412,0.42352941176471},{0.49803921568627,0.8,0.098039215686275},{0.94901960784314,0.69803921568627,0.8},{0.29803921568627,0.29803921568627,0.29803921568627},{0.6,0.6,0.6},{0.29803921568627,0.6,0.69803921568627},{0.69803921568627,0.4,0.89803921568627},{0.2,0.4,0.8},{0.49803921568627,0.4,0.29803921568627},{0.34117647058824,0.65098039215686,0.30588235294118},{0.8,0.29803921568627,0.29803921568627},{0.066666666666667,0.066666666666667,0.066666666666667}}for F=0,15 do U.dirtyPalette[F]=true end end;local j=setmetatable({},{__name=\"Terminal\"})function j.close()end;function j.write(y)y=tostring(y)a(1,y,\"string\")if U.cursor.y<1 or U.cursor.y>T.height then return elseif U.cursor.x>T.width or U.cursor.x+#y<1 then U.cursor.x=U.cursor.x+#y;return elseif U.cursor.x<1 then y=y:sub(-U.cursor.x+2)U.cursor.x=1 end;local a4=#y;if U.cursor.x+#y>T.width then y=y:sub(1,T.width-U.cursor.x+1)end;U[U.cursor.y][1]=U[U.cursor.y][1]:sub(1,U.cursor.x-1)..y..U[U.cursor.y][1]:sub(U.cursor.x+#y)U[U.cursor.y][2]=U[U.cursor.y][2]:sub(1,U.cursor.x-1)..U.colors.fg:rep(#y)..U[U.cursor.y][2]:sub(U.cursor.x+#y)U[U.cursor.y][3]=U[U.cursor.y][3]:sub(1,U.cursor.x-1)..U.colors.bg:rep(#y)..U[U.cursor.y][3]:sub(U.cursor.x+#y)U.cursor.x=U.cursor.x+a4;U.dirtyLines[U.cursor.y]=true;j.redraw()end;function j.blit(y,w,x)y=tostring(y)a(1,y,\"string\")a(2,w,\"string\")a(3,x,\"string\")if#y~=#w or#w~=#x then error(\"Arguments must be the same length\",2)end;if U.cursor.y<1 or U.cursor.y>T.height then return elseif U.cursor.x>T.width or U.cursor.x<1-#y then U.cursor.x=U.cursor.x+#y;j.redraw()return elseif U.cursor.x<1 then y,w,x=y:sub(-U.cursor.x+2),w:sub(-U.cursor.x+2),x:sub(-U.cursor.x+2)U.cursor.x=1 end;local a4=#y;if U.cursor.x+#y>T.width then y,w,x=y:sub(1,T.width-U.cursor.x+1),w:sub(1,T.width-U.cursor.x+1),x:sub(1,T.width-U.cursor.x+1)end;U[U.cursor.y][1]=U[U.cursor.y][1]:sub(1,U.cursor.x-1)..y..U[U.cursor.y][1]:sub(U.cursor.x+#y)U[U.cursor.y][2]=U[U.cursor.y][2]:sub(1,U.cursor.x-1)..w..U[U.cursor.y][2]:sub(U.cursor.x+#w)U[U.cursor.y][3]=U[U.cursor.y][3]:sub(1,U.cursor.x-1)..x..U[U.cursor.y][3]:sub(U.cursor.x+#x)U.cursor.x=U.cursor.x+a4;U.dirtyLines[U.cursor.y]=true;j.redraw()end;function j.clear()for f=1,T.height do U[f]={(' '):rep(T.width),U.colors.fg:rep(T.width),U.colors.bg:rep(T.width)}U.dirtyLines[f]=true end;j.redraw()end;function j.clearLine()if U.cursor.y>=1 and U.cursor.y<=T.height then U[U.cursor.y]={(' '):rep(T.width),U.colors.fg:rep(T.width),U.colors.bg:rep(T.width)}U.dirtyLines[U.cursor.y]=true;j.redraw()end end;function j.getCursorPos()return U.cursor.x,U.cursor.y end;function j.setCursorPos(t,u)a(1,t,\"number\")a(2,u,\"number\")if t==U.cursor.x and u==U.cursor.y then return end;U.cursor.x,U.cursor.y=math.floor(t),math.floor(u)j.redraw()end;function j.getCursorBlink()return U.cursorBlink end;function j.setCursorBlink(n)a(1,n,\"boolean\")U.cursorBlink=n;j.redraw()end;function j.isColor()return true end;function j.getSize()return T.width,T.height end;function j.scroll(E)a(1,E,\"number\")if math.abs(E)>=T.width then for f=1,T.height do U[f]={(' '):rep(T.width),U.colors.fg:rep(T.width),U.colors.bg:rep(T.width)}end elseif E>0 then for F=E+1,T.height do U[F-E]=U[F]end;for F=T.height-E+1,T.height do U[F]={(' '):rep(T.width),U.colors.fg:rep(T.width),U.colors.bg:rep(T.width)}end elseif E<0 then for F=1,T.height+E do U[F-E]=U[F]end;for F=1,-E do U[F]={(' '):rep(T.width),U.colors.fg:rep(T.width),U.colors.bg:rep(T.width)}end else return end;for F=1,T.height do U.dirtyLines[F]=true end;j.redraw()end;function j.getTextColor()return tonumber(U.colors.fg,16)end;function j.setTextColor(k)a(1,k,\"number\")a.range(k,0,15)U.colors.fg=(\"%x\"):format(math.floor(k))end;function j.getBackgroundColor()return tonumber(U.colors.bg,16)end;function j.setBackgroundColor(k)a(1,k,\"number\")a.range(k,0,15)U.colors.bg=(\"%x\"):format(math.floor(k))end;function j.getPaletteColor(k)a(1,k,\"number\")a.range(k,0,15)return table.unpack(U.palette[math.floor(k)])end;function j.setPaletteColor(k,l,m,n)a(1,k,\"number\")a(2,l,\"number\")if m==nil and n==nil then l,m,n=bit32.band(bit32.rshift(l,16),0xFF)/255,bit32.band(bit32.rshift(l,8),0xFF)/255,bit32.band(l,0xFF)/255 end;a(3,m,\"number\")a(4,n,\"number\")a.range(k,0,15)if l<0 or l>1 then error(\"bad argument #2 (value out of range)\",2)end;if m<0 or m>1 then error(\"bad argument #3 (value out of range)\",2)end;if n<0 or n>1 then error(\"bad argument #4 (value out of range)\",2)end;U.palette[math.floor(k)]={l,m,n}U.dirtyPalette[math.floor(k)]=true;j.redraw()end;function j.getLine(f)a(1,f,\"number\")local a5=U[f]if a5 then return table.unpack(a5,1,3)end end;function j.getPosition()return O,P end;function j.getParent()return d end;function j.reposition(e,f,q,r,s)a(1,e,\"number\",\"nil\")a(2,f,\"number\",\"nil\")O=e or O;P=f or P;if s then j.reparent(s)end;if e or f then j.redraw(true)end;if q or r then return j.resize(q,r)end end;function j.resize(g,h)a(1,g,\"number\",\"nil\")a(2,h,\"number\",\"nil\")if g>T.width then for f=1,T.height do U[f][1]=U[f][1]..(' '):rep(g-T.width)U[f][2]=U[f][2]..U.colors.fg:rep(g-T.width)U[f][3]=U[f][3]..U.colors.bg:rep(g-T.width)U.dirtyLines[f]=true end elseif g<T.width then for f=1,T.height do U[f][1]=U[f][1]:sub(1,g)U[f][2]=U[f][2]:sub(1,g)U[f][3]=U[f][3]:sub(1,g)end end;T.width=g;if h>T.height then for f=T.height+1,h do U[f]={(' '):rep(g),U.colors.fg:rep(g),U.colors.bg:rep(g)}U.dirtyLines[f]=true end elseif h<T.height then for f=h+1,T.height do U[f]=nil end end;T.height=h end;function j.reparent(s)a(1,s,\"Terminal\",\"nil\")d=s;j.redraw()end;function j.redraw(a1)if not d or not Q then return end;d.setCursorBlink(false)if a1 then for f=1,T.height do d.setCursorPos(O,P+f-1)if R and(U[f][2]:find(\"[! ]\")or U[f][3]:find(\"[! ]\"))then local a6,a7,a8=d.getLine(P+f-1)if a6 then a6,a7,a8=a6:sub(math.max(O,1),math.max(O+T.width-1,1)),a7:sub(math.max(O,1),math.max(O+T.width-1,1)),a8:sub(math.max(O,1),math.max(O+T.width-1,1))if O<1 then local a9=(\" \"):rep(1-O)a6,a7,a8=a9 ..a6,a9 ..a7,a9 ..a8 end;if#a6<#U[f][1]then local a9=(\" \"):rep(#U[f][1]-#a6)a6,a7,a8=a6 ..a9,a7 ..a9,a8 ..a9 end;local y=U[f][1]:gsub(\"()\\0\",function(aa)return a6:sub(aa,aa)end)local w=U[f][2]:gsub(\"() \",function(aa)return a7:sub(aa,aa)end):gsub(\"()!\",function(aa)return a8:sub(aa,aa)end)local x=U[f][3]:gsub(\"() \",function(aa)return a8:sub(aa,aa)end):gsub(\"()!\",function(aa)return a7:sub(aa,aa)end)d.blit(y,w,x)end else d.blit(U[f][1],U[f][2],U[f][3])end end;for F=0,15 do d.setPaletteColor(F,U.palette[F][1],U.palette[F][2],U.palette[F][3])end else for f in pairs(U.dirtyLines)do d.setCursorPos(O,P+f-1)if#U[f][1]~=#U[f][2]or#U[f][2]~=#U[f][3]then error(debug.traceback(\"Internal error: Invalid lengths\"),2)end;if R and(U[f][2]:find(\"[! ]\")or U[f][3]:find(\"[! ]\"))then local a6,a7,a8=d.getLine(P+f-1)if a6 then a6,a7,a8=a6:sub(math.max(O,1),math.max(O+T.width-1,1)),a7:sub(math.max(O,1),math.max(O+T.width-1,1)),a8:sub(math.max(O,1),math.max(O+T.width-1,1))if O<1 then local a9=(\" \"):rep(1-O)a6,a7,a8=a9 ..a6,a9 ..a7,a9 ..a8 end;if#a6<#U[f][1]then local a9=(\" \"):rep(#U[f][1]-#a6)a6,a7,a8=a6 ..a9,a7 ..a9,a8 ..a9 end;local y=U[f][1]:gsub(\"()\\0\",function(aa)return a6:sub(aa,aa)or\"\\0\"end)local w=U[f][2]:gsub(\"() \",function(aa)return a7:sub(aa,aa)end):gsub(\"()!\",function(aa)return a8:sub(aa,aa)end)local x=U[f][3]:gsub(\"() \",function(aa)return a8:sub(aa,aa)end):gsub(\"()!\",function(aa)return a7:sub(aa,aa)end)d.blit(y,w,x)end else d.blit(U[f][1],U[f][2],U[f][3])end end;for F in pairs(U.dirtyPalette)do d.setPaletteColor(F,U.palette[F][1],U.palette[F][2],U.palette[F][3])end end;d.setCursorPos(O+U.cursor.x-1,P+U.cursor.y-1)d.setCursorBlink(U.cursorBlink)d.setTextColor(j.getTextColor())U.dirtyLines,U.dirtyPalette={},{}end;function j.restoreCursor()if not d or not Q then return end;d.setCursorPos(O+U.cursor.x-1,P+U.cursor.y-1)d.setCursorBlink(U.cursorBlink)d.setTextColor(j.getTextColor())end;function j.isVisible()return Q end;function j.setVisible(a3,l)a(1,a3,\"boolean\")Q=a3;if a3 and l~=false then j.redraw()end end;j.isColour=j.isColor;j.getTextColour=j.getTextColor;j.setTextColour=j.setTextColor;j.getBackgroundColour=j.getBackgroundColor;j.setBackgroundColour=j.setBackgroundColor;j.getPaletteColour=j.getPaletteColor;j.setPaletteColour=j.setPaletteColor;j.redraw()return j end end;return c\n\ngraphics.lua/   0           0     0     644     6669      `\nlocal a=require\"expect\"local b=require\"util\"local c={}function c.drawPixel(d,e,f,g)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,e,\"number\")a(3,f,\"number\")a(4,g,\"number\")if b.type(d)==\"Terminal\"then local h,i=d.getCursorPos()local j=d.getBackgroundColor()d.setCursorPos(e,f)d.setBackgroundColor(g)d.write(\" \")d.setCursorPos(h,i)d.setBackgroundColor(j)else d.setPixel(e-1,f-1,g)end end;local function k(l,m,n,o,p)if math.abs(p-n)<math.abs(o-m)then if m>o then m,n,o,p=o,p,m,n end;local q,r,s=o-m,p-n,1;if r<0 then s,r=-1,-r end;local t,f=2*r-q,n;if s<0 then f=p;for e=o,m,-1 do l(e,f)if t>0 then f=f+1;t=t+2*(r-q)else t=t+2*r end end else for e=m,o do l(e,f)if t>0 then f=f+1;t=t+2*(r-q)else t=t+2*r end end end else if n>p then m,n,o,p=o,p,m,n end;local q,r,u=o-m,p-n,1;if q<0 then u,q=-1,-q end;local t,e=2*q-r,m;for f=n,p do l(e,f)if t>0 then e=e+u;t=t+2*(q-r)else t=t+2*q end end end end;function c.drawLine(d,m,n,o,p,g)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,m,\"number\")a(3,n,\"number\")a(4,o,\"number\")a(5,p,\"number\")a(6,g,\"number\")if n==p then local v=math.abs(o-m)+1;if b.type(d)==\"Terminal\"then local w,x=d.getBackgroundColor(),d.getTextColor()local h,i=d.getCursorPos()local y,z=(\"%x\"):format(x),(\"%x\"):format(g)d.setCursorPos(m,n)d.blit((\" \"):rep(v),y:rep(v),z:rep(v))d.setCursorPos(h,i)d.setBackgroundColor(w)else d.drawPixels(m-1,n-1,g,v,1)end;return elseif m==o and b.type(d)==\"GFXTerminal\"then d.drawPixels(m-1,n-1,g,1,math.abs(p-n)+1)end;local l,A;if b.type(d)==\"Terminal\"then local j=d.getBackgroundColor()local h,i=d.getCursorPos()d.setBackgroundColor(g)l,A=function(e,f)d.setCursorPos(e,f)d.write(\" \")end,function()d.setBackgroundColor(j)d.setCursorPos(h,i)end else l,A=function(e,f)d.setPixel(e-1,f-1,g)end,function()end end;k(l,m,n,o,p)A()end;function c.drawBox(d,e,f,v,B,g)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,e,\"number\")a(3,f,\"number\")a(4,v,\"number\")a(5,B,\"number\")a(6,g,\"number\")if b.type(d)==\"Terminal\"then local w,x=d.getBackgroundColor(),d.getTextColor()local h,i=d.getCursorPos()local y,z=(\"%x\"):format(x),(\"%x\"):format(g)d.setCursorPos(e,f)d.blit((\" \"):rep(v),y:rep(v),z:rep(v))d.setCursorPos(e,f+B-1)d.blit((\" \"):rep(v),y:rep(v),z:rep(v))for C=f+1,f+B-2 do d.setCursorPos(e,C)d.blit(\" \",y,z)d.setCursorPos(e+v-1,C)d.blit(\" \",y,z)end;d.setBackgroundColor(w)d.setCursorPos(h,i)else d.drawPixels(e-1,f-1,g,v,1)d.drawPixels(e-1,f-1,g,1,B)d.drawPixels(e-1,f+B-1,g,v,1)d.drawPixels(e+v-1,f-1,g,1,B)end end;function c.drawFilledBox(d,e,f,v,B,g)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,e,\"number\")a(3,f,\"number\")a(4,v,\"number\")a(5,B,\"number\")a(6,g,\"number\")if b.type(d)==\"Terminal\"then a.range(g,0,15)local w,x=d.getBackgroundColor(),d.getTextColor()local h,i=d.getCursorPos()local D,y,z=(\" \"):rep(v),(\"%x\"):format(x):rep(v),(\"%x\"):format(g):rep(v)for C=f,f+B-1 do d.setCursorPos(e,C)d.blit(D,y,z)end;d.setBackgroundColor(w)d.setCursorPos(h,i)else a.range(g,0,255)d.drawPixels(e-1,f-1,g,v,B)end end;function c.drawCircle(d,e,f,v,B,g,E,F)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,e,\"number\")a(3,f,\"number\")a(4,v,\"number\")a(5,B,\"number\")a(6,g,\"number\")E=(a(7,E,\"number\",\"nil\")or 0)%(2*math.pi)F=(a(8,F,\"number\",\"nil\")or 0)%(2*math.pi)if F==0 then F=2*math.pi end;local l,A;if b.type(d)==\"Terminal\"then local j=d.getBackgroundColor()local h,i=d.getCursorPos()d.setBackgroundColor(g)l,A=function(G,C)d.setCursorPos(G,C)d.write(\" \")end,function()d.setBackgroundColor(j)d.setCursorPos(h,i)end else l,A=function(G,C)d.setPixel(G-1,C-1,g)end,function()end end;local H=math.pi/(v+B)v,B=v/2,B/2;for I=E,E+F,H do local G,C=v*math.cos(I)+v,B*math.sin(I)+B;l(e+G,f+C)end;A()end;function c.drawFilledTriangle(d,m,n,o,p,J,K,g)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,m,\"number\")a(3,n,\"number\")a(4,o,\"number\")a(5,p,\"number\")a(6,J,\"number\")a(7,K,\"number\")a(8,g,\"number\")local L,A;if b.type(d)==\"Terminal\"then local w,x=d.getBackgroundColor(),d.getTextColor()local h,i=d.getCursorPos()local z,y=(\"%x\"):format(g),(\"%x\"):format(x)L,A=function(G,C,M)d.setCursorPos(G,C)d.blit((\" \"):rep(M),y:rep(M),z:rep(M))end,function()d.setBackgroundColor(w)d.setTextColor(x)d.setCursorPos(h,i)end else L,A=function(G,C,M)d.drawPixels(G-1,C-1,g,M,1)end,function()end end;local N={{x=m,y=n},{x=o,y=p},{x=J,y=K}}table.sort(N,function(O,w)return O.y<w.y end)if N[1].y==N[2].y then if N[2].y==N[3].y then local q=math.min(N[1].x,N[2].x,N[3].x)L(q,N[1].y,math.max(N[1].x,N[2].x,N[3].x)-q)A()return end;if N[1].x>N[2].x then N[1],N[2]=N[2],N[1]end;local P,Q=coroutine.create(k),coroutine.create(k)local R,S,T=coroutine.resume(P,coroutine.yield,N[1].x,N[1].y,N[3].x,N[3].y)local R,U,V=coroutine.resume(Q,coroutine.yield,N[2].x,N[2].y,N[3].x,N[3].y)local W,X=S,U;while V do repeat W=math.min(W,S)R,S,T=coroutine.resume(P)until T~=V;repeat X=math.max(X,U)R,U,T=coroutine.resume(Q)until T~=V;L(W,V,X-W+1)W,X,V=S,U,T end elseif N[2].y==N[3].y then if N[2].x>N[3].x then N[2],N[3]=N[3],N[2]end;local P,Q=coroutine.create(k),coroutine.create(k)local R,S,T=coroutine.resume(P,coroutine.yield,N[1].x,N[1].y,N[2].x,N[2].y)local R,U,V=coroutine.resume(Q,coroutine.yield,N[1].x,N[1].y,N[3].x,N[3].y)local W,X=S,U;while V do repeat W=math.min(W,S)R,S,T=coroutine.resume(P)until T~=V;repeat X=math.max(X,U)R,U,T=coroutine.resume(Q)until T~=V;L(W,V,X-W+1)W,X,V=S,U,T end else local P,Q=coroutine.create(k),coroutine.create(k)local R,S,T=coroutine.resume(P,coroutine.yield,N[1].x,N[1].y,N[3].x,N[3].y)local R,U,V=coroutine.resume(Q,coroutine.yield,N[1].x,N[1].y,N[2].x,N[2].y)local W,X=S,U;while S and U and V do repeat W=math.min(W,S)X=math.max(X,S)R,S,T=coroutine.resume(P)until T~=V;if V==N[2].y then Q=coroutine.create(k)R,U,T=coroutine.resume(Q,coroutine.yield,N[2].x,N[2].y,N[3].x,N[3].y)end;repeat W=math.min(W,U)X=math.max(X,U)R,U,T=coroutine.resume(Q)until T~=V;L(W,V,X-W+1)W,X,V=math.min(S or 0,U or 0),math.max(S or 0,U or 0),T end end;A()end;function c.drawImage(d,e,f,Y)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,e,\"number\")a(3,f,\"number\")a(4,Y,\"table\")if b.type(d)==\"Terminal\"then local w,x=d.getBackgroundColor(),d.getTextColor()local h,i=d.getCursorPos()local y=(\"%x\"):format(x)for C=1,#Y do a.field(Y,C,\"string\",\"table\")d.setCursorPos(e,f+C-1)local L=Y[C]if type(L)==\"string\"then local z=L:gsub(\"[\\16-\\255]\",\" \"):gsub(\"[%z-\\15]\",function(j)return(\"%x\"):format(j:byte())end)d.blit((\" \"):rep(#z),y:rep(#z),z)elseif#L==3 and type(L[1]==\"string\")then d.blit(L[1],L[2],L[3])else local z=\"\"for Z=1,#L do a(L,Z,\"number\")z=z..(\"%x\"):format(L[Z])end;d.blit((\" \"):rep(#z),y:rep(#z),z)end end;d.setBackgroundColor(w)d.setTextColor(x)d.setCursorPos(h,i)else if type(Y[1])==\"table\"and type(Y[1][1])==\"string\"then error(\"bad argument #4 to 'drawImage' (image type not supported on this terminal)\",2)end;return d.drawPixels(e-1,f-1,Y)end end;return c\n\nhardware.lua/   0           0     0     644     3104      `\nlocal a=require\"expect\"local b=require\"util\"local c={}function c.wrap(d)a(1,d,\"string\",\"device\",\"devicetree\")if type(d)~=\"string\"then d=getmetatable(d).uuid end;local e=b.syscall.devinfo(d)if not e then return nil end;local f,g=b.syscall.devmethods(d),b.syscall.devproperties(d)for h,i in ipairs(g)do g[i]=true end;local j={}for h,i in ipairs(f)do j[i]=function(self,...)return b.syscall.devcall(d,i,...)end end;return setmetatable(j,{__name=\"device\",uuid=e.uuid,__index=function(self,k)if type(k)==\"string\"and g[k]then return b.syscall.devcall(d,\"get\"..k:gsub(\"^.\",string.upper))end end,__newindex=function(self,k,l)if type(k)==\"string\"and g[k]and self[\"set\"..k:gsub(\"^.\",string.upper)]then return b.syscall.devcall(d,\"set\"..k:gsub(\"^.\",string.upper),l)end end,__tostring=function(self)return\"wrapped device: \"..(e.displayName or e.uuid)end})end;function c.find(type)a(1,type,\"string\")local j={}for m,i in ipairs{b.syscall.devfind(type)}do j[m]=c.wrap(i)end;return table.unpack(j)end;function c.path(d)a(1,d,\"string\",\"device\",\"devicetree\")if type(d)==\"string\"then return b.syscall.devlookup(d)else return b.syscall.devlookup(getmetatable(d).uuid)end end;function c.hasType(d,n)a(1,d,\"string\",\"device\",\"devicetree\")a(2,n,\"string\")local e;if type(d)==\"string\"then e=b.syscall.devinfo(d)else e=b.syscall.devinfo(getmetatable(d).uuid)end;if not e then error(\"No such device\",2)end;return e.types[n]~=nil end;function c.info(d)a(1,d,\"string\",\"device\",\"devicetree\")if type(d)==\"string\"then return b.syscall.devinfo(d)else return b.syscall.devinfo(getmetatable(d).uuid)end end;function c.methods(d)a(1,d,\"string\",\"device\",\"devicetree\")if type(d)==\"string\"then return b.syscall.devmethods(d)else return b.syscall.devmethods(getmetatable(d).uuid)end end;function c.properties(d)a(1,d,\"string\",\"device\",\"devicetree\")if type(d)==\"string\"then return b.syscall.devproperties(d)else return b.syscall.devproperties(getmetatable(d).uuid)end end;function c.children(d)a(1,d,\"string\",\"device\",\"devicetree\")if type(d)==\"string\"then return b.syscall.devchildren(d)else return b.syscall.devchildren(getmetatable(d).uuid)end end;function c.call(d,o,...)a(1,d,\"string\",\"device\",\"devicetree\")a(2,o,\"string\")if type(d)==\"string\"then return b.syscall.devcall(d,o,...)else return b.syscall.devcall(getmetatable(d).uuid,o,...)end end;function c.listen(d,p)a(1,d,\"string\",\"device\",\"devicetree\")a(2,p,\"boolean\",\"nil\")if type(d)==\"string\"then return b.syscall.devlisten(d,p)else return b.syscall.devlisten(getmetatable(d).uuid,p)end end;function c.lock(d,q)a(1,d,\"string\",\"device\",\"devicetree\")a(2,q,\"boolean\",\"nil\")if type(d)==\"string\"then return b.syscall.devlock(d,q)else return b.syscall.devlock(getmetatable(d).uuid,q)end end;function c.unlock(d)a(1,d,\"string\",\"device\",\"devicetree\")if type(d)==\"string\"then return b.syscall.devunlock(d)else return b.syscall.devunlock(getmetatable(d).uuid)end end;local function r(s)local e=c.info(s or\"/\")if not e then return nil end;s=s or\"\"return setmetatable({},{__name=\"devicetree\",uuid=e.uuid,__index=function(self,k)return r(s..\"/\"..k)end,__newindex=function()end})end;c.tree=r()return c\ninit.lua/       0           0     0     644     341       `\nreturn{expect=require\"expect\",filesystem=require\"filesystem\",framebuffer=require\"framebuffer\",graphics=require\"graphics\",hardware=require\"hardware\",keys=require\"keys\",log=require\"log\",network=require\"network\",pretty=require\"pretty\",process=require\"process\",serialization=require\"serialization\",terminal=require\"terminal\",util=require\"util\"}\n\nipc.lua/        0           0     0     644     1133      `\nlocal a=require\"expect\"local b=require\"util\"local c={}c.signal={SIGHUP=1,SIGINT=2,SIGQUIT=3,SIGTRAP=5,SIGABRT=6,SIGKILL=9,SIGPIPE=13,SIGTERM=15,SIGCONT=18,SIGSTOP=19,SIGTTIN=21,SIGTTOU=22}function c.kill(d,e)a(1,d,\"number\")a(2,e,\"number\")return b.syscall.kill(d,e)end;function c.sigaction(e,f)a(1,e,\"number\")a(2,f,\"function\",\"nil\")return b.syscall.signal(e,f)end;function c.sendEvent(d,g,h)a(1,d,\"number\")a(2,g,\"string\")a(3,h,\"table\")return b.syscall.sendEvent(d,g,h)end;function c.register(i)a(1,i,\"string\")return b.syscall.register(i)end;function c.lookup(i)a(1,i,\"string\")return b.syscall.lookup(i)end;function c.sendServiceEvent(i,g,h)a(1,i,\"string\")a(2,g,\"string\")a(3,h,\"table\")local d=b.syscall.lookup(i)if not d then return false end;return b.syscall.sendEvent(d,g,h)end;function c.receiveEvent(d,g,j)a(1,d,\"number\",\"nil\")a(2,g,\"string\",\"nil\")a(3,j,\"number\",\"nil\")local k;if j then k=b.timer(j)end;while true do local l,h=coroutine.yield()if l==\"timer\"and h.id==k then return nil elseif l==\"remote_event\"and(d==nil or d==h.sender)and(g==nil or g==h.type)then if k then b.cancel(k)end;return h.type,h.data end end end;return c\n\nkeys.lua/       0           0     0     644     1542      `\nlocal a={}for b=0x61,0x7A do a[string.char(b)]=b end;for b=0x81,0x99 do a[\"f\"..bit32.band(b,31)]=b end;for b=0xA0,0xA9 do a[\"numPad\"..bit32.band(b,15)]=b end;a.backspace=0x08;a.tab=0x09;a.enter=0x0A;a.space=0x20;a.apostrophe=0x27;a.comma=0x2C;a.minus=0x2D;a.period=0x2E;a.slash=0x2F;a.zero=0x30;a.one=0x31;a.two=0x32;a.three=0x33;a.four=0x34;a.five=0x35;a.six=0x36;a.seven=0x37;a.eight=0x38;a.nine=0x39;a.semicolon=0x3B;a.equals=0x3D;a.leftBracket=0x5B;a.backslash=0x5C;a.rightBracket=0x5D;a.grave=0x60;a.delete=0x7F;a.insert=0x80;a.convert=0x9A;a.noconvert=0x9B;a.kana=0x9C;a.kanji=0x9D;a.yen=0x9E;a.numPadDecimal=0x9F;a.numPadAdd=0xAA;a.numPadSubtract=0xAB;a.numPadMultiply=0xAC;a.numPadDivide=0xAD;a.numPadEqual=0xAE;a.numPadEnter=0xAF;a.leftCtrl=0xB0;a.rightCtrl=0xB1;a.leftAlt=0xB2;a.rightAlt=0xB3;a.leftShift=0xB4;a.rightShift=0xB5;a.leftSuper=0xB6;a.rightSuper=0xB7;a.capsLock=0xB8;a.numLock=0xB9;a.scrollLock=0xBA;a.printScreen=0xBB;a.pause=0xBC;a.menu=0xBD;a.stop=0xBE;a.ax=0xBF;a.up=0xC0;a.down=0xC1;a.left=0xC2;a.right=0xC3;a.pageUp=0xC4;a.pageDown=0xC5;a.home=0xC6;a[\"end\"]=0xC7;a.circumflex=0xC8;a.at=0xC9;a.colon=0xCA;a.underscore=0xCB;local c={}for d,e in pairs(a)do c[e]=d end;function a.getName(f)if type(f)~=\"number\"then error(\"bad argument #1 (expected number, got \"..type(f)..\")\",2)end;return c[f]end;function a.getCharacter(f)if type(f)~=\"number\"then error(\"bad argument #1 (expected number, got \"..type(f)..\")\",2)end;if f>=0x20 and f<0x7F or f==0x0A or f==0x09 then return string.char(f)else return nil end end;return a\nlog.lua/        0           0     0     644     2163      `\nlocal a=require\"expect\"local b=require\"util\"local function c(self,...)return self.log(...)end;local d={debug=0,info=1,notice=2,warning=3,error=4,critical=5}local function e(f)local g={}function g.log(h,...)if type(h)==\"table\"then h.name=f;return b.syscall.syslog(h,...)else return b.syscall.syslog({name=f},h,...)end end;function g.debug(h,...)if type(h)==\"table\"then h.name=f;h.level=d.debug;return b.syscall.syslog(h,...)else return b.syscall.syslog({name=f,level=d.debug},h,...)end end;function g.info(h,...)if type(h)==\"table\"then h.name=f;h.level=d.info;return b.syscall.syslog(h,...)else return b.syscall.syslog({name=f,level=d.info},h,...)end end;function g.notice(h,...)if type(h)==\"table\"then h.name=f;h.level=d.notice;return b.syscall.syslog(h,...)else return b.syscall.syslog({name=f,level=d.notice},h,...)end end;function g.warning(h,...)if type(h)==\"table\"then h.name=f;h.level=d.warning;return b.syscall.syslog(h,...)else return b.syscall.syslog({name=f,level=d.warning},h,...)end end;g.warn=g.warning;function g.error(h,...)if type(h)==\"table\"then h.name=f;h.level=d.error;return b.syscall.syslog(h,...)else return b.syscall.syslog({name=f,level=d.error},h,...)end end;function g.critical(h,...)if type(h)==\"table\"then h.name=f;h.level=d.critical;return b.syscall.syslog(h,...)else return b.syscall.syslog({name=f,level=d.critical},h,...)end end;function g.traceback(i)a(1,i,\"string\",\"nil\")return b.syscall.syslog({name=f,level=d.error,traceback=true},debug.traceback(i,2))end;return setmetatable(g,{__call=c})end;local g=e()g.levels={debug=0,info=1,notice=2,warning=3,error=4,critical=5}function g.create(f,j,k)a(1,f,\"string\")a(2,j,\"boolean\",\"nil\")a(3,k,\"string\",\"nil\")b.syscall.mklog(f,j,k)return e(f)end;function g.remove(f)a(1,f,\"string\")return b.syscall.rmlog(f)end;function g.open(f,l)a(1,f,\"string\")a(2,l,\"string\",\"nil\")return b.syscall.openlog(f,l)end;function g.close(f)a(1,f,\"string\",\"number\")return b.syscall.closelog(f)end;function g.setTTY(f,m,n)a(1,f,\"string\")a(2,m,\"table\",\"nil\")a(3,n,\"number\",\"nil\")return b.syscall.logtty(f,m,n)end;return setmetatable(g,{__call=c,__index=function(o,p)if type(p)==\"string\"then return e(p)end end})\n\nnetwork.lua/    0           0     0     644     6370      `\nlocal a=require\"util\"local b=require\"expect\"local c={route={},arp={}}function c.parseURI(d)local e={scheme=\"\"}for f in d:gmatch\".\"do if e.fragment then if f:match\"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/?]\"then e.fragment=e.fragment..f else error(\"Invalid URI\",3)end elseif e.query then if f==\"#\"then e.fragment=\"\"elseif f:match\"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/?]\"then e.query=e.query..f else error(\"Invalid URI\",3)end elseif e.path then if f==\"/\"and e.path==\"/\"and not e.host then e.path,e.host=nil,\"\"elseif f==\"?\"then e.query=\"\"elseif f==\"#\"then e.fragment=\"\"elseif f:match\"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/]\"then e.path=e.path..f else error(\"Invalid URI\",3)end elseif e.port then if tonumber(f)then e.port=e.port..f elseif f==\"/\"then e.path=\"/\"else error(\"Invalid URI\",3)end elseif e.host then if f==\"@\"and not e.user then e.user,e.host=e.host,\"\"elseif f==\":\"then e.port=\"\"elseif f==\"/\"then e.path=\"/\"elseif f:match\"[%w%-%._~%%/!%$&'%(%)%*%+,;=]\"then e.host=e.host..f else error(\"Invalid URI\",3)end else if f==\":\"then e.path=\"\"elseif f:match(e.scheme==\"\"and\"[%a%+%-%.]\"or\"[%w%+%-%.]\")then e.scheme=e.scheme..f else error(\"Invalid URI\",3)end end end;if e.port then e.port=tonumber(e.port)end;return e end;function c.connect(g)b(1,g,\"table\",\"string\")if type(g)==\"table\"then b.field(g,\"url\",\"string\")end;return a.syscall.connect(g)end;function c.get(g)b(1,g,\"table\",\"string\")if type(g)==\"table\"then b.field(g,\"url\",\"string\")if not g.url:match(\"^https?://\")then error(\"Invalid scheme\",2)end elseif not g:match(\"^https?://\")then error(\"Invalid scheme\",2)end;local h=a.syscall.connect(g)h:write()while true do local i,j=coroutine.yield()if i==\"handle_status_change\"and j.id==h.id then if j.status==\"open\"then return h elseif j.status==\"error\"then return nil,select(2,h:status())end end end end;function c.getData(k,l)b(1,k,\"string\")b(2,l,\"table\",\"nil\")if not k:match(\"^https?://\")then error(\"Invalid scheme\",2)end;local h=a.syscall.connect{url=k,encoding=\"binary\",headers=l}h:write()while true do local i,j=coroutine.yield()if i==\"handle_status_change\"and j.id==h.id then if j.status==\"open\"then local m=h:read(\"*a\")local n=h:responseCode()h:close()return m,n elseif j.status==\"error\"then return nil,select(2,h:status())end end end end;function c.head(g)b(1,g,\"table\",\"string\")if type(g)==\"table\"then b.field(g,\"url\",\"string\")if not g.url:match(\"^https?://\")then error(\"Invalid scheme\",2)end else if not g:match(\"^https?://\")then error(\"Invalid scheme\",2)end;g={url=g}end;g.method=\"HEAD\"local h=a.syscall.connect(g)h:write()while true do local i,j=coroutine.yield()if i==\"handle_status_change\"and j.id==h.id then if j.status==\"open\"then return h elseif j.status==\"error\"then return nil,select(2,h:status())end end end end;function c.options(g)b(1,g,\"table\",\"string\")if type(g)==\"table\"then b.field(g,\"url\",\"string\")if not g.url:match(\"^https?://\")then error(\"Invalid scheme\",2)end else if not g:match(\"^https?://\")then error(\"Invalid scheme\",2)end;g={url=g}end;g.method=\"OPTIONS\"local h=a.syscall.connect(g)h:write()while true do local i,j=coroutine.yield()if i==\"handle_status_change\"and j.id==h.id then if j.status==\"open\"then return h elseif j.status==\"error\"then return nil,select(2,h:status())end end end end;function c.post(g,m)b(1,g,\"table\",\"string\")b(2,m,\"string\")if type(g)==\"table\"then b.field(g,\"url\",\"string\")if not g.url:match(\"^https?://\")then error(\"Invalid scheme\",2)end else if not g:match(\"^https?://\")then error(\"Invalid scheme\",2)end;g={url=g}end;g.method=\"POST\"local h=a.syscall.connect(g)h:write(m)while true do local i,j=coroutine.yield()if i==\"handle_status_change\"and j.id==h.id then if j.status==\"open\"then return h elseif j.status==\"error\"then return nil,select(2,h:status())end end end end;function c.put(g,m)b(1,g,\"table\",\"string\")b(2,m,\"string\")if type(g)==\"table\"then b.field(g,\"url\",\"string\")if not g.url:match(\"^https?://\")then error(\"Invalid scheme\",2)end else if not g:match(\"^https?://\")then error(\"Invalid scheme\",2)end;g={url=g}end;g.method=\"PUT\"local h=a.syscall.connect(g)h:write(m)while true do local i,j=coroutine.yield()if i==\"handle_status_change\"and j.id==h.id then if j.status==\"open\"then return h elseif j.status==\"error\"then return nil,select(2,h:status())end end end end;function c.delete(g,m)b(1,g,\"table\",\"string\")b(2,m,\"string\",\"nil\")if type(g)==\"table\"then b.field(g,\"url\",\"string\")if not g.url:match(\"^https?://\")then error(\"Invalid scheme\",2)end else if not g:match(\"^https?://\")then error(\"Invalid scheme\",2)end;g={url=g}end;g.method=\"DELETE\"local h=a.syscall.connect(g)h:write(m)while true do local i,j=coroutine.yield()if i==\"handle_status_change\"and j.id==h.id then if j.status==\"open\"then return h elseif j.status==\"error\"then return nil,select(2,h:status())end end end end;function c.listen(d)b(1,d,\"string\")return a.syscall.listen(d)end;function c.unlisten(d)b(1,d,\"string\")return a.syscall.unlisten(d)end;function c.ipconfig(o,e)b(1,o,\"string\",\"table\")b(2,e,\"table\",\"nil\")if e then b.field(e,\"ip\",\"string\",\"number\",\"nil\")b.field(e,\"netmask\",\"string\",\"number\",\"nil\")b.field(e,\"up\",\"boolean\",\"nil\")end;return a.syscall.ipconfig(o,e)end;function c.route.list(p)b(1,p,\"number\",\"nil\")return a.syscall.routelist(p)end;function c.route.add(g)b(1,g,\"table\")b.field(g,\"table\",\"number\",\"nil\")b.field(g,\"source\",\"string\")b.field(g,\"sourceNetmask\",\"number\")b.field(g,\"action\",\"string\")b.field(g,\"device\",\"string\",not(g.action==\"local\"or g.action==\"unicast\"or g.action==\"broadcast\")and\"nil\"or nil)b.field(g,\"destination\",\"string\",g.action~=\"unicast\"and\"nil\"or nil)return a.syscall.routeadd(g)end;function c.route.remove(q,r,p)b(1,q,\"string\")b(2,r,\"number\")b(3,p,\"number\",\"nil\")return a.syscall.routedel(q,r,p)end;function c.arp.list(o)b(1,o,\"string\")return a.syscall.arplist(o)end;function c.arp.set(o,s,t)b(1,o,\"string\")b(2,s,\"string\")b(3,t,\"number\",\"nil\")return a.syscall.arpset(o,s,t)end;function c.control(s,type,u)b(1,s,\"string\")b(2,type,\"string\")b(3,u,\"string\",\"nil\")return a.syscall.netcontrol(s,type,u)end;function c.events(v)b(1,v,\"boolean\",\"nil\")return a.syscall.netevent(v)end;function c.checkURI(d)b(1,d,\"string\")return a.syscall.checkuri(d)end;function c.urlEncode(w)b(1,w,\"string\")return w:gsub(\"\\n\",\"\\r\\n\"):gsub(\"([^A-Za-z0-9 %-%_%.])\",function(f)local x=f:byte()if x<128 then return(\"%%%02X\"):format(x)else return(\"%%%02X%%%02X\"):format(bit32.rshift(x,6)+0xC0,bit32.band(x,0x3F)+0x80)end end):gsub(\" \",\"+\")end;return c\npretty.lua/     0           0     0     644     6055      `\nlocal a=require\"terminal\"local b=require\"expect\"local c=b.field;local type,getmetatable,setmetatable,d,tostring=type,getmetatable,setmetatable,a.colours,tostring;local e,f=debug.getinfo,debug.getlocal;local function g(h,i)local j=h.n+1;h[j],h.n=i,j end;local k={__name=\"document\"}local function l(m)return setmetatable(m,k)end;local n=l({tag=\"nil\"})local o=l({tag=\"text\",text=\" \"})local p=l({tag=\"line\",flat=n})local q=l({tag=\"line\",flat=o})local r={[\"\"]=n,[\" \"]=o,[\"\\n\"]=q}local function s(t,u)return r[t]or setmetatable({tag=\"text\",text=t,colour=u},k)end;local function t(t,u)b(1,t,\"string\")b(2,u,\"number\",\"nil\")local v=r[t]if v then return v end;local w=t:find(\"\\n\",1)if not w then return s(t,u)end;local x=setmetatable({tag=\"concat\",n=0},k)if w~=1 then g(x,s(t:sub(1,w-1),u))end;w=w+1;while true do local y=t:find(\"\\n\",w)g(x,q)if not y then if w<=#t then g(x,s(t:sub(w),u))end;return x else if w<=y-1 then g(x,s(t:sub(w,y-1),u))end;w=y+1 end end end;local function z(...)local A=table.pack(...)for B=1,A.n do if type(A[B])==\"string\"then A[B]=t(A[B])end;b(B,A[B],\"document\")end;if A.n==0 then return n end;if A.n==1 then return A[1]end;A.tag=\"concat\"return setmetatable(A,k)end;k.__concat=z;local function C(D,x)b(1,D,\"number\")b(2,x,\"document\")if D<=0 then error(\"depth must be a positive number\",2)end;return setmetatable({tag=\"nest\",depth=D,x},k)end;local function E(x)if x.flat then return x.flat end;local F=x.tag;if F==\"nil\"or F==\"text\"then return x elseif F==\"concat\"then local h=setmetatable({tag=\"concat\",n=x.n},k)for B=1,x.n do h[B]=E(x[B])end;x.flat,h.flat=h,h;return h elseif F==\"nest\"then return E(x[1])elseif F==\"group\"then return x[1]else error(\"Unknown doc \"..F)end end;local function G(x)b(1,x,\"document\")if x.tag==\"group\"then return x end;local H=E(x)if H==x then return x end;return setmetatable({tag=\"group\",H,x},k)end;local function I(x,J)local F=x.tag;if F==\"nil\"or F==\"line\"then return J elseif F==\"text\"then return J-#x.text elseif F==\"concat\"then for B=1,x.n do J=I(x[B],J)if J<0 then break end end;return J elseif F==\"group\"or F==\"nest\"then return I(F[1])else error(\"Unknown doc \"..F)end end;local function K(x,L)b(1,x,\"document\")b(2,L,\"number\",\"nil\")local J,M=a.termsize()local N=(L or 0.6)*J;if N<0 then N=0 end;if N>J then N=J end;local O=d.white;local P=O;local function Q(x,R,S)local F=x.tag;if F==\"nil\"then return S elseif F==\"text\"then local T=x.colour or O;if T~=P then io.write(a.toEscape(T))P=T end;io.write(x.text)return S+#x.text elseif F==\"line\"then io.write(\"\\n\\x1b[\"..R..\"C\")return R elseif F==\"concat\"then for B=1,x.n do S=Q(x[B],R,S)end;return S elseif F==\"nest\"then return Q(x[1],R+x.depth,S)elseif F==\"group\"then if I(x[1],math.min(J,N+R)-S)>=0 then return Q(x[1],R,S)else return Q(x[2],R,S)end else error(\"Unknown doc \"..F)end end;Q(x,0,0)if P~=O then io.write(\"\\x1b[0m\")end end;local function U(x,L)b(1,x,\"document\")b(2,L,\"number\",\"nil\")K(x,L)_G.print()end;local function V(x,J,L)b(1,x,\"document\")b(2,J,\"number\",\"nil\")b(3,L,\"number\",\"nil\")local N;if J then N=(L or 0.6)*J;if N<0 then N=0 end;if N>J then N=J end end;local h={n=0}local function Q(x,R,S)local F=x.tag;if F==\"nil\"then return S elseif F==\"text\"then g(h,x.text)return S+#x.text elseif F==\"line\"then g(h,\"\\n\"..(\" \"):rep(R))return R elseif F==\"concat\"then for B=1,x.n do S=Q(x[B],R,S)end;return S elseif F==\"nest\"then return Q(x[1],R+x.depth,S)elseif F==\"group\"then if not J or I(x[1],math.min(J,N+R)-S)>=0 then return Q(x[1],R,S)else return Q(x[2],R,S)end else error(\"Unknown doc \"..F)end end;Q(x,0,0)return table.concat(h,\"\",1,h.n)end;k.__tostring=V;local W={[\"and\"]=true,[\"break\"]=true,[\"do\"]=true,[\"else\"]=true,[\"elseif\"]=true,[\"end\"]=true,[\"false\"]=true,[\"for\"]=true,[\"function\"]=true,[\"if\"]=true,[\"in\"]=true,[\"local\"]=true,[\"nil\"]=true,[\"not\"]=true,[\"or\"]=true,[\"repeat\"]=true,[\"return\"]=true,[\"then\"]=true,[\"true\"]=true,[\"until\"]=true,[\"while\"]=true}local X=t(\",\")local Y=t(\"{}\")local Z,_=t(\"{\"),t(\"}\")local a0,a1=t(\"[\"),t(\"] = \")local function a2(a3,a4)local a5,a6=type(a3),type(a4)if a5==\"string\"then return a6~=\"string\"or a3<a4 elseif a6==\"string\"then return false end;if a5==\"number\"then return a6~=\"number\"or a3<a4 end;return false end;local function a7(a8,a9)local aa=e and e(a8,\"Su\")local ab;if a9.function_source and aa and aa.short_src and aa.linedefined and aa.linedefined>=1 then ab=\"function<\"..aa.short_src..\":\"..aa.linedefined..\">\"else ab=tostring(a8)end;if a9.function_args and aa and aa.what==\"Lua\"and aa.nparams and f then local A={}for B=1,aa.nparams do A[B]=f(a8,B)or\"?\"end;if aa.isvararg then A[#A+1]=\"...\"end;ab=ab..\"(\"..table.concat(A,\", \")..\")\"end;return ab end;local function ac(ad,a9,ae)local af=type(ad)if af==\"string\"then local ag=(\"%q\"):format(ad):gsub(\"\\\\\\n\",\"\\\\n\")return t(ag,d.red)elseif af==\"number\"then return t(tostring(ad),d.magenta)elseif af==\"function\"then return t(a7(ad,a9),d.lightGrey)elseif af~=\"table\"or ae[ad]then return t(tostring(ad),d.lightGrey)elseif getmetatable(ad)~=nil and getmetatable(ad).__tostring then return t(tostring(ad))elseif next(ad)==nil then return Y else ae[ad]=true;local x=setmetatable({tag=\"concat\",n=1,q},k)local ah,ai,aj=#ad,{},1;for ak in pairs(ad)do if type(ak)~=\"number\"or ak%1~=0 or ak<1 or ak>ah then ai[aj],aj=ak,aj+1 end end;table.sort(ai,a2)for B=1,ah do if B>1 then g(x,X)g(x,q)end;g(x,ac(ad[B],a9,ae))end;for B=1,aj-1 do if B>1 or ah>=1 then g(x,X)g(x,q)end;local ak=ai[B]local al=ad[ak]if type(ak)==\"string\"and not W[ak]and ak:match(\"^[%a_][%a%d_]*$\")then g(x,t(ak..\" = \"))g(x,ac(al,a9,ae))else g(x,a0)g(x,ac(ak,a9,ae))g(x,a1)g(x,ac(al,a9,ae))end end;ae[ad]=nil;return G(z(Z,C(2,z(table.unpack(x,1,x.n))),q,_))end end;local function am(ad,a9)b(2,a9,\"table\",\"nil\")a9=a9 or{}local an={function_source=c(a9,\"function_source\",\"boolean\",\"nil\")or false,function_args=c(a9,\"function_args\",\"boolean\",\"nil\")or false}return ac(ad,an,{})end;local function ao(ad,a9,L)b(2,a9,\"table\",\"nil\")a9=a9 or{}b(3,L,\"number\",\"nil\")return U(am(ad,a9),L)end;return{empty=n,space=o,line=p,space_line=q,text=t,concat=z,nest=C,group=G,write=K,print=U,render=V,pretty=am,pretty_print=ao}\n\nprocess.lua/    0           0     0     644     4173      `\nlocal a=require\"expect\"local b=require\"util\"local c={}function c.getpid()return b.syscall.getpid()end;function c.getppid()return b.syscall.getppid()end;function c.getuser()return b.syscall.getuser()end;function c.setuser(d)a(1,d,\"string\")return b.syscall.setuser(d)end;function c.clock()return b.syscall.clock()end;function c.getenv()return b.syscall.getenv()end;function c.getfenv()return b.syscall.getfenv()end;function c.getname()return b.syscall.getname()end;function c.getcwd()return b.syscall.getcwd()end;function c.chdir(e)a(1,e,\"string\")return b.syscall.chdir(e)end;function c.fork(f,g,...)a(1,f,\"function\")a(2,g,\"string\",\"nil\")return b.syscall.fork(f,g,...)end;function c.forkbg(f,g,...)a(1,f,\"function\")a(2,g,\"string\",\"nil\")return b.syscall.fork(function(...)b.syscall.stdin()b.syscall.stdout()b.syscall.stderr()setfenv(f,_ENV)return f(...)end,g,...)end;function c.exec(h,...)a(1,h,\"string\")return b.syscall.exec(h,...)end;function c.execp(i,...)a(1,i,\"string\")local h=b.syscall.getenv().PATH;if i:find\"/\"or type(h)~=\"string\"then return b.syscall.exec(i,...)end;for e in h:gmatch\"[^:]+\"do local j=b.syscall.combine(e,i)local k=b.syscall.stat(j)if not k then j=b.syscall.combine(e,i..\".lua\")k=b.syscall.stat(j)end;if k and k.type~=\"directory\"then return b.syscall.exec(j,...)end end;error(i..\": No such file\",2)end;function c.start(h,...)a(1,h,\"string\")return b.syscall.fork(function(...)return coroutine.yield(\"syscall\",\"exec\",...)end,h,h,...)end;function c.startbg(h,...)a(1,h,\"string\")return b.syscall.fork(function(...)b.syscall.stdin()b.syscall.stdout()b.syscall.stderr()return coroutine.yield(\"syscall\",\"exec\",...)end,h,h,...)end;function c.run(i,...)a(1,i,\"string\")local l=b.syscall.getenv().PATH;local h;if i:find\"/\"or type(l)~=\"string\"then h=i else for e in l:gmatch\"[^:]+\"do local j=b.syscall.combine(e,i)local k=b.syscall.stat(j)if not k then j=b.syscall.combine(e,i..\".lua\")k=b.syscall.stat(j)end;if k and k.type~=\"directory\"then h=j;break end end;error(i..\": No such file\",2)end;local m=b.syscall.fork(function(...)return coroutine.yield(\"syscall\",\"exec\",...)end,h,h,...)local n,o;repeat n,o=coroutine.yield()until n==\"process_complete\"and o.id==m;return o.error==nil,o.error or o.value end;function c.newthread(f,...)a(1,f,\"function\")return b.syscall.newthread(f,...)end;function c.exit(p)return b.syscall.exit(p)end;function c.atexit(q)a(1,q,\"function\")return b.syscall.atexit(q)end;function c.getplist()return b.syscall.getplist()end;function c.getpinfo(m)a(1,m,\"number\")return b.syscall.getpinfo(m)end;function c.nice(r,m)a(1,r,\"number\")a.range(r,-20,20)a(2,m,\"number\",\"nil\")return b.syscall.nice(r,m)end;c.debug={}function c.debug.enable(m,s)a(1,m,\"number\",\"nil\")a(2,s,\"boolean\")return b.syscall.debug_enable(m,s)end;function c.debug.brk(m,t)a(1,m,\"number\",\"nil\")a(2,t,\"number\",\"nil\")return b.syscall.debug_break(m,t)end;function c.debug.continue(m,t)a(1,m,\"number\")a(2,t,\"number\",\"nil\")return b.syscall.debug_continue(m,t)end;function c.debug.setbreakpoint(m,t,type,u)a(1,m,\"number\")a(2,t,\"number\",\"nil\")a(3,type,\"string\",\"number\")a(4,u,\"table\",\"nil\")return b.syscall.debug_setbreakpoint(m,t,type,u)end;function c.debug.unsetbreakpoint(m,v)a(1,m,\"number\")a(2,v,\"number\")return b.syscall.debug_unsetbreakpoint(m,v)end;function c.debug.listbreakpoints(m)a(1,m,\"number\")return b.syscall.debug_listbreakpoints(m)end;function c.debug.getinfo(m,t,r,w)a(1,m,\"number\")a(2,t,\"number\")a(3,r,\"number\")a(4,w,\"string\",\"nil\")return b.syscall.debug_getinfo(m,t,r,w)end;function c.debug.getlocal(m,t,r,x)a(1,m,\"number\")a(2,t,\"number\")a(3,r,\"number\")a(4,x,\"number\")return b.syscall.debug_getlocal(m,t,r,x)end;function c.debug.getupvalue(m,t,r,x)a(1,m,\"number\")a(2,t,\"number\")a(3,r,\"number\")a(4,x,\"number\")return b.syscall.debug_getupvalue(m,t,r,x)end;function c.debug.exec(m,t,q)a(1,m,\"number\")a(2,t,\"number\")a(3,q,\"function\")b.syscall.debug_exec(m,t,q)while true do local n,o=coroutine.yield()if n==\"debug_exec_result\"and o.process==m and o.thread==t then if o.ok then return table.unpack(o,1,o.n)else error(o.error,0)end end end end;function c.debug.execAsync(m,t,q)a(1,m,\"number\")a(2,t,\"number\")a(3,q,\"function\")return b.syscall.debug_exec(m,t,q)end;return c\n\n/0              0           0     0     644     17469     `\nlocal a=require\"expect\"local b={base64={},json={},lua={},toml={}}local c=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"function b.base64.encode(d)a(1,d,\"string\")local e=\"\"for f in d:gmatch\"...\"do local g=f:byte(1)*65536+f:byte(2)*256+f:byte(3)local h,i,j,k=bit32.extract(g,18,6),bit32.extract(g,12,6),bit32.extract(g,6,6),bit32.extract(g,0,6)e=e..c:sub(h+1,h+1)..c:sub(i+1,i+1)..c:sub(j+1,j+1)..c:sub(k+1,k+1)end;if#d%3==1 then local g=d:byte(-1)local h,i=bit32.rshift(g,2),bit32.lshift(bit32.band(g,3),4)e=e..c:sub(h+1,h+1)..c:sub(i+1,i+1)..\"==\"elseif#d%3==2 then local g=d:byte(-2)*256+d:byte(-1)local h,i,j=bit32.extract(g,10,6),bit32.extract(g,4,6),bit32.lshift(bit32.extract(g,0,4),2)e=e..c:sub(h+1,h+1)..c:sub(i+1,i+1)..c:sub(j+1,j+1)..\"=\"end;return e end;function b.base64.decode(d)a(1,d,\"string\")local e=\"\"for f in d:gmatch\"....\"do if f:sub(3,4)=='=='then e=e..string.char(bit32.bor(bit32.lshift(c:find(f:sub(1,1))-1,2),bit32.rshift(c:find(f:sub(2,2))-1,4)))elseif f:sub(4,4)=='='then local g=(c:find(f:sub(1,1))-1)*4096+(c:find(f:sub(2,2))-1)*64+c:find(f:sub(3,3))-1;e=e..string.char(bit32.extract(g,10,8))..string.char(bit32.extract(g,2,8))else local g=(c:find(f:sub(1,1))-1)*262144+(c:find(f:sub(2,2))-1)*4096+(c:find(f:sub(3,3))-1)*64+c:find(f:sub(4,4))-1;e=e..string.char(bit32.extract(g,16,8))..string.char(bit32.extract(g,8,8))..string.char(bit32.extract(g,0,8))end end;return e end;local function l(d)return setmetatable({},{__newindex=function()error(\"attempt to modify read-only table\")end,__tostring=function()return d end})end;b.json.null=l\"null\"b.json.emptyArray=l\"[]\"local m;local n={[\"\\\\\"]=\"\\\\\",[\"\\\"\"]=\"\\\"\",[\"\\b\"]=\"b\",[\"\\f\"]=\"f\",[\"\\n\"]=\"n\",[\"\\r\"]=\"r\",[\"\\t\"]=\"t\"}local o={[\"/\"]=\"/\"}for p,q in pairs(n)do o[q]=p end;local function r(j)return\"\\\\\"..(n[j]or string.format(\"u%04x\",j:byte()))end;local function s(t)return\"null\"end;local function u(t,v)local w={}v=v or{}if t==b.json.null then return\"null\"elseif t==b.json.emptyArray then return\"[]\"end;if v[t]then error(\"circular reference\")end;v[t]=true;if rawget(t,1)~=nil or next(t)==nil then local g=0;for p in pairs(t)do if type(p)~=\"number\"then error(\"invalid table: mixed or invalid key types\")end;g=g+1 end;if g~=#t then error(\"invalid table: sparse array\")end;for x,q in ipairs(t)do table.insert(w,m(q,v))end;v[t]=nil;return\"[\"..table.concat(w,\",\")..\"]\"else for p,q in pairs(t)do if type(p)~=\"string\"then error(\"invalid table: mixed or invalid key types\")end;table.insert(w,m(p,v)..\":\"..m(q,v))end;v[t]=nil;return\"{\"..table.concat(w,\",\")..\"}\"end end;local function y(t)return'\"'..t:gsub('[%z\\1-\\31\\\\\"]',r)..'\"'end;local function z(t)if t~=t or t<=-math.huge or t>=math.huge then error(\"unexpected number value '\"..tostring(t)..\"'\")end;return string.format(\"%.14g\",t)end;local A={[\"nil\"]=s,[\"table\"]=u,[\"string\"]=y,[\"number\"]=z,[\"boolean\"]=tostring}m=function(t,v)local B=type(t)local C=A[B]if C then return C(t,v)end;error(\"unexpected type '\"..B..\"'\")end;function b.json.encode(t)return m(t)end;local D;local function E(...)local w={}for x=1,select(\"#\",...)do w[select(x,...)]=true end;return w end;local F=E(\" \",\"\\t\",\"\\r\",\"\\n\")local G=E(\" \",\"\\t\",\"\\r\",\"\\n\",\"]\",\"}\",\",\")local H=E(\"\\\\\",\"/\",'\"',\"b\",\"f\",\"n\",\"r\",\"t\",\"u\")local I=E(\"true\",\"false\",\"null\")local J={[\"true\"]=true,[\"false\"]=false,[\"null\"]=nil}local function K(d,L,M,N)for x=L,#d do if M[d:sub(x,x)]~=N then return x end end;return#d+1 end;local function O(d,L,P)local Q=1;local R=1;for x=1,L-1 do R=R+1;if d:sub(x,x)==\"\\n\"then Q=Q+1;R=1 end end;error(string.format(\"%s at line %d col %d\",P,Q,R))end;local function S(g)local C=math.floor;if g<=0x7f then return string.char(g)elseif g<=0x7ff then return string.char(C(g/64)+192,g%64+128)elseif g<=0xffff then return string.char(C(g/4096)+224,C(g%4096/64)+128,g%64+128)elseif g<=0x10ffff then return string.char(C(g/262144)+240,C(g%262144/4096)+128,C(g%4096/64)+128,g%64+128)end;error(string.format(\"invalid unicode codepoint '%x'\",g))end;local function T(f)local U=tonumber(f:sub(1,4),16)local V=tonumber(f:sub(7,10),16)if V then return S((U-0xd800)*0x400+V-0xdc00+0x10000)else return S(U)end end;local function W(d,x)local w=\"\"local X=x+1;local p=X;while X<=#d do local Y=d:byte(X)if Y<32 then O(d,X,\"control character in string\")elseif Y==92 then w=w..d:sub(p,X-1)X=X+1;local j=d:sub(X,X)if j==\"u\"then local Z=d:match(\"^[dD][89aAbB]%x%x\\\\u%x%x%x%x\",X+1)or d:match(\"^%x%x%x%x\",X+1)or O(d,X-1,\"invalid unicode escape in string\")w=w..T(Z)X=X+#Z else if not H[j]then O(d,X-1,\"invalid escape char '\"..j..\"' in string\")end;w=w..o[j]end;p=X+1 elseif Y==34 then w=w..d:sub(p,X-1)return w,X+1 end;X=X+1 end;O(d,x,\"expected closing quote for string\")end;local function _(d,x)local Y=K(d,x,G)local f=d:sub(x,Y-1)local g=tonumber(f)if not g then O(d,x,\"invalid number '\"..f..\"'\")end;return g,Y end;local function a0(d,x)local Y=K(d,x,G)local a1=d:sub(x,Y-1)if not I[a1]then O(d,x,\"invalid literal '\"..a1 ..\"'\")end;return J[a1],Y end;local function a2(d,x)local w={}local g=1;x=x+1;while 1 do local Y;x=K(d,x,F,true)if d:sub(x,x)==\"]\"then x=x+1;break end;Y,x=D(d,x)w[g]=Y;g=g+1;x=K(d,x,F,true)local a3=d:sub(x,x)x=x+1;if a3==\"]\"then break end;if a3~=\",\"then O(d,x,\"expected ']' or ','\")end end;return w,x end;local function a4(d,x)local w={}x=x+1;while 1 do local a5,t;x=K(d,x,F,true)if d:sub(x,x)==\"}\"then x=x+1;break end;if d:sub(x,x)~='\"'then O(d,x,\"expected string for key\")end;a5,x=D(d,x)x=K(d,x,F,true)if d:sub(x,x)~=\":\"then O(d,x,\"expected ':' after key\")end;x=K(d,x+1,F,true)t,x=D(d,x)w[a5]=t;x=K(d,x,F,true)local a3=d:sub(x,x)x=x+1;if a3==\"}\"then break end;if a3~=\",\"then O(d,x,\"expected '}' or ','\")end end;return w,x end;local a6={['\"']=W,[\"0\"]=_,[\"1\"]=_,[\"2\"]=_,[\"3\"]=_,[\"4\"]=_,[\"5\"]=_,[\"6\"]=_,[\"7\"]=_,[\"8\"]=_,[\"9\"]=_,[\"-\"]=_,[\"t\"]=a0,[\"f\"]=a0,[\"n\"]=a0,[\"[\"]=a2,[\"{\"]=a4}D=function(d,L)local a3=d:sub(L,L)local C=a6[a3]if C then return C(d,L)end;O(d,L,\"unexpected character '\"..a3 ..\"'\")end;function b.json.decode(d)a(1,d,\"string\")local w,L=D(d,K(d,1,F,true))L=K(d,L,F,true)if L<=#d then O(d,L,\"trailing garbage\")end;return w end;function b.json.save(t,a7)a(2,a7,\"string\")local a8=assert(io.open(a7,\"w\"))a8:write(b.json.encode(t))a8:close()end;function b.json.load(a7)a(1,a7,\"string\")local a8=assert(io.open(a7,\"r\"))local a9=a8:read(\"*a\")a8:close()return b.json.decode(a9)end;local aa={[\"and\"]=true,[\"break\"]=true,[\"do\"]=true,[\"else\"]=true,[\"elseif\"]=true,[\"end\"]=true,[\"false\"]=true,[\"for\"]=true,[\"function\"]=true,[\"goto\"]=true,[\"if\"]=true,[\"in\"]=true,[\"local\"]=true,[\"nil\"]=true,[\"not\"]=true,[\"or\"]=true,[\"repeat\"]=true,[\"return\"]=true,[\"then\"]=true,[\"true\"]=true,[\"until\"]=true,[\"while\"]=true}local function ab(t,v,ac,ad)if v[t]then error(\"Cannot serialize recursive value\",0)end;local ae=type(t)if ae==\"table\"then if not next(t)then return\"{}\"end;v[t]=true;local w=ac.minified and\"{\"or\"{\\n\"local af={}for x,q in ipairs(t)do if not ac.minified then w=w..(\"    \"):rep(ad)end;af[x]=true;w=w..ab(q,v,ac,ad+1)..(ac.minified and\",\"or\",\\n\")end;for p,q in pairs(t)do if not af[p]then if not ac.minified then w=w..(\"    \"):rep(ad)end;if type(p)==\"string\"and p:match\"^[A-Za-z_][A-Za-z0-9_]*$\"and not aa[p]then w=w..p else w=w..\"[\"..ab(p,v,ac,ad+1)..\"]\"end;w=w..(ac.minified and\"=\"or\" = \")..ab(q,v,ac,ad+1)..(ac.minified and\",\"or\",\\n\")end end;if ac.minified then w=w:gsub(\",$\",\"\")else w=w..(\"    \"):rep(ad-1)end;v[t]=nil;return w..\"}\"elseif ae==\"function\"and ac.allow_functions then local ag,ah=pcall(string.dump,t)if not ag then error(\"Cannot serialize C function\",0)end;ah=(\"%q\"):format(ah):gsub(\"\\\\[%z\\1-\\31\\127-\\255]\",function(j)return(\"\\\\%03d\"):format(string.byte(j))end)local ai={n=0}v[t]=true;for x=1,math.huge do local ag,aj,ak=pcall(debug.getupvalue,t,x)if not ag or not aj then break end;ai[x]=ak;ai.n=x end;local aj=\"=(serialized function)\"local ag,al=pcall(debug.getinfo,t,\"S\")if ag then aj=al.source or aj end;local q=(\"__function(%s,%q,%s)\"):format(ah,aj,ab(ai,v,ac,ad+1))v[t]=nil;return q elseif ae==\"nil\"or ae==\"number\"or ae==\"boolean\"or ae==\"string\"then return(\"%q\"):format(t):gsub(\"\\\\\\n\",\"\\\\n\"):gsub(\"\\\\?[%z\\1-\\31\\127-\\255]\",function(j)return(\"\\\\%03d\"):format(string.byte(j))end)else error(\"Cannot serialize type \"..ae,0)end end;function b.lua.encode(t,ac)a(2,ac,\"table\",\"nil\")return ab(t,{},ac or{},1)end;function b.lua.decode(d,ac)ac=a(2,ac,\"table\",\"nil\")or{}local am={}local an={}if ac.allow_functions then function am.__function(ao,aj,ai)a(1,ao,\"string\")a(3,ai,\"table\")a.field(ai,\"n\",\"number\")local ap=assert(load(ao,aj,\"b\",{}))for x=1,ai.n do debug.setupvalue(ap,x,ai[x])end;an[#an+1]=ap;return ap end end;local w=assert(load(\"return \"..d,\"=unserialize\",\"t\",am))()for aq,q in ipairs(an)do setfenv(q,_G)end;return w end;function b.lua.save(t,a7,ac)a(2,a7,\"string\")local a8=assert(io.open(a7,\"w\"))a8:write(b.lua.encode(t,ac))a8:close()end;function b.lua.load(a7,ac)a(1,a7,\"string\")local a8=assert(io.open(a7,\"r\"))local a9=a8:read(\"*a\")a8:close()return b.lua.decode(a9,ac)end;local function ar(as,ac,at)local au,d=false,false;for av in pairs(as)do if type(av)==\"number\"then au=true elseif type(av)==\"string\"then d=true else error(\"key \"..table.concat(at,\".\")..\".\"..tostring(av)..\" is not a string\")end end;local aw=#at+1;if not au and not d then return\"[]\"elseif au and d then error(\"invalid entry \"..table.concat(at,\".\")..\" (contains both array and dictionary values)\")elseif au then local e=\"[\"for x,q in ipairs(as)do if type(q)==\"table\"then at[aw]=tostring(x)e=e..(e==\"[\"and\"\"or\", \")..ar(q,ac,at)at[aw]=nil else e=e..(e==\"[\"and\"\"or\", \")..ab(q,{},{},#at)end end;return e..\"]\"else local w=\"{\"for p,q in pairs(as)do if w~=\"{\"then w=w..\", \"end;if type(p)==\"string\"and p:match\"^[A-Za-z0-9_%-]+$\"then w=w..p else w=w..ab(p,{},{},#at)end;if type(q)==\"table\"then at[aw]=p;w=w..\" = \"..ar(q,ac,at)at[aw]=nil else w=w..\" = \"..ab(q,{},{},#at)end end;return w..\"}\"end end;local function ax(ay,ac,at)local e=\"\"local az=ac.indent==false and\"\"or(\"    \"):rep(#at)if#at>0 then e=(\"%s[%s]\\n\"):format((\"    \"):rep(#at-1),table.concat(at,\".\"))end;local aA,aB={},{}local aw=#at+1;for p,q in pairs(ay)do assert(type(p)==\"string\",\"key \"..table.concat(at,\".\")..\".\"..tostring(p)..\" is not a string\")local a5=p:match(\"^[A-Za-z0-9_%-]+$\")and p or ab(p,{},{},1)local B=type(q)if B==\"table\"then local au,d,aC=false,false,true;for av,aD in pairs(q)do if type(av)==\"number\"then au=true elseif type(av)==\"string\"then d=true else error(\"key \"..table.concat(at,\".\")..\".\"..tostring(p)..\".\"..tostring(av)..\" is not a string\")end;if type(aD)~=\"table\"then aC=false else for aE in pairs(aD)do if type(aE)~=\"string\"then aC=false;break end end end end;if not au and not d then e=e..az..a5 ..\" = []\\n\"elseif au and d then error(\"invalid entry \"..table.concat(at,\".\")..\".\"..tostring(p)..\" (contains both array and dictionary values)\")elseif au then if aC then aB[p]=q else at[aw]=p;e=e..az..a5 ..\" = \"..ar(q,ac,at)at[aw]=nil end else aA[p]=q end else e=e..az..a5 ..\" = \"..ab(q,{},{},#at)..\"\\n\"end end;for p,as in pairs(aB)do at[aw]=p;for aq,q in ipairs(as)do e=e..(\"%s[[%s]]\\n\"):format(az,table.concat(at,\".\"))..ax(q,ac,at)..\"\\n\"end end;for p,q in pairs(aA)do at[aw]=p;e=e..(\"%s[%s]\\n\"):format(az,table.concat(at,\".\"))..ax(q,ac,at)..\"\\n\"end;at[aw]=nil;return e end;function b.toml.encode(ay,ac)a(1,ay,\"table\")a(2,ac,\"table\",\"nil\")return ax(ay,ac or{},{})end;local function aF(aC,aj,aG,aH,aI)local aJ,aK;while aG<#aj do if aG>1 then aG=aj:match(\"^%s*()\",aG)if aI and aj:sub(aG,aG)==\"=\"then return aJ,aK,aG+1 end;if aj:sub(aG,aG)~=\".\"then error(\"Expected . on line \"..aH,3)end;aG=aj:match(\"^%s*()\",aG+1)end;local a5;if aj:match('^\"',aG)then a5,aG=W(aj,aG+1)elseif aj:match(\"^'\",aG)then a5,aG=aj:match(\"'([^']*)'()\",aG)else a5,aG=aj:match(\"^([A-Za-z0-9_%-]+)()\",aG)end;if not a5 then error(\"Invalid key name on line \"..aH,3)end;aJ,aK=aC,a5;if not aC[a5]then aC[a5]={}end;aC=aC[a5]end;if aI then error(\"Expected = on line \"..aH,3)end;return aC end;local function aL(aM,aG,aH)aG=aM:match(\"^%s*()\",aG)while aG>#aM or aM:sub(aG,aG)==\"#\"do aM=coroutine.yield()aH=aH+1;aG=aM:match\"^%s*()\"end;return aM,aG,aH end;local function aN(aC,a5,aM,aG,aH)local aO=aM:sub(aG,aG)while aO==\"#\"do aM=coroutine.yield()aH=aH+1;aG=aM:match\"^%s*()\"aO=aM:sub(aG,aG)end;if aO==\"[\"then local e={}local x=1;aM,aG,aH=aL(aM,aG+1,aH)while true do aO=aM:sub(aG,aG)if aO==\"]\"then break end;aM,aG,aH=aN(e,x,aM,aG,aH)aM,aG,aH=aL(aM,aG,aH)aO=aM:sub(aG,aG)if aO==\"]\"then break end;if aO~=\",\"then error(\"Expected , on line \"..aH,0)end;aM,aG,aH=aL(aM,aG+1,aH)x=x+1 end;aC[a5]=e;return aM,aG+1,aH elseif aO==\"{\"then local e={}aM,aG,aH=aL(aM,aG+1,aH)while true do aO=aM:sub(aG,aG)if aO==\"}\"then break end;local B,p;B,p,aG=aF(e,aM,aG,aH,true)aM,aG,aH=aL(aM,aG,aH)aM,aG,aH=aN(B,p,aM,aG,aH)aM,aG,aH=aL(aM,aG,aH)aO=aM:sub(aG,aG)if aO==\"}\"then break end;if aO~=\",\"then error(\"Expected , on line \"..aH,0)end;aM,aG,aH=aL(aM,aG+1,aH)end;aC[a5]=e;return aM,aG+1,aH elseif aO==\"'\"then if aM:match(\"^'''\",aG)then aG=aG+3;local d=\"\"while not aM:find(\"'''\",aG)do if not(d==\"\"and aG==#aM)then d=d..aM:sub(aG)..\"\\n\"end;aM=coroutine.yield()aH,aG=aH+1,1 end;d=d..aM:sub(aG,aM:find(\"'''\",aG)-1)aG=aM:match(\"'''()\",aG)aC[a5]=d;return aM,aG,aH else local d,aG=aM:match(\"^'([^']*)'()\",aG)if not d then error(\"Invalid literal string on line \"..aH,0)end;aC[a5]=d;return aM,aG,aH end elseif aO=='\"'then if aM:match('^\"\"\"',aG)then local f=\"\"while not aM:find('\"\"\"',aG)do if not(f==\"\"and aG==#aM)then f=f..aM:sub(aG)..\"\\n\"end;aM=coroutine.yield()aH,aG=aH+1,1 end;f=f..aM:sub(aG,aM:find('\"\"\"',aG)-1)f=f:gsub(\"\\\\\\r?\\n\",\"\"):gsub('\"','\\\\\"')..'\"'aC[a5]=W(f,1)aG=aM:match('\"\"\"()',aG)return aM,aG,aH else local d,aG=W(aM,aG)if not d then error(\"Invalid string on line \"..aH,0)end;aC[a5]=d;return aM,aG,aH end elseif aM:match(\"^%d%d%d%d%-%d%d%-%d%d[T ]%d%d:%d%d:%d%d\",aG)then local aP,aQ,k,aR,aE,f,aG=aM:match(\"^(%d%d%d%d)%-(%d%d)%-(%d%d)[T ](%d%d):(%d%d):(%d%d)()\",aG)local aS={year=tonumber(aP),month=tonumber(aQ),day=tonumber(k),hour=tonumber(aR),min=tonumber(aE),sec=tonumber(f)}local aT=os.time(aS)if aM:match(\"^%.%d+\",aG)then local aU;aU,aG=aM:match(\"(%.%d+)()\",aG)aT=aT+tonumber(\"0\"..aU)end;local j=aM:sub(aG,aG)if j==\"+\"or j==\"-\"then local aV,aW;aV,aW,aG=aM:match(\"^[%+%-](%d%d):(%d%d)()\",aG)if not aV then error(\"Invalid date format on line \"..aH,0)end;local aX=tonumber(aV)*3600+tonumber(aW)*60;if j==\"-\"then aX=-aX end;aT=aT+aX elseif j==\"Z\"then aG=aG+1 end;aC[a5]=aT;return aM,aG,aH elseif aM:match(\"^%d%d%d%d%-%d%d%-%d%d\",aG)then local aP,aQ,k,aG=aM:match(\"^(%d%d%d%d)%-(%d%d)%-(%d%d)()\",aG)local aS={year=tonumber(aP),month=tonumber(aQ),day=tonumber(k),hour=0,min=0,sec=0}local aT=os.time(aS)aC[a5]=aT;return aM,aG,aH elseif aM:match(\"^%d%d%:%d%d:%d%d\",aG)then local aR,aE,f,aG=aM:match(\"^(%d%d):(%d%d):(%d%d)()\",aG)local aT=aR*3600+aE*60*f;if aM:match(\"^%.%d+\",aG)then local aU;aU,aG=aM:match(\"(%.%d+)()\",aG)aT=aT+tonumber(\"0\"..aU)end;aC[a5]=aT;return aM,aG,aH elseif aO:match\"%d\"or aO==\"+\"or aO==\"-\"then if aM:match(\"^%+inf\",aG)then aC[a5]=math.huge;return aM,aG+4,aH elseif aM:match(\"^%-inf\",aG)then aC[a5]=-math.huge;return aM,aG+4,aH elseif aM:match(\"^%+nan\",aG)then aC[a5]=-(0/0)return aM,aG+4,aH elseif aM:match(\"^%-nan\",aG)then aC[a5]=0/0;return aM,aG+4,aH elseif aM:match(\"^[%+%-]?0o\",aG)then local aY,af,aG=aM:match(\"^([%+%-]?)0o([0-7_]+)()\",aG):gsub(\"_\",\"\")if not af then error(\"Invalid number on line \"..aH,0)end;af=tonumber(af,8)if not af then error(\"Invalid number on line \"..aH,0)end;if aY==\"-\"then af=-af end;aC[a5]=af;return aM,aG,aH elseif aM:match(\"^[%+%-]?0b\",aG)then local aY,af,aG=aM:match(\"^([%+%-]?)0b([01_]+)()\",aG):gsub(\"_\",\"\")if not af then error(\"Invalid number on line \"..aH,0)end;af=tonumber(af,2)if not af then error(\"Invalid number on line \"..aH,0)end;if aY==\"-\"then af=-af end;aC[a5]=af;return aM,aG,aH else local af,aG=aM:match(\"^([%+%-]?[%d_]+%.?[%d_]*[Ee]?[%+%-]?[%d_]*)()\",aG)af=af:gsub(\"_\",\"\")af=tonumber(af)if not af then error(\"Invalid number on line \"..aH,0)end;aC[a5]=af;return aM,aG,aH end elseif aM:match(\"^true\",aG)then aC[a5]=true;return aM,aG+4,aH elseif aM:match(\"^false\",aG)then aC[a5]=false;return aM,aG+5,aH elseif aM:match(\"^nil\",aG)then aC[a5]=nil;return aM,aG+3,aH elseif aM:match(\"^inf\",aG)then aC[a5]=math.huge;return aM,aG+3,aH elseif aM:match(\"^nan\",aG)then aC[a5]=-(0/0)return aM,aG+3,aH else error(\"Unexpected \"..aO..\" on line \"..aH,0)end end;function b.toml.decode(d,ac)a(1,d,\"string\")ac=a(2,ac,\"table\",\"nil\")or{}local e={}local aZ=e;local aH=1;local a_;for aM in d:gmatch\"([^\\r\\n]*)\\r?\\n\"do if a_ then local ag,b0=a_:resume(aM)if not ag then error(b0,3)end;if a_:status()==\"dead\"then a_=nil end else aM=aM:gsub(\"^%s+\",\"\")if aM:match\"^#\"or aM==\"\"then elseif aM:match\"^%[%[\"then local b1=aM:match\"^%[(%b[])%]\"if not b1 then error(\"Expected ]] on line \"..aH,2)end;aZ=aF(e,b1:sub(2,-2),1,aH)aZ[#aZ+1]={}aZ=aZ[#aZ]elseif aM:match\"^%[\"then local b1=aM:match\"^%b[]\"if not b1 then error(\"Expected ] on line \"..aH,2)end;aZ=aF(e,b1:sub(2,-2),1,aH)else local aJ,a5,aG=aF(aZ,aM,1,aH,true)aG=aM:match(\"^%s*()\",aG)if not aG then error(\"Expected value on line \"..aH,2)end;a_=coroutine.create(aN)local ag,b0=a_:resume(aJ,a5,aM,aG,aH)if not ag then error(b0,3)end;if a_:status()==\"dead\"then a_=nil end end end;aH=aH+1 end;if a_ then error(\"Unfinished value at end of file\",2)end;return e end;function b.toml.save(t,a7,ac)a(1,t,\"table\")a(2,a7,\"string\")a(3,ac,\"table\",\"nil\")local a8=assert(io.open(a7,\"w\"))a8:write(b.toml.encode(t,ac))a8:close()end;function b.toml.load(a7,ac)a(1,a7,\"string\")a(2,ac,\"table\",\"nil\")local a8=assert(io.open(a7,\"r\"))local a9=a8:read(\"*a\")a8:close()return b.toml.decode(a9,ac)end;return b\n\nsync.lua/       0           0     0     644     3341      `\nlocal a=require\"expect\"local b=require\"util\"local c={mutex={},semaphore={},conditionVariable={},atomic={},barrier={},rwLock={}}function c.mutex.new(d)a(1,d,\"boolean\",\"nil\")return setmetatable({recursive=d and 0},{__name=\"mutex\",__index=c.mutex})end;function c.mutex:lock()a(1,self,\"mutex\")return b.syscall.lockmutex(self)end;function c.mutex:unlock()a(1,self,\"mutex\")return b.syscall.unlockmutex(self)end;function c.mutex:tryLock()a(1,self,\"mutex\")return b.syscall.trylockmutex(self)end;function c.mutex:tryLockFor(e)a(1,self,\"mutex\")a(2,e,\"number\")return b.syscall.timelockmutex(self,e)end;function c.semaphore.new(f)a(1,f,\"number\",\"nil\")if f then a.range(f,0)end;return setmetatable({count=f or 1},{__name=\"semaphore\",__index=c.semaphore})end;function c.semaphore:acquire()a(1,self,\"semaphore\")return b.syscall.acquiresemaphore(self)end;function c.semaphore:tryAcquireFor(e)a(1,self,\"semaphore\")a(2,e,\"number\")return b.syscall.timeacquiresemaphore(self,e)end;function c.semaphore:release()a(1,self,\"semaphore\")return b.syscall.releasesemaphore(self)end;function c.conditionVariable.new()return setmetatable({lock=c.mutex.new(),sem=c.semaphore.new(0),waiting=0},{__name=\"condition variable\",__index=c.conditionVariable})end;function c.conditionVariable:wait()a(1,self,\"condition variable\")self.lock:lock()self.waiting=self.waiting+1;self.lock:unlock()self.sem:acquire()self.lock:lock()self.waiting=self.waiting-1;self.lock:unlock()end;function c.conditionVariable:waitFor(e)a(1,self,\"condition variable\")a(2,e,\"number\")self.lock:lock()self.waiting=self.waiting+1;self.lock:unlock()local g=self.sem:tryAcquireFor(e)self.lock:lock()self.waiting=self.waiting-1;self.lock:unlock()return g end;function c.conditionVariable:notifyOne()a(1,self,\"condition variable\")self.sem:release()end;function c.conditionVariable:notifyAll()a(1,self,\"condition variable\")self.lock:lock()self.sem.count=self.sem.count+self.waiting-1;self.sem:release()self.lock:unlock()end;function c.barrier.new(h)a(1,h,\"number\")a.range(h,1)return setmetatable({cvar=c.conditionVariable.new(),lock=c.mutex.new(),left=h,count=h,cycles=0},{__name=\"barrier\",__index=c.barrier})end;function c.barrier:wait()a(1,self,\"barrier\")self.lock:lock()self.left=self.left-1;if self.left==0 then self.left=self.count;self.cycles=self.cycles+1;self.lock:unlock()self.cvar:notifyAll()return true else self.lock:unlock()self.cvar:wait()return false end end;function c.rwLock.new()return setmetatable({count=0,readLock=c.mutex.new(),globalLock=c.semaphore.new(1)},{__name=\"rwlock\",__index=c.rwLock})end;function c.rwLock:lockRead()a(1,self,\"rwlock\")self.readLock:lock()self.count=self.count+1;if self.count==1 then self.globalLock:acquire()end;self.readLock:unlock()end;function c.rwLock:unlockRead()a(1,self,\"rwlock\")self.readLock:lock()self.count=self.count-1;if self.count==0 then self.globalLock:release()end;self.readLock:unlock()end;function c.rwLock:lockWrite()a(1,self,\"rwlock\")self.globalLock:acquire()end;function c.rwLock:unlockWrite()a(1,self,\"rwlock\")self.globalLock:release()end;function c.lockGuard(i,j,...)a(1,i,\"mutex\")a(2,j,\"function\")i:lock()local k=table.pack(pcall(j,...))i:unlock()if not k[1]then error(k[2],0)end;return table.unpack(k,2,k.n)end;function c.synctab()local l={}local m=c.mutex.new()return function(j)a(1,j,\"function\")return c.lockGuard(m,j,l)end end;return c\n\nterminal.lua/   0           0     0     644     4285      `\nlocal a=require\"expect\"local b=require\"keys\"local c=require\"util\"local d={}d.colors={white=0,orange=1,magenta=2,lightBlue=3,yellow=4,lime=5,pink=6,gray=7,grey=7,lightGray=8,lightGrey=8,cyan=9,purple=10,blue=11,brown=12,green=13,red=14,black=15}d.colours=d.colors;function d.toEscape(e,f)a(1,e,\"number\")a(2,f,\"boolean\",\"nil\")a.range(e,0,15)local g=37-e%8;if e<8 then g=g+60 end;if f then g=g+10 end;return\"\\x1b[\"..g..\"m\"end;function d.write(...)return c.syscall.write(...)end;function d.writeerr(...)return c.syscall.writeerr(...)end;function d.read(g)a(1,g,\"number\")return c.syscall.read(g)end;function d.readline()return c.syscall.readline()end;function d.readline2(h,i)a(1,h,\"table\",\"nil\")a(2,i,\"function\",\"nil\")local j=\"\"local k=1;local l=0;local m;local n,o;d.capture()d.termctl{echo=false}while true do local p,q=coroutine.yield()if p==\"char\"then if n and n[o]and q.character==n[o]:sub(-1)then n=nil else n=nil;if k<=#j then d.write(\"\\x1b[@\"..q.character)j=j:sub(1,k-1)..q.character..j:sub(k)else d.write(q.character)j=j..q.character end;k=k+1 end elseif p==\"key\"then if q.keycode==b.enter then d.termctl{echo=true}if k<=#j then d.write(\"\\x1b[\"..#j-k+1 ..\"C\")end;d.write(\"\\n\")d.readline()d.release()return j elseif q.keycode==b.d and q.ctrlHeld and not q.altHeld and not q.shiftHeld then d.termctl{echo=true}d.release()return d.readline()elseif q.keycode==b.backspace and k>1 then n=nil;d.write(\"\\x1b[D\\x1b[P\")j=j:sub(1,k-2)..j:sub(k)k=k-1 elseif q.keycode==b.delete and k<=#j then n=nil;d.write(\"\\x1b[P\")j=j:sub(1,k-1)..j:sub(k+1)elseif q.keycode==b.left and k>1 then n=nil;d.write(\"\\x1b[D\")k=k-1 elseif q.keycode==b.right and k<=#j then n=nil;d.write(\"\\x1b[C\")k=k+1 elseif q.keycode==b.up and h and l<#h then n=nil;if k>1 then d.write(\"\\x1b[\"..k-1 ..\"D\")end;d.write(\"\\x1b[\"..#j..\"P\")if l==0 then m=j end;l=l+1;j=h[l]d.write(j)k=#j+1 elseif q.keycode==b.down and h and l>0 then n=nil;if k>1 then d.write(\"\\x1b[\"..k-1 ..\"D\")end;d.write(\"\\x1b[\"..#j..\"P\")l=l-1;if l==0 then j=m else j=h[l]end;d.write(j)k=#j+1 elseif q.keycode==b.tab and i then if n and#n>0 then d.write(\"\\x1b[\"..#n[o]..\"D\\x1b[\"..#n[o]..\"P\")j=j:sub(1,k-#n[o]-1)..j:sub(k)k=k-#n[o]o=o%#n+1 else n=i(j:sub(1,k-1))o=1 end;if n[o]then d.write(\"\\x1b[\"..#n[o]..\"@\"..n[o])j=j:sub(1,k-1)..n[o]..j:sub(k)k=k+#n[o]end end elseif p==\"paste\"then n=nil;if k<=#j then d.write(\"\\x1b[\"..#q.text..\"@\"..q.text)j=j:sub(1,k-1)..q.text..j:sub(k)k=k+#q.text else d.write(q.text)j=j..q.text end;k=k+#q.text end end end;function d.termctl(r)a(1,r,\"table\",\"nil\")if r then a.field(r,\"cbreak\",\"boolean\",\"nil\")a.field(r,\"delay\",\"boolean\",\"nil\")a.field(r,\"echo\",\"boolean\",\"nil\")a.field(r,\"keypad\",\"boolean\",\"nil\")a.field(r,\"nlcr\",\"boolean\",\"nil\")a.field(r,\"raw\",\"boolean\",\"nil\")end;return c.syscall.termctl(r)end;function d.openterm()return c.syscall.openterm()end;function d.opengfx()return c.syscall.opengfx()end;function d.mktty(s,t)a(1,s,\"number\")a(2,t,\"number\")return c.syscall.mktty(s,t)end;function d.capture()return c.syscall.capture()end;function d.release()return c.syscall.release()end;function d.stdin(u)a(1,u,\"number\",\"table\",\"nil\")return c.syscall.stdin(u)end;function d.stdout(u)a(1,u,\"number\",\"table\",\"nil\")return c.syscall.stdout(u)end;function d.stderr(u)a(1,u,\"number\",\"table\",\"nil\")return c.syscall.stderr(u)end;function d.istty()return c.syscall.istty()end;function d.termsize()return c.syscall.termsize()end;d.getSize=d.termsize;local v={}function v.close()end;function v.write(w)end;function v.blit(w,x,y)end;function v.clear()end;function v.clearLine()end;function v.getCursorPos()end;function v.setCursorPos(z,A)end;function v.getCursorBlink()end;function v.setCursorBlink(B)end;function v.isColor()end;function v.getSize()end;function v.scroll(C)end;function v.getTextColor()end;function v.setTextColor(e)end;function v.getBackgroundColor()end;function v.setBackgroundColor(e)end;function v.getPaletteColor(e)end;function v.setPaletteColor(e,D,E,F)end;function v.getLine(A)end;local G={}function G.close()end;function G.getSize()end;function G.clear()end;function G.getPaletteColor(e)end;function G.setPaletteColor(e,D,E,F)end;function G.getPixel(z,A)end;function G.setPixel(z,A,e)end;function G.getPixels(z,A,s,t,H)end;function G.drawPixels(z,A,I,s,t)end;function G.getFrozen()end;function G.setFrozen(J)end;return d\n\nutil.lua/       0           0     0     644     6724      `\nlocal a=require\"expect\"local b={}b.syscall=setmetatable({},{__index=function(self,c)return function(...)local d=table.pack(coroutine.yield(\"syscall\",c,...))if d[1]then return table.unpack(d,2,d.n)else error(d[2],2)end end end,__newindex=function()end})function b.argparse(e,...)a(1,e,\"table\")a.field(e,\"\",\"table\",\"nil\")local d={}local f;local g=e[\"\"]or{}for h,i in ipairs{...}do if f then if e[f]==\"number\"then d[f]=tonumber(i)if not d[f]then return nil,\"parameter passed to argument '\"..f..\"' is not a number\"end elseif e[f]==\"multiple\"then d[f]=d[f]or{}d[f][#d[f]+1]=i elseif e[f]==\"multiple number\"then i=tonumber(i)if not i then return nil,\"parameter passed to argument '\"..f..\"' is not a number\"end;d[f]=d[f]or{}d[f][#d[f]+1]=i else d[f]=i end;f=nil elseif i:match\"^%-+$\"then local j=table.pack(...)local k=i==\"-\"and#d+1 or#d;for l=i==\"-\"and 0 or 1,j.n-h do d[k+l]=j[h+l]end;break elseif i:sub(1,2)==\"--\"then local m=i:sub(3)while type(e[m])==\"string\"and e[m]:match\"^@\"do m=e[m]:sub(2)end;if e[m]then f=m elseif e[m]==false then d[m]=true else return nil,\"unrecognized argument '--\"..m..\"'\"end elseif i:sub(1,1)==\"-\"then for m in i:sub(2):gmatch\".\"do while type(e[m])==\"string\"and e[m]:match\"^@\"do m=e[m]:sub(2)end;if e[m]then if f then return nil,\"no parameter passed to argument '\"..f..\"'\"end;f=m elseif e[m]==false then d[m]=true else return nil,\"unrecognized argument '-\"..m..\"'\"end end else if g.stopProcessingOnPositionalArgument then local j=table.pack(...)local k=#d+1;for l=0,j.n-h do d[k+l]=j[h+l]end;break else d[#d+1]=i end end end;if f then return nil,\"no parameter passed to argument '\"..f..\"'\"end;return d end;function b.timer(n)a(1,n,\"number\")return b.syscall.timer(n)end;function b.alarm(n)a(1,n,\"number\")return b.syscall.alarm(n)end;function b.cancel(o)a(1,o,\"number\")return b.syscall.cancel(o)end;function b.sleep(n)a(1,n,\"number\")local p=b.syscall.timer(n)repeat local q,r=coroutine.yield()until q==\"timer\"and r.id==p end;function b.pullEvent()return coroutine.yield()end;function b.filterEvent(...)local s={...}for h,t in ipairs(s)do a(h,t,\"string\")end;while true do local u,r=coroutine.yield()for v,t in ipairs(s)do if u==t then return u,r end end end end;function b.queueEvent(u,r)a(1,u,\"string\")a(2,r,\"table\")return b.syscall.queueEvent(u,r)end;function b.peekEvent()return b.syscall.peekEvent()end;function b.split(w,x,y)a(1,w,\"string\")a(2,x,\"string\",\"nil\")local z={}if y then local k,m=1,w:find(\"[\"..x..\"]\")while k do z[#z+1]=w:sub(k,m and m-1)k=m and m+1;m=w:find(\"[\"..x..\"]\",k)end else for A in w:gmatch(\"[^\"..(x or\"%s\")..\"]+\")do z[#z+1]=A end end;return z end;function b.copy(B)if type(B)==\"table\"then local d=setmetatable({},b.copy(getmetatable(B)))for C,t in pairs(B)do d[b.copy(C)]=b.copy(t)end;return d else return B end end;local D={}function b.addEventListener(u,E)a(1,u,\"string\")a(2,E,\"function\")D[u]=D[u]or{}D[u][#D[u]+1]=E end;function b.removeEventListener(u,E)a(1,u,\"string\")a(2,E,\"function\")if D[u]then for C,t in ipairs(D[u])do if t==E then table.remove(D[u],C)return end end end end;function b.runEvents()while true do local u,r=coroutine.yield()if D[u]then for v,t in ipairs(D[u])do local F,G=pcall(t,u,r)if not F then return G end;if G then break end end end end end;function b.startEvents()return b.syscall.newthread(b.runEvents)end;function b.type(B)local z=type(B)if z==\"table\"then local H=getmetatable(B)if H and H.__name then return H.__name end end;return z end;local I={[0xEDB88320]={[0]=0x00000000,0x77073096,0xee0e612c,0x990951ba,0x076dc419,0x706af48f,0xe963a535,0x9e6495a3,0x0edb8832,0x79dcb8a4,0xe0d5e91e,0x97d2d988,0x09b64c2b,0x7eb17cbd,0xe7b82d07,0x90bf1d91,0x1db71064,0x6ab020f2,0xf3b97148,0x84be41de,0x1adad47d,0x6ddde4eb,0xf4d4b551,0x83d385c7,0x136c9856,0x646ba8c0,0xfd62f97a,0x8a65c9ec,0x14015c4f,0x63066cd9,0xfa0f3d63,0x8d080df5,0x3b6e20c8,0x4c69105e,0xd56041e4,0xa2677172,0x3c03e4d1,0x4b04d447,0xd20d85fd,0xa50ab56b,0x35b5a8fa,0x42b2986c,0xdbbbc9d6,0xacbcf940,0x32d86ce3,0x45df5c75,0xdcd60dcf,0xabd13d59,0x26d930ac,0x51de003a,0xc8d75180,0xbfd06116,0x21b4f4b5,0x56b3c423,0xcfba9599,0xb8bda50f,0x2802b89e,0x5f058808,0xc60cd9b2,0xb10be924,0x2f6f7c87,0x58684c11,0xc1611dab,0xb6662d3d,0x76dc4190,0x01db7106,0x98d220bc,0xefd5102a,0x71b18589,0x06b6b51f,0x9fbfe4a5,0xe8b8d433,0x7807c9a2,0x0f00f934,0x9609a88e,0xe10e9818,0x7f6a0dbb,0x086d3d2d,0x91646c97,0xe6635c01,0x6b6b51f4,0x1c6c6162,0x856530d8,0xf262004e,0x6c0695ed,0x1b01a57b,0x8208f4c1,0xf50fc457,0x65b0d9c6,0x12b7e950,0x8bbeb8ea,0xfcb9887c,0x62dd1ddf,0x15da2d49,0x8cd37cf3,0xfbd44c65,0x4db26158,0x3ab551ce,0xa3bc0074,0xd4bb30e2,0x4adfa541,0x3dd895d7,0xa4d1c46d,0xd3d6f4fb,0x4369e96a,0x346ed9fc,0xad678846,0xda60b8d0,0x44042d73,0x33031de5,0xaa0a4c5f,0xdd0d7cc9,0x5005713c,0x270241aa,0xbe0b1010,0xc90c2086,0x5768b525,0x206f85b3,0xb966d409,0xce61e49f,0x5edef90e,0x29d9c998,0xb0d09822,0xc7d7a8b4,0x59b33d17,0x2eb40d81,0xb7bd5c3b,0xc0ba6cad,0xedb88320,0x9abfb3b6,0x03b6e20c,0x74b1d29a,0xead54739,0x9dd277af,0x04db2615,0x73dc1683,0xe3630b12,0x94643b84,0x0d6d6a3e,0x7a6a5aa8,0xe40ecf0b,0x9309ff9d,0x0a00ae27,0x7d079eb1,0xf00f9344,0x8708a3d2,0x1e01f268,0x6906c2fe,0xf762575d,0x806567cb,0x196c3671,0x6e6b06e7,0xfed41b76,0x89d32be0,0x10da7a5a,0x67dd4acc,0xf9b9df6f,0x8ebeeff9,0x17b7be43,0x60b08ed5,0xd6d6a3e8,0xa1d1937e,0x38d8c2c4,0x4fdff252,0xd1bb67f1,0xa6bc5767,0x3fb506dd,0x48b2364b,0xd80d2bda,0xaf0a1b4c,0x36034af6,0x41047a60,0xdf60efc3,0xa867df55,0x316e8eef,0x4669be79,0xcb61b38c,0xbc66831a,0x256fd2a0,0x5268e236,0xcc0c7795,0xbb0b4703,0x220216b9,0x5505262f,0xc5ba3bbe,0xb2bd0b28,0x2bb45a92,0x5cb36a04,0xc2d7ffa7,0xb5d0cf31,0x2cd99e8b,0x5bdeae1d,0x9b64c2b0,0xec63f226,0x756aa39c,0x026d930a,0x9c0906a9,0xeb0e363f,0x72076785,0x05005713,0x95bf4a82,0xe2b87a14,0x7bb12bae,0x0cb61b38,0x92d28e9b,0xe5d5be0d,0x7cdcefb7,0x0bdbdf21,0x86d3d2d4,0xf1d4e242,0x68ddb3f8,0x1fda836e,0x81be16cd,0xf6b9265b,0x6fb077e1,0x18b74777,0x88085ae6,0xff0f6a70,0x66063bca,0x11010b5c,0x8f659eff,0xf862ae69,0x616bffd3,0x166ccf45,0xa00ae278,0xd70dd2ee,0x4e048354,0x3903b3c2,0xa7672661,0xd06016f7,0x4969474d,0x3e6e77db,0xaed16a4a,0xd9d65adc,0x40df0b66,0x37d83bf0,0xa9bcae53,0xdebb9ec5,0x47b2cf7f,0x30b5ffe9,0xbdbdf21c,0xcabac28a,0x53b39330,0x24b4a3a6,0xbad03605,0xcdd70693,0x54de5729,0x23d967bf,0xb3667a2e,0xc4614ab8,0x5d681b02,0x2a6f2b94,0xb40bbe37,0xc30c8ea1,0x5a05df1b,0x2d02ef8d}}function b.crc32(w,J,K)a(1,w,\"string\")J=a(2,J,\"table\",\"number\",\"nil\")or 0xEDB88320;K=a(3,K,\"number\",\"nil\")or 0xFFFFFFFF;local L=type(J)==\"table\"and J or I[J]if not L then L={}for h=0,255 do local M=h;for v=1,8 do if bit32.btest(M,1)then M=bit32.bxor(bit32.rshift(M,1),J)else M=bit32.rshift(M,1)end end;L[h]=M end;I[J]=L end;for h=1,#w do K=bit32.bxor(L[bit32.band(bit32.bxor(w:byte(h),bit32.band(K,0xFF)))],bit32.rshift(K,8))end;return bit32.bnot(K)end;return b\n",setuser=false,size=91336,modified=1757997041256,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["yellowbox.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997043422,data="\n",setuser=false,size=1,modified=1757997043406,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["startmgr.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997042776,data="local a=require\"system.expect\"local b=require\"system.ipc\"local c=require\"system.process\"local d={}local function e(f,g,h)h=h or c.getuser()local i=b.lookup(h==\"root\"and\"ServiceManager\"or\"ServiceManager.\"..h)if not i then error(\"Could not connect to service manager\",2)end;b.sendEvent(i,\"startmgr.request\",{func=f,param=g})while true do local j,k=b.receiveEvent(i,\"startmgr.response\",5)if not k then error(\"Timed out waiting for service manager\",2)end;if k.func==f then if k.ok then return table.unpack(k.result)else error(k.error,3)end end end end;function d.start(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"start\",l,h)end;function d.stop(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"stop\",l,h)end;function d.kill(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"kill\",l,h)end;function d.restart(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"restart\",l,h)end;function d.reload(l,h)a(1,l,\"string\",\"nil\")a(2,h,\"string\",\"nil\")return e(\"reload\",l,h)end;function d.add(m,h)a(1,m,\"string\")a(2,h,\"string\",\"nil\")return e(\"add\",m,h)end;function d.remove(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"remove\",l,h)end;function d.list(h)a(1,h,\"string\",\"nil\")return e(\"list\",nil,h)end;function d.status(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"status\",l,h)end;function d.install(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"install\",l,h)end;function d.uninstall(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"uninstall\",l,h)end;function d.shutdown()if c.getuser()~=\"root\"then error(\"Permission denied\")end;return e(\"shutdown\",{},\"root\")end;function d.reboot()if c.getuser()~=\"root\"then error(\"Permission denied\")end;return e(\"reboot\",{},\"root\")end;return d\n",setuser=false,size=1682,modified=1757997042751,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["diff.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040204,data="local a={}SKIP_SEPARATOR=true;IN=\"in\"OUT=\"out\"SAME=\"same\"local function b(c,d,e)d=d or\"%s+\"local f={}local g=1;local h,i=c:find(d,g)while h do table.insert(f,c:sub(g,h-1))if not e then table.insert(f,c:sub(h,i))end;g=i+1;h,i=c:find(d,g)end;if c:sub(g)~=\"\"then table.insert(f,c:sub(g))end;return f end;function a.quick_LCS(j,k)local l=#j;local m=#k;local n={}local setmetatable=setmetatable;local o={__index=function(p,q)p[q]=0;return 0 end}local r={__index=function(p,q)local s={}setmetatable(s,o)p[q]=s;return s end}setmetatable(n,r)local t=math.max;for u=1,l+1 do local v=n[u+1]local w=n[u]for x=1,m+1 do if j[u-1]==k[x-1]then v[x+1]=w[x]+1 else v[x+1]=t(v[x],w[x+1])end end end;return n end;local function y(c)c=c:gsub(\"&\",\"&amp;\"):gsub(\">\",\"&gt;\"):gsub(\"<\",\"&lt;\")c=c:gsub(\"\\\"\",\"&quot;\")return c end;function a.format_as_html(z)local A=\"\"local B,C;for u,D in ipairs(z)do B=y(D[1])C=D[2]if C==\"in\"then A=A..\"<ins>\"..B..\"</ins>\"elseif C==\"out\"then A=A..\"<del>\"..B..\"</del>\"else A=A..B end end;return A end;function a.diff(E,F,d)assert(E)assert(F)F=b(F,d)E=b(E,d)local G=\"\"local H=\"\"while E[1]and E[1]==F[1]do local B=table.remove(E,1)table.remove(F,1)G=G..B end;while E[#E]and E[#E]==F[#F]do local B=table.remove(E)table.remove(F)H=B..H end;local I={put=function(self,B,J)table.insert(self,{B,J})end,ins=function(self,B)self:put(B,IN)end,del=function(self,B)self:put(B,OUT)end,same=function(self,B)if B then self:put(B,SAME)end end}I:same(H)local function K(n,E,F,u,x)local L=E[u]local M=F[x]if u>=1 and x>=1 and L==M then I:same(L)return K(n,E,F,u-1,x-1)else local N=n[u][x-1]local O=n[u-1][x]if x>=1 and(u==0 or N>=O)then I:ins(M)return K(n,E,F,u,x-1)elseif u>=1 and(x==0 or N<O)then I:del(L)return K(n,E,F,u-1,x)end end end;K(a.quick_LCS(E,F),E,F,#E+1,#F+1)I:same(G)local a={}for u=#I,1,-1 do table.insert(a,I[u])end;a.to_html=a.format_as_html;return a end;return a\n",setuser=false,size=1871,modified=1757997040201,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["typescript.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997043014,data="local a=require('system.expect')local function b(c,...)return a.expect(...)end;local function d(c,...)return a.field(...)end;local e=table.unpack or unpack;local function f(self,g)local h=g<0 and#self+g or g;if h>=0 and h<#self then return self[h+1]end;return nil end;local function i(j)return type(j)==\"table\"and(j[1]~=nil or next(j)==nil)end;local function k(self,...)local l={...}local m={}local n=0;for o=1,#self do n=n+1;m[n]=self[o]end;for o=1,#l do local p=l[o]if i(p)then for q=1,#p do n=n+1;m[n]=p[q]end else n=n+1;m[n]=p end end;return m end;local r,s;do local t={__tostring=function(self)return(\"Symbol(\"..(self.description or\"\"))..\")\"end}function r(u)return setmetatable({description=u},t)end;s={asyncDispose=r(\"Symbol.asyncDispose\"),dispose=r(\"Symbol.dispose\"),iterator=r(\"Symbol.iterator\"),hasInstance=r(\"Symbol.hasInstance\"),species=r(\"Symbol.species\"),toStringTag=r(\"Symbol.toStringTag\")}end;local function v(w)local x=0;return{[s.iterator]=function(self)return self end,next=function(self)local m={done=w[x+1]==nil,value={x,w[x+1]}}x=x+1;return m end}end;local function y(self,z,A)for o=1,#self do if not z(A,self[o],o-1,self)then return false end end;return true end;local function B(self,j,C,D)local E=C or 0;local F=D or#self;if E<0 then E=E+#self end;if F<0 then F=F+#self end;do local o=E;while o<F do self[o+1]=j;o=o+1 end end;return self end;local function G(self,z,A)local m={}local n=0;for o=1,#self do if z(A,self[o],o-1,self)then n=n+1;m[n]=self[o]end end;return m end;local function H(self,I,A)for o=1,#self do I(A,self[o],o-1,self)end end;local function J(self,K,A)for o=1,#self do local L=self[o]if K(A,L,o-1,self)then return L end end;return nil end;local function M(self,I,A)for o=1,#self do if I(A,self[o],o-1,self)then return o-1 end end;return-1 end;local N;do local function O(self)local P=self.____coroutine;local Q=table.pack(coroutine.resume(P))while true do if not Q[1]then error(Q[2],0)end;if coroutine.status(P)==\"dead\"then return end;if Q[2]==\"__TS__DelegatedYield\"then return true,Q[3]end;Q=table.pack(coroutine.resume(P,coroutine.yield(e(Q,2,Q.n))))end end;local function R(self)local m=self:next()if m.done then return end;return true,m.value end;local function S(self,T)T=T+1;if T>#self then return end;return T,string.sub(self,T,T)end;function N(U)if type(U)==\"string\"then return S,U,0 elseif U.____coroutine~=nil then return O,U elseif U[s.iterator]then local V=U[s.iterator](U)return R,V else return ipairs(U)end end end;local W;do local function X(self,T)T=T+1;if T>self.length then return end;return T,self[T]end;local function Y(Z)if type(Z.length)==\"number\"then return X,Z,0 end;return N(Z)end;function W(_,a0,A)local m={}if a0==nil then for a1,a2 in Y(_)do m[#m+1]=a2 end else local o=0;for a1,a2 in Y(_)do local a3=a0;local a4=A;local a5=a2;local a6=o;o=a6+1;m[#m+1]=a3(a4,a5,a6)end end;return m end end;local function a7(self,a8,a9)if a9==nil then a9=0 end;local n=#self;local aa=a9;if a9<0 then aa=n+a9 end;if aa<0 then aa=0 end;for o=aa+1,n do if self[o]==a8 then return true end end;return false end;local function ab(self,a8,a9)if a9==nil then a9=0 end;local n=#self;if n==0 then return-1 end;if a9>=n then return-1 end;if a9<0 then a9=n+a9;if a9<0 then a9=0 end end;for o=a9+1,n do if self[o]==a8 then return o-1 end end;return-1 end;local function ac(self,ad)if ad==nil then ad=\",\"end;local ae={}for o=1,#self do ae[o]=tostring(self[o])end;return table.concat(ae,ad)end;local function af(self,z,A)local m={}for o=1,#self do m[o]=z(A,self[o],o-1,self)end;return m end;local function ag(self,...)local l={...}local n=#self;for o=1,#l do n=n+1;self[n]=l[o]end;return n end;local function ah(self,l)local n=#self;for o=1,#l do n=n+1;self[n]=l[o]end;return n end;local function ai(...)return select(\"#\",...)end;local function aj(self,I,...)local n=#self;local aa=0;local ak=nil;if ai(...)~=0 then ak=...elseif n>0 then ak=self[1]aa=1 else error(\"Reduce of empty array with no initial value\",0)end;for o=aa+1,n do ak=I(nil,ak,self[o],o-1,self)end;return ak end;local function al(self,I,...)local n=#self;local aa=n-1;local ak=nil;if ai(...)~=0 then ak=...elseif n>0 then ak=self[aa+1]aa=aa-1 else error(\"Reduce of empty array with no initial value\",0)end;for o=aa+1,1,-1 do ak=I(nil,ak,self[o],o-1,self)end;return ak end;local function am(self)local o=1;local q=#self;while o<q do local an=self[q]self[q]=self[o]self[o]=an;o=o+1;q=q-1 end;return self end;local function ao(self,...)local l={...}local ap=#l;if ap==0 then return#self end;for o=#self,1,-1 do self[o+ap]=self[o]end;for o=1,ap do self[o]=l[o]end;return#self end;local function aq(self,ar)if ar~=nil then table.sort(self,function(as,at)return ar(nil,as,at)<0 end)else table.sort(self)end;return self end;local function au(self,av,aw)local n=#self;av=av or 0;if av<0 then av=n+av;if av<0 then av=0 end else if av>n then av=n end end;aw=aw or n;if aw<0 then aw=n+aw;if aw<0 then aw=0 end else if aw>n then aw=n end end;local ax={}av=av+1;aw=aw+1;local ay=1;while av<aw do ax[ay]=self[av]av=av+1;ay=ay+1 end;return ax end;local function az(self,z,A)for o=1,#self do if z(A,self[o],o-1,self)then return true end end;return false end;local function aA(self,...)local aB={...}local n=#self;local aC=ai(...)local C=aB[1]local aD=aB[2]if C<0 then C=n+C;if C<0 then C=0 end elseif C>n then C=n end;local aE=aC-2;if aE<0 then aE=0 end;local aF;if aC==0 then aF=0 elseif aC==1 then aF=n-C else aF=aD or 0;if aF<0 then aF=0 end;if aF>n-C then aF=n-C end end;local ax={}for aa=1,aF do local aG=C+aa;if self[aG]~=nil then ax[aa]=self[aG]end end;if aE<aF then for aa=C+1,n-aF do local aG=aa+aF;local aH=aa+aE;if self[aG]then self[aH]=self[aG]else self[aH]=nil end end;for aa=n-aF+aE+1,n do self[aa]=nil end elseif aE>aF then for aa=n-aF,C+1,-1 do local aG=aa+aF;local aH=aa+aE;if self[aG]then self[aH]=self[aG]else self[aH]=nil end end end;local q=C+1;for o=3,aC do self[q]=aB[o]q=q+1 end;for aa=#self,n-aF+aE+1,-1 do self[aa]=nil end;return ax end;local function aI(self)local aJ={}for o=1,#self do aJ[o-1]=self[o]end;return aJ end;local function aK(self,aL)if aL==nil then aL=1 end;local m={}local n=0;for o=1,#self do local j=self[o]if aL>0 and i(j)then local aM;if aL==1 then aM=j else aM=aK(j,aL-1)end;for q=1,#aM do local aN=aM[q]n=n+1;m[n]=aN end else n=n+1;m[n]=j end end;return m end;local function aO(self,aP,A)local m={}local n=0;for o=1,#self do local j=aP(A,self[o],o-1,self)if i(j)then for q=1,#j do n=n+1;m[n]=j[q]end else n=n+1;m[n]=j end end;return m end;local function aQ(self,aR)if aR<0 or aR~=aR or aR==math.huge or math.floor(aR)~=aR then error(\"invalid array length: \"..tostring(aR),0)end;for o=aR+1,#self do self[o]=nil end;return aR end;local function aS(self)local aT={e(self)}am(aT)return aT end;local function aU(self,ar)local aT={e(self)}aq(aT,ar)return aT end;local function aV(self,C,aD,...)local aT={e(self)}aA(aT,C,aD,...)return aT end;local function aW(self,T,j)local aT={e(self)}aT[T+1]=j;return aT end;local function aX(aY,...)local aZ=setmetatable({},aY.prototype)aZ:____constructor(...)return aZ end;local function a_(b0,b1)if type(b1)~=\"table\"then error(\"Right-hand side of 'instanceof' is not an object\",0)end;if b1[s.hasInstance]~=nil then return not not b1[s.hasInstance](b1,b0)end;if type(b0)==\"table\"then local b2=b0.constructor;while b2~=nil do if b2==b1 then return true end;b2=b2.____super end end;return false end;local function b3(self)local b4={prototype={}}b4.prototype.__index=b4.prototype;b4.prototype.constructor=b4;return b4 end;local b5;do local function b6()local b7;local b8;local function b9(a1,Q,ba)b7=Q;b8=ba end;return function()local bb=aX(b5,b9)return bb,b7,b8 end end;local bc=b6()local function bd(j)return a_(j,b5)end;local function be(self)end;local bf=_G.pcall;b5=b3()b5.name=\"__TS__Promise\"function b5.prototype.____constructor(self,b9)self.state=0;self.fulfilledCallbacks={}self.rejectedCallbacks={}self.finallyCallbacks={}local bg,bh=bf(b9,nil,function(a1,a2)return self:resolve(a2)end,function(a1,bi)return self:reject(bi)end)if not bg then self:reject(bh)end end;function b5.resolve(j)if a_(j,b5)then return j end;local bb=aX(b5,be)bb.state=1;bb.value=j;return bb end;function b5.reject(bj)local bb=aX(b5,be)bb.state=2;bb.rejectionReason=bj;return bb end;b5.prototype[\"then\"]=function(self,bk,bl)local bb,b7,b8=bc()self:addCallbacks(bk and self:createPromiseResolvingCallback(bk,b7,b8)or b7,bl and self:createPromiseResolvingCallback(bl,b7,b8)or b8)return bb end;function b5.prototype.addCallbacks(self,bm,bn)if self.state==1 then return bm(nil,self.value)end;if self.state==2 then return bn(nil,self.rejectionReason)end;local bo=self.fulfilledCallbacks;bo[#bo+1]=bm;local bp=self.rejectedCallbacks;bp[#bp+1]=bn end;function b5.prototype.catch(self,bl)return self[\"then\"](self,nil,bl)end;function b5.prototype.finally(self,bq)if bq then local br=self.finallyCallbacks;br[#br+1]=bq;if self.state~=0 then bq(nil)end end;return self end;function b5.prototype.resolve(self,j)if bd(j)then return j:addCallbacks(function(a1,a2)return self:resolve(a2)end,function(a1,bi)return self:reject(bi)end)end;if self.state==0 then self.state=1;self.value=j;return self:invokeCallbacks(self.fulfilledCallbacks,j)end end;function b5.prototype.reject(self,bj)if self.state==0 then self.state=2;self.rejectionReason=bj;return self:invokeCallbacks(self.rejectedCallbacks,bj)end end;function b5.prototype.invokeCallbacks(self,bs,j)local bt=#bs;local bu=self.finallyCallbacks;local bv=#bu;if bt~=0 then for o=1,bt-1 do bs[o](bs,j)end;if bv==0 then return bs[bt](bs,j)end;bs[bt](bs,j)end;if bv~=0 then for o=1,bv-1 do bu[o](bu)end;return bu[bv](bu)end end;function b5.prototype.createPromiseResolvingCallback(self,bw,b7,b8)return function(a1,j)local bg,bx=bf(bw,nil,j)if not bg then return b8(nil,bx)end;return self:handleCallbackValue(bx,b7,b8)end end;function b5.prototype.handleCallbackValue(self,j,b7,b8)if bd(j)then local by=j;if by.state==1 then return b7(nil,by.value)elseif by.state==2 then return b8(nil,by.rejectionReason)else return by:addCallbacks(b7,b8)end else return b7(nil,j)end end end;local bz,bA;do local bB=_G.coroutine or{}local bC=bB.create;local bD=bB.resume;local bE=bB.status;local bF=bB.yield;function bz(bG)return aX(b5,function(a1,b7,b8)local bH,bI,bJ,bK;function bH(self,j)local Q=table.pack(bD(bK,j))while true do if not Q[1]then return b8(nil,Q[2])elseif Q[1]and Q[2]==\"__TS__Await\"then return bI(Q[3])elseif bE(bK)==\"dead\"then return bI(Q[2])end;Q=table.pack(bD(bK,bF(e(Q,2,Q.n))))end end;function bI(m)if bJ then return end;if bE(bK)==\"dead\"then return b7(nil,m)end;return b5.resolve(m):addCallbacks(bH,b8)end;bJ=false;bK=bC(bG)local Q=table.pack(bD(bK,function(a1,a2)bJ=true;return b5.resolve(a2):addCallbacks(b7,b8)end))while true do if not Q[1]then return b8(nil,Q[2])elseif Q[1]and Q[2]==\"__TS__Await\"then return bI(Q[3])elseif bE(bK)==\"dead\"then return bI(Q[2])end;Q=table.pack(bD(bK,bF(e(Q,2,Q.n))))end end)end;function bA(bL)return bF(\"__TS__Await\",bL)end end;local function bM(aY,bN)aY.____super=bN;local bO=setmetatable({__index=bN},bN)setmetatable(aY,bO)local bP=getmetatable(bN)if bP then if type(bP.__index)==\"function\"then bO.__index=bP.__index end;if type(bP.__newindex)==\"function\"then bO.__newindex=bP.__newindex end end;setmetatable(aY.prototype,bN.prototype)if type(bN.prototype.__index)==\"function\"then aY.prototype.__index=bN.prototype.__index end;if type(bN.prototype.__newindex)==\"function\"then aY.prototype.__newindex=bN.prototype.__newindex end;if type(bN.prototype.__tostring)==\"function\"then aY.prototype.__tostring=bN.prototype.__tostring end end;local function bQ(bR)local j;local bS;local bT;local bU;local bV;local bW;bW=bR.enumerable;bV=bR.configurable;bU=bR.get;bT=bR.set;bS=bR.writable;j=bR.value;local bX={enumerable=bW==true,configurable=bV==true}local bY=bU~=nil or bT~=nil;local bZ=bS~=nil or j~=nil;if bY and bZ then error(\"Invalid property descriptor. Cannot both specify accessors and a value or writable attribute.\",0)end;if bU or bT then bX.get=bU;bX.set=bT else bX.value=j;bX.writable=bS==true end;return bX end;local function b_(self,c0,c1,c2)local m=c0;do local o=#c1;while o>=0 do local c3=c1[o+1]if c3~=nil then local c4=c3(self,m,c2)if c4==nil then c4=m end;m=c4 end;o=o-1 end end;return m end;local function c5(aY,...)local c6={...}for o=1,#c6 do local c7=c6[o]for x in pairs(c7)do aY[x]=c7[x]end end;return aY end;local function c8(aJ,x)local c9=getmetatable(aJ)if not c9 then return end;if not rawget(c9,\"_descriptors\")then return end;return rawget(c9,\"_descriptors\")[x]end;local ca;do local getmetatable=_G.getmetatable;local cb=_G.rawget;function ca(self,c9,x)while c9 do local cc=cb(c9,x)if cc~=nil then return cc end;local cd=cb(c9,\"_descriptors\")if cd then local bX=cd[x]if bX~=nil then if bX.get then return bX.get(self)end;return bX.value end end;c9=getmetatable(c9)end end end;local ce;do local getmetatable=_G.getmetatable;local cb=_G.rawget;local rawset=_G.rawset;function ce(self,c9,x,j)while c9 do local cd=cb(c9,\"_descriptors\")if cd then local bX=cd[x]if bX~=nil then if bX.set then bX.set(self,j)else if bX.writable==false then error((((\"Cannot assign to read only property '\"..x)..\"' of object '\")..tostring(self))..\"'\",0)end;bX.value=j end;return end end;c9=getmetatable(c9)end;rawset(self,x,j)end end;local cf;do local getmetatable=_G.getmetatable;local function cg(self,x)return ca(self,getmetatable(self),x)end;local function ch(self,x,j)return ce(self,getmetatable(self),x,j)end;function cf(aY,x,ci,cj)if cj==nil then cj=false end;local ck;if cj then ck=aY else ck=getmetatable(aY)end;local c9=ck;if not c9 then c9={}setmetatable(aY,c9)end;local j=rawget(aY,x)if j~=nil then rawset(aY,x,nil)end;if not rawget(c9,\"_descriptors\")then c9._descriptors={}end;c9._descriptors[x]=bQ(ci)c9.__index=cg;c9.__newindex=ch end end;local function cl(c1,aY,x,ci)local m=aY;do local o=#c1;while o>=0 do local c3=c1[o+1]if c3~=nil then local cm=m;if x==nil then m=c3(nil,m)elseif ci==true then local j=rawget(aY,x)local bX=c8(aY,x)or{configurable=true,writable=true,value=j}local ci=c3(nil,aY,x,bX)or bX;local cn=ci.configurable==true and ci.writable==true and not ci.get and not ci.set;if cn then rawset(aY,x,ci.value)else cf(aY,x,c5({},bX,ci))end elseif ci==false then m=c3(nil,aY,x,ci)else m=c3(nil,aY,x)end;m=m or cm end;o=o-1 end end;return m end;local function co(cp,c3)return function(a1,aY,x)return c3(nil,aY,x,cp)end end;local function cq(self,cr,cs)if not cs then cs=1 else cs=cs+1 end;local T=string.find(self,cr,cs,true)return T~=nil end;local ct,cu,cv,cw,cx,cy;do local function cz(self,cA)if debug==nil then return nil end;local cB=1;while true do local cC=debug.getinfo(cB,\"f\")cB=cB+1;if not cC then cB=1;break elseif cC.func==cA then break end end;if cq(_VERSION,\"Lua 5.0\")then return debug.traceback((\"[Level \"..tostring(cB))..\"]\")else return debug.traceback(nil,cB)end end;local function cD(self,cE)return function(self)local u=cE(self)local cF=debug.getinfo(3,\"f\")local cG=cq(_VERSION,\"Lua 5.0\")or _VERSION==\"Lua 5.1\"if cG or cF and cF.func~=error then return u else return(u..\"\\n\")..tostring(self.stack)end end end;local function cH(self,cI,cJ)cI.name=cJ;return setmetatable(cI,{__call=function(a1,cK,cL)return aX(cI,cL)end})end;local cM=cH;local cN=b3()cN.name=\"\"function cN.prototype.____constructor(self,cL)if cL==nil then cL=\"\"end;self.message=cL;self.name=\"Error\"self.stack=cz(nil,self.constructor.new)local c9=getmetatable(self)if c9 and not c9.__errorToStringPatched then c9.__errorToStringPatched=true;c9.__tostring=cD(nil,c9.__tostring)end end;function cN.prototype.__tostring(self)return self.message~=\"\"and(self.name..\": \")..self.message or self.name end;ct=cM(nil,cN,\"Error\")local function cO(self,cJ)local cP=cH;local cQ=b3()cQ.name=cQ.name;bM(cQ,ct)function cQ.prototype.____constructor(self,...)cQ.____super.prototype.____constructor(self,...)self.name=cJ end;return cP(nil,cQ,cJ)end;cu=cO(nil,\"RangeError\")cv=cO(nil,\"ReferenceError\")cw=cO(nil,\"SyntaxError\")cx=cO(nil,\"TypeError\")cy=cO(nil,\"URIError\")end;local function cR(aJ)local c9=getmetatable(aJ)if not c9 then return{}end;return rawget(c9,\"_descriptors\")or{}end;local function cS(aY,x)local cd=cR(aY)local bX=cd[x]if bX then if not bX.configurable then error(aX(cx,(((\"Cannot delete property \"..tostring(x))..\" of \")..tostring(aY))..\".\"),0)end;cd[x]=nil;return true end;aY[x]=nil;return true end;local function cT(self,T)if T>=0 and T<#self then return string.sub(self,T+1,T+1)end end;local function cU(U)if type(U)==\"string\"then for T=0,#U-1 do coroutine.yield(\"__TS__DelegatedYield\",cT(U,T))end elseif U.____coroutine~=nil then local P=U.____coroutine;local Q=table.pack(coroutine.resume(P))while true do if not Q[1]then error(Q[2],0)end;if coroutine.status(P)==\"dead\"then return Q[2]else Q=table.pack(coroutine.resume(P,coroutine.yield(e(Q,2,Q.n))))end end elseif U[s.iterator]then local V=U[s.iterator](U)while true do local m=V:next()if m.done then return m.value else coroutine.yield(\"__TS__DelegatedYield\",m.value)end end else for a1,j in ipairs(U)do coroutine.yield(\"__TS__DelegatedYield\",j)end end end;local function cV(cW,...)local cX={...}return function(a1,...)local aB={...}ao(aB,e(cX))return cW(e(aB))end end;local cY;do local function cZ(self)return self end;local function c_(self,...)local P=self.____coroutine;if coroutine.status(P)==\"dead\"then return{done=true}end;local Q=table.pack(coroutine.resume(P,...))while true do if not Q[1]then error(Q[2],0)end;if Q[2]==\"__TS__DelegatedYield\"then return{value=Q[3],done=false}elseif coroutine.status(P)==\"dead\"then return{value=Q[2],done=true}end;Q=table.pack(coroutine.resume(P,coroutine.yield(e(Q,2,Q.n))))end end;function cY(cW)return function(...)local aB={...}local d0=ai(...)return{____coroutine=coroutine.create(function()return cW(e(aB,1,d0))end),[s.iterator]=cZ,next=c_}end end end;local function d1(j)local d2=type(j)return d2==\"table\"or d2==\"function\"end;local function d3(self,d4,d5)local d6={}local x,j=self(d4,d5)while x do d6[#d6+1]={x,j}x,j=self(d4,x)end;return e(d6)end;local d7;do d7=b3()d7.name=\"Map\"function d7.prototype.____constructor(self,d8)self[s.toStringTag]=\"Map\"self.items={}self.size=0;self.nextKey={}self.previousKey={}if d8==nil then return end;local U=d8;if U[s.iterator]then local V=U[s.iterator](U)while true do local m=V:next()if m.done then break end;local j=m.value;self:set(j[1],j[2])end else local w=d8;for a1,d9 in ipairs(w)do self:set(d9[1],d9[2])end end end;function d7.prototype.clear(self)self.items={}self.nextKey={}self.previousKey={}self.firstKey=nil;self.lastKey=nil;self.size=0 end;function d7.prototype.delete(self,x)local da=self:has(x)if da then self.size=self.size-1;local next=self.nextKey[x]local db=self.previousKey[x]if next~=nil and db~=nil then self.nextKey[db]=next;self.previousKey[next]=db elseif next~=nil then self.firstKey=next;self.previousKey[next]=nil elseif db~=nil then self.lastKey=db;self.nextKey[db]=nil else self.firstKey=nil;self.lastKey=nil end;self.nextKey[x]=nil;self.previousKey[x]=nil end;self.items[x]=nil;return da end;function d7.prototype.forEach(self,aP)for a1,x in N(self:keys())do aP(nil,self.items[x],x,self)end end;function d7.prototype.get(self,x)return self.items[x]end;function d7.prototype.has(self,x)return self.nextKey[x]~=nil or self.lastKey==x end;function d7.prototype.set(self,x,j)local dc=not self:has(x)if dc then self.size=self.size+1 end;self.items[x]=j;if self.firstKey==nil then self.firstKey=x;self.lastKey=x elseif dc then self.nextKey[self.lastKey]=x;self.previousKey[x]=self.lastKey;self.lastKey=x end;return self end;d7.prototype[s.iterator]=function(self)return self:entries()end;function d7.prototype.entries(self)local l=self.items;local dd=self.nextKey;local x=self.firstKey;return{[s.iterator]=function(self)return self end,next=function(self)local m={done=not x,value={x,l[x]}}x=dd[x]return m end}end;function d7.prototype.keys(self)local dd=self.nextKey;local x=self.firstKey;return{[s.iterator]=function(self)return self end,next=function(self)local m={done=not x,value=x}x=dd[x]return m end}end;function d7.prototype.values(self)local l=self.items;local dd=self.nextKey;local x=self.firstKey;return{[s.iterator]=function(self)return self end,next=function(self)local m={done=not x,value=l[x]}x=dd[x]return m end}end;d7[s.species]=d7 end;local function de(l,df)local m=aX(d7)local o=0;for a1,p in N(l)do local x=df(nil,p,o)if m:has(x)then local dg=m:get(x)dg[#dg+1]=p else m:set(x,{p})end;o=o+1 end;return m end;local dh=string.match;local di=math.atan2 or math.atan;local dj=math.modf;local function dk(j)return j~=j end;local function dl(aN)if dk(aN)or aN==0 then return aN end;if aN<0 then return-1 end;return 1 end;local function dm(j)return type(j)==\"number\"and j==j and j~=math.huge and j~=-math.huge end;local function dn(aN)if not dm(aN)or aN==0 then return aN end;return aN>0 and math.floor(aN)or math.ceil(aN)end;local function dp(j)local d2=type(j)if d2==\"number\"then return j elseif d2==\"string\"then local dq=tonumber(j)if dq then return dq end;if j==\"Infinity\"then return math.huge end;if j==\"-Infinity\"then return-math.huge end;local dr=string.gsub(j,\"%s\",\"\")if dr==\"\"then return 0 end;return 0/0 elseif d2==\"boolean\"then return j and 1 or 0 else return 0/0 end end;local function ds(j)return dm(j)and math.floor(j)==j end;local function dt(self,C,D)if D~=D then D=0 end;if D~=nil and C>D then C,D=D,C end;if C>=0 then C=C+1 else C=1 end;if D~=nil and D<0 then D=0 end;return string.sub(self,C,D)end;local du;do local dv=\"0123456789aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTvVwWxXyYzZ\"function du(dw,bN)if bN==nil then bN=10;local dx=dh(dw,\"^%s*-?0[xX]\")if dx~=nil then bN=16;dw=dh(dx,\"-\")and\"-\"..dt(dw,#dx)or dt(dw,#dx)end end;if bN<2 or bN>36 then return 0/0 end;local dy=bN<=10 and dt(dv,0,bN)or dt(dv,0,10+2*(bN-10))local dz=(\"^%s*(-?[\"..dy)..\"]*)\"local dA=tonumber(dh(dw,dz),bN)if dA==nil then return 0/0 end;if dA>=0 then return math.floor(dA)else return math.ceil(dA)end end end;local function dB(dw)local dC=dh(dw,\"^%s*(-?Infinity)\")if dC~=nil then return cT(dC,0)==\"-\"and-math.huge or math.huge end;local dA=tonumber(dh(dw,\"^%s*(-?%d+%.?%d*)\"))return dA or 0/0 end;local dD;do local dE=\"0123456789abcdefghijklmnopqrstuvwxyz\"function dD(self,dF)if dF==nil or dF==10 or self==math.huge or self==-math.huge or self~=self then return tostring(self)end;dF=math.floor(dF)if dF<2 or dF>36 then error(\"toString() radix argument must be between 2 and 36\",0)end;local dG,dH=dj(math.abs(self))local m=\"\"if dF==8 then m=string.format(\"%o\",dG)elseif dF==16 then m=string.format(\"%x\",dG)else repeat do m=cT(dE,dG%dF)..m;dG=math.floor(dG/dF)end until not(dG~=0)end;if dH~=0 then m=m..\".\"local dI=1e-16;repeat do dH=dH*dF;dI=dI*dF;local dJ=math.floor(dH)m=m..cT(dE,dJ)dH=dH-dJ end until not(dH>=dI)end;if self<0 then m=\"-\"..m end;return m end end;local function dK(self,dL)if math.abs(self)>=1e+21 or self~=self then return tostring(self)end;local bw=math.floor(dL or 0)if bw<0 or bw>99 then error(\"toFixed() digits argument must be between 0 and 99\",0)end;return string.format((\"%.\"..tostring(bw))..\"f\",self)end;local function dM(aY,x,ci)local dN=type(x)==\"number\"and x+1 or x;local j=rawget(aY,dN)local bY=ci.get~=nil or ci.set~=nil;local bX;if bY then if j~=nil then error(\"Cannot redefine property: \"..tostring(x),0)end;bX=ci else local dO=j~=nil;local dP=ci.set;local dQ=ci.get;local dR=ci.configurable;if dR==nil then dR=dO end;local dS=ci.enumerable;if dS==nil then dS=dO end;local dT=ci.writable;if dT==nil then dT=dO end;local dU;if ci.value~=nil then dU=ci.value else dU=j end;bX={set=dP,get=dQ,configurable=dR,enumerable=dS,writable=dT,value=dU}end;cf(aY,dN,bX)return aY end;local function dV(b0)local m={}local n=0;for x in pairs(b0)do n=n+1;m[n]={x,b0[x]}end;return m end;local function dW(d8)local b0={}local U=d8;if U[s.iterator]then local V=U[s.iterator](U)while true do local m=V:next()if m.done then break end;local j=m.value;b0[j[1]]=j[2]end else for a1,dX in ipairs(d8)do b0[dX[1]]=dX[2]end end;return b0 end;local function dY(l,df)local m={}local o=0;for a1,p in N(l)do local x=df(nil,p,o)if m[x]~=nil then local dZ=m[x]dZ[#dZ+1]=p else m[x]={p}end;o=o+1 end;return m end;local function d_(b0)local m={}local n=0;for x in pairs(b0)do n=n+1;m[n]=x end;return m end;local function e0(aY,e1)local m={}for e2 in pairs(aY)do if not e1[e2]then m[e2]=aY[e2]end end;return m end;local function e3(b0)local m={}local n=0;for x in pairs(b0)do n=n+1;m[n]=b0[x]end;return m end;local function e4(U)local d6={}local e5={}local e6=0;local o=0;for a1,p in N(U)do if a_(p,b5)then if p.state==1 then d6[o+1]=p.value elseif p.state==2 then return b5.reject(p.rejectionReason)else e6=e6+1;e5[o]=p end else d6[o+1]=p end;o=o+1 end;if e6==0 then return b5.resolve(d6)end;return aX(b5,function(a1,b7,b8)for T,bb in pairs(e5)do bb[\"then\"](bb,function(a1,e7)d6[T+1]=e7;e6=e6-1;if e6==0 then b7(nil,d6)end end,function(a1,bj)b8(nil,bj)end)end end)end;local function e8(U)local d6={}local e5={}local e6=0;local o=0;for a1,p in N(U)do if a_(p,b5)then if p.state==1 then d6[o+1]={status=\"fulfilled\",value=p.value}elseif p.state==2 then d6[o+1]={status=\"rejected\",reason=p.rejectionReason}else e6=e6+1;e5[o]=p end else d6[o+1]={status=\"fulfilled\",value=p}end;o=o+1 end;if e6==0 then return b5.resolve(d6)end;return aX(b5,function(a1,b7)for T,bb in pairs(e5)do bb[\"then\"](bb,function(a1,e7)d6[T+1]={status=\"fulfilled\",value=e7}e6=e6-1;if e6==0 then b7(nil,d6)end end,function(a1,bj)d6[T+1]={status=\"rejected\",reason=bj}e6=e6-1;if e6==0 then b7(nil,d6)end end)end end)end;local function e9(U)local ea={}local eb={}for a1,p in N(U)do if a_(p,b5)then if p.state==1 then return b5.resolve(p.value)elseif p.state==2 then ea[#ea+1]=p.rejectionReason else eb[#eb+1]=p end else return b5.resolve(p)end end;if#eb==0 then return b5.reject(\"No promises to resolve with .any()\")end;local ec=0;return aX(b5,function(a1,b7,b8)for a1,bb in ipairs(eb)do bb[\"then\"](bb,function(a1,e7)b7(nil,e7)end,function(a1,bj)ea[#ea+1]=bj;ec=ec+1;if ec==#eb then b8(nil,{name=\"AggregateError\",message=\"All Promises rejected\",errors=ea})end end)end end)end;local function ed(U)local eb={}for a1,p in N(U)do if a_(p,b5)then if p.state==1 then return b5.resolve(p.value)elseif p.state==2 then return b5.reject(p.rejectionReason)else eb[#eb+1]=p end else return b5.resolve(p)end end;return aX(b5,function(a1,b7,b8)for a1,bb in ipairs(eb)do bb[\"then\"](bb,function(a1,j)return b7(nil,j)end,function(a1,bj)return b8(nil,bj)end)end end)end;local ee;do ee=b3()ee.name=\"Set\"function ee.prototype.____constructor(self,ef)self[s.toStringTag]=\"Set\"self.size=0;self.nextKey={}self.previousKey={}if ef==nil then return end;local U=ef;if U[s.iterator]then local V=U[s.iterator](U)while true do local m=V:next()if m.done then break end;self:add(m.value)end else local w=ef;for a1,j in ipairs(w)do self:add(j)end end end;function ee.prototype.add(self,j)local dc=not self:has(j)if dc then self.size=self.size+1 end;if self.firstKey==nil then self.firstKey=j;self.lastKey=j elseif dc then self.nextKey[self.lastKey]=j;self.previousKey[j]=self.lastKey;self.lastKey=j end;return self end;function ee.prototype.clear(self)self.nextKey={}self.previousKey={}self.firstKey=nil;self.lastKey=nil;self.size=0 end;function ee.prototype.delete(self,j)local da=self:has(j)if da then self.size=self.size-1;local next=self.nextKey[j]local db=self.previousKey[j]if next~=nil and db~=nil then self.nextKey[db]=next;self.previousKey[next]=db elseif next~=nil then self.firstKey=next;self.previousKey[next]=nil elseif db~=nil then self.lastKey=db;self.nextKey[db]=nil else self.firstKey=nil;self.lastKey=nil end;self.nextKey[j]=nil;self.previousKey[j]=nil end;return da end;function ee.prototype.forEach(self,aP)for a1,x in N(self:keys())do aP(nil,x,x,self)end end;function ee.prototype.has(self,j)return self.nextKey[j]~=nil or self.lastKey==j end;ee.prototype[s.iterator]=function(self)return self:values()end;function ee.prototype.entries(self)local dd=self.nextKey;local x=self.firstKey;return{[s.iterator]=function(self)return self end,next=function(self)local m={done=not x,value={x,x}}x=dd[x]return m end}end;function ee.prototype.keys(self)local dd=self.nextKey;local x=self.firstKey;return{[s.iterator]=function(self)return self end,next=function(self)local m={done=not x,value=x}x=dd[x]return m end}end;function ee.prototype.values(self)local dd=self.nextKey;local x=self.firstKey;return{[s.iterator]=function(self)return self end,next=function(self)local m={done=not x,value=x}x=dd[x]return m end}end;function ee.prototype.union(self,eg)local m=aX(ee,self)for a1,p in N(eg)do m:add(p)end;return m end;function ee.prototype.intersection(self,eg)local m=aX(ee)for a1,p in N(self)do if eg:has(p)then m:add(p)end end;return m end;function ee.prototype.difference(self,eg)local m=aX(ee,self)for a1,p in N(eg)do m:delete(p)end;return m end;function ee.prototype.symmetricDifference(self,eg)local m=aX(ee,self)for a1,p in N(eg)do if self:has(p)then m:delete(p)else m:add(p)end end;return m end;function ee.prototype.isSubsetOf(self,eg)for a1,p in N(self)do if not eg:has(p)then return false end end;return true end;function ee.prototype.isSupersetOf(self,eg)for a1,p in N(eg)do if not self:has(p)then return false end end;return true end;function ee.prototype.isDisjointFrom(self,eg)for a1,p in N(self)do if eg:has(p)then return false end end;return true end;ee[s.species]=ee end;local function eh(...)local ei={...}ei.sparseLength=ai(...)return ei end;local function ej(ei,...)local aB={...}local ek=ai(...)local el=ei.sparseLength;for o=1,ek do ei[el+o]=aB[o]end;ei.sparseLength=el+ek end;local function em(ei)local en=unpack or table.unpack;return en(ei,1,ei.sparseLength)end;local eo;do eo=b3()eo.name=\"WeakMap\"function eo.prototype.____constructor(self,d8)self[s.toStringTag]=\"WeakMap\"self.items={}setmetatable(self.items,{__mode=\"k\"})if d8==nil then return end;local U=d8;if U[s.iterator]then local V=U[s.iterator](U)while true do local m=V:next()if m.done then break end;local j=m.value;self.items[j[1]]=j[2]end else for a1,d9 in ipairs(d8)do self.items[d9[1]]=d9[2]end end end;function eo.prototype.delete(self,x)local da=self:has(x)self.items[x]=nil;return da end;function eo.prototype.get(self,x)return self.items[x]end;function eo.prototype.has(self,x)return self.items[x]~=nil end;function eo.prototype.set(self,x,j)self.items[x]=j;return self end;eo[s.species]=eo end;local ep;do ep=b3()ep.name=\"WeakSet\"function ep.prototype.____constructor(self,ef)self[s.toStringTag]=\"WeakSet\"self.items={}setmetatable(self.items,{__mode=\"k\"})if ef==nil then return end;local U=ef;if U[s.iterator]then local V=U[s.iterator](U)while true do local m=V:next()if m.done then break end;self.items[m.value]=true end else for a1,j in ipairs(ef)do self.items[j]=true end end end;function ep.prototype.add(self,j)self.items[j]=true;return self end;function ep.prototype.delete(self,j)local da=self:has(j)self.items[j]=nil;return da end;function ep.prototype.has(self,j)return self.items[j]==true end;ep[s.species]=ep end;local function eq(er,es)_G.__TS__sourcemap=_G.__TS__sourcemap or{}_G.__TS__sourcemap[er]=es;if _G.__TS__originalTraceback==nil then local et=debug.traceback;_G.__TS__originalTraceback=et;debug.traceback=function(eu,cL,cB)local ev;if eu==nil and cL==nil and cB==nil then ev=et()elseif cq(_VERSION,\"Lua 5.0\")then ev=et(((\"[Level \"..tostring(cB))..\"] \")..tostring(cL))else ev=et(eu,cL,cB)end;if type(ev)~=\"string\"then return ev end;local function ew(a1,ex,ey,ez)local eA=_G.__TS__sourcemap[ex]if eA~=nil and eA[ez]~=nil then local e7=eA[ez]if type(e7)==\"number\"then return(ey..\":\")..tostring(e7)end;return(e7.file..\":\")..tostring(e7.line)end;return(ex..\":\")..ez end;local m=string.gsub(ev,\"(%S+)%.lua:(%d+)\",function(ex,ez)return ew(nil,ex..\".lua\",ex..\".ts\",ez)end)local function eB(a1,ex,ez)local eA=_G.__TS__sourcemap[ex]if eA~=nil and eA[ez]~=nil then local eC=dh(ex,\"%[string \\\"([^\\\"]+)\\\"%]\")local eD=string.gsub(eC,\".lua$\",\".ts\")local e7=eA[ez]if type(e7)==\"number\"then return(eD..\":\")..tostring(e7)end;return(e7.file..\":\")..tostring(e7.line)end;return(ex..\":\")..ez end;m=string.gsub(m,\"(%[string \\\"[^\\\"]+\\\"%]):(%d+)\",function(ex,ez)return eB(nil,ex,ez)end)return m end end end;local function eE(U)local Z={}if type(U)==\"string\"then for o=0,#U-1 do Z[o+1]=cT(U,o)end else local n=0;for a1,p in N(U)do n=n+1;Z[n]=p end end;return e(Z)end;local function eF(self,eG)if eG~=eG then eG=0 end;if eG<0 then return\"\"end;return string.sub(self,eG+1,eG+1)end;local function eH(self,T)if T~=T then T=0 end;if T<0 then return 0/0 end;return string.byte(self,T+1)or 0/0 end;local function eI(self,cr,eJ)if eJ==nil or eJ>#self then eJ=#self end;return string.sub(self,eJ-#cr+1,eJ)==cr end;local function eK(self,eL,eM)if eM==nil then eM=\" \"end;if eL~=eL then eL=0 end;if eL==-math.huge or eL==math.huge then error(\"Invalid string length\",0)end;if#self>=eL or#eM==0 then return self end;eL=eL-#self;if eL>#eM then eM=eM..string.rep(eM,math.floor(eL/#eM))end;return self..string.sub(eM,1,math.floor(eL))end;local function eN(self,eL,eM)if eM==nil then eM=\" \"end;if eL~=eL then eL=0 end;if eL==-math.huge or eL==math.huge then error(\"Invalid string length\",0)end;if#self>=eL or#eM==0 then return self end;eL=eL-#self;if eL>#eM then eM=eM..string.rep(eM,math.floor(eL/#eM))end;return string.sub(eM,1,math.floor(eL))..self end;local eO;do local eP=string.sub;function eO(c7,eQ,eR)local eS,eT=string.find(c7,eQ,nil,true)if not eS then return c7 end;local eU=eP(c7,1,eS-1)local eV=type(eR)==\"string\"and eR or eR(nil,eQ,eS-1,c7)local eW=eP(c7,eT+1)return(eU..eV)..eW end end;local eX;do local eP=string.sub;local eY=string.find;function eX(c7,ad,eZ)if eZ==nil then eZ=4294967295 end;if eZ==0 then return{}end;local m={}local e_=1;if ad==nil or ad==\"\"then for o=1,#c7 do m[e_]=eP(c7,o,o)e_=e_+1 end else local f0=1;while e_<=eZ do local eS,eT=eY(c7,ad,f0,true)if not eS then break end;m[e_]=eP(c7,f0,eS-1)e_=e_+1;f0=eT+1 end;if e_<=eZ then m[e_]=eP(c7,f0)end end;return m end end;local f1;do local eP=string.sub;local eY=string.find;function f1(c7,eQ,eR)if type(eR)==\"string\"then local f2=table.concat(eX(c7,eQ),eR)if#eQ==0 then return(eR..f2)..eR end;return f2 end;local ae={}local f3=1;if#eQ==0 then ae[1]=eR(nil,\"\",0,c7)f3=2;for o=1,#c7 do ae[f3]=eP(c7,o,o)ae[f3+1]=eR(nil,\"\",o,c7)f3=f3+2 end else local f0=1;while true do local eS,eT=eY(c7,eQ,f0,true)if not eS then break end;ae[f3]=eP(c7,f0,eS-1)ae[f3+1]=eR(nil,eQ,eS-1,c7)f3=f3+2;f0=eT+1 end;ae[f3]=eP(c7,f0)end;return table.concat(ae)end end;local function f4(self,C,D)if C==nil or C~=C then C=0 end;if D~=D then D=0 end;if C>=0 then C=C+1 end;if D~=nil and D<0 then D=D-1 end;return string.sub(self,C,D)end;local function f5(self,cr,cs)if cs==nil or cs<0 then cs=0 end;return string.sub(self,cs+1,#cr+cs)==cr end;local function f6(self,aG,aR)if aG~=aG then aG=0 end;if aR~=nil then if aR~=aR or aR<=0 then return\"\"end;aR=aR+aG end;if aG>=0 then aG=aG+1 end;return string.sub(self,aG,aR)end;local function f7(self)local m=string.gsub(self,\"^[%s\194\160\239\187\191]*(.-)[%s\194\160\239\187\191]*$\",\"%1\")return m end;local function f8(self)local m=string.gsub(self,\"[%s\194\160\239\187\191]*$\",\"\")return m end;local function f9(self)local m=string.gsub(self,\"^[%s\194\160\239\187\191]*\",\"\")return m end;local fa,fb;do local fc={}function fa(x)if not fc[x]then fc[x]=r(x)end;return fc[x]end;function fb(fd)for x in pairs(fc)do if fc[x]==fd then return x end end;return nil end end;local function fe(j)local ff=type(j)if ff==\"table\"then return\"object\"elseif ff==\"nil\"then return\"undefined\"else return ff end end;local function fg(self,fh,...)local aB={...}local fi;local fj,m=xpcall(function()return fh(e(aB))end,function(bi)fi=bi;return fi end)local fk={e(aB)}do local o=#fk-1;while o>=0 do local fl=fk[o+1]fl[s.dispose](fl)o=o-1 end end;if not fj then error(fi,0)end;return m end;local function fm(self,fh,...)local aB={...}return bz(function(fn)local fi;local fj,m=xpcall(function()return fh(nil,e(aB))end,function(bi)fi=bi;return fi end)local fk={e(aB)}do local o=#fk-1;while o>=0 do if fk[o+1][s.dispose]~=nil then local fl=fk[o+1]fl[s.dispose](fl)end;if fk[o+1][s.asyncDispose]~=nil then local fo=fk[o+1]bA(fo[s.asyncDispose](fo))end;o=o-1 end end;if not fj then error(fi,0)end;return fn(nil,m)end)end;return{__TS__ArrayAt=f,__TS__ArrayConcat=k,__TS__ArrayEntries=v,__TS__ArrayEvery=y,__TS__ArrayFill=B,__TS__ArrayFilter=G,__TS__ArrayForEach=H,__TS__ArrayFind=J,__TS__ArrayFindIndex=M,__TS__ArrayFrom=W,__TS__ArrayIncludes=a7,__TS__ArrayIndexOf=ab,__TS__ArrayIsArray=i,__TS__ArrayJoin=ac,__TS__ArrayMap=af,__TS__ArrayPush=ag,__TS__ArrayPushArray=ah,__TS__ArrayReduce=aj,__TS__ArrayReduceRight=al,__TS__ArrayReverse=am,__TS__ArrayUnshift=ao,__TS__ArraySort=aq,__TS__ArraySlice=au,__TS__ArraySome=az,__TS__ArraySplice=aA,__TS__ArrayToObject=aI,__TS__ArrayFlat=aK,__TS__ArrayFlatMap=aO,__TS__ArraySetLength=aQ,__TS__ArrayToReversed=aS,__TS__ArrayToSorted=aU,__TS__ArrayToSpliced=aV,__TS__ArrayWith=aW,__TS__AsyncAwaiter=bz,__TS__Await=bA,__TS__Class=b3,__TS__ClassExtends=bM,__TS__CloneDescriptor=bQ,__TS__CountVarargs=ai,__TS__Decorate=b_,__TS__DecorateLegacy=cl,__TS__DecorateParam=co,__TS__Delete=cS,__TS__DelegatedYield=cU,__TS__DescriptorGet=ca,__TS__DescriptorSet=ce,Error=ct,RangeError=cu,ReferenceError=cv,SyntaxError=cw,TypeError=cx,URIError=cy,__TS__FunctionBind=cV,__TS__Generator=cY,__TS__InstanceOf=a_,__TS__InstanceOfObject=d1,__TS__Iterator=N,__TS__LuaIteratorSpread=d3,Map=d7,__TS__MapGroupBy=de,__TS__Match=dh,__TS__MathAtan2=di,__TS__MathModf=dj,__TS__MathSign=dl,__TS__MathTrunc=dn,__TS__New=aX,__TS__Number=dp,__TS__NumberIsFinite=dm,__TS__NumberIsInteger=ds,__TS__NumberIsNaN=dk,__TS__ParseInt=du,__TS__ParseFloat=dB,__TS__NumberToString=dD,__TS__NumberToFixed=dK,__TS__ObjectAssign=c5,__TS__ObjectDefineProperty=dM,__TS__ObjectEntries=dV,__TS__ObjectFromEntries=dW,__TS__ObjectGetOwnPropertyDescriptor=c8,__TS__ObjectGetOwnPropertyDescriptors=cR,__TS__ObjectGroupBy=dY,__TS__ObjectKeys=d_,__TS__ObjectRest=e0,__TS__ObjectValues=e3,__TS__ParseFloat=dB,__TS__ParseInt=du,__TS__Promise=b5,__TS__PromiseAll=e4,__TS__PromiseAllSettled=e8,__TS__PromiseAny=e9,__TS__PromiseRace=ed,Set=ee,__TS__SetDescriptor=cf,__TS__SparseArrayNew=eh,__TS__SparseArrayPush=ej,__TS__SparseArraySpread=em,WeakMap=eo,WeakSet=ep,__TS__SourceMapTraceBack=eq,__TS__Spread=eE,__TS__StringAccess=cT,__TS__StringCharAt=eF,__TS__StringCharCodeAt=eH,__TS__StringEndsWith=eI,__TS__StringIncludes=cq,__TS__StringPadEnd=eK,__TS__StringPadStart=eN,__TS__StringReplace=eO,__TS__StringReplaceAll=f1,__TS__StringSlice=f4,__TS__StringSplit=eX,__TS__StringStartsWith=f5,__TS__StringSubstr=f6,__TS__StringSubstring=dt,__TS__StringTrim=f7,__TS__StringTrimEnd=f8,__TS__StringTrimStart=f9,__TS__Symbol=r,Symbol=s,__TS__SymbolRegistryFor=fa,__TS__SymbolRegistryKeyFor=fb,__TS__TypeOf=fe,__TS__Unpack=e,__TS__Using=fg,__TS__UsingAsync=fm}\n",setuser=false,size=38745,modified=1757997043012,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["ar.lua"]={permissions={root={write=true,read=true,execute=false}},created=1757997039664,data="local a=require\"system.filesystem\"local function b(c)return c:match('^()[%s%z]*$')and''or c:match('^[%s%z]*(.*[^%s%z])')end;local function d(e,f,g)return#e<f and e:sub(1,f)..(g or\" \"):rep(f-#e)or e end;local function h(i)return 0x38+(i.worldPermissions.read and 4 or 0)+(i.worldPermissions.write and 2 or 0)+(i.worldPermissions.execute and 1 or 0)+(i.permissions[i.owner].read and 256 or 0)+(i.permissions[i.owner].write and 128 or 0)+(i.permissions[i.owner].execute and 64 or 0)end;local j={verbosity=0}function j.load(k)if not a.exists(k)then return nil end;local l=a.open(k,\"rb\")if l.read(8)~=\"!<arch>\\n\"then l.close()error(\"Not an ar archive\",2)end;local m={}local n=nil;local o={}while true do local p={}local q=l.read(1)while q==\"\\n\"do q=l.read(1)end;if q==nil then break end;local r=l.read(15)if r==nil then break end;r=q..r;if r:find(\"/\")and r:find(\"/\")>1 then r=r:sub(1,r:find(\"/\")-1)else r=b(r)end;p.timestamp=tonumber(b(l.read(12)))p.owner=tonumber(b(l.read(6)))p.group=tonumber(b(l.read(6)))p.mode=tonumber(b(l.read(8)),8)local s=tonumber(b(l.read(10)))if l.read(2)~=\"`\\n\"then error(\"Invalid header for file \"..r,2)end;if r:match(\"^#1/%d+$\")then r=l.read(tonumber(r:match(\"#1/(%d+)\")))elseif r:match(\"^/%d+$\")then if n then local t=tonumber(r:match(\"/(%d+)\"))r=n:sub(t+1,n:find(\"\\n\",t+1)-1)else o[#o+1]=r end end;p.name=r;p.data=l.read(s)if r==\"//\"then n=p.data elseif r~=\"/\"and r~=\"/SYM64/\"then m[#m+1]=p end end;l.close()if n then for u,v in ipairs(o)do local t=tonumber(v:match(\"/(%d+)\"))for u,w in ipairs(m)do if w.name==v then w.name=n:sub(t,n:find(\"/\",t)-1)break end end end end;return m end;function j.write(v,x)local l=a.open(x,\"wb\")l.write(v.data)l.close()if j.verbosity>0 then print(\"Extracted to \"..x)end end;function j.extract(p,k)if type(p)==\"string\"then p=j.load(p)end;if not a.exists(k)then a.mkdir(k)end;for u,v in ipairs(p)do local x=a.combine(k,v.name)j.write(v,x)end end;function j.read(x)local i=a.stat(x)if not i then return nil end;local l=assert(a.open(x,\"rb\"))local m={name=a.basename(x),timestamp=math.floor(i.modified/1000),owner=(i.owner==\"root\"or i.owner==nil)and 0 or 501,group=0,mode=h(i),data=l.readAll()}l.close()return m end;function j.pack(k)local m={}for u,v in ipairs(a.list(k))do local x=a.combine(k,v)if not a.isDir(x)then m[v]=j.read(x)end end;return m end;function j.save(p,k)local l=a.open(k,\"wb\")l.write(\"!<arch>\\n\")local n={}local y=nil;for u,v in ipairs(p)do if#v.name>15 then n[v.name]=#(y or\"\")y=(y or\"\")..v.name..\"/\\n\"end end;if y then l.write(\"//              0           0     0     666     \"..d(tostring(#y),10)..\"`\\n\"..y)if l.seek()%2==1 then l.write(\"\\n\")end end;for u,v in ipairs(p)do local r=n[v.name]and\"/\"..n[v.name]or v.name..(y and\"/\"or\"\")l.write(d(r,16)..d(tostring(v.timestamp),12)..d(tostring(v.owner),6)..d(tostring(v.group),6))l.write(d((\"%o\"):format(v.mode),8)..d(tostring(#v.data),10)..\"`\\n\"..v.data)if l.seek()%2==1 then l.write(\"\\n\")end end;l.close()end;return j\n",setuser=false,size=2942,modified=1757997039661,worldPermissions={write=false,read=true,execute=false},type="file",owner="root"},["libcc.a"]={permissions={root={read=true,write=true,execute=false}},created=1757997041054,data="!<arch>\naudio.dfpwm.lua/0           0     0     644     1285      `\nlocal a=require\"expect\".expect;local b,c,d,e,f=string.char,string.byte,math.floor,bit32.band,bit32.arshift;local g=10;local h=2^g;local i=2^(g-1)local j=2^(g-8+1)local function k()local l,m,n=0,0,false;return function(o)local p=o and 127 or-128;local q=l+d((m*(p-l)+i)/h)if q==l and q~=p then q=q+(o and 1 or-1)end;local r=o==n and h-1 or 0;local s=m;if s~=r then s=s+(o==n and 1 or-1)end;if s<j then s=j end;l,m,n=q,s,o;return l end end;local function t()local u=k()local v=0;return function(w)a(1,w,\"table\")local x,y={},0;for z=1,#w,8 do local A=0;for B=0,7 do local C=d(w[z+B]or 0)if C>127 or C<-128 then error((\"Amplitude at position %d was %d, but should be between -128 and 127\"):format(z+B,C),2)end;local o=C>v or C==v and C==127;A=d(A/2)+(o and 128 or 0)v=u(o)end;y=y+1;x[y]=b(A)end;return table.concat(x,\"\",1,y)end end;local function D()local u=k()local E=0;local v,n=0,false;return function(w,x)a(1,w,\"string\")local x,y={},0;for z=1,#w do local F=c(w,z)for G=1,8 do local o=e(F,1)~=0;local l=u(o)local H=l;if o~=n then H=d((l+v+1)/2)end;v,n=l,o;E=E+d(((H-E)*140+0x80)/256)y=y+1;x[y]=E;F=f(F,1)end end;return x end end;local function I(w)a(1,w,\"string\")return D()(w)end;local function J(w)a(1,w,\"table\")return t()(w)end;return{make_encoder=t,encode=J,make_decoder=D,decode=I}\n\nexpect.lua/     0           0     0     644     1273      `\nlocal a={}local b={[\"nil\"]=true,boolean=true,number=true,string=true,table=true,[\"function\"]=true,userdata=true,thread=true}local function c(d,e,...)local f=type(e)local g;if f==\"table\"then local h=getmetatable(e)if h then g=h.__name end end;local i=table.pack(...)for j,k in ipairs(i)do if b[k]then if f==k then return e end elseif g==k then return e end end;local l=debug.getinfo(2,\"n\")if l and l.name and l.name~=\"\"then d=d..\" to '\"..l.name..\"'\"end;local m;if i.n==1 then m=i[1]elseif i.n==2 then m=i[1]..\" or \"..i[2]else m=table.concat(i,\", \",1,i.n-1)..\", or \"..i[i.n]end;error(d..\" (expected \"..m..\", got \"..f..\")\",3)end;function a.expect(n,e,...)return c(\"bad argument #\"..n,e,...)end;function a.field(o,p,...)local q,r=pcall(string.format,\"%q\",p)if not q then r=tostring(p)end;return c(\"bad field \"..r,o[p],...)end;function a.range(s,t,u)a.expect(1,s,\"number\")a.expect(2,t,\"number\",\"nil\")a.expect(3,u,\"number\",\"nil\")if u and t and u<t then error(\"bad argument #3 (min must be less than or equal to max)\",2)end;if s~=s or s<(t or-math.huge)or s>(u or math.huge)then error((\"number outside of range (expected %s to be within %s and %s)\"):format(s,t or-math.huge,u or math.huge),3)end;return s end;return setmetatable(a,{__call=function(j,...)return a.expect(...)end})\n\nimage.nft.lua/  0           0     0     644     943       `\nlocal a=require\"expect\".expect;local function b(c)a(1,c,\"string\")local d={}local e=1;local f=\"0\"local g=\"f\"local h,i=1,#c;while h<=i do local j=c:sub(h,h)if j==\"\\31\"and h<i then h=h+1;f=c:sub(h,h)elseif j==\"\\30\"and h<i then h=h+1;g=c:sub(h,h)elseif j==\"\\n\"then if d[e]==nil then d[e]={text=\"\",foreground=\"\",background=\"\"}end;e=e+1;f,g=\"0\",\"f\"else local k=c:find(\"[\\n\\30\\31]\",h)or#c+1;local l=k-h;local m=d[e]if m==nil then m={foreground=\"\",background=\"\",text=\"\"}d[e]=m end;m.text=m.text..c:sub(h,k-1)m.foreground=m.foreground..f:rep(l)m.background=m.background..g:rep(l)h=k-1 end;h=h+1 end;return d end;local function n(o)a(1,o,\"string\")local p,q=io.open(o,\"r\")if not p then return nil,q end;local d=p:read(\"*a\")p:close()return b(d)end;local function r(c,s,t,u)a(1,c,\"table\")a(2,s,\"number\")a(3,t,\"number\")a(4,u,\"table\")for v,e in ipairs(c)do u.setCursorPos(s,t+v-1)u.blit(e.text,e.foreground,e.background)end end;return{parse=b,load=n,draw=r}\n\npretty.lua/     0           0     0     644     6449      `\nlocal term=term or require\"craftos.term\"local a=require\"expect\"local a,b=a.expect,a.field;local type,getmetatable,setmetatable,colours,c,tostring=type,getmetatable,setmetatable,colours,write,tostring;local d,e=debug.getinfo,debug.getlocal;local function f(g,h)local i=g.n+1;g[i],g.n=h,i end;local j={}local function k(l)return setmetatable(l,j)end;local m=k({tag=\"nil\"})local n=k({tag=\"text\",text=\" \"})local o=k({tag=\"line\",flat=m})local p=k({tag=\"line\",flat=n})local q={[\"\"]=m,[\" \"]=n,[\"\\n\"]=p}local function r(s,t)return q[s]or setmetatable({tag=\"text\",text=s,colour=t},j)end;local function s(s,t)a(1,s,\"string\")a(2,t,\"number\",\"nil\")local u=q[s]if u then return u end;local v=s:find(\"\\n\",1)if not v then return r(s,t)end;local w=setmetatable({tag=\"concat\",n=0},j)if v~=1 then f(w,r(s:sub(1,v-1),t))end;v=v+1;while true do local x=s:find(\"\\n\",v)f(w,p)if not x then if v<=#s then f(w,r(s:sub(v),t))end;return w else if v<=x-1 then f(w,r(s:sub(v,x-1),t))end;v=x+1 end end end;local function y(...)local z=table.pack(...)for A=1,z.n do if type(z[A])==\"string\"then z[A]=s(z[A])end;if getmetatable(z[A])~=j then a(A,z[A],\"document\")end end;if z.n==0 then return m end;if z.n==1 then return z[1]end;z.tag=\"concat\"return setmetatable(z,j)end;j.__concat=y;local function B(C,w)a(1,C,\"number\")if getmetatable(w)~=j then a(2,w,\"document\")end;if C<=0 then error(\"depth must be a positive number\",2)end;return setmetatable({tag=\"nest\",depth=C,w},j)end;local function D(w)if w.flat then return w.flat end;local E=w.tag;if E==\"nil\"or E==\"text\"then return w elseif E==\"concat\"then local g=setmetatable({tag=\"concat\",n=w.n},j)for A=1,w.n do g[A]=D(w[A])end;w.flat,g.flat=g,g;return g elseif E==\"nest\"then return D(w[1])elseif E==\"group\"then return w[1]else error(\"Unknown doc \"..E)end end;local function F(w)if getmetatable(w)~=j then a(1,w,\"document\")end;if w.tag==\"group\"then return w end;local G=D(w)if G==w then return w end;return setmetatable({tag=\"group\",G,w},j)end;local function H(w,I)local E=w.tag;if E==\"nil\"or E==\"line\"then return I elseif E==\"text\"then return I-#w.text elseif E==\"concat\"then for A=1,w.n do I=H(w[A],I)if I<0 then break end end;return I elseif E==\"group\"or E==\"nest\"then return H(E[1])else error(\"Unknown doc \"..E)end end;local function write(w,J)if getmetatable(w)~=j then a(1,w,\"document\")end;a(2,J,\"number\",\"nil\")local term=term;local I,K=term.getSize()local L=(J or 0.6)*I;if L<0 then L=0 end;if L>I then L=I end;local M=term.getTextColour()local N=M;local function O(w,P,Q)local E=w.tag;if E==\"nil\"then return Q elseif E==\"text\"then local R=w.colour or M;if R~=N then term.setTextColour(R)N=R end;c(w.text)return Q+#w.text elseif E==\"line\"then local S,T=term.getCursorPos()if T<K then term.setCursorPos(P+1,T+1)else term.scroll(1)term.setCursorPos(P+1,K)end;return P elseif E==\"concat\"then for A=1,w.n do Q=O(w[A],P,Q)end;return Q elseif E==\"nest\"then return O(w[1],P+w.depth,Q)elseif E==\"group\"then if H(w[1],math.min(I,L+P)-Q)>=0 then return O(w[1],P,Q)else return O(w[2],P,Q)end else error(\"Unknown doc \"..E)end end;local Q=math.max(term.getCursorPos()-1,0)O(w,0,Q)if N~=M then term.setTextColour(M)end end;local function U(w,J)if getmetatable(w)~=j then a(1,w,\"document\")end;a(2,J,\"number\",\"nil\")write(w,J)c(\"\\n\")end;local function V(w,I,J)if getmetatable(w)~=j then a(1,w,\"document\")end;a(2,I,\"number\",\"nil\")a(3,J,\"number\",\"nil\")local L;if I then L=(J or 0.6)*I;if L<0 then L=0 end;if L>I then L=I end end;local g={n=0}local function O(w,P,Q)local E=w.tag;if E==\"nil\"then return Q elseif E==\"text\"then f(g,w.text)return Q+#w.text elseif E==\"line\"then f(g,\"\\n\"..(\" \"):rep(P))return P elseif E==\"concat\"then for A=1,w.n do Q=O(w[A],P,Q)end;return Q elseif E==\"nest\"then return O(w[1],P+w.depth,Q)elseif E==\"group\"then if not I or H(w[1],math.min(I,L+P)-Q)>=0 then return O(w[1],P,Q)else return O(w[2],P,Q)end else error(\"Unknown doc \"..E)end end;O(w,0,0)return table.concat(g,\"\",1,g.n)end;j.__tostring=V;local W={[\"and\"]=true,[\"break\"]=true,[\"do\"]=true,[\"else\"]=true,[\"elseif\"]=true,[\"end\"]=true,[\"false\"]=true,[\"for\"]=true,[\"function\"]=true,[\"if\"]=true,[\"in\"]=true,[\"local\"]=true,[\"nil\"]=true,[\"not\"]=true,[\"or\"]=true,[\"repeat\"]=true,[\"return\"]=true,[\"then\"]=true,[\"true\"]=true,[\"until\"]=true,[\"while\"]=true}local X=s(\",\")local Y=s(\"{}\")local Z,_=s(\"{\"),s(\"}\")local a0,a1=s(\"[\"),s(\"] = \")local function a2(a3,a4)local a5,a6=type(a3),type(a4)if a5==\"string\"then return a6~=\"string\"or a3<a4 elseif a6==\"string\"then return false end;if a5==\"number\"then return a6~=\"number\"or a3<a4 end;return false end;local function a7(a8,a9)local aa=d and d(a8,\"Su\")local ab;if a9.function_source and aa and aa.short_src and aa.linedefined and aa.linedefined>=1 then ab=\"function<\"..aa.short_src..\":\"..aa.linedefined..\">\"else ab=tostring(a8)end;if a9.function_args and aa and aa.what==\"Lua\"and aa.nparams and e then local z={}for A=1,aa.nparams do z[A]=e(a8,A)or\"?\"end;if aa.isvararg then z[#z+1]=\"...\"end;ab=ab..\"(\"..table.concat(z,\", \")..\")\"end;return ab end;local function ac(ad,a9,ae)local af=type(ad)if af==\"string\"then local ag=(\"%q\"):format(ad):gsub(\"\\\\\\n\",\"\\\\n\")return s(ag,colours.red)elseif af==\"number\"then return s(tostring(ad),colours.magenta)elseif af==\"function\"then return s(a7(ad,a9),colours.lightGrey)elseif af~=\"table\"or ae[ad]then return s(tostring(ad),colours.lightGrey)elseif getmetatable(ad)~=nil and getmetatable(ad).__tostring then return s(tostring(ad))elseif next(ad)==nil then return Y else ae[ad]=true;local w=setmetatable({tag=\"concat\",n=1,p},j)local ah,ai,aj=#ad,{},1;for ak in pairs(ad)do if type(ak)~=\"number\"or ak%1~=0 or ak<1 or ak>ah then ai[aj],aj=ak,aj+1 end end;table.sort(ai,a2)for A=1,ah do if A>1 then f(w,X)f(w,p)end;f(w,ac(ad[A],a9,ae))end;for A=1,aj-1 do if A>1 or ah>=1 then f(w,X)f(w,p)end;local ak=ai[A]local al=ad[ak]if type(ak)==\"string\"and not W[ak]and ak:match(\"^[%a_][%a%d_]*$\")then f(w,s(ak..\" = \"))f(w,ac(al,a9,ae))else f(w,a0)f(w,ac(ak,a9,ae))f(w,a1)f(w,ac(al,a9,ae))end end;ae[ad]=nil;return F(y(Z,B(2,y(table.unpack(w,1,w.n))),p,_))end end;local function am(ad,a9)a(2,a9,\"table\",\"nil\")a9=a9 or{}local an={function_source=b(a9,\"function_source\",\"boolean\",\"nil\")or false,function_args=b(a9,\"function_args\",\"boolean\",\"nil\")or false}return ac(ad,an,{})end;local function ao(ad,a9,J)a(2,a9,\"table\",\"nil\")a9=a9 or{}a(3,J,\"number\",\"nil\")return U(am(ad,a9),J)end;return{empty=m,space=n,line=o,space_line=p,text=s,concat=y,nest=B,group=F,write=write,print=U,render=V,pretty=am,pretty_print=ao}\n\n",setuser=false,size=10202,modified=1757997041040,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["libcraftos.a"]={permissions={root={read=true,write=true,execute=false}},created=1757997041055,data="!<arch>\ncolors.lua/     0           0     0     644     669       `\nlocal a=require\"cc.expect\"local b={white=0,orange=1,magenta=2,lightBlue=3,yellow=4,lime=5,pink=6,gray=7,lightGray=8,cyan=9,purple=10,blue=11,brown=12,green=13,red=14,black=15}function b.combine(...)return math.max(...)end;function b.subtract(...)return math.min(...)end;function b.test(c,d)return c==d end;function b.packRGB(e,f,d)a(1,e,\"number\")a(2,f,\"number\")a(3,d,\"number\")return bit32.bor(bit32.lshift(e*255,16),bit32.lshift(f*255,8),d*255)end;function b.unpackRGB(g)a(1,g,\"number\")return bit32.band(bit32.rshift(g,16),0xFF)/255,bit32.band(bit32.rshift(g,8),0xFF)/255,bit32.band(g,0xFF)/255 end;function b.toBlit(h)a(1,h,\"number\")return(\"%x\"):format(h)end;return b\n\ncolours.lua/    0           0     0     644     669       `\nlocal a=require\"cc.expect\"local b={white=0,orange=1,magenta=2,lightBlue=3,yellow=4,lime=5,ping=6,grey=7,lightGrey=8,cyan=9,purple=10,blue=11,brown=12,green=13,red=14,black=15}function b.combine(...)return math.max(...)end;function b.subtract(...)return math.min(...)end;function b.test(c,d)return c==d end;function b.packRGB(e,f,d)a(1,e,\"number\")a(2,f,\"number\")a(3,d,\"number\")return bit32.bor(bit32.lshift(e*255,16),bit32.lshift(f*255,8),d*255)end;function b.unpackRGB(g)a(1,g,\"number\")return bit32.band(bit32.rshift(g,16),0xFF)/255,bit32.band(bit32.rshift(g,8),0xFF)/255,bit32.band(g,0xFF)/255 end;function b.toBlit(h)a(1,h,\"number\")return(\"%x\"):format(h)end;return b\n\ndisk.lua/       0           0     0     644     1517      `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"local function c(d)local e=b.devinfo(d)return e and e.types.drive end;local f={}function f.isPresent(d)a(1,d,\"string\")return b.devlookup(d)~=nil and b.devinfo(d).types.drive and b.devcall(d,\"getState\")~=nil end;function f.getLabel(d)a(1,d,\"string\")if not c(d)then return nil end;local g=b.devcall(d,\"getState\")return g and g.label end;function f.setLabel(d,h)a(1,d,\"string\")a(2,h,\"string\",\"nil\")if not c(d)then return end;b.devcall(d,\"setLabel\",h)end;function f.hasData(d)a(1,d,\"string\")if not c(d)then return false end;local g=b.devcall(d,\"getState\")return g and not g.isAudio end;function f.getMountPath(d)a(1,d,\"string\")local e=b.devinfo(d)if not e or not e.types.drive then return nil end;local i=b.mountlist()for j,k in ipairs(i)do if k.type==\"drivefs\"and k.uuid==e.uuid then return k.path end end;return nil end;function f.hasAudio(d)a(1,d,\"string\")if not c(d)then return false end;local g=b.devcall(d,\"getState\")return g and g.audio~=nil end;function f.getAudioTitle(d)a(1,d,\"string\")if not c(d)then return nil end;local g=b.devcall(d,\"getState\")return g and g.audio end;function f.playAudio(d)a(1,d,\"string\")if not c(d)then return end;b.devcall(d,\"play\")end;function f.stopAudio(d)a(1,d,\"string\")if not c(d)then return end;b.devcall(d,\"stop\")end;function f.eject(d)a(1,d,\"string\")if not c(d)then return end;b.devcall(d,\"eject\")end;function f.getID(d)a(1,d,\"string\")if not c(d)then return nil end;local g=b.devcall(d,\"getState\")return g and g.id end;return f\n\nfs.lua/         0           0     0     644     3003      `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"local c={}function c.list(d)a(1,d,\"string\")return b.list(d)end;function c.exists(d)a(1,d,\"string\")return b.stat(d)~=nil end;function c.isDir(d)a(1,d,\"string\")local e=b.stat(d)return e~=nil and e.type==\"directory\"end;function c.isReadOnly(d)a(1,d,\"string\")local e=b.stat(d)while e==nil do d=c.getDir(d)e=b.stat(d)end;local f=b.getuser()if e.permissions[f]then return not e.permissions[f].write else return not e.worldPermissions.write end end;function c.getName(d)a(1,d,\"string\")return b.combine(d):match\"[^/]+$\"end;function c.getDrive(d)a(1,d,\"string\")local e=b.stat(d)return e and(e.mountpoint==\"/\"and\"hdd\"or e.mountpoint:gsub(\"^/\",\"\"))end;function c.getSize(d)a(1,d,\"string\")local e=b.stat(d)return e and e.size end;function c.getFreeSpace(d)a(1,d,\"string\")local e=b.stat(d)while e==nil do d=c.getDir(d)e=b.stat(d)end;return e and e.freeSpace end;function c.makeDir(d)a(1,d,\"string\")return b.mkdir(d)end;function c.move(g,h)a(1,g,\"string\")a(2,h,\"string\")local i=assert(b.stat(g),\"No such file or directory\")local d=h;local j=b.stat(d)if j then error(\"File exists\",2)end;while j==nil do d=c.getDir(d)j=b.stat(d)end;if i.mountpoint==j.mountpoint then return b.rename(g,h)end;c.copy(g,h)b.remove(g)end;function c.copy(g,h)a(1,g,\"string\")a(2,h,\"string\")local e=b.stat(g)if e.type==\"directory\"then local k=b.list(g)b.mkdir(h)for l,m in ipairs(k)do c.copy(b.combine(g,m),b.combine(h,m))end else local n,o=b.open(g,\"rb\")if not n then error(o,2)end;local p,o=b.open(h,\"wb\")if not p then n.close()error(o,2)end;repeat local q=n.read(512)if q then p.write(q)end until not q;p.close()n.close()end end;function c.delete(d)a(1,d,\"string\")return b.remove(d)end;function c.combine(...)return b.combine(...)end;function c.open(d,r)a(1,d,\"string\")a(2,r,\"string\")return b.open(d,r)end;local function s(t,u,v)if v>#u then return{}end;local w=u[v]:gsub(\"[%^%$%(%)%%%.%+%-]\",\"%%%1\"):gsub(\"%*\",\".*\"):gsub(\"%?\",\".\"):gsub(\"%[!\",\"[^\")local x={}for l,y in ipairs(t)do local z,A=pcall(b.list,y)if z then for l,d in ipairs(A)do if d:match(w)then x[#x+1]=b.combine(y,d)end end end end;if v+1>#u then return x end;return s(x,u,v+1)end;function c.find(B)a(1,B,\"string\")local C={}for D in B:gmatch(\"[^/]+\")do C[#C+1]=D end;local E=s({B:sub(1,1)==\"/\"and\"/\"or\".\"},C,1)table.sort(E)return E end;function c.getDir(d)a(1,d,\"string\")local D=b.combine(d):match\"^(.*)/[^/]*$\"or\"\"if D==\"\"then if d:sub(1,1)==\"/\"then return\"/\"else return\".\"end else return D end end;function c.complete(F,d,G,H)end;function c.attributes(d)a(1,d,\"string\")local e=b.stat(d)if not e then return nil end;e.isDir=e.type==\"directory\"local f=b.getuser()if e.permissions[f]then e.isReadOnly=not e.permissions[f].write else e.isReadOnly=not e.worldPermissions.write end end;function c.getCapacity(d)a(1,d,\"string\")local e=b.stat(d)while e==nil do d=c.getDir(d)e=b.stat(d)end;return e and e.capacity end;function c.isDriveRoot(d)a(1,d,\"string\")local e=b.stat(d)return e~=nil and b.combine(d)==e.mountpoint end;return c\n\ngps.lua/        0           0     0     644     53        `\nlocal a={}function a.locate()return nil end;return a\n\n_handles.lua/   0           0     0     644     39        `\nreturn{http={},websocket={},rednet={}}\n\nhelp.lua/       0           0     0     644     698       `\nlocal a=require\"cc.expect\"local b=require\"fs\"local c={}local d=\"/usr/share/man/*:/usr/local/share/man/*\"function c.path()return d end;function c.setPath(e)a(1,e,\"string\")d=e end;function c.lookup(f)a(1,f,\"string\")for g in d:gmatch\"[^:]+\"do local h=b.find(b.combine(g,f..\".*\"))if#h>0 then return table.unpack(h)end end;return nil end;function c.topics()local i={}for g in d:gmatch\"[^:]+\"do for j in ipairs(b.find(g))do for k,l in ipairs(b.list(j))do i[#i+1]=l:gsub(\"%..*$\",\"\")end end end;return i end;function c.completeTopic(f)a(1,f,\"string\")local i={}for g in d:gmatch\"[^:]+\"do for k,l in ipairs(b.find(b.combine(g,f..\"*\")))do i[#i+1]=l:match(f..\"([^/%.]+)%.?[^/]*$\")end end;return i end;return c\nhttp.lua/       0           0     0     644     3221      `\nlocal a=require\"cc.expect\"local b=require\"_handles\"local c=require\"_syscall\"local d=require\"craftos.os\"local e={}local function f(g)local h={}function h.read(i)return g:read(i or 1)end;function h.readLine(j)return g:read(j and\"*L\"or\"*l\")end;function h.readAll()return g:read(\"*a\")end;function h.getResponseCode()return g:responseCode()end;function h.getResponseHeaders()return g:responseHeaders()end;function h.close()return g:close()end;return h end;local function k(g,l)local h={}function h.send(m,n)return g:write(m)end;function h.receive(o)local p;if o then p=d.startTimer(o)end;while true do if g.status==\"closed\"then error('attempt to use a closed file',2)end;local q,r,s=d.pullEvent()if q=='websocket_message'and r==l then return s elseif q=='websocket_closed'and r==l and g.status==\"closed\"then return nil elseif q=='timer'and r==p then return nil end end end;function h.close()return g:close()end;return h end;function e.get(r,t,n)a(1,r,\"string\",\"table\")if type(r)==\"string\"then r={url=r,headers=t,binary=n}end;a.field(r,\"url\",\"string\")a.field(r,\"headers\",\"table\",\"nil\")a.field(r,\"binary\",\"boolean\",\"nil\")a.field(r,\"method\",\"string\",\"nil\")a.field(r,\"redirect\",\"boolean\",\"nil\")r.method=\"GET\"return e.post(r)end;function e.post(r,u,t,n)a(1,r,\"string\",\"table\")if type(r)==\"string\"then r={url=r,body=u,headers=t,binary=n}end;a.field(r,\"url\",\"string\")a.field(r,\"body\",\"string\",\"nil\")a.field(r,\"headers\",\"table\",\"nil\")a.field(r,\"binary\",\"boolean\",\"nil\")a.field(r,\"method\",\"string\",\"nil\")a.field(r,\"redirect\",\"boolean\",\"nil\")r.encoding=r.binary and\"binary\"or\"utf8\"local g,v=c.connect(r)if not g then return nil,v end;local w=f(g)b.http[g.id]={url=r.url,handle=g,craftos=w}if r.body then g:write(r.body)else g:write()end;while true do local x,y=d.pullEvent()if x==\"http_success\"and y==r.url then return w elseif x==\"http_failure\"and y==r.url then return nil,g.error,w end end end;function e.request(r,u,t,n)a(1,r,\"string\",\"table\")if type(r)==\"string\"then r={url=r,body=u,headers=t,binary=n}end;a.field(r,\"url\",\"string\")a.field(r,\"body\",\"string\",\"nil\")a.field(r,\"headers\",\"table\",\"nil\")a.field(r,\"binary\",\"boolean\",\"nil\")a.field(r,\"method\",\"string\",\"nil\")a.field(r,\"redirect\",\"boolean\",\"nil\")r.encoding=r.binary and\"binary\"or\"utf8\"local g,v=c.connect(r)if not g then d.queueEvent(\"http_failure\",r.url,v)return false,v end;local w=f(g)b.http[g.id]={url=r.url,handle=g,craftos=w}if r.body then g:write(r.body)else g:write()end;return true end;function e.checkURLAsync(r)a(1,r,\"string\")local z=c.checkuri(r)d.queueEvent(\"http_check\",r,z)end;function e.checkURL(r)a(1,r,\"string\")return c.checkuri(r)end;function e.websocketAsync(r,t)a(1,r,\"string\")a(2,t,\"table\",\"nil\")local g,v=c.connect({url=r,headers=t})if not g then d.queueEvent(\"websocket_failure\",r.url,v)return false,v end;local w=k(g,r)b.websocket[g.id]={url=r.url,handle=g,craftos=w}return true end;function e.websocket(r,t)a(1,r,\"string\")a(2,t,\"table\",\"nil\")local g,v=c.connect({url=r,headers=t})if not g then return nil,v end;local w=k(g,r)b.websocket[g.id]={url=r.url,handle=g,craftos=w}while true do local x,y=d.pullEvent()if x==\"websocket_success\"and y==r.url then return w elseif x==\"websocket_failure\"and y==r.url then return nil,g.error end end end;return e\n\ninit.lua/       0           0     0     644     3570      `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"package.loaded.os=nil;local c=setmetatable({colors=require\"colors\",colours=require\"colours\",disk=require\"disk\",fs=require\"fs\",gps=require\"gps\",help=require\"help\",http=require\"http\",keys=require\"keys\",os=require\"os\",paintutils=require\"paintutils\",parallel=require\"parallel\",peripheral=require\"peripheral\",rednet=require\"rednet\",redstone=require\"redstone\",settings=require\"settings\",shell=require\"shell\",term=require\"term\",textutils=require\"textutils\",vector=require\"vector\",window=require\"window\"},{__index=_G})c.rs=c.redstone;c._HOST=b.cchost()c._CC_DEFAULT_SETTINGS=\"\"c.sleep=c.os.sleep;function c.write(d)a(1,d,\"string\")local e=0;local f,g=c.term.getSize()local function h(i)e=e+1;if i>g-1 then c.term.scroll(1)return i else return i+1 end end;while#d>0 do local j=d:find(\"\\n\")or#d;local k=d:sub(1,j)d=d:sub(#k+1)local l=k:sub(-1)==\"\\n\"if l then k=k:sub(1,-2)end;local m,i=c.term.getCursorPos()while#k>0 do if m>f then c.term.setCursorPos(1,h(i))m,i=c.term.getCursorPos()end;local n=k:sub(1,f-m+1)c.term.write(n)k=k:sub(#n+1)m,i=c.term.getCursorPos()end;if l then c.term.setCursorPos(1,h(i))end end;return e end;function c.print(...)local o=table.pack(...)for p=1,o.n,1 do o[p]=tostring(o[p])end;return c.write(table.concat(o,\"  \")..\"\\n\")end;function c.printError(...)local q=c.term.getTextColor()c.term.setTextColor(c.colors.red)print(...)c.term.setTextColor(q)end;local r={}function c.read(s,t,u,v)a(1,s,\"string\",\"nil\")a(2,t,\"table\",\"nil\")a(3,u,\"function\",\"nil\")a(4,v,\"string\",\"nil\")if s then s=s:sub(1,1)end;local w=t or{}t={}for p=1,#w,1 do t[p]=w[p]end;local x=v or\"\"local y=x;t[#t+1]=x;local z=#t;local A=0;local B,C=c.term.getCursorPos()local f,g=c.term.getSize()local D=false;local E={}local F=0;local function G()if E[F]then c.write((\" \"):rep(#E[F]))end end;local function H(I)if I or D then if u and x~=y then E=u(x)or r;F=math.min(1,#E)end;y=x;c.term.setCursorPos(B,C)local d=x;if s then d=s:rep(#d)end;local J=c.write(d)if E[F]then local K=c.term.getTextColor()local L=c.term.getBackgroundColor()c.term.setTextColor(c.colors.white)c.term.setBackgroundColor(c.colors.gray)J=J+c.write(E[F])c.term.setTextColor(K)c.term.setBackgroundColor(L)else J=J+c.write(\" \")end;if C+J>g then C=C-(C+J-g)end end;local m,i=B,C;m=m+#x-A;while m>f do m=m-f;i=i+1 end;c.term.setCursorPos(m,i)end;c.term.setCursorBlink(true)while true do H()local M,N=c.os.pullEvent()if M==\"char\"then D=true;G()if A==0 then x=x..N elseif A==#x then x=N..x else x=x:sub(0,-A-1)..N..x:sub(-A)end elseif M==\"paste\"then D=true;G()if A==0 then x=x..N elseif A==#x then x=N..x else x=x:sub(0,-A-1)..N..x:sub(-A+#id-1)end elseif M==\"key\"then local id=c.keys.getName(N)if id==\"backspace\"and#x>0 then D=true;if A==0 then x=x:sub(1,-2)G()elseif A<#x then x=x:sub(0,-A-2)..x:sub(-A)end elseif id==\"delete\"and A>0 then D=true;if A==#x then x=x:sub(2)elseif A==1 then x=x:sub(1,-2)else x=x:sub(0,-A-1)..x:sub(-A+1)end;A=A-1 elseif id==\"up\"then if#E>1 then D=true;G()if F>1 then F=F-1 else F=#E end elseif z>1 then A=0;t[z]=x;z=z-1;x=(\" \"):rep(#x)H(true)x=t[z]D=true end elseif id==\"down\"then if#E>1 then D=true;G()if F<#E then F=F+1 else F=1 end elseif z<#t then A=0;t[z]=x;z=z+1;x=(\" \"):rep(#x)H(true)x=t[z]D=true end elseif id==\"left\"then if A<#x then G()A=A+1 end elseif id==\"right\"then if A>0 then A=A-1 elseif F>0 then D=true;x=x..E[F]end elseif id==\"tab\"then if F>0 then D=true;x=x..E[F]end elseif id==\"home\"then A=#x elseif id==\"end\"then A=0 elseif id==\"enter\"then G()c.write(\"\\n\")break end end end;c.term.setCursorBlink(false)return x end;return c\nkeys.lua/       0           0     0     644     1330      `\nlocal a={}for b=0x61,0x7A do a[string.char(b)]=b end;for b=0x81,0x99 do a[\"f\"..bit32.band(b,31)]=b end;for b=0xA0,0xA9 do a[\"numPad\"..bit32.band(b,15)]=b end;a.backspace=0x08;a.tab=0x09;a.enter=0x0A;a.space=0x20;a.apostrophe=0x27;a.comma=0x2C;a.minus=0x2D;a.period=0x2E;a.slash=0x2F;a.zero=0x30;a.one=0x31;a.two=0x32;a.three=0x33;a.four=0x34;a.five=0x35;a.six=0x36;a.seven=0x37;a.eight=0x38;a.nine=0x39;a.semicolon=0x3B;a.equals=0x3D;a.leftBracket=0x5B;a.backslash=0x5C;a.rightBracket=0x5D;a.grave=0x60;a.delete=0x7F;a.insert=0x80;a.convert=0x9A;a.noconvert=0x9B;a.kana=0x9C;a.kanji=0x9D;a.yen=0x9E;a.numPadDecimal=0x9F;a.numPadAdd=0xAA;a.numPadSubtract=0xAB;a.numPadMultiply=0xAC;a.numPadDivide=0xAD;a.numPadEqual=0xAE;a.numPadEnter=0xAF;a.leftCtrl=0xB0;a.rightCtrl=0xB1;a.leftAlt=0xB2;a.rightAlt=0xB3;a.leftShift=0xB4;a.rightShift=0xB5;a.leftSuper=0xB6;a.rightSuper=0xB7;a.capsLock=0xB8;a.numLock=0xB9;a.scrollLock=0xBA;a.printScreen=0xBB;a.pause=0xBC;a.menu=0xBD;a.stop=0xBE;a.ax=0xBF;a.up=0xC0;a.down=0xC1;a.left=0xC2;a.right=0xC3;a.pageUp=0xC4;a.pageDown=0xC5;a.home=0xC6;a[\"end\"]=0xC7;a.circumflex=0xC8;a.at=0xC9;a.colon=0xCA;a.underscore=0xCB;local c={}for d,e in pairs(a)do c[e]=d end;function a.getName(f)if type(f)~=\"number\"then error(\"bad argument #1 (expected number, got \"..type(f)..\")\",2)end;return c[f]end;return a\nos.lua/         0           0     0     644     4668      `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"local c=require\"_handles\"local d=os;local os={date=d.date}function os.loadAPI(e)a(1,e,\"string\")local f=setmetatable({},{__index=_G})local g=loadfile(e,nil,f)if not g then return false end;if not pcall(g)then return false end;setmetatable(f,nil)_G[e:match(\"([^/]+)%.lua$\")or e:match(\"[^/]+\")]=f;return true end;function os.unloadAPI(h)_G[h]=nil end;function os.pullEvent(i)local j=table.pack(os.pullEventRaw(i))if j[1]==\"terminate\"then error(\"Terminated\",2)end;return table.unpack(j,1,j.n)end;function os._convertEvent(k,l)local j;if k==\"alarm\"or k==\"timer\"then j={k,l.id,n=2}elseif k==\"char\"then j={\"char\",l.character,n=2}elseif k==\"disk\"or k==\"disk_eject\"or k==\"speaker_audio_empty\"or k==\"monitor_resize\"or k==\"device_added\"or k==\"device_removed\"then j={k,l.device,n=2}elseif k==\"key\"then j={\"key\",l.keycode,l.isRepeat,n=3}elseif k==\"key_up\"then j={\"key_up\",l.keycode,n=2}elseif k==\"modem_message\"then j={\"modem_message\",l.device,l.channel,l.replyChannel,l.message,l.distance,n=6}elseif k==\"mouse_click\"or k==\"mouse_drag\"or k==\"mouse_up\"or k==\"mouse_move\"then j={k,l.button,l.x,l.y,n=4}elseif k==\"mouse_scroll\"then j={\"mouse_scroll\",l.direction,l.x,l.y,n=4}elseif k==\"paste\"then j={\"paste\",l.text,n=2}elseif k==\"redstone\"or k==\"term_resize\"or k==\"turtle_inventory\"or k==\"terminate\"then j={k,n=1}elseif k==\"craftos_event\"then j=l elseif k==\"handle_status_change\"then if c.http[l.id]then if l.status==\"open\"then if math.floor(c.http[l.id].handle:responseCode()/100)~=2 then j={\"http_failure\",c.http[l.id].url,c.http[l.id].handle.error,c.http[l.id].craftos,n=4}else j={\"http_success\",c.http[l.id].url,c.http[l.id].craftos,n=3}end;c.http[l.id]=nil elseif l.status==\"error\"then j={\"http_failure\",c.http[l.id].url,c.http[l.id].handle.error,c.http[l.id].craftos,n=4}c.http[l.id]=nil end elseif c.websocket[l.id]then if l.status==\"open\"then j={\"websocket_success\",c.websocket[l.id].url,c.websocket[l.id].craftos,n=3}elseif l.status==\"error\"then j={\"websocket_failure\",c.websocket[l.id].url,c.websocket[l.id].error,n=3}elseif l.status==\"closed\"then j={\"websocket_closed\",c.websocket[l.id].url,n=2}c.websocket[l.id]=nil end end elseif k==\"handle_data_ready\"then if c.websocket[l.id]then j={\"websocket_message\",c.websocket[l.id].url,c.websocket[l.id].handle:read(\"*a\"),true,n=4}elseif c.rednet[l.id]then j={\"rednet_message\",c.rednet[l.id].id,c.rednet[l.id].handle:read(\"*a\"),n=3}end else j={\"phoenix_event\",k,l,n=3}end;return j end;function os.pullEventRaw(i)local j;repeat j=table.pack(coroutine.yield())if j.n==2 and type(j[1])==\"string\"and type(j[2])==\"table\"then local k,l=j[1],j[2]j=os._convertEvent(k,l)end until i==nil or j[1]==i or j[1]==\"terminate\"return table.unpack(j,1,j.n)end;function os.sleep(m)a(1,m,\"number\")local n=b.timer(m)repeat local j,l=os.pullEvent()until j==\"timer\"and l==n end;function os.version()return\"Phoenix \"..b.version()end;function os.run(f,e,...)a(1,f,\"table\")a(2,e,\"string\")setmetatable(f,{__index=_ENV})local g,o=loadfile(e,nil,f)if not g then return false end;local p,q=pcall(g,...)return p end;function os.queueEvent(h,...)a(1,h,\"string\")b.queueEvent(\"craftos_event\",table.pack(h,...))end;function os.startTimer(m)a(1,m,\"number\")return b.timer(m)end;function os.cancelTimer(r)a(1,r,\"number\")return b.cancel(r)end;os.cancelAlarm=os.cancelTimer;function os.setAlarm(m)a(1,m,\"number\")return b.alarm(m)end;function os.shutdown()b.devcall(\"/\",\"shutdown\")end;function os.reboot()b.devcall(\"/\",\"reboot\")end;function os.getComputerID()return b.devinfo(\"/\").metadata.id end;os.computerID=os.getComputerID;function os.getComputerLabel()return b.devcall(\"/\",\"getLabel\")end;os.computerLabel=os.getComputerLabel;function os.setComputerLabel(s)a(1,s,\"string\")return b.devcall(\"/\",\"setLabel\",s)end;function os.clock()return b.uptime()end;function os.time(t)a(1,t,\"string\",\"table\",\"nil\")if type(t)==\"table\"then return d.time(t)end;local u;if t==\"utc\"then u=os.date(\"!*t\")elseif t==\"local\"then u=os.date(\"*t\")elseif t==\"ingame\"or u==nil then u=os.date(\"?*t\")else error(\"Unsupported operation\",2)end;return u.hour+u.min/60+u.sec/3600 end;function os.day(t)a(1,t,\"string\",\"nil\")local u;if t==\"utc\"then u=os.date(\"!*t\")elseif t==\"local\"then u=os.date(\"*t\")elseif t==\"ingame\"or u==nil then u=os.date(\"?*t\")else error(\"Unsupported operation\",2)end;return math.floor((u.year-1970)*365.24)+u.yday end;function os.epoch(t)a(1,t,\"string\",\"nil\")if t==\"utc\"then return d.time()*1000 elseif t==\"local\"then return(d.time()+d.time(os.date(\"*t\"))-d.time(os.date(\"!*t\")))*1000 elseif t==\"ingame\"then return d.time\"ingame\"*1000 elseif t==\"nano\"then return d.time\"nano\"else error(\"Unsupported operation\",2)end end;return os\npaintutils.lua/ 0           0     0     644     2739      `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"local c=require\"term\"local d={}function d.drawPixel(e,f,g)a(1,e,\"number\")a(2,f,\"number\")local h,i=c.getCursorPos()local j=c.getBackgroundColor()c.setCursorPos(e,f)if g then c.setBackgroundColor(g)end;c.write(\" \")c.setCursorPos(h,i)c.setBackgroundColor(j)end;local function k(l,m,n,o,p)if math.abs(p-n)<math.abs(o-m)then if m>o then m,n,o,p=o,p,m,n end;local q,r,s=o-m,p-n,1;if r<0 then s,r=-1,-r end;local t,f=2*r-q,n;if s<0 then f=p;for e=o,m,-1 do l(e,f)if t>0 then f=f+1;t=t+2*(r-q)else t=t+2*r end end else for e=m,o do l(e,f)if t>0 then f=f+1;t=t+2*(r-q)else t=t+2*r end end end else if n>p then m,n,o,p=o,p,m,n end;local q,r,u=o-m,p-n,1;if q<0 then u,q=-1,-q end;local t,e=2*q-r,m;for f=n,p do l(e,f)if t>0 then e=e+u;t=t+2*(q-r)else t=t+2*q end end end end;function d.drawLine(m,n,o,p,g)a(1,m,\"number\")a(2,n,\"number\")a(3,o,\"number\")a(4,p,\"number\")a(5,g,\"number\")if n==p then local v=math.abs(o-m)+1;local w,x=c.getBackgroundColor(),c.getTextColor()local h,i=c.getCursorPos()local y,z=(\"%x\"):format(x),(\"%x\"):format(g)c.setCursorPos(m,n)c.blit((\" \"):rep(v),y:rep(v),z:rep(v))c.setCursorPos(h,i)c.setBackgroundColor(w)return end;local l,A;local j=c.getBackgroundColor()local h,i=c.getCursorPos()c.setBackgroundColor(g)l,A=function(e,f)c.setCursorPos(e,f)c.write(\" \")end,function()c.setBackgroundColor(j)c.setCursorPos(h,i)end;k(l,m,n,o,p)A()end;function d.drawBox(e,f,v,B,g)a(1,e,\"number\")a(2,f,\"number\")a(3,v,\"number\")a(4,B,\"number\")a(5,g,\"number\")local w,x=c.getBackgroundColor(),c.getTextColor()local h,i=c.getCursorPos()local y,z=(\"%x\"):format(x),(\"%x\"):format(g)c.setCursorPos(e,f)c.blit((\" \"):rep(v),y:rep(v),z:rep(v))c.setCursorPos(e,f+B-1)c.blit((\" \"):rep(v),y:rep(v),z:rep(v))for C=f+1,f+B-2 do c.setCursorPos(e,C)c.blit(\" \",y,z)c.setCursorPos(e+v-1,C)c.blit(\" \",y,z)end;c.setBackgroundColor(w)c.setCursorPos(h,i)end;function d.drawFilledBox(e,f,v,B,g)a(1,e,\"number\")a(2,f,\"number\")a(3,v,\"number\")a(4,B,\"number\")a(5,g,\"number\")local w,x=c.getBackgroundColor(),c.getTextColor()local h,i=c.getCursorPos()local D,y,z=(\" \"):rep(v),(\"%x\"):format(x):rep(v),(\"%x\"):format(g):rep(v)for C=f,f+B-1 do c.setCursorPos(e,C)c.blit(D,y,z)end;c.setBackgroundColor(w)c.setCursorPos(h,i)end;function d.drawImage(e,f,E)a(1,e,\"number\")a(2,f,\"number\")a(3,E,\"table\")for F,G in ipairs(E)do c.setCursorPos(e,f+F-1)for H,j in ipairs(G)do c.setBackgroundColor(j)c.write(\" \")end end end;function d.parseImage(E)a(1,E,\"string\")local I={}for G in E:gmatch\"[^\\n]+\"do local J={}for j in G:gmatch\".\"do J[#J+1]=tonumber(j,16)end;I[#I+1]=J end;return I end;function d.loadImage(K)a(1,K,\"string\")local L=b.open(K,\"r\")if not L then return nil end;local M=L.readAll()L.close()return d.parseImage(M)end;return d\n\nparallel.lua/   0           0     0     644     837       `\nlocal a=require\"craftos.os\"local b={}local function c(d,e)local f={}for g,h in ipairs(d)do if type(h)~=\"function\"then error(\"bad argument #\"..g..\" (expected function, got \"..type(h)..\")\",2)end;f[g]={coro=coroutine.create(h),filter=nil,pos=g}end;local i={n=0}while#f>=e do local g=1;while g<#f do if f[g].filter==nil or f[g].filter==i[1]then local j=i;repeat local k=table.pack(f[g].coro(table.unpack(j,1,j.n)))if not k[1]then error(k[2],0)end;if k[2]==\"syscall\"then j=table.pack(coroutine.yield(table.unpack(k,1,k.n)))else f[g].filter=k[2]end until k[2]~=\"syscall\"if f[g]:status()==\"dead\"then local l=f[g].pos;table.remove(f,g)if#f<e then return l end;g=g-1 end end;g=g+1 end;i=table.pack(a.pullEvent())end;return 1 end;function b.waitForAny(...)return c({...},select(\"#\",...))end;function b.waitForAll(...)return c({...},1)end;return b\n\nperipheral.lua/ 0           0     0     644     2243      `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"local c={}function c.getNames()return b.devchildren(\"/\")end;function c.isPresent(d)a(1,d,\"string\")return b.devinfo(d)~=nil end;function c.getType(e)a(1,e,\"string\",\"table\")if type(e)==\"string\"then local f=b.devinfo(e)if not f then return nil end;local g={}for h in pairs(f.types)do g[#g+1]=h end;return table.unpack(g)else local i=getmetatable(e)if not i or i.__name~=\"peripheral\"or type(i.types)~=\"table\"then error(\"bad argument #1 (table is not a peripheral)\",2)end;return table.unpack(i.types)end end;function c.hasType(e,j)a(1,e,\"string\",\"table\")a(2,j,\"string\")if type(e)==\"string\"then local f=b.devinfo(e)if not f then return nil end;return f.types[j]~=nil else local i=getmetatable(e)if not i or i.__name~=\"peripheral\"or type(i.types)~=\"table\"then error(\"bad argument #1 (table is not a peripheral)\",2)end;return i.types[j]~=nil end end;function c.getMethods(d)a(1,d,\"string\")local k,g=pcall(b.devmethods,d)return k and g or nil end;function c.getName(e)a(1,e,\"table\")local i=getmetatable(e)if not i or i.__name~=\"peripheral\"or type(i.name)~=\"string\"then error(\"bad argument #1 (table is not a peripheral)\",2)end;return i.name end;function c.call(d,l,...)a(1,d,\"string\")a(2,l,\"string\")return b.devcall(d,l,...)end;function c.wrap(d)a(1,d,\"string\")local f=b.devinfo(d)if not f then return nil end;local m,n=b.devmethods(d),b.devproperties(d)for o,p in ipairs(n)do n[p]=true end;for h in pairs(f.types)do if type(h)==\"string\"then f.types[#f.types+1]=h end end;local g={}for o,p in ipairs(m)do g[p]=function(self,...)return b.devcall(d,p,...)end end;return setmetatable(g,{__name=\"peripheral\",name=d,type=f.types[1],types=f.types,__index=function(self,q)if type(q)==\"string\"and n[q]then return b.devcall(d,\"get\"..q:gsub(\"^.\",string.upper))end end,__newindex=function(self,q,r)if type(q)==\"string\"and n[q]and m[\"set\"..q:gsub(\"^.\",string.upper)]then return b.devcall(d,\"set\"..q:gsub(\"^.\",string.upper),r)end end,__tostring=function(self)return\"wrapped device: \"..(f.displayName or f.uuid)end})end;function c.find(j,s)a(1,j,\"string\")a(2,s,\"function\",\"nil\")local g={}for o,p in ipairs{b.devfind(j)}do local t=c.wrap(p)if not s or s(p,t)then g[#g+1]=t end end;return table.unpack(g)end;return c\n\nrednet.lua/     0           0     0     644     19        `\nlocal a={}return a\n\nredstone.lua/   0           0     0     644     1339      `\nlocal a=require\"_syscall\"local b=require\"cc.expect\"local c={}function c.getSides()return a.devchildren(\"/redstone\")end;function c.getInput(d)b(1,d,\"string\")return a.devcall(\"/redstone/\"..d,\"getInput\")>0 end;function c.getOutput(d)b(1,d,\"string\")return a.devcall(\"/redstone/\"..d,\"getOutput\")>0 end;function c.setOutput(d,e)b(1,d,\"string\")b(2,e,\"boolean\")return a.devcall(\"/redstone/\"..d,\"setOutput\",e and 15 or 0)end;function c.getAnalogInput(d)b(1,d,\"string\")return a.devcall(\"/redstone/\"..d,\"getInput\")end;function c.getAnalogOutput(d)b(1,d,\"string\")return a.devcall(\"/redstone/\"..d,\"getOutput\")end;function c.setAnalogOutput(d,e)b(1,d,\"string\")b(2,e,\"number\")b.range(e,0,15)return a.devcall(\"/redstone/\"..d,\"setOutput\",e)end;function c.getBundledInput(d)b(1,d,\"string\")return a.devcall(\"/redstone/\"..d,\"getBundledInput\")end;function c.getBundledOutput(d)b(1,d,\"string\")return a.devcall(\"/redstone/\"..d,\"getBundledOutput\")end;function c.setBundledOutput(d,e)b(1,d,\"string\")b(2,e,\"number\")b.range(e,0,65535)return a.devcall(\"/redstone/\"..d,\"setBundledOutput\",e)end;function c.testBundledInput(d,f)b(1,d,\"string\")b(2,f,\"number\")b.range(f,0,65535)return bit32.band(a.devcall(\"/redstone/\"..d,\"getBundledInput\"),f)==f end;c.getAnalogueInput=c.getAnalogInput;c.getAnalogueOutput=c.getAnalogOutput;c.setAnalogueOutput=c.setAnalogOutput;return c\n\nsettings.lua/   0           0     0     644     3872      `\nlocal a=require\"cc.expect\"local b=require\"fs\"local c=require\"textutils\"local d={}local e={}local f={}function d.get(g,h)a(1,g,\"string\")if e[g]~=nil then return e[g]elseif h~=nil then return h else return f[g]and f[g].default end end;function d.set(g,i)a(1,g,\"string\")if i==nil then error(\"bad argument #2 (expected value, got nil)\",2)end;if f[g]and f[g].type then a(2,i,f[g].value)end;e[g]=i end;function d.unset(g)a(1,g,\"string\")e[g]=nil end;function d.define(g,j)a(1,g,\"string\")if j~=nil then a(2,j,\"table\")a.field(j,\"description\",\"string\",\"nil\")a.field(j,\"type\",\"string\",\"nil\")if j.type then a.field(j,\"default\",j.type,\"nil\")end end;f[g]=j or{}end;function d.undefine(g)a(1,g,\"string\")f[g]=nil end;function d.getDetails(g)a(1,g,\"string\")local k=f[g]if k then return{description=k.description,default=k.default,type=k.type,value=e[g]}else return{value=e[g]}end end;function d.clear()e={}end;function d.getNames()local l={}for m in pairs(f)do l[#l+1]=m end;table.sort(l)return l end;function d.load(n)n=a(1,n,\"string\",\"nil\")or\"/etc/settings\"if not b.exists(n)then return false end;local o=b.open(n,\"r\")if not o then return false end;local p,q=pcall(c.unserialize,o.readAll())o.close()if not p or type(q)~=\"table\"then return false end;for m,r in pairs(q)do e[m]=r end;return true end;function d.save(n)n=a(1,n,\"string\",\"nil\")or\"/etc/settings\"local o=b.open(n,\"r\")if not o then return false end;o.write(c.serialize(e))o.close()return true end;d.define(\"shell.allow_startup\",{default=true,description=\"Run startup files when the computer turns on.\",type=\"boolean\"})d.define(\"shell.allow_disk_startup\",{default=true,description=\"Run startup files from disk drives when the computer turns on.\",type=\"boolean\"})d.define(\"shell.autocomplete\",{default=false,description=\"Autocomplete program and arguments in the shell.\",type=\"boolean\"})d.define(\"edit.autocomplete\",{default=false,description=\"Autocomplete API and function names in the editor.\",type=\"boolean\"})d.define(\"lua.autocomplete\",{default=false,description=\"Autocomplete API and function names in the Lua REPL.\",type=\"boolean\"})d.define(\"edit.default_extension\",{default=\"lua\",description=[[The file extension the editor will use if none is given. Set to \"\" to disable.]],type=\"string\"})d.define(\"paint.default_extension\",{default=\"nfp\",description=[[The file extension the paint program will use if none is given. Set to \"\" to disable.]],type=\"string\"})d.define(\"list.show_hidden\",{default=false,description=[[Show hidden files (those starting with \".\" in the Lua REPL).]],type=\"boolean\"})d.define(\"motd.enable\",{default=true,description=\"Display a random message when the computer starts up.\",type=\"boolean\"})d.define(\"motd.path\",{default=\"/rom/motd.txt:/motd.txt\",description=[[The path to load random messages from. Should be a colon (\":\") separated string of file paths.]],type=\"string\"})d.define(\"lua.warn_against_use_of_local\",{default=true,description=[[Print a message when input in the Lua REPL starts with the word 'local'. Local variables defined in the Lua REPL are be inaccessable on the next input.]],type=\"boolean\"})d.define(\"lua.function_args\",{default=true,description=\"Show function arguments when printing functions.\",type=\"boolean\"})d.define(\"lua.function_source\",{default=false,description=\"Show where a function was defined when printing functions.\",type=\"boolean\"})d.define(\"bios.strict_globals\",{default=false,description=\"Prevents assigning variables into a program's environment. Make sure you use the local keyword or assign to _G explicitly.\",type=\"boolean\"})d.define(\"shell.autocomplete_hidden\",{default=false,description=[[Autocomplete hidden files and folders (those starting with \".\").]],type=\"boolean\"})d.define(\"bios.use_multishell\",{default=true,description=[[Allow running multiple programs at once, through the use of the \"fg\" and \"bg\" programs.]],type=\"boolean\"})d.load()return d\nshell.lua/      0           0     0     644     1632      `\nlocal a=require\"_syscall\"local b=require\"cc.expect\"local c=require\"craftos.os\"local d={}local e=a.getenv().PATH or\"/bin:/sbin:/usr/bin\"local f={}local g={}function d.dir()return a.getcwd()end;function d.setDir(h)b(1,h,\"string\")return a.chdir(h)end;function d.path()return e end;function d.setPath(i)b(1,i,\"string\")e=i end;function d.getRunningProgram()return a.getname()end;function d.resolve(e)b(1,e,\"string\")if e:sub(1,1)==\"/\"then return e end;return a.combine(a.getcwd(),e)end;function d.run(...)local j=\"\"for k,l in ipairs{...}do j=j..(j==\"\"and\"\"or\" \")..l end;local m={}for n in j:gmatch\"%S+\"do m[#m+1]=n end;return d.execute(table.unpack(m))end;function d.execute(...)local o=setmetatable({shell=d},{__index=_ENV})local p,q=loadfile(e,nil,o)if not p then return false end;local r,s=pcall(p,...)return r end;function d.aliases()local t={}for u,l in pairs(f)do t[u]=l end;return t end;function d.setAlias(v,w)b(1,v,\"string\")b(2,w,\"string\")f[v]=w end;function d.clearAlias(v)b(1,v,\"string\")f[v]=nil end;function d.getCompletionInfo()return g end;function d.setCompletionFunction(w,p)end;function d.complete(x)return{}end;function d.completeProgram(w)return{}end;function d.resolveProgram(v)for y in e:gmatch\"[^:]+\"do local r,z=pcall(a.list,y)if r then for A in ipairs(z)do if v==A or v..\".lua\"==A then return a.combine(y,A)end end end end;return nil end;function d.programs(B)b(1,B,\"boolean\",\"nil\")local t={}for y in e:gmatch\"[^:]+\"do local r,z=pcall(a.list,y)if r then for A in ipairs(z)do if a.stat(a.combine(y,A)).type~=\"directory\"and(B or not A:match\"^%.\")then t[#t+1]=A:gsub(\"%.lua$\",\"\")end end end end;return t end;return d\n_syscall.lua/   0           0     0     644     217       `\nreturn setmetatable({},{__index=function(self,a)return function(...)local b=table.pack(coroutine.yield(\"syscall\",a,...))if b[1]then return table.unpack(b,2,b.n)else error(b[2],2)end end end,__newindex=function()end})\n\nterm.lua/       0           0     0     644     544       `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"local c={}local d=assert(b.openterm())local e={}local f=e;for g,h in pairs(d)do e[g]=h;c[g]=function(...)return f[g](...)end end;function c.redirect(i)a(1,i,\"table\")if i==c then error(\"term is not a recommended redirect target, try term.current() instead\",2)end;for g in pairs(e)do if type(i[g])~=\"function\"then i[g]=function()error(\"Redirect object is missing method \"..g..\".\",2)end end end;local j=f;f=i;return j end;function c.current()return f end;function c.native()return e end;return c\ntextutils.lua/  0           0     0     644     9020      `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"local c=require\"craftos.os\"local d=require\"term\"local e={}function e.slowWrite(f,g)a(1,f,\"string\")g=a(2,g,\"number\",\"nil\")or 20;local h,i=d.getCursorPos()local j,k=d.getSize()for l in f:gmatch\".\"do d.write(l)h=h+1;if l=='\\n'or h>j then h,i=1,i+1;if i>k then d.scroll(1)i=i-1 end;d.setCursorPos(h,i)end;local m=b.timer(1/g)repeat local n,o=c.pullEvent()until n==\"timer\"and o==m end end;function e.slowPrint(f,g)return e.slowWrite(f..\"\\n\",g)end;function e.formatTime(p,q)a(1,p,\"number\")a(2,q,\"boolean\",\"nil\")local r,s=math.floor(p),math.floor(p%1*60)return c.date(q and\"%H:%M\"or\"%I:%M %p\",c.time{year=1970,month=1,day=1,hour=r,min=s})end;function e.pagedPrint(f,t)error(\"Not implemented\")end;local function u(v,...)local t={}local w=0;local x={}for y,z in ipairs{...}do local A=type(z)if A==\"number\"then x[#t+1]=z elseif A==\"table\"then if#z>0 then t[#t+1]=z;for B=1,#z do z[B]=tostring(z[B])w=math.max(w,#z[B]+1)end end else error((\"bad argument #%d (expected table or number, got %s)\"):format(y,A),3)end end;local h,i=d.getCursorPos()local j,k=d.getSize()local function C()h,i=1,i+1;if i>k then d.scroll(1)i=i-1;if v then d.setCursorPos(h,i)d.write(\"Press any key to continue\")c.pullEvent(\"key\")d.clearLine()end end;d.setCursorPos(h,i)end;for y,z in ipairs(t)do if x[y]then d.setTextColor(x[y])end;for D,E in ipairs(z)do if h+w>j then C()end;d.write(E..(\" \"):rep(w-#E))h=h+w end;C()end end;function e.tabulate(...)return u(false,...)end;function e.pagedTabulate(...)return u(true,...)end;local function F(G)return setmetatable({},{__newindex=function()error(\"attempt to modify read-only table\")end,__tostring=function()return G end})end;e.json_null=F\"null\"e.empty_json_array=F\"[]\"local H;local I={[\"\\\\\"]=\"\\\\\",[\"\\\"\"]=\"\\\"\",[\"\\b\"]=\"b\",[\"\\f\"]=\"f\",[\"\\n\"]=\"n\",[\"\\r\"]=\"r\",[\"\\t\"]=\"t\"}local J={[\"/\"]=\"/\"}for B,z in pairs(I)do J[z]=B end;local function K(l)return\"\\\\\"..(I[l]or string.format(\"u%04x\",l:byte()))end;local function L(M)return\"null\"end;local function N(M,O)local P={}O=O or{}if M==e.json_null then return\"null\"elseif M==e.empty_json_array then return\"[]\"end;if O[M]then error(\"circular reference\")end;O[M]=true;if rawget(M,1)~=nil or next(M)==nil then local Q=0;for B in pairs(M)do if type(B)~=\"number\"then error(\"invalid table: mixed or invalid key types\")end;Q=Q+1 end;if Q~=#M then error(\"invalid table: sparse array\")end;for y,z in ipairs(M)do table.insert(P,H(z,O))end;O[M]=nil;return\"[\"..table.concat(P,\",\")..\"]\"else for B,z in pairs(M)do if type(B)~=\"string\"then error(\"invalid table: mixed or invalid key types\")end;table.insert(P,H(B,O)..\":\"..H(z,O))end;O[M]=nil;return\"{\"..table.concat(P,\",\")..\"}\"end end;local function R(M)return'\"'..M:gsub('[%z\\1-\\31\\\\\"]',K)..'\"'end;local function S(M)if M~=M or M<=-math.huge or M>=math.huge then error(\"unexpected number value '\"..tostring(M)..\"'\")end;return string.format(\"%.14g\",M)end;local T={[\"nil\"]=L,[\"table\"]=N,[\"string\"]=R,[\"number\"]=S,[\"boolean\"]=tostring}H=function(M,O)local U=type(M)local V=T[U]if V then return V(M,O)end;error(\"unexpected type '\"..U..\"'\")end;function e.serializeJSON(M,W)a(2,W,\"boolean\",\"nil\")return H(M)end;local X;local function Y(...)local P={}for y=1,select(\"#\",...)do P[select(y,...)]=true end;return P end;local Z=Y(\" \",\"\\t\",\"\\r\",\"\\n\")local _=Y(\" \",\"\\t\",\"\\r\",\"\\n\",\"]\",\"}\",\",\")local a0=Y(\"\\\\\",\"/\",'\"',\"b\",\"f\",\"n\",\"r\",\"t\",\"u\")local a1=Y(\"true\",\"false\",\"null\")local a2={[\"true\"]=true,[\"false\"]=false,[\"null\"]=nil}local function a3(G,a4,a5,a6)for y=a4,#G do if a5[G:sub(y,y)]~=a6 then return y end end;return#G+1 end;local function a7(G,a4,a8)local a9=1;local aa=1;for y=1,a4-1 do aa=aa+1;if G:sub(y,y)==\"\\n\"then a9=a9+1;aa=1 end end;error(string.format(\"%s at line %d col %d\",a8,a9,aa))end;local function ab(Q)local V=math.floor;if Q<=0x7f then return string.char(Q)elseif Q<=0x7ff then return string.char(V(Q/64)+192,Q%64+128)elseif Q<=0xffff then return string.char(V(Q/4096)+224,V(Q%4096/64)+128,Q%64+128)elseif Q<=0x10ffff then return string.char(V(Q/262144)+240,V(Q%262144/4096)+128,V(Q%4096/64)+128,Q%64+128)end;error(string.format(\"invalid unicode codepoint '%x'\",Q))end;local function ac(E)local ad=tonumber(E:sub(1,4),16)local ae=tonumber(E:sub(7,10),16)if ae then return ab((ad-0xd800)*0x400+ae-0xdc00+0x10000)else return ab(ad)end end;local function af(G,y)local P=\"\"local ag=y+1;local B=ag;while ag<=#G do local ah=G:byte(ag)if ah<32 then a7(G,ag,\"control character in string\")elseif ah==92 then P=P..G:sub(B,ag-1)ag=ag+1;local l=G:sub(ag,ag)if l==\"u\"then local ai=G:match(\"^[dD][89aAbB]%x%x\\\\u%x%x%x%x\",ag+1)or G:match(\"^%x%x%x%x\",ag+1)or a7(G,ag-1,\"invalid unicode escape in string\")P=P..ac(ai)ag=ag+#ai else if not a0[l]then a7(G,ag-1,\"invalid escape char '\"..l..\"' in string\")end;P=P..J[l]end;B=ag+1 elseif ah==34 then P=P..G:sub(B,ag-1)return P,ag+1 end;ag=ag+1 end;a7(G,y,\"expected closing quote for string\")end;local function aj(G,y,ak)local ah=a3(G,y,_)local E=G:sub(y,ah-1)if ak.nbt_style then E=E:gsub(\"[bBsSlLfFdD]%s*$\",\"\")end;local Q=tonumber(E)if not Q then a7(G,y,\"invalid number '\"..E..\"'\")end;return Q,ah end;local function al(G,y,ak)local ah=a3(G,y,_)local am=G:sub(y,ah-1)if not a1[am]then a7(G,y,\"invalid literal '\"..am..\"'\")end;if am==\"null\"and ak.parse_null then return e.json_null,ah end;return a2[am],ah end;local function an(G,y,ak)local P={}local Q=1;y=y+1;while 1 do local ah;y=a3(G,y,Z,true)if G:sub(y,y)==\"]\"then y=y+1;break elseif Q==1 and ak.nbt_style and G:sub(y,y):match(\"[BIL]\")then local ao=y;y=a3(G,y,Z,true)if G:sub(y,y)==\";\"then y=a3(G,y,Z,true)if G:sub(y,y)==\"]\"then y=y+1;break end else y=ao end end;ah,y=X(G,y,ak)P[Q]=ah;Q=Q+1;y=a3(G,y,Z,true)local ap=G:sub(y,y)y=y+1;if ap==\"]\"then break end;if ap~=\",\"then a7(G,y,\"expected ']' or ','\")end end;if#P==0 and ak.parse_empty_array~=false then return e.empty_json_array,y end;return P,y end;local function aq(G,y,ak)local P={}y=y+1;while 1 do local ar,M;y=a3(G,y,Z,true)if G:sub(y,y)==\"}\"then y=y+1;break end;if G:sub(y,y)=='\"'then ar,y=X(G,y,ak)elseif ak.nbt_style then local ao=y;ar,y=G:match(\"([A-Za-z0-9_%-%.%+]+)()\",y)if not ar then a7(G,ao,\"expected key\")end else a7(G,y,\"expected string for key\")end;y=a3(G,y,Z,true)if G:sub(y,y)~=\":\"then a7(G,y,\"expected ':' after key\")end;y=a3(G,y+1,Z,true)M,y=X(G,y,ak)P[ar]=M;y=a3(G,y,Z,true)local ap=G:sub(y,y)y=y+1;if ap==\"}\"then break end;if ap~=\",\"then a7(G,y,\"expected '}' or ','\")end end;return P,y end;local as={['\"']=af,[\"0\"]=aj,[\"1\"]=aj,[\"2\"]=aj,[\"3\"]=aj,[\"4\"]=aj,[\"5\"]=aj,[\"6\"]=aj,[\"7\"]=aj,[\"8\"]=aj,[\"9\"]=aj,[\"-\"]=aj,[\"t\"]=al,[\"f\"]=al,[\"n\"]=al,[\"[\"]=an,[\"{\"]=aq}X=function(G,a4,ak)local ap=G:sub(a4,a4)local V=as[ap]if V then return V(G,a4,ak)end;a7(G,a4,\"unexpected character '\"..ap..\"'\")end;function e.unserializeJSON(G,ak)a(1,G,\"string\")ak=a(2,ak,\"table\",\"nil\")or{}a.field(ak,\"nbt_style\",\"boolean\",\"nil\")a.field(ak,\"parse_null\",\"boolean\",\"nil\")a.field(ak,\"parse_empty_array\",\"boolean\",\"nil\")local P,a4=X(G,a3(G,1,Z,true),ak)a4=a3(G,a4,Z,true)if a4<=#G then a7(G,a4,\"trailing garbage\")end;return P end;local at={[\"and\"]=true,[\"break\"]=true,[\"do\"]=true,[\"else\"]=true,[\"elseif\"]=true,[\"end\"]=true,[\"false\"]=true,[\"for\"]=true,[\"function\"]=true,[\"goto\"]=true,[\"if\"]=true,[\"in\"]=true,[\"local\"]=true,[\"nil\"]=true,[\"not\"]=true,[\"or\"]=true,[\"repeat\"]=true,[\"return\"]=true,[\"then\"]=true,[\"true\"]=true,[\"until\"]=true,[\"while\"]=true}local function au(M,O,ak,av)if O[M]then error(\"Cannot serialize recursive value\",0)end;local A=type(M)if A==\"table\"then if not next(M)then return\"{}\"end;O[M]=true;local P=ak.compact and\"{\"or\"{\\n\"local aw={}for y,z in ipairs(M)do if not ak.compact then P=P..(\"    \"):rep(av)end;aw[y]=true;P=P..au(z,O,ak,av+1)..(ak.compact and\",\"or\",\\n\")end;for B,z in pairs(M)do if not aw[B]then if not ak.compact then P=P..(\"    \"):rep(av)end;if type(B)==\"string\"and B:match\"^[A-Za-z_][A-Za-z0-9_]*$\"and not at[B]then P=P..B else P=P..\"[\"..au(B,O,ak,av+1)..\"]\"end;P=P..(ak.compact and\"=\"or\" = \")..au(z,O,ak,av+1)..(ak.compact and\",\"or\",\\n\")end end;if ak.compact then P=P:gsub(\",$\",\"\")else P=P..(\"    \"):rep(av-1)end;if not ak.allow_repetitons then O[M]=nil end;return P..\"}\"elseif A==\"nil\"or A==\"number\"or A==\"boolean\"or A==\"string\"then return(\"%q\"):format(M):gsub(\"\\\\\\n\",\"\\\\n\"):gsub(\"\\\\?[%z\\1-\\31\\127-\\255]\",function(l)return(\"\\\\%03d\"):format(string.byte(l))end)else error(\"Cannot serialize type \"..A,0)end end;function e.serialize(M,ak)ak=a(2,ak,\"table\",\"nil\")or{}a.field(ak,\"compact\",\"boolean\",\"nil\")a.field(ak,\"allow_repetitions\",\"boolean\",\"nil\")return au(M,{},ak,1)end;function e.unserialize(E)a(1,E,\"string\")return assert(load(\"return \"..E,\"=unserialize\",\"t\",{}))()end;function e.urlEncode(G)a(1,G,\"string\")return G:gsub(\"\\n\",\"\\r\\n\"):gsub(\"([^A-Za-z0-9 %-%_%.])\",function(l)local Q=l:byte()if Q<128 then return(\"%%%02X\"):format(Q)else return(\"%%%02X%%%02X\"):format(bit32.rshift(Q,6)+0xC0,bit32.band(Q,0x3F)+0x80)end end):gsub(\" \",\"+\")end;function e.complete(ax,ay)error(\"Not implemented\")end;e.serialise=e.serialize;e.unserialise=e.unserialize;e.serialiseJSON=e.serializeJSON;e.unserialiseJSON=e.unserializeJSON;return e\nvector.lua/     0           0     0     644     1002      `\nlocal a={}local b={__name=\"vector\",__index=a}local function c(d,e,f)return setmetatable({x=tonumber(d)or 0,y=tonumber(e)or 0,z=tonumber(f)or 0},b)end;function a:add(g)return c(self.x+g.x,self.y+g.y,self.z+g.z)end;b.__add=a.add;function a:sub(g)return c(self.x-g.x,self.y-g.y,self.z-g.z)end;b.__sub=a.sub;function a:mul(h)return c(self.x*h,self.y*h,self.z*h)end;b.__mul=a.mul;function a:div(h)return c(self.x/h,self.y/h,self.z/h)end;b.__div=a.div;function a:unm()return c(-self.x,-self.y,-self.z)end;b.__unm=a.unm;function a:dot(g)return self.x*g.x+self.y*g.y+self.z*g.z end;function a:cross(g)return c(self.y*g.z-self.z*g.y,self.z*g.x-self.x*g.z,self.x*g.y-self.y*g.x)end;function a:length()return math.sqrt(self.x*self.x+self.y*self.y+self.z*self.z)end;function a:normalize()return self:mul(1/self:length())end;function a:tostring()return self.x..\",\"..self.y..\",\"..self.z end;b.__tostring=a.tostring;function a:equals(g)return self.x==g.x and self.y==g.y and self.z==g.z end;b.__eq=a.eq;return{new=c}\nwindow.lua/     0           0     0     644     7320      `\nlocal a=require\"cc.expect\"return{new=function(b,c,d,e,f,g)a(1,b,\"table\")a(2,c,\"number\")a(3,d,\"number\")a(4,e,\"number\")a(5,f,\"number\")a(6,g,\"boolean\",\"nil\")if g==nil then g=true end;local h={width=e,height=f}local i={cursor={x=1,y=1},cursorBlink=false,colors={fg='0',bg='f'},palette={},dirtyLines={},dirtyPalette={}}for j=1,h.height do i[j]={(' '):rep(h.width),('0'):rep(h.width),('f'):rep(h.width)}i.dirtyLines[j]=true end;if b then for k=0,15 do i.palette[k]={b.getPaletteColor(k)}i.dirtyPalette[k]=true end else i.palette={[0]={0.94117647058824,0.94117647058824,0.94117647058824},{0.94901960784314,0.69803921568627,0.2},{0.89803921568627,0.49803921568627,0.84705882352941},{0.6,0.69803921568627,0.94901960784314},{0.87058823529412,0.87058823529412,0.42352941176471},{0.49803921568627,0.8,0.098039215686275},{0.94901960784314,0.69803921568627,0.8},{0.29803921568627,0.29803921568627,0.29803921568627},{0.6,0.6,0.6},{0.29803921568627,0.6,0.69803921568627},{0.69803921568627,0.4,0.89803921568627},{0.2,0.4,0.8},{0.49803921568627,0.4,0.29803921568627},{0.34117647058824,0.65098039215686,0.30588235294118},{0.8,0.29803921568627,0.29803921568627},{0.066666666666667,0.066666666666667,0.066666666666667}}for k=0,15 do i.dirtyPalette[k]=true end end;local l=setmetatable({},{__name=\"Terminal\"})function l.close()end;function l.write(m)m=tostring(m)a(1,m,\"string\")if i.cursor.y<1 or i.cursor.y>h.height then return elseif i.cursor.x>h.width or i.cursor.x+#m<1 then i.cursor.x=i.cursor.x+#m;return elseif i.cursor.x<1 then m=m:sub(-i.cursor.x+2)i.cursor.x=1 end;local n=#m;if i.cursor.x+#m>h.width then m=m:sub(1,h.width-i.cursor.x+1)end;i[i.cursor.y][1]=i[i.cursor.y][1]:sub(1,i.cursor.x-1)..m..i[i.cursor.y][1]:sub(i.cursor.x+#m)i[i.cursor.y][2]=i[i.cursor.y][2]:sub(1,i.cursor.x-1)..i.colors.fg:rep(#m)..i[i.cursor.y][2]:sub(i.cursor.x+#m)i[i.cursor.y][3]=i[i.cursor.y][3]:sub(1,i.cursor.x-1)..i.colors.bg:rep(#m)..i[i.cursor.y][3]:sub(i.cursor.x+#m)i.cursor.x=i.cursor.x+n;i.dirtyLines[i.cursor.y]=true;l.redraw()end;function l.blit(m,o,p)m=tostring(m)a(1,m,\"string\")a(2,o,\"string\")a(3,p,\"string\")if#m~=#o or#o~=#p then error(\"Arguments must be the same length\",2)end;if i.cursor.y<1 or i.cursor.y>h.height then return elseif i.cursor.x>h.width or i.cursor.x<1-#m then i.cursor.x=i.cursor.x+#m;l.redraw()return elseif i.cursor.x<1 then m,o,p=m:sub(-i.cursor.x+2),o:sub(-i.cursor.x+2),p:sub(-i.cursor.x+2)i.cursor.x=1 end;local n=#m;if i.cursor.x+#m>h.width then m,o,p=m:sub(1,h.width-i.cursor.x+1),o:sub(1,h.width-i.cursor.x+1),p:sub(1,h.width-i.cursor.x+1)end;i[i.cursor.y][1]=i[i.cursor.y][1]:sub(1,i.cursor.x-1)..m..i[i.cursor.y][1]:sub(i.cursor.x+#m)i[i.cursor.y][2]=i[i.cursor.y][2]:sub(1,i.cursor.x-1)..o..i[i.cursor.y][2]:sub(i.cursor.x+#o)i[i.cursor.y][3]=i[i.cursor.y][3]:sub(1,i.cursor.x-1)..p..i[i.cursor.y][3]:sub(i.cursor.x+#p)i.cursor.x=i.cursor.x+n;i.dirtyLines[i.cursor.y]=true;l.redraw()end;function l.clear()for j=1,h.height do i[j]={(' '):rep(h.width),i.colors.fg:rep(h.width),i.colors.bg:rep(h.width)}i.dirtyLines[j]=true end;l.redraw()end;function l.clearLine()if i.cursor.y>=1 and i.cursor.y<=h.height then i[i.cursor.y]={(' '):rep(h.width),i.colors.fg:rep(h.width),i.colors.bg:rep(h.width)}i.dirtyLines[i.cursor.y]=true;l.redraw()end end;function l.getCursorPos()return i.cursor.x,i.cursor.y end;function l.setCursorPos(q,r)a(1,q,\"number\")a(2,r,\"number\")if q==i.cursor.x and r==i.cursor.y then return end;i.cursor.x,i.cursor.y=math.floor(q),math.floor(r)l.redraw()end;function l.getCursorBlink()return i.cursorBlink end;function l.setCursorBlink(s)a(1,s,\"boolean\")i.cursorBlink=s;l.redraw()end;function l.isColor()return true end;function l.getSize()return h.width,h.height end;function l.scroll(t)a(1,t,\"number\")if math.abs(t)>=h.width then for j=1,h.height do i[j]={(' '):rep(h.width),i.colors.fg:rep(h.width),i.colors.bg:rep(h.width)}end elseif t>0 then for k=t+1,h.height do i[k-t]=i[k]end;for k=h.height-t+1,h.height do i[k]={(' '):rep(h.width),i.colors.fg:rep(h.width),i.colors.bg:rep(h.width)}end elseif t<0 then for k=1,h.height+t do i[k-t]=i[k]end;for k=1,-t do i[k]={(' '):rep(h.width),i.colors.fg:rep(h.width),i.colors.bg:rep(h.width)}end else return end;for k=1,h.height do i.dirtyLines[k]=true end;l.redraw()end;function l.getTextColor()return tonumber(i.colors.fg)end;function l.setTextColor(u)a(1,u,\"number\")a.range(u,0,15)i.colors.fg=(\"%x\"):format(u)end;function l.getBackgroundColor()return tonumber(i.colors.bg)end;function l.setBackgroundColor(u)a(1,u,\"number\")a.range(u,0,15)i.colors.bg=(\"%x\"):format(u)end;function l.getPaletteColor(u)a(1,u,\"number\")a.range(u,0,15)return table.unpack(i.palette[math.floor(u)])end;function l.setPaletteColor(u,v,w,s)a(1,u,\"number\")a(2,v,\"number\")if w==nil and s==nil then v,w,s=bit32.band(bit32.rshift(v,16),0xFF)/255,bit32.band(bit32.rshift(v,8),0xFF)/255,bit32.band(v,0xFF)/255 end;a(3,w,\"number\")a(4,s,\"number\")a.range(u,0,15)if v<0 or v>1 then error(\"bad argument #2 (value out of range)\",2)end;if w<0 or w>1 then error(\"bad argument #3 (value out of range)\",2)end;if s<0 or s>1 then error(\"bad argument #4 (value out of range)\",2)end;i.palette[math.floor(u)]={v,w,s}i.dirtyPalette[math.floor(u)]=true;l.redraw()end;function l.getLine(j)a(1,j,\"number\")local x=i[j]return x and table.unpack(x,1,3)end;function l.getPosition()return c,d end;function l.reposition(y,j,e,f,z)a(1,y,\"number\",\"nil\")a(2,j,\"number\",\"nil\")c=y or c;d=j or d;if z then l.reparent(z)end;if y or j then l.redraw(true)end;if e or f then return l.resize(e,f)end end;function l.resize(A,B)a(1,A,\"number\",\"nil\")a(2,B,\"number\",\"nil\")if A>h.width then for j=1,h.height do i[j][1]=i[j][1]..(' '):rep(A-h.width)i[j][2]=i[j][2]..i.colors.fg:rep(A-h.width)i[j][3]=i[j][3]..i.colors.bg:rep(A-h.width)i.dirtyLines[j]=true end elseif A<h.width then for j=1,h.height do i[j][1]=i[j][1]:sub(1,A)i[j][2]=i[j][2]:sub(1,A)i[j][3]=i[j][3]:sub(1,A)end end;h.width=A;if B>h.height then for j=h.height+1,B do i[j]={(' '):rep(A),i.colors.fg:rep(A),i.colors.bg:rep(A)}i.dirtyLines[j]=true end elseif B<h.height then for j=B+1,h.height do i[j]=nil end end;h.height=B end;function l.reparent(z)a(1,z,\"Terminal\",\"nil\")b=z;l.redraw()end;function l.redraw(C)if not b or not g then return end;b.setCursorBlink(false)if C then b.clear()for j=1,h.height do b.setCursorPos(c,d+j-1)b.blit(i[j][1],i[j][2],i[j][3])end;for k=0,15 do b.setPaletteColor(k,i.palette[k][1],i.palette[k][2],i.palette[k][3])end else for j in pairs(i.dirtyLines)do b.setCursorPos(c,d+j-1)if#i[j][1]~=#i[j][2]or#i[j][2]~=#i[j][3]then error(\"Internal error: Invalid lengths\")end;b.blit(i[j][1],i[j][2],i[j][3])end;for k in pairs(i.dirtyPalette)do b.setPaletteColor(k,i.palette[k][1],i.palette[k][2],i.palette[k][3])end end;b.setCursorPos(c+i.cursor.x-1,d+i.cursor.y-1)b.setCursorBlink(i.cursorBlink)i.dirtyLines,i.dirtyPalette={},{}end;function l.restoreCursor()if not b or not g then return end;b.setCursorPos(c+i.cursor.x-1,d+i.cursor.y-1)b.setCursorBlink(i.cursorBlink)end;function l.isVisible()return g end;function l.setVisible(D)a(1,D,\"boolean\")g=D;l.redraw()end;l.isColour=l.isColor;l.getTextColour=l.getTextColor;l.setTextColour=l.setTextColor;l.getBackgroundColour=l.getBackgroundColor;l.setBackgroundColour=l.setBackgroundColor;l.getPaletteColour=l.getPaletteColor;l.setPaletteColour=l.setPaletteColor;l.redraw()return l end}\n",setuser=false,size=51622,modified=1757997041041,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["tar.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997042894,data="local a=require\"system.filesystem\"local function b(c)return string.match(c,'^()[%s%z]*$')and''or string.match(c,'^[%s%z]*(.*[^%s%z])')end;local function d(e,f,g)return string.len(e)<f and string.sub(e,1,f)..string.rep(g or\" \",f-string.len(e))or e end;local function h(i,j,...)if j and i[j]==nil then i[j]={}end;return j~=nil and h(i[j],...)or i end;local function k(e,l)local i={}for c in string.gmatch(e,\"([^\"..(l or\"%s\")..\"]+)\")do table.insert(i,c)end;return i end;local function m(n)return 0x38+(n.worldPermissions.read and 4 or 0)+(n.worldPermissions.write and 2 or 0)+(n.worldPermissions.execute and 1 or 0)+(n.permissions[n.owner].read and 256 or 0)+(n.permissions[n.owner].write and 128 or 0)+(n.permissions[n.owner].execute and 64 or 0)end;local o={verbosity=0,ignore_zero=false}function o.unserialize(p)local q={}local r={}for s,t in pairs(p)do local u=k(t.name,\"/\")local v=table.remove(u,table.maxn(u))local w=h(q,table.unpack(u))if t.type==0 or t.type==7 then w[v]=t elseif t.type==1 or t.type==2 then table.insert(r,t)elseif t.type==5 then w[v]={[\"//\"]=t}end end;for s,t in pairs(r)do local u=k(t.name,\"/\")local v=table.remove(u,table.maxn(u))h(q,table.unpack(u))[v]=h(q,table.unpack(k(t.link,\"/\")))end;return q end;function o.serialize(p)local q=p[\"//\"]~=nil and#p[\"//\"]>0 and{p[\"//\"]}or{}for s,t in pairs(p)do if s~=\"//\"then if t[\"//\"]~=nil or t.name==nil then local i=table.maxn(q)for x,y in ipairs(o.serialize(t))do q[i+x]=y end else table.insert(q,t)end end end;return q end;function o.load(z,A,B)if not B and not a.exists(z)then error(\"Path does not exist\",2)end;local C;if B then local c=1;C={read=function(D)if D then c=c+D;return string.sub(z,c-D,c-1)end;c=c+1;return string.byte(string.sub(z,c-1,c-1))end,close=function()end,seek=true}else C=a.open(z,\"rb\")end;local E=C.read;local F=0;local G=0;C.read=function(g)g=g or 1;if g<1 then return end;local q=nil;q=E(g)for H in q:gmatch(\".\")do F=F+H:byte()end;G=G+g;return q end;local q={}local I=0;while true do local p={}F=0;p.name=C.read(100)assert(G%512==100)if p.name==nil then break elseif p.name==string.rep(\"\\0\",100)then C.read(412)assert(G%512==0)I=I+1;if I==2 and not o.ignore_zero then break end else p.name=b(p.name)p.mode=tonumber(b(C.read(8)),8)p.owner=tonumber(b(C.read(8)),8)p.group=tonumber(b(C.read(8)),8)local J=tonumber(b(C.read(12)),8)p.timestamp=tonumber(b(C.read(12)),8)local K=F;local L=tonumber(b(C.read(8)),8)F=K+256;local i=C.read()p.type=tonumber(i==\"\\0\"and\"0\"or i)or i;p.link=b(C.read(100))if b(C.read(6))==\"ustar\"then C.read(2)p.ownerName=b(C.read(32))p.groupName=b(C.read(32))p.deviceNumber={tonumber(b(C.read(8))),tonumber(b(C.read(8)))}if p.deviceNumber[1]==nil and p.deviceNumber[2]==nil then p.deviceNumber=nil end;p.name=b(C.read(155))..p.name end;C.read(512-G%512)assert(G%512==0)if F~=L then print(\"Warning: checksum mismatch for \"..p.name)end;if J~=nil then if J==0 then p.data=\"\"else p.data=C.read(J)or\"\"if J%512~=0 then C.read(512-G%512)end end end;assert(G%512==0)table.insert(q,p)end end;C.close()return A and q or o.unserialize(q)end;function o.extract(p,z,M)a.mkdir(z)local r={}for s,t in pairs(p)do if s~=\"//\"then local N=a.combine(z,s)if t[\"//\"]~=nil then local x=o.extract(t,N,true)for O,y in pairs(x)do table.insert(r,y)end elseif t.type==1 or t.type==2 then table.insert(r,t)elseif t.type==0 or t.type==7 then local C=a.open(N,\"wb\")C.write(t.data)C.close()if t.owner~=nil then a.chmod(N,nil,bit32.band(t.mode,7))if t.ownerName~=nil and t.ownerName~=\"\"then a.chmod(N,t.ownerName,bit32.band(bit32.rshift(t.mode,3),7))a.chown(N,t.ownerName)elseif t.owner==0 then a.chmod(N,\"root\",bit32.band(bit32.rshift(t.mode,3),7))a.chown(N,\"root\")end end elseif t.type~=nil then print(\"Unimplemented type \"..t.type)end;if o.verbosity>0 then print((t[\"//\"]and t[\"//\"].name or t.name or\"?\")..\" => \"..(N or\"?\"))end end end;if M then return r else for s,t in pairs(r)do end end end;function o.read(P,N)local z=a.combine(P,N)local n=a.stat(z)if not n then return nil end;local C=a.open(z,\"rb\")local q={name=N,mode=m(n),owner=0,group=0,timestamp=n.modified,type=0,link=\"\",ownerName=n.owner,groupName=\"\",deviceNumber=nil,data=C.readAll()}C.close()return q end;function o.pack(P,z)local n=a.stat(a.combine(P,z))if n.type~=\"directory\"then return o.read(P,z)end;local q={[\"//\"]={name=z..\"/\",mode=m(n),owner=0,group=0,timestamp=n.modified,type=5,link=\"\",ownerName=n.owner,groupName=\"\",deviceNumber=nil,data=nil}}if string.sub(P,-1)==\"/\"then P=string.sub(P,1,-1)end;if z and string.sub(z,1,1)==\"/\"then z=string.sub(z,2)end;if z and string.sub(z,-1)==\"/\"then z=string.sub(z,1,-1)end;local N=z and P..\"/\"..z or P;for s,t in pairs(a.list(N))do if a.isDir(a.combine(N,t))then q[t]=o.pack(P,z and z..\"/\"..t or t)else q[t]=o.read(P,z and z..\"/\"..t or t)end;if o.verbosity>0 then print(a.combine(N,t)..\" => \"..(z and z..\"/\"..t or t))end end;return q end;function o.save(p,z,A)if not A then p=o.serialize(p)end;local Q=z==nil;local C;local G=0;if not Q then C=a.open(z,\"wb\")local R=C.write;C.write=function(e)for g in string.gmatch(e,\".\")do R(string.byte(g))end;G=G+string.len(e)end else C=\"\"end;for s,t in pairs(p)do local S=\"\"S=S..d(string.sub(t.name,-100),100,\"\\0\")S=S..(t.mode and string.format(\"%07o\\0\",t.mode)or string.rep(\"\\0\",8))S=S..(t.owner and string.format(\"%07o\\0\",t.owner)or string.rep(\"\\0\",8))S=S..(t.group and string.format(\"%07o\\0\",t.group)or string.rep(\"\\0\",8))S=S..(t.data and string.format(\"%011o\\0\",string.len(t.data))or string.rep(\"0\",11)..\"\\0\")S=S..(t.timestamp and string.format(\"%011o\\0\",t.timestamp)or string.rep(\"\\0\",12))S=S..t.type;S=S..(t.link and d(t.link,100,\"\\0\")or string.rep(\"\\0\",100))S=S..\"ustar  \\0\"S=S..(t.ownerName and d(t.ownerName,32,\"\\0\")or string.rep(\"\\0\",32))S=S..(t.groupName and d(t.groupName,32,\"\\0\")or string.rep(\"\\0\",32))S=S..(t.deviceNumber and t.deviceNumber[1]and string.format(\"%07o\\0\",t.deviceNumber[1])or string.rep(\"\\0\",8))S=S..(t.deviceNumber and t.deviceNumber[2]and string.format(\"%07o\\0\",t.deviceNumber[2])or string.rep(\"\\0\",8))S=S..(string.len(t.name)>100 and d(string.sub(t.name,1,-101),155,\"\\0\")or string.rep(\"\\0\",155))if string.len(S)<504 then S=S..string.rep(\"\\0\",504-string.len(S))end;local F=256;for g in string.gmatch(S,\".\")do F=F+string.byte(g)end;S=string.sub(S,1,148)..string.format(\"%06o\\0 \",F)..string.sub(S,149)if Q then C=C..S else C.write(S)end;if t.data~=nil and t.data~=\"\"then if Q then C=C..d(t.data,math.ceil(string.len(t.data)/512)*512,\"\\0\")else C.write(d(t.data,math.ceil(string.len(t.data)/512)*512,\"\\0\"))end end end;if Q then C=C..string.rep(\"\\0\",1024)else C.write(string.rep(\"\\0\",1024))end;if Q then C=C..string.rep(\"\\0\",10240-string.len(C)%10240)else C.write(string.rep(\"\\0\",10240-G%10240))end;if not Q then C.close()end;if Q then return C end end;return o\n",setuser=false,size=6722,modified=1757997042881,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},fuse={permissions={root={write=true,read=true,execute=true}},created=1757997040758,contents={["ftp.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040615,data="local a,b=...local c=require\"ftp\"local d=require\"system.sync\"local e,f,g,h=a:match\"ftp://([^:]+):([^@]+)@([^:]+):(%d+)\"if not e then e,f,g=a:match\"ftp://([^:]+):([^@]+)@([^:/]+)\"if not e then e,g,h=a:match\"ftp://([^:]+)@([^:]+):(%d+)\"if not e then e,g=a:match\"ftp://([^:]+)@([^:/]+)\"if not e then g,h=a:match\"ftp://([^:]+):(%d+)\"if not g then g=a:match\"ftp://([^:/]+)\"if not g then error(\"Malformed URL\")end end end end end end;local i=c.client(g,h,b.pasv,tonumber(b.timeout))if e then i:login(e,f)end;local j=d.mutex.new()local k={}function k:open(l,m,n)return d.lockGuard(j,i.open,i,\"/\"..m,n)end;function k:list(l,m)return d.lockGuard(j,i.list,i,\"/\"..m)end;function k:stat(l,m)return d.lockGuard(j,i.stat,i,\"/\"..m)end;function k:remove(l,m)return d.lockGuard(j,i.remove,i,\"/\"..m)end;function k:rename(l,m,o)return d.lockGuard(j,i.rename,i,\"/\"..m,\"/\"..o)end;function k:mkdir(l,m)return d.lockGuard(j,i.mkdir,i,\"/\"..m)end;function k:unmount(l)return d.lockGuard(j,i.close,i)end;function k:init(l)i.connection:transfer()end;return k\n",setuser=false,size=1032,modified=1757997040590,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"},["githubfs.lua"]={permissions={root={read=true,write=true,execute=false}},created=1757997040758,data="local a,b=...local c=require\"system.network\"local d=require\"system.serialization\"local e,f,g=a:match\"^https?://([^@]+)@github.com/([^/]+)/([^/]+).git$\"if not e then e,f,g=a:match\"^https?://([^@]+)@github.com/([^/]+)/([^/]+)/?$\"if not e then f,g=a:match\"^https?://github.com/([^/]+)/([^/]+).git$\"if not f then f,g=a:match\"^https?://github.com/([^/]+)/([^/]+)/?$\"if not f then error(\"Malformed URL\")end end end end;e=e or b.token;local h={}local i={}local function j(k)if i[k]~=nil then return i[k]or nil end;local l=\"https://api.github.com/repos/\"..f..\"/\"..g..\"/contents/\"..c.urlEncode(k)if b.branch then l=l..\"?ref=\"..b.branch end;local m,n=c.getData(l,{Accept=\"application/vnd.github.object+json\",Authorization=e and\"Bearer \"..e,[\"X-GitHub-Api-Version\"]=\"2022-11-28\"})if not m or n<200 or n>=300 then i[k]=false;return nil,n end;m=d.json.decode(m)i[k]=m or false;return m end;function h:open(o,k,p)if k==\".githubfs-flush-cache\"and(p==\"w\"or p==\"wb\")then i={}return{write=function()end,writeLine=function()end,flush=function()end,close=function()end,seek=function()end}end;if p~=\"r\"and p~=\"rb\"then return nil,\"Read-only filesystem\"end;local q,n=j(k)if not q then return nil,n end;if q.type~=\"file\"then return nil,\"Not a file\"end;return c.getData(q.download_url,{Accept=\"application/vnd.github.object+json\",Authorization=e and\"Bearer \"..e,[\"X-GitHub-Api-Version\"]=\"2022-11-28\"})end;function h:list(o,k)local q=assert(j(k))if q.type~=\"dir\"then error(\"Not a directory\",2)end;local r={}for s,t in ipairs(q.entries)do r[s]=t.name end;return r end;function h:stat(o,k)local q,n=j(k)if not q then return q,n end;local u={type=q.type,size=q.size,created=0,modified=0,owner=f,capacity=0,freeSpace=0,permissions={},worldPermissions={read=true,write=false,execute=true},setuser=false}if q.type==\"dir\"then u.type=\"directory\"end;return u end;function h:remove(o,k)error(\"Read-only filesystem\",2)end;function h:rename(o,k,v)error(\"Read-only filesystem\",2)end;function h:mkdir(o,k)error(\"Read-only filesystem\",2)end;function h:unmount(o)end;function h:init(o)end;return h\n",setuser=false,size=2056,modified=1757997040750,worldPermissions={read=true,write=false,execute=false},type="file",owner="root"}},size=0,modified=1757997040758,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"}},setuser=false,size=0,modified=1757997043456,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},root={permissions={root={write=true,read=true,execute=true}},created=1757997043457,contents={},size=0,modified=1757997043457,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},bin={permissions={root={write=true,read=true,execute=true}},created=1757997043420,contents={["link.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039919,data="return coroutine.yield(\"syscall\",\"link\",...)\n",setuser=false,size=45,modified=1757997039883,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["yellowbox.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997043420,data="local a=require\"system.filesystem\"local b=require\"system.keys\"local c=require\"system.ipc\"local d=require\"system.process\"local e=require\"system.terminal\"local f=require\"system.util\"local function g(h,i)return h[b.getName(i)]end;local function j(k)local h=f.syscall.loadCraftOSAPI(\"keys\")local l=f.syscall.callmodule(\"yellowbox\",\"getTTY\",k)local m=assert(e.openterm())do local n=l.textBuffer;for o=1,l.size.height do m.setCursorPos(1,o)m.blit(n[o][1],n[o][2],n[o][3])end;for p=0,15 do m.setPaletteColor(p,table.unpack(n.palette[p]))end;m.setCursorPos(n.cursor.x,n.cursor.y)m.setCursorBlink(n.cursorBlink)end;while true do local q,r=coroutine.yield()if q==\"tty_redraw\"and r.id==l.id then local n=l.textBuffer;for o=1,l.size.height do m.setCursorPos(1,o)m.blit(n[o][1],n[o][2],n[o][3])end;for p=0,15 do m.setPaletteColor(p,table.unpack(n.palette[p]))end;m.setCursorPos(n.cursor.x,n.cursor.y)m.setCursorBlink(n.cursorBlink)elseif q==\"key\"then c.sendEvent(k,\"key\",{g(h,r.keycode),r.isRepeat})elseif q==\"key_up\"then c.sendEvent(k,\"key_up\",{g(h,r.keycode)})elseif q==\"char\"then c.sendEvent(k,\"char\",{r.character})elseif q==\"paste\"then c.sendEvent(k,\"paste\",{r.text})elseif q==\"mouse_click\"or q==\"mouse_up\"or q==\"mouse_drag\"then c.sendEvent(k,q,{r.button,r.x,r.y})elseif q==\"mouse_scroll\"then c.sendEvent(k,q,{r.direction,r.x,r.y})end end;m.close()end;local s=...if s==\"status\"then print(\"Running boxes:\")local t=d.getplist()for u,v in ipairs(t)do local w=d.getpinfo(v)if w.name==\"[yellowbox]\"then print(\"- PID \"..v..\", running as \"..w.user)end end elseif s==\"start\"then if d.getuser()~=\"root\"then error(\"Starting a box requires root privileges.\")end;local x=f.argparse({p=true,peripherals=\"@p\",b=true,bios=\"@b\",r=true,root=\"@r\",u=true,user=\"@u\",i=false,interactive=\"@i\",http=false,[\"no-http\"]=false},select(2,...))local y={root=\"/var/lib/yellowbox\",user=select(2,d.getuser()),bios=\"/var/lib/yellowbox/bios.lua\",peripherals={}}if x.b then y.bios=x.b end;if x.r then y.root=x.r end;if x.u then y.user=x.u end;if x.http then y.http=true end;if x[\"no-http\"]then y.http=false end;if x.p then for w in x.p:gmatch\"[^,;]+\"do local z,A=w:match\"^([^=]+)=(.+)$\"if not z then error(\"bad argument 'p' (invalid format)\")end;y.peripherals[z]=A end end;local B=assert(io.open(y.bios,\"r\"))y.bios=B:read(\"*a\")B:close()if not a.exists(a.combine(y.root,\"rom/startup.lua\"))then a.mkdir(a.combine(y.root,\"rom\"))a.mount(\"craftos\",\"rom\",a.combine(y.root,\"rom\"),{ro=true})end;local C=f.syscall.callmodule(\"yellowbox\",\"create\",y)print(\"* Started box at PID \"..C)if x.i then j(C)end elseif s==\"stop\"then if d.getuser()~=\"root\"then error(\"Stopping a box requires root privileges.\")end;f.syscall.callmodule(\"yellowbox\",\"stop\",assert(tonumber(select(2,...))))elseif s==\"shutdown\"or s==\"reboot\"then f.syscall.callmodule(\"yellowbox\",s,assert(tonumber(select(2,...))))elseif s==\"view\"then return j(assert(tonumber(select(2,...)),\"argument must be a number\"))elseif s==\"get-bios\"then else error(\"Usage: yellowbox <status|start|stop|shutdown|reboot|view|get-bios> [...]\")end\n",setuser=false,size=3032,modified=1757997043404,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["clear.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039910,data="io.write(\"\\x1b[0m\\x1b[2J\\x1b[H\")\n",setuser=false,size=33,modified=1757997039869,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["reboot.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039926,data="return coroutine.yield(\"syscall\",\"devcall\",\"/\",\"reboot\")\n",setuser=false,size=57,modified=1757997039891,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["mv.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039923,data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=assert(b.argparse({i=false,f=false},...))if#c<2 then error(\"mv: missing operand\")end;local d=table.remove(c)local e=a.stat(d)if#c==1 and(not e or e.type~=\"directory\")then if e and not c.f and(not a.effectivePermissions(e).write and b.syscall.istty()or c.i)then io.stderr:write(\"mv: overwrite \"..e.type..\" \"..d..\"? \")local f=io.read()if f:lower()~=\"y\"then return false end end;a.move(c[1],d)return end;if not e or e.type~=\"directory\"then error(\"mv: \"..d..\": not a directory\")end;for g,h in ipairs(c)do local i=a.combine(d,a.basename(h))e=a.stat(i)if e and not c.f and(not a.effectivePermissions(e).write and b.syscall.istty()or c.i)then io.stderr:write(\"mv: overwrite \"..e.type..\" \"..i..\"? \")local f=io.read()if f:lower()~=\"y\"then return false end end;a.move(h,i)end\n",setuser=false,size=836,modified=1757997039888,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["rmdir.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039928,data="local a=require\"system.filesystem\"local b=false;local function c(d)if not a.isDir(d)or#a.list(d)>0 then error(\"rmdir: \"..d..\": directory not empty\")end;a.remove(d)if b and d:find\"/\"then return c(a.dirname(d))end end;for e,f in ipairs{...}do if f==\"-p\"then b=true else c(f)end end\n",setuser=false,size=280,modified=1757997039893,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["df.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039913,data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=assert(b.argparse({k=false,P=false,t=false,h=false},...))local d=a.mountlist()local e={}if#c==0 then for f,g in ipairs(d)do e[f],g.stat=g,a.stat(g.path)end else for f,g in ipairs(c)do local h,i=a.stat(g)if h then for j,k in ipairs(d)do if k.path==h.mountpoint then e[f],k.stat=k,h;break end end else io.stderr:write(\"df: could not stat \"..g..\": \"..(i or\"\")..\"\\n\")end end end;local function l(m)if m==math.huge then return\"inf\"elseif m~=m then return\"nan\"else return tostring(m)end end;if c.P then local n=c.k and 1024 or 512;print(\"Filesystem \"..n..\"-blocks Used Available Capacity Mounted on\")for j,g in ipairs(e)do print((\"%s %s %s %s %s%% %s\"):format(g.source,l(math.ceil(g.stat.capacity/n)),l(math.ceil((g.stat.capacity-g.stat.freeSpace)/n)),l(math.ceil(g.stat.freeSpace/n)),l(math.floor((g.stat.capacity-g.stat.freeSpace)/g.stat.capacity*100)),g.path))end elseif c.h then local function o(m)if m==math.huge then return\"inf\"elseif m~=m then return\"nan\"elseif m>=1000000000000 then return(\"%.3gT\"):format(m/1000000000000)elseif m>=1000000000 then return(\"%.3gG\"):format(m/1000000000)elseif m>=1000000 then return(\"%.3gM\"):format(m/1000000)elseif m>=1000 then return(\"%.3gK\"):format(m/1000)else return(\"%.3g \"):format(m)end end;print(\"Filesystem\\tSize\\tUsed\\tAvail\\tUse%\\tMounted on\")for j,g in ipairs(e)do print((\"%s\\t%s\\t%s\\t%s\\t%s%%\\t%s\"):format(g.source..(#g.source<8 and\"\\t\"or\"\"),o(g.stat.capacity),o(g.stat.capacity-g.stat.freeSpace),o(g.stat.freeSpace),l(math.floor((g.stat.capacity-g.stat.freeSpace)/g.stat.capacity*100)),g.path))end else local n=c.k and 1024 or 512;print(\"Filesystem\\tSize\\tUsed\\tAvail\\tUse%\\tMounted on\")for j,g in ipairs(e)do print((\"%s\\t%s\\t%s\\t%s\\t%s%%\\t%s\"):format(g.source..(#g.source<8 and\"\\t\"or\"\"),l(math.ceil(g.stat.capacity/n)),l(math.ceil((g.stat.capacity-g.stat.freeSpace)/n)),l(math.ceil(g.stat.freeSpace/n)),l(math.floor((g.stat.capacity-g.stat.freeSpace)/g.stat.capacity*100)),g.path))end end\n",setuser=false,size=2006,modified=1757997039873,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["mount.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039923,data="local a=require\"system.filesystem\"local b=require\"system.util\"if select(\"#\",...)==0 then for c,d in ipairs(a.mountlist())do local e={}for f,g in pairs(d.options)do if g==true then e[#e+1]=f elseif type(g)==\"string\"then e[#e+1]=g elseif type(g)==\"number\"then e[#e+1]=tostring(g)end end;print((\"%s on %s type %s (%s)\"):format(d.source,d.path,d.type,table.concat(e,\",\")))end;return end;local h={}local i=a.open(\"/etc/fstab\",\"r\")if i then for j in i.readLine do local k,l,type,e,c,m=j:gsub(\"#.*\",\"\"):match(\"(%S+)%s+(%S+)%s+(%S+)%s+(%S+)%s+(%S+)%s+(%S+)\")if k then k=k:gsub(\"\\\\([0-3][0-7][0-7])\",function(n)return string.char(tonumber(n,8))end):gsub(\"\\\\x(%x%x)\",function(n)return string.char(tonumber(n,16))end)l=l:gsub(\"\\\\([0-3][0-7][0-7])\",function(n)return string.char(tonumber(n,8))end):gsub(\"\\\\x(%x%x)\",function(n)return string.char(tonumber(n,16))end)local o={}for p in e:gmatch\"[^,]+\"do local f,d=p:match\"([^=]+)=?(.*)\"if f==\"defaults\"then o.rw=true;o.suid=true;o.dev=true;o.exec=true;o.auto=true;o.owner=true;o.async=true else if not f then f,d=p,true end;o[f]=d end end;h[k]={src=k,dest=l,type=type,options=o,check=tonumber(m)}h[#h+1]=h[k]end end end;local q=assert(b.argparse({t=true,o=true,a=false},...))if q.a then local r=true;for c,d in ipairs(h)do if d.options.auto and not d.options.noauto then local s,t=pcall(a.mount,d.type,d.src,d.dest,d.options)if not s and not d.options.nofail then io.stderr:write(\"mount: could not mount \"..d.src..\": \"..t..\"\\n\")r=false end end end;return r end;if q[1]and not q[2]and h[q[1]]then q[2]=h[q[1]].dest end;if#q<2 then error(\"Usage: mount [-t type] [-o options] device [mountpoint]\\n       mount -a\")end;local type=q.t or h[q[1]]and h[q[1]].type or\"craftos\"local o=h[q[1]]and h[q[1]].options or{rw=true,suid=true,dev=true,exec=true,auto=true,owner=true,async=true}if q.o then for p in q.o:gmatch\"[^,]+\"do local f,d=p:match\"([^=]+)=(.*)\"if not f then f,d=p,true end;o[f]=d end end;return a.mount(type,q[1],q[2],o)\n",setuser=false,size=1959,modified=1757997039887,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["echo.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039914,data="print(...)\n",setuser=false,size=11,modified=1757997039875,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["attach.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039906,data="local a={...}if type(a[1])~=\"string\"or type(a[2])~=\"string\"then print(\"Usage: attach <side> <type> [options...]\")else if tonumber(a[3])~=nil then a[3]=tonumber(a[3])end;local b,c,d=coroutine.yield(\"syscall\",\"attach\",a[1],a[2],a[3])if not b then io.stderr:write(\"Could not attach peripheral\"..(c and\": \"..c or\"\")..\"\\n\")elseif not c then io.stderr:write(\"Could not attach peripheral\"..(d and\": \"..d or\"\")..\"\\n\")end end\n",setuser=false,size=417,modified=1757997039864,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["apropos.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039905,data="return coroutine.yield(\"syscall\",\"exec\",\"/bin/man\",\"-k\",...)\n",setuser=false,size=61,modified=1757997039863,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["redstone.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039926,data="local a=require\"system.hardware\"local b=require\"system.util\"local c={...}if c[1]==\"probe\"then local d=false;print(\"Redstone inputs:\")local e={}for f,g in ipairs(a.children(\"/redstone\"))do local h=a.wrap(\"/redstone/\"..g)local i=h.bundledInput;if i and i>0 then d=true end;local j=h.input;if j then e[#e+1]=g..\" (\"..j..\")\"end end;if#e>0 then print(table.concat(e,\", \"))else print(\"None.\")end;if d then print()print(\"Bundled inputs:\")local k={[0]=\"white\",\"orange\",\"magenta\",\"lightBlue\",\"yellow\",\"lime\",\"pink\",\"gray\",\"lightGray\",\"cyan\",\"purple\",\"blue\",\"brown\",\"green\",\"red\",\"black\"}for f,g in ipairs(a.children(\"/redstone\"))do local h=a.wrap(\"/redstone/\"..g)local i=h.bundledInput;if i and i>0 then io.write(g..\": \")local e={}for l=0,15 do if bit32.btest(i,2^l)then e[#e+1]=k[l]end end;print(table.concat(e,\", \"))end end end elseif c[1]==\"set\"then if#c<3 then error(\"Usage: redstone set <side> [color] <value>\")end;local h=assert(a.wrap(\"/redstone/\"..c[2]),\"Not a side\")if#c>=4 then if not h.bundledOutput then error(\"Bundled output is not available\")end;local k={white=0,orange=1,magenta=2,lightBlue=3,yellow=4,lime=5,pink=6,gray=7,grey=7,lightGray=8,lightGrey=8,cyan=9,purple=10,blue=11,brown=12,green=13,red=14,black=15}local m=2^assert(k[c[3]],\"Invalid color\")if c[4]:lower()==\"true\"then h.bundledOutput=bit32.bor(h.bundledOutput,m)else h.bundledOutput=bit32.band(h.bundledOutput,bit32.bnot(m))end else local n;if c[3]:lower()==\"true\"then n=15 else n=tonumber(c[3])or 0 end;h.output=n end elseif c[1]==\"pulse\"then if#c<4 then error(\"Usage: redstone pulse <side> <count> <period>\")end;local h=assert(a.wrap(\"/redstone/\"..c[2]),\"Not a side\")local o=tonumber(c[3])or 1;local p=tonumber(c[4])or 0.5;for f=1,o do h.output=true;b.sleep(p/2)h.output=false;b.sleep(p/2)end else print(\"Usage: redstone <probe|set|pulse> ...\")end\n",setuser=false,size=1820,modified=1757997039891,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["ar.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039663,data="local a=require\"ar\"local function b(c,d,e)return string.len(c)<d and string.sub(c,1,d)..string.rep(e or\" \",d-string.len(c))or c end;local function f(g,c,e)local h=\"\"for i=1,string.len(c)do h=h..(bit32.band(g,bit32.lshift(1,string.len(c)-i))==0 and e or string.sub(c,i,i))end;return h end;local j={...}if#j<2 then error(\"Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]\")end;if j[1]==\"--version\"then print(\"Phoenix ar (baseutils) 1.0 (compatible with GNU/BSD ar)\\nCopyright (c) 2019-2022 JackMacWindows.\")return 2 end;local k=nil;local l=false;local m=false;if string.find(j[1],\"d\")then k=0 end;if string.find(j[1],\"p\")then k=1 end;if string.find(j[1],\"q\")then k=2 end;if string.find(j[1],\"r\")then k=3 end;if string.find(j[1],\"t\")then k=4 end;if string.find(j[1],\"x\")then k=5 end;if string.find(j[1],\"c\")then a.verbosity=-1 end;if string.find(j[1],\"v\")then a.verbosity=1 end;if string.find(j[1],\"u\")then l=true end;if string.find(j[1],\"T\")then m=true end;if string.find(j[1],\"f\")then m=true end;local n=a.load(j[2])local o={...}table.remove(o,1)table.remove(o,1)if n==nil then if a.verbosity>-1 then print(\"ar: Creating archive \"..j[2])end;n={}end;if k==0 then for p,q in pairs(n)do for r,s in pairs(o)do if q.name==s then n[p]=nil;break end end end;a.save(n,j[2])elseif k==1 then if#j>2 then for p,q in pairs(n)do for r,s in pairs(o)do if q.name==s then print(q.data)break end end end else for p,q in pairs(n)do print(q.data)end end elseif k==2 then for p,q in pairs(o)do local t=a.read(q)t.name=string.sub(t.name,1,m and 15 or nil)table.insert(n,t)end;a.save(n,j[2])elseif k==3 then for p,q in pairs(o)do local t=a.read(q)t.name=string.sub(t.name,1,m and 15 or nil)local u=false;for r,s in pairs(n)do if s.name==t.name then u=true;for v,w in pairs(t)do s[v]=t[v]end;break end end;if not u then table.insert(n,t)end end;a.save(n,j[2])elseif k==4 then if a.verbosity>0 then local x={}local y={0,0,0,0,0}for p,q in pairs(n)do local z=os.date(\"%c\",q.timestamp or 0)local A={f(q.mode,\"rwxrwxrwx\",\"-\"),q.owner..\"/\"..q.group,string.len(q.data),z,q.name}for r,s in pairs(A)do if string.len(s)+3>y[r]then y[r]=string.len(s)+3 end end;table.insert(x,A)end;for p,q in pairs(x)do for r,s in pairs(q)do io.write(b(s,y[r]))end;print(\"\")end else for p,q in pairs(n)do print(q.name)end end elseif k==5 then local B=#o>0 and table.remove(o,1)or\".\"local t;if#o>0 then t={}for p,q in pairs(n)do for r,s in pairs(o)do if q.name==s then table.insert(t,q)break end end end else t=n end;a.extract(t,B)else error(\"Unknown mode\")end\n",setuser=false,size=2516,modified=1757997039660,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["tty.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039930,data="local a=require\"system.process\"local b=a.getpinfo(a.getpid())if b.stdout then print(\"tty\"..b.stdout)end\n",setuser=false,size=104,modified=1757997039896,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["du.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039914,data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=assert(b.argparse({a=false,s=false,k=false,h=false,x=false,H=false,L=false},...))if#c==0 then c[1]=\".\"end;local d=0;local function e(f)if c.h then if f>=1000000000000 then return(\"%.3gT\"):format(f/1000000000000)elseif f>=1000000000 then return(\"%.3gG\"):format(f/1000000000)elseif f>=1000000 then return(\"%.3gM\"):format(f/1000000)elseif f>=1000 then return(\"%.3gK\"):format(f/1000)else return(\"%.3g \"):format(f)end elseif c.k then return math.ceil(f/1024)else return math.ceil(f/512)end end;local function g(h,i,j)local k,l=a.stat(h,not(j and c.H or c.L))if k then if i==true then i=k.mountpoint end;if i and i~=k.mountpoint then return 0 end;if k.type==\"directory\"then local m=0;for n,o in ipairs(a.list(h))do m=m+g(a.combine(h,o),i)end;if not c.s then print(e(m),h)end;return m else if c.a and not c.s then print(e(k.size),h)end;return k.size end else io.stderr:write(\"du: could not stat \"..h..\": \"..(l or\"\")..\"\\n\")d=1;return 0 end end;for n,o in ipairs(c)do local m=g(o,c.x,true)if c.s then print(e(m),o)end end;return d\n",setuser=false,size=1092,modified=1757997039875,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["cmp.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039910,data="local a=require\"system.util\"local b=assert(a.argparse({l=false,s=false},...))if#b<2 then error(\"usage: cmp [-ls] <file1> <file2>\")end;local c,d;if b[1]==\"-\"then c=io.stdin else c=io.open(b[1],\"rb\")end;if b[2]==\"-\"then d=io.stdin else d=io.open(b[2],\"rb\")end;local function e(f)if c~=io.stdin then c:close()end;if d~=io.stdin then d:close()end;return f end;if c==d then return e(0)end;local g,h=1,0;for i=1,math.huge do local j=c:read(1)local k=d:read(1)if j~=k then h=1;if not j then if not b.s then io.stderr:write(\"cmp: EOF on \"..b[1]..\"\\n\")end elseif not k then if not b.s then io.stderr:write(\"cmp: EOF on \"..b[2]..\"\\n\")end elseif not b.s then if b.l then io.write(i..\" \"..j..\" \"..k..\"\\n\")else io.write((\"%s %s differ: char %d, line %d\\n\"):format(b[1],b[2],i,g))end end;if not b.l then return e(1)end end;if j==\"\\n\"then g=g+1 end;if not j or not k then break end end;return e(h)\n",setuser=false,size=883,modified=1757997039870,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["compress.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039911,data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=string.char;local type=type;local d=string.sub;local e=math.floor;local f={}for g=0,255 do local h=c(g)f[h]=g end;local function i(j,k,l,m)if l>=256 then l,m=0,m+1;if m>=256 then k={}m=1 end end;k[j]=m*256+l;l=l+1;return k,l,m end;local function n(o,p)if type(o)~=\"string\"then return nil,\"string expected, got \"..type(o)end;local q=#o;local k={}local l,m=1,1;local r=\"\"local s,t,u,v=9,\"\\x1F\\x9D\\x90\",0,0;for g=1,q do local w=d(o,g,g)local x=r..w;if not(f[x]or k[x])then local y=f[r]or k[r]if not y then return nil,\"algorithm error, could not fetch word\"end;u=u+y*2^v;v=v+s;while v>=8 do t=t..c(u%256)u=e(u/256)v=v-8 end;if m<p then k,l,m=i(x,k,l,m)if l==1 and m==2^(s-8)then if v>0 then t=t..c(u%256)end;u=0;v=0;s=s+1 end end;r=w else r=x end end;u=u+(f[r]or k[r])*2^v;v=v+s;while v>=8 do t=t..c(u%256)u=e(u/256)v=v-8 end;if v>0 then t=t..c(u)end;return t end;local z=assert(b.argparse({b=\"number\",c=false,f=false,k=false,v=false},...))local A;if z[1]==\"-\"or z[1]==nil then A=io.read(\"*a\")else local B=assert(io.open(z[1],\"rb\"))A=B:read(\"*a\")B:close()end;local C=n(A,z.b and 2^(z.b-8)or 256)if z.v then io.stderr:write((\"%s: %.3g%%\\n\"):format(z[1],#C/#A*100))end;if z.c then io.write(C)return end;if not z.f and#C>#A then return 2 end;if not z.f and a.exists(z[1]..\".Z\")then io.write(\"replace file \"..z[1]..\".Z? (y/N) \")local D=io.read()if D~=\"Y\"and D~=\"y\"then return 1 end end;local B=assert(io.open(z[1]..\".Z\",\"wb\"))B:write(C)B:close()if not z.k then os.remove(z[1])end\n",setuser=false,size=1542,modified=1757997039871,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["touch.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039929,data="for a,b in ipairs{...}do if b:sub(1,1)~=\"-\"then assert(io.open(b,\"a\")):close()end end\n",setuser=false,size=86,modified=1757997039895,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["logger.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039919,data="local a=require\"system.log\"local b=require\"system.process\"local c=require\"system.util\"local d={[0]=\"Debug\",\"Info\",\"Notice\",\"Warning\",\"Error\",\"Critical\",\"Panic\"}local e={[0]='\\27[90m','\\27[97m','\\27[36m','\\27[93m','\\27[31m','\\27[95m','\\27[96m'}local f={...}local g=table.remove(f,1)if g==\"log\"then f=assert(c.argparse({c=true,l=true,m=true,n=true},table.unpack(f)))a.log({name=f.n,level=f.l,category=f.c,module=f.m},table.unpack(f))elseif g==\"create\"then f=assert(c.argparse({F=true,s=false},table.unpack(f)))if not f[1]then error(\"Usage: logger create [-F <file>] [-s] <log>\")end;a.create(f[1],f.s,f.F)elseif g==\"delete\"then f=assert(c.argparse({p=true},table.unpack(f)))if not f[1]then error(\"Usage: logger delete [-p] <log>\")end;a.remove(f[1])if f.p then os.remove(\"/var/log/\"..f[1]..\".log\")end elseif g==\"view\"then if not f[1]then error(\"Usage: logger view <log>\")end;b.run(\"/bin/less\",\"/var/log/\"..f[1]..\".log\")elseif g==\"follow\"then f=assert(c.argparse({f=true},table.unpack(f)))if not f[1]then error(\"Usage: logger follow [-f <filter>] <log>\")end;a.open(f[1],f.f)print(\"Listening for messages...\")while true do local h,i=coroutine.yield()if h==\"syslog\"then if i.traceback then i.message=i.message:gsub(\"\\t\",\"  \"):gsub(\"([^\\n]+):(%d+):\",\"\\27[96m%1\\27[37m:\\27[95m%2\\27[37m:\"):gsub(\"'([^']+)'\\n\",\"\\27[93m'%1'\\27[37m\\n\")end;local j=b.getpinfo(i.process)print((\"%s[%s]%s %s[%d%s]%s [%s]: %s\\27[0m\"):format(e[i.level],os.date(\"%b %d %X\",i.time/1000),i.category and\" <\"..i.category..\">\"or\"\",j and j.name or\"(unknown)\",i.process,i.thread and\":\"..i.thread or\"\",i.module and\" (\"..i.module..\")\"or\"\",d[i.level],i.message))end end else error(\"Usage: logger <log|create|delete|view|follow> ...\")end\n",setuser=false,size=1691,modified=1757997039883,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["dirname.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039913,data="local a=require\"system.filesystem\"print(a.dirname(...))\n",setuser=false,size=56,modified=1757997039874,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["basename.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039906,data="local a=assert(...,\"basename: missing path\")if a==\"\"then print\".\"elseif a:match\"^/+$\"then print\"/\"else local b=a:gsub(\"/+$\",\"\"):match\"[^/]+$\"local c=select(2,...)if c and b~=c then b=b:gsub(c..\"$\",\"\")end;print(b)end\n",setuser=false,size=216,modified=1757997039864,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["lua.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039921,data="local a=require\"system.pretty\"local b=require\"system.terminal\"local c=require\"system.util\"local d=assert(c.argparse({h=false,help=false,e=true,l=true,i=false,v=false},...))for e,f in ipairs(d)do if f==\"--\"then table.remove(d,e)break end end;if d.h then print[=[\nusage: lua [options] [script [args]].\nAvailable options are:\n  -e stat  execute string 'stat'\n  -l name  require library 'name'\n  -i       enter interactive mode after executing 'script'\n  -v       show version information\n  --       stop handling options\n  -        execute stdin and stop handling options\n]=]return 0 elseif d.v then print(_VERSION,\"Copyright (C) 2021 JackMacWindows\")return 0 end;if d.l then _ENV[d.l]=require(d.l)end;if d.e then assert(load(d.e,\"=(command line)\",\"t\"))()end;if d[1]then local g;if d[1]==\"-\"then g=assert(load(function()return io.stdin:read(\"*L\")end,\"=stdin\"))else g=assert(load(d[1],\"@\"..d[1]))end;g(table.unpack(d,2,#d))if not d.i then return 0 end end;exit=setmetatable({},{__tostring=function()return\"Press Ctrl+D or Ctrl+C to exit\"end})quit=exit;print(_VERSION,\"Copyright (C) 2021 JackMacWindows\")local h={}while true do local i=\"\"local g,j;repeat if i==\"\"then io.stdout:write(\"> \")else io.stdout:write(\">> \")end;local k=b.readline2(h)if not k then print()return 0 end;i=i..k..\"\\n\"g,j=load(\"return \"..i,\"=stdin\")if not g then g,j=load(i,\"=stdin\")end until g or not j:match(\"<eof>\")if g then local l=table.pack(pcall(g))if l[1]then for e=2,l.n do a.print(a.pretty(l[e],{function_source=true,function_args=true}))end else io.stderr:write(l[2]..\"\\n\")end else io.stderr:write(j..\"\\n\")end;table.insert(h,1,i:sub(1,-2))end\n",setuser=false,size=1619,modified=1757997039885,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["date.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039912,data="local a=false;local b=\"%c\"for c,d in ipairs{...}do if d==\"-u\"then a=true elseif d:sub(1,1)==\"+\"then b=d:sub(2)end end;if a then b=\"!\"..b end;print(os.date(b))\n",setuser=false,size=159,modified=1757997039872,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["false.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039916,data="return false\n",setuser=false,size=13,modified=1757997039878,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["screenfetch.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039928,data="local a=require\"system.filesystem\"local b=require\"system.hardware\"local c=require\"system.process\"local d=require\"system.terminal\"local e=require\"system.util\"local f={\"\\x1b[30;40m                \\x1b[0m\",\"\\x1b[30;40m  \\x1b[33;106m\\x88\\x1b[96;43m\\x8F\\x1b[96;40m\\x90 \\x1b[30;106m\\x9F\\x1b[96;40m\\x90   \\x1b[30;106m\\x9F\\x1b[96;43m\\x8F\\x1b[33;106m\\x84\\x1b[30;40m  \\x1b[0m\",\"\\x1b[96;40m \\x9A\\x1b[33;106m\\x89\\x84\\x1b[33;41m\\x82\\x1b[33;40m\\x94\\x1b[30;106m\\x95 \\x1b[96;40m\\x90 \\x1b[30;43m\\x97\\x1b[33;41m\\x81\\x1b[33;106m\\x88\\x86\\x1b[30;106m\\x9A\\x1b[30;40m \\x1b[0m\",\"\\x1b[30;106m\\x9F\\x1b[96;43m\\x9B\\x8C\\x1b[96;41m\\x95 \\x1b[33;40m\\x95\\x1b[30;106m\\x95 \\x96\\x1b[30;40m \\x1b[30;43m\\x95\\x1b[96;41m \\x1b[31;106m\\x95\\x1b[96;43m\\x8C\\x1b[33;106m\\x98\\x1b[96;40m\\x90\\x1b[0m\",\"\\x1b[30;106m\\x95\\x1b[33;106m\\x8C\\x84\\x1b[96;41m\\x95 \\x1b[30;43m\\x8A\\x1b[30;106m\\x95\\x1b[96;100m\\x8F\\x8F\\x1b[96;40m\\x95\\x1b[30;43m\\x85\\x1b[96;41m \\x1b[31;106m\\x95\\x1b[33;106m\\x88\\x8C\\x1b[96;40m\\x95\\x1b[0m\",\"\\x1b[96;40m\\x8A\\x1b[96;43m\\x9C\\x8E\\x1b[31;106m\\x82\\x1b[33;41m \\x82\\x1b[90;106m\\x95\\x1b[33;106m\\x90\\x1b[96;43m\\x9F\\x1b[96;100m\\x95\\x1b[33;41m\\x81 \\x1b[31;106m\\x81\\x1b[96;43m\\x8D\\x1b[33;106m\\x93\\x1b[96;40m\\x85\\x1b[0m\",\"\\x1b[30;40m \\x1b[96;43m\\x9E\\x1b[33;106m\\x8C\\x1b[96;43m\\x9B\\x1b[31;106m\\x82\\x1b[96;41m\\x90\\x1b[90;106m\\x95\\x1b[33;106m\\x85\\x8A\\x1b[96;100m\\x95\\x1b[31;106m\\x9F\\x81\\x1b[33;106m\\x98\\x8C\\x92\\x1b[30;40m \\x1b[0m\",\"\\x1b[96;40m \\x82\\x1b[33;106m\\x86\\x99\\x99\\x1b[96;100m\\x95\\x1b[33;106m\\x8A\\x88\\x81\\x85\\x1b[90;106m\\x95\\x1b[96;43m\\x99\\x99\\x1b[33;106m\\x89\\x1b[106;40m\\x81 \\x1b[0m\",\"\\x1b[33;40m  \\x82\\x8B\\x1b[90;106m \\x96 \\x1b[33;106m\\x95\\x1b[96;43m\\x95\\x1b[96;106m \\x1b[96;100m\\x96\\x1b[96;106m \\x1b[33;40m\\x87\\x81  \\x1b[0m\",\"\\x1b[96;40m     \\x83\\x8B\\x8F\\x8F\\x87\\x83     \\x1b[0m\",\"\\x1b[30;40m                \\x1b[0m\"}local function g(h)local i=math.floor(h/3600)local j=math.floor(h/60)%60;local k=h%60;local l=k..\"s\"if j>0 or i>0 then l=j..\"m \"..l end;if i>0 then l=i..\"h \"..l end;return l end;local function m(h)if h>=1073741824 then return(\"%.3g GiB\"):format(h/1073741824)elseif h>=1048576 then return(\"%.3g MiB\"):format(h/1048576)elseif h>=1024 then return(\"%.3g kiB\"):format(h/1024)else return(\"%.3g B\"):format(h)end end;local n={\"\\x1b[96m\"..c.getuser()..\"\\x1b[0m@\\x1b[96m\"..(b.call(\"/\",\"getLabel\")or\"Computer \"..b.info(\"/\").id)}n[#n+1]=(\"-\"):rep(#n[1]-14)local function o(p,q)n[#n+1]=\"\\x1b[96m\"..p..\"\\x1b[0m: \"..q end;o(\"OS\",\"Phoenix \"..e.syscall.version())o(\"Uptime\",g(e.syscall.uptime()))o(\"Runtime\",e.syscall.cchost():match(\"%b()\"):sub(2,-2))o(\"Lua\",_VERSION)o(\"CC Version\",e.syscall.cchost():match(\"ComputerCraft [%d%.]+\"))o(\"Resolution\",table.concat({d.termsize()},\"x\"))local r=a.stat(\"/\")o(\"Disk Space\",m(r.freeSpace)..\" / \"..m(r.capacity))if collectgarbage then o(\"Memory\",m(collectgarbage(\"count\")*1024))end;n[#n+1]=\"\"n[#n+1]=\"\\x1b[40m   \\x1b[41m   \\x1b[42m   \\x1b[43m   \\x1b[44m   \\x1b[45m   \\x1b[46m   \\x1b[47m   \\x1b[0m\"n[#n+1]=\"\\x1b[100m   \\x1b[101m   \\x1b[102m   \\x1b[103m   \\x1b[104m   \\x1b[105m   \\x1b[106m   \\x1b[107m   \\x1b[0m\"n[#n+1]=\"\"local s=d.termsize()-18;for t=1,math.max(#f,#n)do local k=n[t]or\"\"local u,v=0,false;for w,x in k:gmatch\"(.)()\"do if v then if w=='m'then v=false end elseif w=='\\x1b'then v=true else u=u+1;if u==s then k=k:sub(1,x)v=true;break end end end;if v then io.write((f[t]or\"                \")..\"  \"..k)else print((f[t]or\"                \")..\"  \"..k)end end\n",setuser=false,size=3370,modified=1757997039893,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["chown.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039909,data="local a=require\"system.util\"local b=require\"system.filesystem\"local c=assert(a.argparse({h=false,H=false,L=false,P=false,R=false},...))if#c<2 then error(\"usage: chown [-h] [-R [-H|-L|-P]] <owner> <file...>\")end;local function d(e,f)b.chown(e,f)if b.stat(e,true).type==\"directory\"then for g,h in ipairs(b.list(e))do d(b.combine(e,h),f)end end end;local f=c[1]:gsub(\":.*\",\"\")for i=2,#c do if c.R then d(c[i],f)else b.chown(c[i],f)end end\n",setuser=false,size=436,modified=1757997039868,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["rm.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039927,data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=assert(b.argparse({f=false,i=false,R=\"@r\",r=false,[\"no-preserve-root\"]=false},...))local d=true;for e,f in ipairs(c)do local g=a.stat(f)if not c[\"no-preserve-root\"]and a.combine(f)==\"/\"then io.stderr:write(\"rm: refusing to remove root directory\")elseif not g then if not c.f then io.stderr:write(\"rm: \"..f..\": No such file or directory\\n\")end;d=false elseif g.type==\"directory\"then if c.r then a.remove(f)else io.stderr:write(\"rm: -r not specified, skipping directory \"..f..\"\\n\")d=false end else a.remove(f)end end;return d\n",setuser=false,size=594,modified=1757997039892,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["cat.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039908,data="local a={...}if a[1]==\"-u\"then table.remove(a,1)end;if#a==0 then a[1]=\"-\"end;for b,c in ipairs(a)do if c==\"-\"then io.stdout:write(io.stdin:read(\"*a\"))else local d,e=io.open(c,\"rb\")if not d then error(\"cat: \"..c..\": \"..e)end;io.stdout:write(d:read(\"*a\"))d:close()end end\n",setuser=false,size=270,modified=1757997039866,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["luz.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997041334,data="local a=require\"luz.lex\"local b=require\"luz.minify\"local c=require\"luz.compress\"local d=require\"luz.decompress\"local function e()print[[Usage: luz [options] <input> [output]\nOptions:\n  -c       Force compression\n  -d       Force decompression\n  -l <num> Compression level (0-9)\n  -m       Minify before compression (experimental)\n  -r       Run compressed file\n  --help   Show this help\n]]end;local f,g,h={}local i,j;local k=false;local l;for m,n in ipairs{...}do if l then if l==1 then j=tonumber(n)end;l=nil elseif n:sub(1,2)==\"--\"then if n==\"--help\"then return e()end elseif n:sub(1,1)==\"-\"then for o in n:sub(2):gmatch(\".\")do if o==\"c\"then i=1 elseif o==\"d\"then i=2 elseif o==\"l\"then l=1 elseif o==\"r\"then i=3 elseif o==\"m\"then k=true end end elseif not g then g=n elseif not h then h=n else f[#f+1]=n end end;if not g then return e()end;if i==3 then table.insert(f,1,h)h=nil end;if shell then g,h=shell.resolve(g),h and shell.resolve(h)end;local p=assert(io.open(g,\"rb\"))local q=p:read(\"*a\")p:close()if not i then i=q:sub(1,5)==\"\\27LuzQ\"and 2 or 1 end;local r=pcall(load,\"\")if i==3 then local s=d(q)return assert((r and load or loadstring)(s,\"@\"..g,\"t\",_ENV))((table.unpack or unpack)(f))elseif i==2 then h=h or g..\".lua\"local s=d(q)p=assert(io.open(h,\"w\"))p:write(s)p:close()else h=h or g..\".luz\"assert((r and load or loadstring)(q))local t=a(q,1,2)if k then t=b(t)end;local u=c(t,j)p=assert(io.open(h,\"wb\"))p:write(u)p:close()print(g..\": \"..#q..\" => \"..#u)end\n",setuser=false,size=1467,modified=1757997041328,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["expr.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039916,data="print(assert(load(table.concat({...},\" \"):gsub(\"&\",\" and \"):gsub(\"|\",\" or \"),\"=expr\",\"t\",{}))())\n",setuser=false,size=97,modified=1757997039878,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["craftos.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997041053,data="for a,b in pairs(require\"craftos\")do _G[a]=b end;return coroutine.yield(\"syscall\",\"exec\",...)\n",setuser=false,size=94,modified=1757997041039,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["halt.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039917,data="coroutine.yield(\"syscall\",\"devcall\",\"/\",\"shutdown\")\n",setuser=false,size=52,modified=1757997039879,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["cd.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039908,data="return coroutine.yield(\"syscall\",\"chdir\",...)\n",setuser=false,size=46,modified=1757997039867,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["mkdir.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039922,data="local a=require\"system.util\"local b=require\"system.filesystem\"local c=assert(a.argparse({p=false,m=true},...))local d=c.m;local e=d and tonumber(d,8)local function f(g)local h=b.stat(g)if e then b.chmod(g,h.owner,bit32.band(bit32.rshift(e,6),7))b.chmod(g,nil,bit32.band(e,7))else for i in d:gmatch\"[^,]+\"do local j,k=i:match\"^([^%+%-=]*)([%+%-=][rwxs]+)$\"if not j then error(\"mkdir: invalid mode: \"..i)end;if j==\"\"then j=nil end;b.chmod(g,j,k)end end end;for l,m in ipairs(c)do if not c.p and not b.isDir(b.dirname(m))then error(\"mkdir: \"..b.dirname(m)..\": Not a directory\")end;b.mkdir(m)if d then f(m)end end\n",setuser=false,size=610,modified=1757997039886,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["true.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039930,data="return true\n",setuser=false,size=12,modified=1757997039895,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["sh.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039928,data="return coroutine.yield(\"syscall\",\"exec\",\"/bin/cash\",...)\n",setuser=false,size=57,modified=1757997039894,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["id.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039917,data="local a=require\"system.hardware\"if...then local b=assert(a.wrap(...),\"No such device\")local c=b.state;if c and c.id then print(\"This drive has disk #\"..c.id)else error(\"No disk in drive\")end else print(\"This is computer #\"..a.info(\"/\").metadata.id)end\n",setuser=false,size=252,modified=1757997039880,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["env.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039915,data="local a=require\"system.process\"local b={...}local c=a.getenv()while#b>0 do if b[1]==\"-i\"then for d in pairs(c)do c[d]=nil end;table.remove(b,1)elseif b[1]:find(\"=\")then local d,e=table.remove(b,1):match\"^([^=]+)=(.*)$\"c[d]=e else break end end;if#b==0 then for d,e in pairs(c)do print(d..\"=\"..e)end else return a.execp(table.unpack(b))end\n",setuser=false,size=339,modified=1757997039877,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["chroot.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039909,data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=require\"system.util\"local d=assert(c.argparse({userspec=true,[\"skip-chdir\"]=false},...))if b.getuser()~=\"root\"then error(\"This program requires root.\")end;local e=table.remove(d,1)if not e then error(\"Usage: chroot [options] <path> [program] [args...]\")end;if#d==0 then d[1],d[2]=b.getenv().SHELL or\"/bin/sh\",\"-i\"end;a.chroot(e)if not d[\"skip-chdir\"]then b.chdir(\"/\")end;if d.userspec then b.setuser(d.userspec)end;return b.execp(table.unpack(d))\n",setuser=false,size=520,modified=1757997039868,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["less.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039918,data="local a=require\"system.filesystem\"local b=require\"system.keys\"local c=require\"system.process\"local d=require\"system.terminal\"local e=require\"system.util\"local f=assert(e.argparse({[\"chop-long-lines\"]=false,S=\"@chop-long-lines\",[\"prompt\"]=true,P=\"@prompt\",help=false,version=false},...))local g=f[1]local h=not f[\"chop-long-lines\"]local i=f.prompt;if g==nil and not d.istty()then g=\"-\"end;if g==nil then error(\"Missing filename (\\\"less --help\\\" for help)\")end;local j;local k=assert(d.openterm())local l,m,n={},{},{}local o,p=1,1;local q,r=k.getSize()r=r-1;local function s()l={}if g==\"-\"then if not j then j={}repeat local t=io.stdin:read()j[#j+1]=t until not t end;for u,v in ipairs(j)do l[u]=v end else local w=a.open(g,\"r\")if w==nil then error(\"Could not open file \"..g)end;local t=w.readLine()while t do table.insert(l,({string.gsub(t,\"\\t\",\"    \")})[1])t=w.readLine()end;w.close()end;for u,v in ipairs(l)do local x,y,z=\"\",\"\",\"\"local A=1;local B,C=\"0\",\"f\"for D,E,F in v:gmatch\"()%f[\\x1b]\\x1b%[(%d+)m()\"do x=x..v:sub(A,D-1)y=y..B:rep(D-A)z=z..C:rep(D-A)E=tonumber(E)if E==0 then B,C=\"0\",\"f\"elseif E>=30 and E<=37 then B=(\"%x\"):format(15-(E-30))elseif E==39 then B='0'elseif E>=40 and E<=47 then C=(\"%x\"):format(15-(E-40))elseif E==49 then C='f'elseif E>=90 and E<=97 then B=(\"%x\"):format(15-(E-90)-8)elseif E>=100 and E<=107 then C=(\"%x\"):format(15-(E-100)-8)end;A=F end;x=x..v:sub(A)y=y..B:rep(#v-A+1)z=z..C:rep(#v-A+1)l[u],m[u],n[u]=x,y,z end;if h and p==1 then local u=1;while u<=#l do while#l[u]>q do local G=q-(l[u]:sub(1,q):reverse():find(\" \")or 1)+1;table.insert(l,u+1,string.sub(l[u],G+1)or\"\")table.insert(m,u+1,string.sub(m[u],G+1)or\"\")table.insert(n,u+1,string.sub(n[u],G+1)or\"\")l[u],m[u],n[u]=l[u]:sub(1,G),m[u]:sub(1,G),n[u]:sub(1,G)end;u=u+1 end end end;local function H()k.clear()k.setCursorPos(1,1)k.setCursorBlink(false)for u=o,o+r-1 do if l[u]~=nil then k.blit(l[u]:sub(p),m[u]:sub(p),n[u]:sub(p))end;k.setCursorPos(1,u-o+2)end;k.setCursorPos(1,r+1)if i then k.blit(i,string.rep(\"f\",#i),string.rep(\"0\",#i))elseif o>=#l-r then k.blit(\"(END)\",\"fffff\",\"00000\")else k.write(\":\")end;k.setCursorBlink(true)end;local function I(J,m,n)k.setCursorPos(1,r+1)k.clearLine()k.blit(J,m or string.rep(\"0\",#J),n or string.rep(\"f\",#J))local K=\"\"local L=1;while true do k.setCursorPos(#J+1,r+1)k.write(K..string.rep(\" \",q-#K-#J-2))k.setCursorPos(#J+L,r+1)k.setCursorBlink(true)local M,N=coroutine.yield()if M==\"key\"then if N.keycode==b.backspace then if K==\"\"then return nil elseif L>1 then K=string.sub(K,1,L-2)..string.sub(K,L)L=L-1 end elseif N.keycode==b.left and L>1 then L=L-1 elseif N.keycode==b.right and L<#K+1 then L=L+1 elseif N.keycode==b.enter then return K end elseif M==\"char\"then K=string.sub(K,1,L-1)..N.character..string.sub(K,L)L=L+1 end end end;local function O()local P,n,Q=k.getPaletteColor(d.colors.black)k.setPaletteColor(d.colors.black,k.getPaletteColor(d.colors.lightGray))e.sleep(0.1)k.setPaletteColor(d.colors.black,k.getPaletteColor(d.colors.gray))e.sleep(0.05)k.setPaletteColor(d.colors.black,P,n,Q)e.sleep(0.05)end;s()local R=nil;while true do H()local M,N=coroutine.yield()local S=i;i=nil;if M==\"key\"then if N.keycode==b.left and p>q/2 then p=p-q/2 elseif N.keycode==b.right then p=p+q/2 elseif N.keycode==b.up then if o>1 then o=o-1 else O()end elseif N.keycode==b.down or N.keycode==b.enter then if o<#l-r then o=o+1 else O()end elseif N.keycode==b.space then if o<#l-r then o=o+(o<#l-2*r+1 and r or#l-r-o)else O()end end elseif M==\"char\"then if N.character==\"q\"then break elseif N.character==\"f\"then if o<#l-r then o=o+(o<#l-2*r+1 and r or#l-r-o)else O()end elseif N.character==\"b\"then if o>1 then o=o-(o>r+1 and r or o-1)else O()end elseif N.character==\"d\"then if o<#l-r then o=o+(o<#l-1.5*r+1 and r/2 or#l-r-o)else O()end elseif N.character==\"u\"then if o>1 then o=o-(o>r/2+1 and r/2 or o-1)else O()end elseif N.character==\"g\"or N.character==\"<\"then o=1 elseif N.character==\"G\"or N.character==\">\"then o=#l-r elseif N.character==\"e\"or N.character==\"j\"then if o<#l-r then o=o+1 else O()end elseif N.character==\"y\"or N.character==\"k\"then if o>1 then o=o-1 else O()end elseif N.character==\"K\"or N.character==\"Y\"then o=o-1 elseif N.character==\"J\"then o=o+1 elseif N.character==\"/\"then local T=I(\"/\")if T==\"\"then T=R end;if T~=nil then R=T;local U=false;for u=o+1,#l do if string.match(l[u],T)then o=u;U=true;break end end;if o>#l-r then o=#l-r end;if not U then i=\"Pattern not found\"end end elseif N.character==\"?\"then local T=I(\"?\")if T==\"\"then T=R end;if T~=nil then R=T;local U=false;for u=o-1,1,-1 do if string.match(l[u],T)then o=u;U=true;break end end;if o>#l-r then o=#l-r end;if not U then i=\"Pattern not found\"end end elseif N.character==\"n\"then local U=false;for u=o+1,#l do if string.match(l[u],R)then o=u;U=true;break end end;if o>#l-r then o=#l-r end;if not U then i=\"Pattern not found\"end elseif N.character==\"N\"then local U=false;for u=o-1,1,-1 do if string.match(l[u],R)then o=u;U=true;break end end;if o>#l-r then o=#l-r end;if not U then i=\"Pattern not found\"end elseif N.character==\"v\"then local V=c.start(EDITOR or\"/bin/vi\",g)repeat local M,N=coroutine.yield()until M==\"process_complete\"and N.id==V;s()elseif N.character==\"!\"then local W=I(\"!\")if W then local V=c.start(string.gsub(W,\"%%\",g))repeat local M,N=coroutine.yield()until M==\"process_complete\"and N.id==V end end elseif M==\"term_resize\"then q,r=k.getSize()r=r-1;s()elseif M==\"mouse_scroll\"then if N.direction==1 and o<#l-r then o=o+1 elseif N.direction==-1 and o>1 then o=o-1 end else i=S end end;k.clear()k.setCursorPos(1,1)k.close()\n",setuser=false,size=5547,modified=1757997039882,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["whoami.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039932,data="local a=require\"system.process\"local b=a.getuser()print(b)\n",setuser=false,size=59,modified=1757997039899,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["expand.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039916,data="local a=require\"system.util\"local b=assert(a.argparse({t=true},...))b.t=b.t or\"8\"if#b==0 then b[1]=\"-\"end;local c={}if b.t:match(\"^%d+$\")then local d=tonumber(b.t)setmetatable(c,{__index=function(e,f)return math.ceil((f+1)/d)*d-f end})elseif b.t:match(\"^[%d, ]+$\")then local g=1;for h in b.t:gmatch\"%d+\"do local d=tonumber(h)assert(d>g,\"expand: invalid tab stop format\")for i=g,d-1 do c[i]=d-i end;g=d end;setmetatable(c,{__index=function(e,f)return 1 end})else error(\"expand: invalid tab stop format\")end;for e,j in ipairs(b)do for k in io.lines(j~=\"-\"and j or nil)do print(k:gsub(\"()\\t\",function(f)return(\" \"):rep(c[f])end))end end\n",setuser=false,size=634,modified=1757997039877,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["sleep.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039929,data="require\"system.util\".sleep(tonumber(...))\n",setuser=false,size=42,modified=1757997039894,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["tar.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997042893,data="local a=require\"tar\"local b=require\"system.filesystem\"local c=require\"system.process\"local function d(e,f,g)return string.len(e)<f and string.sub(e,1,f)..string.rep(g or\" \",f-string.len(e))or e end;local function h(e,f,g)return string.len(e)<f and string.rep(g or\" \",f-string.len(e))..string.sub(e,1,f)or e end;local function i(j)return 0x38+(j.worldPermissions.read and 4 or 0)+(j.worldPermissions.write and 2 or 0)+(j.worldPermissions.execute and 1 or 0)+(j.permissions[j.owner].read and 256 or 0)+(j.permissions[j.owner].write and 128 or 0)+(j.permissions[j.owner].execute and 64 or 0)end;local function k(l,e,g)local m=\"\"for n=1,string.len(e)do m=m..(bit32.band(l,bit32.lshift(1,string.len(e)-n))==0 and g or string.sub(e,n,n))end;return m end;local o=[=[Usage: tar [OPTION...] [FILE]...\nPhoenix 'tar' saves many files together into a single tape or disk archive, and\ncan restore individual files from the archive.\n\nExamples:\n  tar -cf archive.tar foo bar  # Create archive.tar from files foo and bar.\n  tar -tvf archive.tar         # List all files in archive.tar verbosely.\n  tar -xf archive.tar          # Extract all files from archive.tar.\n\n Local file name selection:\n\n      --add-file=FILE        add given FILE to the archive (useful if its name\n                             starts with a dash)\n  -C, --directory=DIR        change to directory DIR\n      --no-null              disable the effect of the previous --null option\n      --no-recursion         avoid descending automatically in directories\n      --null                 -T reads null-terminated names; implies\n                             --verbatim-files-from\n      --recursion            recurse into directories (default)\n  -T, --files-from=FILE      get names to extract or create from FILE\n\n Main operation mode:\n\n  -A, --catenate, --concatenate   append tar files to an archive\n  -c, --create               create a new archive\n  -d, --diff, --compare      find differences between archive and file system\n      --delete               delete from the archive (not on mag tapes!)\n  -r, --append               append files to the end of an archive\n  -t, --list                 list the contents of an archive\n  -u, --update               only append files newer than copy in archive\n  -x, --extract, --get       extract files from an archive\n\n Overwrite control:\n\n  -k, --keep-old-files       don't replace existing files when extracting,\n                             treat them as errors\n      --overwrite            overwrite existing files when extracting\n      --remove-files         remove files after adding them to the archive\n  -W, --verify               attempt to verify the archive after writing it\n\n Device selection and switching:\n\n  -f, --file=ARCHIVE         use archive file or device ARCHIVE\n\n Device blocking:\n\n  -i, --ignore-zeros         ignore zeroed blocks in archive (means EOF)\n\n Compression options:\n\n  -z, --gzip, --gunzip, --ungzip   filter the archive through gzip\n\n Local file selection:\n\n  -N, --newer=DATE-OR-FILE, --after-date=DATE-OR-FILE\n                             only store files newer than DATE-OR-FILE\n\n Informative output:\n\n  -v, --verbose              verbosely list files processed\n\n Other options:\n\n  -?, --help                 give this help list\n      --usage                give a short usage message\n      --version              print program version]=]local p={...}local q=nil;local r={}local s=nil;local t=nil;local u=true;local v=false;local w=false;local x=nil;local y=false;local z=false;local A=nil;local B=0;local C=false;local D=false;for E,F in ipairs(p)do if t then if t==0 then q=F elseif t==1 then x=F elseif t==2 then A=F elseif t==3 then B=tonumber(F)elseif t==4 then local G=b.open(F,\"r\")local H=G.readLine()while H~=nil do if C then table.insert(r,H)else table.insert(p,H)end;H=G.readLine()end;G.close()end;t=nil elseif E==1 or string.sub(F,1,1)==\"-\"and string.sub(F,2,2)~=\"-\"then if string.find(F,\"A\")then s=0 end;if string.find(F,\"d\")then s=2 end;if string.find(F,\"c\")then s=1 end;if string.find(F,\"r\")then s=3 end;if string.find(F,\"t\")then s=4 end;if string.find(F,\"u\")then s=5 end;if string.find(F,\"x\")then s=6 end;if string.find(F,\"f\")then t=0 end;if string.find(F,\"k\")then u=false end;if string.find(F,\"U\")then v=true end;if string.find(F,\"W\")then w=true end;if string.find(F,\"O\")then x=0 end;if string.find(F,\"p\")then y=true end;if string.find(F,\"i\")then a.ignore_zero=true end;if string.find(F,\"z\")then z=true end;if string.find(F,\"C\")then t=1 end;if string.find(F,\"K\")then t=2 end;if string.find(F,\"N\")then t=3 end;if string.find(F,\"T\")then t=4 end;if string.find(F,\"v\")then a.verbosity=1 end;if string.find(F,\"?\")then print(o)return 2 end elseif string.sub(F,1,2)==\"--\"then if F==\"--catenate\"then s=0 elseif F==\"--concatenate\"then s=0 elseif F==\"--create\"then s=1 elseif F==\"--diff\"then s=2 elseif F==\"--compare\"then s=2 elseif F==\"--delete\"then s=7 elseif F==\"--append\"then s=3 elseif F==\"--list\"then s=4 elseif F==\"--update\"then s=5 elseif F==\"--extract\"then s=6 elseif F==\"--get\"then s=6 elseif F==\"--help\"or F==\"--usage\"then print(o)return 2 elseif F==\"--version\"then print(\"Phoenix tar v1.0\")return 2 elseif F==\"--keep-old-files\"then u=false elseif F==\"--overwrite\"then u=true elseif F==\"--remove-files\"then v=true elseif F==\"--unlink-first\"then v=true elseif F==\"--verify\"then w=true elseif F==\"--to-stdout\"then x=0 elseif F==\"--preserve-permissions\"then y=true elseif F==\"--same-permissions\"then y=true elseif F==\"--preserve\"then y=true elseif string.find(F,\"--file=\")then q=string.sub(F,8)elseif F==\"--ignore-zeros\"then a.ignore_zero=true elseif F==\"--gzip\"or F==\"--gunzip\"or F==\"--ungzip\"then z=true elseif string.find(F,\"--add-file=\")then table.insert(r,string.sub(F,12))elseif string.find(F,\"--directory=\")then x=string.sub(F,13)elseif string.find(F,\"--starting-file=\")then A=string.sub(F,17)elseif F==\"--no-null\"then C=false elseif F==\"--null\"then C=true elseif string.find(F,\"--newer=\")then B=tonumber(string.sub(F,9))elseif string.find(F,\"--after-date=\")then B=tonumber(string.sub(F,14))elseif string.find(F,\"--files-from=\")then local G=b.open(string.sub(F,14),\"r\")local H=G.readLine()while H~=nil do if C then table.insert(r,H)else table.insert(p,H)end;H=G.readLine()end;G.close()elseif F==\"--verbose\"then a.verbosity=1 elseif F==\"--no-recursion\"then D=true end else table.insert(r,F)end end;if z and LibDeflate==nil then LibDeflate=require\"LibDeflate\"if LibDeflate==nil then error(\"Compression is only supported when LibDeflate.lua is available in the PATH.\")end end;local I=c.getcwd()if type(x)==\"string\"then c.chdir(x)end;local function J(e)c.chdir(I)error(e)end;local function K(L)if z then local M=\"\"local G=b.open(q,\"rb\")local g=G.read()while g~=nil do M=M..string.char(g)g=G.read()if string.len(M)%10240==0 then os.queueEvent(\"nosleep\")os.pullEvent()end end;G.close()return a.load(LibDeflate:DecompressGzip(M),L,true)else return a.load(q,L)end end;local function N(O)if not z and q then a.save(O,q)else local m=a.save(O,nil)if z then m=LibDeflate:CompressGzip(m)end;if x==0 then io.write(m)elseif m then local G=b.open(q,\"wb\")for g in string.gmatch(m,\".\")do G.write(string.byte(g))end;G.close()end end end;if s==0 then if z==true then J(\"Compressed files cannot be concatenated\")end;if q==nil then J(\"You must specify an arhive with -f <first.tar>.\")end;local P=b.open(q,\"ab\")for E,F in pairs(r)do local Q=b.open(F,\"rb\")local g=Q.read()while g do P.write(g)g=Q.read()end;Q.close()end;P.close()elseif s==1 then if q==nil and x~=0 then J(\"You must specify an archive with -f <output.tar> or -O.\")end;local O={}for E,F in pairs(r)do local R=split(F,\"/\")local S=O;local T=nil;for E,F in pairs(R)do if E==#R then break end;T=T and b.combine(T,F)or F;if S[F]==nil then S[F]={}end;S=S[F]end;if string.sub(F,1,1)==\"/\"then S[R[#R]]=(D and a.read or a.pack)(\"/\",string.sub(F,2))else S[R[#R]]=(D and a.read or a.pack)(c.getcwd(),F)end;if v then b.remove(F)end end;N(O)elseif s==2 then J(\"Not implemented\")elseif s==3 then if q==nil and x~=0 then J(\"You must specify an archive with -f <output.tar> or -O.\")end;local O=K(true)for E,F in pairs(r)do if string.sub(F,1,1)==\"/\"then table.insert(O,(D and a.read or a.pack)(\"/\",string.sub(F,2)))else table.insert(O,(D and a.read or a.pack)(c.getcwd(),F))end;if v then b.remove(F)end end;N(O)elseif s==4 then if q==nil then J(\"You must specify an archive with -f <file.tar>.\")end;local O=K(true)if a.verbosity>0 then local U={}local V={0,0,0,0,0}for E,F in pairs(O)do local S=os.date(\"%F %R\",F.timestamp or 0)local W={k(F.mode+(F.type==5 and 0x200 or 0),\"drwxrwxrwx\",\"-\"),(F.ownerName or F.owner or 0)..\"/\"..(F.groupName or F.group or 0),string.len(F.data or\"\"),S,F.name..(F.link and F.link~=\"\"and\" -> \"..F.link or\"\")}for X,Y in pairs(W)do if string.len(Y)+1>V[X]then V[X]=string.len(Y)+1 end end;table.insert(U,W)end;for E,F in pairs(U)do for X,Y in pairs(F)do io.write((X==3 and h or d)(Y,V[X])..(X==3 and\" \"or\"\"))end;print(\"\")end else for E,F in pairs(O)do print(F.name)end end elseif s==5 then if q==nil and x~=0 then J(\"You must specify an archive with -f <output.tar> or -O.\")end;local O=K()for E,F in pairs(r)do local R=split(F,\"/\")local S=O;local T=nil;for E,F in pairs(R)do if E==#R then break end;T=T and b.combine(T,F)or F;local j=b.stat(T)if S[F]==nil then S[F]={[\"//\"]={name=T,mode=i(j),owner=0,group=0,timestamp=j.modified,type=5,link=\"\",ownerName=j.owner,groupName=\"\",deviceNumber=nil,data=nil}}end;S=S[F]end;if string.sub(F,1,1)==\"/\"then S[R[#R]]=(D and a.read or a.pack)(\"/\",string.sub(F,2))else S[R[#R]]=(D and a.read or a.pack)(c.getcwd(),F)end;if v then b.remove(F)end end;N(O)elseif s==6 then if q==nil then J(\"You must specify an archive with -f <file.tar>.\")end;local O=K()a.extract(O,c.getcwd())elseif s==7 then if q==nil then J(\"You must specify an archive with -f <file.tar>.\")end;local O=K(true)for E,F in pairs(r)do for X,Y in pairs(O)do if Y.name==F then O[X]=nil;break end end end;N(O)else J(\"You must specify one of -Acdrtux, see --help for details.\")end;c.chdir(I)\n",setuser=false,size=10000,modified=1757997042880,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["chmod.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039908,data="local a=require\"system.filesystem\"local b={...}local c=false;if b[1]==\"-R\"then c=true;table.remove(b,1)end;local d=table.remove(b,1)local e=tonumber(d,8)local function f(g)local h=a.stat(g,true)if e then a.chmod(g,h.owner,bit32.band(bit32.rshift(e,6),7))a.chmod(g,nil,bit32.band(e,7))else for i in d:gmatch\"[^,]+\"do local j,k=i:match\"^([^%+%-=]*)([%+%-=][rwxs]+)$\"if not j then error(\"chmod: invalid mode: \"..i)end;if j==\"\"then j=nil end;a.chmod(g,j,k)end end;if c and h.type==\"directory\"then for l,m in ipairs(a.list(g))do f(a.combine(g,m))end end end;for l,g in ipairs(b)do f(g)end\n",setuser=false,size=584,modified=1757997039867,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["cash.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039907,data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=require\"system.serialization\"local d=require\"system.terminal\"local e=require\"system.util\"local f=assert(e.argparse({c=false,i=false,s=false},...))local g,h;if f.c then h=table.remove(f,1)end;if not f.s then g=table.remove(f,1)end;if not f.c and not f.s and e.syscall.istty()then f.i=true end;local i={}local j=os.time()local k=true;local l=0;local m;local n;local o=b.getenv()if table.maxn==nil then table.maxn=function(p)local q=1;while p[q]~=nil do q=q+1 end;return q-1 end end;local function r(s)return string.match(s,'^()%s*$')and''or string.match(s,'^%s*(.*%S)')end;o.HOME=o.HOME or\"/\"o.SHELL=b.getname()o.PATH=o.PATH or\"/bin:/sbin:/usr/bin\"o.USER=b.getuser()o.EDITOR=o.EDITOR or\"nano\"o.OLDPWD=b.getcwd()o.PWD=o.OLDPWD;o.SHLVL=o.SHLVL and o.SHLVL+1 or 1;o.TERM=o.TERM or\"craftos\"o.COLORTERM=o.COLORTERM or\"16color\"local t={PS1=\"\\\\s-\\\\v\\\\$ \",PS2=\"> \",IFS=\"\\n\",CASH=o.SHELL,CASH_VERSION=\"0.4.1\",RANDOM=function()return math.random(0,32767)end,SECONDS=function()return math.floor((os.time()-j)/1000)end,HOSTNAME=\"localhost\",TERMINATE_QUIT=\"no\",[\"*\"]=table.concat(f,\" \"),[\"@\"]=function()return table.concat(f,\" \")end,[\"#\"]=#f,[\"?\"]=0,[\"0\"]=o.SHELL,_=o.SHELL,[\"$\"]=b.getpid()}local u={}local v={}local w={}local x,y={},0;local z,A={},0;local B,C={},0;local D=nil;local E={}local F={}local G;local H,I;local J=false;local K=false;local L=false;local M={}local N={}local O={}local function P(...)io.write(...)io.write(\"\\n\")end;local Q;Q={[\":\"]=function()return 0 end,[\".\"]=function(R)local S=io.open(R,\"r\")if not S then return 1 end;t.LINENUM=1;for T in S:lines()do i.run(T)t.LINENUM=t.LINENUM+1 end;t.LINENUM=nil;S:close()end,echo=function(...)P(...)return 0 end,builtin=function(U,...)return Q[U](...)end,cd=function(V)V=V or\"/\"if not V:match\"^/\"then V=a.combine(o.PWD,V)end;local W,X=b.chdir(V)if not W then io.stderr:write(\"cash: cd: \"..V..\": \"..X..\"\\n\")return 1 end;o.OLDPWD=o.PWD;o.PWD=V end,command=function(...)L=true;i.run(...)L=false;return t[\"?\"]end,complete=function()end,eval=function(...)i.run(...)return t[\"?\"]end,exec=function(...)m=table.concat({...},' ')i.exit()end,exit=function(...)return i.exit(...)end,export=function(...)local t={...}if#t==0 or t[1]==\"-p\"then for Y,Z in pairs(o)do if type(Z)==\"string\"or type(Z)==\"number\"then P(\"export \"..Y..\"=\"..Z)end end else for Y,Z in ipairs(t)do local _,a0=string.match(Z,\"(.+)=(.+)\")if not(_==nil or a0==nil)and(o[_]==nil or type(o[_])==\"string\"or type(o[_])==\"number\")then o[_]=a0 end end end end,history=function(...)if({...})[1]==\"-c\"then G.close()G=a.open(\".cash_history\",\"w\")F={}return end;local a1={}for Y,Z in ipairs(F)do P(\" \"..Y..string.rep(\" \",math.floor(math.log10(#F))-math.floor(math.log10(Y))+2)..Z)end end,jobs=function(...)local a2={...}for Y,Z in pairs(N)do if Z.cmd~=\"jobs\"then if#a2==0 then P(\"[\"..Y..\"]+  \"..(Z.paused and\"Paused\"or\"Running\")..\"  \"..Z.cmd)else for a3,a4 in ipairs(a2)do if Y==a4 then P(\"[\"..Y..\"]+  \"..(Z.paused and\"Paused\"or\"Running\")..\"  \"..Z.cmd)end end end end end end,pushd=function(a5)if a5 then if not a5:match\"^/\"then a5=a.combine(o.PWD,a5)end;local W,X=b.chdir(a5)if not W then io.stderr:write(\"cash: pushd: \"..a5 ..\": \"..X..\"\\n\")return 1 end end;table.insert(M,o.PWD)if a5 then o.OLDPWD=o.PWD;o.PWD=a5 end;io.write((o.PWD==\"\"and\"/\"or o.PWD)..\" \")for q=#M,1,-1 do io.write((M[q]==\"\"and\"/\"or M[q])..\" \")end;P()end,popd=function()if#M==0 then io.stderr:write(\"cash: popd: directory stack empty\\n\")return-1 end;local W,X=b.chdir(M[#M])if not W then io.stderr:write(\"cash: popd: \"..M[#M]..\": \"..X..\"\\n\")return 1 end;o.PWD=table.remove(M,#M)io.write((o.PWD==\"\"and\"/\"or o.PWD)..\" \")for q=#M,1,-1 do io.write((M[q]==\"\"and\"/\"or M[q])..\" \")end;P()end,dirs=function()io.write((o.PWD==\"\"and\"/\"or o.PWD)..\" \")for q=#M,1,-1 do io.write((M[q]==\"\"and\"/\"or M[q])..\" \")end;P()end,pwd=function()P(o.PWD)end,read=function(a6)t[a6]=io.read()end,set=function(...)local a7={...}if#a7==0 then for Y,Z in pairs(t)do P(Y..\"=\"..Z)end else for Y,Z in ipairs(a7)do if Z:match\"^%-\"then for a8 in Z:sub(2):gmatch\".\"do u[a8]=true end elseif string.find(Z,\"=\")then local _,a0=string.match(Z,\"(.+)=(.+)\")t[_]=a0 end end end end,alias=function(...)local t={...}if#t==0 or t[1]==\"-p\"then for Y,Z in pairs(v)do P(\"alias \"..Y..\"=\"..Z)end else for Y,Z in ipairs(t)do local _,a0=string.match(Z,\"(.+)=(.+)\")v[_]=a0 end end end,sleep=function(a9)e.sleep(tonumber(a9)or 0)end,test=function(...)local f={...}if#f<1 then io.stderr:write(\"cash: test: unary operator expected\\n\")return-1 end;local function aa(Z)return Z end;if f[1]==\"!\"then table.remove(f,1)aa=function(Z)return not Z end end;if string.sub(f[1],1,1)==\"-\"then if f[2]==nil then return aa(true)elseif f[1]==\"-d\"then return aa((a.stat(f[2])or{}).type==\"directory\")elseif f[1]==\"-e\"then return aa(a.stat(f[2])~=nil)elseif f[1]==\"-f\"then return aa((a.stat(f[2])or{}).type==\"file\")elseif f[1]==\"-n\"then return aa(#f[2]>0)elseif f[1]==\"-s\"then return aa(a.stat(f[2])>0)elseif f[1]==\"-u\"then return aa((a.stat(f[2])or{}).permissions.setuid)elseif f[1]==\"-w\"then local ab=a.stat(f[2])if not ab then return aa(false)end;return aa((ab.permissions[b.getuser()]or ab.worldPermissions).write)elseif f[1]==\"-x\"then local ab=a.stat(f[2])if not ab then return aa(false)end;return aa((ab.permissions[b.getuser()]or ab.worldPermissions).execute)elseif f[1]==\"-z\"then return aa(#f[2]==0)else return aa(false)end elseif f[3]and string.sub(f[2],1,1)==\"-\"then if f[2]==\"-eq\"then return aa(tonumber(f[1])==tonumber(f[3]))elseif f[2]==\"-ne\"then return aa(tonumber(f[1])~=tonumber(f[3]))elseif f[2]==\"-lt\"then return aa(tonumber(f[1])<tonumber(f[3]))elseif f[2]==\"-gt\"then return aa(tonumber(f[1])>tonumber(f[3]))elseif f[2]==\"-le\"then return aa(tonumber(f[1])<=tonumber(f[3]))elseif f[2]==\"-ge\"then return aa(tonumber(f[1])>=tonumber(f[3]))else return aa(false)end elseif f[2]==\"=\"then return aa(f[1]==f[3])elseif f[2]==\"!=\"then return aa(f[1]~=f[3])else io.stderr:write(\"cash: test: unary operator expected\\n\")return 2 end end,time=function(...)if not...then io.stderr:write(\"cash: time: missing program path\\n\")return false end;local ac=os.time()local Z={vars={},[0]=...,select(2,...)}local R,ad=i.resolveProgram(Z[0])R=R or Z[0]if not(ad and string.find(Z[0],\"/\")==nil)then Z[0]=R end;local ae=I(Z)if not ae then ae={cputime=0,systime=0}end;P(table.concat({...},\" \"),(\"%.2f user %.2f sys %.3f total\"):format(ae.cputime,ae.systime,(os.time()-ac)/1000))return t[\"?\"]end,[\"true\"]=function()return 0 end,[\"false\"]=function()return 1 end,unalias=function(...)for Y,Z in ipairs({...})do v[Z]=nil end end,unset=function(...)for Y,Z in ipairs({...})do if Z:match\"^%-\"then for a8 in Z:sub(2):gmatch\".\"do u[a8]=nil end else t[Z]=nil end end end,wait=function(af)if af then while N[tonumber(af)]~=nil do sleep(0.1)end else while table.maxn(N)~=0 do sleep(0.1)end end end,which=function(U)if not U then return 1 end;local U,Z=i.resolveProgram(U)if not Z and U then P(U)end end,[\"if\"]=function(...)i.run(...)table.insert(x,{cond=t[\"?\"]==0,inv=false})end,[\"then\"]=function(...)if y>=table.maxn(x)then io.stderr:write(\"cash: syntax error near unexpected token `then'\\n\")return-1 end;y=y+1;i.run(...)return t[\"?\"]end,[\"else\"]=function(...)if y<1 or x[y].inv then io.stderr:write(\"cash: syntax error near unexpected token `else'\\n\")return-1 end;x[y].inv=true;x[y].cond=not x[y].cond;i.run(...)return t[\"?\"]end,fi=function()if y<1 then io.stderr:write(\"cash: syntax error near unexpected token `fi'\\n\")return-1 end;table.remove(x,y)y=y-1 end,[\"while\"]=function(...)table.insert(z,{cond={...},lines={}})end,[\"do\"]=function(...)if table.maxn(z)==0 then io.stderr:write(\"cash: syntax error near unexpected token `do'\\n\")return-1 end;A=A+1 end,done=function()if A<1 then io.stderr:write(\"cash: syntax error near unexpected token `done'\\n\")return-1 end;A=A-1;if A==0 then local ag=table.remove(z,A+1)if type(ag.cond)==\"function\"then ag.cond()else i.run(table.unpack(ag.cond))end;local ah=t[\"?\"]K=false;while ah==0 and not K do for Y,Z in ipairs(ag.lines)do if type(Z)==\"function\"then Z()else i.run(Z)end end;if type(ag.cond)==\"function\"then ag.cond()else i.run(table.unpack(ag.cond))end;ah=t[\"?\"]end end end,[\"break\"]=function()K=true end,[\"for\"]=function(...)local f={...}if f[2]~=\"in\"then io.stderr:write(\"cash: missing `in' in for loop\\n\")return-1 end;local q=2;table.insert(z,{cond=function()q=q+1;t[\"?\"]=f[q]~=nil and 0 or 1 end,lines={function()t[f[1]]=f[q]end}})end,[\"function\"]=function(U,ai)if D~=nil then io.stderr:write(\"cash: syntax error near unexpected token `function'\\n\")return-1 end;if ai~=\"{\"then io.stderr:write(\"cash: syntax error near token `\"..U..\"'\\n\")return-1 end;D=U;E[D]={}end,[\"}\"]=function()if D==nil then io.stderr:write(\"cash: syntax error near unexpected token `}'\\n\")return-1 end;D=nil end,[\"return\"]=function(a6)if J==false then io.stderr:write(\"cash: syntax error near unexpected token `return'\\n\")return-1 end;J=false;return a6 end,bg=function(p)if n then N[n].isfg=false;N[n].paused=false;if CCKernel2 then kernel.signal(signal.SIGCONT,N[n].pid)end;n=nil;return 0 elseif tonumber(p)and N[tonumber(p)]then local aj=tonumber(p)N[aj].isfg=false;N[aj].paused=false;if CCKernel2 then kernel.signal(signal.SIGCONT,N[aj].pid)end;return 0 else io.stderr:write(\"cash: bg: current: no such job\\n\")return 1 end end,fg=function(p)if n then N[n].isfg=true;N[n].paused=false;if CCKernel2 then kernel.signal(signal.SIGCONT,N[n].pid)end;n=nil;return 0 elseif tonumber(p)and N[tonumber(p)]then local aj=tonumber(p)N[aj].isfg=true;N[aj].paused=false;if CCKernel2 then kernel.signal(signal.SIGCONT,N[aj].pid)end;return 0 else io.stderr:write(\"cash: fg: current: no such job\\n\")return 1 end end}Q[\"[\"]=Q.test;function i.exit(ak)k=false;l=ak or 0 end;function i.resolveProgram(U)if Q[U]~=nil then return U end;if v[U]~=nil then U=v[U]end;for R in string.gmatch(o.PATH,\"[^:]+\")do local ai=a.combine(R,U)local ab=a.stat(ai)if ab and ab.type==\"file\"and(ab.permissions[b.getuser()]or ab.worldPermissions).execute then return ai else ai=a.combine(R,U..\".lua\")ab=a.stat(ai)if ab and ab.type==\"file\"and(ab.permissions[b.getuser()]or ab.worldPermissions).execute then return ai end end end;if(a.stat(U)or{}).type==\"file\"then return U,string.find(U,\"/\")==nil end;if(a.stat(U..\".lua\")or{}).type==\"file\"then return U..\".lua\",string.find(U,\"/\")==nil end;return nil end;local function al(a6)if string.sub(a6,1,1)~=\"$\"then return nil end;if string.sub(a6,2,2)==\"{\"then local am=string.sub(string.match(a6,\"%b{}\"),2,-2)local ak=o[am]or t[am]if type(ak)==\"function\"then return ak(),#am+2 else return ak or\"\",#am+2 end elseif string.sub(a6,2,3)==\"((\"then local an=string.gsub(string.sub(string.match(string.sub(a6,3),\"%b()\"),2,-2),\"%$\",\"\")local ao=loadstring(\"return \"..an)local ap=setmetatable({},{__index=_ENV})for Y,Z in pairs(t)do ap[Y]=Z end;setfenv(ao,ap)return tostring(ao()),#an+4 elseif tonumber(string.sub(a6,2,2))then local am=tonumber(string.match(string.sub(a6,2,2),\"[0-9]+\"))if am==0 then return t[\"0\"],1 else return f[am]or\"\",math.floor(math.log10(am))+1 end else local am=\"\"for a8 in string.gmatch(string.sub(a6,2),\".\")do if a8==\" \"then return\"\",#am end;am=am..a8;if o[am]or t[am]then local ak=o[am]or t[am]if type(ak)==\"function\"then return ak(),#am else return ak or\"\",#am end end end;return\"\",#a6-1 end end;local function aq(ar)local as=false;local at=false;local au=1;local ak={\"\"}local av,aw;for a8 in string.gmatch(ar,\".\")do if av=='&'and a8~='&'and aw~='&'and not at and not as then au=au+1;ak[au]=\"\"end;local ax=false;if a8=='\"'or a8=='\\''and not as then at=not at elseif a8=='\\\\'and not at and not as then ax=true;as=true end;if a8==';'and not at and not as then au=au+1;ak[au]=\"\"elseif not(a8==' 'and ak[au]==\"\")then ak[au]=ak[au]..a8 end;if not ax then as=false end;aw=av;av=a8 end;return ak end;local function ay(ar,az)local aA=false;local as=false;local aB=\"\"local q=1;local function aC(Z)if type(Z)==\"boolean\"then return Z and\"true\"or\"false\"elseif Z==nil then return\"nil\"elseif type(Z)==\"table\"then return c.lua.encode(Z)elseif type(Z)==\"string\"then return Z else return tostring(Z)end end;if az then aB=ar else while q<=#ar do local a8=string.sub(ar,q,q)if a8=='$'and not as and not aA then local s,aa=al(string.sub(ar,q))s=aC(s)aB=aB..s;q=q+aa else if a8=='\\''and not as then aA=not aA end;as=a8=='\\\\'and not as;aB=aB..a8 end;q=q+1 end end;local ak={{[0]=\"\"}}q=0;local au=1;local at=false;as=false;local av,aD;for a8 in string.gmatch(aB,\".\")do if aD then if a8==';'then au=au+1;q=0;ak[au]={[0]=\"\"}elseif av=='&'and a8=='&'then ak[au][aD]=string.sub(ak[au][aD],1,-2)au=au+1;q=0;ak[au]={[0]=\"\",last=0}elseif av=='|'and a8=='|'then ak[au][aD]=string.sub(ak[au][aD],1,-2)au=au+1;q=0;ak[au]={[0]=\"\",last=1}elseif av=='2'and a8=='>'then ak[au].stderr=\"\"aD=\"stderr\"elseif a8=='>'then ak[au].stdout=\"\"aD=\"stdout\"elseif a8=='<'then ak[au].stdin=\"\"aD=\"stdin\"elseif a8~=' 'or ak[au][aD]~=\"\"then ak[au][aD]=ak[au][aD]..a8 end elseif not as then if(a8=='\"'or a8=='\\'')and not as then at=not at elseif not at then if a8==' 'then if#ak[au][q]>0 then q=q+1;ak[au][q]=\"\"end elseif a8==';'then if ak[au][q]==\"\"then ak[au][q]=nil end;au=au+1;q=0;ak[au]={[0]=\"\"}elseif av=='&'and a8=='&'then ak[au][q]=string.sub(ak[au][q],1,-2)if ak[au][q]==\"\"then ak[au][q]=nil end;au=au+1;q=0;ak[au]={[0]=\"\",last=0}elseif av=='|'and a8=='|'then ak[au][q]=string.sub(ak[au][q],1,-2)if ak[au][q]==\"\"then ak[au][q]=nil end;au=au+1;q=0;ak[au]={[0]=\"\",last=1}elseif av=='2'and a8=='>'then if ak[au][q]==\"\"then ak[au][q]=nil end;ak[au].stderr=\"\"aD=\"stderr\"elseif a8=='>'then if ak[au][q]==\"\"then ak[au][q]=nil end;ak[au].stdout=\"\"aD=\"stdout\"elseif a8=='<'then if ak[au][q]==\"\"then ak[au][q]=nil end;ak[au].stdin=\"\"aD=\"stdin\"elseif a8~='\\\\'then ak[au][q]=ak[au][q]..a8 end else ak[au][q]=ak[au][q]..a8 end else ak[au][q]=ak[au][q]..a8 end;as=a8=='\\\\'and not at and not as;av=a8 end;if av=='&'then ak.async=true end;for Y,Z in ipairs(ak)do if Z[0]~=\"\"then local R,ad=i.resolveProgram(Z[0])R=R or Z[0]if not(ad and string.find(Z[0],\"/\")==nil)then Z[0]=R end;Z.vars={}while Z[0]and string.find(Z[0],\"=\")do local a3=string.sub(Z[0],1,string.find(Z[0],\"=\")-1)Z.vars[a3]=string.sub(Z[0],string.find(Z[0],\"=\")+1)Z.vars[a3]=tonumber(Z.vars[a3])or Z.vars[a3]Z[0]=nil;for q=1,table.maxn(Z)do Z[q-1]=Z[q]Z[q]=nil end end end end;return ak end;local aE=31+28+31+30+31+30;local function aF(aG)if aG<=31 then return\"Jan \"..aG elseif aG>31 and aG<=31+28 then return\"Feb \"..aG-31 elseif aG>31+28 and aG<=31+28+31 then return\"Mar \"..aG-31-28 elseif aG>31+28+31 and aG<=31+28+31+30 then return\"Apr \"..aG-31-28-31 elseif aG>31+28+31+30 and aG<=31+28+31+30+31 then return\"May \"..aG-31-28-31-30 elseif aG>31+28+31+30+31 and aG<=aE then return\"Jun \"..aG-31-28-31-30-31 elseif aG>aE and aG<=aE+31 then return\"Jul \"..aG-aE elseif aG>aE+31 and aG<=aE+31+31 then return\"Aug \"..aG-aE-31 elseif aG>aE+31+31 and aG<=aE+31+31+30 then return\"Sep \"..aG-aE-31-31 elseif aG>aE+31+31+30 and aG<=aE+31+31+30+31 then return\"Oct \"..aG-aE-31-31-30 elseif aG>aE+31+31+30+31 and aG<=aE+31+31+30+31+30 then return\"Nov \"..aG-aE-31-31-30-31 else return\"Dec \"..aG-aE-31-31-30-31-30 end end;local function aH()local ak=(y>0 or A>0 or C>0)and t.PS2 or t.PS1 or\"\\\\$ \"for Y,Z in pairs({[\"\\\\d\"]=aF(0),[\"\\\\e\"]=string.char(0x1b),[\"\\\\h\"]=string.sub(\"localhost\",1,string.find(\"localhost\",\"%.\")),[\"\\\\H\"]=\"localhost\",[\"\\\\n\"]=\"\\n\",[\"\\\\s\"]=string.gsub(t[\"0\"]:match(\"[^/]+$\"),\".lua\",\"\"),[\"\\\\t\"]=\"00:00\",[\"\\\\T\"]=\"00:00\",[\"\\\\u\"]=o.USER,[\"\\\\v\"]=t.CASH_VERSION,[\"\\\\V\"]=t.CASH_VERSION,[\"\\\\w\"]=o.PWD,[\"\\\\W\"]=o.PWD:match(\"[^/]+$\")==\".\"and\"/\"or o.PWD:match(\"[^/]+$\"),[\"\\\\%#\"]=t.LINENUM,[\"\\\\%$\"]=o.USER==\"root\"and\"#\"or\"$\",[\"\\\\([0-7][0-7][0-7])\"]=function(aa)return string.char(tonumber(aa,8))end,[\"\\\\\\\\\"]=\"\\\\\",[\"\\\\%[.+\\\\%]\"]=\"\"})do ak=string.gsub(ak,Y,Z)end;return ak end;function I(aI)local R=aI[0]if R==nil then return end;if#aI==0 and string.find(R,\"=\")~=nil then local Y=string.sub(R,1,string.find(R,\"=\")-1)t[Y]=string.sub(R,string.find(R,\"=\")+1)t[Y]=tonumber(t[Y])or t[Y]return end;local aJ={}for Y,Z in pairs(aI.vars)do aJ[Y]=_ENV[Y]_ENV[Y]=Z end;if y>0 and not x[y].cond and R~=\"else\"and R~=\"elif\"and R~=\"fi\"then return end;if u.x then P(\"- \"..table.concat(aI,\" \",0))end;local ae;if Q[R]~=nil then local aK,aL=io.input(),io.output()if aI.stdin then io.input(aI.stdin)end;if aI.stdout then io.output(aI.stdout)end;t[\"?\"]=Q[R](table.unpack(aI))if aI.stdin then io.input():close()io.input(aK)end;if aI.stdout then io.output():close()io.output(aL)end;if t[\"?\"]==nil or t[\"?\"]==true then t[\"?\"]=0 elseif t[\"?\"]==false then t[\"?\"]=1 end elseif E[R]~=nil and not L then local aM=f;f=aI;J=true;for Y,Z in ipairs(E[R])do i.run(Z)if not J then break end end;f=aM else local ab=a.stat(R)if not ab then io.stderr:write(\"cash: \"..R..\": No such file or directory\\n\")t[\"?\"]=-1;return elseif not(ab.permissions[b.getuser()]or ab.worldPermissions).execute then io.stderr:write(\"cash: \"..R..\": Permission denied\\n\")t[\"?\"]=-1;return end;if aI.stdin then aI.stdin=a.open(aI.stdin,\"rb\")end;if aI.stdout then aI.stdout=a.open(aI.stdout,\"wb\")end;if aI.stderr then aI.stderr=a.open(aI.stderr,\"wb\")end;local aN=t._;t._=R;if m then if aI.stdin then e.syscall.stdin(aI.stdin)end;if aI.stdout then e.syscall.stdout(aI.stdout)end;if aI.stderr then e.syscall.stderr(aI.stderr)end;b.exec(R,table.unpack(aI))return end;local aO=b.fork(function()if aI.stdin then e.syscall.stdin(aI.stdin)elseif aI.async then e.syscall.stdin(nil)end;if aI.stdout then e.syscall.stdout(aI.stdout)end;if aI.stderr then e.syscall.stderr(aI.stderr)end;b.exec(R,table.unpack(aI))end)while true do local U,aP=coroutine.yield()if U==\"process_complete\"and aP.pid==aO then t[\"?\"]=aP.return_value;break end;ae=b.getpinfo(aO)end;if aI.stdin then aI.stdin.close()end;if aI.stdout then aI.stdout.close()end;if aI.stderr then aI.stderr.close()end;if t[\"?\"]==nil or t[\"?\"]==true then t[\"?\"]=0 elseif t[\"?\"]==false then t[\"?\"]=1 end;t._=aN end;for Y,Z in pairs(aI.vars)do _ENV[Y]=aJ[Y]end;return ae end;function H(aI,aQ)if aI.async and not aQ then local aO=b.fork(function()return H(aI,true)end,\"cash\")local aR=#N+1;N[aR]={cmd=aI[1][0]..\" \"..table.concat(aI[1],\" \"),pid=aO,isfg=false,start=true}P(\"[\"..aR..\"] \"..(aO or\"\"))else for aS,aT in ipairs(aI)do if aT[0]then if r(aT[0])~=\"\"and(aT.last==0 and t[\"?\"]==0)or aT.last==1 and t[\"?\"]~=0 or aT.last==nil then I(aT)end else for Y,Z in pairs(aT.vars)do t[Y]=tonumber(Z)or Z end end end end;return t[\"?\"]==0 end;local aU=function(aI)local aO=b.fork(function()return H(aI,true)end,\"cash\")local aR=#N+1;N[aR]={cmd=aI[1][0]and aI[1][0]..\" \"..table.concat(aI[1],\" \")or\"cash\",pid=aO,isfg=not aI.async,start=true}if aI.async then P(\"[\"..aR..\"] \"..(aO or\"\"))end end;function i.run(...)local aV=table.concat({...},\" \"):gsub(\"%s+$\",\"\")if aV==\"\"or string.sub(aV,1,1)==\"#\"then return end;if D~=nil then if string.find(aV,\"}\")then D=nil else table.insert(E[D],aV)end;return true elseif A>0 then local aI=aq(aV)for Y,T in ipairs(aI)do T=string.sub(T,#string.match(T,\"^ *\")+1)if T==\"do\"or T==\"done\"or string.find(T,\"^do \")or string.find(T,\"^done \")then H(ay(T))end;if A>0 then table.insert(z[1].lines,T)end end;return true end;local a1=aq(aV)for Y,Z in ipairs(a1)do H(ay(Z,string.sub(Z,1,6)==\"while \"))end;return t[\"?\"]==0 end;function i.runAsync(...)local aV=table.concat({...},\" \")if aV==\"\"or string.sub(aV,1,1)==\"#\"then return end;if D~=nil then if string.find(aV,\"}\")then D=nil else table.insert(E[D],aV)end;return true elseif A>0 then local aI=aq(aV)for Y,T in ipairs(aI)do T=string.sub(T,#string.match(T,\"^ *\")+1)if T==\"do\"or T==\"done\"or string.find(T,\"^do \")or string.find(T,\"^done \")then H(ay(T))end;if A>0 then table.insert(z[1].lines,T)end end;return true end;local a1=aq(aV)for Y,Z in ipairs(a1)do aU(ay(Z,string.sub(Z,1,6)==\"while \"))end;return t[\"?\"]==0 end;if a.stat(\"/etc/cashrc\")then local S,X=io.open(\"/etc/cashrc\",\"r\")if not S then io.stderr:write(\"Could not open /etc/cashrc:\",X)else for T in S:lines()do i.run(T)end;S:close()end end;if a.stat(a.combine(o.HOME,\".cashrc\"))then local S,X=io.open(a.combine(o.HOME,\".cashrc\"),\"r\")if not S then io.stderr:write(\"Could not open .cashrc:\",X)else for T in S:lines()do i.run(T)end;S:close()end end;if a.stat(a.combine(o.HOME,\".cash_history\"))then local S,X=io.open(a.combine(o.HOME,\".cash_history\"),\"r\")if not S then io.stderr:write(\"Could not open .cashhistory:\",X)else for T in S:lines()do table.insert(F,1,T)end;S:close()end;G=a.open(a.combine(o.HOME,\".cash_history\"),\"a\")else G=a.open(a.combine(o.HOME,\".cash_history\"),\"w\")end;if h then t[\"0\"]=g;t.LINENUM=1;i.run(h)t.LINENUM=nil;return l end;if g then if g==\"-\"then t.LINENUM=1;for T in io.lines()do i.run(T)t.LINENUM=t.LINENUM+1;if not k then break end end;t.LINENUM=nil;return l else local S=io.open(g,\"r\")if not S then S=io.open(i.resolveProgram(g),\"r\")if not S then return 1 end end;t[\"0\"]=g;t.LINENUM=1;for T in S:lines()do i.run(T)t.LINENUM=t.LINENUM+1;if not k then break end end;S:close()t.LINENUM=nil;return l end end;while k do if f.i then local aW=aH()io.stdout:write(aW)end;local aX=d.readline2(F,function(aY)if aY:find\" \"then local R=aY:match\"%S*$\"local aZ=a.find(R..\"*\")for q,Z in ipairs(aZ)do if a.isDir(Z)then aZ[q]=Z:gsub(\"^\"..R:gsub(\"[%^%$%(%)%[%]%%%.%*%+%-%?]\",\"%%%1\"),\"\")..\"/\"else aZ[q]=Z:gsub(\"^\"..R:gsub(\"[%^%$%(%)%[%]%%%.%*%+%-%?]\",\"%%%1\"),\"\")..\" \"end end;table.sort(aZ)return aZ else local a_={}for Y in pairs(Q)do if Y:sub(1,#aY)==aY then a_[#a_+1]=Y:sub(#aY+1)..\" \"end end;for Y in pairs(E)do if Y:sub(1,#aY)==aY then a_[#a_+1]=Y:sub(#aY+1)..\" \"end end;for R in o.PATH:gmatch\"[^:]+\"do R=a.combine(R,aY)local aZ=a.find(R..\"*\")for aS,Z in ipairs(aZ)do a_[#a_+1]=Z:gsub(\"^\"..R:gsub(\"[%^%$%(%)%[%]%%%.%*%+%-%?]\",\"%%%1\"),\"\"):gsub(\"%.lua$\",\"\")..\" \"end end;table.sort(a_)return a_ end end)if f.i then if G and aX~=\"\"and aX~=F[1]then table.insert(F,1,aX)G.writeLine(aX)G.flush()end end;i.run(aX)end;if m then i.run(m)return t[\"?\"]end;G.close()return l\n",setuser=false,size=21838,modified=1757997039865,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["cksum.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039909,data="local a={...}local b={[0]=0x00000000,0x04c11db7,0x09823b6e,0x0d4326d9,0x130476dc,0x17c56b6b,0x1a864db2,0x1e475005,0x2608edb8,0x22c9f00f,0x2f8ad6d6,0x2b4bcb61,0x350c9b64,0x31cd86d3,0x3c8ea00a,0x384fbdbd,0x4c11db70,0x48d0c6c7,0x4593e01e,0x4152fda9,0x5f15adac,0x5bd4b01b,0x569796c2,0x52568b75,0x6a1936c8,0x6ed82b7f,0x639b0da6,0x675a1011,0x791d4014,0x7ddc5da3,0x709f7b7a,0x745e66cd,0x9823b6e0,0x9ce2ab57,0x91a18d8e,0x95609039,0x8b27c03c,0x8fe6dd8b,0x82a5fb52,0x8664e6e5,0xbe2b5b58,0xbaea46ef,0xb7a96036,0xb3687d81,0xad2f2d84,0xa9ee3033,0xa4ad16ea,0xa06c0b5d,0xd4326d90,0xd0f37027,0xddb056fe,0xd9714b49,0xc7361b4c,0xc3f706fb,0xceb42022,0xca753d95,0xf23a8028,0xf6fb9d9f,0xfbb8bb46,0xff79a6f1,0xe13ef6f4,0xe5ffeb43,0xe8bccd9a,0xec7dd02d,0x34867077,0x30476dc0,0x3d044b19,0x39c556ae,0x278206ab,0x23431b1c,0x2e003dc5,0x2ac12072,0x128e9dcf,0x164f8078,0x1b0ca6a1,0x1fcdbb16,0x018aeb13,0x054bf6a4,0x0808d07d,0x0cc9cdca,0x7897ab07,0x7c56b6b0,0x71159069,0x75d48dde,0x6b93dddb,0x6f52c06c,0x6211e6b5,0x66d0fb02,0x5e9f46bf,0x5a5e5b08,0x571d7dd1,0x53dc6066,0x4d9b3063,0x495a2dd4,0x44190b0d,0x40d816ba,0xaca5c697,0xa864db20,0xa527fdf9,0xa1e6e04e,0xbfa1b04b,0xbb60adfc,0xb6238b25,0xb2e29692,0x8aad2b2f,0x8e6c3698,0x832f1041,0x87ee0df6,0x99a95df3,0x9d684044,0x902b669d,0x94ea7b2a,0xe0b41de7,0xe4750050,0xe9362689,0xedf73b3e,0xf3b06b3b,0xf771768c,0xfa325055,0xfef34de2,0xc6bcf05f,0xc27dede8,0xcf3ecb31,0xcbffd686,0xd5b88683,0xd1799b34,0xdc3abded,0xd8fba05a,0x690ce0ee,0x6dcdfd59,0x608edb80,0x644fc637,0x7a089632,0x7ec98b85,0x738aad5c,0x774bb0eb,0x4f040d56,0x4bc510e1,0x46863638,0x42472b8f,0x5c007b8a,0x58c1663d,0x558240e4,0x51435d53,0x251d3b9e,0x21dc2629,0x2c9f00f0,0x285e1d47,0x36194d42,0x32d850f5,0x3f9b762c,0x3b5a6b9b,0x0315d626,0x07d4cb91,0x0a97ed48,0x0e56f0ff,0x1011a0fa,0x14d0bd4d,0x19939b94,0x1d528623,0xf12f560e,0xf5ee4bb9,0xf8ad6d60,0xfc6c70d7,0xe22b20d2,0xe6ea3d65,0xeba91bbc,0xef68060b,0xd727bbb6,0xd3e6a601,0xdea580d8,0xda649d6f,0xc423cd6a,0xc0e2d0dd,0xcda1f604,0xc960ebb3,0xbd3e8d7e,0xb9ff90c9,0xb4bcb610,0xb07daba7,0xae3afba2,0xaafbe615,0xa7b8c0cc,0xa379dd7b,0x9b3660c6,0x9ff77d71,0x92b45ba8,0x9675461f,0x8832161a,0x8cf30bad,0x81b02d74,0x857130c3,0x5d8a9099,0x594b8d2e,0x5408abf7,0x50c9b640,0x4e8ee645,0x4a4ffbf2,0x470cdd2b,0x43cdc09c,0x7b827d21,0x7f436096,0x7200464f,0x76c15bf8,0x68860bfd,0x6c47164a,0x61043093,0x65c52d24,0x119b4be9,0x155a565e,0x18197087,0x1cd86d30,0x029f3d35,0x065e2082,0x0b1d065b,0x0fdc1bec,0x3793a651,0x3352bbe6,0x3e119d3f,0x3ad08088,0x2497d08d,0x2056cd3a,0x2d15ebe3,0x29d4f654,0xc5a92679,0xc1683bce,0xcc2b1d17,0xc8ea00a0,0xd6ad50a5,0xd26c4d12,0xdf2f6bcb,0xdbee767c,0xe3a1cbc1,0xe760d676,0xea23f0af,0xeee2ed18,0xf0a5bd1d,0xf464a0aa,0xf9278673,0xfde69bc4,0x89b8fd09,0x8d79e0be,0x803ac667,0x84fbdbd0,0x9abc8bd5,0x9e7d9662,0x933eb0bb,0x97ffad0c,0xafb010b1,0xab710d06,0xa6322bdf,0xa2f33668,0xbcb4666d,0xb8757bda,0xb5365d03,0xb1f740b4}local function c(d)d=d..((\"%x\"):format(#d):reverse()..\"0\"):gsub(\"%x%x\",function(e)return string.char(tonumber(e:sub(1,1),16)+tonumber(e:sub(2,2),16)*16)end)local f=0;for g=1,#d do f=bit32.bxor(bit32.lshift(f,8),b[bit32.bxor(bit32.rshift(f,24),d:byte(g))])end;return bit32.bnot(f)end;if#a==0 then a[1]=\"-\"end;local h=0;for i,j in ipairs(a)do local d;if j==\"-\"then d=io.read(\"*a\")else local k,h=io.open(j,\"rb\")if k then d=k:read(\"*a\")k:close()else io.stderr:write(\"Could not open \"..j..\": \"..h..\"\\n\")h=h+1 end end;print((\"%u %d %s\"):format(c(d),#d,j))end;return h\n",setuser=false,size=3404,modified=1757997039869,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["curl.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039912,data="local a=require\"system.network\"local b=require\"system.serialization\"local c=require\"system.util\"local function d(e)return e:gsub(\"[^A-Za-z0-9%-_%.~]\",function(f)return(\"%%%02X\"):format(f:byte())end)end;local g={[100]=\"Continue\",[101]=\"Switching Protocols\",[102]=\"Processing\",[200]=\"OK\",[201]=\"Created\",[202]=\"Accepted\",[203]=\"Non-authoritative Information\",[204]=\"No Content\",[205]=\"Reset Content\",[206]=\"Partial Content\",[207]=\"Multi-Status\",[208]=\"Already Reported\",[226]=\"IM Used\",[300]=\"Multiple Choices\",[301]=\"Moved Permanently\",[302]=\"Found\",[303]=\"See Other\",[304]=\"Not Modified\",[305]=\"Use Proxy\",[307]=\"Temporary Redirect\",[308]=\"Permanent Redirect\",[400]=\"Bad Request\",[401]=\"Unauthorized\",[402]=\"Payment Required\",[403]=\"Forbidden\",[404]=\"Not Found\",[405]=\"Method Not Allowed\",[406]=\"Not Acceptable\",[407]=\"Proxy Authentication Required\",[408]=\"Request Timeout\",[409]=\"Conflict\",[410]=\"Gone\",[411]=\"Length Required\",[412]=\"Precondition Failed\",[413]=\"Payload Too Large\",[414]=\"Request-URI Too Long\",[415]=\"Unsupported Media Type\",[416]=\"Requested Range Not Satisfiable\",[417]=\"Expectation Failed\",[418]=\"I'm a teapot\",[421]=\"Misdirected Request\",[422]=\"Unprocessable Entity\",[423]=\"Locked\",[424]=\"Failed Dependency\",[426]=\"Upgrade Required\",[428]=\"Precondition Required\",[429]=\"Too Many Requests\",[431]=\"Request Header Fields Too Large\",[444]=\"Connection Closed Without Response\",[451]=\"Unavailable For Legal Reasons\",[499]=\"Client Closed Request\",[500]=\"Internal Server Error\",[501]=\"Not Implemented\",[502]=\"Bad Gateway\",[503]=\"Service Unavailable\",[504]=\"Gateway Timeout\",[505]=\"HTTP Version Not Supported\",[506]=\"Variant Also Negotiates\",[507]=\"Insufficient Storage\",[508]=\"Loop Detected\",[510]=\"Not Extended\",[511]=\"Network Authentication Required\",[599]=\"Network Connect Timeout Error\"}local h=assert(c.argparse({[\"\"]={stopProcessingOnPositionalArgument=true},A=true,[\"user-agent\"]=\"@A\",b=true,cookie=\"@b\",c=true,[\"cookie-jar\"]=\"@c\",d=\"multiple\",data=\"@d\",[\"data-ascii\"]=\"@d\",D=true,[\"dump-header\"]=\"@D\",e=true,referer=\"@e\",G=false,get=\"@G\",H=\"multiple\",header=\"@H\",I=false,head=\"@I\",i=false,include=\"@i\",J=false,[\"remote-header-name\"]=\"@J\",L=false,location=\"@L\",o=true,output=\"@o\",O=false,[\"remote-name\"]=\"@O\",r=true,range=\"@r\",R=false,run=\"@R\",s=false,silent=\"@s\",S=false,[\"show-error\"]=\"@S\",T=true,[\"upload-file\"]=\"@T\",u=true,user=\"@u\",v=false,verbose=\"@v\",X=true,request=\"@X\",[\"#\"]=false,[\"progress-bar\"]=\"@#\",basic=false,[\"data-binary\"]=\"multiple\",[\"data-raw\"]=\"multiple\",[\"data-urlencode\"]=\"multiple\",digest=false,[\"disallow-username-in-url\"]=false,[\"doh-url\"]=true,json=true,[\"location-trusted\"]=false,[\"oauth2-bearer\"]=true,[\"output-dir\"]=true,post301=false,post302=false,post303=false,retry=\"number\",[\"retry-delay\"]=\"number\",h=false,help=\"@h\"},...))if h.h then print[[\nUsage: curl [options...] URL\nOptions:\n  -o, --output <path>     Path to write to\n  -H, --header <header>   Add a header to the request\n      --run               Run the file as a Lua script\n  -h, --help              Show this help\n]]return end;local i=h[1]if not i then error(\"curl: Missing URL.\")end;local j={}if h.H then for k,l in ipairs(h.H)do local m,n=l:match(\"^([^:]+):%s*(.+)$\")if not m then error(\"curl: Malformed header \"..l)end;j[m]=n end end;if h.A then j[\"User-Agent\"]=h.A end;if h.b then end;if h.c then end;if h.e then j[\"Referer\"]=h.e end;if h.u then if not h.u:find\":\"then io.stdout:write(\"Password: \")terminal.termctl({echo=false})h.u=h.u..\":\"..io.stdin:read()terminal.termctl({echo=true})print()end;if h.basic then j[\"Authorization\"]=\"Basic \"..b.base64.encode(h.u)elseif h.digest then elseif h[\"oauth2-bearer\"]then j[\"Authorization\"]=\"Bearer \"..h[\"oauth2-bearer\"]else i=i:gsub(\"^(https?://)\",\"%1\"..h.u)end end;local o;if h.d then for k,l in ipairs(h.d)do if o then o=o..\"&\"else o=\"\"end;if l:sub(1,1)==\"@\"then local p=l:sub(2):gsub(\"[\\r\\n]\",\"\")local q,r=io.open(p,\"r\")if not q then error(\"curl: Could not open \"..p..\": \"..r)end;o=o..q:read(\"*a\")q:close()else o=o..l end end end;if h[\"data-raw\"]then for k,l in ipairs(h[\"data-raw\"])do if o then o=o..\"&\"else o=\"\"end;o=o..l end end;if h[\"data-binary\"]then for k,l in ipairs(h[\"data-binary\"])do if o then o=o..\"&\"else o=\"\"end;if l:sub(1,1)==\"@\"then local p=l:sub(2):gsub(\"[\\r\\n]\",\"\")local q,r=io.open(p,\"rb\")if not q then error(\"curl: Could not open \"..p..\": \"..r)end;o=o..q:read(\"*a\")q:close()else o=o..l end end end;if h[\"data-urlencode\"]then for k,l in ipairs(h[\"data-urlencode\"])do if o then o=o..\"&\"else o=\"\"end;local s,t=l:match\"^([^=]+)=(.+)$\"local u,p=l:match\"^([^@]*)@(.*)$\"if s then o=o..s..\"=\"..d(t)elseif u then if u~=\"\"then o=o..u..\"=\"end;local q,r=io.open(p,\"r\")if not q then error(\"curl: Could not open \"..p..\": \"..r)end;o=o..d(q:read(\"*a\"))q:close()else o=o..l end end end;if h.json then if o then o=o..\"&\"else o=\"\"end;if h.json:sub(1,1)==\"@\"then local p=h.json:sub(2):gsub(\"[\\r\\n]\",\"\")local q,r=io.open(p,\"rb\")if not q then error(\"curl: Could not open \"..p..\": \"..r)end;o=o..q:read(\"*a\")q:close()else o=o..h.json end;j[\"Content-Type\"]=\"application/json\"j[\"Accept\"]=\"application/json\"end;local v;if h.X then v=h.X:upper()elseif h.G then v=\"GET\"if o then i=i..\"?\"..o end elseif h.I then v=\"HEAD\"elseif h.T then v=\"PUT\"local q,r=io.open(h.T,\"rb\")if not q then error(\"curl: Could not open \"..h.T..\": \"..r)end;o=q:read(\"*a\")q:close()elseif o then v=\"POST\"else v=\"GET\"end;if h.v then io.stderr:write(\"* Opening connection to \"..i:match(\"^https?://([^/]+)\")..\"\\n\")io.stderr:write(\"> GET \"..i:match(\"^https?://[^/]+(/[^#]+)\")..\" HTTP/1.1\\n\")for m,l in pairs(j)do io.stderr:write(\"> \"..m..\": \"..l..\"\\n\")end;io.stderr:write(\"> \\n\")end;local w;for k=0,h.retry or 0 do w=a.connect{url=i,method=v,headers=j,redirect=h.L}w:write(o)local x=false;while true do local y,z=coroutine.yield()if y==\"handle_status_change\"and z.id==w.id then if z.status==\"open\"then x=true;break elseif z.status==\"error\"then io.stderr:write(select(2,w:status()))w=nil;break end end end;if x then break end end;if not w then return false end;local A=w:responseCode()local B=w:responseHeaders()if h.o then io.output(h.o)elseif h.O then local s=i:gsub(\"%?.*$\",\"\"):gsub(\"#.*$\",\"\"):match(\"([^/]+)/*$\")if h.J then s=B[\"Content-Disposition\"]or s end;if h[\"output-dir\"]then s=h[\"output-dir\"]..\"/\"..s end;io.output(s)end;if h.v or h.i then local C=function(D)return io.write(D)end;if h.v then C=function(D)return io.stderr:write(\"< \"..D)end end;C(\"HTTP/1.1 \"..A..\" \"..(g[A]or\"Unknown\"))for m,l in pairs(B)do C(m..\": \"..l)end;C(\"\")end;if h.D then local q,r=io.open(h.D,\"w\")if q then for m,l in pairs(B)do q:write(m..\": \"..l..\"\\n\")end;q:close()else io.stderr:write(\"curl: Could not open header dump file: \"..r..\"\\n\")end end;if h.R then if math.floor(A/100)~=2 then error(\"curl: Got HTTP response \"..A..\", not running data.\")end;local s=i:gsub(\"%?.*$\",\"\"):gsub(\"#.*$\",\"\"):match(\"([^/]+)/*$\")if h.J then s=B[\"Content-Disposition\"]or s end;local E,r=load(function()return w:read(\"*L\")end,\"=\"..s)if not E then error(\"curl: Could not load file: \"..r)end;return E(table.unpack(h,2,h.n))end;io.write(w:read(\"*a\"))w:close()io.output():close()\n",setuser=false,size=7062,modified=1757997039872,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["unlink.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039931,data="return coroutine.yield(\"syscall\",\"remove\",...)\n",setuser=false,size=47,modified=1757997039897,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["ls.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039920,data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=assert(b.argparse({A=false,C=false,F=false,H=false,L=false,R=false,S=false,a=false,c=false,d=false,f=false,g=false,h=false,i=false,k=false,l=false,m=false,n=false,o=false,p=false,q=false,r=false,s=false,t=false,u=false,x=false,[\"1\"]=false},...))if not c[1]then c[1]=\".\"end;if c.f then c.a,c.r,c.S,c.t=true,false,false,false end;if c.a then c.A=true end;if c.g or c.n or c.o then c.l=true end;local d={file='-',directory='d',fifo='p',link='l'}local function e(f,g,h)if c.p and g.type==\"directory\"then f=f..\"/\"elseif c.F then if g.type==\"directory\"then f=f..\"/\"elseif g.type==\"fifo\"then f=f..\"|\"elseif g.type==\"link\"then f=f..\"@\"elseif g.worldPermissions.execute then f=f..\"*\"end end;if c.q then f=f:gsub(\"[\\0-\\31\\127-\\255]\",\"?\")end;if c.s then io.stdout:write(math.ceil(g.size/(c.k and 1024 or 512))..\" \")end;if c.l then local i=g.worldPermissions;local j=g.permissions[g.owner]or g.worldPermissions;local k=(i.read and'r'or'-')..(i.write and'w'or'-')..(i.execute and'x'or'-')local l=(\"%s%s%s%s%s%s\"):format(d[g.type],j.read and'r'or'-',j.write and'w'or'-',j.execute and(g.setuser and's'or'x')or'-',k,k)local m=os.time()-g.modified>15552000000 and os.date(\"%b %e  %Y\",g.modified/1000)or os.date(\"%b %e %H:%M\",g.modified/1000)if c.h then local n,o;if g.size>=1000000000 then n,o=g.size/1000000000,\"G\"elseif g.size>=1000000 then n,o=g.size/1000000,\"M\"elseif g.size>=1000 then n,o=g.size/1000,\"k\"else n=g.size end;if o then print((\"%s %u %s %s\\t%4.3g%s %s %s%s\"):format(l,0,c.g and\"\"or g.owner,\"\",n,o,m,f,g.type==\"link\"and\" -> \"..g.link or\"\"))else print((\"%s %u %s %s\\t%5.3g %s %s%s\"):format(l,0,c.g and\"\"or g.owner,\"\",n,m,f,g.type==\"link\"and\" -> \"..g.link or\"\"))end else print((\"%s %u %s %s\\t%\"..h..\"u %s %s%s\"):format(l,0,c.g and\"\"or g.owner,\"\",math.ceil(g.size/(c.k and 1024 or 512)),m,f,g.type==\"link\"and\" -> \"..g.link or\"\"))end elseif c.m then io.stdout:write(f..\", \")elseif c.C then elseif c.x then else print(f)end end;for p,q in ipairs(c)do if#c>1 then print(q..\":\")end;local g,r=a.stat(q,true)local s;if g then if g.type==\"directory\"then s=a.list(q)else q,s=a.dirname(q),{a.basename(q)}end;local t={}if c.a then s[#s+1]=\".\"s[#s+1]=\"..\"end;for p,u in ipairs(s)do if c.A or not u:match\"^%.\"then local v=a.stat(a.combine(q,u),true)if v then t[#t+1]={name=u,stat=v}end end end;local w;if c.r then w=function(x,y)return x>=y end else w=function(x,y)return x<y end end;if c.S then table.sort(t,function(x,y)if x.stat.size==y.stat.size then return w(x.name,y.name)else return not w(x.stat.size,y.stat.size)end end)elseif c.t then table.sort(t,function(x,y)if x.stat.modified==y.stat.modified then return w(x.name,y.name)else return not w(x.stat.modified,y.stat.modified)end end)elseif not c.f then table.sort(t,function(x,y)return w(x.name,y.name)end)end;if c.l or c.s then local n=0;for p,z in ipairs(t)do n=n+math.ceil(z.stat.size/(c.k and 1024 or 512))end;print(\"total \"..n)end;local A=0;for p,z in ipairs(t)do A=math.max(A,math.ceil(math.log(z.stat.size/(c.k and 1024 or 512),10)))end;for p,z in ipairs(t)do e(z.name,z.stat,A)end;if c.m then print()end else io.stderr:write(\"ls: cannot access '\"..q..\"': \"..(r or\"\")..\"\\n\")end end\n",setuser=false,size=3202,modified=1757997039884,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["pwd.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039926,data="print(select(2,coroutine.yield(\"syscall\",\"getcwd\")))\n",setuser=false,size=53,modified=1757997039890,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["unmount.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039932,data="return coroutine.yield(\"syscall\",\"unmount\",assert(...,\"Usage: unmount <path>\"))\n",setuser=false,size=80,modified=1757997039898,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["uncompress.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039931,data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=string.char;local type=type;local d=string.sub;local e=table.concat;local f=math.floor;local g=string.byte;local h={}for i=0,255 do local j=c(i)h[i]=j end;local function k(l,m,n,o)if n>=256 then n,o=0,o+1;if o>=256 then m={}o=1 end end;m[o*256+n]=l;n=n+1;return m,n,o end;local function p(q)if type(q)~=\"string\"then return nil,\"string expected, got \"..type(q)end;if#q<1 then return nil,\"invalid input - not a compressed string\"end;local r=#q;if r<3 then return nil,\"invalid input - not a compressed string\"end;if d(q,1,2)~=\"\\x1F\\x9D\"then return nil,\"invalid input - not a compressed string\"end;local s,t,u,v=9,0,0,4;local function w()while u<s do if v>r then return nil end;t=t+g(q,v)*2^u;v=v+1;u=u+8 end;local x=t%2^s;t=f(t/2^s)u=u-s;return x end;local m={}local n,o=1,1;local y={}local z=1;local A=w()y[z]=h[A]or m[A]z=z+1;while true do local B=w()if not B then break end;local C=h[A]or m[A]if not C then return nil,\"could not find last from dict. Invalid input?\"end;local D=h[B]or m[B]if D then y[z]=D;z=z+1;m,n,o=k(C..d(D,1,1),m,n,o)else local E=C..d(C,1,1)y[z]=E;z=z+1;m,n,o=k(E,m,n,o)end;if n==256 and o==2^(s-8)-1 then local F=u%8;if F~=0 then t=f(t/2^F)u=u-F end;s=s+1 end;A=B end;return e(y)end;local G=assert(b.argparse({c=false,f=false,k=false,v=false},...))local H;if G[1]==\"-\"or G[1]==nil then H=io.read(\"*a\")else local I=assert(io.open(G[1],\"rb\"))H=I:read(\"*a\")I:close()end;local J=assert(p(H))if G.v then io.stderr:write((\"%s: %.3g%%\\n\"):format(G[1],#J/#H*100))end;if G.c then io.write(J)return end;local K=G[1]:gsub(\"%.Z$\",\"\")if not G.f and a.exists(K)then io.write(\"replace file \"..K..\"? (y/N) \")local L=io.read()if L~=\"Y\"and L~=\"y\"then return 1 end end;local I=assert(io.open(K,\"wb\"))I:write(J)I:close()if not G.k then os.remove(G[1])end\n",setuser=false,size=1826,modified=1757997039897,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["ps.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039925,data="local a=setmetatable({},{__index=function(self,b)return function(...)local c=table.pack(coroutine.yield(\"syscall\",b,...))if c[1]then return table.unpack(c,2,c.n)else error(c[2],2)end end end,__newindex=function()end})local d=a.getplist()print(\"PID\\tTTY\\tTIME\\t\\tCMD\")for e,f in ipairs(d)do local g=a.getpinfo(f)if g then print(f,g.stdout and\"tty\"..g.stdout or\"?\",(\"%02d:%02d:%02d.%03d\"):format(math.floor(g.cputime/3600),math.floor(g.cputime/60),math.floor(g.cputime),math.floor(g.cputime*1000)%1000),g.name)end end\n",setuser=false,size=516,modified=1757997039890,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["cp.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039912,data="local a=require\"system.util\"local b=require\"system.filesystem\"local c=assert(a.argparse({P=false,f=false,i=false,p=false,R=false,H=false,L=false,n=false},...))if#c<2 then error(\"cp: missing operand\")end;local function d(e,f)local g=b.stat(e)if not g then error(\"cp: \"..e..\": No such file or directory\")end;local h=b.stat(f)if g.type==\"directory\"then local i=false;if not c.R then io.stderr:write(\"cp: -R not specified, omitting directory '\"..e..\"'\\n\")return false end;if h then if h.type~=\"directory\"then io.stderr:write(\"cp: omitting existing \"..h.type..\" '\"..f..\"'\\n\")return false end else b.mkdir(f)i=true end;local j=b.list(e)local k=true;for l,m in ipairs(j)do k=d(b.combine(e,m),b.combine(f,m))and k end;if i then b.chmod(f,nil,g.worldPermissions)for n,m in pairs(g.permissions)do b.chmod(f,n,m)end;if g.owner then b.chown(f,g.owner)end end;return k else if h then if c.i then io.stderr:write(\"overwrite \"..h.type..\" \"..f..\"? \")local o=io.read()if o:lower()~=\"y\"then return false end elseif c.n then return false end end;local p,q=b.open(e,\"rb\")if not p then error(\"cp: \"..e..\": \"..q,2)end;local r,q=b.open(f,\"wb\")if not r then if c.f and h then b.remove(f)r,q=b.open(f,\"wb\")end;if not r then p.close()error(q,2)end end;repeat local s=p.read(512)if s then r.write(s)end until not s;r.close()p.close()if c.p then b.chmod(f,nil,g.worldPermissions)for n,m in pairs(g.permissions)do b.chmod(f,n,m)end;if g.owner then b.chown(f,g.owner)end end;return true end end;local t=table.remove(c)if#c==1 and not b.isDir(t)then return d(c[1],t)else if not b.isDir(t)then error(\"cp: target is not a directory\")end;local k=true;for l,m in ipairs(c)do k=d(m,b.combine(t,b.basename(m)))and k end;return k end\n",setuser=false,size=1696,modified=1757997039871,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["man.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039922,data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=assert(b.argparse({k=false,apropos=\"@k\",P=true,pager=\"@P\",M=true,manpath=\"@M\",S=true,s=\"@S\",sections=\"@S\",r=true,prompt=\"@r\",u=false,update=\"@u\"},...))local d=c.M or os.getenv(\"MANPATH\")or\"/usr/share/man\"local e=c.S or os.getenv(\"MANSECT\")or\"1 8 3 2 5 4 9 6 7\"local f={[\"and\"]=true,[\"break\"]=true,[\"do\"]=true,[\"else\"]=true,[\"elseif\"]=true,[\"end\"]=true,[\"for\"]=true,[\"function\"]=true,[\"if\"]=true,[\"in\"]=true,[\"local\"]=true,[\"not\"]=true,[\"or\"]=true,[\"repeat\"]=true,[\"return\"]=true,[\"then\"]=true,[\"until\"]=true,[\"while\"]=true}local g={[\"false\"]=true,[\"nil\"]=true,[\"true\"]=true}if c.u then for h in d:gmatch\"[^:]+\"do local i=assert(io.open(a.combine(h,\".mandb\"),\"w\"))for j,k in ipairs(a.list(h))do if k:match\"^man\"then for j,l in ipairs(a.list(a.combine(h,k)))do local m=l:match(\"^[^%.]+\")..\"(\"..k:sub(4)..\"): \"local n=io.open(a.combine(h,k,l),\"r\")if n then for o in n:lines()do local p=o:match(\"<summary>(.-)</summary>\")if p then m=m..p;break end end;n:close()end;i:write(m..\"\\n\")end end end;i:close()end;return true elseif c.k then for j,q in ipairs(c)do for h in d:gmatch\"[^:]+\"do local i=io.open(a.combine(h,\".mandb\"),\"r\")if i then for o in i:lines()do if o:match(q)then print(o)end end;i:close()end end end;return true end;if#c>1 and c[1]:match(\"^%d\")then e=table.remove(c,1)end;for j,q in ipairs(c)do for h in d:gmatch\"[^:]+\"do local r=nil;for s in e:gmatch\"[0-9a-z]+\"do if a.exists(a.combine(h,\"man\"..s,q..\".md\"))then r=a.combine(h,\"man\"..s,q..\".md\")break elseif a.exists(a.combine(h,\"man\"..s,q))then r=a.combine(h,\"man\"..s,q)break end end;if r then local m=\"\"local t=true;local u=false;for o in io.lines(r)do if u then if o==\"```\"then u=false;t=true;m=m..\"\\x1b[0m\\n\"else if u==\"lua\"then o=o:gsub(\"%f[%d](%d+)%f[%D]\",\"\\x1b[94m%1\\x1b[37m\"):gsub(\"%-%-.*$\",\"\\x1b[32m%0\\x1b[37m\"):gsub(\"%f[\\\\'\\\"]['\\\"].*%f[\\\\'\\\"]['\\\"]\",\"\\x1b[31m%0\\x1b[37m\")for v in pairs(f)do o=o:gsub(\"%f[0-9A-Za-z_]\"..v..\"%f[^0-9A-Za-z_]\",\"\\x1b[93m%0\\x1b[37m\")end;for v in pairs(g)do o=o:gsub(\"%f[0-9A-Za-z_]\"..v..\"%f[^0-9A-Za-z_]\",\"\\x1b[34m%0\\x1b[37m\")end end;m=m..o..\"\\n\"end else if o:match\"^#\"then if not t then m=m..\"\\n\"end;m=m..\"\\x1b[92m\"..o:match\"^#+%s*(.*)$\"..\"\\x1b[0m\\n\"t=true elseif o:match\"^%s*[%-%*]%s+\"then if not t then m=m..\"\\n\"end;m=m..o:match\"^(%s*)\"..\" \\7 \"..o:match\"^%s*[%-%*]%s+(.*)$\"..\"\\n\"t=true elseif o:match\"^%d+%.%s\"then if not t then m=m..\"\\n\"end;m=m..o..\"\\n\"t=true elseif o:match\"^>%s\"then if not t then m=m..\"\\n\"end;m=m..\"\\x1b[47m\\x1b[30m\\x95\\x1b[49m\\x1b[37m \"..o:match\"^>%s+(.*)$\"..\"\\x1b[0m\\n\"t=true elseif o:match\"^%-%-%-\"then if not t then m=m..\"\\n\"end;m=m..\"\\x8C\\x8C\\x8C\\x8C\\x8C\\x8C\\x8C\\x8C\\x8C\\x8C\\n\"t=true elseif o:match\"<summary>.*</summary>\"then elseif o:match\"^```\"then if o==\"```lua\"then u=\"lua\"else u=true end;if not t then m=m..\"\\n\"end;m=m..\"\\x1b[37m\"else o=o:gsub(\"%f[\\\\%*]%*%*(%S.-)%f[\\\\%*]%*%*\",\"\\x1b[94m%1\\x1b[0m\"):gsub(\"%f[\\\\%*]%*(%S.-)%f[\\\\%*]%*\",\"\\x1b[92m%1\\x1b[0m\"):gsub(\"%f[\\\\`]`(.-)%f[\\\\`]`\",\"\\x1b[37m%1\\x1b[0m\"):gsub(\"\\\\x(%x%x)\",function(w)return string.char(tonumber(w,16))end):gsub(\"\\\\e\",\"\\x1b\")m=m..o..\" \"t=false end;if not t then if o:match\"^%s*$\"then m=m..\"\\n\\n\"t=true elseif o:match\"%s%s$\"then m=m..\"\\n\"t=true end end end end;io.popen(c.P or\"/bin/less -P '\"..(c.r or\"Manual page \"..q)..\"'\",\"w\"):write(m..\"\\n\"):close()break end end end\n",setuser=false,size=3328,modified=1757997039885,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["dj.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039914,data="local a=require\"system.hardware\"local b={...}local c=b[2]and a.wrap(b[2])or a.find(\"drive\")if not c then if b[2]then error(\"Could not find drive named \"..b[2])else error(\"Could not find any attached drives\")end end;if b[1]==\"play\"then local d=c.state;if not d then error(\"No disc in drive\")elseif not d.audio then error(\"Disc in drive is not a record\")end;c.play()print(\"Playing '\"..d.audio..\"'\")elseif b[1]==\"stop\"then c.stop()else error(\"Usage: dj <play|stop> [drive]\")end\n",setuser=false,size=475,modified=1757997039874,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["printf.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039925,data="local a={...}if#a<1 then error(\"printf: missing format\")end;local b=table.remove(a,1)local c={}for d in b:gmatch\"%%[%-%+ #0]?%d*%.?%d*[jzt]?[diuoxXfFeEgGaAcsq]\"do local e=d:sub(-1,-1)local f=#c+1;local g=assert(a[f],\"printf: missing argument for \"..d)if e==\"q\"or e==\"s\"then c[f]=g else c[f]=assert(tonumber(g),\"printf: argument \"..g..\" not a number\")end end;print(b:format(table.unpack(c)))\n",setuser=false,size=391,modified=1757997039890,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["lsdev.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039920,data="local a=require\"system.hardware\"local b=require\"system.util\"local c=assert(b.argparse({v=false},...))local function d(e,f)for g,h in ipairs(a.children(e))do local i=a.info(e..\"/\"..h)if c.v then print((\"%sDevice %s (%s): %s\"):format((\" \"):rep(f),h,i.uuid,i.displayName or\"\"))io.write((\" \"):rep(f)..\"Types: \")local j=true;for k,l in pairs(i.types)do io.write((j and\"\"or\", \")..k..\" (\"..l..\")\")j=false end;print()else print((\"%sDevice %s: %s\"):format((\" \"):rep(f),h,i.displayName or\"\"))end;d(e..\"/\"..h,f+2)end end;local i=a.info(\"/\")if c.v then print((\"Device / (%s): %s\"):format(i.uuid,i.displayName or\"\"))io.write(\"Types: \")local j=true;for k,l in pairs(i.types)do io.write((j and\"\"or\", \")..k..\" (\"..l..\")\")j=false end;print()else print((\"Device /: %s\"):format(i.displayName or\"\"))end;d(\"/\",2)\n",setuser=false,size=792,modified=1757997039884,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["uname.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039930,data="local a=require\"system.util\"local b=assert(a.argparse({a=false,m=false,n=false,r=false,s=false,v=false},...))if next(b)==nil then b.s=true end;if b.a then b.m,b.n,b.r,b.s,b.v=true,true,true,true,true end;local c={}if b.s then c[#c+1]=\"Phoenix\"end;if b.n then c[#c+1]=a.syscall.devinfo(\"/\").name end;if b.r then c[#c+1]=a.syscall.version()end;if b.v then c[#c+1]=a.syscall.version(true)end;if b.m then c[#c+1]=a.syscall.cchost()end;print(table.concat(c,\" \"))\n",setuser=false,size=458,modified=1757997039896,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["label.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039918,data="local a=require\"system.hardware\"local b={...}if b[1]==\"set\"and not b[3]then b[3],b[2]=b[2],nil end;local c;if b[2]then c=assert(a.wrap(b[2]),\"No such device '\"..b[2]..\"'\")else c=a.wrap(\"/\")end;if not c.getLabel then error(\"Device does not support labels\")end;if b[1]==\"get\"then local d=c.label;if d then print((b[2]or\"Computer\")..\" is labeled '\"..d..\"'\")else print(\"No \"..(b[2]or\"computer\")..\" label\")end elseif b[1]==\"set\"then c.label=b[3]print(\"Set \"..(b[2]or\"computer\")..\" label to '\"..b[3]..\"'\")elseif b[1]==\"clear\"then c.label=nil;print(\"Cleared \"..(b[2]or\"computer\")..\" label\")else error(\"Usage: label <get|set|clear> [drive] [label]\")end\n",setuser=false,size=645,modified=1757997039881,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["shell.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997041053,data="for a,b in pairs(require\"craftos\")do if a~=\"shell\"and a~=\"multishell\"then _G[a]=b end end;if not fs.isDir(\"/rom\")then if select(2,coroutine.yield(\"syscall\",\"getuser\"))~=\"root\"then error(\"The CraftOS ROM must be mounted to /rom. Please mount it as root.\")end;fs.makeDir(\"/rom\")end;if not fs.isDir(\"/rom/programs\")then if select(2,coroutine.yield(\"syscall\",\"getuser\"))~=\"root\"then error(\"The CraftOS ROM must be mounted to /rom. Please mount it as root.\")end;coroutine.yield(\"syscall\",\"mount\",\"craftos\",\"/rom\",\"/rom\",{})end;local c=coroutine.resume;function coroutine.resume(d,...)local e=table.pack(c(d,...))while e[1]and e[2]==\"syscall\"do e=table.pack(c(d,coroutine.yield(table.unpack(e,2,e.n))))end;return table.unpack(e,1,e.n)end;coroutine.yield(\"syscall\",\"chdir\",\"/\")return coroutine.yield(\"syscall\",\"exec\",\"/rom/programs/shell.lua\",...)\n",setuser=false,size=841,modified=1757997041040,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["renice.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039927,data="local a=require\"system.process\"local b=require\"system.util\"local c=assert(b.argparse({n=\"number\"},...))if not c[1]or not c.n then error(\"Usage: renice -n <increment> <PID...>\")end;for d,e in ipairs(c)do e=tonumber(e)or error(\"renice: argument \"..e..\" is not a PID\")a.nice(c.n,e)end\n",setuser=false,size=282,modified=1757997039892,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["mkfifo.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039923,data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=assert(b.argparse({m=true},...))local function d(e)local f=a.stat(e,true)local g=tonumber(c.m,8)if g then a.chmod(e,f.owner,bit32.band(bit32.rshift(g,6),7))a.chmod(e,nil,bit32.band(g,7))else for h in c.m:gmatch\"[^,]+\"do local i,j=h:match\"^([^%+%-=]*)([%+%-=][rwxs]+)$\"if not i then error(\"chmod: invalid mode: \"..h)end;if i==\"\"then i=nil end;a.chmod(e,i,j)end end end;for k,l in ipairs(c)do a.mkfifo(l)if c.m then d(l)end end\n",setuser=false,size=496,modified=1757997039887,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["comm.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039911,data="local a=require\"system.util\"local b=assert(a.argparse({[\"1\"]=false,[\"2\"]=false,[\"3\"]=false},...))if#b<2 then error(\"Usage: comm [-123] <file1> <file2>\")end;local c=b[1]==\"-\"and io.input()or assert(io.open(b[1],\"r\"))local d=b[2]==\"-\"and io.input()or assert(io.open(b[2],\"r\"))local e,f=c,d;local g=e:read(\"*l\")while g do local h=f:read(\"*l\")if not h then break end;if g<h then if e==c then if not b[\"1\"]then print(g)end elseif not b[\"2\"]then print((b[\"1\"]and\"\"or\"\\t\")..g)end;e,f=f,e;g=h elseif g==h then if not b[\"3\"]then print((b[\"1\"]and\"\"or\"\\t\")..(b[\"2\"]and\"\"or\"\\t\")..g)end;g=e:read(\"*l\")if not g then e,g=f,h;break end else if f==c then if not b[\"1\"]then print(h)end elseif not b[\"2\"]then print((b[\"1\"]and\"\"or\"\\t\")..h)end end end;while g do if e==c then if not b[\"1\"]then print(g)end elseif not b[\"2\"]then print((b[\"1\"]and\"\"or\"\\t\")..g)end;g=e:read(\"*l\")end;c:close()if c~=d then d:close()end\n",setuser=false,size=893,modified=1757997039870,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["nm.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039924,data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=require\"system.util\"local d=assert(c.argparse({A=false,e=false,f=false,g=false,o=false,P=false,t=true,u=false,v=false,x=false},...))if d.t then assert(d.t:match\"^[dox]$\",\"nm: invalid option '\"..d.t..\"' for argument -t\")end;if#d==0 then error(\"nm: missing file operand\")end;if d.o then d.t=\"o\"end;d.t=d.t or(d.P and\"d\"or\"x\")local e={d=\"%s%s %s %d %d\",o=\"%s%s %s %o %o\",x=\"%s%s %s %x %x\"}for f,g in ipairs(d)do local h={}local require=require;local i={}local j=setmetatable({require=function(k)local l=require(k)local m={name=k,lib=l,used={}}h[#h+1]=m;return setmetatable({},{__index=function(f,n)m.used[n]=true;return l[n]end,__newindex=function(f,n,o)m.used[n]=true;l[n]=o end})end,__scrapelocals=function()if not d.g and not d.e then for p=1,math.huge do local q,r=debug.getlocal(2,p)if not q then break end;local s=type(r)if s==\"function\"then i[#i+1]={lib=g,type=\"t\",name=q,value=tonumber(tostring(r):match(\": (%x+)\"),16),size=#string.dump(r)}elseif s==\"string\"then i[#i+1]={lib=g,type=\"d\",name=q,value=p,size=#r}elseif s==\"number\"then i[#i+1]={lib=g,type=\"d\",name=q,value=p,size=8}elseif s==\"boolean\"then i[#i+1]={lib=g,type=\"d\",name=q,value=p,size=1}elseif s==\"nil\"then i[#i+1]={lib=g,type=\"d\",name=q,value=p,size=0}else i[#i+1]={lib=g,type=\"d\",name=q,value=tonumber(tostring(r):match(\": (%x+)\"),16),size=#r or 8}end end end end},{__index=_G})local t,u=a.open(g,\"r\")if t then local v=t.readAll()t.close()local w;repeat local x=v:find(\"%f[A-Za-z0-9_]return%f[^A-Za-z0-9_]\",w and w+1)if x then w=x end until not x;if w and v:find(\"%f[A-Za-z0-9_]end%f[^A-Za-z0-9_]\",w)then w=nil end;if w then v=v:sub(1,w-1)..\" __scrapelocals() \"..v:sub(w)else v=v..\" __scrapelocals()\"end;local y,u=load(v,\"@\"..g,nil,j)if y then local z=b.getcwd()b.chdir(a.dirname(g))local A,B=pcall(y,a.basename(g):gsub(\"%.lua$\",\"\"),g)b.chdir(z)if A then local C=type(B)if not d.u then if C==\"function\"then i[#i+1]={lib=g,type=\"T\",name=\"\",value=tonumber(tostring(B):match(\": (%x+)\"),16),size=#string.dump(B)}elseif C==\"table\"then local p=1;for q,r in pairs(B)do local s=type(r)if s==\"function\"then i[#i+1]={lib=g,type=\"T\",name=q,value=tonumber(tostring(r):match(\": (%x+)\"),16),size=#string.dump(r)}elseif s==\"string\"then i[#i+1]={lib=g,type=\"D\",name=q,value=p,size=#r}elseif s==\"number\"then i[#i+1]={lib=g,type=\"D\",name=q,value=p,size=8}elseif s==\"boolean\"then i[#i+1]={lib=g,type=\"D\",name=q,value=p,size=1}elseif s==\"nil\"then i[#i+1]={lib=g,type=\"D\",name=q,value=p,size=0}else i[#i+1]={lib=g,type=\"D\",name=q,value=tonumber(tostring(r):match(\": (%x+)\"),16),size=#r or 8}end;p=p+1 end end end else io.stderr:write(\"nm: could not require \"..g..\": \"..B..\"\\n\")end;if not d.u then local p=1;for q,r in pairs(j)do if q~=\"require\"and q~=\"__scrapelocals\"and q~=\"_ENV\"and q~=\"_G\"then local s=type(r)if s==\"function\"then i[#i+1]={lib=g,type=\"A\",name=q,value=tonumber(tostring(r):match(\": (%x+)\"),16),size=#string.dump(r)}elseif s==\"string\"then i[#i+1]={lib=g,type=\"A\",name=q,value=p,size=#r}elseif s==\"number\"then i[#i+1]={lib=g,type=\"A\",name=q,value=p,size=8}elseif s==\"boolean\"then i[#i+1]={lib=g,type=\"A\",name=q,value=p,size=1}elseif s==\"nil\"then i[#i+1]={lib=g,type=\"A\",name=q,value=p,size=0}else i[#i+1]={lib=g,type=\"A\",name=q,value=tonumber(tostring(r):match(\": (%x+)\"),16),size=#r or 8}end;p=p+1 end end end;if not d.g and not d.e then for f,l in ipairs(h)do for q in pairs(l.used)do i[#i+1]={lib=l.name,type=\"U\",name=q}end end end;if d.v then table.sort(i,function(D,E)return(D.value or-1)<(E.value or-1)end)else table.sort(i,function(D,E)return D.name<E.name end)end;if#d>1 then print(g..\":\")end;for f,F in ipairs(i)do if d.P then print(e[d.t]:format(d.A and F.lib..\": \"or\"\",F.name,F.type,F.value or 0,F.size or 0))else if d.A then io.write(F.name..\":\")end;if F.value then io.write((\"%016x \"):format(F.value))else io.write(\"         \")end;print(F.type..\" \"..F.name)end end else io.stderr:write(\"nm: could not load \"..g..\": \"..u..\"\\n\")end else io.stderr:write(\"nm: could not load \"..g..\": \"..u..\"\\n\")end end\n",setuser=false,size=4048,modified=1757997039889,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["nano.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039924,data="local a=require\"system.filesystem\"local b=require\"system.framebuffer\"local c=require\"system.keys\"local d=require\"system.terminal\"local e=require\"system.util\"local f=\"0.1\"local g=assert(e.argparse({},...))local h={[c.leftBracket]='{',[c.rightBracket]='}',[c.minus]='_',[c.nine]='(',[c.zero]=')',[c.semicolon]=':',[c.up]='\\24',[c.down]='\\25',[c.left]='\\27',[c.right]='\\26'}local i,j;local k=assert(d.openterm())local l=d.termctl()d.termctl{raw=true}local m,n=k.getSize()local o=g[1]local p={}local q=1;local r,s=1,1;local t=b.window(k,1,2,m,n-4)local u=false;local v,w;local x=false;local y,z=\"\",1;local A;local B=true;local C={}local function D(E,F,G)if#E<F then return(G and\"\"or(' '):rep(math.ceil((F-#E)/2)))..E..(' '):rep(math.floor((F-#E)/(G and 1 or 2)))elseif#E==F then return E elseif G then return E:sub(1,F)else return\"...\"..E:sub(-F+3)end end;local function H(I)local J=\"\"if I.key==c.delete and I.shift then J=\"Sh-\"end;if I.ctrl then J=J..\"^\"elseif I.alt then J=J..\"M-\"end;if h[I.key]then J=J..h[I.key]else J=J..c.getCharacter(I.key):upper()end;return J end;local function K()if v then k.setTextColor(d.colors.black)k.setBackgroundColor(d.colors.white)if x then k.setCursorPos(1,n-2)k.clearLine()k.write(v)local F=m-#v-1;if#y>F then if z<F-1 then k.write(y:sub(1,F-1)..\">\")k.setCursorPos(#v+z,n-2)else local L=math.floor((z-F+1)/(F-8)+1)*(F-8)+2;k.write(\"<\"..y:sub(L,L+F-3))if#y>L+m-1 then k.write(\">\")else k.write(y:sub(L+F-3,L+F-2))end;k.setCursorPos(#v+z-L+2,n-2)end else k.write(y)k.setCursorPos(#v+z,n-2)end else k.setCursorPos(math.floor((m-#v)/2)+1,n-2)k.write(v)end;k.setTextColor(d.colors.white)k.setBackgroundColor(d.colors.black)end end;local M;local function N()k.setBackgroundColor(d.colors.black)k.clear()k.setCursorBlink(false)k.setCursorPos(1,1)k.setBackgroundColor(d.colors.white)k.setTextColor(d.colors.black)if m>=#f+#o+26 then k.write(\"  Phoenix nano \"..f..D(o,m-#f-26)..(u and\" Modified  \"or(' '):rep(11)))elseif m>=#o+13 then k.write(\"  \"..D(o,m-13)..(u and\" Modified  \"or(' '):rep(11)))elseif m>=#o+4 and not u then k.write(\"  \"..D(o,m-4)..\"  \")else k.write(D(o,u and m-9 or m)..(u and\" Modified\"or\"\"))end;K()local O,P=k.getCursorPos()k.setCursorPos(1,n-1)local Q=math.floor(m/20)+2;local R=math.floor(m/Q)for S=1,Q do if not i[1][S]then break end;local I=H(i[1][S])local E=D(I..\" \"..i[1][S].description,S==Q and m-R*(S-1)or R,true)k.blit(E,('f'):rep(#I)..('0'):rep(#E-#I),('0'):rep(#I)..('f'):rep(#E-#I))end;k.setCursorPos(1,n)for S=1,Q do if not i[2][S]then break end;local I=H(i[2][S])local E=D(I..\" \"..i[2][S].description,S==Q and m-R*(S-1)or R,true)k.blit(E,('f'):rep(#I)..('0'):rep(#E-#I),('0'):rep(#I)..('f'):rep(#E-#I))end;M()if v and x then k.setCursorPos(O,P)end end;M=function()t.setBackgroundColor(d.colors.black)t.setTextColor(d.colors.white)t.clear()t.setCursorBlink(false)local T,U;for S=1,n-4 do t.setCursorPos(1,S)if p[q+S-1]==nil then break end;if S+q-1==s and#p[q+S-1]>m then if r<m-1 then t.write(p[q+S-1]:sub(1,m-1))t.blit(\">\",\"f\",\"0\")t.setBackgroundColor(d.colors.black)t.setTextColor(d.colors.white)else local L=math.floor((r-m+1)/(m-8)+1)*(m-8)+2;t.blit(\"<\",\"f\",\"0\")t.setBackgroundColor(d.colors.black)t.setTextColor(d.colors.white)t.write(p[q+S-1]:sub(L,L+m-3))if#p[q+S-1]>L+m-1 then t.blit(\">\",\"f\",\"0\")t.setBackgroundColor(d.colors.black)t.setTextColor(d.colors.white)else t.write(p[q+S-1]:sub(L+m-3,L+m-2))end;T,U=r-L+2,s-q+1 end elseif#p[q+S-1]>m then t.write(p[q+S-1]:sub(1,m-1))t.blit(\">\",\"f\",\"0\")t.setBackgroundColor(d.colors.black)t.setTextColor(d.colors.white)else t.write(p[q+S-1])end end;if T==nil then T,U=r,s-q+1 end;t.setCursorPos(T,U)t.setCursorBlink(true)end;local function V(W)v=W;x=false;w=20;N()end;local function X(W,Y,Z)v=W;w=nil;x=true;i=Y or i;y=\"\"z=1;A=Z;N()end;local function _(a0)local a1=1;local a2={\"File Name to Write: \",\"File Name to Write [DOS Format]: \",\"File Name to Write [Mac Format]: \"}X(\"File Name to Write: \",{{{key=c.g,ctrl=true,description=\"Help\"},{key=c.d,alt=true,description=\"DOS Format\",action=function()if a1==2 then a1=1 else a1=2 end;v=a2[a1]K()end},{key=c.a,alt=true,description=\"Append\"},{key=c.b,alt=true,description=\"Backup File\"}},{{key=c.c,ctrl=true,description=\"Cancel\",action=function()i=j;V\"[ Cancelled ]\"end},{key=c.m,alt=true,description=\"Mac Format\",action=function()if a1==3 then a1=1 else a1=3 end;v=a2[a1]K()end},{key=c.p,alt=true,description=\"Prepend\"},{key=c.t,ctrl=true,description=\"Browse\"}}},function(a3)local a4,a5=a.open(a3,\"w\")if not a4 then V(\"[ Could not write file: \"..a5 ..\" ]\")return end;local a6=({\"\\n\",\"\\r\\n\",\"\\r\"})[a1]for a7,a8 in ipairs(p)do a4.write(a8 ..a6)end;a4.close()u=false;if a0 then B=false else V(\"[ Wrote \"..#p..\" lines ]\")end end)if g[1]then y=o;z=#o+1;K()end end;j={{{key=c.g,ctrl=true,description=\"Get Help\"},{key=c.o,ctrl=true,description=\"Write Out\",action=_},{key=c.w,ctrl=true,description=\"Where Is\"},{key=c.k,ctrl=true,description=\"Cut Text\",action=function()if s==#p then V(\"[ Nothing was cut ]\")else C[#C+1]=table.remove(p,s)r=math.min(r,#p[s]+1)if not u then u=true;N()else M()end end end},{key=c.j,ctrl=true,description=\"Justify\"},{key=c.c,ctrl=true,description=\"Cur Pos\",action=function()local a9=0;for U=1,s-1 do a9=a9+#p[U]end;local aa=a9;for U=s,#p do aa=aa+#p[U]end;V((\"[ line %d/%d, col %d/%d, char %d/%d ]\"):format(s,#p,r,#p[s],a9+r-1,aa))end},{key=c.u,alt=true,description=\"Undo\"},{key=c.a,alt=true,description=\"Mark Text\"},{key=c.rightBracket,alt=true,description=\"To Bracket\"},{key=c.q,alt=true,description=\"Previous\"},{key=c.b,ctrl=true,description=\"Back\"},{key=c.left,ctrl=true,description=\"Prev Word\"},{key=c.a,ctrl=true,description=\"Home\"},{key=c.p,ctrl=true,description=\"Prev Line\"},{key=c.up,alt=true,description=\"Scroll Up\"},{key=c.up,ctrl=true,description=\"Prev Block\"},{key=c.nine,shift=true,alt=true,description=\"Beg of Par\"},{key=c.y,ctrl=true,description=\"Prev Page\"},{key=c.backslash,alt=true,description=\"First Line\"},{key=c.left,alt=true,description=\"Prev File\"},{key=c.i,ctrl=true,description=\"Tab\"},{key=c.h,ctrl=true,description=\"Backspace\"},{key=c.delete,shift=true,ctrl=true,description=\"Chop Left\"},{key=c.t,alt=true,description=\"CutTillEnd\"},{key=c.d,alt=true,description=\"Word Count\"},{key=c.l,ctrl=true,description=\"Refresh\"},{key=c.rightBracket,shift=true,alt=true,description=\"Indent\"},{key=c.three,alt=true,description=\"Comment Lines\"},{key=c.semicolon,shift=true,alt=true,description=\"Record\"},{key=c.delete,alt=true,description=\"Zap Text\"},{key=c.f,alt=true,description=\"Formatter\"}},{{key=c.x,ctrl=true,description=\"Exit\"},{key=c.r,ctrl=true,description=\"Read File\"},{key=c.backslash,ctrl=true,description=\"Replace\"},{key=c.u,ctrl=true,description=\"Paste Text\",action=function()if#C==0 then V(\"[ Nothing was pasted ]\")else for S=#C,1,-1 do table.insert(p,s,C[S])end;C={}if not u then u=true;N()else M()end end end},{key=c.t,ctrl=true,description=\"To Spell\"},{key=c.minus,shift=true,ctrl=true,description=\"Go To Line\",action=function()X(\"Enter line number, column number: \",{{{key=c.g,ctrl=true,description=\"Help\"},{key=c.w,ctrl=true,description=\"Begin of Paragr.\"},{key=c.y,ctrl=true,description=\"First Line\"},{key=c.t,ctrl=true,description=\"Go To Text\"}},{{key=c.c,ctrl=true,description=\"Cancel\",action=function()i=j;V\"[ Cancelled ]\"end},{key=c.o,ctrl=true,description=\"End of Paragraph\"},{key=c.v,ctrl=true,description=\"Last Line\"}}},function(W)local ab=tonumber(W)if ab and ab<=#p then s=ab;if s<q then q=s elseif s-n+5>q then q=s-n+5 end else V\"[ Invalid line or column number ]\"end end)end},{key=c.e,alt=true,description=\"Redo\"},{key=c.six,alt=true,description=\"Copy Text\"},{key=c.q,ctrl=true,description=\"Where Was\"},{key=c.w,alt=true,description=\"Next\"},{key=c.f,ctrl=true,description=\"Forward\"},{key=c.right,ctrl=true,description=\"Next Word\"},{key=c.e,ctrl=true,description=\"End\"},{key=c.n,ctrl=true,description=\"Next Line\"},{key=c.down,alt=true,description=\"Scroll Down\"},{key=c.down,ctrl=true,description=\"Next Block\"},{key=c.zero,shift=true,alt=true,description=\"End of Par\"},{key=c.v,ctrl=true,description=\"Next Page\"},{key=c.slash,alt=true,description=\"Last Line\"},{key=c.right,alt=true,description=\"Next File\"},{key=c.m,ctrl=true,description=\"Enter\"},{key=c.d,ctrl=true,description=\"Delete\"},{key=c.delete,ctrl=true,description=\"Chop Right\"},{key=c.j,alt=true,description=\"FullJstify\"},{key=c.v,alt=true,description=\"Verbatim\"},{key=c.z,ctrl=true,description=\"Suspend\"},{key=c.leftBracket,shift=true,alt=true,description=\"Unindent\"},{key=c.rightBracket,ctrl=true,description=\"Complete\"},{key=c.semicolon,alt=true,description=\"Run Macro\"},{key=c.b,alt=true,description=\"To Linter\"},{key=c.s,ctrl=true,description=\"Save\"}}}i=j;if o then if a.stat(o)then for ac in io.lines(o)do table.insert(p,ac)end;V(\"[ Read \"..#p..\" lines ]\")else V\"[ New File ]\"end else o=\"New Buffer\"V\"[ Welcome to nano. For basic help, type Ctrl+G. ]\"end;N()while B do local ad,ae=coroutine.yield()if v and x then if ad==\"key\"then if ae.keycode==c.left and z>1 then z=z-1;K()elseif ae.keycode==c.right and z<=#y then z=z+1;K()elseif ae.keycode==c.backspace and z>1 then y=y:sub(1,z-2)..y:sub(z)z=z-1;K()elseif ae.keycode==c.delete then y=y:sub(1,z-1)..y:sub(z+1)K()elseif ae.keycode==c.enter then v,x=nil;i=j;A(y)N()else local af;for a7,a8 in ipairs(i[1])do if ae.keycode==a8.key and ae.ctrlHeld==(a8.ctrl or false)and ae.altHeld==(a8.alt or false)and ae.shiftHeld==(a8.shift or false)then if a8.action then a8.action()end;af=true;break end end;if not af then for a7,a8 in ipairs(i[2])do if ae.keycode==a8.key and ae.ctrlHeld==(a8.ctrl or false)and ae.altHeld==(a8.alt or false)and ae.shiftHeld==(a8.shift or false)then if a8.action then a8.action()end;af=true;break end end end end elseif ad==\"char\"then y=y:sub(1,z-1)..ae.character..y:sub(z)z=z+1;K()end else if ad==\"key\"then if ae.keycode==c.up and s>1 then s=s-1;if s<q then q=s end;if not p[s]then r=1 elseif r>#p[s]+1 then r=#p[s]+1 end;M()elseif ae.keycode==c.down and s<=#p then s=s+1;if s-n+5>q then q=s-n+5 end;if not p[s]then r=1 elseif r>#p[s]+1 then r=#p[s]+1 end;M()elseif ae.keycode==c.right and p[s]then if#p[s]<r then s=s+1;r=1 else r=r+1 end;M()elseif ae.keycode==c.left and(r>1 or s>1)then if r==1 then s=s-1;r=#p[s]+1 else r=r-1 end;M()elseif ae.keycode==c.backspace then if r==1 then if s~=1 then r=#p[s-1]+1;p[s-1]=p[s-1]..(table.remove(p,s)or\"\")s=s-1;if s<q then q=s end end else p[s]=p[s]:sub(1,r-2)..p[s]:sub(r)r=r-1 end;if not u then u=true;N()else M()end elseif ae.keycode==c.delete and p[s]then if r==#p[s]+1 then p[s]=p[s]..(table.remove(p,s+1)or\"\")else p[s]=p[s]:sub(1,r-1)..p[s]:sub(r+1)end;if not u then u=true;N()else M()end elseif ae.keycode==c.enter then local ag=(p[s]or\"\"):sub(r)p[s]=(p[s]or\"\"):sub(1,r-1)table.insert(p,s+1,ag)r=1;s=s+1;if s-n+5>q then q=s-n+5 end;if not u then u=true;N()else M()end elseif ae.keycode==c.x and ae.ctrlHeld then local ah=true;if u then k.setCursorPos(1,n-2)k.setBackgroundColor(d.colors.white)k.setTextColor(d.colors.black)k.clearLine()k.write(\"Save modified buffer?\")k.setBackgroundColor(d.colors.black)k.setTextColor(d.colors.white)k.setCursorPos(1,n-1)k.clearLine()k.blit(\" Y Yes\",\"ff0000\",\"00ffff\")k.setCursorPos(1,n)k.clearLine()k.blit(\" N No       ^C Cancel\",\"ff0000000000ff0000000\",\"00ffffffffff00fffffff\")k.setCursorBlink(false)while true do ad,ae=coroutine.yield()if ad==\"key\"and ae.keycode==c.c and ae.ctrlHeld then ah=false;break elseif ad==\"char\"then if ae.character==\"y\"then _(true)ah=false;break elseif ae.character==\"n\"then break end end end end;if ah then break end;if not x then V\"[ Cancelled ]\"end else local af;for a7,a8 in ipairs(i[1])do if ae.keycode==a8.key and ae.ctrlHeld==(a8.ctrl or false)and ae.altHeld==(a8.alt or false)and ae.shiftHeld==(a8.shift or false)then if a8.action then a8.action()end;af=true;break end end;if not af then for a7,a8 in ipairs(i[2])do if ae.keycode==a8.key and ae.ctrlHeld==(a8.ctrl or false)and ae.altHeld==(a8.alt or false)and ae.shiftHeld==(a8.shift or false)then if a8.action then a8.action()end;af=true;break end end end end elseif ad==\"char\"then if p[s]then p[s]=p[s]:sub(1,r-1)..ae.character..p[s]:sub(r)else p[s]=ae.character end;r=r+1;if not u then u=true;N()else M()end end end;if w then w=w-1;if w==0 then v,w=nil;N()end end end;k.setBackgroundColor(d.colors.black)k.setTextColor(d.colors.white)k.clear()k.setCursorPos(1,1)k.close()d.termctl(l)\n",setuser=false,size=12311,modified=1757997039888,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["eject.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039915,data="if not...then error(\"Usage: eject <drive>\")end;return assert(coroutine.yield(\"syscall\",\"devcall\",...,\"eject\"))\n",setuser=false,size=111,modified=1757997039876,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["cal.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039907,data="local a={...}local b={\"january\",\"february\",\"march\",\"april\",\"may\",\"june\",\"july\",\"august\",\"september\",\"october\",\"november\",\"december\"}local c={31,28,31,30,31,30,31,31,30,31,30,31}local function d(e)if#e<3 then return end;local f=\"^\"..e:lower()for g,h in ipairs(b)do if h:match(f)then return g end end end;local i=os.date(\"*t\")local j,k;if a[2]then j,k=assert(tonumber(a[1])or d(a[1]),\"cal: \"..a[1]..\" is neither a month number (1..12) nor a name\"),assert(tonumber(a[2]),\"cal: year `\"..a[2]..\"' not in range 1..9999\")elseif a[1]then k=assert(tonumber(a[1]),\"cal: year `\"..a[1]..\"' not in range 1..9999\")else j,k=i.month,i.year end;if k<1 or k>9999 then error(\"cal: year `\"..k..\"' not in range 1..9999\")end;if j and(j<1 or j>12)then error(\"cal: \"..j..\" is neither a month number (1..12) nor a name\")end;if j then local l=b[j]:gsub(\"^.\",string.upper)..\" \"..k;l=(\" \"):rep(math.floor((20-#l)/2))..l;print(l)print(\"Su Mo Tu We Th Fr Sa\")local m=os.date(\"*t\",os.time({year=k,month=j,day=1})).wday;io.stdout:write((\"   \"):rep(m-1))local n=c[j]if j==2 and(k%4==0 and k%100~=0 or k%400==0)then n=29 end;for g=1,n do if i.year==k and i.month==j and i.day==g then io.stdout:write((\"\\x1b[7m%2d\\x1b[7m \"):format(g))else io.stdout:write((\"%2d \"):format(g))end;m=m+1;if m>7 then print()m=1 end end;if m>1 then print()end else print((\"                              %4d\"):format(k))local function o(p)local l=b[p]:gsub(\"^.\",string.upper)l=(\" \"):rep(math.floor((20-#l)/2))..l..(\" \"):rep(math.ceil((20-#l)/2))coroutine.yield(l)coroutine.yield(\"Su Mo Tu We Th Fr Sa\")local m=os.date(\"*t\",os.time({year=k,month=p,day=1})).wday;local q=(\"   \"):rep(m-1)local n=c[p]if p==2 and(k%4==0 and k%100~=0 or k%400==0)then n=29 end;for g=1,n do if i.year==k and i.month==p and i.day==g then q=q..(\"\\x1b[7m%2d\\x1b[7m \"):format(g)else q=q..(\"%2d \"):format(g)end;m=m+1;if m>7 then coroutine.yield(q:sub(1,-2))q,m=\"\",1 end end;if m>1 then coroutine.yield(q:sub(1,-2)..(\" \"):rep(20-#q+1))end end;for g=0,3 do local r,s,t=coroutine.create(function()o(g*3+1)end),coroutine.create(function()o(g*3+2)end),coroutine.create(function()o(g*3+3)end)while coroutine.status(r)==\"suspended\"or coroutine.status(s)==\"suspended\"or coroutine.status(t)==\"suspended\"do local q=\"\"local u,v=coroutine.resume(r)if u and v then q=v..\"  \"end;u,v=coroutine.resume(s)if u and v then q=q..v..\"  \"end;u,v=coroutine.resume(t)if u and v then q=q..v end;print(q)end end end\n",setuser=false,size=2404,modified=1757997039865,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["kill.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039918,data="local a=require\"system.ipc\"local b={}local c=a.signal.SIGTERM;local d;for e,f in ipairs{...}do if d then c,d=a.signal[\"SIG\"..f]or c,nil elseif f:sub(1,1)==\"-\"then f=f:sub(2)if f==\"s\"then d=true elseif f==\"l\"then b.l=true elseif a.signal[\"SIG\"..f]then c=a.signal[\"SIG\"..f]elseif tonumber(f)then c=tonumber(f)else error(\"unknown argument \"..f)end else b[#b+1]=assert(tonumber(f),\"invalid PID \"..f)end end;if b.l then if b[1]then for g,f in pairs(a.signal)do if f==b[1]then print(g:sub(4))return end end;print(\"UNKNOWN\")return false else for g,f in pairs(a.signal)do io.write(g:sub(4)..\" \")end;print()end else for e,f in ipairs(b)do a.kill(f,c)end end\n",setuser=false,size=649,modified=1757997039880,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["nice.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997039924,data="local a=require\"system.process\"local b=require\"system.util\"local c=assert(b.argparse({n=\"number\"},...))if not c[1]then error(\"Usage: nice [-n <increment>] <program> [args...]\")end;local d=a.fork(function()a.nice(c.n or 10)a.execp(table.unpack(c))end,c[1])local e,f;repeat e,f=coroutine.yield()until e==\"process_complete\"and f.id==d;return f.value\n",setuser=false,size=347,modified=1757997039888,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"}},size=0,modified=1757997043420,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"},sbin={permissions={root={write=true,read=true,execute=true}},created=1757997042777,contents={["startctl.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997042777,data="local a=require\"startmgr\"local b=require\"system.util\"local c=assert(b.argparse({user=false},...))local d;if not c.user then d=\"root\"end;if not a[c[1]]then error(\"Invalid operation\")end;if c[1]==\"list\"then local e,f=a.list(d)for g,h in pairs(f)do print(g..\": \"..(h.running and\"running\"or\"stopped\"))end else print(a[c[1]](c[2],d))end\n",setuser=false,size=332,modified=1757997042753,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["mkencryptfs.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997040511,data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=require\"system.terminal\"local d=require\"system.util\"local e=require\"ccryptolib.aead\"local f=require\"ccryptolib.random\"local g=require\"ccryptolib.sha256\"local h=assert(d.argparse({p=true,password=\"@p\",t=true,type=\"@t\",d=true,[\"mount-dir\"]=\"@d\",i=\"number\",iter=\"@i\",o=true,options=\"@o\",c=false,convert=\"@c\",e=false,erase=\"@e\"},...))if#h<1 then error(\"Usage: mkencryptfs [-c|-e] [-p <password>] [-t type] [-d mount-dir] [-i iter] [-o options] <filesystem>\")end;if h.c and h.e then error(\"-c and -e are mutually exclusive\")end;if not h.p then c.termctl{echo=false}c.write(\"Enter encryption password: \")h.p=c.readline()c.write(\"\\nConfirm password: \")if h.p~=c.readline()then c.termctl{echo=true}error(\"\\nPasswords do not match.\")end;c.termctl{echo=true}print()end;h.d=h.d or\"/tmp/.mkencryptfs\"f.initWithTiming()a.mkdir(h.d)local i={rw=true,suid=true,dev=true,exec=true,auto=true,owner=true,async=true}if h.o then for j in h.o:gmatch\"[^,]+\"do local k,l=j:match\"([^=]+)=?(.*)\"if not k then k,l=j,true end;i[k]=l end end;print(\"Creating encryptfs filesystem on \"..h[1]..\" (type \"..(h.t or\"craftos\")..\")\")a.mount(h.t or\"craftos\",h[1],h.d,i)if h.e then for m,l in ipairs(a.list(h.d))do a.remove(a.combine(h.d,l))end end;local n=f.random(28)local o=f.random(32)local p=g.digest(h.p..\" encryptfs salt file \\x12\\x34\\x56\\x78\\x9A\\xBC\\xDE\\xF0\"):gsub(\".\",function(q)return(\"%02x\"):format(q:byte())end)local r=assert(a.open(a.combine(h.d,p),\"wb\"))r.write(\"Efs\\x00\")r.write(n)r.write(o)r.close()local s=g.pbkdf2(h.p,n,h.i or 5000)local t=f.random(12)local u=b.getuser()local v=os.time()*1000;local w,x=e.encrypt(s,t,([[{\n    type = \"directory\",\n    owner = \"%s\",\n    permissions = {[\"%s\"] = {read = true, write = true, execute = true}},\n    worldPermissions = {read = true, write = false, execute = true},\n    created = %d,\n    modified = %d,\n    contents = {}\n}]]):format(u,u,v,v),t)o=o:gsub(\".\",function(q)return(\"%02x\"):format(q:byte())end)r=assert(a.open(a.combine(h.d,o),\"wb\"))r.write(\"Efs\\x01\")r.write(t)r.write(x)r.write(w)r.close()if h.c then print(\"Converting drive...\")a.mkdir(h.d..\"_convert\")i.encryptfs_password=h.p;i.encryptfs_basefs=h.t;i.encryptfs_iter=h.i;a.mount(\"encryptfs\",h[1],h.d..\"_convert\",i)local function y(z)local A=a.stat(a.combine(h.d,z))if A.type==\"file\"then print(z)a.move(a.combine(h.d,z),a.combine(h.d..\"_convert\",z))elseif A.type==\"directory\"then a.mkdir(a.combine(h.d..\"_convert\",z))for m,l in ipairs(a.list(a.combine(h.d,z)))do y(a.combine(z,l))end;a.remove(a.combine(h.d,z))elseif A.type==\"link\"then a.link(a.combine(h.d..\"_convert\",z),A.link)elseif A.type==\"fifo\"then a.mkfifo(a.combine(h.d..\"_convert\",z))end end;local B=\"^\"..(\"%x\"):rep(64)..\"$\"for m,l in ipairs(a.list(h.d))do if not l:match(B)then y(l)end end;a.unmount(h.d..\"_convert\")a.remove(h.d..\"_convert\")end;a.unmount(h.d)print(\"Filesystem created successfully.\")\n",setuser=false,size=2915,modified=1757997040506,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["spanadd.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997042636,data="local a=require\"system.filesystem\"local b=require\"system.hardware\"local c=require\"system.process\"local d=require\"system.util\"local e={...}if#e<2 then error(\"Usage: spanadd <span mount> <drives...>\")end;if c.getuser()~=\"root\"then error(\"This program must be run as root.\")end;local f=table.remove(e,1)local g=d.syscall.callmodule(\"spanfs\",\"info\",f)local h=\"The following disks will be erased and added to the span filesystem '\"..(g.name or g.uuid)..\"':\\n\"for i,j in ipairs(e)do local k=b.info(j)if not k then error(\"Device '\"..j..\"' does not exist.\")end;if not k.types.drive then error(\"Device '\"..j..\"' is not a compatible disk drive.\")end;h=h..\"  Drive '\"..(k.alias or k.displayName or b.path(j))..\"' (\"..k.uuid..\")\\n\"end;print(h)io.write(\"Continue? (y/N) \")local l=io.read()if l:upper()~=\"Y\"then return false end;local m=\"/tmp/.mkspanfs-\"..math.random(0,99999)a.mkdir(m)local n,o=g.freeSpace,g.capacity;for i,j in ipairs(e)do a.mount(\"drivefs\",j,m,{})for i,p in ipairs(a.list(m))do a.remove(m..\"/\"..p)end;local q=assert(io.open(m..\"/.spanfs\",\"w\"))q:write(g.name..\"\\n\"..g.uuid..\"\\n\"..#g.disks+1 ..\"\\n\")q:close()local r=a.stat(m)print(\"Data disk \"..j..\" has \"..r.freeSpace..\" bytes free\")n=n+r.freeSpace;o=o+r.capacity;g.disks[#g.disks+1]={device=j,space=r.freeSpace}a.unmount(m)end;a.remove(m)print(\"Finished adding \"..#e..\" disks to the span filesystem '\"..g.name..\"' (\"..g.uuid..\").\")print(\"New total disk capacity: \"..o)print(\"Usable space: \"..n)print(\"You must remount the filesystem or restart the computer for changes to take effect.\")\n",setuser=false,size=1543,modified=1757997042611,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["shutdown.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997042777,data="local a=require\"startmgr\"local b=require\"system.log\"local c=require\"system.process\"local d=require\"system.util\"local e=assert(d.argparse({P=false,poweroff=\"@P\",H=\"@P\",halt=\"@P\",h=\"@P\",r=false,reboot=\"@r\",c=false,show=false,help=false},...))if e.help then print[[\nUsage: shutdown [OPTIONS] [TIME]\nOptions:\n  --help          Show this help\n  -H, --halt      Equivalent to -P\n  -P, --poweroff  Power off the machine\n  -r, --reboot    Reboot the machine\n  -h              Equivalent to -P\n  -c              Cancel a pending shutdown\n  --show          Show pending shutdown\n]]end;local f={31,28,31,30,31,30,31,31,30,31,30,31}local function g(h)return h%4==0 and(h%100~=0 or h%400==0)end;if e.c then return a.remove(\"shutdown-timer\",\"root\")elseif e.show then local i=a.status(\"shutdown-timer\",\"root\")if i then else print(\"No scheduled shutdown.\")end else local j=e[1]or\"+1\"if j==\"+0\"or j==\"now\"then if e.r and not e.P then assert(a.reboot())else assert(a.shutdown())end else local k;if j:match\"^%+%d+$\"then k=tonumber(j:match\"^%+(%d+)$\")*60 elseif j:match\"^%d+:%d+$\"then local l,m=j:match\"^(%d+):(%d+)$\"l,m=tonumber(l),tonumber(m)if l<0 or l>23 or m<0 or m>59 then error(\"shutdown: Invalid argument\")end;local n=os.date(\"!*t\")if l<n.hour or l==n.hour and m<n.min then n.day=n.day+1;n.wday=(n.wday+1)%7;n.yday=(n.yday+1)%(g(n.year)and 366 or 365)if n.day>f[n.month]or n.month==2 and g(n.year)and n.day>29 then n.day=1;n.month=n.month+1;if n.month>12 then n.month=1;n.year=n.year+1 end end end;n.hour,n.min,n.sec=l,m,0;k=os.time(n)-os.time()else error(\"shutdown: Invalid argument\")end;assert(a.add([[\nname = \"shutdown-timer\"\nunit.description = \"Shutdown Timer\"\nfunction trigger()\n    startmgr.]]..(e.r and not e.P and\"reboot\"or\"shutdown\")..[[()\nend\ntimer.loadTime = ]]..k,\"root\"))b.notice(\"System is going down in \"..k/60 ..\" minutes.\")end end\n",setuser=false,size=1836,modified=1757997042752,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["mkspanfs.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997042634,data="local a=require\"system.filesystem\"local b=require\"system.hardware\"local c=require\"system.process\"local d={...}if#d<3 then error(\"Usage: mkspanfs <name> <index drive> <data drives...>\")end;if c.getuser()~=\"root\"then error(\"This program must be run as root.\")end;local e=table.remove(d,1)local f=\"The following disks will be erased and replaced with a new span filesystem:\\n\"for g,h in ipairs(d)do local i=b.info(h)if not i then error(\"Device '\"..h..\"' does not exist.\")end;if not i.types.drive then error(\"Device '\"..h..\"' is not a compatible disk drive.\")end;f=f..\"  Drive '\"..(i.alias or i.displayName or b.path(h))..\"' (\"..i.uuid..\")\\n\"end;print(f)io.write(\"Continue? (y/N) \")local j=io.read()if j:upper()~=\"Y\"then return false end;local k=('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'):gsub('[xy]',function(l)local h=l=='x'and math.random(0,0xf)or math.random(8,0xb)return('%x'):format(h)end)local m=\"/tmp/.mkspanfs-\"..math.random(0,99999)a.mkdir(m)local n,o=0,0;for p,h in ipairs(d)do a.mount(\"drivefs\",h,m,{})for g,q in ipairs(a.list(m))do a.remove(m..\"/\"..q)end;local r=assert(io.open(m..\"/.spanfs\",\"w\"))r:write(e..\"\\n\"..k..\"\\n\"..p-1 ..\"\\n\")r:close()if p==1 then r=assert(io.open(m..\"/index\",\"wb\"))r:write((\"<III8I8BBs2s2Bs2BI\"):pack(38+#e,0,os.time()*1000,os.time()*1000,5,5,e,\"root\",1,\"root\",7,0))r:close()local s=a.stat(m)print(\"Index disk \"..h..\" has \"..s.freeSpace..\" bytes free\")else local s=a.stat(m)print(\"Data disk \"..h..\" has \"..s.freeSpace..\" bytes free\")n=n+s.freeSpace;o=o+s.capacity end;a.unmount(m)end;a.remove(m)print(\"Finished creating span filesystem '\"..e..\"' (\"..k..\") across \"..#d..\" disks.\")print(\"Total disk capacity: \"..o)print(\"Usable space: \"..n)\n",setuser=false,size=1673,modified=1757997042610,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["spaninfo.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997042637,data="local a=require\"system.util\"local b=...if not b then error(\"Usage: spaninfo <mountpoint>\\n\")end;local function c(d)if d>=1000000000 then return(\"%.3g GB\"):format(d/1000000000)elseif d>=1000000 then return(\"%.3g MB\"):format(d/1000000)elseif d>=1000 then return(\"%.3g kB\"):format(d/1000)else return d..\" bytes\"end end;local e=a.syscall.callmodule(\"spanfs\",\"info\",b)local f=a.syscall.stat(b)print(\"Span '\"..e.name..\"' (\"..e.uuid..\")\")print(\"Capacity: \"..c(f.capacity))print(\"Free space: \"..c(f.freeSpace))print(\"Disks:\")for g,h in pairs(e.disks)do print(\"  Disk \"..g..\" (\"..h.device:match(\"^%x+\")..\"): \"..h.space..\" bytes free\")end;print(\"Free index space: \"..e.freeindex)\n",setuser=false,size=670,modified=1757997042612,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"},["init.lua"]={permissions={root={read=true,write=true,execute=true}},created=1757997042776,data="local a=require\"system.expect\"local b=require\"system.filesystem\"local c=require\"system.ipc\"local d=require\"system.log\"local e=require\"system.process\"local f=require\"system.sync\"local g=require\"system.util\"startmgr={}local h,i;local j={}local k=e.getuser()if k==\"root\"then assert(e.getpid()==1,\"startmgr must be run as init.\")h={\"/etc/startmgr/system\",j}c.register(\"ServiceManager\")i=d.create(\"startmgr\",true,\"/var/log/startmgr.log\")else assert(not c.lookup(\"ServiceManager.\"..k),\"startmgr is already running for this user.\")h={\"/home/\"..k..\"/.local/etc/startmgr\",\"/etc/startmgr/user\",j}c.register(\"ServiceManager.\"..k)i=d.create(\"startmgr.\"..k,true,\"/home/\"..k..\"/.local/var/log/startmgr.log\")end;local l={}local m,n;local o={[0]='\\27[90m','\\27[97m','\\27[36m','\\27[93m','\\27[31m','\\27[95m','\\27[96m'}local function p(q,r,...)if k==\"root\"then local s=o[r or 1]if q==\"OK\"then s=\"\\27[92m\"end;local t=...print((q and\"[\"..s..(\" \"):rep(math.floor((6-#q)/2))..q..(\" \"):rep(math.ceil((6-#q)/2))..\"\\27[0m]\"or\"        \")..\"  \"..t)end;i.log({level=r},...)end;local function u(v)if type(v)==\"table\"then local w={}for x,t in pairs(v)do w[u(x)]=u(t)end;return w else return v end end;local function y(z,A)if next(z)==nil then return true end;local B=f.barrier.new(#z+1)local C,D=true,\"\"for x,t in pairs(z)do e.newthread(function()local E,F=A(x)if t and not E then C=false;if F then D=D..F..\"\\n\"end end;B:wait()end)end;B:wait()return C,D:gsub(\"\\n+$\",\"\")end;function startmgr.start(G)local H=l[G]if not H then return false,\"No such service\"end;if H.runtime.running then return false,\"Service is already running\"end;if H.runtime.pending then return true end;local I={}for J,t in ipairs(H.unit.wants or{})do I[t]=false end;for J,t in ipairs(H.unit.upholds or{})do I[t]=false end;for J,t in ipairs(H.unit.requires or{})do if not l[t]then return false,\"Required service \"..t..\" does not exist\"end;I[t]=true end;for J,t in ipairs(H.unit.bindsTo or{})do if not l[t]then return false,\"Required service \"..t..\" does not exist\"end;I[t]=true end;for J,t in ipairs(H.unit.requisites or{})do if not l[t]or not l[t].runtime.running then return false,\"Requisite service \"..t..\" is not running\"end end;for J,t in ipairs(H.unit.conflicts or{})do if l[t]and l[t].runtime.running then return false,\"Conflicting service \"..t..\" is running\"end end;local K,L,M={},{[G]=true},{}local N,O={},{}for J,t in ipairs(H.unit.before or{})do N[t]=true end;for J,t in ipairs(H.unit.after or{})do O[t]=true end;for x,t in pairs(I)do if O[x]then K[x]=t end;if N[x]then M[x]=t end;if l[x]then for J,P in ipairs(l[x].unit.before or{})do if P==x then K[x]=t;break end end;for J,P in ipairs(l[x].unit.after or{})do if P==x then M[x]=t;break end end end;if K[x]and M[x]then return false,\"Service is misconfigured: Dependency \"..x..\" is ordered both before and after service\"end;if not K[x]and not M[x]then L[x]=t end end;if H.runtime.pending then return true end;H.runtime.pending=true;local E,F=y(K,startmgr.start)if not E then H.runtime.pending=false;return false,F end;E,F=y(L,function(Q)if Q==G then local E,R=false,\"Missing service start function\"if H.start then p(nil,nil,\"Starting \"..(H.unit and H.unit.description or Q)..\"...\")E,R=pcall(H.start)H.runtime.running=E and R;H.runtime.pending=false;p(E and R and\"OK\"or\"ERROR\",E and R and d.levels.notice or d.levels.error,\"Started \"..(H.unit and H.unit.description or Q)..\".\")end;if not E and type(R)==\"string\"then p(\"ERROR\",d.levels.error,\"Service \"..Q..\" threw an error:\",R)end;if not E or not R then return false,E and\"Failed to start service\"or R end;return true else return startmgr.start(Q)end end)if not E then return false,F end;return y(M,startmgr.start)end;function startmgr.stop(G)local H=l[G]if not H then return false,\"No such service\"end;if not H.runtime.running then return false,\"Service is already stopped\"end;local S={[G]=true}for J,t in ipairs(H.unit.bindsTo or{})do S[t]=false end;for J,t in ipairs(H.unit.parts or{})do S[t]=false end;return y(S,function(Q)if Q==G then p(nil,nil,\"Stopping \"..(H.unit and H.unit.description or Q)..\"...\")H.runtime.pending=true;if H.stop then local E,R=pcall(H.stop,false)H.runtime.running=not(E and R)if H.runtime.running then if not E and type(R)==\"string\"then p(\"ERROR\",d.levels.error,\"Service \"..Q..\" threw an error:\",R)end;return false,E and\"Failed to start service\"or R end end;for J,t in pairs(H.service.pid)do c.kill(t,c.signal.SIGHUP)end;return true else return startmgr.stop(Q)end end)end;function startmgr.kill(G)local H=l[G]if not H then return false,\"No such service\"end;if not H.runtime.running then return false,\"Service is already stopped\"end;local S={[G]=true}for J,t in ipairs(H.unit.bindsTo or{})do S[t]=false end;for J,t in ipairs(H.unit.parts or{})do S[t]=false end;return y(S,function(Q)if Q==G then p(nil,nil,\"Killing \"..(H.unit and H.unit.description or Q)..\"...\")H.runtime.pending=true;if H.stop then pcall(H.stop,true)H.runtime.running=false end;for J,t in pairs(H.service.pid)do c.kill(t,c.signal.SIGKILL)end;return true else return startmgr.stop(Q)end end)end;function startmgr.restart(G)local E,F=startmgr.stop(G)if not E then return E,F end;return startmgr.start(G)end;local function T(U,V,W,X,Y,Z)local _=setmetatable(u(U[V])or{name=V,path=W~=j and b.combine(W,X)or nil,runtime={},unit={},install={},service={pid={}},timer={}},{__index=_ENV})local A,F;if W==j then A,F=load(X,\"=service:\"..V,\"t\",_)else A,F=loadfile(b.combine(W,X),\"t\",_)end;if A then local E;E,F=pcall(A)if E then if _.service and type(_.unit.partOf)==\"table\"then for J,t in ipairs(_.unit.partOf)do Y[t]=Y[t]or{}Y[t][#Y[t]+1]=V end end;U[V]=_;_.runtime.didDelete=nil else Z[#Z+1]=\"\\x1b[31mError\\x1b[0m: Could not load \"..V..\": \"..F end else Z[#Z+1]=\"\\x1b[31mError\\x1b[0m: Could not load \"..V..\": \"..F end end;function startmgr.reload(G)if G then local H=l[G]if not H then return false,\"No such service\"end;if not H.runtime.running then return false,\"Service is not running\"end;if H.reload then return pcall(H.reload)else return true,\"Service has no reload function\"end else local U={}local Z={}for x,t in pairs(l)do if t.runtime.running then U[x]=t;t.runtime.didDelete=true end end;local Y={}for J,W in ipairs(h)do local E,z;if W==j then E,z=true,j else E,z=pcall(b.list,W)end;if E then for J,X in ipairs(z)do local V=W==j and select(2,X:match\"name%s*=%s*([\\\"'])([^\\\"']+)%1\")or X:match(\"^%w+\")if X:match\"%.wants$\"and b.isDir(b.combine(W,X))then if not U[V]then U[V]={unit={requires={}}}end;if not U[V].unit.requires then U[V].unit.requires={}end;local a0=U[V].unit.requires;for J,a1 in ipairs(b.list(b.combine(W,X)))do local Q=a1:match(\"^%w+\")T(U,Q,b.combine(W,X),a1,Y,Z)a0[#a0+1]=Q end else T(U,V,W,X,Y,Z)end end end end;for x,t in pairs(Y)do if U[x]and U[x].service then U[x].unit.parts=t end end;for x,t in pairs(U)do if t.runtime.didDelete then Z[#Z+1]=\"\\x1b[93mWarning\\x1b[0m: The service \"..x..\"was deleted on disk, but it is still running. The service will be deleted upon being stopped.\"end end;l=U;return true,Z end end;function startmgr.add(a2)local J,X=a2:match\"name%s*=%s*([\\\"'])([^\\\"']+)%1\"if not X then return false,\"Could not get name from service\"end;if l[X]then return false,\"Service with this name already exists\"end;j[#j+1]=a2;startmgr.reload()return true,X end;function startmgr.remove(G)for a3,t in ipairs(j)do local J,X=t:match\"name%s*=%s*([\\\"'])([^\\\"']+)%1\"if X==G then table.remove(j,a3)return true end end;return false end;function startmgr.list()local w={}for x,t in pairs(l)do w[x]={running=t.runtime.running}end;return true,w end;function startmgr.status(G)end;function startmgr.install(G)local H=l[G]if not H or not H.path or not H.install.wantedBy then return false end;local a4=l[H.install.wantedBy]if not a4 or not a4.path then return false end;b.mkdir(a4.path..\".wants\")if not b.exists(a4.path..\".wants/\"..b.basename(H.path))then b.link(a4.path..\".wants/\"..b.basename(H.path),H.path)end;return true end;function startmgr.uninstall(G)local H=l[G]if not H or not H.path or not H.install.wantedBy then return false end;local a4=l[H.install.wantedBy]if not a4 or not a4.path then return false end;b.remove(a4.path..\".wants/\"..b.basename(H.path))return true end;local function a5()p(nil,nil,\"Stopping all services...\")local a6=0;repeat local E=true;for x,t in pairs(l)do if t.runtime.running then E=(a6>=5 and startmgr.kill or startmgr.stop)(x)and E end end;a6=a6+1;if a6>10 then p(\"ERROR\",d.levels.error,\"Could not stop all services successfully, killing all processes.\")elseif a6==5 then p(nil,nil,\"Killing all remaining services...\")end;g.sleep(0.25)until E or a6>10 end;function startmgr.shutdown()if k~=\"root\"then return false,\"Operation invalid for this instance\"end;a5()g.syscall.devcall(\"/\",\"shutdown\")end;function startmgr.reboot()if k~=\"root\"then return false,\"Operation invalid for this instance\"end;a5()g.syscall.devcall(\"/\",\"reboot\")end;print(\"Welcome to \\27[96mPhoenix\\27[0m!\\n\")startmgr.reload()if not l.startup then p(\"WARN\",d.levels.warning,\"No startup service available. Installing default shell service.\")local a7={}l.startup={name=\"startup\",runtime={},unit={description=\"Shell prompt\"},install={},service={pid=a7,restart=k==\"root\"and\"always\"or\"no\"},timer={},start=function()a7[1]=e.start(\"/bin/sh\")return true end}end;assert(startmgr.start(\"startup\"))while true do local a8,a9=coroutine.yield()if a8==\"timer\"and a9.id==n then n=g.timer(m)elseif a8==\"process_complete\"then for x,t in pairs(l)do for a3,a7 in pairs(t.service and t.service.pid or{})do if a7==a9.id then t.service.pid[a3]=nil;local aa=a9.error or a9.value==false;p(nil,nil,\"Process \"..a7 ..\" (of service \"..x..\") exited \"..(aa and\"with an error: \"or\"successfully with return value: \")..(a9.error or tostring(a9.value)))if a9.error then p(\"ERROR\",d.levels.error,a9.error)end;if next(t.service.pid)==nil then if t.runtime.running and not t.runtime.pending and t.service.restart and t.service.restart~=\"no\"then if t.service.restart==\"always\"or t.service.restart==\"on-success\"and not aa or t.service.restart==\"on-failure\"and a9.value==false or t.service.restart==\"on-abnormal\"and aa or t.service.restart==\"on-abort\"and a9.error then startmgr.start(x)end else t.runtime.running=false;t.runtime.pending=false;if aa then if t.failure then pcall(t.failure)end elseif t.success then pcall(t.success)end;p(\"OK\",d.levels.notice,\"Stopped \"..(t.unit and t.unit.description or x)..\".\")end end end end end elseif a8==\"remote_event\"and a9.type==\"startmgr.request\"then if type(a9.data)==\"table\"and type(a9.data.func)==\"string\"then local ab=e.getpinfo(a9.sender)if ab.user==k then e.newthread(function()local A=startmgr[a9.data.func]if A then c.sendEvent(a9.sender,\"startmgr.response\",{func=a9.data.func,ok=true,result={A(a9.data.param)}})else c.sendEvent(a9.sender,\"startmgr.response\",{func=a9.data.func,ok=false,error=\"Unknown function\"})end end)else c.sendEvent(a9.sender,\"startmgr.response\",{func=a9.data.func,ok=false,error=\"Permission denied\"})end else c.sendEvent(a9.sender,\"startmgr.response\",{func=a9.data.func,ok=false,error=\"Invalid request\"})end end end\n",setuser=false,size=11007,modified=1757997042751,worldPermissions={read=true,write=false,execute=true},type="file",owner="root"}},size=0,modified=1757997042777,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"}},setuser=false,size=0,modified=1757997043457,worldPermissions={write=false,read=true,execute=true},type="directory",owner="root"}