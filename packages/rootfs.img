{modified=1704748613177,created=1704748613177,contents={lib={modified=1704748613176,created=1704748613176,contents={fuse={modified=1704748610982,created=1704748610982,contents={["ftp.lua"]={modified=1704748610959,data="local a,b=...local c=require\"ftp\"local d,e,f,g=a:match\"ftp://([^:]+):([^@]+)@([^:]+):(%d+)\"if not d then d,e,f=a:match\"ftp://([^:]+):([^@]+)@([^:/]+)\"if not d then d,f,g=a:match\"ftp://([^:]+)@([^:]+):(%d+)\"if not d then d,f=a:match\"ftp://([^:]+)@([^:/]+)\"if not d then f,g=a:match\"ftp://([^:]+):(%d+)\"if not f then f=a:match\"ftp://([^:/]+)\"if not f then error(\"Malformed URL\")end end end end end end;local h=c.client(f,g,b.pasv,tonumber(b.timeout))if d then h:login(d,e)end;local i={}function i:open(j,k,l)return h:open(\"/\"..k,l)end;function i:list(j,k)return h:list(\"/\"..k)end;function i:stat(j,k)return h:stat(\"/\"..k)end;function i:remove(j,k)return h:remove(\"/\"..k)end;function i:rename(j,k,m)return h:rename(\"/\"..k,\"/\"..m)end;function i:mkdir(j,k)return h:mkdir(\"/\"..k)end;function i:unmount(j)return h:close()end;function i:init(j)h.connection:transfer()end;return i\n",created=1704748610982,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=872}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},luz={modified=1704748611574,created=1704748611574,contents={["decompress.lua"]={modified=1704748611565,data="local a={{\":name\",{{\",\",\":repeat0\"},{\"=\",{\"(\",\")\"}}}},{{{{\".\",\":number\"},{\":repeat1\",\":repeat2\"}},{{\":string\",\"end\"},{\"local\",{\":repeat3\",\":repeat4\"}}}},{{{{\"if\",\"then\"},{{\"+\",\"-\"},{\"0\",\"1\"}}},{{{\":repeat5\",\":repeat6\"},{\"==\",\"[\"}},{{\"]\",\"do\"},{\"function\",\"return\"}}}},{{{{\"{\",\"}\"},{{\"#\",\"*\"},{\"..\",\"2\"}}},{{{\":\",\":repeat7\"},{\":repeat8\",\"and\"}},{{\"else\",\"for\"},{\"nil\",\"or\"}}}},{{{{\"self\",\"~=\"},{{\"\\\"\\\"\",\"/\"},{\":repeat10\",\":repeat9\"}}},{{{\";\",\"<\"},{\">\",\"elseif\"}},{{\"false\",\"not\"},{\"string\",\"true\"}}}},{{{{\"type\",{\"%\",\"-1\"}},{{\"...\",\":repeat11\"},{\"<=\",\">=\"}}},{{{\"error\",\"in\"},{\"math\",\"os\"}},{{\"print\",\"sub\"},{\"table\",\"while\"}}}},{{{{{\"\\\"number\\\"\",\"\\\"string\\\"\"},{\"\\\"table\\\"\",\":repeat12\"}},{{\":repeat13\",\"_\"},{\"_G\",\"bit32\"}}},{{{\"break\",\"close\"},{\"coroutine\",\"find\"}},{{\"ipairs\",\"match\"},{\"open\",\"pairs\"}}}},{{{{\"read\",\"require\"},{\"setmetatable\",\"tonumber\"}},{{\"tostring\",\"unpack\"},{\"write\",{\"\\\"function\\\"\",\"\\\"nil\\\"\"}}}},{{{{\"\\\"r\\\"\",\"\\\"w\\\"\"},{\"^\",\"_ENV\"}},{{\"__index\",\"debug\"},{\"getmetatable\",\"gsub\"}}},{{{\"io\",\"package\"},{\"pcall\",\"repeat\"}},{{\"select\",\"until\"},{{\"\\\"boolean\\\"\",\"__newindex\"},{\"load\",{\":end\",\"__call\"}}}}}}}}}}}}}}local b,c,d=bit32.rshift,bit32.lshift,bit32.band;local e,f=string.byte,string.char;local g,unpack=table.concat,unpack or table.unpack;local h=math.min;local i={17,18,19,1,9,8,10,7,11,6,12,5,13,4,14,3,15,2,16}local j={2,3,7}local k={144,112,24,8}local l={8,9,7,8}local m={[0]=5,261,133,389,69,325,197,453,37,293,165,421,101,357,229,485,21,277,149,405,85,341,213,469,53,309,181,437,117,373,245,501}local n=5;local o=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_\"local p={}for q=1,#o do p[string.char(q-1)]=o:sub(q,q)end;local function r(s,t)s.bits=b(s.bits,t)s.count=s.count-t end;local function u(s,t)local v,w,x,y=s.buffer,s.bits,s.count,s.position;while x<t do if y>#v then return nil end;w=w+c(e(v,y),x)y=y+1;x=x+8 end;s.bits=w;s.position=y;s.count=x;return d(w,c(1,t)-1)end;local function z(s,t)local A=u(s,t)s.bits=b(s.bits,t)s.count=s.count-t;return A end;local function B(s,t)local v,w,x,y=s.buffer,s.bits,s.count,s.position;while x<t do if y>#v then return nil end;w=c(w,8)+e(v,y)y=y+1;x=x+8 end;s.bits=w;s.position=y;s.count=x;return d(b(w,x-t),c(1,t)-1)end;local function C(s,t)local A=B(s,t)s.count=s.count-t;return A end;local function D(s,E,t)local F=E[u(s,t)]if not F then return nil end;local G=d(F,15)local A=b(F,4)s.bits=b(s.bits,G)s.count=s.count-G;return A end;local function H(I)local J=#I;local K,L,E={[0]=0},{},{}local w,M=1,0;for q=1,J do local N=I[q]if N>w then w=N end;K[N]=(K[N]or 0)+1 end;for q=1,w do M=(M+(K[q-1]or 0))*2;L[q]=M end;for q=1,J do local N=I[q]if N>0 then local F=(q-1)*16+N;local O=0;for P=1,N do O=O+c(d(1,b(L[N],P-1)),N-P)end;for P=0,2^w-1,2^N do E[P+O]=F end;L[N]=L[N]+1 end end;return E,w end;local function Q(R,s,S,T,U,V)local W=#R+1;local X;repeat X=D(s,S,T)if not X then return nil end;if X<256 then R[W]=X;W=W+1 elseif X>256 then local w,J,Y=0,3,1;if X<265 then J=J+X-257 elseif X<285 then w=b(X-261,2)J=J+c(d(X-261,3)+4,w)else J=258 end;if w>0 then J=J+z(s,w)end;local F=D(s,U,V)if F<4 then Y=Y+F else w=b(F-2,1)Y=Y+c(d(F,1)+2,w)+z(s,w)end;local y=W-Y;repeat R[W]=R[y]or 0;W=W+1;y=y+1;J=J-1 until J==0 end until X==256 end;local function Z(R,s)local _=z(s,5)if not _ then return nil end;local X,Y,G=257+_,1+z(s,5),4+z(s,4)local I={}for q=1,G do I[i[q]]=z(s,3)end;for q=G+1,19 do I[i[q]]=0 end;local a0,a1=H(I)local q=1;local a2=X+Y+1;repeat local F=D(s,a0,a1)if F<16 then I[q]=F;q=q+1 elseif F<19 then local t=j[F-15]local x=0;local a3=3+z(s,t)if F==16 then x=I[q-1]elseif F==18 then a3=a3+8 end;for a4=1,a3 do I[q]=x;q=q+1 end end until q==a2;local a5,a6={},{}for P=1,X do a5[P]=I[P]end;for P=X+1,#I do a6[#a6+1]=I[P]end;local S,T=H(a5)local U,V=H(a6)Q(R,s,S,T,U,V)end;local function a7(R,s)local I={}for q=1,4 do local N=l[q]for a4=1,k[q]do I[#I+1]=N end end;local S,T=H(I)Q(R,s,S,T,m,n)end;local function a8(R,s)r(s,d(s.count,7))local G=z(s,16)z(s,16)if not G then return nil end;local v,y=s.buffer,s.position;for q=y,y+G-1 do R[#R+1]=e(v,q,q)end;s.position=y+G end;local function a9(s)local a3=0;repeat local _=C(s,8)a3=a3*128+_%128 until _<128;return a3 end;local function aa(s)local type=C(s,2)if type>=2 then local ab=C(s,1)local ac=0;repeat local _=C(s,4)ac=c(ac,3)+d(_,7)until _<8;if ab==1 then ac=-ac end;local ad=a9(s)/0x20000000000000+0.5;return math.ldexp(ad,ac)*(type==2 and 1 or-1)else return a9(s)*(type==0 and 1 or-1)end end;local ae={2,6,22}local function af(s,ag)local w=C(s,2)if w==0 then return 1,C(s,ag)end;local ah=C(s,w*2)+ae[w]return ah,C(s,ag)end;local function ai(s,aj)local ak=C(s,4)if ak==0 then if C(s,1)==0 then return nil else return a9(s)end end;local al={}local _,am=0;for q=1,#aj do if _==0 then _,am=af(s,ak)end;if am>0 then al[#al+1]={s=aj[q],l=am}end;_=_-1 end;assert(_==0,_)table.sort(al,function(an,ao)if an.l==ao.l then return an.s<ao.s else return an.l<ao.l end end)al[1].c=0;for P=2,#al do al[P].c=bit32.lshift(al[P-1].c+1,al[P].l-al[P-1].l)end;local ap={}for P=1,#al do local am=al[P].c;local aq=ap;for ar=al[P].l-1,1,-1 do local _=bit32.extract(am,ar,1)if not aq[_+1]then aq[_+1]={}end;aq=aq[_+1]end;local _=bit32.extract(am,0,1)aq[_+1]=al[P].s end;return ap end;local function as(at)if at:sub(1,5)~=\"\\27LuzQ\"then error(\"invalid format\",2)end;local self={buffer=at,position=6,bits=0,count=0}local au,av;do local R,v={},{}local aw,ax;repeat aw,ax=z(self,1),z(self,2)if not aw or not ax then break end;ax=ax==0 and a8(R,self)or ax==1 and a7(R,self)or ax==2 and Z(R,self)until aw==1;local J=#R;for q=1,J,4096 do v[#v+1]=f(unpack(R,q,h(q+4095,J)))end;au=g(v)if self.count%8>0 then r(self,self.count%8)end end;do local R,v={},{}local aw,ax;repeat aw,ax=z(self,1),z(self,2)if not aw or not ax then break end;ax=ax==0 and a8(R,self)or ax==1 and a7(R,self)or ax==2 and Z(R,self)until aw==1;local J=#R;for q=1,J,4096 do v[#v+1]=f(unpack(R,q,h(q+4095,J)))end;av=g(v)if self.count%8>0 then r(self,self.count%8)end end;local ay={}for az in av:gmatch\"([%z\\1-\\62]+)\\63\"do ay[#ay+1]=az:gsub(\".\",p)end;local aA=ai(self,{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29})local ap=ai(self,{0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29})local aB;if C(self,1)==1 then local aC,ad={},{}local function aD(aq)if type(aq)==\"string\"then aC[#aC+1],ad[aq]=aq,true else aD(aq[1])aD(aq[2])end end;aD(a)for q=0,29 do if not ad[\":repeat\"..q]then aC[#aC+1]=\":repeat\"..q end end;table.sort(aC)aB=ai(self,aC)else aB=a end;local aE,aF=1,1;local aG={}local aH={}while true do local aq=aB;while type(aq)==\"table\"do aq=aq[C(self,1)+1]end;if aq==\":end\"then break elseif aq==\":name\"then aq=ap;while type(aq)==\"table\"do aq=aq[C(self,1)+1]end;local aI,aJ=math.max(math.floor(aq/2)-1,0)if aI>0 then local aK=C(self,aI)aJ=bit32.bor(aK,bit32.lshift(bit32.band(aq,1)+2,aI))else aJ=aq end;if aJ==0 then aG[#aG+1]=ay[aF]table.insert(aH,1,ay[aF])aF=aF+1 else local aL=table.remove(aH,aJ)aG[#aG+1]=aL;table.insert(aH,1,aL)end elseif aq==\":string\"then local ag=a9(self)aG[#aG+1]=(\"%q\"):format(au:sub(aE,aE+ag-1)):gsub(\"\\\\?\\n\",\"\\\\n\"):gsub(\"\\t\",\"\\\\t\"):gsub(\"[%z\\1-\\31\\127-\\255]\",function(_)return(\"\\\\%03d\"):format(_:byte())end)aE=aE+ag elseif aq==\":number\"then aG[#aG+1]=tostring(aa(self))elseif aq:find\"^:repeat\"then local aM=tonumber(aq:match\"^:repeat(%d+)\")local aI=math.max(math.floor(aM/2)-1,0)if aI>0 then local aK=C(self,aI)aM=bit32.bor(aK,bit32.lshift(bit32.band(aM,1)+2,aI))+3 else aM=aM+3 end;aq=aA;while type(aq)==\"table\"do aq=aq[C(self,1)+1]end;local aJ;aI=math.max(math.floor(aq/2)-1,0)if aI>0 then local aK=C(self,aI)aJ=bit32.bor(aK,bit32.lshift(bit32.band(aq,1)+2,aI))+1 else aJ=aq+1 end;for a4=1,aM do aG[#aG+1]=aG[#aG-aJ+1]end else aG[#aG+1]=aq end end;local aN=\"\"local aO,aP=false,false;for a4,aQ in ipairs(aG)do if aO and aQ:match\"^[A-Za-z0-9_]\"or aP and aQ:match\"^%.\"then aN=aN..\" \"end;aN=aN..aQ;aO,aP=aQ:match\"[A-Za-z0-9_]$\",aQ:match\"%.$\"end;return aN end;return as\n",created=1704748611571,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=7942},["lex.lua"]={modified=1704748611565,data="local a={}function a.__tostring(self)return(self.src or\"unknown\")..\":\"..self.line..\": \"..self.text end;local function b(c,d,e)error(setmetatable({line=c,col=d,text=e},a),0)end;local f={operator=\"^([;:=%.,%[%]%(%)%{%}%+%-%*/%^%%<>~#&|][=%.]?%.?)()\",name=\"^([%a_][%w_]*)()\",number=\"^(%d+%.?%d*)()\",scinumber=\"^(%d+%.?%d*[eE][%+%-]?%d+)()\",hexnumber=\"^(0[xX]%x+%.?%x*)()\",scihexnumber=\"^(0[xX]%x+%.?%x*[pP][%+%-]?%x+)()\",linecomment=\"^(%-%-[^\\n]*)()\",blockcomment=\"^(%-%-%[(=*)%[.-%]%2%])()\",emptyblockcomment=\"^(%-%-%[(=*)%[%]%2%])()\",blockquote=\"^(%[(=*)%[.-%]%2%])()\",emptyblockquote=\"^(%[(=*)%[%]%2%])()\",dquote='^(\"[^\"]*\")()',squote=\"^('[^']*')()\",whitespace=\"^(%s+)()\",invalid=\"^([^%w%s_;:=%.,%[%]%(%)%{%}%+%-%*/%^%%<>~#&|]+)()\"}local g={\"name\",\"scihexnumber\",\"hexnumber\",\"scinumber\",\"number\",\"blockcomment\",\"emptyblockcomment\",\"linecomment\",\"blockquote\",\"emptyblockquote\",\"operator\",\"dquote\",\"squote\",\"whitespace\",\"invalid\"}local h={[\"break\"]=true,[\"do\"]=true,[\"else\"]=true,[\"elseif\"]=true,[\"end\"]=true,[\"for\"]=true,[\"function\"]=true,[\"if\"]=true,[\"in\"]=true,[\"local\"]=true,[\"repeat\"]=true,[\"return\"]=true,[\"then\"]=true,[\"until\"]=true,[\"while\"]=true}local i={[\"and\"]=true,[\"not\"]=true,[\"or\"]=true,[\"+\"]=true,[\"-\"]=true,[\"*\"]=true,[\"/\"]=true,[\"%\"]=true,[\"^\"]=true,[\"#\"]=true,[\"==\"]=true,[\"~=\"]=true,[\"<=\"]=true,[\">=\"]=true,[\"<\"]=true,[\">\"]=true,[\"=\"]=true,[\"(\"]=true,[\")\"]=true,[\"{\"]=true,[\"}\"]=true,[\"[\"]=true,[\"]\"]=true,[\"::\"]=true,[\";\"]=true,[\":\"]=true,[\",\"]=true,[\".\"]=true,[\"..\"]=true}local j={[\"&\"]=true,[\"~\"]=true,[\"|\"]=true,[\"<<\"]=true,[\">>\"]=true,[\"//\"]=true}local k={[\"true\"]=true,[\"false\"]=true,[\"nil\"]=true,[\"...\"]=true}local function l(m,e)local n=1;e=m.pending..e;m.pending=\"\"while true do local o=false;for p,q in ipairs(g)do local r,s,t=e:match(f[q],n)if r then if q==\"dquote\"or q==\"squote\"then local u=true;while not r:gsub(\"\\\\.\",\"\"):match(f[q])do local v;v,s=e:match(f[q],s-1)if not v then u=false;break end;r=r..v:sub(2)end;if not u then break end elseif q==\"operator\"and#r>1 then while not(i[r]or r==\"...\")and#r>1 do r,s=r:sub(1,-2),s-1 end end;if t then s=t end;o=true;m[#m+1]={type=q,text=r,line=m.line,col=m.col}n=s;local w=select(2,r:gsub(\"\\n\",\"\\n\"))if w==0 then m.col=m.col+#r else m.line=m.line+w;m.col=#r:match(\"[^\\n]*$\")end;break end end;if not o then m.pending=e:sub(n)break end end end;local function x(m,y,z)for A,q in ipairs(m)do if q.type==\"operator\"then if q.text==\"...\"then q.type=\"constant\"elseif not i[q.text]and(y<3 or not j[q.text])then b(q.line,q.col,\"invalid operator '\"..q.text..\"'\")end elseif q.type==\"name\"then if h[q.text]then q.type=\"keyword\"elseif i[q.text]then q.type=\"operator\"elseif k[q.text]then q.type=\"constant\"end elseif q.type==\"dquote\"or q.type==\"squote\"or q.type==\"blockquote\"or q.type==\"emptyblockquote\"then q.type=\"string\"elseif q.type==\"linecomment\"or q.type==\"blockcomment\"or q.type==\"emptyblockcomment\"then q.type=\"comment\"elseif q.type==\"hexnumber\"or q.type==\"scinumber\"or q.type==\"scihexnumber\"then q.type=\"number\"elseif q.type==\"invalid\"then b(q.line,q.col,\"invalid characters\")end end;if z then local B={}for A,q in ipairs(m)do if q.type==\"number\"and B[#B].type==\"operator\"and B[#B].text==\"-\"then local C=B[#B-1]if C.type==\"operator\"and C.text~=\"}\"and C.text~=\"]\"and C.text~=\")\"or C.type==\"keyword\"and C.text~=\"end\"then q.text=\"-\"..q.text;B[#B]=nil end end;if q.type~=\"whitespace\"and(z~=2 or q.type~=\"comment\")then B[#B+1]=q end end;return B end;m.pending,m.line,m.col=nil;return m end;local function D(E,y,z)if type(E)==\"string\"then local F=E;function E()local G=F;F=nil;return G end end;local m={pending=\"\",line=1,col=1}while true do local F=E()if not F then break end;l(m,F)end;if m.pending~=\"\"then b(m.line,m.col,\"unfinished string\")end;return x(m,y,z)end;return D\n",created=1704748611572,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=3737},["token_encode_map.lua"]={modified=1704748611568,data="return{string={code=494,bits=9},[\"-\"]={code=101,bits=7},table={code=1006,bits=10},[\"*\"]={code=229,bits=8},print={code=1004,bits=10},pairs={code=2031,bits=11},ipairs={code=2028,bits=11},getmetatable={code=4086,bits=12},setmetatable={code=2034,bits=11},[\";\"]={code=488,bits=9},os={code=1003,bits=10},unpack={code=2037,bits=11},select={code=4092,bits=12},tonumber={code=2035,bits=11},[\"..\"]={code=230,bits=8},_={code=2021,bits=11},pcall={code=4090,bits=12},open={code=2030,bits=11},load={code=8190,bits=13},[\"[\"]={code=107,bits=7},[\"%\"]={code=994,bits=10},[\"^\"]={code=4082,bits=12},[\"==\"]={code=106,bits=7},[\":repeat1\"]={code=18,bits=5},[\":repeat0\"]={code=5,bits=4},[\":repeat3\"]={code=46,bits=6},require={code=2033,bits=11},[\":repeat4\"]={code=47,bits=6},[\":repeat8\"]={code=234,bits=8},[\":repeat7\"]={code=233,bits=8},[\"\\\"table\\\"\"]={code=2018,bits=11},[\"{\"]={code=112,bits=7},sub={code=1005,bits=10},[\"/\"]={code=485,bits=9},[\"...\"]={code=996,bits=10},[\"and\"]={code=235,bits=8},type={code=496,bits=9},[\":repeat11\"]={code=997,bits=10},find={code=2027,bits=11},match={code=2029,bits=11},[\"or\"]={code=239,bits=8},gsub={code=4087,bits=12},[\"end\"]={code=21,bits=5},_G={code=2022,bits=11},math={code=1002,bits=10},[\".\"]={code=16,bits=5},[\"function\"]={code=110,bits=7},tostring={code=2036,bits=11},[\"}\"]={code=113,bits=7},[\"0\"]={code=102,bits=7},[\"<\"]={code=489,bits=9},close={code=2025,bits=11},[\"\\\"nil\\\"\"]={code=4079,bits=12},read={code=2032,bits=11},[\":name\"]={code=0,bits=2},[\"=\"]={code=6,bits=4},[\",\"]={code=4,bits=4},[\">=\"]={code=999,bits=10},[\":repeat2\"]={code=19,bits=5},[\"<=\"]={code=998,bits=10},[\"#\"]={code=228,bits=8},write={code=2038,bits=11},[\"~=\"]={code=241,bits=8},error={code=1000,bits=10},__index={code=4084,bits=12},[\":repeat13\"]={code=2020,bits=11},coroutine={code=2026,bits=11},[\">\"]={code=490,bits=9},_ENV={code=4083,bits=12},[\"\\\"\\\"\"]={code=484,bits=9},[\":repeat9\"]={code=487,bits=9},[\"\\\"r\\\"\"]={code=4080,bits=12},[\"\\\"w\\\"\"]={code=4081,bits=12},__call={code=16383,bits=14},[\"1\"]={code=103,bits=7},debug={code=4085,bits=12},[\"\\\"number\\\"\"]={code=2016,bits=11},[\"\\\"boolean\\\"\"]={code=8188,bits=13},[\"2\"]={code=231,bits=8},[\"\\\"function\\\"\"]={code=4078,bits=12},[\":string\"]={code=20,bits=5},[\"-1\"]={code=995,bits=10},self={code=240,bits=8},[\":number\"]={code=17,bits=5},[\":repeat5\"]={code=104,bits=7},[\":end\"]={code=16382,bits=14},[\":repeat12\"]={code=2019,bits=11},[\"break\"]={code=2024,bits=11},[\"do\"]={code=109,bits=7},[\"else\"]={code=236,bits=8},[\"elseif\"]={code=491,bits=9},[\":repeat10\"]={code=486,bits=9},[\"false\"]={code=492,bits=9},[\"for\"]={code=237,bits=8},bit32={code=2023,bits=11},[\"\\\"string\\\"\"]={code=2017,bits=11},[\"if\"]={code=48,bits=6},[\"in\"]={code=1001,bits=10},[\"local\"]={code=22,bits=5},[\"nil\"]={code=238,bits=8},[\"not\"]={code=493,bits=9},[\")\"]={code=15,bits=5},[\"repeat\"]={code=4091,bits=12},[\"return\"]={code=111,bits=7},[\"then\"]={code=49,bits=6},[\"true\"]={code=495,bits=9},[\"until\"]={code=4093,bits=12},[\"while\"]={code=1007,bits=10},[\"(\"]={code=14,bits=5},[\":repeat6\"]={code=105,bits=7},[\":\"]={code=232,bits=8},[\"]\"]={code=108,bits=7},package={code=4089,bits=12},io={code=4088,bits=12},__newindex={code=8189,bits=13},[\"+\"]={code=100,bits=7}}\n",created=1704748611574,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=3157},["compress.lua"]={modified=1704748611564,data="local a=require\"LibDeflate\"local b=require\"maketree\"local c=require\"lz77\"local d=require\"token_encode_map\"local e=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_\"local f={}for g,h in e:gmatch\"()(.)\"do f[h]=g-1 end;local function i(j)if j%1>=0.5 then return math.ceil(j)else return math.floor(j)end end;local function k(g)if g==0 or g==1 then return{code=g,extra=0,bits=0}end;local l=math.max(select(2,math.frexp(g))-2,0)local m=2^l;return{code=l*2+(bit32.btest(g,m)and 3 or 2),extra=bit32.band(g,m-1),bits=l}end;local function n()return setmetatable({data=\"\",partial=0,len=0},{__call=function(self,o,p)if not o then o,p=0,8-self.len end;if p==0 then return end;assert(o<2^p)self.partial=bit32.bor(bit32.lshift(self.partial,p),o)self.len=self.len+p;while self.len>=8 do local q=bit32.extract(self.partial,self.len-8,8)self.data=self.data..string.char(q)self.len=self.len-8 end end})end;local function r(s,t)local u={}while t>127 do u[#u+1],t=t%128,math.floor(t/128)end;u[#u+1]=t%128;if s then for g=#u,1,-1 do s(u[g]+(g==1 and 0 or 128),8)end end;return#u*8 end;local function v(s,t)if t%1==0 then if s then s(t<0 and 1 or 0,2)end;return r(s,math.abs(t))else local w,x=math.frexp(t)w=i((math.abs(w)-0.5)*0x20000000000000)if w>0xFFFFFFFFFFFFF then x=x+1 end;if s then s((t<0 and 6 or 4)+(x<0 and 1 or 0),3)end;x=math.abs(x)local y={}while x>7 do y[#y+1],x=x%8,math.floor(x/8)end;y[#y+1]=x%8;if s then for g=#y,1,-1 do s(y[g]+(g==1 and 0 or 8),4)end end;return r(s,w)+#y*4+3 end end;local function z(s,A)if not A or next(A)==nil then if s then s(0,5)end;return 5 elseif A.idx then if s then s(0,4)s(1,1)end;return r(s,A.idx-1)+5 end;local B=A.lengths;local C=select(2,math.frexp(A.maxlen))if s then s(C,4)end;local o=4;local h,j=B[1],0;local t,D=1,0;for E,F in ipairs(B)do if F~=h or j==85 then if j>21 then if s then s(3,2)s(j-22,6)end;o=o+8+C elseif j>5 then if s then s(2,2)s(j-6,4)end;o=o+6+C elseif j>1 then if s then s(1,2)s(j-2,2)end;o=o+4+C else if s then s(0,2)end;o=o+2+C end;if s then s(h,C)end;h,j=F,0;t=t+1;if h>1 then D=D+1 end end;j=j+1 end;if j>21 then if s then s(3,2)s(j-22,6)end;o=o+8+C elseif j>5 then if s then s(2,2)s(j-6,4)end;o=o+6+C elseif j>1 then if s then s(1,2)s(j-2,2)end;o=o+4+C else if s then s(0,2)end;o=o+2+C end;if s then s(h,C)end;if h>1 then D=D+1 end;return o end;local function G(H,I)local A={list={}}for g,J in pairs(I)do A.list[g]={J[1],H[J[1]]or 0}end;A.map,A.lengths=b(A.list)if not A.map then if A.map==nil then return nil elseif A.map==false then return{idx=A.lengths,map={[I[A.lengths][1]]={code=0,bits=0,extra=0}}}end end;A.maxlen=0;for E,J in pairs(A.lengths)do A.maxlen=math.max(A.maxlen,J)end;return A end;local function K(L,M)local N=M and(M==0 and 0 or 2^(M+6))local O,I,P,Q={},{},\"\",{}L=c(L,N)local R={}for E,F in ipairs(L)do if F.type:find\"^repeat\"then R[F.dist.code]=(R[F.dist.code]or 0)+1 end end;local S={}for g=0,29 do S[g+1]={g,R[g]or 0}end;local T={}T.map,T.lengths=b(S)if T.map then T.maxlen=0;for E,J in ipairs(T.lengths)do T.maxlen=math.max(T.maxlen,J)end elseif T.map==false then T={idx=T.lengths}end;for g,F in ipairs(L)do if F.type==\"name\"and not d[F.text]then local U;for V,J in ipairs(I)do if J==F.text then U=V;break end end;if U then F.code=k(U)O[F.code.code]=(O[F.code.code]or 0)+1;table.insert(I,1,table.remove(I,U))else F.code=k(0)O[0]=(O[0]or 0)+1;Q[#Q+1]=F.text;table.insert(I,1,F.text)end elseif F.type==\"string\"and not d[F.text]then F.str=load(\"return \"..F.text,\"=string\",\"t\",{})()P=P..F.str end end;local W={}for g=0,29 do W[#W+1]={g,O[g]or 0}end;local X=G(O,W)local H={[\":end\"]=1}for E,F in ipairs(L)do if d[F.text]then H[F.text]=(H[F.text]or 0)+1 else H[\":\"..F.type]=(H[\":\"..F.type]or 0)+1 end end;local Y={}for g=0,29 do if not d[\":repeat\"..g]then Y[#Y+1]={\":repeat\"..g,H[\":repeat\"..g]or 0}end end;for Z in pairs(d)do Y[#Y+1]={Z,H[Z]or 0}end;table.sort(Y,function(_,a0)return _[1]<a0[1]end)local a1=G(H,Y)local a2,a3=z(nil,a1),0;for E,F in ipairs(L)do if d[F.text]then a3=a3+d[F.text].bits;a2=a2+a1.map[F.text].bits elseif F.type==\"name\"then a3=a3+d[\":name\"].bits+X.map[F.code.code].bits+F.code.bits;a2=a2+a1.map[\":name\"].bits+X.map[F.code.code].bits+F.code.bits elseif F.type==\"string\"then a3=a3+d[\":string\"].bits+r(nil,#F.str)a2=a2+a1.map[\":string\"].bits+r(nil,#F.str)elseif F.type==\"number\"then a3=a3+d[\":number\"].bits+v(nil,tonumber(F.text))a2=a2+a1.map[\":number\"].bits+v(nil,tonumber(F.text))elseif F.type:find\"^repeat\"then a3=a3+d[\":\"..F.type].bits+F.len.bits+T.map[F.dist.code].bits+F.dist.bits;a2=a2+a1.map[\":\"..F.type].bits+F.len.bits+T.map[F.dist.code].bits+F.dist.bits else error(\"Could not find encoding for token \"..F.type..\"(\"..F.text..\")!\")end end;print(a3,a2)local s=n()s.data=\"\\27LuzQ\"..a:CompressDeflate(P,{level=M})local a4=#s.data-5;local a5=\"\"for E,F in ipairs(Q)do for h in F:gmatch\".\"do a5=a5 ..string.char(f[h])end;a5=a5 ..\"\\63\"end;local a6=a:CompressDeflate(a5,{level=M})s.data=s.data..a6;local a7=#s.data-a4-5;z(s,T)z(s,X)local a8;if a2<a3 then s(1,1)z(s,a1)a8=a1.map else s(0,1)a8=d end;print(a4,a7,#s.data-a7-a4-5,#I)local a9,aa,ab,ac,ad,ae,af=0,0,0,0,0,0,0;for E,F in ipairs(L)do if d[F.text]then s(a8[F.text].code,a8[F.text].bits)a9=a9+a8[F.text].bits elseif F.type==\"name\"then s(a8[\":name\"].code,a8[\":name\"].bits)a9=a9+a8[\":name\"].bits;s(X.map[F.code.code].code,X.map[F.code.code].bits)s(F.code.extra,F.code.bits)aa=aa+X.map[F.code.code].bits+F.code.bits elseif F.type==\"string\"then s(a8[\":string\"].code,a8[\":string\"].bits)a9=a9+a8[\":string\"].bits;ab=ab+r(s,#F.str)elseif F.type==\"number\"then s(a8[\":number\"].code,a8[\":number\"].bits)a9=a9+a8[\":number\"].bits;ac=ac+v(s,tonumber(F.text))elseif F.type:find\"^repeat\"then s(a8[\":\"..F.type].code,a8[\":\"..F.type].bits)a9=a9+a8[\":\"..F.type].bits;s(F.len.extra,F.len.bits)s(T.map[F.dist.code].code,T.map[F.dist.code].bits)s(F.dist.extra,F.dist.bits)ad=ad+F.len.bits+T.map[F.dist.code].bits+F.dist.bits;af=af+1 else error(\"Could not find encoding for token \"..F.type..\"(\"..F.text..\")!\")end end;s(a8[\":end\"].code,a8[\":end\"].bits)s()a9=a9+d[\":end\"].bits;print(a9/8,aa/8,ab/8,ac/8,ad/8,ae/8,af)return s.data end;return K\n",created=1704748611571,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=6084},["maketree.lua"]={modified=1704748611566,data="local function a(b,c)return b.weight>c.weight end;local function d(b,c)if b.bits==c.bits then return b.symbol<c.symbol else return b.bits<c.bits end end;local function e(f,g,h,i)if f.data then i.symbol=f.data;h[f.data]=i;g[#g+1]=i else e(f[1],g,h,{bits=i.bits+1,code=i.code*2})e(f[2],g,h,{bits=i.bits+1,code=i.code*2+1})end end;local function j(k)local l={}for m,n in ipairs(k)do if n[2]>0 then l[#l+1]={data=n[1],weight=n[2]}end end;if#l==0 then return nil elseif#l==1 then for m,n in ipairs(k)do if n[1]==l[1].data then return false,m end end;return nil end;table.sort(l,a)while#l>1 do local b,c=l[#l-1],l[#l]local o={weight=b.weight+c.weight,b,c}l[#l]=nil;l[#l]=o;table.sort(l,a)end;local g,h={},{}e(l[1],g,h,{bits=0,code=0})table.sort(g,d)g[1].code=0;for m=2,#g do g[m].code=bit32.lshift(g[m-1].code+1,g[m].bits-g[m-1].bits)end;local p={}for m,n in ipairs(k)do p[m]=h[n[1]]and h[n[1]].bits or 0 end;local q={}for r,n in ipairs(g)do if n.bits==1 then q[n.code+1]=n.symbol else local f=q;for o=n.bits-1,1,-1 do local s=bit32.extract(n.code,o)+1;f[s]=f[s]or{}f=f[s]end;local s=bit32.extract(n.code,0)+1;f[s]=n.symbol end;n.symbol=nil end;return h,p,q end;return j\n",created=1704748611573,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1165},["lz77.lua"]={modified=1704748611566,data="local function a(b)if b==0 or b==1 then return{code=b,extra=0,bits=0}end;local c=math.max(select(2,math.frexp(b))-2,0)local d=2^c;return{code=c*2+(bit32.btest(b,d)and 3 or 2),extra=bit32.band(b,d-1),bits=c}end;local function e(f,g)g=math.min(g or 1024,32768)local h={}local i={}local b=1;while b<=#f do local j=f[b]if not j.names and i[j.type]and i[j.type][j.text]then local k=i[j.type][j.text]local l,m=0;for n=#k,1,-1 do local o=k[n]if b-o>g then break end;for p=1,math.min(#f-b,129)do local q=(p-1)%(b-o)+1;if f[b+p].type==f[o+q].type and f[b+p].text==f[o+q].text then if p>l then l,m=p,o end;if f[o+q].names then break end else break end end end;if l>=2 then local r=a(l-2)local s=a(b-m-1)h[#h+1]={type=\"repeat\"..r.code,text=\"\",dist=s,len=r}for p=0,l do j=f[b+p]i[j.type][j.text][#i[j.type][j.text]+1]=b+p end;if f[b+l].names then h[#h].names=f[b+l].names end;b=b+l+1;j=nil end end;if j then h[#h+1]=j;i[j.type]=i[j.type]or{}i[j.type][j.text]=i[j.type][j.text]or{}i[j.type][j.text][#i[j.type][j.text]+1]=b;b=b+1 end end;return h end;return e\n",created=1704748611573,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1046},["minify.lua"]={modified=1704748611567,data="local a=\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\"local function b(c)local d=\"\"while c>=52 do d,c=d..a:sub(c%52+1,c%52+1),math.floor(c/52)end;return a:sub(c%52+1,c%52+1)..d:reverse()end;local function e(f,g,h,i)error(\"Not implemented yet\")return i,h end;local function j(f,g,h,k)h=h or 1;k=k or 0;local l=setmetatable({},{__index=g or{}})local m=1;local i={}while h<=#f do local n=f[h]if m==1 then if n.type==\"keyword\"then i[h]=n;if n.text==\"do\"or n.text==\"then\"then local o,d=j(f,l,h+1,k)for p=h+1,d do i[p]=o[p]end;h=d elseif n.text==\"until\"then return e(f,l,h+1,i)elseif n.text==\"function\"then local q=k;if f[h+1].type==\"name\"then h=h+1;if l[f[h].text]then i[h]={col=n.col,line=n.line,type=\"name\",text=l[f[h].text]}else i[h]=f[h]end end;h=h+1;i[h]=f[h]h=h+1;n=f[h]local r=setmetatable({},{__index=l})while n.type~=\"operator\"or n.text~=\")\"do if n.type==\"name\"then r[n.text]=b(k)k=k+1;i[h]={col=n.col,line=n.line,type=\"name\",text=r[n.text]}else i[h]=n end;h=h+1;n=f[h]end;i[h]=n;local o,d=j(f,r,h+1,k)for p=h+1,d do i[p]=o[p]end;h=d;k=q elseif n.text==\"local\"or n.text==\"for\"then m=3 elseif n.text==\"end\"then return i,h end elseif n.type==\"name\"then if l[n.text]then i[h]={col=n.col,line=n.line,type=\"name\",text=l[n.text]}else i[h]=n end elseif n.type==\"operator\"then i[h]=n;if n.text==\".\"or n.text==\":\"then m=2 end else i[h]=n end elseif m==2 then i[h]=n;if not(n.type==\"operator\"and(n.text==\".\"or n.text==\":\")or n.type==\"name\")then m=1 end elseif m==3 then if n.type==\"keyword\"and n.text==\"function\"then n=i[h+1]l[n.text]=b(k)k=k+1;i[h]={col=n.col,line=n.line,type=\"name\",text=l[n.text]}local q=k;h=h+2;i[h]=f[h]h=h+1;n=f[h]local r=setmetatable({},{__index=l})while n.type~=\"operator\"or n.text~=\")\"do if n.type==\"name\"then r[n.text]=b(k)k=k+1;i[h]={col=n.col,line=n.line,type=\"name\",text=r[n.text]}else i[h]=n end;h=h+1;n=f[h]end;i[h]=n;local o,d=j(f,r,h+1,k)for p=h+1,d do i[p]=o[p]end;h=d;k=q elseif n.type==\"name\"then l[n.text]=b(k)k=k+1;i[h]={col=n.col,line=n.line,type=\"name\",text=l[n.text]}m=4 else error(\"invalid local statement\")end elseif m==4 then if n.type==\"operator\"and n.text==\",\"then m=3;i[h]=n else m=1;h=h-1 end end;h=h+1 end;return i,#f end;return j\n",created=1704748611574,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=2183}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},["libcc.a"]={modified=1704748611236,data="!<arch>\naudio.dfpwm.lua/0           0     0     644     1285      `\nlocal a=require\"expect\".expect;local b,c,d,e,f=string.char,string.byte,math.floor,bit32.band,bit32.arshift;local g=10;local h=2^g;local i=2^(g-1)local j=2^(g-8+1)local function k()local l,m,n=0,0,false;return function(o)local p=o and 127 or-128;local q=l+d((m*(p-l)+i)/h)if q==l and q~=p then q=q+(o and 1 or-1)end;local r=o==n and h-1 or 0;local s=m;if s~=r then s=s+(o==n and 1 or-1)end;if s<j then s=j end;l,m,n=q,s,o;return l end end;local function t()local u=k()local v=0;return function(w)a(1,w,\"table\")local x,y={},0;for z=1,#w,8 do local A=0;for B=0,7 do local C=d(w[z+B]or 0)if C>127 or C<-128 then error((\"Amplitude at position %d was %d, but should be between -128 and 127\"):format(z+B,C),2)end;local o=C>v or C==v and C==127;A=d(A/2)+(o and 128 or 0)v=u(o)end;y=y+1;x[y]=b(A)end;return table.concat(x,\"\",1,y)end end;local function D()local u=k()local E=0;local v,n=0,false;return function(w,x)a(1,w,\"string\")local x,y={},0;for z=1,#w do local F=c(w,z)for G=1,8 do local o=e(F,1)~=0;local l=u(o)local H=l;if o~=n then H=d((l+v+1)/2)end;v,n=l,o;E=E+d(((H-E)*140+0x80)/256)y=y+1;x[y]=E;F=f(F,1)end end;return x end end;local function I(w)a(1,w,\"string\")return D()(w)end;local function J(w)a(1,w,\"table\")return t()(w)end;return{make_encoder=t,encode=J,make_decoder=D,decode=I}\n\nexpect.lua/     0           0     0     644     1273      `\nlocal a={}local b={[\"nil\"]=true,boolean=true,number=true,string=true,table=true,[\"function\"]=true,userdata=true,thread=true}local function c(d,e,...)local f=type(e)local g;if f==\"table\"then local h=getmetatable(e)if h then g=h.__name end end;local i=table.pack(...)for j,k in ipairs(i)do if b[k]then if f==k then return e end elseif g==k then return e end end;local l=debug.getinfo(2,\"n\")if l and l.name and l.name~=\"\"then d=d..\" to '\"..l.name..\"'\"end;local m;if i.n==1 then m=i[1]elseif i.n==2 then m=i[1]..\" or \"..i[2]else m=table.concat(i,\", \",1,i.n-1)..\", or \"..i[i.n]end;error(d..\" (expected \"..m..\", got \"..f..\")\",3)end;function a.expect(n,e,...)return c(\"bad argument #\"..n,e,...)end;function a.field(o,p,...)local q,r=pcall(string.format,\"%q\",p)if not q then r=tostring(p)end;return c(\"bad field \"..r,o[p],...)end;function a.range(s,t,u)a.expect(1,s,\"number\")a.expect(2,t,\"number\",\"nil\")a.expect(3,u,\"number\",\"nil\")if u and t and u<t then error(\"bad argument #3 (min must be less than or equal to max)\",2)end;if s~=s or s<(t or-math.huge)or s>(u or math.huge)then error((\"number outside of range (expected %s to be within %s and %s)\"):format(s,t or-math.huge,u or math.huge),3)end;return s end;return setmetatable(a,{__call=function(j,...)return a.expect(...)end})\n\nimage.nft.lua/  0           0     0     644     943       `\nlocal a=require\"expect\".expect;local function b(c)a(1,c,\"string\")local d={}local e=1;local f=\"0\"local g=\"f\"local h,i=1,#c;while h<=i do local j=c:sub(h,h)if j==\"\\31\"and h<i then h=h+1;f=c:sub(h,h)elseif j==\"\\30\"and h<i then h=h+1;g=c:sub(h,h)elseif j==\"\\n\"then if d[e]==nil then d[e]={text=\"\",foreground=\"\",background=\"\"}end;e=e+1;f,g=\"0\",\"f\"else local k=c:find(\"[\\n\\30\\31]\",h)or#c+1;local l=k-h;local m=d[e]if m==nil then m={foreground=\"\",background=\"\",text=\"\"}d[e]=m end;m.text=m.text..c:sub(h,k-1)m.foreground=m.foreground..f:rep(l)m.background=m.background..g:rep(l)h=k-1 end;h=h+1 end;return d end;local function n(o)a(1,o,\"string\")local p,q=io.open(o,\"r\")if not p then return nil,q end;local d=p:read(\"*a\")p:close()return b(d)end;local function r(c,s,t,u)a(1,c,\"table\")a(2,s,\"number\")a(3,t,\"number\")a(4,u,\"table\")for v,e in ipairs(c)do u.setCursorPos(s,t+v-1)u.blit(e.text,e.foreground,e.background)end end;return{parse=b,load=n,draw=r}\n\npretty.lua/     0           0     0     644     6449      `\nlocal term=term or require\"craftos.term\"local a=require\"expect\"local a,b=a.expect,a.field;local type,getmetatable,setmetatable,colours,c,tostring=type,getmetatable,setmetatable,colours,write,tostring;local d,e=debug.getinfo,debug.getlocal;local function f(g,h)local i=g.n+1;g[i],g.n=h,i end;local j={}local function k(l)return setmetatable(l,j)end;local m=k({tag=\"nil\"})local n=k({tag=\"text\",text=\" \"})local o=k({tag=\"line\",flat=m})local p=k({tag=\"line\",flat=n})local q={[\"\"]=m,[\" \"]=n,[\"\\n\"]=p}local function r(s,t)return q[s]or setmetatable({tag=\"text\",text=s,colour=t},j)end;local function s(s,t)a(1,s,\"string\")a(2,t,\"number\",\"nil\")local u=q[s]if u then return u end;local v=s:find(\"\\n\",1)if not v then return r(s,t)end;local w=setmetatable({tag=\"concat\",n=0},j)if v~=1 then f(w,r(s:sub(1,v-1),t))end;v=v+1;while true do local x=s:find(\"\\n\",v)f(w,p)if not x then if v<=#s then f(w,r(s:sub(v),t))end;return w else if v<=x-1 then f(w,r(s:sub(v,x-1),t))end;v=x+1 end end end;local function y(...)local z=table.pack(...)for A=1,z.n do if type(z[A])==\"string\"then z[A]=s(z[A])end;if getmetatable(z[A])~=j then a(A,z[A],\"document\")end end;if z.n==0 then return m end;if z.n==1 then return z[1]end;z.tag=\"concat\"return setmetatable(z,j)end;j.__concat=y;local function B(C,w)a(1,C,\"number\")if getmetatable(w)~=j then a(2,w,\"document\")end;if C<=0 then error(\"depth must be a positive number\",2)end;return setmetatable({tag=\"nest\",depth=C,w},j)end;local function D(w)if w.flat then return w.flat end;local E=w.tag;if E==\"nil\"or E==\"text\"then return w elseif E==\"concat\"then local g=setmetatable({tag=\"concat\",n=w.n},j)for A=1,w.n do g[A]=D(w[A])end;w.flat,g.flat=g,g;return g elseif E==\"nest\"then return D(w[1])elseif E==\"group\"then return w[1]else error(\"Unknown doc \"..E)end end;local function F(w)if getmetatable(w)~=j then a(1,w,\"document\")end;if w.tag==\"group\"then return w end;local G=D(w)if G==w then return w end;return setmetatable({tag=\"group\",G,w},j)end;local function H(w,I)local E=w.tag;if E==\"nil\"or E==\"line\"then return I elseif E==\"text\"then return I-#w.text elseif E==\"concat\"then for A=1,w.n do I=H(w[A],I)if I<0 then break end end;return I elseif E==\"group\"or E==\"nest\"then return H(E[1])else error(\"Unknown doc \"..E)end end;local function write(w,J)if getmetatable(w)~=j then a(1,w,\"document\")end;a(2,J,\"number\",\"nil\")local term=term;local I,K=term.getSize()local L=(J or 0.6)*I;if L<0 then L=0 end;if L>I then L=I end;local M=term.getTextColour()local N=M;local function O(w,P,Q)local E=w.tag;if E==\"nil\"then return Q elseif E==\"text\"then local R=w.colour or M;if R~=N then term.setTextColour(R)N=R end;c(w.text)return Q+#w.text elseif E==\"line\"then local S,T=term.getCursorPos()if T<K then term.setCursorPos(P+1,T+1)else term.scroll(1)term.setCursorPos(P+1,K)end;return P elseif E==\"concat\"then for A=1,w.n do Q=O(w[A],P,Q)end;return Q elseif E==\"nest\"then return O(w[1],P+w.depth,Q)elseif E==\"group\"then if H(w[1],math.min(I,L+P)-Q)>=0 then return O(w[1],P,Q)else return O(w[2],P,Q)end else error(\"Unknown doc \"..E)end end;local Q=math.max(term.getCursorPos()-1,0)O(w,0,Q)if N~=M then term.setTextColour(M)end end;local function U(w,J)if getmetatable(w)~=j then a(1,w,\"document\")end;a(2,J,\"number\",\"nil\")write(w,J)c(\"\\n\")end;local function V(w,I,J)if getmetatable(w)~=j then a(1,w,\"document\")end;a(2,I,\"number\",\"nil\")a(3,J,\"number\",\"nil\")local L;if I then L=(J or 0.6)*I;if L<0 then L=0 end;if L>I then L=I end end;local g={n=0}local function O(w,P,Q)local E=w.tag;if E==\"nil\"then return Q elseif E==\"text\"then f(g,w.text)return Q+#w.text elseif E==\"line\"then f(g,\"\\n\"..(\" \"):rep(P))return P elseif E==\"concat\"then for A=1,w.n do Q=O(w[A],P,Q)end;return Q elseif E==\"nest\"then return O(w[1],P+w.depth,Q)elseif E==\"group\"then if not I or H(w[1],math.min(I,L+P)-Q)>=0 then return O(w[1],P,Q)else return O(w[2],P,Q)end else error(\"Unknown doc \"..E)end end;O(w,0,0)return table.concat(g,\"\",1,g.n)end;j.__tostring=V;local W={[\"and\"]=true,[\"break\"]=true,[\"do\"]=true,[\"else\"]=true,[\"elseif\"]=true,[\"end\"]=true,[\"false\"]=true,[\"for\"]=true,[\"function\"]=true,[\"if\"]=true,[\"in\"]=true,[\"local\"]=true,[\"nil\"]=true,[\"not\"]=true,[\"or\"]=true,[\"repeat\"]=true,[\"return\"]=true,[\"then\"]=true,[\"true\"]=true,[\"until\"]=true,[\"while\"]=true}local X=s(\",\")local Y=s(\"{}\")local Z,_=s(\"{\"),s(\"}\")local a0,a1=s(\"[\"),s(\"] = \")local function a2(a3,a4)local a5,a6=type(a3),type(a4)if a5==\"string\"then return a6~=\"string\"or a3<a4 elseif a6==\"string\"then return false end;if a5==\"number\"then return a6~=\"number\"or a3<a4 end;return false end;local function a7(a8,a9)local aa=d and d(a8,\"Su\")local ab;if a9.function_source and aa and aa.short_src and aa.linedefined and aa.linedefined>=1 then ab=\"function<\"..aa.short_src..\":\"..aa.linedefined..\">\"else ab=tostring(a8)end;if a9.function_args and aa and aa.what==\"Lua\"and aa.nparams and e then local z={}for A=1,aa.nparams do z[A]=e(a8,A)or\"?\"end;if aa.isvararg then z[#z+1]=\"...\"end;ab=ab..\"(\"..table.concat(z,\", \")..\")\"end;return ab end;local function ac(ad,a9,ae)local af=type(ad)if af==\"string\"then local ag=(\"%q\"):format(ad):gsub(\"\\\\\\n\",\"\\\\n\")return s(ag,colours.red)elseif af==\"number\"then return s(tostring(ad),colours.magenta)elseif af==\"function\"then return s(a7(ad,a9),colours.lightGrey)elseif af~=\"table\"or ae[ad]then return s(tostring(ad),colours.lightGrey)elseif getmetatable(ad)~=nil and getmetatable(ad).__tostring then return s(tostring(ad))elseif next(ad)==nil then return Y else ae[ad]=true;local w=setmetatable({tag=\"concat\",n=1,p},j)local ah,ai,aj=#ad,{},1;for ak in pairs(ad)do if type(ak)~=\"number\"or ak%1~=0 or ak<1 or ak>ah then ai[aj],aj=ak,aj+1 end end;table.sort(ai,a2)for A=1,ah do if A>1 then f(w,X)f(w,p)end;f(w,ac(ad[A],a9,ae))end;for A=1,aj-1 do if A>1 or ah>=1 then f(w,X)f(w,p)end;local ak=ai[A]local al=ad[ak]if type(ak)==\"string\"and not W[ak]and ak:match(\"^[%a_][%a%d_]*$\")then f(w,s(ak..\" = \"))f(w,ac(al,a9,ae))else f(w,a0)f(w,ac(ak,a9,ae))f(w,a1)f(w,ac(al,a9,ae))end end;ae[ad]=nil;return F(y(Z,B(2,y(table.unpack(w,1,w.n))),p,_))end end;local function am(ad,a9)a(2,a9,\"table\",\"nil\")a9=a9 or{}local an={function_source=b(a9,\"function_source\",\"boolean\",\"nil\")or false,function_args=b(a9,\"function_args\",\"boolean\",\"nil\")or false}return ac(ad,an,{})end;local function ao(ad,a9,J)a(2,a9,\"table\",\"nil\")a9=a9 or{}a(3,J,\"number\",\"nil\")return U(am(ad,a9),J)end;return{empty=m,space=n,line=o,space_line=p,text=s,concat=y,nest=B,group=F,write=write,print=U,render=V,pretty=am,pretty_print=ao}\n\n",created=1704748611250,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=10202},["libcraftos.a"]={modified=1704748611236,data="!<arch>\ncolors.lua/     0           0     0     644     669       `\nlocal a=require\"cc.expect\"local b={white=0,orange=1,magenta=2,lightBlue=3,yellow=4,lime=5,pink=6,gray=7,lightGray=8,cyan=9,purple=10,blue=11,brown=12,green=13,red=14,black=15}function b.combine(...)return math.max(...)end;function b.subtract(...)return math.min(...)end;function b.test(c,d)return c==d end;function b.packRGB(e,f,d)a(1,e,\"number\")a(2,f,\"number\")a(3,d,\"number\")return bit32.bor(bit32.lshift(e*255,16),bit32.lshift(f*255,8),d*255)end;function b.unpackRGB(g)a(1,g,\"number\")return bit32.band(bit32.rshift(g,16),0xFF)/255,bit32.band(bit32.rshift(g,8),0xFF)/255,bit32.band(g,0xFF)/255 end;function b.toBlit(h)a(1,h,\"number\")return(\"%x\"):format(h)end;return b\n\ncolours.lua/    0           0     0     644     669       `\nlocal a=require\"cc.expect\"local b={white=0,orange=1,magenta=2,lightBlue=3,yellow=4,lime=5,ping=6,grey=7,lightGrey=8,cyan=9,purple=10,blue=11,brown=12,green=13,red=14,black=15}function b.combine(...)return math.max(...)end;function b.subtract(...)return math.min(...)end;function b.test(c,d)return c==d end;function b.packRGB(e,f,d)a(1,e,\"number\")a(2,f,\"number\")a(3,d,\"number\")return bit32.bor(bit32.lshift(e*255,16),bit32.lshift(f*255,8),d*255)end;function b.unpackRGB(g)a(1,g,\"number\")return bit32.band(bit32.rshift(g,16),0xFF)/255,bit32.band(bit32.rshift(g,8),0xFF)/255,bit32.band(g,0xFF)/255 end;function b.toBlit(h)a(1,h,\"number\")return(\"%x\"):format(h)end;return b\n\ndisk.lua/       0           0     0     644     1517      `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"local function c(d)local e=b.devinfo(d)return e and e.types.drive end;local f={}function f.isPresent(d)a(1,d,\"string\")return b.devlookup(d)~=nil and b.devinfo(d).types.drive and b.devcall(d,\"getState\")~=nil end;function f.getLabel(d)a(1,d,\"string\")if not c(d)then return nil end;local g=b.devcall(d,\"getState\")return g and g.label end;function f.setLabel(d,h)a(1,d,\"string\")a(2,h,\"string\",\"nil\")if not c(d)then return end;b.devcall(d,\"setLabel\",h)end;function f.hasData(d)a(1,d,\"string\")if not c(d)then return false end;local g=b.devcall(d,\"getState\")return g and not g.isAudio end;function f.getMountPath(d)a(1,d,\"string\")local e=b.devinfo(d)if not e or not e.types.drive then return nil end;local i=b.mountlist()for j,k in ipairs(i)do if k.type==\"drivefs\"and k.uuid==e.uuid then return k.path end end;return nil end;function f.hasAudio(d)a(1,d,\"string\")if not c(d)then return false end;local g=b.devcall(d,\"getState\")return g and g.audio~=nil end;function f.getAudioTitle(d)a(1,d,\"string\")if not c(d)then return nil end;local g=b.devcall(d,\"getState\")return g and g.audio end;function f.playAudio(d)a(1,d,\"string\")if not c(d)then return end;b.devcall(d,\"play\")end;function f.stopAudio(d)a(1,d,\"string\")if not c(d)then return end;b.devcall(d,\"stop\")end;function f.eject(d)a(1,d,\"string\")if not c(d)then return end;b.devcall(d,\"eject\")end;function f.getID(d)a(1,d,\"string\")if not c(d)then return nil end;local g=b.devcall(d,\"getState\")return g and g.id end;return f\n\nfs.lua/         0           0     0     644     2804      `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"local c={}function c.list(d)a(1,d,\"string\")return b.list(d)end;function c.exists(d)a(1,d,\"string\")return b.stat(d)~=nil end;function c.isDir(d)a(1,d,\"string\")local e=b.stat(d)return e~=nil and e.type==\"directory\"end;function c.isReadOnly(d)a(1,d,\"string\")local e=b.stat(d)while e==nil do d=c.getDir(d)e=b.stat(d)end;local f=b.getuser()if e.permissions[f]then return not e.permissions[f].write else return not e.worldPermissions.write end end;function c.getName(d)a(1,d,\"string\")return filesystem.combine(d):match\"[^/]+$\"end;function c.getDrive(d)a(1,d,\"string\")local e=b.stat(d)return e and(e.mountpoint==\"/\"and\"hdd\"or e.mountpoint:gsub(\"^/\",\"\"))end;function c.getSize(d)a(1,d,\"string\")local e=b.stat(d)return e and e.size end;function c.getFreeSpace(d)a(1,d,\"string\")local e=b.stat(d)return e and e.freeSpace end;function c.makeDir(d)a(1,d,\"string\")return b.mkdir(d)end;function c.move(g,h)a(1,g,\"string\")a(2,h,\"string\")local i,j=assert(b.stat(g)),assert(b.stat(h))if i.mountpoint==j.mountpoint then return b.rename(g,h)end;c.copy(g,h)b.remove(g)end;function c.copy(g,h)a(1,g,\"string\")a(2,h,\"string\")local e=b.stat(g)if e.type==\"directory\"then local k=b.list(g)b.mkdir(h)for l,m in ipairs(k)do c.copy(b.combine(g,m),b.combine(h,m))end else local n,o=b.open(g,\"rb\")if not n then error(o,2)end;local p,o=b.open(h,\"wb\")if not p then n.close()error(o,2)end;repeat local q=n.read(512)if q then p.write(q)end until not q;p.close()n.close()end end;function c.delete(d)a(1,d,\"string\")return b.remove(d)end;function c.combine(...)return b.combine(...)end;function c.open(d,r)a(1,d,\"string\")a(2,r,\"string\")return b.open(d,r)end;local function s(t,u,v)if v>#u then return{}end;local w=u[v]:gsub(\"[%^%$%(%)%%%.%+%-]\",\"%%%1\"):gsub(\"%*\",\".*\"):gsub(\"%?\",\".\"):gsub(\"%[!\",\"[^\")local x={}for l,y in ipairs(t)do local z,A=pcall(b.list,y)if z then for l,d in ipairs(A)do if d:match(w)then x[#x+1]=b.combine(y,d)end end end end;if v+1>#u then return x end;return s(x,u,v+1)end;function c.find(B)a(1,B,\"string\")local C={}for D in B:gmatch(\"[^/]+\")do C[#C+1]=D end;local E=s({B:sub(1,1)==\"/\"and\"/\"or\".\"},C,1)table.sort(E)return E end;function c.getDir(d)a(1,d,\"string\")local D=b.combine(d):match\"^(.*)[^/]*$\"if D==\"\"then if d:sub(1,1)==\"/\"then return\"/\"else return\".\"end else return D end end;function c.complete(F,d,G,H)end;function c.attributes(d)a(1,d,\"string\")local e=b.stat(d)if not e then return nil end;e.isDir=e.type==\"directory\"local f=b.getuser()if e.permissions[f]then e.isReadOnly=not e.permissions[f].write else e.isReadOnly=not e.worldPermissions.write end end;function c.getCapacity(d)a(1,d,\"string\")local e=b.stat(d)return e and e.capacity end;function c.isDriveRoot(d)a(1,d,\"string\")local e=b.stat(d)return e~=nil and b.combine(d)==e.mountpoint end;return c\ngps.lua/        0           0     0     644     53        `\nlocal a={}function a.locate()return nil end;return a\n\n_handles.lua/   0           0     0     644     39        `\nreturn{http={},websocket={},rednet={}}\n\nhelp.lua/       0           0     0     644     698       `\nlocal a=require\"cc.expect\"local b=require\"fs\"local c={}local d=\"/usr/share/man/*:/usr/local/share/man/*\"function c.path()return d end;function c.setPath(e)a(1,e,\"string\")d=e end;function c.lookup(f)a(1,f,\"string\")for g in d:gmatch\"[^:]+\"do local h=b.find(b.combine(g,f..\".*\"))if#h>0 then return table.unpack(h)end end;return nil end;function c.topics()local i={}for g in d:gmatch\"[^:]+\"do for j in ipairs(b.find(g))do for k,l in ipairs(b.list(j))do i[#i+1]=l:gsub(\"%..*$\",\"\")end end end;return i end;function c.completeTopic(f)a(1,f,\"string\")local i={}for g in d:gmatch\"[^:]+\"do for k,l in ipairs(b.find(b.combine(g,f..\"*\")))do i[#i+1]=l:match(f..\"([^/%.]+)%.?[^/]*$\")end end;return i end;return c\nhttp.lua/       0           0     0     644     3221      `\nlocal a=require\"cc.expect\"local b=require\"_handles\"local c=require\"_syscall\"local d=require\"craftos.os\"local e={}local function f(g)local h={}function h.read(i)return g:read(i or 1)end;function h.readLine(j)return g:read(j and\"*L\"or\"*l\")end;function h.readAll()return g:read(\"*a\")end;function h.getResponseCode()return g:responseCode()end;function h.getResponseHeaders()return g:responseHeaders()end;function h.close()return g:close()end;return h end;local function k(g,l)local h={}function h.send(m,n)return g:write(m)end;function h.receive(o)local p;if o then p=d.startTimer(o)end;while true do if g.status==\"closed\"then error('attempt to use a closed file',2)end;local q,r,s=d.pullEvent()if q=='websocket_message'and r==l then return s elseif q=='websocket_closed'and r==l and g.status==\"closed\"then return nil elseif q=='timer'and r==p then return nil end end end;function h.close()return g:close()end;return h end;function e.get(r,t,n)a(1,r,\"string\",\"table\")if type(r)==\"string\"then r={url=r,headers=t,binary=n}end;a.field(r,\"url\",\"string\")a.field(r,\"headers\",\"table\",\"nil\")a.field(r,\"binary\",\"boolean\",\"nil\")a.field(r,\"method\",\"string\",\"nil\")a.field(r,\"redirect\",\"boolean\",\"nil\")r.method=\"GET\"return e.post(r)end;function e.post(r,u,t,n)a(1,r,\"string\",\"table\")if type(r)==\"string\"then r={url=r,body=u,headers=t,binary=n}end;a.field(r,\"url\",\"string\")a.field(r,\"body\",\"string\",\"nil\")a.field(r,\"headers\",\"table\",\"nil\")a.field(r,\"binary\",\"boolean\",\"nil\")a.field(r,\"method\",\"string\",\"nil\")a.field(r,\"redirect\",\"boolean\",\"nil\")r.encoding=r.binary and\"binary\"or\"utf8\"local g,v=c.connect(r)if not g then return nil,v end;local w=f(g)b.http[g.id]={url=r.url,handle=g,craftos=w}if r.body then g:write(r.body)else g:write()end;while true do local x,y=d.pullEvent()if x==\"http_success\"and y==r.url then return w elseif x==\"http_failure\"and y==r.url then return nil,g.error,w end end end;function e.request(r,u,t,n)a(1,r,\"string\",\"table\")if type(r)==\"string\"then r={url=r,body=u,headers=t,binary=n}end;a.field(r,\"url\",\"string\")a.field(r,\"body\",\"string\",\"nil\")a.field(r,\"headers\",\"table\",\"nil\")a.field(r,\"binary\",\"boolean\",\"nil\")a.field(r,\"method\",\"string\",\"nil\")a.field(r,\"redirect\",\"boolean\",\"nil\")r.encoding=r.binary and\"binary\"or\"utf8\"local g,v=c.connect(r)if not g then d.queueEvent(\"http_failure\",r.url,v)return false,v end;local w=f(g)b.http[g.id]={url=r.url,handle=g,craftos=w}if r.body then g:write(r.body)else g:write()end;return true end;function e.checkURLAsync(r)a(1,r,\"string\")local z=c.checkuri(r)d.queueEvent(\"http_check\",r,z)end;function e.checkURL(r)a(1,r,\"string\")return c.checkuri(r)end;function e.websocketAsync(r,t)a(1,r,\"string\")a(2,t,\"table\",\"nil\")local g,v=c.connect({url=r,headers=t})if not g then d.queueEvent(\"websocket_failure\",r.url,v)return false,v end;local w=k(g,r)b.websocket[g.id]={url=r.url,handle=g,craftos=w}return true end;function e.websocket(r,t)a(1,r,\"string\")a(2,t,\"table\",\"nil\")local g,v=c.connect({url=r,headers=t})if not g then return nil,v end;local w=k(g,r)b.websocket[g.id]={url=r.url,handle=g,craftos=w}while true do local x,y=d.pullEvent()if x==\"websocket_success\"and y==r.url then return w elseif x==\"websocket_failure\"and y==r.url then return nil,g.error end end end;return e\n\ninit.lua/       0           0     0     644     3570      `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"package.loaded.os=nil;local c=setmetatable({colors=require\"colors\",colours=require\"colours\",disk=require\"disk\",fs=require\"fs\",gps=require\"gps\",help=require\"help\",http=require\"http\",keys=require\"keys\",os=require\"os\",paintutils=require\"paintutils\",parallel=require\"parallel\",peripheral=require\"peripheral\",rednet=require\"rednet\",redstone=require\"redstone\",settings=require\"settings\",shell=require\"shell\",term=require\"term\",textutils=require\"textutils\",vector=require\"vector\",window=require\"window\"},{__index=_G})c.rs=c.redstone;c._HOST=b.cchost()c._CC_DEFAULT_SETTINGS=\"\"c.sleep=c.os.sleep;function c.write(d)a(1,d,\"string\")local e=0;local f,g=c.term.getSize()local function h(i)e=e+1;if i>g-1 then c.term.scroll(1)return i else return i+1 end end;while#d>0 do local j=d:find(\"\\n\")or#d;local k=d:sub(1,j)d=d:sub(#k+1)local l=k:sub(-1)==\"\\n\"if l then k=k:sub(1,-2)end;local m,i=c.term.getCursorPos()while#k>0 do if m>f then c.term.setCursorPos(1,h(i))m,i=c.term.getCursorPos()end;local n=k:sub(1,f-m+1)c.term.write(n)k=k:sub(#n+1)m,i=c.term.getCursorPos()end;if l then c.term.setCursorPos(1,h(i))end end;return e end;function c.print(...)local o=table.pack(...)for p=1,o.n,1 do o[p]=tostring(o[p])end;return c.write(table.concat(o,\"  \")..\"\\n\")end;function c.printError(...)local q=c.term.getTextColor()c.term.setTextColor(c.colors.red)print(...)c.term.setTextColor(q)end;local r={}function c.read(s,t,u,v)a(1,s,\"string\",\"nil\")a(2,t,\"table\",\"nil\")a(3,u,\"function\",\"nil\")a(4,v,\"string\",\"nil\")if s then s=s:sub(1,1)end;local w=t or{}t={}for p=1,#w,1 do t[p]=w[p]end;local x=v or\"\"local y=x;t[#t+1]=x;local z=#t;local A=0;local B,C=c.term.getCursorPos()local f,g=c.term.getSize()local D=false;local E={}local F=0;local function G()if E[F]then c.write((\" \"):rep(#E[F]))end end;local function H(I)if I or D then if u and x~=y then E=u(x)or r;F=math.min(1,#E)end;y=x;c.term.setCursorPos(B,C)local d=x;if s then d=s:rep(#d)end;local J=c.write(d)if E[F]then local K=c.term.getTextColor()local L=c.term.getBackgroundColor()c.term.setTextColor(c.colors.white)c.term.setBackgroundColor(c.colors.gray)J=J+c.write(E[F])c.term.setTextColor(K)c.term.setBackgroundColor(L)else J=J+c.write(\" \")end;if C+J>g then C=C-(C+J-g)end end;local m,i=B,C;m=m+#x-A;while m>f do m=m-f;i=i+1 end;c.term.setCursorPos(m,i)end;c.term.setCursorBlink(true)while true do H()local M,N=c.os.pullEvent()if M==\"char\"then D=true;G()if A==0 then x=x..N elseif A==#x then x=N..x else x=x:sub(0,-A-1)..N..x:sub(-A)end elseif M==\"paste\"then D=true;G()if A==0 then x=x..N elseif A==#x then x=N..x else x=x:sub(0,-A-1)..N..x:sub(-A+#id-1)end elseif M==\"key\"then local id=c.keys.getName(N)if id==\"backspace\"and#x>0 then D=true;if A==0 then x=x:sub(1,-2)G()elseif A<#x then x=x:sub(0,-A-2)..x:sub(-A)end elseif id==\"delete\"and A>0 then D=true;if A==#x then x=x:sub(2)elseif A==1 then x=x:sub(1,-2)else x=x:sub(0,-A-1)..x:sub(-A+1)end;A=A-1 elseif id==\"up\"then if#E>1 then D=true;G()if F>1 then F=F-1 else F=#E end elseif z>1 then A=0;t[z]=x;z=z-1;x=(\" \"):rep(#x)H(true)x=t[z]D=true end elseif id==\"down\"then if#E>1 then D=true;G()if F<#E then F=F+1 else F=1 end elseif z<#t then A=0;t[z]=x;z=z+1;x=(\" \"):rep(#x)H(true)x=t[z]D=true end elseif id==\"left\"then if A<#x then G()A=A+1 end elseif id==\"right\"then if A>0 then A=A-1 elseif F>0 then D=true;x=x..E[F]end elseif id==\"tab\"then if F>0 then D=true;x=x..E[F]end elseif id==\"home\"then A=#x elseif id==\"end\"then A=0 elseif id==\"enter\"then G()c.write(\"\\n\")break end end end;c.term.setCursorBlink(false)return x end;return c\nkeys.lua/       0           0     0     644     1330      `\nlocal a={}for b=0x61,0x7A do a[string.char(b)]=b end;for b=0x81,0x99 do a[\"f\"..bit32.band(b,31)]=b end;for b=0xA0,0xA9 do a[\"numPad\"..bit32.band(b,15)]=b end;a.backspace=0x08;a.tab=0x09;a.enter=0x0A;a.space=0x20;a.apostrophe=0x27;a.comma=0x2C;a.minus=0x2D;a.period=0x2E;a.slash=0x2F;a.zero=0x30;a.one=0x31;a.two=0x32;a.three=0x33;a.four=0x34;a.five=0x35;a.six=0x36;a.seven=0x37;a.eight=0x38;a.nine=0x39;a.semicolon=0x3B;a.equals=0x3D;a.leftBracket=0x5B;a.backslash=0x5C;a.rightBracket=0x5D;a.grave=0x60;a.delete=0x7F;a.insert=0x80;a.convert=0x9A;a.noconvert=0x9B;a.kana=0x9C;a.kanji=0x9D;a.yen=0x9E;a.numPadDecimal=0x9F;a.numPadAdd=0xAA;a.numPadSubtract=0xAB;a.numPadMultiply=0xAC;a.numPadDivide=0xAD;a.numPadEqual=0xAE;a.numPadEnter=0xAF;a.leftCtrl=0xB0;a.rightCtrl=0xB1;a.leftAlt=0xB2;a.rightAlt=0xB3;a.leftShift=0xB4;a.rightShift=0xB5;a.leftSuper=0xB6;a.rightSuper=0xB7;a.capsLock=0xB8;a.numLock=0xB9;a.scrollLock=0xBA;a.printScreen=0xBB;a.pause=0xBC;a.menu=0xBD;a.stop=0xBE;a.ax=0xBF;a.up=0xC0;a.down=0xC1;a.left=0xC2;a.right=0xC3;a.pageUp=0xC4;a.pageDown=0xC5;a.home=0xC6;a[\"end\"]=0xC7;a.circumflex=0xC8;a.at=0xC9;a.colon=0xCA;a.underscore=0xCB;local c={}for d,e in pairs(a)do c[e]=d end;function a.getName(f)if type(f)~=\"number\"then error(\"bad argument #1 (expected number, got \"..type(f)..\")\",2)end;return c[f]end;return a\nos.lua/         0           0     0     644     4451      `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"local c=require\"_handles\"local d=os;local os={date=d.date}function os.loadAPI(e)a(1,e,\"string\")local f=setmetatable({},{__index=_G})local g=loadfile(e,nil,f)if not g then return false end;if not pcall(g)then return false end;setmetatable(f,nil)_G[e:match(\"([^/]+)%.lua$\")or e:match(\"[^/]+\")]=f;return true end;function os.unloadAPI(h)_G[h]=nil end;function os.pullEvent(i)local j=table.pack(os.pullEventRaw(i))if j[1]==\"terminate\"then error(\"Terminated\",2)end;return table.unpack(j,1,j.n)end;function os.pullEventRaw(i)local j;repeat j=table.pack(coroutine.yield())if j.n==2 and type(j[1])==\"string\"and type(j[2])==\"table\"then local k,l=j[1],j[2]if k==\"alarm\"or k==\"timer\"then j={k,l.id,n=2}elseif k==\"char\"then j={\"char\",l.character,n=2}elseif k==\"disk\"or k==\"disk_eject\"or k==\"speaker_audio_empty\"or k==\"monitor_resize\"or k==\"device_added\"or k==\"device_removed\"then j={k,l.device,n=2}elseif k==\"key\"then j={\"key\",l.keycode,l.isRepeat,n=3}elseif k==\"key_up\"then j={\"key_up\",l.keycode,n=2}elseif k==\"modem_message\"then j={\"modem_message\",l.device,l.channel,l.replyChannel,l.message,l.distance,n=6}elseif k==\"mouse_click\"or k==\"mouse_drag\"or k==\"mouse_up\"or k==\"mouse_move\"then j={k,l.button,l.x,l.y,n=4}elseif k==\"mouse_scroll\"then j={\"mouse_scroll\",l.direction,l.x,l.y,n=4}elseif k==\"paste\"then j={\"paste\",l.text,n=2}elseif k==\"redstone\"or k==\"term_resize\"or k==\"turtle_inventory\"or k==\"terminate\"then j={k,n=1}elseif k==\"craftos_event\"then j=l elseif k==\"handle_status_change\"then if c.http[l.id]then if l.status==\"open\"then j={\"http_success\",c.http[l.id].url,c.http[l.id].craftos,n=3}c.http[l.id]=nil elseif l.status==\"error\"then j={\"http_failure\",c.http[l.id].url,c.http[l.id].handle.error,c.http[l.id].craftos,n=4}c.http[l.id]=nil end elseif c.websocket[l.id]then if l.status==\"open\"then j={\"websocket_success\",c.websocket[l.id].url,c.websocket[l.id].craftos,n=3}elseif l.status==\"error\"then j={\"websocket_failure\",c.websocket[l.id].url,c.websocket[l.id].error,n=3}elseif l.status==\"closed\"then j={\"websocket_closed\",c.websocket[l.id].url,n=2}c.websocket[l.id]=nil end end elseif k==\"handle_data_ready\"then if c.websocket[l.id]then j={\"websocket_message\",c.websocket[l.id].url,c.websocket[l.id].handle:read(\"*a\"),true,n=4}elseif c.rednet[l.id]then j={\"rednet_message\",c.rednet[l.id].id,c.rednet[l.id].handle:read(\"*a\"),n=3}end else j={\"phoenix_event\",{event=k,param=l},n=2}end end until i==nil or j[1]==i or j[1]==\"terminate\"return table.unpack(j,1,j.n)end;function os.sleep(m)a(1,m,\"number\")local n=b.timer(m)repeat local j,l=os.pullEvent()until j==\"timer\"and l==n end;function os.version()return\"Phoenix \"..b.version()end;function os.run(f,e,...)a(1,f,\"table\")a(2,e,\"string\")setmetatable(f,{__index=_ENV})local g,o=loadfile(e,nil,f)if not g then return false end;local p,q=pcall(g,...)return p end;function os.queueEvent(h,...)a(1,h,\"string\")b.queueEvent(\"craftos_event\",table.pack(h,...))end;function os.startTimer(m)a(1,m,\"number\")return b.timer(m)end;function os.cancelTimer(r)a(1,r,\"number\")return b.cancel(r)end;os.cancelAlarm=os.cancelTimer;function os.setAlarm(m)a(1,m,\"number\")return b.alarm(m)end;function os.shutdown()b.devcall(\"/\",\"shutdown\")end;function os.reboot()b.devcall(\"/\",\"reboot\")end;function os.getComputerID()return b.devinfo(\"/\").metadata.id end;os.computerID=os.getComputerID;function os.getComputerLabel()return b.devcall(\"/\",\"getLabel\")end;os.computerLabel=os.getComputerLabel;function os.setComputerLabel(s)a(1,s,\"string\")return b.devcall(\"/\",\"setLabel\",s)end;function os.clock()return b.uptime()end;function os.time(t)a(1,t,\"string\",\"table\",\"nil\")if type(t)==\"table\"then return d.time(t)end;local u;if t==\"utc\"then u=os.date(\"!*t\")elseif t==\"local\"then u=os.date(\"*t\")elseif t==\"ingame\"or u==nil then u=os.date(\"?*t\")else error(\"Unsupported operation\",2)end;return u.hour+u.min/60+u.sec/3600 end;function os.day(t)a(1,t,\"string\",\"nil\")local u;if t==\"utc\"then u=os.date(\"!*t\")elseif t==\"local\"then u=os.date(\"*t\")elseif t==\"ingame\"or u==nil then u=os.date(\"?*t\")else error(\"Unsupported operation\",2)end;return math.floor((u.year-1970)*365.24)+u.yday end;function os.epoch(t)a(1,t,\"string\",\"nil\")if t==\"utc\"then return d.time()*1000 elseif t==\"local\"then return(d.time()+d.time(os.date(\"*t\"))-d.time(os.date(\"!*t\")))*1000 elseif t==\"ingame\"then return d.time\"ingame\"*1000 elseif t==\"nano\"then return d.time\"nano\"else error(\"Unsupported operation\",2)end end;return os\n\npaintutils.lua/ 0           0     0     644     2739      `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"local c=require\"term\"local d={}function d.drawPixel(e,f,g)a(1,e,\"number\")a(2,f,\"number\")local h,i=c.getCursorPos()local j=c.getBackgroundColor()c.setCursorPos(e,f)if g then c.setBackgroundColor(g)end;c.write(\" \")c.setCursorPos(h,i)c.setBackgroundColor(j)end;local function k(l,m,n,o,p)if math.abs(p-n)<math.abs(o-m)then if m>o then m,n,o,p=o,p,m,n end;local q,r,s=o-m,p-n,1;if r<0 then s,r=-1,-r end;local t,f=2*r-q,n;if s<0 then f=p;for e=o,m,-1 do l(e,f)if t>0 then f=f+1;t=t+2*(r-q)else t=t+2*r end end else for e=m,o do l(e,f)if t>0 then f=f+1;t=t+2*(r-q)else t=t+2*r end end end else if n>p then m,n,o,p=o,p,m,n end;local q,r,u=o-m,p-n,1;if q<0 then u,q=-1,-q end;local t,e=2*q-r,m;for f=n,p do l(e,f)if t>0 then e=e+u;t=t+2*(q-r)else t=t+2*q end end end end;function d.drawLine(m,n,o,p,g)a(1,m,\"number\")a(2,n,\"number\")a(3,o,\"number\")a(4,p,\"number\")a(5,g,\"number\")if n==p then local v=math.abs(o-m)+1;local w,x=c.getBackgroundColor(),c.getTextColor()local h,i=c.getCursorPos()local y,z=(\"%x\"):format(x),(\"%x\"):format(g)c.setCursorPos(m,n)c.blit((\" \"):rep(v),y:rep(v),z:rep(v))c.setCursorPos(h,i)c.setBackgroundColor(w)return end;local l,A;local j=c.getBackgroundColor()local h,i=c.getCursorPos()c.setBackgroundColor(g)l,A=function(e,f)c.setCursorPos(e,f)c.write(\" \")end,function()c.setBackgroundColor(j)c.setCursorPos(h,i)end;k(l,m,n,o,p)A()end;function d.drawBox(e,f,v,B,g)a(1,e,\"number\")a(2,f,\"number\")a(3,v,\"number\")a(4,B,\"number\")a(5,g,\"number\")local w,x=c.getBackgroundColor(),c.getTextColor()local h,i=c.getCursorPos()local y,z=(\"%x\"):format(x),(\"%x\"):format(g)c.setCursorPos(e,f)c.blit((\" \"):rep(v),y:rep(v),z:rep(v))c.setCursorPos(e,f+B-1)c.blit((\" \"):rep(v),y:rep(v),z:rep(v))for C=f+1,f+B-2 do c.setCursorPos(e,C)c.blit(\" \",y,z)c.setCursorPos(e+v-1,C)c.blit(\" \",y,z)end;c.setBackgroundColor(w)c.setCursorPos(h,i)end;function d.drawFilledBox(e,f,v,B,g)a(1,e,\"number\")a(2,f,\"number\")a(3,v,\"number\")a(4,B,\"number\")a(5,g,\"number\")local w,x=c.getBackgroundColor(),c.getTextColor()local h,i=c.getCursorPos()local D,y,z=(\" \"):rep(v),(\"%x\"):format(x):rep(v),(\"%x\"):format(g):rep(v)for C=f,f+B-1 do c.setCursorPos(e,C)c.blit(D,y,z)end;c.setBackgroundColor(w)c.setCursorPos(h,i)end;function d.drawImage(e,f,E)a(1,e,\"number\")a(2,f,\"number\")a(3,E,\"table\")for F,G in ipairs(E)do c.setCursorPos(e,f+F-1)for H,j in ipairs(G)do c.setBackgroundColor(j)c.write(\" \")end end end;function d.parseImage(E)a(1,E,\"string\")local I={}for G in E:gmatch\"[^\\n]+\"do local J={}for j in G:gmatch\".\"do J[#J+1]=tonumber(j,16)end;I[#I+1]=J end;return I end;function d.loadImage(K)a(1,K,\"string\")local L=b.open(K,\"r\")if not L then return nil end;local M=L.readAll()L.close()return d.parseImage(M)end;return d\n\nparallel.lua/   0           0     0     644     837       `\nlocal a=require\"craftos.os\"local b={}local function c(d,e)local f={}for g,h in ipairs(d)do if type(h)~=\"function\"then error(\"bad argument #\"..g..\" (expected function, got \"..type(h)..\")\",2)end;f[g]={coro=coroutine.create(h),filter=nil,pos=g}end;local i={n=0}while#f>=e do local g=1;while g<#f do if f[g].filter==nil or f[g].filter==i[1]then local j=i;repeat local k=table.pack(f[g].coro(table.unpack(j,1,j.n)))if not k[1]then error(k[2],0)end;if k[2]==\"syscall\"then j=table.pack(coroutine.yield(table.unpack(k,1,k.n)))else f[g].filter=k[2]end until k[2]~=\"syscall\"if f[g]:status()==\"dead\"then local l=f[g].pos;table.remove(f,g)if#f<e then return l end;g=g-1 end end;g=g+1 end;i=table.pack(a.pullEvent())end;return 1 end;function b.waitForAny(...)return c({...},select(\"#\",...))end;function b.waitForAll(...)return c({...},1)end;return b\n\nperipheral.lua/ 0           0     0     644     2243      `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"local c={}function c.getNames()return b.devchildren(\"/\")end;function c.isPresent(d)a(1,d,\"string\")return b.devinfo(d)~=nil end;function c.getType(e)a(1,e,\"string\",\"table\")if type(e)==\"string\"then local f=b.devinfo(e)if not f then return nil end;local g={}for h in pairs(f.types)do g[#g+1]=h end;return table.unpack(g)else local i=getmetatable(e)if not i or i.__name~=\"peripheral\"or type(i.types)~=\"table\"then error(\"bad argument #1 (table is not a peripheral)\",2)end;return table.unpack(i.types)end end;function c.hasType(e,j)a(1,e,\"string\",\"table\")a(2,j,\"string\")if type(c)==\"string\"then local f=b.devinfo(e)if not f then return nil end;return f.types[j]~=nil else local i=getmetatable(e)if not i or i.__name~=\"peripheral\"or type(i.types)~=\"table\"then error(\"bad argument #1 (table is not a peripheral)\",2)end;return i.types[j]~=nil end end;function c.getMethods(d)a(1,d,\"string\")local k,g=pcall(b.devmethods,d)return k and g or nil end;function c.getName(e)a(1,e,\"table\")local i=getmetatable(e)if not i or i.__name~=\"peripheral\"or type(i.name)~=\"string\"then error(\"bad argument #1 (table is not a peripheral)\",2)end;return i.name end;function c.call(d,l,...)a(1,d,\"string\")a(2,l,\"string\")return b.devcall(d,l,...)end;function c.wrap(d)a(1,d,\"string\")local f=b.devinfo(d)if not f then return nil end;local m,n=b.devmethods(d),b.devproperties(d)for o,p in ipairs(n)do n[p]=true end;for h in pairs(f.types)do if type(h)==\"string\"then f.types[#f.types+1]=h end end;local g={}for o,p in ipairs(m)do g[p]=function(self,...)return b.devcall(d,p,...)end end;return setmetatable(g,{__name=\"peripheral\",name=d,type=f.types[1],types=f.types,__index=function(self,q)if type(q)==\"string\"and n[q]then return b.devcall(d,\"get\"..q:gsub(\"^.\",string.upper))end end,__newindex=function(self,q,r)if type(q)==\"string\"and n[q]and m[\"set\"..q:gsub(\"^.\",string.upper)]then return b.devcall(d,\"set\"..q:gsub(\"^.\",string.upper),r)end end,__tostring=function(self)return\"wrapped device: \"..(f.displayName or f.uuid)end})end;function c.find(j,s)a(1,j,\"string\")a(2,s,\"function\",\"nil\")local g={}for o,p in ipairs{b.devfind(j)}do local t=c.wrap(p)if not s or s(p,t)then g[#g+1]=t end end;return table.unpack(g)end;return c\n\nrednet.lua/     0           0     0     644     19        `\nlocal a={}return a\n\nredstone.lua/   0           0     0     644     1339      `\nlocal a=require\"_syscall\"local b=require\"cc.expect\"local c={}function c.getSides()return a.devchildren(\"/redstone\")end;function c.getInput(d)b(1,d,\"string\")return a.devcall(\"/redstone/\"..d,\"getInput\")>0 end;function c.getOutput(d)b(1,d,\"string\")return a.devcall(\"/redstone/\"..d,\"getOutput\")>0 end;function c.setOutput(d,e)b(1,d,\"string\")b(2,e,\"boolean\")return a.devcall(\"/redstone/\"..d,\"setOutput\",e and 15 or 0)end;function c.getAnalogInput(d)b(1,d,\"string\")return a.devcall(\"/redstone/\"..d,\"getInput\")end;function c.getAnalogOutput(d)b(1,d,\"string\")return a.devcall(\"/redstone/\"..d,\"getOutput\")end;function c.setAnalogOutput(d,e)b(1,d,\"string\")b(2,e,\"number\")b.range(e,0,15)return a.devcall(\"/redstone/\"..d,\"setOutput\",e)end;function c.getBundledInput(d)b(1,d,\"string\")return a.devcall(\"/redstone/\"..d,\"getBundledInput\")end;function c.getBundledOutput(d)b(1,d,\"string\")return a.devcall(\"/redstone/\"..d,\"getBundledOutput\")end;function c.setBundledOutput(d,e)b(1,d,\"string\")b(2,e,\"number\")b.range(e,0,65535)return a.devcall(\"/redstone/\"..d,\"setBundledOutput\",e)end;function c.testBundledInput(d,f)b(1,d,\"string\")b(2,f,\"number\")b.range(f,0,65535)return bit32.band(a.devcall(\"/redstone/\"..d,\"getBundledInput\"),f)==f end;c.getAnalogueInput=c.getAnalogInput;c.getAnalogueOutput=c.getAnalogOutput;c.setAnalogueOutput=c.setAnalogOutput;return c\n\nsettings.lua/   0           0     0     644     3872      `\nlocal a=require\"cc.expect\"local b=require\"fs\"local c=require\"textutils\"local d={}local e={}local f={}function d.get(g,h)a(1,g,\"string\")if e[g]~=nil then return e[g]elseif h~=nil then return h else return f[g]and f[g].default end end;function d.set(g,i)a(1,g,\"string\")if i==nil then error(\"bad argument #2 (expected value, got nil)\",2)end;if f[g]and f[g].type then a(2,i,f[g].value)end;e[g]=i end;function d.unset(g)a(1,g,\"string\")e[g]=nil end;function d.define(g,j)a(1,g,\"string\")if j~=nil then a(2,j,\"table\")a.field(j,\"description\",\"string\",\"nil\")a.field(j,\"type\",\"string\",\"nil\")if j.type then a.field(j,\"default\",j.type,\"nil\")end end;f[g]=j or{}end;function d.undefine(g)a(1,g,\"string\")f[g]=nil end;function d.getDetails(g)a(1,g,\"string\")local k=f[g]if k then return{description=k.description,default=k.default,type=k.type,value=e[g]}else return{value=e[g]}end end;function d.clear()e={}end;function d.getNames()local l={}for m in pairs(f)do l[#l+1]=m end;table.sort(l)return l end;function d.load(n)n=a(1,n,\"string\",\"nil\")or\"/etc/settings\"if not b.exists(n)then return false end;local o=b.open(n,\"r\")if not o then return false end;local p,q=pcall(c.unserialize,o.readAll())o.close()if not p or type(q)~=\"table\"then return false end;for m,r in pairs(q)do e[m]=r end;return true end;function d.save(n)n=a(1,n,\"string\",\"nil\")or\"/etc/settings\"local o=b.open(n,\"r\")if not o then return false end;o.write(c.serialize(e))o.close()return true end;d.define(\"shell.allow_startup\",{default=true,description=\"Run startup files when the computer turns on.\",type=\"boolean\"})d.define(\"shell.allow_disk_startup\",{default=true,description=\"Run startup files from disk drives when the computer turns on.\",type=\"boolean\"})d.define(\"shell.autocomplete\",{default=false,description=\"Autocomplete program and arguments in the shell.\",type=\"boolean\"})d.define(\"edit.autocomplete\",{default=false,description=\"Autocomplete API and function names in the editor.\",type=\"boolean\"})d.define(\"lua.autocomplete\",{default=false,description=\"Autocomplete API and function names in the Lua REPL.\",type=\"boolean\"})d.define(\"edit.default_extension\",{default=\"lua\",description=[[The file extension the editor will use if none is given. Set to \"\" to disable.]],type=\"string\"})d.define(\"paint.default_extension\",{default=\"nfp\",description=[[The file extension the paint program will use if none is given. Set to \"\" to disable.]],type=\"string\"})d.define(\"list.show_hidden\",{default=false,description=[[Show hidden files (those starting with \".\" in the Lua REPL).]],type=\"boolean\"})d.define(\"motd.enable\",{default=true,description=\"Display a random message when the computer starts up.\",type=\"boolean\"})d.define(\"motd.path\",{default=\"/rom/motd.txt:/motd.txt\",description=[[The path to load random messages from. Should be a colon (\":\") separated string of file paths.]],type=\"string\"})d.define(\"lua.warn_against_use_of_local\",{default=true,description=[[Print a message when input in the Lua REPL starts with the word 'local'. Local variables defined in the Lua REPL are be inaccessable on the next input.]],type=\"boolean\"})d.define(\"lua.function_args\",{default=true,description=\"Show function arguments when printing functions.\",type=\"boolean\"})d.define(\"lua.function_source\",{default=false,description=\"Show where a function was defined when printing functions.\",type=\"boolean\"})d.define(\"bios.strict_globals\",{default=false,description=\"Prevents assigning variables into a program's environment. Make sure you use the local keyword or assign to _G explicitly.\",type=\"boolean\"})d.define(\"shell.autocomplete_hidden\",{default=false,description=[[Autocomplete hidden files and folders (those starting with \".\").]],type=\"boolean\"})d.define(\"bios.use_multishell\",{default=true,description=[[Allow running multiple programs at once, through the use of the \"fg\" and \"bg\" programs.]],type=\"boolean\"})d.load()return d\nshell.lua/      0           0     0     644     1632      `\nlocal a=require\"_syscall\"local b=require\"cc.expect\"local c=require\"craftos.os\"local d={}local e=a.getenv().PATH or\"/bin:/sbin:/usr/bin\"local f={}local g={}function d.dir()return a.getcwd()end;function d.setDir(h)b(1,h,\"string\")return a.chdir(h)end;function d.path()return e end;function d.setPath(i)b(1,i,\"string\")e=i end;function d.getRunningProgram()return a.getname()end;function d.resolve(e)b(1,e,\"string\")if e:sub(1,1)==\"/\"then return e end;return a.combine(a.getcwd(),e)end;function d.run(...)local j=\"\"for k,l in ipairs{...}do j=j..(j==\"\"and\"\"or\" \")..l end;local m={}for n in j:gmatch\"%S+\"do m[#m+1]=n end;return d.execute(table.unpack(m))end;function d.execute(...)local o=setmetatable({shell=d},{__index=_ENV})local p,q=loadfile(e,nil,o)if not p then return false end;local r,s=pcall(p,...)return r end;function d.aliases()local t={}for u,l in pairs(f)do t[u]=l end;return t end;function d.setAlias(v,w)b(1,v,\"string\")b(2,w,\"string\")f[v]=w end;function d.clearAlias(v)b(1,v,\"string\")f[v]=nil end;function d.getCompletionInfo()return g end;function d.setCompletionFunction(w,p)end;function d.complete(x)return{}end;function d.completeProgram(w)return{}end;function d.resolveProgram(v)for y in e:gmatch\"[^:]+\"do local r,z=pcall(a.list,y)if r then for A in ipairs(z)do if v==A or v..\".lua\"==A then return a.combine(y,A)end end end end;return nil end;function d.programs(B)b(1,B,\"boolean\",\"nil\")local t={}for y in e:gmatch\"[^:]+\"do local r,z=pcall(a.list,y)if r then for A in ipairs(z)do if a.stat(a.combine(y,A)).type~=\"directory\"and(B or not A:match\"^%.\")then t[#t+1]=A:gsub(\"%.lua$\",\"\")end end end end;return t end;return d\n_syscall.lua/   0           0     0     644     217       `\nreturn setmetatable({},{__index=function(self,a)return function(...)local b=table.pack(coroutine.yield(\"syscall\",a,...))if b[1]then return table.unpack(b,2,b.n)else error(b[2],2)end end end,__newindex=function()end})\n\nterm.lua/       0           0     0     644     525       `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"local c={}local d=assert(b.openterm())local e=d;for f in pairs(d)do c[f]=function(...)return e[f](...)end end;function c.redirect(g)a(1,g,\"table\")if g==c then error(\"term is not a recommended redirect target, try term.current() instead\",2)end;for f in pairs(d)do if type(g[f])~=\"function\"then g[f]=function()error(\"Redirect object is missing method \"..f..\".\",2)end end end;local h=e;e=g;return h end;function c.current()return e end;function c.native()return d end;return c\n\ntextutils.lua/  0           0     0     644     9022      `\nlocal a=require\"cc.expect\"local b=require\"_syscall\"local c=require\"craftos.os\"local d=require\"term\"local e={}function e.slowWrite(f,g)a(1,f,\"string\")g=a(2,g,\"number\",\"nil\")or 20;local h,i=d.getCursorPos()local j,k=d.getSize()for l in f:gmatch\".\"do d.write(l)h=h+1;if l=='\\n'or h>j then h,i=1,i+1;if i>k then d.scroll(1)i=i-1 end;d.setCursorPos(h,i)end;local m=b.timer(1/g)repeat local n,o=c.pullEvent()until n==\"timer\"and o==m end end;function e.slowPrint(f,g)return e.slowWrite(f..\"\\n\",g)end;function e.formatTime(p,q)a(1,p,\"number\")a(2,q,\"boolean\",\"nil\")local r,s=math.floor(p),math.floor(p%1*60)return c.date(q and\"%H:%M\"or\"%I:%M %p\",c.time{year=1970,month=1,day=1,hour=r,min=s})end;function e.pagedPrint(f,t)error(\"Not implemented\")end;local function u(v,...)local t={}local w={}local x={}for y,z in ipairs{...}do local A=type(z)if A==\"number\"then x[#t+1]=z elseif A==\"table\"then t[#t+1]=z;for B=1,#z do z[B]=tostring(z[B])w[B]=math.max(w[B]or 0,#z[B]+1)end else error((\"bad argument #%d (expected table or number, got %s)\"):format(y,A),3)end end;local h,i=d.getCursorPos()local j,k=d.getSize()local function C()h,i=1,i+1;if i>k then d.scroll(1)i=i-1;if v then d.setCursorPos(h,i)d.write(\"Press any key to continue\")c.pullEvent(\"key\")d.clearLine()end end;d.setCursorPos(h,i)end;for y,z in ipairs(t)do if x[y]then d.setTextColor(x[y])end;for D,E in ipairs(z)do if h+w[y]>j then C()end;d.write(E..(\" \"):rep(w[y]-#E))h=h+w[y]end;C()end end;function e.tabulate(...)return u(false,...)end;function e.pagedTabulate(...)return u(true,...)end;local function F(G)return setmetatable({},{__newindex=function()error(\"attempt to modify read-only table\")end,__tostring=function()return G end})end;e.json_null=F\"null\"e.empty_json_array=F\"[]\"local H;local I={[\"\\\\\"]=\"\\\\\",[\"\\\"\"]=\"\\\"\",[\"\\b\"]=\"b\",[\"\\f\"]=\"f\",[\"\\n\"]=\"n\",[\"\\r\"]=\"r\",[\"\\t\"]=\"t\"}local J={[\"/\"]=\"/\"}for B,z in pairs(I)do J[z]=B end;local function K(l)return\"\\\\\"..(I[l]or string.format(\"u%04x\",l:byte()))end;local function L(M)return\"null\"end;local function N(M,O)local P={}O=O or{}if M==e.json_null then return\"null\"elseif M==e.empty_json_array then return\"[]\"end;if O[M]then error(\"circular reference\")end;O[M]=true;if rawget(M,1)~=nil or next(M)==nil then local Q=0;for B in pairs(M)do if type(B)~=\"number\"then error(\"invalid table: mixed or invalid key types\")end;Q=Q+1 end;if Q~=#M then error(\"invalid table: sparse array\")end;for y,z in ipairs(M)do table.insert(P,H(z,O))end;O[M]=nil;return\"[\"..table.concat(P,\",\")..\"]\"else for B,z in pairs(M)do if type(B)~=\"string\"then error(\"invalid table: mixed or invalid key types\")end;table.insert(P,H(B,O)..\":\"..H(z,O))end;O[M]=nil;return\"{\"..table.concat(P,\",\")..\"}\"end end;local function R(M)return'\"'..M:gsub('[%z\\1-\\31\\\\\"]',K)..'\"'end;local function S(M)if M~=M or M<=-math.huge or M>=math.huge then error(\"unexpected number value '\"..tostring(M)..\"'\")end;return string.format(\"%.14g\",M)end;local T={[\"nil\"]=L,[\"table\"]=N,[\"string\"]=R,[\"number\"]=S,[\"boolean\"]=tostring}H=function(M,O)local U=type(M)local V=T[U]if V then return V(M,O)end;error(\"unexpected type '\"..U..\"'\")end;function e.serializeJSON(M,W)a(2,W,\"boolean\",\"nil\")return H(M)end;local X;local function Y(...)local P={}for y=1,select(\"#\",...)do P[select(y,...)]=true end;return P end;local Z=Y(\" \",\"\\t\",\"\\r\",\"\\n\")local _=Y(\" \",\"\\t\",\"\\r\",\"\\n\",\"]\",\"}\",\",\")local a0=Y(\"\\\\\",\"/\",'\"',\"b\",\"f\",\"n\",\"r\",\"t\",\"u\")local a1=Y(\"true\",\"false\",\"null\")local a2={[\"true\"]=true,[\"false\"]=false,[\"null\"]=nil}local function a3(G,a4,a5,a6)for y=a4,#G do if a5[G:sub(y,y)]~=a6 then return y end end;return#G+1 end;local function a7(G,a4,a8)local a9=1;local aa=1;for y=1,a4-1 do aa=aa+1;if G:sub(y,y)==\"\\n\"then a9=a9+1;aa=1 end end;error(string.format(\"%s at line %d col %d\",a8,a9,aa))end;local function ab(Q)local V=math.floor;if Q<=0x7f then return string.char(Q)elseif Q<=0x7ff then return string.char(V(Q/64)+192,Q%64+128)elseif Q<=0xffff then return string.char(V(Q/4096)+224,V(Q%4096/64)+128,Q%64+128)elseif Q<=0x10ffff then return string.char(V(Q/262144)+240,V(Q%262144/4096)+128,V(Q%4096/64)+128,Q%64+128)end;error(string.format(\"invalid unicode codepoint '%x'\",Q))end;local function ac(E)local ad=tonumber(E:sub(1,4),16)local ae=tonumber(E:sub(7,10),16)if ae then return ab((ad-0xd800)*0x400+ae-0xdc00+0x10000)else return ab(ad)end end;local function af(G,y)local P=\"\"local ag=y+1;local B=ag;while ag<=#G do local ah=G:byte(ag)if ah<32 then a7(G,ag,\"control character in string\")elseif ah==92 then P=P..G:sub(B,ag-1)ag=ag+1;local l=G:sub(ag,ag)if l==\"u\"then local ai=G:match(\"^[dD][89aAbB]%x%x\\\\u%x%x%x%x\",ag+1)or G:match(\"^%x%x%x%x\",ag+1)or a7(G,ag-1,\"invalid unicode escape in string\")P=P..ac(ai)ag=ag+#ai else if not a0[l]then a7(G,ag-1,\"invalid escape char '\"..l..\"' in string\")end;P=P..J[l]end;B=ag+1 elseif ah==34 then P=P..G:sub(B,ag-1)return P,ag+1 end;ag=ag+1 end;a7(G,y,\"expected closing quote for string\")end;local function aj(G,y,ak)local ah=a3(G,y,_)local E=G:sub(y,ah-1)if ak.nbt_style then E=E:gsub(\"[bBsSlLfFdD]%s*$\",\"\")end;local Q=tonumber(E)if not Q then a7(G,y,\"invalid number '\"..E..\"'\")end;return Q,ah end;local function al(G,y,ak)local ah=a3(G,y,_)local am=G:sub(y,ah-1)if not a1[am]then a7(G,y,\"invalid literal '\"..am..\"'\")end;if am==\"null\"and ak.parse_null then return e.json_null,ah end;return a2[am],ah end;local function an(G,y,ak)local P={}local Q=1;y=y+1;while 1 do local ah;y=a3(G,y,Z,true)if G:sub(y,y)==\"]\"then y=y+1;break elseif Q==1 and ak.nbt_style and G:sub(y,y):match(\"[BIL]\")then local ao=y;y=a3(G,y,Z,true)if G:sub(y,y)==\";\"then y=a3(G,y,Z,true)if G:sub(y,y)==\"]\"then y=y+1;break end else y=ao end end;ah,y=X(G,y,ak)P[Q]=ah;Q=Q+1;y=a3(G,y,Z,true)local ap=G:sub(y,y)y=y+1;if ap==\"]\"then break end;if ap~=\",\"then a7(G,y,\"expected ']' or ','\")end end;if#P==0 and ak.parse_empty_array~=false then return e.empty_json_array,y end;return P,y end;local function aq(G,y,ak)local P={}y=y+1;while 1 do local ar,M;y=a3(G,y,Z,true)if G:sub(y,y)==\"}\"then y=y+1;break end;if G:sub(y,y)=='\"'then ar,y=X(G,y,ak)elseif ak.nbt_style then local ao=y;ar,y=G:match(\"([A-Za-z0-9_%-%.%+]+)()\",y)if not ar then a7(G,ao,\"expected key\")end else a7(G,y,\"expected string for key\")end;y=a3(G,y,Z,true)if G:sub(y,y)~=\":\"then a7(G,y,\"expected ':' after key\")end;y=a3(G,y+1,Z,true)M,y=X(G,y,ak)P[ar]=M;y=a3(G,y,Z,true)local ap=G:sub(y,y)y=y+1;if ap==\"}\"then break end;if ap~=\",\"then a7(G,y,\"expected '}' or ','\")end end;return P,y end;local as={['\"']=af,[\"0\"]=aj,[\"1\"]=aj,[\"2\"]=aj,[\"3\"]=aj,[\"4\"]=aj,[\"5\"]=aj,[\"6\"]=aj,[\"7\"]=aj,[\"8\"]=aj,[\"9\"]=aj,[\"-\"]=aj,[\"t\"]=al,[\"f\"]=al,[\"n\"]=al,[\"[\"]=an,[\"{\"]=aq}X=function(G,a4,ak)local ap=G:sub(a4,a4)local V=as[ap]if V then return V(G,a4,ak)end;a7(G,a4,\"unexpected character '\"..ap..\"'\")end;function e.unserializeJSON(G,ak)a(1,G,\"string\")ak=a(2,ak,\"table\",\"nil\")or{}a.field(ak,\"nbt_style\",\"boolean\",\"nil\")a.field(ak,\"parse_null\",\"boolean\",\"nil\")a.field(ak,\"parse_empty_array\",\"boolean\",\"nil\")local P,a4=X(G,a3(G,1,Z,true),ak)a4=a3(G,a4,Z,true)if a4<=#G then a7(G,a4,\"trailing garbage\")end;return P end;local at={[\"and\"]=true,[\"break\"]=true,[\"do\"]=true,[\"else\"]=true,[\"elseif\"]=true,[\"end\"]=true,[\"false\"]=true,[\"for\"]=true,[\"function\"]=true,[\"goto\"]=true,[\"if\"]=true,[\"in\"]=true,[\"local\"]=true,[\"nil\"]=true,[\"not\"]=true,[\"or\"]=true,[\"repeat\"]=true,[\"return\"]=true,[\"then\"]=true,[\"true\"]=true,[\"until\"]=true,[\"while\"]=true}local function au(M,O,ak,av)if O[M]then error(\"Cannot serialize recursive value\",0)end;local A=type(M)if A==\"table\"then if not next(M)then return\"{}\"end;O[M]=true;local P=ak.compact and\"{\"or\"{\\n\"local aw={}for y,z in ipairs(M)do if not ak.compact then P=P..(\"    \"):rep(av)end;aw[y]=true;P=P..au(z,O,ak,av+1)..(ak.compact and\",\"or\",\\n\")end;for B,z in pairs(M)do if not aw[B]then if not ak.compact then P=P..(\"    \"):rep(av)end;if type(B)==\"string\"and B:match\"^[A-Za-z_][A-Za-z0-9_]*$\"and not at[B]then P=P..B else P=P..\"[\"..au(B,O,ak,av+1)..\"]\"end;P=P..(ak.compact and\"=\"or\" = \")..au(z,O,ak,av+1)..(ak.compact and\",\"or\",\\n\")end end;if ak.compact then P=P:gsub(\",$\",\"\")else P=P..(\"    \"):rep(av-1)end;if not ak.allow_repetitons then O[M]=nil end;return P..\"}\"elseif A==\"nil\"or A==\"number\"or A==\"boolean\"or A==\"string\"then return(\"%q\"):format(M):gsub(\"\\\\\\n\",\"\\\\n\"):gsub(\"\\\\?[%z\\1-\\31\\127-\\255]\",function(l)return(\"\\\\%03d\"):format(string.byte(l))end)else error(\"Cannot serialize type \"..A,0)end end;function e.serialize(M,ak)ak=a(2,ak,\"table\",\"nil\")or{}a.field(ak,\"compact\",\"boolean\",\"nil\")a.field(ak,\"allow_repetitions\",\"boolean\",\"nil\")return au(M,{},ak,1)end;function e.unserialize(E)a(1,E,\"string\")return assert(load(\"return \"..E,\"=unserialize\",\"t\",{}))()end;function e.urlEncode(G)a(1,G,\"string\")return G:gsub(\"\\n\",\"\\r\\n\"):gsub(\"([^A-Za-z0-9 %-%_%.])\",function(l)local Q=l:byte()if Q<128 then return(\"%%%02X\"):format(Q)else return(\"%%%02X%%%02X\"):format(bit32.rshift(Q,6)+0xC0,bit32.band(Q,0x3F)+0x80)end end):gsub(\" \",\"+\")end;function e.complete(ax,ay)error(\"Not implemented\")end;e.serialise=e.serialize;e.unserialise=e.unserialize;e.serialiseJSON=e.serializeJSON;e.unserialiseJSON=e.unserializeJSON;return e\nvector.lua/     0           0     0     644     1002      `\nlocal a={}local b={__name=\"vector\",__index=a}local function c(d,e,f)return setmetatable({x=tonumber(d)or 0,y=tonumber(e)or 0,z=tonumber(f)or 0},b)end;function a:add(g)return c(self.x+g.x,self.y+g.y,self.z+g.z)end;b.__add=a.add;function a:sub(g)return c(self.x-g.x,self.y-g.y,self.z-g.z)end;b.__sub=a.sub;function a:mul(h)return c(self.x*h,self.y*h,self.z*h)end;b.__mul=a.mul;function a:div(h)return c(self.x/h,self.y/h,self.z/h)end;b.__div=a.div;function a:unm()return c(-self.x,-self.y,-self.z)end;b.__unm=a.unm;function a:dot(g)return self.x*g.x+self.y*g.y+self.z*g.z end;function a:cross(g)return c(self.y*g.z-self.z*g.y,self.z*g.x-self.x*g.z,self.x*g.y-self.y*g.x)end;function a:length()return math.sqrt(self.x*self.x+self.y*self.y+self.z*self.z)end;function a:normalize()return self:mul(1/self:length())end;function a:tostring()return self.x..\",\"..self.y..\",\"..self.z end;b.__tostring=a.tostring;function a:equals(g)return self.x==g.x and self.y==g.y and self.z==g.z end;b.__eq=a.eq;return{new=c}\nwindow.lua/     0           0     0     644     7320      `\nlocal a=require\"cc.expect\"return{new=function(b,c,d,e,f,g)a(1,b,\"table\")a(2,c,\"number\")a(3,d,\"number\")a(4,e,\"number\")a(5,f,\"number\")a(6,g,\"boolean\",\"nil\")if g==nil then g=true end;local h={width=e,height=f}local i={cursor={x=1,y=1},cursorBlink=false,colors={fg='0',bg='f'},palette={},dirtyLines={},dirtyPalette={}}for j=1,h.height do i[j]={(' '):rep(h.width),('0'):rep(h.width),('f'):rep(h.width)}i.dirtyLines[j]=true end;if b then for k=0,15 do i.palette[k]={b.getPaletteColor(k)}i.dirtyPalette[k]=true end else i.palette={[0]={0.94117647058824,0.94117647058824,0.94117647058824},{0.94901960784314,0.69803921568627,0.2},{0.89803921568627,0.49803921568627,0.84705882352941},{0.6,0.69803921568627,0.94901960784314},{0.87058823529412,0.87058823529412,0.42352941176471},{0.49803921568627,0.8,0.098039215686275},{0.94901960784314,0.69803921568627,0.8},{0.29803921568627,0.29803921568627,0.29803921568627},{0.6,0.6,0.6},{0.29803921568627,0.6,0.69803921568627},{0.69803921568627,0.4,0.89803921568627},{0.2,0.4,0.8},{0.49803921568627,0.4,0.29803921568627},{0.34117647058824,0.65098039215686,0.30588235294118},{0.8,0.29803921568627,0.29803921568627},{0.066666666666667,0.066666666666667,0.066666666666667}}for k=0,15 do i.dirtyPalette[k]=true end end;local l=setmetatable({},{__name=\"Terminal\"})function l.close()end;function l.write(m)m=tostring(m)a(1,m,\"string\")if i.cursor.y<1 or i.cursor.y>h.height then return elseif i.cursor.x>h.width or i.cursor.x+#m<1 then i.cursor.x=i.cursor.x+#m;return elseif i.cursor.x<1 then m=m:sub(-i.cursor.x+2)i.cursor.x=1 end;local n=#m;if i.cursor.x+#m>h.width then m=m:sub(1,h.width-i.cursor.x+1)end;i[i.cursor.y][1]=i[i.cursor.y][1]:sub(1,i.cursor.x-1)..m..i[i.cursor.y][1]:sub(i.cursor.x+#m)i[i.cursor.y][2]=i[i.cursor.y][2]:sub(1,i.cursor.x-1)..i.colors.fg:rep(#m)..i[i.cursor.y][2]:sub(i.cursor.x+#m)i[i.cursor.y][3]=i[i.cursor.y][3]:sub(1,i.cursor.x-1)..i.colors.bg:rep(#m)..i[i.cursor.y][3]:sub(i.cursor.x+#m)i.cursor.x=i.cursor.x+n;i.dirtyLines[i.cursor.y]=true;l.redraw()end;function l.blit(m,o,p)m=tostring(m)a(1,m,\"string\")a(2,o,\"string\")a(3,p,\"string\")if#m~=#o or#o~=#p then error(\"Arguments must be the same length\",2)end;if i.cursor.y<1 or i.cursor.y>h.height then return elseif i.cursor.x>h.width or i.cursor.x<1-#m then i.cursor.x=i.cursor.x+#m;l.redraw()return elseif i.cursor.x<1 then m,o,p=m:sub(-i.cursor.x+2),o:sub(-i.cursor.x+2),p:sub(-i.cursor.x+2)i.cursor.x=1 end;local n=#m;if i.cursor.x+#m>h.width then m,o,p=m:sub(1,h.width-i.cursor.x+1),o:sub(1,h.width-i.cursor.x+1),p:sub(1,h.width-i.cursor.x+1)end;i[i.cursor.y][1]=i[i.cursor.y][1]:sub(1,i.cursor.x-1)..m..i[i.cursor.y][1]:sub(i.cursor.x+#m)i[i.cursor.y][2]=i[i.cursor.y][2]:sub(1,i.cursor.x-1)..o..i[i.cursor.y][2]:sub(i.cursor.x+#o)i[i.cursor.y][3]=i[i.cursor.y][3]:sub(1,i.cursor.x-1)..p..i[i.cursor.y][3]:sub(i.cursor.x+#p)i.cursor.x=i.cursor.x+n;i.dirtyLines[i.cursor.y]=true;l.redraw()end;function l.clear()for j=1,h.height do i[j]={(' '):rep(h.width),i.colors.fg:rep(h.width),i.colors.bg:rep(h.width)}i.dirtyLines[j]=true end;l.redraw()end;function l.clearLine()if i.cursor.y>=1 and i.cursor.y<=h.height then i[i.cursor.y]={(' '):rep(h.width),i.colors.fg:rep(h.width),i.colors.bg:rep(h.width)}i.dirtyLines[i.cursor.y]=true;l.redraw()end end;function l.getCursorPos()return i.cursor.x,i.cursor.y end;function l.setCursorPos(q,r)a(1,q,\"number\")a(2,r,\"number\")if q==i.cursor.x and r==i.cursor.y then return end;i.cursor.x,i.cursor.y=math.floor(q),math.floor(r)l.redraw()end;function l.getCursorBlink()return i.cursorBlink end;function l.setCursorBlink(s)a(1,s,\"boolean\")i.cursorBlink=s;l.redraw()end;function l.isColor()return true end;function l.getSize()return h.width,h.height end;function l.scroll(t)a(1,t,\"number\")if math.abs(t)>=h.width then for j=1,h.height do i[j]={(' '):rep(h.width),i.colors.fg:rep(h.width),i.colors.bg:rep(h.width)}end elseif t>0 then for k=t+1,h.height do i[k-t]=i[k]end;for k=h.height-t+1,h.height do i[k]={(' '):rep(h.width),i.colors.fg:rep(h.width),i.colors.bg:rep(h.width)}end elseif t<0 then for k=1,h.height+t do i[k-t]=i[k]end;for k=1,-t do i[k]={(' '):rep(h.width),i.colors.fg:rep(h.width),i.colors.bg:rep(h.width)}end else return end;for k=1,h.height do i.dirtyLines[k]=true end;l.redraw()end;function l.getTextColor()return tonumber(i.colors.fg)end;function l.setTextColor(u)a(1,u,\"number\")a.range(u,0,15)i.colors.fg=(\"%x\"):format(u)end;function l.getBackgroundColor()return tonumber(i.colors.bg)end;function l.setBackgroundColor(u)a(1,u,\"number\")a.range(u,0,15)i.colors.bg=(\"%x\"):format(u)end;function l.getPaletteColor(u)a(1,u,\"number\")a.range(u,0,15)return table.unpack(i.palette[math.floor(u)])end;function l.setPaletteColor(u,v,w,s)a(1,u,\"number\")a(2,v,\"number\")if w==nil and s==nil then v,w,s=bit32.band(bit32.rshift(v,16),0xFF)/255,bit32.band(bit32.rshift(v,8),0xFF)/255,bit32.band(v,0xFF)/255 end;a(3,w,\"number\")a(4,s,\"number\")a.range(u,0,15)if v<0 or v>1 then error(\"bad argument #2 (value out of range)\",2)end;if w<0 or w>1 then error(\"bad argument #3 (value out of range)\",2)end;if s<0 or s>1 then error(\"bad argument #4 (value out of range)\",2)end;i.palette[math.floor(u)]={v,w,s}i.dirtyPalette[math.floor(u)]=true;l.redraw()end;function l.getLine(j)a(1,j,\"number\")local x=i[j]return x and table.unpack(x,1,3)end;function l.getPosition()return c,d end;function l.reposition(y,j,e,f,z)a(1,y,\"number\",\"nil\")a(2,j,\"number\",\"nil\")c=y or c;d=j or d;if z then l.reparent(z)end;if y or j then l.redraw(true)end;if e or f then return l.resize(e,f)end end;function l.resize(A,B)a(1,A,\"number\",\"nil\")a(2,B,\"number\",\"nil\")if A>h.width then for j=1,h.height do i[j][1]=i[j][1]..(' '):rep(A-h.width)i[j][2]=i[j][2]..i.colors.fg:rep(A-h.width)i[j][3]=i[j][3]..i.colors.bg:rep(A-h.width)i.dirtyLines[j]=true end elseif A<h.width then for j=1,h.height do i[j][1]=i[j][1]:sub(1,A)i[j][2]=i[j][2]:sub(1,A)i[j][3]=i[j][3]:sub(1,A)end end;h.width=A;if B>h.height then for j=h.height+1,B do i[j]={(' '):rep(A),i.colors.fg:rep(A),i.colors.bg:rep(A)}i.dirtyLines[j]=true end elseif B<h.height then for j=B+1,h.height do i[j]=nil end end;h.height=B end;function l.reparent(z)a(1,z,\"Terminal\",\"nil\")b=z;l.redraw()end;function l.redraw(C)if not b or not g then return end;b.setCursorBlink(false)if C then b.clear()for j=1,h.height do b.setCursorPos(c,d+j-1)b.blit(i[j][1],i[j][2],i[j][3])end;for k=0,15 do b.setPaletteColor(k,i.palette[k][1],i.palette[k][2],i.palette[k][3])end else for j in pairs(i.dirtyLines)do b.setCursorPos(c,d+j-1)if#i[j][1]~=#i[j][2]or#i[j][2]~=#i[j][3]then error(\"Internal error: Invalid lengths\")end;b.blit(i[j][1],i[j][2],i[j][3])end;for k in pairs(i.dirtyPalette)do b.setPaletteColor(k,i.palette[k][1],i.palette[k][2],i.palette[k][3])end end;b.setCursorPos(c+i.cursor.x-1,d+i.cursor.y-1)b.setCursorBlink(i.cursorBlink)i.dirtyLines,i.dirtyPalette={},{}end;function l.restoreCursor()if not b or not g then return end;b.setCursorPos(c+i.cursor.x-1,d+i.cursor.y-1)b.setCursorBlink(i.cursorBlink)end;function l.isVisible()return g end;function l.setVisible(D)a(1,D,\"boolean\")g=D;l.redraw()end;l.isColour=l.isColor;l.getTextColour=l.getTextColor;l.setTextColour=l.setTextColor;l.getBackgroundColour=l.getBackgroundColor;l.setBackgroundColour=l.setBackgroundColor;l.getPaletteColour=l.getPaletteColor;l.setPaletteColour=l.setPaletteColor;l.redraw()return l end}\n",created=1704748611251,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=51190},["ar.lua"]={modified=1704748610204,data="local a=require\"system.filesystem\"local function b(c)return c:match('^()[%s%z]*$')and''or c:match('^[%s%z]*(.*[^%s%z])')end;local function d(e,f,g)return#e<f and e:sub(1,f)..(g or\" \"):rep(f-#e)or e end;local function h(i)return 0x38+(i.worldPermissions.read and 4 or 0)+(i.worldPermissions.write and 2 or 0)+(i.worldPermissions.execute and 1 or 0)+(i.permissions[i.owner].read and 256 or 0)+(i.permissions[i.owner].write and 128 or 0)+(i.permissions[i.owner].execute and 64 or 0)end;local j={verbosity=0}function j.load(k)if not a.exists(k)then return nil end;local l=a.open(k,\"rb\")if l.read(8)~=\"!<arch>\\n\"then l.close()error(\"Not an ar archive\",2)end;local m={}local n=nil;local o={}while true do local p={}local q=l.read(1)while q==\"\\n\"do q=l.read(1)end;if q==nil then break end;local r=l.read(15)if r==nil then break end;r=q..r;if r:find(\"/\")and r:find(\"/\")>1 then r=r:sub(1,r:find(\"/\")-1)else r=b(r)end;p.timestamp=tonumber(b(l.read(12)))p.owner=tonumber(b(l.read(6)))p.group=tonumber(b(l.read(6)))p.mode=tonumber(b(l.read(8)),8)local s=tonumber(b(l.read(10)))if l.read(2)~=\"`\\n\"then error(\"Invalid header for file \"..r,2)end;if r:match(\"^#1/%d+$\")then r=l.read(tonumber(r:match(\"#1/(%d+)\")))elseif r:match(\"^/%d+$\")then if n then local t=tonumber(r:match(\"/(%d+)\"))r=n:sub(t+1,n:find(\"\\n\",t+1)-1)else o[#o+1]=r end end;p.name=r;p.data=l.read(s)if r==\"//\"then n=p.data elseif r~=\"/\"and r~=\"/SYM64/\"then m[#m+1]=p end end;l.close()if n then for u,v in ipairs(o)do local t=tonumber(v:match(\"/(%d+)\"))for u,w in ipairs(m)do if w.name==v then w.name=n:sub(t,n:find(\"/\",t)-1)break end end end end;return m end;function j.write(v,x)local l=a.open(x,\"wb\")l.write(v.data)l.close()if j.verbosity>0 then print(\"Extracted to \"..x)end end;function j.extract(p,k)if type(p)==\"string\"then p=j.load(p)end;if not a.exists(k)then a.mkdir(k)end;for u,v in ipairs(p)do local x=a.combine(k,v.name)j.write(v,x)end end;function j.read(x)local i=a.stat(x)if not i then return nil end;local l=assert(a.open(x,\"rb\"))local m={name=a.basename(x),timestamp=math.floor(i.modified/1000),owner=(i.owner==\"root\"or i.owner==nil)and 0 or 501,group=0,mode=h(i),data=l.readAll()}l.close()return m end;function j.pack(k)local m={}for u,v in ipairs(a.list(k))do local x=a.combine(k,v)if not a.isDir(x)then m[v]=j.read(x)end end;return m end;function j.save(p,k)local l=a.open(k,\"wb\")l.write(\"!<arch>\\n\")local n={}local y=nil;for u,v in ipairs(p)do if#v.name>15 then n[v.name]=#(y or\"\")y=(y or\"\")..v.name..\"\\n\"end end;if y then l.write(\"//              0           0     0     666     \"..d(tostring(#y),10)..\"`\\n\"..y)if l.seek()%2==1 then l.write(\"\\n\")end end;for u,v in ipairs(p)do local r=n[v.name]and\"/\"..n[v.name]or v.name..(y and\"/\"or\"\")l.write(d(r,16)..d(tostring(v.timestamp),12)..d(tostring(v.owner),6)..d(tostring(v.group),6))l.write(d((\"%o\"):format(v.mode),8)..d(tostring(#v.data),10)..\"`\\n\"..v.data)if l.seek()%2==1 then l.write(\"\\n\")end end;l.close()end;return j\n",created=1704748610207,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=2941},["typescript.lua"]={modified=1704748612889,data="local function a(b)return type(b)==\"table\"and(b[1]~=nil or next(b)==nil)end;local function c(self,...)local d={...}local e={}local f=0;for g=1,#self do f=f+1;e[f]=self[g]end;for g=1,#d do local h=d[g]if a(h)then for i=1,#h do f=f+1;e[f]=h[i]end else f=f+1;e[f]=h end end;return e end;local j,k;do local l={__tostring=function(self)return(\"Symbol(\"..(self.description or\"\"))..\")\"end}function j(m)return setmetatable({description=m},l)end;k={iterator=j(\"Symbol.iterator\"),hasInstance=j(\"Symbol.hasInstance\"),species=j(\"Symbol.species\"),toStringTag=j(\"Symbol.toStringTag\")}end;local function n(o)local p=0;return{[k.iterator]=function(self)return self end,next=function(self)local e={done=o[p+1]==nil,value={p,o[p+1]}}p=p+1;return e end}end;local function q(self,r,s)for g=1,#self do if not r(s,self[g],g-1,self)then return false end end;return true end;local function t(self,r,s)local e={}local f=0;for g=1,#self do if r(s,self[g],g-1,self)then f=f+1;e[f]=self[g]end end;return e end;local function u(self,v,s)for g=1,#self do v(s,self[g],g-1,self)end end;local function w(self,x,s)for g=1,#self do local y=self[g]if x(s,y,g-1,self)then return y end end;return nil end;local function z(self,v,s)for g=1,#self do if v(s,self[g],g-1,self)then return g-1 end end;return-1 end;local A;do local function B(self)local C=self.____coroutine;local D,b=coroutine.resume(C)if not D then error(b,0)end;if coroutine.status(C)==\"dead\"then return end;return true,b end;local function E(self)local e=self:next()if e.done then return end;return true,e.value end;local function F(self,G)G=G+1;if G>#self then return end;return G,string.sub(self,G,G)end;function A(H)if type(H)==\"string\"then return F,H,0 elseif H.____coroutine~=nil then return B,H elseif H[k.iterator]then local I=H[k.iterator](H)return E,I else return ipairs(H)end end end;local J;do local function K(self,G)G=G+1;if G>self.length then return end;return G,self[G]end;local function L(M)if type(M.length)==\"number\"then return K,M,0 end;return A(M)end;function J(N,O,s)local e={}if O==nil then for P,Q in L(N)do e[#e+1]=Q end else for g,Q in L(N)do e[#e+1]=O(s,Q,g-1)end end;return e end end;local function R(self,S,T)if T==nil then T=0 end;local f=#self;local U=T;if T<0 then U=f+T end;if U<0 then U=0 end;for g=U+1,f do if self[g]==S then return true end end;return false end;local function V(self,S,T)if T==nil then T=0 end;local f=#self;if f==0 then return-1 end;if T>=f then return-1 end;if T<0 then T=f+T;if T<0 then T=0 end end;for g=T+1,f do if self[g]==S then return g-1 end end;return-1 end;local function W(self,X)if X==nil then X=\",\"end;local Y={}for g=1,#self do Y[g]=tostring(self[g])end;return table.concat(Y,X)end;local function Z(self,r,s)local e={}for g=1,#self do e[g]=r(s,self[g],g-1,self)end;return e end;local function _(self,...)local d={...}local f=#self;for g=1,#d do f=f+1;self[f]=d[g]end;return f end;local function a0(self,d)local f=#self;for g=1,#d do f=f+1;self[f]=d[g]end;return f end;local function a1(...)return select(\"#\",...)end;local function a2(self,v,...)local f=#self;local U=0;local a3=nil;if a1(...)~=0 then a3=...elseif f>0 then a3=self[1]U=1 else error(\"Reduce of empty array with no initial value\",0)end;for g=U+1,f do a3=v(nil,a3,self[g],g-1,self)end;return a3 end;local function a4(self,v,...)local f=#self;local U=f-1;local a3=nil;if a1(...)~=0 then a3=...elseif f>0 then a3=self[U+1]U=U-1 else error(\"Reduce of empty array with no initial value\",0)end;for g=U+1,1,-1 do a3=v(nil,a3,self[g],g-1,self)end;return a3 end;local function a5(self)local g=1;local i=#self;while g<i do local a6=self[i]self[i]=self[g]self[g]=a6;g=g+1;i=i-1 end;return self end;local function a7(self,...)local d={...}local a8=#d;if a8==0 then return#self end;for g=#self,1,-1 do self[g+a8]=self[g]end;for g=1,a8 do self[g]=d[g]end;return#self end;local function a9(self,aa)if aa~=nil then table.sort(self,function(ab,ac)return aa(nil,ab,ac)<0 end)else table.sort(self)end;return self end;local function ad(self,ae,af)local f=#self;ae=ae or 0;if ae<0 then ae=f+ae;if ae<0 then ae=0 end else if ae>f then ae=f end end;af=af or f;if af<0 then af=f+af;if af<0 then af=0 end else if af>f then af=f end end;local ag={}ae=ae+1;af=af+1;local ah=1;while ae<af do ag[ah]=self[ae]ae=ae+1;ah=ah+1 end;return ag end;local function ai(self,r,s)for g=1,#self do if r(s,self[g],g-1,self)then return true end end;return false end;local function aj(self,...)local ak={...}local f=#self;local al=a1(...)local am=ak[1]local an=ak[2]if am<0 then am=f+am;if am<0 then am=0 end elseif am>f then am=f end;local ao=al-2;if ao<0 then ao=0 end;local ap;if al==0 then ap=0 elseif al==1 then ap=f-am else ap=an or 0;if ap<0 then ap=0 end;if ap>f-am then ap=f-am end end;local ag={}for U=1,ap do local aq=am+U;if self[aq]~=nil then ag[U]=self[aq]end end;if ao<ap then for U=am+1,f-ap do local aq=U+ap;local ar=U+ao;if self[aq]then self[ar]=self[aq]else self[ar]=nil end end;for U=f-ap+ao+1,f do self[U]=nil end elseif ao>ap then for U=f-ap,am+1,-1 do local aq=U+ap;local ar=U+ao;if self[aq]then self[ar]=self[aq]else self[ar]=nil end end end;local i=am+1;for g=3,al do self[i]=ak[g]i=i+1 end;for U=#self,f-ap+ao+1,-1 do self[U]=nil end;return ag end;local function as(self)local at={}for g=1,#self do at[g-1]=self[g]end;return at end;local function au(self,av)if av==nil then av=1 end;local e={}local f=0;for g=1,#self do local b=self[g]if av>0 and a(b)then local aw;if av==1 then aw=b else aw=au(b,av-1)end;for i=1,#aw do local ax=aw[i]f=f+1;e[f]=ax end else f=f+1;e[f]=b end end;return e end;local function ay(self,az,s)local e={}local f=0;for g=1,#self do local b=az(s,self[g],g-1,self)if a(b)then for i=1,#b do f=f+1;e[f]=b[i]end else f=f+1;e[f]=b end end;return e end;local function aA(self,aB)if aB<0 or aB~=aB or aB==math.huge or math.floor(aB)~=aB then error(\"invalid array length: \"..tostring(aB),0)end;for g=aB+1,#self do self[g]=nil end;return aB end;local function aC(aD,aE)if type(aE)~=\"table\"then error(\"Right-hand side of 'instanceof' is not an object\",0)end;if aE[k.hasInstance]~=nil then return not not aE[k.hasInstance](aE,aD)end;if type(aD)==\"table\"then local aF=aD.constructor;while aF~=nil do if aF==aE then return true end;aF=aF.____super end end;return false end;local function aG(aH,...)local aI=setmetatable({},aH.prototype)aI:____constructor(...)return aI end;local function aJ(self)local aK={prototype={}}aK.prototype.__index=aK.prototype;aK.prototype.constructor=aK;return aK end;local aL=table.unpack or unpack;local function aM(aN,...)local aO={...}return function(P,...)local ak={...}a7(ak,aL(aO))return aN(aL(ak))end end;local aP;do local function aQ(self)local aR;local aS;local aT=aG(aP,function(P,aU,aV)aR=aU;aS=aV end)return{promise=aT,resolve=aR,reject=aS}end;local function aW(self,aX)return aC(aX,aP)end;aP=aJ()aP.name=\"__TS__Promise\"function aP.prototype.____constructor(self,aY)self.state=0;self.fulfilledCallbacks={}self.rejectedCallbacks={}self.finallyCallbacks={}do local function aZ(a_)self:reject(a_)end;local b0,b1=pcall(function()aY(nil,aM(self.resolve,self),aM(self.reject,self))end)if not b0 then aZ(b1)end end end;function aP.resolve(b2)local aT=aG(aP,function()end)aT.state=1;aT.value=b2;return aT end;function aP.reject(b3)local aT=aG(aP,function()end)aT.state=2;aT.rejectionReason=b3;return aT end;aP.prototype[\"then\"]=function(self,b4,b5)local b6=aQ(nil)local aT=b6.promise;local aR=b6.resolve;local aS=b6.reject;local b7=self.state==1;local b8=self.state==2;if b4 then local b9=self:createPromiseResolvingCallback(b4,aR,aS)local ba=self.fulfilledCallbacks;ba[#ba+1]=b9;if b7 then b9(nil,self.value)end else local bb=self.fulfilledCallbacks;bb[#bb+1]=function(P,Q)return aR(nil,Q)end end;if b5 then local b9=self:createPromiseResolvingCallback(b5,aR,aS)local bc=self.rejectedCallbacks;bc[#bc+1]=b9;if b8 then b9(nil,self.rejectionReason)end else local bd=self.rejectedCallbacks;bd[#bd+1]=function(P,be)return aS(nil,be)end end;if b7 then aR(nil,self.value)end;if b8 then aS(nil,self.rejectionReason)end;return aT end;function aP.prototype.catch(self,b5)return self[\"then\"](self,nil,b5)end;function aP.prototype.finally(self,bf)if bf then local bg=self.finallyCallbacks;bg[#bg+1]=bf;if self.state~=0 then bf(nil)end end;return self end;function aP.prototype.resolve(self,b2)if aC(b2,aP)then b2[\"then\"](b2,function(P,Q)return self:resolve(Q)end,function(P,be)return self:reject(be)end)return end;if self.state==0 then self.state=1;self.value=b2;for P,az in ipairs(self.fulfilledCallbacks)do az(nil,b2)end;for P,az in ipairs(self.finallyCallbacks)do az(nil)end end end;function aP.prototype.reject(self,b3)if self.state==0 then self.state=2;self.rejectionReason=b3;for P,az in ipairs(self.rejectedCallbacks)do az(nil,b3)end;for P,az in ipairs(self.finallyCallbacks)do az(nil)end end end;function aP.prototype.createPromiseResolvingCallback(self,bh,aR,aS)return function(P,b)do local function aZ(a_)aS(nil,a_)end;local b0,b1=pcall(function()self:handleCallbackData(bh(nil,b),aR,aS)end)if not b0 then aZ(b1)end end end end;function aP.prototype.handleCallbackData(self,b2,aR,aS)if aW(nil,b2)then local bi=b2;if bi.state==1 then aR(nil,bi.value)elseif bi.state==2 then aS(nil,bi.rejectionReason)else b2[\"then\"](b2,aR,aS)end else aR(nil,b2)end end end;local function bj(bk)return aG(aP,function(P,aR,aS)local bl,bm,bn,bo,bp;function bl(self,b)return aC(b,aP)and b or aP.resolve(b)end;function bm(self,b)local bq,br=coroutine.resume(bp,b)if bq then bn(nil,br)else aS(nil,br)end end;function bn(self,e)if bo then return end;if coroutine.status(bp)==\"dead\"then aR(nil,e)else local bs=bl(nil,e)bs[\"then\"](bs,bm,aS)end end;bo=false;bp=coroutine.create(bk)local bq,br=coroutine.resume(bp,function(P,Q)bo=true;local bt=bl(nil,Q)bt[\"then\"](bt,aR,aS)end)if bq then bn(nil,br)else aS(nil,br)end end)end;local function bu(aX)return coroutine.yield(aX)end;local function bv(aH,bw)aH.____super=bw;local bx=setmetatable({__index=bw},bw)setmetatable(aH,bx)local by=getmetatable(bw)if by then if type(by.__index)==\"function\"then bx.__index=by.__index end;if type(by.__newindex)==\"function\"then bx.__newindex=by.__newindex end end;setmetatable(aH.prototype,bw.prototype)if type(bw.prototype.__index)==\"function\"then aH.prototype.__index=bw.prototype.__index end;if type(bw.prototype.__newindex)==\"function\"then aH.prototype.__newindex=bw.prototype.__newindex end;if type(bw.prototype.__tostring)==\"function\"then aH.prototype.__tostring=bw.prototype.__tostring end end;local function bz(bA)local b;local bB;local bC;local bD;local bE;local bF;bF=bA.enumerable;bE=bA.configurable;bD=bA.get;bC=bA.set;bB=bA.writable;b=bA.value;local bG={enumerable=bF==true,configurable=bE==true}local bH=bD~=nil or bC~=nil;local bI=bB~=nil or b~=nil;if bH and bI then error(\"Invalid property descriptor. Cannot both specify accessors and a value or writable attribute.\",0)end;if bD or bC then bG.get=bD;bG.set=bC else bG.value=b;bG.writable=bB==true end;return bG end;local function bJ(self,bK,bL,bM)local e=bK;do local g=#bL;while g>=0 do local bN=bL[g+1]if bN~=nil then local bO=bN(self,e,bM)if bO==nil then bO=e end;e=bO end;g=g-1 end end;return e end;local function bP(aH,...)local bQ={...}for g=1,#bQ do local bR=bQ[g]for p in pairs(bR)do aH[p]=bR[p]end end;return aH end;local function bS(at,p)local bT=getmetatable(at)if not bT then return end;if not rawget(bT,\"_descriptors\")then return end;return rawget(bT,\"_descriptors\")[p]end;local bU;do local function bV(self,p)local b=rawget(self,p)if b~=nil then return b end;local bT=getmetatable(self)while bT do local bW=rawget(bT,p)if bW~=nil then return bW end;local bX=rawget(bT,\"_descriptors\")if bX then local bG=bX[p]if bG~=nil then if bG.get then return bG.get(self)end;return bG.value end end;bT=getmetatable(bT)end end;local function bY(self,p,b)local bT=getmetatable(self)while bT do local bX=rawget(bT,\"_descriptors\")if bX then local bG=bX[p]if bG~=nil then if bG.set then bG.set(self,b)else if bG.writable==false then error((((\"Cannot assign to read only property '\"..p)..\"' of object '\")..tostring(self))..\"'\",0)end;bG.value=b end;return end end;bT=getmetatable(bT)end;rawset(self,p,b)end;function bU(aH,p,bZ,b_)if b_==nil then b_=false end;local c0;if b_ then c0=aH else c0=getmetatable(aH)end;local bT=c0;if not bT then bT={}setmetatable(aH,bT)end;local b=rawget(aH,p)if b~=nil then rawset(aH,p,nil)end;if not rawget(bT,\"_descriptors\")then bT._descriptors={}end;bT._descriptors[p]=bz(bZ)bT.__index=bV;bT.__newindex=bY end end;local function c1(bL,aH,p,bZ)local e=aH;do local g=#bL;while g>=0 do local bN=bL[g+1]if bN~=nil then local c2=e;if p==nil then e=bN(nil,e)elseif bZ==true then local b=rawget(aH,p)local bG=bS(aH,p)or{configurable=true,writable=true,value=b}local bZ=bN(nil,aH,p,bG)or bG;local c3=bZ.configurable==true and bZ.writable==true and not bZ.get and not bZ.set;if c3 then rawset(aH,p,bZ.value)else bU(aH,p,bP({},bG,bZ))end elseif bZ==false then e=bN(nil,aH,p,bZ)else e=bN(nil,aH,p)end;e=e or c2 end;g=g-1 end end;return e end;local function c4(c5,bN)return function(P,aH,p)return bN(nil,aH,p,c5)end end;local function c6(self,c7,c8)if not c8 then c8=1 else c8=c8+1 end;local G=string.find(self,c7,c8,true)return G~=nil end;local c9,ca,cb,cc,cd,ce;do local function cf(self,cg)local ch=1;while true do local ci=debug.getinfo(ch,\"f\")ch=ch+1;if not ci then ch=1;break elseif ci.func==cg then break end end;if c6(_VERSION,\"Lua 5.0\")then return debug.traceback((\"[Level \"..tostring(ch))..\"]\")else return debug.traceback(nil,ch)end end;local function cj(self,ck)return function(self)local m=ck(self)local cl=debug.getinfo(3,\"f\")local cm=c6(_VERSION,\"Lua 5.0\")or _VERSION==\"Lua 5.1\"if cm or cl and cl.func~=error then return m else return(m..\"\\n\")..tostring(self.stack)end end end;local function cn(self,co,cp)co.name=cp;return setmetatable(co,{__call=function(P,cq,cr)return aG(co,cr)end})end;local cs=cn;local ct=aJ()ct.name=\"\"function ct.prototype.____constructor(self,cr)if cr==nil then cr=\"\"end;self.message=cr;self.name=\"Error\"self.stack=cf(nil,self.constructor.new)local bT=getmetatable(self)if bT and not bT.__errorToStringPatched then bT.__errorToStringPatched=true;bT.__tostring=cj(nil,bT.__tostring)end end;function ct.prototype.__tostring(self)return self.message~=\"\"and(self.name..\": \")..self.message or self.name end;c9=cs(nil,ct,\"Error\")local function cu(self,cp)local cv=cn;local cw=aJ()cw.name=cw.name;bv(cw,c9)function cw.prototype.____constructor(self,...)cw.____super.prototype.____constructor(self,...)self.name=cp end;return cv(nil,cw,cp)end;ca=cu(nil,\"RangeError\")cb=cu(nil,\"ReferenceError\")cc=cu(nil,\"SyntaxError\")cd=cu(nil,\"TypeError\")ce=cu(nil,\"URIError\")end;local function cx(at)local bT=getmetatable(at)if not bT then return{}end;return rawget(bT,\"_descriptors\")or{}end;local function cy(aH,p)local bX=cx(aH)local bG=bX[p]if bG then if not bG.configurable then error(aG(cd,(((\"Cannot delete property \"..tostring(p))..\" of \")..tostring(aH))..\".\"),0)end;bX[p]=nil;return true end;aH[p]=nil;return true end;local function cz(self,G)if G>=0 and G<#self then return string.sub(self,G+1,G+1)end end;local function cA(H)if type(H)==\"string\"then for G=0,#H-1 do coroutine.yield(cz(H,G))end elseif H.____coroutine~=nil then local C=H.____coroutine;while true do local D,b=coroutine.resume(C)if not D then error(b,0)end;if coroutine.status(C)==\"dead\"then return b else coroutine.yield(b)end end elseif H[k.iterator]then local I=H[k.iterator](H)while true do local e=I:next()if e.done then return e.value else coroutine.yield(e.value)end end else for P,b in ipairs(H)do coroutine.yield(b)end end end;local cB;do local function cC(self)return self end;local function cD(self,...)local C=self.____coroutine;if coroutine.status(C)==\"dead\"then return{done=true}end;local D,b=coroutine.resume(C,...)if not D then error(b,0)end;return{value=b,done=coroutine.status(C)==\"dead\"}end;function cB(aN)return function(...)local ak={...}local cE=a1(...)return{____coroutine=coroutine.create(function()return aN(aL(ak,1,cE))end),[k.iterator]=cC,next=cD}end end end;local function cF(b)local cG=type(b)return cG==\"table\"or cG==\"function\"end;local function cH(self,cI,cJ)local cK={}local p,b=self(cI,cJ)while p do cK[#cK+1]={p,b}p,b=self(cI,p)end;return aL(cK)end;local cL;do cL=aJ()cL.name=\"Map\"function cL.prototype.____constructor(self,cM)self[k.toStringTag]=\"Map\"self.items={}self.size=0;self.nextKey={}self.previousKey={}if cM==nil then return end;local H=cM;if H[k.iterator]then local I=H[k.iterator](H)while true do local e=I:next()if e.done then break end;local b=e.value;self:set(b[1],b[2])end else local o=cM;for P,cN in ipairs(o)do self:set(cN[1],cN[2])end end end;cL[k.species]=cL;function cL.prototype.clear(self)self.items={}self.nextKey={}self.previousKey={}self.firstKey=nil;self.lastKey=nil;self.size=0 end;function cL.prototype.delete(self,p)local cO=self:has(p)if cO then self.size=self.size-1;local next=self.nextKey[p]local cP=self.previousKey[p]if next~=nil and cP~=nil then self.nextKey[cP]=next;self.previousKey[next]=cP elseif next~=nil then self.firstKey=next;self.previousKey[next]=nil elseif cP~=nil then self.lastKey=cP;self.nextKey[cP]=nil else self.firstKey=nil;self.lastKey=nil end;self.nextKey[p]=nil;self.previousKey[p]=nil end;self.items[p]=nil;return cO end;function cL.prototype.forEach(self,az)for P,p in A(self:keys())do az(nil,self.items[p],p,self)end end;function cL.prototype.get(self,p)return self.items[p]end;function cL.prototype.has(self,p)return self.nextKey[p]~=nil or self.lastKey==p end;function cL.prototype.set(self,p,b)local cQ=not self:has(p)if cQ then self.size=self.size+1 end;self.items[p]=b;if self.firstKey==nil then self.firstKey=p;self.lastKey=p elseif cQ then self.nextKey[self.lastKey]=p;self.previousKey[p]=self.lastKey;self.lastKey=p end;return self end;cL.prototype[k.iterator]=function(self)return self:entries()end;function cL.prototype.entries(self)local d=self.items;local cR=self.nextKey;local p=self.firstKey;return{[k.iterator]=function(self)return self end,next=function(self)local e={done=not p,value={p,d[p]}}p=cR[p]return e end}end;function cL.prototype.keys(self)local cR=self.nextKey;local p=self.firstKey;return{[k.iterator]=function(self)return self end,next=function(self)local e={done=not p,value=p}p=cR[p]return e end}end;function cL.prototype.values(self)local d=self.items;local cR=self.nextKey;local p=self.firstKey;return{[k.iterator]=function(self)return self end,next=function(self)local e={done=not p,value=d[p]}p=cR[p]return e end}end end;local cS=string.match;local cT=math.atan2 or math.atan;local cU=math.modf;local function cV(ax)if ax>0 then return 1 elseif ax<0 then return-1 end;return 0 end;local function cW(b)local cG=type(b)if cG==\"number\"then return b elseif cG==\"string\"then local cX=tonumber(b)if cX then return cX end;if b==\"Infinity\"then return math.huge end;if b==\"-Infinity\"then return-math.huge end;local cY=string.gsub(b,\"%s\",\"\")if cY==\"\"then return 0 end;return 0/0 elseif cG==\"boolean\"then return b and 1 or 0 else return 0/0 end end;local function cZ(b)return type(b)==\"number\"and b==b and b~=math.huge and b~=-math.huge end;local function c_(b)return b~=b end;local d0;do local d1=\"0123456789abcdefghijklmnopqrstuvwxyz\"function d0(self,d2)if d2==nil or d2==10 or self==math.huge or self==-math.huge or self~=self then return tostring(self)end;d2=math.floor(d2)if d2<2 or d2>36 then error(\"toString() radix argument must be between 2 and 36\",0)end;local d3,d4=cU(math.abs(self))local e=\"\"if d2==8 then e=string.format(\"%o\",d3)elseif d2==16 then e=string.format(\"%x\",d3)else repeat do e=cz(d1,d3%d2)..e;d3=math.floor(d3/d2)end until not(d3~=0)end;if d4~=0 then e=e..\".\"local d5=1e-16;repeat do d4=d4*d2;d5=d5*d2;local d6=math.floor(d4)e=e..cz(d1,d6)d4=d4-d6 end until not(d4>=d5)end;if self<0 then e=\"-\"..e end;return e end end;local function d7(self,d8)if math.abs(self)>=1e+21 or self~=self then return tostring(self)end;local bh=math.floor(d8 or 0)if bh<0 or bh>99 then error(\"toFixed() digits argument must be between 0 and 99\",0)end;return string.format((\"%.\"..tostring(bh))..\"f\",self)end;local function d9(aH,p,bZ)local da=type(p)==\"number\"and p+1 or p;local b=rawget(aH,da)local bH=bZ.get~=nil or bZ.set~=nil;local bG;if bH then if b~=nil then error(\"Cannot redefine property: \"..tostring(p),0)end;bG=bZ else local db=b~=nil;local dc=bZ.set;local dd=bZ.get;local de;if bZ.configurable~=nil then de=bZ.configurable else de=db end;local df;if bZ.enumerable~=nil then df=bZ.enumerable else df=db end;local dg;if bZ.writable~=nil then dg=bZ.writable else dg=db end;local dh;if bZ.value~=nil then dh=bZ.value else dh=b end;bG={set=dc,get=dd,configurable=de,enumerable=df,writable=dg,value=dh}end;bU(aH,da,bG)return aH end;local function di(aD)local e={}local f=0;for p in pairs(aD)do f=f+1;e[f]={p,aD[p]}end;return e end;local function dj(cM)local aD={}local H=cM;if H[k.iterator]then local I=H[k.iterator](H)while true do local e=I:next()if e.done then break end;local b=e.value;aD[b[1]]=b[2]end else for P,dk in ipairs(cM)do aD[dk[1]]=dk[2]end end;return aD end;local function dl(aD)local e={}local f=0;for p in pairs(aD)do f=f+1;e[f]=p end;return e end;local function dm(aH,dn)local e={}for dp in pairs(aH)do if not dn[dp]then e[dp]=aH[dp]end end;return e end;local function dq(aD)local e={}local f=0;for p in pairs(aD)do f=f+1;e[f]=aD[p]end;return e end;local function dr(ds)local dt=cS(ds,\"^%s*(-?Infinity)\")if dt~=nil then return cz(dt,0)==\"-\"and-math.huge or math.huge end;local du=tonumber(cS(ds,\"^%s*(-?%d+%.?%d*)\"))return du or 0/0 end;local function dv(self,am,dw)if dw~=dw then dw=0 end;if dw~=nil and am>dw then am,dw=dw,am end;if am>=0 then am=am+1 else am=1 end;if dw~=nil and dw<0 then dw=0 end;return string.sub(self,am,dw)end;local dx;do local dy=\"0123456789aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTvVwWxXyYzZ\"function dx(ds,bw)if bw==nil then bw=10;local dz=cS(ds,\"^%s*-?0[xX]\")if dz~=nil then bw=16;ds=cS(dz,\"-\")and\"-\"..dv(ds,#dz)or dv(ds,#dz)end end;if bw<2 or bw>36 then return 0/0 end;local dA=bw<=10 and dv(dy,0,bw)or dv(dy,0,10+2*(bw-10))local dB=(\"^%s*(-?[\"..dA)..\"]*)\"local du=tonumber(cS(ds,dB),bw)if du==nil then return 0/0 end;if du>=0 then return math.floor(du)else return math.ceil(du)end end end;local function dC(H)local cK={}local dD={}local dE=0;local g=0;for P,h in A(H)do if aC(h,aP)then if h.state==1 then cK[g+1]=h.value elseif h.state==2 then return aP.reject(h.rejectionReason)else dE=dE+1;dD[g]=h end else cK[g+1]=h end;g=g+1 end;if dE==0 then return aP.resolve(cK)end;return aG(aP,function(P,aR,aS)for G,aT in pairs(dD)do aT[\"then\"](aT,function(P,b2)cK[G+1]=b2;dE=dE-1;if dE==0 then aR(nil,cK)end end,function(P,b3)aS(nil,b3)end)end end)end;local function dF(H)local cK={}local dD={}local dE=0;local g=0;for P,h in A(H)do if aC(h,aP)then if h.state==1 then cK[g+1]={status=\"fulfilled\",value=h.value}elseif h.state==2 then cK[g+1]={status=\"rejected\",reason=h.rejectionReason}else dE=dE+1;dD[g]=h end else cK[g+1]={status=\"fulfilled\",value=h}end;g=g+1 end;if dE==0 then return aP.resolve(cK)end;return aG(aP,function(P,aR)for G,aT in pairs(dD)do aT[\"then\"](aT,function(P,b2)cK[G+1]={status=\"fulfilled\",value=b2}dE=dE-1;if dE==0 then aR(nil,cK)end end,function(P,b3)cK[G+1]={status=\"rejected\",reason=b3}dE=dE-1;if dE==0 then aR(nil,cK)end end)end end)end;local function dG(H)local dH={}local dI={}for P,h in A(H)do if aC(h,aP)then if h.state==1 then return aP.resolve(h.value)elseif h.state==2 then dH[#dH+1]=h.rejectionReason else dI[#dI+1]=h end else return aP.resolve(h)end end;if#dI==0 then return aP.reject(\"No promises to resolve with .any()\")end;local dJ=0;return aG(aP,function(P,aR,aS)for P,aT in ipairs(dI)do aT[\"then\"](aT,function(P,b2)aR(nil,b2)end,function(P,b3)dH[#dH+1]=b3;dJ=dJ+1;if dJ==#dI then aS(nil,{name=\"AggregateError\",message=\"All Promises rejected\",errors=dH})end end)end end)end;local function dK(H)local dI={}for P,h in A(H)do if aC(h,aP)then if h.state==1 then return aP.resolve(h.value)elseif h.state==2 then return aP.reject(h.rejectionReason)else dI[#dI+1]=h end else return aP.resolve(h)end end;return aG(aP,function(P,aR,aS)for P,aT in ipairs(dI)do aT[\"then\"](aT,function(P,b)return aR(nil,b)end,function(P,b3)return aS(nil,b3)end)end end)end;local dL;do dL=aJ()dL.name=\"Set\"function dL.prototype.____constructor(self,dM)self[k.toStringTag]=\"Set\"self.size=0;self.nextKey={}self.previousKey={}if dM==nil then return end;local H=dM;if H[k.iterator]then local I=H[k.iterator](H)while true do local e=I:next()if e.done then break end;self:add(e.value)end else local o=dM;for P,b in ipairs(o)do self:add(b)end end end;dL[k.species]=dL;function dL.prototype.add(self,b)local cQ=not self:has(b)if cQ then self.size=self.size+1 end;if self.firstKey==nil then self.firstKey=b;self.lastKey=b elseif cQ then self.nextKey[self.lastKey]=b;self.previousKey[b]=self.lastKey;self.lastKey=b end;return self end;function dL.prototype.clear(self)self.nextKey={}self.previousKey={}self.firstKey=nil;self.lastKey=nil;self.size=0 end;function dL.prototype.delete(self,b)local cO=self:has(b)if cO then self.size=self.size-1;local next=self.nextKey[b]local cP=self.previousKey[b]if next~=nil and cP~=nil then self.nextKey[cP]=next;self.previousKey[next]=cP elseif next~=nil then self.firstKey=next;self.previousKey[next]=nil elseif cP~=nil then self.lastKey=cP;self.nextKey[cP]=nil else self.firstKey=nil;self.lastKey=nil end;self.nextKey[b]=nil;self.previousKey[b]=nil end;return cO end;function dL.prototype.forEach(self,az)for P,p in A(self:keys())do az(nil,p,p,self)end end;function dL.prototype.has(self,b)return self.nextKey[b]~=nil or self.lastKey==b end;dL.prototype[k.iterator]=function(self)return self:values()end;function dL.prototype.entries(self)local cR=self.nextKey;local p=self.firstKey;return{[k.iterator]=function(self)return self end,next=function(self)local e={done=not p,value={p,p}}p=cR[p]return e end}end;function dL.prototype.keys(self)local cR=self.nextKey;local p=self.firstKey;return{[k.iterator]=function(self)return self end,next=function(self)local e={done=not p,value=p}p=cR[p]return e end}end;function dL.prototype.values(self)local cR=self.nextKey;local p=self.firstKey;return{[k.iterator]=function(self)return self end,next=function(self)local e={done=not p,value=p}p=cR[p]return e end}end end;local function dN(...)local dO={...}dO.sparseLength=a1(...)return dO end;local function dP(dO,...)local ak={...}local dQ=a1(...)local dR=dO.sparseLength;for g=1,dQ do dO[dR+g]=ak[g]end;dO.sparseLength=dR+dQ end;local function dS(dO)local dT=unpack or table.unpack;return dT(dO,1,dO.sparseLength)end;local dU;do dU=aJ()dU.name=\"WeakMap\"function dU.prototype.____constructor(self,cM)self[k.toStringTag]=\"WeakMap\"self.items={}setmetatable(self.items,{__mode=\"k\"})if cM==nil then return end;local H=cM;if H[k.iterator]then local I=H[k.iterator](H)while true do local e=I:next()if e.done then break end;local b=e.value;self.items[b[1]]=b[2]end else for P,cN in ipairs(cM)do self.items[cN[1]]=cN[2]end end end;dU[k.species]=dU;function dU.prototype.delete(self,p)local cO=self:has(p)self.items[p]=nil;return cO end;function dU.prototype.get(self,p)return self.items[p]end;function dU.prototype.has(self,p)return self.items[p]~=nil end;function dU.prototype.set(self,p,b)self.items[p]=b;return self end end;local dV;do dV=aJ()dV.name=\"WeakSet\"function dV.prototype.____constructor(self,dM)self[k.toStringTag]=\"WeakSet\"self.items={}setmetatable(self.items,{__mode=\"k\"})if dM==nil then return end;local H=dM;if H[k.iterator]then local I=H[k.iterator](H)while true do local e=I:next()if e.done then break end;self.items[e.value]=true end else for P,b in ipairs(dM)do self.items[b]=true end end end;dV[k.species]=dV;function dV.prototype.add(self,b)self.items[b]=true;return self end;function dV.prototype.delete(self,b)local cO=self:has(b)self.items[b]=nil;return cO end;function dV.prototype.has(self,b)return self.items[b]==true end end;local function dW(dX,dY)_G.__TS__sourcemap=_G.__TS__sourcemap or{}_G.__TS__sourcemap[dX]=dY;if _G.__TS__originalTraceback==nil then local dZ=debug.traceback;_G.__TS__originalTraceback=dZ;debug.traceback=function(d_,cr,ch)local e0;if d_==nil and cr==nil and ch==nil then e0=dZ()elseif c6(_VERSION,\"Lua 5.0\")then e0=dZ(((\"[Level \"..tostring(ch))..\"] \")..tostring(cr))else e0=dZ(d_,cr,ch)end;if type(e0)~=\"string\"then return e0 end;local function e1(P,e2,e3,e4)local e5=_G.__TS__sourcemap[e2]if e5~=nil and e5[e4]~=nil then local b2=e5[e4]if type(b2)==\"number\"then return(e3 ..\":\")..tostring(b2)end;return(b2.file..\":\")..tostring(b2.line)end;return(e2 ..\":\")..e4 end;local e=string.gsub(e0,\"(%S+)%.lua:(%d+)\",function(e2,e4)return e1(nil,e2 ..\".lua\",e2 ..\".ts\",e4)end)local function e6(P,e2,e4)local e5=_G.__TS__sourcemap[e2]if e5~=nil and e5[e4]~=nil then local e7=cS(e2,\"%[string \\\"([^\\\"]+)\\\"%]\")local e8=string.gsub(e7,\".lua$\",\".ts\")local b2=e5[e4]if type(b2)==\"number\"then return(e8 ..\":\")..tostring(b2)end;return(b2.file..\":\")..tostring(b2.line)end;return(e2 ..\":\")..e4 end;e=string.gsub(e,\"(%[string \\\"[^\\\"]+\\\"%]):(%d+)\",function(e2,e4)return e6(nil,e2,e4)end)return e end end end;local function e9(H)local M={}if type(H)==\"string\"then for g=0,#H-1 do M[g+1]=cz(H,g)end else local f=0;for P,h in A(H)do f=f+1;M[f]=h end end;return aL(M)end;local function ea(self,eb)if eb~=eb then eb=0 end;if eb<0 then return\"\"end;return string.sub(self,eb+1,eb+1)end;local function ec(self,G)if G~=G then G=0 end;if G<0 then return 0/0 end;return string.byte(self,G+1)or 0/0 end;local function ed(self,c7,ee)if ee==nil or ee>#self then ee=#self end;return string.sub(self,ee-#c7+1,ee)==c7 end;local function ef(self,eg,eh)if eh==nil then eh=\" \"end;if eg~=eg then eg=0 end;if eg==-math.huge or eg==math.huge then error(\"Invalid string length\",0)end;if#self>=eg or#eh==0 then return self end;eg=eg-#self;if eg>#eh then eh=eh..string.rep(eh,math.floor(eg/#eh))end;return self..string.sub(eh,1,math.floor(eg))end;local function ei(self,eg,eh)if eh==nil then eh=\" \"end;if eg~=eg then eg=0 end;if eg==-math.huge or eg==math.huge then error(\"Invalid string length\",0)end;if#self>=eg or#eh==0 then return self end;eg=eg-#self;if eg>#eh then eh=eh..string.rep(eh,math.floor(eg/#eh))end;return string.sub(eh,1,math.floor(eg))..self end;local ej;do local ek=string.sub;function ej(bR,el,em)local en,eo=string.find(bR,el,nil,true)if not en then return bR end;local ep=ek(bR,1,en-1)local eq=type(em)==\"string\"and em or em(nil,el,en-1,bR)local er=ek(bR,eo+1)return(ep..eq)..er end end;local es;do local ek=string.sub;local et=string.find;function es(bR,X,eu)if eu==nil then eu=4294967295 end;if eu==0 then return{}end;local e={}local ev=1;if X==nil or X==\"\"then for g=1,#bR do e[ev]=ek(bR,g,g)ev=ev+1 end else local ew=1;while ev<=eu do local en,eo=et(bR,X,ew,true)if not en then break end;e[ev]=ek(bR,ew,en-1)ev=ev+1;ew=eo+1 end;if ev<=eu then e[ev]=ek(bR,ew)end end;return e end end;local ex;do local ek=string.sub;local et=string.find;function ex(bR,el,em)if type(em)==\"string\"then local ey=table.concat(es(bR,el),em)if#el==0 then return(em..ey)..em end;return ey end;local Y={}local ez=1;if#el==0 then Y[1]=em(nil,\"\",0,bR)ez=2;for g=1,#bR do Y[ez]=ek(bR,g,g)Y[ez+1]=em(nil,\"\",g,bR)ez=ez+2 end else local ew=1;while true do local en,eo=et(bR,el,ew,true)if not en then break end;Y[ez]=ek(bR,ew,en-1)Y[ez+1]=em(nil,el,en-1,bR)ez=ez+2;ew=eo+1 end;Y[ez]=ek(bR,ew)end;return table.concat(Y)end end;local function eA(self,am,dw)if am==nil or am~=am then am=0 end;if dw~=dw then dw=0 end;if am>=0 then am=am+1 end;if dw~=nil and dw<0 then dw=dw-1 end;return string.sub(self,am,dw)end;local function eB(self,c7,c8)if c8==nil or c8<0 then c8=0 end;return string.sub(self,c8+1,#c7+c8)==c7 end;local function eC(self,aq,aB)if aq~=aq then aq=0 end;if aB~=nil then if aB~=aB or aB<=0 then return\"\"end;aB=aB+aq end;if aq>=0 then aq=aq+1 end;return string.sub(self,aq,aB)end;local function eD(self)local e=string.gsub(self,\"^[%s\194\160\239\187\191]*(.-)[%s\194\160\239\187\191]*$\",\"%1\")return e end;local function eE(self)local e=string.gsub(self,\"[%s\194\160\239\187\191]*$\",\"\")return e end;local function eF(self)local e=string.gsub(self,\"^[%s\194\160\239\187\191]*\",\"\")return e end;local eG,eH;do local eI={}function eG(p)if not eI[p]then eI[p]=j(p)end;return eI[p]end;function eH(eJ)for p in pairs(eI)do if eI[p]==eJ then return p end end;return nil end end;local function eK(b)local eL=type(b)if eL==\"table\"then return\"object\"elseif eL==\"nil\"then return\"undefined\"else return eL end end;return{__TS__ArrayConcat=c,__TS__ArrayEntries=n,__TS__ArrayEvery=q,__TS__ArrayFilter=t,__TS__ArrayForEach=u,__TS__ArrayFind=w,__TS__ArrayFindIndex=z,__TS__ArrayFrom=J,__TS__ArrayIncludes=R,__TS__ArrayIndexOf=V,__TS__ArrayIsArray=a,__TS__ArrayJoin=W,__TS__ArrayMap=Z,__TS__ArrayPush=_,__TS__ArrayPushArray=a0,__TS__ArrayReduce=a2,__TS__ArrayReduceRight=a4,__TS__ArrayReverse=a5,__TS__ArrayUnshift=a7,__TS__ArraySort=a9,__TS__ArraySlice=ad,__TS__ArraySome=ai,__TS__ArraySplice=aj,__TS__ArrayToObject=as,__TS__ArrayFlat=au,__TS__ArrayFlatMap=ay,__TS__ArraySetLength=aA,__TS__AsyncAwaiter=bj,__TS__Await=bu,__TS__Class=aJ,__TS__ClassExtends=bv,__TS__CloneDescriptor=bz,__TS__CountVarargs=a1,__TS__Decorate=bJ,__TS__DecorateLegacy=c1,__TS__DecorateParam=c4,__TS__Delete=cy,__TS__DelegatedYield=cA,Error=c9,RangeError=ca,ReferenceError=cb,SyntaxError=cc,TypeError=cd,URIError=ce,__TS__FunctionBind=aM,__TS__Generator=cB,__TS__InstanceOf=aC,__TS__InstanceOfObject=cF,__TS__Iterator=A,__TS__LuaIteratorSpread=cH,Map=cL,__TS__Match=cS,__TS__MathAtan2=cT,__TS__MathModf=cU,__TS__MathSign=cV,__TS__New=aG,__TS__Number=cW,__TS__NumberIsFinite=cZ,__TS__NumberIsNaN=c_,__TS__NumberToString=d0,__TS__NumberToFixed=d7,__TS__ObjectAssign=bP,__TS__ObjectDefineProperty=d9,__TS__ObjectEntries=di,__TS__ObjectFromEntries=dj,__TS__ObjectGetOwnPropertyDescriptor=bS,__TS__ObjectGetOwnPropertyDescriptors=cx,__TS__ObjectKeys=dl,__TS__ObjectRest=dm,__TS__ObjectValues=dq,__TS__ParseFloat=dr,__TS__ParseInt=dx,__TS__Promise=aP,__TS__PromiseAll=dC,__TS__PromiseAllSettled=dF,__TS__PromiseAny=dG,__TS__PromiseRace=dK,Set=dL,__TS__SetDescriptor=bU,__TS__SparseArrayNew=dN,__TS__SparseArrayPush=dP,__TS__SparseArraySpread=dS,WeakMap=dU,WeakSet=dV,__TS__SourceMapTraceBack=dW,__TS__Spread=e9,__TS__StringAccess=cz,__TS__StringCharAt=ea,__TS__StringCharCodeAt=ec,__TS__StringEndsWith=ed,__TS__StringIncludes=c6,__TS__StringPadEnd=ef,__TS__StringPadStart=ei,__TS__StringReplace=ej,__TS__StringReplaceAll=ex,__TS__StringSlice=eA,__TS__StringSplit=es,__TS__StringStartsWith=eB,__TS__StringSubstr=eC,__TS__StringSubstring=dv,__TS__StringTrim=eD,__TS__StringTrimEnd=eE,__TS__StringTrimStart=eF,__TS__Symbol=j,Symbol=k,__TS__SymbolRegistryFor=eG,__TS__SymbolRegistryKeyFor=eH,__TS__TypeOf=eK,__TS__Unpack=aL}\n",created=1704748612890,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=34616},["libsystem.a"]={modified=1704748611467,data="!<arch>\n//                                              20        `\nserialization.lua/\n\nexpect.lua/     0           0     0     644     1273      `\nlocal a={}local b={[\"nil\"]=true,boolean=true,number=true,string=true,table=true,[\"function\"]=true,userdata=true,thread=true}local function c(d,e,...)local f=type(e)local g;if f==\"table\"then local h=getmetatable(e)if h then g=h.__name end end;local i=table.pack(...)for j,k in ipairs(i)do if b[k]then if f==k then return e end elseif g==k then return e end end;local l=debug.getinfo(2,\"n\")if l and l.name and l.name~=\"\"then d=d..\" to '\"..l.name..\"'\"end;local m;if i.n==1 then m=i[1]elseif i.n==2 then m=i[1]..\" or \"..i[2]else m=table.concat(i,\", \",1,i.n-1)..\", or \"..i[i.n]end;error(d..\" (expected \"..m..\", got \"..f..\")\",3)end;function a.expect(n,e,...)return c(\"bad argument #\"..n,e,...)end;function a.field(o,p,...)local q,r=pcall(string.format,\"%q\",p)if not q then r=tostring(p)end;return c(\"bad field \"..r,o[p],...)end;function a.range(s,t,u)a.expect(1,s,\"number\")a.expect(2,t,\"number\",\"nil\")a.expect(3,u,\"number\",\"nil\")if u and t and u<t then error(\"bad argument #3 (min must be less than or equal to max)\",2)end;if s~=s or s<(t or-math.huge)or s>(u or math.huge)then error((\"number outside of range (expected %s to be within %s and %s)\"):format(s,t or-math.huge,u or math.huge),3)end;return s end;return setmetatable(a,{__call=function(j,...)return a.expect(...)end})\n\nfilesystem.lua/ 0           0     0     644     4492      `\nlocal a=require\"util\"local b=require\"expect\"local c={}function c.open(d,e)b(1,d,\"string\")b(2,e,\"string\")return a.syscall.open(d,e)end;function c.list(d)b(1,d,\"string\")return a.syscall.list(d)end;function c.stat(d,f)b(1,d,\"string\")b(2,f,\"nil\",\"boolean\")return a.syscall.stat(d,f)end;function c.remove(d)b(1,d,\"string\")return a.syscall.remove(d)end;function c.rename(g,h)b(1,g,\"string\")b(2,h,\"string\")return a.syscall.rename(g,h)end;function c.mkdir(d)b(1,d,\"string\")return a.syscall.mkdir(d)end;function c.link(d,i)b(1,d,\"string\")b(2,i,\"string\")return a.syscall.link(d,i)end;function c.mkfifo(d)b(1,d,\"string\")return a.syscall.mkfifo(d)end;function c.chmod(d,j,e)b(1,d,\"string\")b(2,j,\"string\",\"nil\")b(3,e,\"number\",\"string\",\"table\")if type(e)==\"string\"and not e:match\"^[%+%-=][rwxs]+$\"and not e:match\"^[r%-][w%-][xs%-]$\"then error(\"bad argument #3 (invalid mode)\",2)elseif type(e)==\"table\"then b.field(e,\"read\",\"boolean\",\"nil\")b.field(e,\"write\",\"boolean\",\"nil\")b.field(e,\"execute\",\"boolean\",\"nil\")end;return a.syscall.chmod(d,j,e)end;function c.chown(d,j)b(1,d,\"string\")b(2,j,\"string\")return a.syscall.chown(d,j)end;function c.chroot(d)b(1,d,\"string\")return a.syscall.chroot(d)end;function c.mount(type,k,l,m)b(1,type,\"string\")b(2,k,\"string\")b(3,l,\"string\")b(4,m,\"table\",\"nil\")return a.syscall.mount(type,k,l,m)end;function c.unmount(d)b(1,d,\"string\")return a.syscall.unmount(d)end;function c.mountlist()return a.syscall.mountlist()end;function c.combine(...)return a.syscall.combine(...)end;function c.copy(g,h,n)b(1,g,\"string\")b(2,h,\"string\")local o=assert(c.stat(g),g..\": No such file or directory\")if o.type==\"directory\"then local p=c.list(g)c.mkdir(h)for q,r in ipairs(p)do c.copy(c.combine(g,r),c.combine(h,r))end else local s,t=c.open(g,\"rb\")if not s then error(t,2)end;local u,t=c.open(h,\"wb\")if not u then s.close()error(t,2)end;repeat local v=s.read(512)if v then u.write(v)end until not v;u.close()s.close()end;if n then c.chmod(h,nil,o.worldPermissions)for w,r in pairs(o.permissions)do c.chmod(h,w,r)end;if o.owner then c.chown(h,o.owner)end;if o.setuser then pcall(c.chmod,h,o.owner,\"+s\")end end end;function c.move(g,h)b(1,g,\"string\")b(2,h,\"string\")local x=assert(c.stat(g,true),\"File not found\")local y=c.stat(h)if y then error(\"File already exists\",2)end;local d=c.dirname(h)repeat y,d=c.stat(d),c.dirname(d)until y;if x.type==\"directory\"then local p=c.list(g)c.mkdir(h)for q,r in ipairs(p)do c.move(c.combine(g,r),c.combine(h,r))end elseif x.mountpoint==y.mountpoint then c.rename(g,h)else local s,t=c.open(g,\"rb\")if not s then error(t,2)end;local z=s.readAll()s.close()local u,t=c.open(h,\"wb\")if not u then error(t,2)end;c.remove(g)if z then u.write(z)end;u.close()end;c.chmod(h,nil,x.worldPermissions)for w,r in pairs(x.permissions)do c.chmod(h,w,r)end;if x.owner then c.chown(h,x.owner)end;if x.setuser then pcall(c.chmod,h,x.owner,\"+s\")end end;function c.basename(d)b(1,d,\"string\")return c.combine(d):match\"[^/]+$\"end;function c.dirname(d)b(1,d,\"string\")local A=c.combine(d):match\"^(.*)/[^/]*$\"if A==\"\"or A==nil then if d:sub(1,1)==\"/\"then return\"/\"else return\".\"end else return A end end;local function B(m,C,D)if D>#C then return{}end;local E=\"^\"..C[D]:gsub(\"[%^%$%(%)%%%.%+%-]\",\"%%%1\"):gsub(\"%*\",\".*\"):gsub(\"%?\",\".\"):gsub(\"%[!\",\"[^\")..\"$\"local F={}for q,G in ipairs(m)do local H,I=pcall(c.list,G)if H then for q,d in ipairs(I)do if d:match(E)then F[#F+1]=c.combine(G,d)end end end end;if D+1>#C then return F end;return B(F,C,D+1)end;function c.find(J)b(1,J,\"string\")local K={}for A in J:gmatch(\"[^/]+\")do K[#K+1]=A end;local L=B({J:sub(1,1)==\"/\"and\"/\"or\".\"},K,1)table.sort(L)return L end;function c.exists(d)b(1,d,\"string\")return c.stat(d)~=nil end;function c.isFile(d)b(1,d,\"string\")local M=c.stat(d)if not M then return false end;return M.type==\"file\"end;function c.isDir(d)b(1,d,\"string\")local M=c.stat(d)if not M then return false end;return M.type==\"directory\"end;function c.isLink(d)b(1,d,\"string\")local M=c.stat(d)if not M then return false end;return M.type==\"link\"end;function c.effectivePermissions(N,j)b(1,N,\"string\",\"table\")j=b(2,j,\"number\",\"nil\")or a.syscall.getpid()if type(N)==\"string\"then N=a.syscall.stat(N)if not N then return nil end end;b.field(N,\"permissions\",\"table\")b.field(N,\"worldPermissions\",\"table\")return N.permissions[j]or N.worldPermissions end;local O={}O.type=\"\"O.size=0;O.created=0;O.modified=0;O.owner=\"\"O.permissions={read=false,write=false,execute=false}O.worldPermissions={read=false,write=false,execute=false}O.special={}return c\nframebuffer.lua/0           0     0     644     16558     `\nlocal a=require\"expect\"local b=require\"util\"local c={}c.empty={text={},graphics={}}function c.window(d,e,f,g,h)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,e,\"number\")a(3,f,\"number\")a(4,g,\"number\")a(5,h,\"number\")local i=b.type(d)local j={}function j.close()end;function j.getSize()return g,h end;function j.getPosition()return e,f end;function j.getParent()return d end;function j.getPaletteColor(k)return d.getPaletteColor(k)end;function j.setPaletteColor(k,l,m,n)return d.setPaletteColor(k,l,m,n)end;j.getPaletteColour=j.getPaletteColor;j.setPaletteColour=j.setPaletteColor;function j.reposition(o,p,q,r,s)a(1,o,\"number\",\"nil\")a(2,p,\"number\",\"nil\")a(3,q,\"number\",\"nil\")a(4,r,\"number\",\"nil\")a(5,s,\"nil\",i)e=o or e;f=p or f;g=q or g;h=r or h;d=s or d end;function j.resize(q,r)a(1,q,\"number\",\"nil\")a(2,r,\"number\",\"nil\")g=q or g;h=r or h end;function j.reparent(s)a(1,s,\"nil\",i)d=s or d end;if i==\"Terminal\"then setmetatable(j,{__name=\"Terminal\"})local t,u,v=1,1,d.getCursorBlink()local w,x=d.getTextColor(),d.getBackgroundColor()function j.write(y)a(1,y,\"string\")if u<1 or u>h or t>g or#y==0 then return end;if t<1 then local z=math.min(1-t,#y)t=t+z;if z==#y then return end;y=y:sub(z)end;local z=math.min(g-t+1,#y)d.setCursorPos(e+t-1,f+u-1)d.setTextColor(w)d.setBackgroundColor(x)d.write(y:sub(1,z))t=t+z end;function j.blit(y,A,B)a(1,y,\"string\")a(2,A,\"string\")a(3,B,\"string\")if u<1 or u>h or t>g or#y==0 then return end;if t<1 then local z=math.min(1-t,#y)t=t+z;if z==#y then return end;y=y:sub(z)end;local z=math.min(g-t+1,#y)d.setCursorPos(e+t-1,f+u-1)d.blit(y:sub(1,z),A:sub(1,z),B:sub(1,z))w,x=d.getTextColor(),d.getBackgroundColor()t=t+z end;function j.clear()d.setTextColor(w)d.setBackgroundColor(x)for C=1,h do d.setCursorPos(e,f+C-1)d.write((\" \"):rep(g))end end;function j.clearLine()d.setTextColor(w)d.setBackgroundColor(x)d.setCursorPos(e,f+u-1)d.write((\" \"):rep(g))end;function j.getCursorPos()return t,u end;function j.setCursorPos(o,p)a(1,o,\"number\")a(2,p,\"number\")t,u=o,p;d.setCursorPos(e+t-1,f+u-1)end;function j.getCursorBlink()return v end;function j.setCursorBlink(D)a(1,D,\"boolean\")v=D;d.setCursorBlink(D)end;function j.isColor()return d.isColor()end;function j.scroll(E)a(1,E,\"number\")if math.abs(E)>=g then return j.clear()elseif E>0 then for F=E+1,h do local G=j.getLine(F)d.setCursorPos(e,f+F-E-1)d.blit(table.unpack(G,1,3))end;for F=h-E+1,h do d.setCursorPos(e,f+F-1)d.setTextColor(w)d.setBackgroundColor(x)d.write((' '):rep(g))end elseif E<0 then for F=1,h+E do local G=j.getLine(F)d.setCursorPos(e,f+F-E-1)d.blit(table.unpack(G,1,3))end;for F=1,-E do d.setCursorPos(e,f+F-1)d.setTextColor(w)d.setBackgroundColor(x)d.write((' '):rep(g))end else return end end;function j.getTextColor()return w end;function j.setTextColor(k)a(1,k,\"number\")w=k;d.setTextColor(k)end;function j.getBackgroundColor()return x end;function j.setBackgroundColor(k)a(1,k,\"number\")x=k;d.setBackgroundColor(k)end;function j.getLine(p)a(1,p,\"number\")local G=d.getLine(f+p-1)if not G then return nil end;return{G[1]:sub(e,e+g-1),G[2]:sub(e,e+g-1),G[3]:sub(e,e+g-1)}end;function j.restoreCursor()d.setCursorPos(e+t-1,f+u-1)d.setCursorBlink(v)end;j.isColour=j.isColor;j.getTextColour=j.getTextColor;j.setTextColour=j.setTextColor;j.getBackgroundColour=j.getBackgroundColor;j.setBackgroundColour=j.setBackgroundColor else setmetatable(j,{__name=\"GFXTerminal\"})function j.clear()d.drawPixels(e,f,15,g,h)end;function j.getPixel(o,p)return d.getPixel(e+o,f+p)end;function j.setPixel(o,p,k)return d.setPixel(e+o,f+p,k)end;function j.getPixels(o,p,H,I,J)return d.getPixels(e+o,f+p,H,I,J)end;function j.drawPixels(o,p,K,H,I)return d.drawPixels(e+o,f+p,K,H,I)end;function j.getFrozen()return d.getFrozen()end;function j.setFrozen(L)return d.setFrozen(L)end end;return j end;function c.framebuffer(d,M,N,q,r,O)local P;if d==c.empty.text or d==c.empty.graphics then M=a(2,M,\"number\",\"nil\")or 1;N=a(3,N,\"number\",\"nil\")or 1;P=d==c.empty.graphics;d=nil else a(1,d,\"Terminal\",\"GFXTerminal\")a(2,M,\"number\")a(3,N,\"number\")P=b.type(d)==\"GFXTerminal\"end;a(4,q,\"number\")a(5,r,\"number\")a(6,O,\"boolean\",\"nil\")if O==nil then O=true end;local Q={width=q,height=r}if P then local R={palette={},dirtyRects={},dirtyPalette={},frozen=false}for f=1,Q.height*9 do R[f]=('\\15'):rep(Q.width*6)end;if d then for F=0,15 do R.palette[F]={d.getPaletteColor(F)}R.dirtyPalette[F]=true end else R.palette={[0]={0.94117647058824,0.94117647058824,0.94117647058824},{0.94901960784314,0.69803921568627,0.2},{0.89803921568627,0.49803921568627,0.84705882352941},{0.6,0.69803921568627,0.94901960784314},{0.87058823529412,0.87058823529412,0.42352941176471},{0.49803921568627,0.8,0.098039215686275},{0.94901960784314,0.69803921568627,0.8},{0.29803921568627,0.29803921568627,0.29803921568627},{0.6,0.6,0.6},{0.29803921568627,0.6,0.69803921568627},{0.69803921568627,0.4,0.89803921568627},{0.2,0.4,0.8},{0.49803921568627,0.4,0.29803921568627},{0.34117647058824,0.65098039215686,0.30588235294118},{0.8,0.29803921568627,0.29803921568627},{0.066666666666667,0.066666666666667,0.066666666666667}}for F=0,15 do R.dirtyPalette[F]=true end end;for F=16,255 do R.palette[F]={0,0,0}R.dirtyPalette[F]=true end;local j=setmetatable({},{__name=\"GFXTerminal\"})function j.close()end;function j.getSize()return Q.width*6,Q.height*9 end;function j.clear()for f=1,Q.height*9 do R[f]=('\\15'):rep(Q.width*6)end;j.redraw(true)end;function j.getPixel(e,f)a(1,e,\"number\")a(2,f,\"number\")a.range(e,0,Q.width*6-1)a.range(f,0,Q.height*9-1)e,f=math.floor(e),math.floor(f)return R[f+1]:byte(e+1)end;function j.setPixel(e,f,k)a(1,e,\"number\")a(2,f,\"number\")a(3,k,\"number\")a.range(e,0,Q.width*6-1)a.range(f,0,Q.height*9-1)a.range(k,0,255)e,f=math.floor(e),math.floor(f)R[f+1]=R[f+1]:sub(1,e)..string.char(k)..R[f+1]:sub(e+2)R.dirtyRects[#R.dirtyRects+1]={x=e,y=f,color=k}j.redraw()end;function j.getPixels(e,f,g,h,J)a(1,e,\"number\")a(2,f,\"number\")a(3,g,\"number\")a(4,h,\"number\")a(5,J,\"boolean\",\"nil\")a.range(g,0)a.range(h,0)e,f=math.floor(e),math.floor(f)local S={}for T=1,h do if J then S[T]=R[f+T]:sub(e+1,e+g)else S[T]={R[f+T]:sub(e+1,e+g):byte(1,-1)}end end;return S end;function j.drawPixels(e,f,K,g,h)a(1,e,\"number\")a(2,f,\"number\")a(3,K,\"table\",\"number\")local U=type(K)==\"number\"a(4,g,\"number\",not U and\"nil\"or nil)a(5,h,\"number\",not U and\"nil\"or nil)a.range(e,0,Q.width*6-1)a.range(f,0,Q.height*9-1)if g then a.range(g,0)end;if h then a.range(h,0)end;if U then a.range(K,0,255)end;if g==0 or h==0 then return end;e,f=math.floor(e),math.floor(f)if g and e+g>=Q.width*6 then g=Q.width*6-e end;h=h or#K;local V={x=e,y=f,width=g,height=h}for T=1,h do if f+T>Q.height*9 then break end;if U then local W=string.char(K):rep(g)R[f+T]=R[f+T]:sub(1,e)..W..R[f+T]:sub(e+g+1)V[T]=W elseif K[T]~=nil then if type(K[T])~=\"table\"and type(K[T])~=\"string\"then error(\"bad argument #3 to 'drawPixels' (invalid row \"..T..\")\",2)end;local g=g or#K[T]if e+g>=Q.width*6 then g=Q.width*6-e end;local W;if type(K[T])==\"string\"then W=K[T]if#W<g then W=W..('\\15'):rep(g-#W)elseif#W>g then W=W:sub(1,g)end else W=\"\"for X=1,g do W=W..string.char(K[T][X]or R[f+T]:byte(e+X))end end;R[f+T]=R[f+T]:sub(1,e)..W..R[f+T]:sub(e+g+1)V[T]=W end end;R.dirtyRects[#R.dirtyRects+1]=V;j.redraw()end;function j.getFrozen()return R.frozen end;function j.setFrozen(Y)a(1,Y,\"boolean\")R.frozen=Y;j.redraw()end;function j.getPaletteColor(k)a(1,k,\"number\")a.range(k,0,255)return table.unpack(R.palette[k])end;function j.setPaletteColor(k,l,m,n)a(1,k,\"number\")a(2,l,\"number\")if m==nil and n==nil then l,m,n=bit32.band(bit32.rshift(l,16),0xFF)/255,bit32.band(bit32.rshift(l,8),0xFF)/255,bit32.band(l,0xFF)/255 end;a(3,m,\"number\")a(4,n,\"number\")a.range(l,0,1)a.range(m,0,1)a.range(n,0,1)a.range(k,0,255)R.palette[k]={l,m,n}R.dirtyPalette[k]=true;j.redraw()end;function j.getPosition()return M,N end;function j.getParent()return d end;function j.reposition(e,f,q,r,s)a(1,e,\"number\",\"nil\")a(2,f,\"number\",\"nil\")M=e or M;N=f or N;if s then j.reparent(s)end;if q or r then return j.resize(q,r)end end;function j.resize(g,h)a(1,g,\"number\",\"nil\")a(2,h,\"number\",\"nil\")if g>Q.width then for f=1,Q.height*9 do R[f]=R[f]..('\\15'):rep((g-Q.width)*6)end;R.dirtyRects[#R.dirtyRects+1]={x=Q.width*6+1,y=1,width=(g-Q.width)*6,height=Q.height*9}elseif g<Q.width then for f=1,Q.height*9 do R[f]=R[f]:sub(1,g*6)end end;Q.width=g;if h>Q.height then for f=Q.height*9+1,h*9 do R[f]=('\\15'):rep(g*6)end;R.dirtyRects[#R.dirtyRects+1]={x=1,y=Q.height*9+1,width=Q.width*6,height=(h-Q.height)*9}elseif h<Q.height then for f=h*9+1,Q.height*9 do R[f]=nil end end;Q.height=h end;function j.reparent(s)a(1,s,\"GFXTerminal\",\"nil\")d=s;j.redraw()end;function j.redraw(Z)if not d or not O then return end;if d.setFrozen then d.setFrozen(true)end;if Z then d.clear()d.drawPixels(0,0,R)for F=0,255 do d.setPaletteColor(F,R.palette[F][1],R.palette[F][2],R.palette[F][3])end else if R.frozen then if d.setFrozen then d.setFrozen(false)end;return end;for _,a0 in ipairs(R.dirtyRects)do if a0.color then d.setPixel(a0.x,a0.y,a0.color,a0.width,a0.height)else d.drawPixels(a0.x,a0.y,a0)end end;for F in pairs(R.dirtyPalette)do d.setPaletteColor(F,R.palette[F][1],R.palette[F][2],R.palette[F][3])end end;if d.setFrozen then d.setFrozen(false)end;R.dirtyRects,R.dirtyPalette={},{}end;function j.isVisible()return O end;function j.setVisible(a0)a(1,a0,\"boolean\")O=a0;j.redraw()end;j.getPaletteColour=j.getPaletteColor;j.setPaletteColour=j.setPaletteColor;j.redraw()return j else local R={cursor={x=1,y=1},cursorBlink=false,colors={fg='0',bg='f'},palette={},dirtyLines={},dirtyPalette={}}for f=1,Q.height do R[f]={(' '):rep(Q.width),('0'):rep(Q.width),('f'):rep(Q.width)}R.dirtyLines[f]=true end;if d then for F=0,15 do R.palette[F]={d.getPaletteColor(F)}R.dirtyPalette[F]=true end else R.palette={[0]={0.94117647058824,0.94117647058824,0.94117647058824},{0.94901960784314,0.69803921568627,0.2},{0.89803921568627,0.49803921568627,0.84705882352941},{0.6,0.69803921568627,0.94901960784314},{0.87058823529412,0.87058823529412,0.42352941176471},{0.49803921568627,0.8,0.098039215686275},{0.94901960784314,0.69803921568627,0.8},{0.29803921568627,0.29803921568627,0.29803921568627},{0.6,0.6,0.6},{0.29803921568627,0.6,0.69803921568627},{0.69803921568627,0.4,0.89803921568627},{0.2,0.4,0.8},{0.49803921568627,0.4,0.29803921568627},{0.34117647058824,0.65098039215686,0.30588235294118},{0.8,0.29803921568627,0.29803921568627},{0.066666666666667,0.066666666666667,0.066666666666667}}for F=0,15 do R.dirtyPalette[F]=true end end;local j=setmetatable({},{__name=\"Terminal\"})function j.close()end;function j.write(y)y=tostring(y)a(1,y,\"string\")if R.cursor.y<1 or R.cursor.y>Q.height then return elseif R.cursor.x>Q.width or R.cursor.x+#y<1 then R.cursor.x=R.cursor.x+#y;return elseif R.cursor.x<1 then y=y:sub(-R.cursor.x+2)R.cursor.x=1 end;local a1=#y;if R.cursor.x+#y>Q.width then y=y:sub(1,Q.width-R.cursor.x+1)end;R[R.cursor.y][1]=R[R.cursor.y][1]:sub(1,R.cursor.x-1)..y..R[R.cursor.y][1]:sub(R.cursor.x+#y)R[R.cursor.y][2]=R[R.cursor.y][2]:sub(1,R.cursor.x-1)..R.colors.fg:rep(#y)..R[R.cursor.y][2]:sub(R.cursor.x+#y)R[R.cursor.y][3]=R[R.cursor.y][3]:sub(1,R.cursor.x-1)..R.colors.bg:rep(#y)..R[R.cursor.y][3]:sub(R.cursor.x+#y)R.cursor.x=R.cursor.x+a1;R.dirtyLines[R.cursor.y]=true;j.redraw()end;function j.blit(y,w,x)y=tostring(y)a(1,y,\"string\")a(2,w,\"string\")a(3,x,\"string\")if#y~=#w or#w~=#x then error(\"Arguments must be the same length\",2)end;if R.cursor.y<1 or R.cursor.y>Q.height then return elseif R.cursor.x>Q.width or R.cursor.x<1-#y then R.cursor.x=R.cursor.x+#y;j.redraw()return elseif R.cursor.x<1 then y,w,x=y:sub(-R.cursor.x+2),w:sub(-R.cursor.x+2),x:sub(-R.cursor.x+2)R.cursor.x=1 end;local a1=#y;if R.cursor.x+#y>Q.width then y,w,x=y:sub(1,Q.width-R.cursor.x+1),w:sub(1,Q.width-R.cursor.x+1),x:sub(1,Q.width-R.cursor.x+1)end;R[R.cursor.y][1]=R[R.cursor.y][1]:sub(1,R.cursor.x-1)..y..R[R.cursor.y][1]:sub(R.cursor.x+#y)R[R.cursor.y][2]=R[R.cursor.y][2]:sub(1,R.cursor.x-1)..w..R[R.cursor.y][2]:sub(R.cursor.x+#w)R[R.cursor.y][3]=R[R.cursor.y][3]:sub(1,R.cursor.x-1)..x..R[R.cursor.y][3]:sub(R.cursor.x+#x)R.cursor.x=R.cursor.x+a1;R.dirtyLines[R.cursor.y]=true;j.redraw()end;function j.clear()for f=1,Q.height do R[f]={(' '):rep(Q.width),R.colors.fg:rep(Q.width),R.colors.bg:rep(Q.width)}R.dirtyLines[f]=true end;j.redraw()end;function j.clearLine()if R.cursor.y>=1 and R.cursor.y<=Q.height then R[R.cursor.y]={(' '):rep(Q.width),R.colors.fg:rep(Q.width),R.colors.bg:rep(Q.width)}R.dirtyLines[R.cursor.y]=true;j.redraw()end end;function j.getCursorPos()return R.cursor.x,R.cursor.y end;function j.setCursorPos(t,u)a(1,t,\"number\")a(2,u,\"number\")if t==R.cursor.x and u==R.cursor.y then return end;R.cursor.x,R.cursor.y=math.floor(t),math.floor(u)j.redraw()end;function j.getCursorBlink()return R.cursorBlink end;function j.setCursorBlink(n)a(1,n,\"boolean\")R.cursorBlink=n;j.redraw()end;function j.isColor()return true end;function j.getSize()return Q.width,Q.height end;function j.scroll(E)a(1,E,\"number\")if math.abs(E)>=Q.width then for f=1,Q.height do R[f]={(' '):rep(Q.width),R.colors.fg:rep(Q.width),R.colors.bg:rep(Q.width)}end elseif E>0 then for F=E+1,Q.height do R[F-E]=R[F]end;for F=Q.height-E+1,Q.height do R[F]={(' '):rep(Q.width),R.colors.fg:rep(Q.width),R.colors.bg:rep(Q.width)}end elseif E<0 then for F=1,Q.height+E do R[F-E]=R[F]end;for F=1,-E do R[F]={(' '):rep(Q.width),R.colors.fg:rep(Q.width),R.colors.bg:rep(Q.width)}end else return end;for F=1,Q.height do R.dirtyLines[F]=true end;j.redraw()end;function j.getTextColor()return tonumber(R.colors.fg)end;function j.setTextColor(k)a(1,k,\"number\")a.range(k,0,15)R.colors.fg=(\"%x\"):format(k)end;function j.getBackgroundColor()return tonumber(R.colors.bg)end;function j.setBackgroundColor(k)a(1,k,\"number\")a.range(k,0,15)R.colors.bg=(\"%x\"):format(k)end;function j.getPaletteColor(k)a(1,k,\"number\")a.range(k,0,15)return table.unpack(R.palette[math.floor(k)])end;function j.setPaletteColor(k,l,m,n)a(1,k,\"number\")a(2,l,\"number\")if m==nil and n==nil then l,m,n=bit32.band(bit32.rshift(l,16),0xFF)/255,bit32.band(bit32.rshift(l,8),0xFF)/255,bit32.band(l,0xFF)/255 end;a(3,m,\"number\")a(4,n,\"number\")a.range(k,0,15)if l<0 or l>1 then error(\"bad argument #2 (value out of range)\",2)end;if m<0 or m>1 then error(\"bad argument #3 (value out of range)\",2)end;if n<0 or n>1 then error(\"bad argument #4 (value out of range)\",2)end;R.palette[math.floor(k)]={l,m,n}R.dirtyPalette[math.floor(k)]=true;j.redraw()end;function j.getLine(f)a(1,f,\"number\")local G=R[f]return G and table.unpack(G,1,3)end;function j.getPosition()return M,N end;function j.getParent()return d end;function j.reposition(e,f,q,r,s)a(1,e,\"number\",\"nil\")a(2,f,\"number\",\"nil\")M=e or M;N=f or N;if s then j.reparent(s)end;if e or f then j.redraw(true)end;if q or r then return j.resize(q,r)end end;function j.resize(g,h)a(1,g,\"number\",\"nil\")a(2,h,\"number\",\"nil\")if g>Q.width then for f=1,Q.height do R[f][1]=R[f][1]..(' '):rep(g-Q.width)R[f][2]=R[f][2]..R.colors.fg:rep(g-Q.width)R[f][3]=R[f][3]..R.colors.bg:rep(g-Q.width)R.dirtyLines[f]=true end elseif g<Q.width then for f=1,Q.height do R[f][1]=R[f][1]:sub(1,g)R[f][2]=R[f][2]:sub(1,g)R[f][3]=R[f][3]:sub(1,g)end end;Q.width=g;if h>Q.height then for f=Q.height+1,h do R[f]={(' '):rep(g),R.colors.fg:rep(g),R.colors.bg:rep(g)}R.dirtyLines[f]=true end elseif h<Q.height then for f=h+1,Q.height do R[f]=nil end end;Q.height=h end;function j.reparent(s)a(1,s,\"Terminal\",\"nil\")d=s;j.redraw()end;function j.redraw(Z)if not d or not O then return end;d.setCursorBlink(false)if Z then d.clear()for f=1,Q.height do d.setCursorPos(M,N+f-1)d.blit(R[f][1],R[f][2],R[f][3])end;for F=0,15 do d.setPaletteColor(F,R.palette[F][1],R.palette[F][2],R.palette[F][3])end else for f in pairs(R.dirtyLines)do d.setCursorPos(M,N+f-1)if#R[f][1]~=#R[f][2]or#R[f][2]~=#R[f][3]then error(\"Internal error: Invalid lengths\")end;d.blit(R[f][1],R[f][2],R[f][3])end;for F in pairs(R.dirtyPalette)do d.setPaletteColor(F,R.palette[F][1],R.palette[F][2],R.palette[F][3])end end;d.setCursorPos(M+R.cursor.x-1,N+R.cursor.y-1)d.setCursorBlink(R.cursorBlink)R.dirtyLines,R.dirtyPalette={},{}end;function j.restoreCursor()if not d or not O then return end;d.setCursorPos(M+R.cursor.x-1,N+R.cursor.y-1)d.setCursorBlink(R.cursorBlink)end;function j.isVisible()return O end;function j.setVisible(a0)a(1,a0,\"boolean\")O=a0;j.redraw()end;j.isColour=j.isColor;j.getTextColour=j.getTextColor;j.setTextColour=j.setTextColor;j.getBackgroundColour=j.getBackgroundColor;j.setBackgroundColour=j.setBackgroundColor;j.getPaletteColour=j.getPaletteColor;j.setPaletteColour=j.setPaletteColor;j.redraw()return j end end;return c\ngraphics.lua/   0           0     0     644     6638      `\nlocal a=require\"expect\"local b=require\"util\"local c={}function c.drawPixel(d,e,f,g)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,e,\"number\")a(3,f,\"number\")a(4,g,\"number\")if b.type(d)==\"Terminal\"then local h,i=d.getCursorPos()local j=d.getBackgroundColor()d.setCursorPos(e,f)d.setBackgroundColor(g)d.write(\" \")d.setCursorPos(h,i)d.setBackgroundColor(j)else d.setPixel(e-1,f-1,g)end end;local function k(l,m,n,o,p)if math.abs(p-n)<math.abs(o-m)then if m>o then m,n,o,p=o,p,m,n end;local q,r,s=o-m,p-n,1;if r<0 then s,r=-1,-r end;local t,f=2*r-q,n;if s<0 then f=p;for e=o,m,-1 do l(e,f)if t>0 then f=f+1;t=t+2*(r-q)else t=t+2*r end end else for e=m,o do l(e,f)if t>0 then f=f+1;t=t+2*(r-q)else t=t+2*r end end end else if n>p then m,n,o,p=o,p,m,n end;local q,r,u=o-m,p-n,1;if q<0 then u,q=-1,-q end;local t,e=2*q-r,m;for f=n,p do l(e,f)if t>0 then e=e+u;t=t+2*(q-r)else t=t+2*q end end end end;function c.drawLine(d,m,n,o,p,g)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,m,\"number\")a(3,n,\"number\")a(4,o,\"number\")a(5,p,\"number\")a(6,g,\"number\")if n==p then local v=math.abs(o-m)+1;if b.type(d)==\"Terminal\"then local w,x=d.getBackgroundColor(),d.getTextColor()local h,i=d.getCursorPos()local y,z=(\"%x\"):format(x),(\"%x\"):format(g)d.setCursorPos(m,n)d.blit((\" \"):rep(v),y:rep(v),z:rep(v))d.setCursorPos(h,i)d.setBackgroundColor(w)else d.drawPixels(m-1,n-1,g,v,1)end;return elseif m==o and b.type(d)==\"GFXTerminal\"then d.drawPixels(m-1,n-1,g,1,math.abs(p-n)+1)end;local l,A;if b.type(d)==\"Terminal\"then local j=d.getBackgroundColor()local h,i=d.getCursorPos()d.setBackgroundColor(g)l,A=function(e,f)d.setCursorPos(e,f)d.write(\" \")end,function()d.setBackgroundColor(j)d.setCursorPos(h,i)end else l,A=function(e,f)d.setPixel(e-1,f-1,g)end,function()end end;k(l,m,n,o,p)A()end;function c.drawBox(d,e,f,v,B,g)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,e,\"number\")a(3,f,\"number\")a(4,v,\"number\")a(5,B,\"number\")a(6,g,\"number\")if b.type(d)==\"Terminal\"then local w,x=d.getBackgroundColor(),d.getTextColor()local h,i=d.getCursorPos()local y,z=(\"%x\"):format(x),(\"%x\"):format(g)d.setCursorPos(e,f)d.blit((\" \"):rep(v),y:rep(v),z:rep(v))d.setCursorPos(e,f+B-1)d.blit((\" \"):rep(v),y:rep(v),z:rep(v))for C=f+1,f+B-2 do d.setCursorPos(e,C)d.blit(\" \",y,z)d.setCursorPos(e+v-1,C)d.blit(\" \",y,z)end;d.setBackgroundColor(w)d.setCursorPos(h,i)else d.drawPixels(e-1,f-1,g,v,1)d.drawPixels(e-1,f-1,g,1,B)d.drawPixels(e-1,f+B-1,g,v,1)d.drawPixels(e+v-1,f-1,g,1,B)end end;function c.drawFilledBox(d,e,f,v,B,g)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,e,\"number\")a(3,f,\"number\")a(4,v,\"number\")a(5,B,\"number\")a(6,g,\"number\")if b.type(d)==\"Terminal\"then local w,x=d.getBackgroundColor(),d.getTextColor()local h,i=d.getCursorPos()local D,y,z=(\" \"):rep(v),(\"%x\"):format(x):rep(v),(\"%x\"):format(g):rep(v)for C=f,f+B-1 do d.setCursorPos(e,C)d.blit(D,y,z)end;d.setBackgroundColor(w)d.setCursorPos(h,i)else d.drawPixels(e-1,f-1,g,v,B)end end;function c.drawCircle(d,e,f,v,B,g,E,F)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,e,\"number\")a(3,f,\"number\")a(4,v,\"number\")a(5,B,\"number\")a(6,g,\"number\")E=(a(7,E,\"number\",\"nil\")or 0)%(2*math.pi)F=(a(8,F,\"number\",\"nil\")or 0)%(2*math.pi)if F==0 then F=2*math.pi end;local l,A;if b.type(d)==\"Terminal\"then local j=d.getBackgroundColor()local h,i=d.getCursorPos()d.setBackgroundColor(g)l,A=function(G,C)d.setCursorPos(G,C)d.write(\" \")end,function()d.setBackgroundColor(j)d.setCursorPos(h,i)end else l,A=function(G,C)d.setPixel(G-1,C-1,g)end,function()end end;local H=math.pi/(v+B)v,B=v/2,B/2;for I=E,E+F,H do local G,C=v*math.cos(I)+v,B*math.sin(I)+B;l(e+G,f+C)end;A()end;function c.drawFilledTriangle(d,m,n,o,p,J,K,g)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,m,\"number\")a(3,n,\"number\")a(4,o,\"number\")a(5,p,\"number\")a(6,J,\"number\")a(7,K,\"number\")a(8,g,\"number\")local L,A;if b.type(d)==\"Terminal\"then local w,x=d.getBackgroundColor(),d.getTextColor()local h,i=d.getCursorPos()local z,y=(\"%x\"):format(g),(\"%x\"):format(x)L,A=function(G,C,M)d.setCursorPos(G,C)d.blit((\" \"):rep(M),y:rep(M),z:rep(M))end,function()d.setBackgroundColor(w)d.setTextColor(x)d.setCursorPos(h,i)end else L,A=function(G,C,M)d.drawPixels(G-1,C-1,g,M,1)end,function()end end;local N={{x=m,y=n},{x=o,y=p},{x=J,y=K}}table.sort(N,function(O,w)return O.y<w.y end)if N[1].y==N[2].y then if N[2].y==N[3].y then local q=math.min(N[1].x,N[2].x,N[3].x)L(q,N[1].y,math.max(N[1].x,N[2].x,N[3].x)-q)A()return end;if N[1].x>N[2].x then N[1],N[2]=N[2],N[1]end;local P,Q=coroutine.create(k),coroutine.create(k)local R,S,T=coroutine.resume(P,coroutine.yield,N[1].x,N[1].y,N[3].x,N[3].y)local R,U,V=coroutine.resume(Q,coroutine.yield,N[2].x,N[2].y,N[3].x,N[3].y)local W,X=S,U;while V do repeat W=math.min(W,S)R,S,T=coroutine.resume(P)until T~=V;repeat X=math.max(X,U)R,U,T=coroutine.resume(Q)until T~=V;L(W,V,X-W+1)W,X,V=S,U,T end elseif N[2].y==N[3].y then if N[2].x>N[3].x then N[2],N[3]=N[3],N[2]end;local P,Q=coroutine.create(k),coroutine.create(k)local R,S,T=coroutine.resume(P,coroutine.yield,N[1].x,N[1].y,N[2].x,N[2].y)local R,U,V=coroutine.resume(Q,coroutine.yield,N[1].x,N[1].y,N[3].x,N[3].y)local W,X=S,U;while V do repeat W=math.min(W,S)R,S,T=coroutine.resume(P)until T~=V;repeat X=math.max(X,U)R,U,T=coroutine.resume(Q)until T~=V;L(W,V,X-W+1)W,X,V=S,U,T end else local P,Q=coroutine.create(k),coroutine.create(k)local R,S,T=coroutine.resume(P,coroutine.yield,N[1].x,N[1].y,N[3].x,N[3].y)local R,U,V=coroutine.resume(Q,coroutine.yield,N[1].x,N[1].y,N[2].x,N[2].y)local W,X=S,U;while S and U and V do repeat W=math.min(W,S)X=math.max(X,S)R,S,T=coroutine.resume(P)until T~=V;if V==N[2].y then Q=coroutine.create(k)R,U,T=coroutine.resume(Q,coroutine.yield,N[2].x,N[2].y,N[3].x,N[3].y)end;repeat W=math.min(W,U)X=math.max(X,U)R,U,T=coroutine.resume(Q)until T~=V;L(W,V,X-W+1)W,X,V=math.min(S or 0,U or 0),math.max(S or 0,U or 0),T end end;A()end;function c.drawImage(d,e,f,Y)a(1,d,\"Terminal\",\"GFXTerminal\")a(2,e,\"number\")a(3,f,\"number\")a(4,Y,\"table\")if b.type(d)==\"Terminal\"then local w,x=d.getBackgroundColor(),d.getTextColor()local h,i=d.getCursorPos()local y=(\"%x\"):format(x)for C=1,#Y do a.field(Y,C,\"string\",\"table\")d.setCursorPos(e,f+C-1)local L=Y[C]if type(L)==\"string\"then local z=L:gsub(\"[\\16-\\255]\",\" \"):gsub(\"[%z-\\15]\",function(j)return(\"%x\"):format(j:byte())end)d.blit((\" \"):rep(#z),y:rep(#z),z)elseif#L==3 and type(L[1]==\"string\")then d.blit(L[1],L[2],L[3])else local z=\"\"for Z=1,#L do a(L,Z,\"number\")z=z..(\"%x\"):format(L[Z])end;d.blit((\" \"):rep(#z),y:rep(#z),z)end end;d.setBackgroundColor(w)d.setTextColor(x)d.setCursorPos(h,i)else if type(Y[1])==\"table\"and type(Y[1][1])==\"string\"then error(\"bad argument #4 to 'drawImage' (image type not supported on this terminal)\",2)end;return d.drawPixels(e-1,f-1,Y)end end;return c\nhardware.lua/   0           0     0     644     3104      `\nlocal a=require\"expect\"local b=require\"util\"local c={}function c.wrap(d)a(1,d,\"string\",\"device\",\"devicetree\")if type(d)~=\"string\"then d=getmetatable(d).uuid end;local e=b.syscall.devinfo(d)if not e then return nil end;local f,g=b.syscall.devmethods(d),b.syscall.devproperties(d)for h,i in ipairs(g)do g[i]=true end;local j={}for h,i in ipairs(f)do j[i]=function(self,...)return b.syscall.devcall(d,i,...)end end;return setmetatable(j,{__name=\"device\",uuid=e.uuid,__index=function(self,k)if type(k)==\"string\"and g[k]then return b.syscall.devcall(d,\"get\"..k:gsub(\"^.\",string.upper))end end,__newindex=function(self,k,l)if type(k)==\"string\"and g[k]and self[\"set\"..k:gsub(\"^.\",string.upper)]then return b.syscall.devcall(d,\"set\"..k:gsub(\"^.\",string.upper),l)end end,__tostring=function(self)return\"wrapped device: \"..(e.displayName or e.uuid)end})end;function c.find(type)a(1,type,\"string\")local j={}for m,i in ipairs{b.syscall.devfind(type)}do j[m]=c.wrap(i)end;return table.unpack(j)end;function c.path(d)a(1,d,\"string\",\"device\",\"devicetree\")if type(d)==\"string\"then return b.syscall.devlookup(d)else return b.syscall.devlookup(getmetatable(d).uuid)end end;function c.hasType(d,n)a(1,d,\"string\",\"device\",\"devicetree\")a(2,n,\"string\")local e;if type(d)==\"string\"then e=b.syscall.devinfo(d)else e=b.syscall.devinfo(getmetatable(d).uuid)end;if not e then error(\"No such device\",2)end;return e.types[n]~=nil end;function c.info(d)a(1,d,\"string\",\"device\",\"devicetree\")if type(d)==\"string\"then return b.syscall.devinfo(d)else return b.syscall.devinfo(getmetatable(d).uuid)end end;function c.methods(d)a(1,d,\"string\",\"device\",\"devicetree\")if type(d)==\"string\"then return b.syscall.devmethods(d)else return b.syscall.devmethods(getmetatable(d).uuid)end end;function c.properties(d)a(1,d,\"string\",\"device\",\"devicetree\")if type(d)==\"string\"then return b.syscall.devproperties(d)else return b.syscall.devproperties(getmetatable(d).uuid)end end;function c.children(d)a(1,d,\"string\",\"device\",\"devicetree\")if type(d)==\"string\"then return b.syscall.devchildren(d)else return b.syscall.devchildren(getmetatable(d).uuid)end end;function c.call(d,o,...)a(1,d,\"string\",\"device\",\"devicetree\")a(2,o,\"string\")if type(d)==\"string\"then return b.syscall.devcall(d,o,...)else return b.syscall.devcall(getmetatable(d).uuid,o,...)end end;function c.listen(d,p)a(1,d,\"string\",\"device\",\"devicetree\")a(2,p,\"boolean\",\"nil\")if type(d)==\"string\"then return b.syscall.devlisten(d,p)else return b.syscall.devlisten(getmetatable(d).uuid,p)end end;function c.lock(d,q)a(1,d,\"string\",\"device\",\"devicetree\")a(2,q,\"boolean\",\"nil\")if type(d)==\"string\"then return b.syscall.devlock(d,q)else return b.syscall.devlock(getmetatable(d).uuid,q)end end;function c.unlock(d)a(1,d,\"string\",\"device\",\"devicetree\")if type(d)==\"string\"then return b.syscall.devunlock(d)else return b.syscall.devunlock(getmetatable(d).uuid)end end;local function r(s)local e=c.info(s or\"/\")if not e then return nil end;s=s or\"\"return setmetatable({},{__name=\"devicetree\",uuid=e.uuid,__index=function(self,k)return r(s..\"/\"..k)end,__newindex=function()end})end;c.tree=r()return c\ninit.lua/       0           0     0     644     341       `\nreturn{expect=require\"expect\",filesystem=require\"filesystem\",framebuffer=require\"framebuffer\",graphics=require\"graphics\",hardware=require\"hardware\",keys=require\"keys\",log=require\"log\",network=require\"network\",pretty=require\"pretty\",process=require\"process\",serialization=require\"serialization\",terminal=require\"terminal\",util=require\"util\"}\n\nipc.lua/        0           0     0     644     1133      `\nlocal a=require\"expect\"local b=require\"util\"local c={}c.signal={SIGHUP=1,SIGINT=2,SIGQUIT=3,SIGTRAP=5,SIGABRT=6,SIGKILL=9,SIGPIPE=13,SIGTERM=15,SIGCONT=18,SIGSTOP=19,SIGTTIN=21,SIGTTOU=22}function c.kill(d,e)a(1,d,\"number\")a(2,e,\"number\")return b.syscall.kill(d,e)end;function c.sigaction(e,f)a(1,e,\"number\")a(2,f,\"function\",\"nil\")return b.syscall.signal(e,f)end;function c.sendEvent(d,g,h)a(1,d,\"number\")a(2,g,\"string\")a(3,h,\"table\")return b.syscall.sendEvent(d,g,h)end;function c.register(i)a(1,i,\"string\")return b.syscall.register(i)end;function c.lookup(i)a(1,i,\"string\")return b.syscall.lookup(i)end;function c.sendServiceEvent(i,g,h)a(1,i,\"string\")a(2,g,\"string\")a(3,h,\"table\")local d=b.syscall.lookup(i)if not d then return false end;return b.syscall.sendEvent(d,g,h)end;function c.receiveEvent(d,g,j)a(1,d,\"number\",\"nil\")a(2,g,\"string\",\"nil\")a(3,j,\"number\",\"nil\")local k;if j then k=b.timer(j)end;while true do local l,h=coroutine.yield()if l==\"timer\"and h.id==k then return nil elseif l==\"remote_event\"and(d==nil or d==h.sender)and(g==nil or g==h.type)then if k then b.cancel(k)end;return h.type,h.data end end end;return c\n\nkeys.lua/       0           0     0     644     1542      `\nlocal a={}for b=0x61,0x7A do a[string.char(b)]=b end;for b=0x81,0x99 do a[\"f\"..bit32.band(b,31)]=b end;for b=0xA0,0xA9 do a[\"numPad\"..bit32.band(b,15)]=b end;a.backspace=0x08;a.tab=0x09;a.enter=0x0A;a.space=0x20;a.apostrophe=0x27;a.comma=0x2C;a.minus=0x2D;a.period=0x2E;a.slash=0x2F;a.zero=0x30;a.one=0x31;a.two=0x32;a.three=0x33;a.four=0x34;a.five=0x35;a.six=0x36;a.seven=0x37;a.eight=0x38;a.nine=0x39;a.semicolon=0x3B;a.equals=0x3D;a.leftBracket=0x5B;a.backslash=0x5C;a.rightBracket=0x5D;a.grave=0x60;a.delete=0x7F;a.insert=0x80;a.convert=0x9A;a.noconvert=0x9B;a.kana=0x9C;a.kanji=0x9D;a.yen=0x9E;a.numPadDecimal=0x9F;a.numPadAdd=0xAA;a.numPadSubtract=0xAB;a.numPadMultiply=0xAC;a.numPadDivide=0xAD;a.numPadEqual=0xAE;a.numPadEnter=0xAF;a.leftCtrl=0xB0;a.rightCtrl=0xB1;a.leftAlt=0xB2;a.rightAlt=0xB3;a.leftShift=0xB4;a.rightShift=0xB5;a.leftSuper=0xB6;a.rightSuper=0xB7;a.capsLock=0xB8;a.numLock=0xB9;a.scrollLock=0xBA;a.printScreen=0xBB;a.pause=0xBC;a.menu=0xBD;a.stop=0xBE;a.ax=0xBF;a.up=0xC0;a.down=0xC1;a.left=0xC2;a.right=0xC3;a.pageUp=0xC4;a.pageDown=0xC5;a.home=0xC6;a[\"end\"]=0xC7;a.circumflex=0xC8;a.at=0xC9;a.colon=0xCA;a.underscore=0xCB;local c={}for d,e in pairs(a)do c[e]=d end;function a.getName(f)if type(f)~=\"number\"then error(\"bad argument #1 (expected number, got \"..type(f)..\")\",2)end;return c[f]end;function a.getCharacter(f)if type(f)~=\"number\"then error(\"bad argument #1 (expected number, got \"..type(f)..\")\",2)end;if f>=0x20 and f<0x7F or f==0x0A or f==0x09 then return string.char(f)else return nil end end;return a\nlog.lua/        0           0     0     644     2163      `\nlocal a=require\"expect\"local b=require\"util\"local function c(self,...)return self.log(...)end;local d={debug=0,info=1,notice=2,warning=3,error=4,critical=5}local function e(f)local g={}function g.log(h,...)if type(h)==\"table\"then h.name=f;return b.syscall.syslog(h,...)else return b.syscall.syslog({name=f},h,...)end end;function g.debug(h,...)if type(h)==\"table\"then h.name=f;h.level=d.debug;return b.syscall.syslog(h,...)else return b.syscall.syslog({name=f,level=d.debug},h,...)end end;function g.info(h,...)if type(h)==\"table\"then h.name=f;h.level=d.info;return b.syscall.syslog(h,...)else return b.syscall.syslog({name=f,level=d.info},h,...)end end;function g.notice(h,...)if type(h)==\"table\"then h.name=f;h.level=d.notice;return b.syscall.syslog(h,...)else return b.syscall.syslog({name=f,level=d.notice},h,...)end end;function g.warning(h,...)if type(h)==\"table\"then h.name=f;h.level=d.warning;return b.syscall.syslog(h,...)else return b.syscall.syslog({name=f,level=d.warning},h,...)end end;g.warn=g.warning;function g.error(h,...)if type(h)==\"table\"then h.name=f;h.level=d.error;return b.syscall.syslog(h,...)else return b.syscall.syslog({name=f,level=d.error},h,...)end end;function g.critical(h,...)if type(h)==\"table\"then h.name=f;h.level=d.critical;return b.syscall.syslog(h,...)else return b.syscall.syslog({name=f,level=d.critical},h,...)end end;function g.traceback(i)a(1,i,\"string\",\"nil\")return b.syscall.syslog({name=f,level=d.error,traceback=true},debug.traceback(i,2))end;return setmetatable(g,{__call=c})end;local g=e()g.levels={debug=0,info=1,notice=2,warning=3,error=4,critical=5}function g.create(f,j,k)a(1,f,\"string\")a(2,j,\"boolean\",\"nil\")a(3,k,\"string\",\"nil\")b.syscall.mklog(f,j,k)return e(f)end;function g.remove(f)a(1,f,\"string\")return b.syscall.rmlog(f)end;function g.open(f,l)a(1,f,\"string\")a(2,l,\"string\",\"nil\")return b.syscall.openlog(f,l)end;function g.close(f)a(1,f,\"string\",\"number\")return b.syscall.closelog(f)end;function g.setTTY(f,m,n)a(1,f,\"string\")a(2,m,\"table\",\"nil\")a(3,n,\"number\",\"nil\")return b.syscall.logtty(f,m,n)end;return setmetatable(g,{__call=c,__index=function(o,p)if type(p)==\"string\"then return e(p)end end})\n\nnetwork.lua/    0           0     0     644     4949      `\nlocal a=require\"util\"local b=require\"expect\"local c={route={},arp={}}function c.connect(d)b(1,d,\"table\",\"string\")if type(d)==\"table\"then b.field(d,\"url\",\"string\")end;return a.syscall.connect(d)end;function c.get(d)b(1,d,\"table\",\"string\")if type(d)==\"table\"then b.field(d,\"url\",\"string\")if not d.url:match(\"^https?://\")then error(\"Invalid scheme\",2)end elseif not d:match(\"^https?://\")then error(\"Invalid scheme\",2)end;local e=a.syscall.connect(d)e:write()while true do local f,g=coroutine.yield()if f==\"handle_status_change\"and g.id==e.id then if g.status==\"open\"then return e elseif g.status==\"error\"then return nil,select(2,e:status())end end end end;function c.getData(h,i)b(1,h,\"string\")b(2,i,\"table\",\"nil\")if not h:match(\"^https?://\")then error(\"Invalid scheme\",2)end;local e=a.syscall.connect{url=h,encoding=\"binary\",headers=i}e:write()while true do local f,g=coroutine.yield()if f==\"handle_status_change\"and g.id==e.id then if g.status==\"open\"then local j=e:read(\"*a\")e:close()return j elseif g.status==\"error\"then return nil,select(2,e:status())end end end end;function c.head(d)b(1,d,\"table\",\"string\")if type(d)==\"table\"then b.field(d,\"url\",\"string\")if not d.url:match(\"^https?://\")then error(\"Invalid scheme\",2)end else if not d:match(\"^https?://\")then error(\"Invalid scheme\",2)end;d={url=d}end;d.method=\"HEAD\"local e=a.syscall.connect(d)e:write()while true do local f,g=coroutine.yield()if f==\"handle_status_change\"and g.id==e.id then if g.status==\"open\"then return e elseif g.status==\"error\"then return nil,select(2,e:status())end end end end;function c.options(d)b(1,d,\"table\",\"string\")if type(d)==\"table\"then b.field(d,\"url\",\"string\")if not d.url:match(\"^https?://\")then error(\"Invalid scheme\",2)end else if not d:match(\"^https?://\")then error(\"Invalid scheme\",2)end;d={url=d}end;d.method=\"OPTIONS\"local e=a.syscall.connect(d)e:write()while true do local f,g=coroutine.yield()if f==\"handle_status_change\"and g.id==e.id then if g.status==\"open\"then return e elseif g.status==\"error\"then return nil,select(2,e:status())end end end end;function c.post(d,j)b(1,d,\"table\",\"string\")b(2,j,\"string\")if type(d)==\"table\"then b.field(d,\"url\",\"string\")if not d.url:match(\"^https?://\")then error(\"Invalid scheme\",2)end else if not d:match(\"^https?://\")then error(\"Invalid scheme\",2)end;d={url=d}end;d.method=\"POST\"local e=a.syscall.connect(d)e:write(j)while true do local f,g=coroutine.yield()if f==\"handle_status_change\"and g.id==e.id then if g.status==\"open\"then return e elseif g.status==\"error\"then return nil,select(2,e:status())end end end end;function c.put(d,j)b(1,d,\"table\",\"string\")b(2,j,\"string\")if type(d)==\"table\"then b.field(d,\"url\",\"string\")if not d.url:match(\"^https?://\")then error(\"Invalid scheme\",2)end else if not d:match(\"^https?://\")then error(\"Invalid scheme\",2)end;d={url=d}end;d.method=\"PUT\"local e=a.syscall.connect(d)e:write(j)while true do local f,g=coroutine.yield()if f==\"handle_status_change\"and g.id==e.id then if g.status==\"open\"then return e elseif g.status==\"error\"then return nil,select(2,e:status())end end end end;function c.delete(d,j)b(1,d,\"table\",\"string\")b(2,j,\"string\",\"nil\")if type(d)==\"table\"then b.field(d,\"url\",\"string\")if not d.url:match(\"^https?://\")then error(\"Invalid scheme\",2)end else if not d:match(\"^https?://\")then error(\"Invalid scheme\",2)end;d={url=d}end;d.method=\"DELETE\"local e=a.syscall.connect(d)e:write(j)while true do local f,g=coroutine.yield()if f==\"handle_status_change\"and g.id==e.id then if g.status==\"open\"then return e elseif g.status==\"error\"then return nil,select(2,e:status())end end end end;function c.listen(k)b(1,k,\"string\")return a.syscall.listen(k)end;function c.unlisten(k)b(1,k,\"string\")return a.syscall.unlisten(k)end;function c.ipconfig(l,m)b(1,l,\"string\",\"table\")b(2,m,\"table\",\"nil\")if m then b.field(m,\"ip\",\"string\",\"number\",\"nil\")b.field(m,\"netmask\",\"string\",\"number\",\"nil\")b.field(m,\"up\",\"boolean\",\"nil\")end;return a.syscall.ipconfig(l,m)end;function c.route.list(n)b(1,n,\"number\",\"nil\")return a.syscall.routelist(n)end;function c.route.add(d)b(1,d,\"table\")b.field(d,\"table\",\"number\",\"nil\")b.field(d,\"source\",\"string\")b.field(d,\"sourceNetmask\",\"number\")b.field(d,\"action\",\"string\")b.field(d,\"device\",\"string\",not(d.action==\"local\"or d.action==\"unicast\"or d.action==\"broadcast\")and\"nil\"or nil)b.field(d,\"destination\",\"string\",d.action~=\"unicast\"and\"nil\"or nil)return a.syscall.routeadd(d)end;function c.route.remove(o,p,n)b(1,o,\"string\")b(2,p,\"number\")b(3,n,\"number\",\"nil\")return a.syscall.routedel(o,p,n)end;function c.arp.list(l)b(1,l,\"string\")return a.syscall.arplist(l)end;function c.arp.set(l,q,r)b(1,l,\"string\")b(2,q,\"string\")b(3,r,\"number\",\"nil\")return a.syscall.arpset(l,q,r)end;function c.control(q,type,s)b(1,q,\"string\")b(2,type,\"string\")b(3,s,\"string\",\"nil\")return a.syscall.netcontrol(q,type,s)end;function c.events(t)b(1,t,\"boolean\",\"nil\")return a.syscall.netevent(t)end;function c.checkURI(k)b(1,k,\"string\")return a.syscall.checkuri(k)end;return c\n\npretty.lua/     0           0     0     644     6055      `\nlocal a=require\"terminal\"local b=require\"expect\"local c=b.field;local type,getmetatable,setmetatable,d,tostring=type,getmetatable,setmetatable,a.colours,tostring;local e,f=debug.getinfo,debug.getlocal;local function g(h,i)local j=h.n+1;h[j],h.n=i,j end;local k={__name=\"document\"}local function l(m)return setmetatable(m,k)end;local n=l({tag=\"nil\"})local o=l({tag=\"text\",text=\" \"})local p=l({tag=\"line\",flat=n})local q=l({tag=\"line\",flat=o})local r={[\"\"]=n,[\" \"]=o,[\"\\n\"]=q}local function s(t,u)return r[t]or setmetatable({tag=\"text\",text=t,colour=u},k)end;local function t(t,u)b(1,t,\"string\")b(2,u,\"number\",\"nil\")local v=r[t]if v then return v end;local w=t:find(\"\\n\",1)if not w then return s(t,u)end;local x=setmetatable({tag=\"concat\",n=0},k)if w~=1 then g(x,s(t:sub(1,w-1),u))end;w=w+1;while true do local y=t:find(\"\\n\",w)g(x,q)if not y then if w<=#t then g(x,s(t:sub(w),u))end;return x else if w<=y-1 then g(x,s(t:sub(w,y-1),u))end;w=y+1 end end end;local function z(...)local A=table.pack(...)for B=1,A.n do if type(A[B])==\"string\"then A[B]=t(A[B])end;b(B,A[B],\"document\")end;if A.n==0 then return n end;if A.n==1 then return A[1]end;A.tag=\"concat\"return setmetatable(A,k)end;k.__concat=z;local function C(D,x)b(1,D,\"number\")b(2,x,\"document\")if D<=0 then error(\"depth must be a positive number\",2)end;return setmetatable({tag=\"nest\",depth=D,x},k)end;local function E(x)if x.flat then return x.flat end;local F=x.tag;if F==\"nil\"or F==\"text\"then return x elseif F==\"concat\"then local h=setmetatable({tag=\"concat\",n=x.n},k)for B=1,x.n do h[B]=E(x[B])end;x.flat,h.flat=h,h;return h elseif F==\"nest\"then return E(x[1])elseif F==\"group\"then return x[1]else error(\"Unknown doc \"..F)end end;local function G(x)b(1,x,\"document\")if x.tag==\"group\"then return x end;local H=E(x)if H==x then return x end;return setmetatable({tag=\"group\",H,x},k)end;local function I(x,J)local F=x.tag;if F==\"nil\"or F==\"line\"then return J elseif F==\"text\"then return J-#x.text elseif F==\"concat\"then for B=1,x.n do J=I(x[B],J)if J<0 then break end end;return J elseif F==\"group\"or F==\"nest\"then return I(F[1])else error(\"Unknown doc \"..F)end end;local function K(x,L)b(1,x,\"document\")b(2,L,\"number\",\"nil\")local J,M=a.termsize()local N=(L or 0.6)*J;if N<0 then N=0 end;if N>J then N=J end;local O=d.white;local P=O;local function Q(x,R,S)local F=x.tag;if F==\"nil\"then return S elseif F==\"text\"then local T=x.colour or O;if T~=P then io.write(a.toEscape(T))P=T end;io.write(x.text)return S+#x.text elseif F==\"line\"then io.write(\"\\n\\x1b[\"..R..\"C\")return R elseif F==\"concat\"then for B=1,x.n do S=Q(x[B],R,S)end;return S elseif F==\"nest\"then return Q(x[1],R+x.depth,S)elseif F==\"group\"then if I(x[1],math.min(J,N+R)-S)>=0 then return Q(x[1],R,S)else return Q(x[2],R,S)end else error(\"Unknown doc \"..F)end end;Q(x,0,0)if P~=O then io.write(\"\\x1b[0m\")end end;local function U(x,L)b(1,x,\"document\")b(2,L,\"number\",\"nil\")K(x,L)_G.print()end;local function V(x,J,L)b(1,x,\"document\")b(2,J,\"number\",\"nil\")b(3,L,\"number\",\"nil\")local N;if J then N=(L or 0.6)*J;if N<0 then N=0 end;if N>J then N=J end end;local h={n=0}local function Q(x,R,S)local F=x.tag;if F==\"nil\"then return S elseif F==\"text\"then g(h,x.text)return S+#x.text elseif F==\"line\"then g(h,\"\\n\"..(\" \"):rep(R))return R elseif F==\"concat\"then for B=1,x.n do S=Q(x[B],R,S)end;return S elseif F==\"nest\"then return Q(x[1],R+x.depth,S)elseif F==\"group\"then if not J or I(x[1],math.min(J,N+R)-S)>=0 then return Q(x[1],R,S)else return Q(x[2],R,S)end else error(\"Unknown doc \"..F)end end;Q(x,0,0)return table.concat(h,\"\",1,h.n)end;k.__tostring=V;local W={[\"and\"]=true,[\"break\"]=true,[\"do\"]=true,[\"else\"]=true,[\"elseif\"]=true,[\"end\"]=true,[\"false\"]=true,[\"for\"]=true,[\"function\"]=true,[\"if\"]=true,[\"in\"]=true,[\"local\"]=true,[\"nil\"]=true,[\"not\"]=true,[\"or\"]=true,[\"repeat\"]=true,[\"return\"]=true,[\"then\"]=true,[\"true\"]=true,[\"until\"]=true,[\"while\"]=true}local X=t(\",\")local Y=t(\"{}\")local Z,_=t(\"{\"),t(\"}\")local a0,a1=t(\"[\"),t(\"] = \")local function a2(a3,a4)local a5,a6=type(a3),type(a4)if a5==\"string\"then return a6~=\"string\"or a3<a4 elseif a6==\"string\"then return false end;if a5==\"number\"then return a6~=\"number\"or a3<a4 end;return false end;local function a7(a8,a9)local aa=e and e(a8,\"Su\")local ab;if a9.function_source and aa and aa.short_src and aa.linedefined and aa.linedefined>=1 then ab=\"function<\"..aa.short_src..\":\"..aa.linedefined..\">\"else ab=tostring(a8)end;if a9.function_args and aa and aa.what==\"Lua\"and aa.nparams and f then local A={}for B=1,aa.nparams do A[B]=f(a8,B)or\"?\"end;if aa.isvararg then A[#A+1]=\"...\"end;ab=ab..\"(\"..table.concat(A,\", \")..\")\"end;return ab end;local function ac(ad,a9,ae)local af=type(ad)if af==\"string\"then local ag=(\"%q\"):format(ad):gsub(\"\\\\\\n\",\"\\\\n\")return t(ag,d.red)elseif af==\"number\"then return t(tostring(ad),d.magenta)elseif af==\"function\"then return t(a7(ad,a9),d.lightGrey)elseif af~=\"table\"or ae[ad]then return t(tostring(ad),d.lightGrey)elseif getmetatable(ad)~=nil and getmetatable(ad).__tostring then return t(tostring(ad))elseif next(ad)==nil then return Y else ae[ad]=true;local x=setmetatable({tag=\"concat\",n=1,q},k)local ah,ai,aj=#ad,{},1;for ak in pairs(ad)do if type(ak)~=\"number\"or ak%1~=0 or ak<1 or ak>ah then ai[aj],aj=ak,aj+1 end end;table.sort(ai,a2)for B=1,ah do if B>1 then g(x,X)g(x,q)end;g(x,ac(ad[B],a9,ae))end;for B=1,aj-1 do if B>1 or ah>=1 then g(x,X)g(x,q)end;local ak=ai[B]local al=ad[ak]if type(ak)==\"string\"and not W[ak]and ak:match(\"^[%a_][%a%d_]*$\")then g(x,t(ak..\" = \"))g(x,ac(al,a9,ae))else g(x,a0)g(x,ac(ak,a9,ae))g(x,a1)g(x,ac(al,a9,ae))end end;ae[ad]=nil;return G(z(Z,C(2,z(table.unpack(x,1,x.n))),q,_))end end;local function am(ad,a9)b(2,a9,\"table\",\"nil\")a9=a9 or{}local an={function_source=c(a9,\"function_source\",\"boolean\",\"nil\")or false,function_args=c(a9,\"function_args\",\"boolean\",\"nil\")or false}return ac(ad,an,{})end;local function ao(ad,a9,L)b(2,a9,\"table\",\"nil\")a9=a9 or{}b(3,L,\"number\",\"nil\")return U(am(ad,a9),L)end;return{empty=n,space=o,line=p,space_line=q,text=t,concat=z,nest=C,group=G,write=K,print=U,render=V,pretty=am,pretty_print=ao}\n\nprocess.lua/    0           0     0     644     2523      `\nlocal a=require\"expect\"local b=require\"util\"local c={}function c.getpid()return b.syscall.getpid()end;function c.getppid()return b.syscall.getppid()end;function c.getuser()return b.syscall.getuser()end;function c.setuser(d)a(1,d,\"string\")return b.syscall.setuser(d)end;function c.clock()return b.syscall.clock()end;function c.getenv()return b.syscall.getenv()end;function c.getname()return b.syscall.getname()end;function c.getcwd()return b.syscall.getcwd()end;function c.chdir(e)a(1,e,\"string\")return b.syscall.chdir(e)end;function c.fork(f,g,...)a(1,f,\"function\")a(2,g,\"string\",\"nil\")return b.syscall.fork(f,g,...)end;function c.forkbg(f,g,...)a(1,f,\"function\")a(2,g,\"string\",\"nil\")return b.syscall.fork(function(...)b.syscall.stdin()b.syscall.stdout()b.syscall.stderr()setfenv(f,_ENV)return f(...)end,g,...)end;function c.exec(h,...)a(1,h,\"string\")return b.syscall.exec(h,...)end;function c.execp(i,...)a(1,i,\"string\")local h=b.syscall.getenv().PATH;if i:find\"/\"or type(h)~=\"string\"then return b.syscall.exec(i,...)end;for e in h:gmatch\"[^:]+\"do local j=b.syscall.combine(e,i)local k=b.syscall.stat(j)if not k then j=b.syscall.combine(e,i..\".lua\")k=b.syscall.stat(j)end;if k and k.type~=\"directory\"then return b.syscall.exec(j,...)end end;error(i..\": No such file\",2)end;function c.start(h,...)a(1,h,\"string\")return b.syscall.fork(function(...)return coroutine.yield(\"syscall\",\"exec\",...)end,h,h,...)end;function c.startbg(h,...)a(1,h,\"string\")return b.syscall.fork(function(...)b.syscall.stdin()b.syscall.stdout()b.syscall.stderr()return coroutine.yield(\"syscall\",\"exec\",...)end,h,h,...)end;function c.run(i,...)a(1,i,\"string\")local l=b.syscall.getenv().PATH;local h;if i:find\"/\"or type(l)~=\"string\"then h=i else for e in l:gmatch\"[^:]+\"do local j=b.syscall.combine(e,i)local k=b.syscall.stat(j)if not k then j=b.syscall.combine(e,i..\".lua\")k=b.syscall.stat(j)end;if k and k.type~=\"directory\"then h=j;break end end;error(i..\": No such file\",2)end;local m=b.syscall.fork(function(...)return coroutine.yield(\"syscall\",\"exec\",...)end,h,h,...)local n,o;repeat n,o=coroutine.yield()until n==\"process_complete\"and o.id==m;return o.error==nil,o.error or o.value end;function c.newthread(f,...)a(1,f,\"function\")return b.syscall.newthread(f,...)end;function c.exit(p)return b.syscall.exit(p)end;function c.getplist()return b.syscall.getplist()end;function c.getpinfo(m)a(1,m,\"number\")return b.syscall.getpinfo(m)end;function c.nice(q,m)a(1,q,\"number\")a.range(q,-20,20)a(2,m,\"number\",\"nil\")return b.syscall.nice(q,m)end;return c\n\n/0              0           0     0     644     8891      `\nlocal a=require\"expect\"local b={base64={},json={},lua={}}local c=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"function b.base64.encode(d)a(1,d,\"string\")local e=\"\"for f in d:gmatch\"...\"do local g=f:byte(1)*65536+f:byte(2)*256+f:byte(3)local h,i,j,k=bit32.extract(g,18,6),bit32.extract(g,12,6),bit32.extract(g,6,6),bit32.extract(g,0,6)e=e..c:sub(h+1,h+1)..c:sub(i+1,i+1)..c:sub(j+1,j+1)..c:sub(k+1,k+1)end;if#d%3==1 then local g=d:byte(-1)local h,i=bit32.rshift(g,2),bit32.lshift(bit32.band(g,3),4)e=e..c:sub(h+1,h+1)..c:sub(i+1,i+1)..\"==\"elseif#d%3==2 then local g=d:byte(-2)*256+d:byte(-1)local h,i,j=bit32.extract(g,10,6),bit32.extract(g,4,6),bit32.lshift(bit32.extract(g,0,4),2)e=e..c:sub(h+1,h+1)..c:sub(i+1,i+1)..c:sub(j+1,j+1)..\"=\"end;return e end;function b.base64.decode(d)a(1,d,\"string\")local e=\"\"for f in d:gmatch\"....\"do if f:sub(3,4)=='=='then e=e..string.char(bit32.bor(bit32.lshift(c:find(f:sub(1,1))-1,2),bit32.rshift(c:find(f:sub(2,2))-1,4)))elseif f:sub(4,4)=='='then local g=(c:find(f:sub(1,1))-1)*4096+(c:find(f:sub(2,2))-1)*64+c:find(f:sub(3,3))-1;e=e..string.char(bit32.extract(g,10,8))..string.char(bit32.extract(g,2,8))else local g=(c:find(f:sub(1,1))-1)*262144+(c:find(f:sub(2,2))-1)*4096+(c:find(f:sub(3,3))-1)*64+c:find(f:sub(4,4))-1;e=e..string.char(bit32.extract(g,16,8))..string.char(bit32.extract(g,8,8))..string.char(bit32.extract(g,0,8))end end;return e end;local function l(d)return setmetatable({},{__newindex=function()error(\"attempt to modify read-only table\")end,__tostring=function()return d end})end;b.json.null=l\"null\"b.json.emptyArray=l\"[]\"local m;local n={[\"\\\\\"]=\"\\\\\",[\"\\\"\"]=\"\\\"\",[\"\\b\"]=\"b\",[\"\\f\"]=\"f\",[\"\\n\"]=\"n\",[\"\\r\"]=\"r\",[\"\\t\"]=\"t\"}local o={[\"/\"]=\"/\"}for p,q in pairs(n)do o[q]=p end;local function r(j)return\"\\\\\"..(n[j]or string.format(\"u%04x\",j:byte()))end;local function s(t)return\"null\"end;local function u(t,v)local w={}v=v or{}if t==b.json.null then return\"null\"elseif t==b.json.emptyArray then return\"[]\"end;if v[t]then error(\"circular reference\")end;v[t]=true;if rawget(t,1)~=nil or next(t)==nil then local g=0;for p in pairs(t)do if type(p)~=\"number\"then error(\"invalid table: mixed or invalid key types\")end;g=g+1 end;if g~=#t then error(\"invalid table: sparse array\")end;for x,q in ipairs(t)do table.insert(w,m(q,v))end;v[t]=nil;return\"[\"..table.concat(w,\",\")..\"]\"else for p,q in pairs(t)do if type(p)~=\"string\"then error(\"invalid table: mixed or invalid key types\")end;table.insert(w,m(p,v)..\":\"..m(q,v))end;v[t]=nil;return\"{\"..table.concat(w,\",\")..\"}\"end end;local function y(t)return'\"'..t:gsub('[%z\\1-\\31\\\\\"]',r)..'\"'end;local function z(t)if t~=t or t<=-math.huge or t>=math.huge then error(\"unexpected number value '\"..tostring(t)..\"'\")end;return string.format(\"%.14g\",t)end;local A={[\"nil\"]=s,[\"table\"]=u,[\"string\"]=y,[\"number\"]=z,[\"boolean\"]=tostring}m=function(t,v)local B=type(t)local C=A[B]if C then return C(t,v)end;error(\"unexpected type '\"..B..\"'\")end;function b.json.encode(t)return m(t)end;local D;local function E(...)local w={}for x=1,select(\"#\",...)do w[select(x,...)]=true end;return w end;local F=E(\" \",\"\\t\",\"\\r\",\"\\n\")local G=E(\" \",\"\\t\",\"\\r\",\"\\n\",\"]\",\"}\",\",\")local H=E(\"\\\\\",\"/\",'\"',\"b\",\"f\",\"n\",\"r\",\"t\",\"u\")local I=E(\"true\",\"false\",\"null\")local J={[\"true\"]=true,[\"false\"]=false,[\"null\"]=nil}local function K(d,L,M,N)for x=L,#d do if M[d:sub(x,x)]~=N then return x end end;return#d+1 end;local function O(d,L,P)local Q=1;local R=1;for x=1,L-1 do R=R+1;if d:sub(x,x)==\"\\n\"then Q=Q+1;R=1 end end;error(string.format(\"%s at line %d col %d\",P,Q,R))end;local function S(g)local C=math.floor;if g<=0x7f then return string.char(g)elseif g<=0x7ff then return string.char(C(g/64)+192,g%64+128)elseif g<=0xffff then return string.char(C(g/4096)+224,C(g%4096/64)+128,g%64+128)elseif g<=0x10ffff then return string.char(C(g/262144)+240,C(g%262144/4096)+128,C(g%4096/64)+128,g%64+128)end;error(string.format(\"invalid unicode codepoint '%x'\",g))end;local function T(f)local U=tonumber(f:sub(1,4),16)local V=tonumber(f:sub(7,10),16)if V then return S((U-0xd800)*0x400+V-0xdc00+0x10000)else return S(U)end end;local function W(d,x)local w=\"\"local X=x+1;local p=X;while X<=#d do local Y=d:byte(X)if Y<32 then O(d,X,\"control character in string\")elseif Y==92 then w=w..d:sub(p,X-1)X=X+1;local j=d:sub(X,X)if j==\"u\"then local Z=d:match(\"^[dD][89aAbB]%x%x\\\\u%x%x%x%x\",X+1)or d:match(\"^%x%x%x%x\",X+1)or O(d,X-1,\"invalid unicode escape in string\")w=w..T(Z)X=X+#Z else if not H[j]then O(d,X-1,\"invalid escape char '\"..j..\"' in string\")end;w=w..o[j]end;p=X+1 elseif Y==34 then w=w..d:sub(p,X-1)return w,X+1 end;X=X+1 end;O(d,x,\"expected closing quote for string\")end;local function _(d,x)local Y=K(d,x,G)local f=d:sub(x,Y-1)local g=tonumber(f)if not g then O(d,x,\"invalid number '\"..f..\"'\")end;return g,Y end;local function a0(d,x)local Y=K(d,x,G)local a1=d:sub(x,Y-1)if not I[a1]then O(d,x,\"invalid literal '\"..a1 ..\"'\")end;return J[a1],Y end;local function a2(d,x)local w={}local g=1;x=x+1;while 1 do local Y;x=K(d,x,F,true)if d:sub(x,x)==\"]\"then x=x+1;break end;Y,x=D(d,x)w[g]=Y;g=g+1;x=K(d,x,F,true)local a3=d:sub(x,x)x=x+1;if a3==\"]\"then break end;if a3~=\",\"then O(d,x,\"expected ']' or ','\")end end;return w,x end;local function a4(d,x)local w={}x=x+1;while 1 do local a5,t;x=K(d,x,F,true)if d:sub(x,x)==\"}\"then x=x+1;break end;if d:sub(x,x)~='\"'then O(d,x,\"expected string for key\")end;a5,x=D(d,x)x=K(d,x,F,true)if d:sub(x,x)~=\":\"then O(d,x,\"expected ':' after key\")end;x=K(d,x+1,F,true)t,x=D(d,x)w[a5]=t;x=K(d,x,F,true)local a3=d:sub(x,x)x=x+1;if a3==\"}\"then break end;if a3~=\",\"then O(d,x,\"expected '}' or ','\")end end;return w,x end;local a6={['\"']=W,[\"0\"]=_,[\"1\"]=_,[\"2\"]=_,[\"3\"]=_,[\"4\"]=_,[\"5\"]=_,[\"6\"]=_,[\"7\"]=_,[\"8\"]=_,[\"9\"]=_,[\"-\"]=_,[\"t\"]=a0,[\"f\"]=a0,[\"n\"]=a0,[\"[\"]=a2,[\"{\"]=a4}D=function(d,L)local a3=d:sub(L,L)local C=a6[a3]if C then return C(d,L)end;O(d,L,\"unexpected character '\"..a3 ..\"'\")end;function b.json.decode(d)a(1,d,\"string\")local w,L=D(d,K(d,1,F,true))L=K(d,L,F,true)if L<=#d then O(d,L,\"trailing garbage\")end;return w end;function b.json.save(t,a7)a(2,a7,\"string\")local a8=assert(io.open(a7,\"w\"))a8:write(b.json.encode(t))a8:close()end;function b.json.load(a7)a(1,a7,\"string\")local a8=assert(io.open(a7,\"r\"))local a9=a8:read(\"*a\")a8:close()return b.json.decode(a9)end;local aa={[\"and\"]=true,[\"break\"]=true,[\"do\"]=true,[\"else\"]=true,[\"elseif\"]=true,[\"end\"]=true,[\"false\"]=true,[\"for\"]=true,[\"function\"]=true,[\"goto\"]=true,[\"if\"]=true,[\"in\"]=true,[\"local\"]=true,[\"nil\"]=true,[\"not\"]=true,[\"or\"]=true,[\"repeat\"]=true,[\"return\"]=true,[\"then\"]=true,[\"true\"]=true,[\"until\"]=true,[\"while\"]=true}local function ab(t,v,ac,ad)if v[t]then error(\"Cannot serialize recursive value\",0)end;local ae=type(t)if ae==\"table\"then if not next(t)then return\"{}\"end;v[t]=true;local w=ac.minified and\"{\"or\"{\\n\"local af={}for x,q in ipairs(t)do if not ac.minified then w=w..(\"    \"):rep(ad)end;af[x]=true;w=w..ab(q,v,ac,ad+1)..(ac.minified and\",\"or\",\\n\")end;for p,q in pairs(t)do if not af[p]then if not ac.minified then w=w..(\"    \"):rep(ad)end;if type(p)==\"string\"and p:match\"^[A-Za-z_][A-Za-z0-9_]*$\"and not aa[p]then w=w..p else w=w..\"[\"..ab(p,v,ac,ad+1)..\"]\"end;w=w..(ac.minified and\"=\"or\" = \")..ab(q,v,ac,ad+1)..(ac.minified and\",\"or\",\\n\")end end;if ac.minified then w=w:gsub(\",$\",\"\")else w=w..(\"    \"):rep(ad-1)end;v[t]=nil;return w..\"}\"elseif ae==\"function\"and ac.allow_functions then local ag,ah=pcall(string.dump,t)if not ag then error(\"Cannot serialize C function\",0)end;ah=(\"%q\"):format(ah):gsub(\"\\\\[%z\\1-\\31\\127-\\255]\",function(j)return(\"\\\\%03d\"):format(string.byte(j))end)local ai={n=0}v[t]=true;for x=1,math.huge do local ag,aj,ak=pcall(debug.getupvalue,t,x)if not ag or not aj then break end;ai[x]=ak;ai.n=x end;local aj=\"=(serialized function)\"local ag,al=pcall(debug.getinfo,t,\"S\")if ag then aj=al.source or aj end;local q=(\"__function(%s,%q,%s)\"):format(ah,aj,ab(ai,v,ac,ad+1))v[t]=nil;return q elseif ae==\"nil\"or ae==\"number\"or ae==\"boolean\"or ae==\"string\"then return(\"%q\"):format(t):gsub(\"\\\\\\n\",\"\\\\n\"):gsub(\"\\\\?[%z\\1-\\31\\127-\\255]\",function(j)return(\"\\\\%03d\"):format(string.byte(j))end)else error(\"Cannot serialize type \"..ae,0)end end;function b.lua.encode(t,ac)a(2,ac,\"table\",\"nil\")return ab(t,{},ac or{},1)end;function b.lua.decode(d,ac)ac=a(2,ac,\"table\",\"nil\")or{}local am={}local an={}if ac.allow_functions then function am.__function(ao,aj,ai)a(1,ao,\"string\")a(3,ai,\"table\")a.field(ai,\"n\",\"number\")local ap=assert(load(ao,aj,\"b\",{}))for x=1,ai.n do debug.setupvalue(ap,x,ai[x])end;an[#an+1]=ap;return ap end end;local w=assert(load(\"return \"..d,\"=unserialize\",\"t\",am))()for aq,q in ipairs(an)do setfenv(q,_G)end;return w end;function b.lua.save(t,a7,ac)a(2,a7,\"string\")local a8=assert(io.open(a7,\"w\"))a8:write(b.lua.encode(t,ac))a8:close()end;function b.lua.load(a7,ac)a(1,a7,\"string\")local a8=assert(io.open(a7,\"r\"))local a9=a8:read(\"*a\")a8:close()return b.lua.decode(a9,ac)end;return b\n\nsync.lua/       0           0     0     644     3222      `\nlocal a=require\"expect\"local b=require\"util\"local c={mutex={},semaphore={},conditionVariable={},atomic={},barrier={},rwLock={}}function c.mutex.new(d)a(1,d,\"boolean\",\"nil\")return setmetatable({recursive=d and 0},{__name=\"mutex\",__index=c.mutex})end;function c.mutex:lock()a(1,self,\"mutex\")return b.syscall.lockmutex(self)end;function c.mutex:unlock()a(1,self,\"mutex\")return b.syscall.unlockmutex(self)end;function c.mutex:tryLock()a(1,self,\"mutex\")return b.syscall.trylockmutex(self)end;function c.mutex:tryLockFor(e)a(1,self,\"mutex\")a(2,e,\"number\")return b.syscall.timelockmutex(self,e)end;function c.semaphore.new(f)a(1,f,\"number\",\"nil\")if f then a.range(f,0)end;return setmetatable({count=f or 1},{__name=\"semaphore\",__index=c.semaphore})end;function c.semaphore:acquire()a(1,self,\"semaphore\")return b.syscall.acquiresemaphore(self)end;function c.semaphore:tryAcquireFor(e)a(1,self,\"semaphore\")a(2,e,\"number\")return b.syscall.timeacquiresemaphore(self,e)end;function c.semaphore:release()a(1,self,\"semaphore\")return b.syscall.releasesemaphore(self)end;function c.conditionVariable.new()return setmetatable({lock=c.mutex.new(),sem=c.semaphore.new(0),waiting=0},{__name=\"condition variable\",__index=c.conditionVariable})end;function c.conditionVariable:wait()a(1,self,\"condition variable\")self.lock:lock()self.waiting=self.waiting+1;self.lock:unlock()self.sem:acquire()self.lock:lock()self.waiting=self.waiting-1;self.lock:unlock()end;function c.conditionVariable:waitFor(e)a(1,self,\"condition variable\")a(2,e,\"number\")self.lock:lock()self.waiting=self.waiting+1;self.lock:unlock()local g=self.sem:tryAcquireFor(e)self.lock:lock()self.waiting=self.waiting-1;self.lock:unlock()return g end;function c.conditionVariable:notifyOne()a(1,self,\"condition variable\")self.sem:release()end;function c.conditionVariable:notifyAll()a(1,self,\"condition variable\")self.lock:lock()self.sem.count=self.sem.count+self.waiting-1;self.sem:release()self.lock:unlock()end;function c.barrier.new(h)a(1,h,\"number\")a.range(h,1)return setmetatable({cvar=c.conditionVariable.new(),lock=c.mutex.new(),left=h,count=h,cycles=0},{__name=\"barrier\",__index=c.barrier})end;function c.barrier:wait()a(1,self,\"barrier\")self.lock:lock()self.left=self.left-1;if self.left==0 then self.left=self.count;self.cycles=self.cycles+1;self.lock:unlock()self.cvar:notifyAll()return true else self.lock:unlock()self.cvar:wait()return false end end;function c.rwLock.new()return setmetatable({count=0,readLock=c.mutex.new(),globalLock=c.semaphore.new(1)},{__name=\"rwlock\",__index=c.rwLock})end;function c.rwLock:lockRead()a(1,self,\"rwlock\")self.readLock:lock()self.count=self.count+1;if self.count==1 then self.globalLock:acquire()end;self.readLock:unlock()end;function c.rwLock:unlockRead()a(1,self,\"rwlock\")self.readLock:lock()self.count=self.count-1;if self.count==0 then self.globalLock:release()end;self.readLock:unlock()end;function c.rwLock:lockWrite()a(1,self,\"rwlock\")self.globalLock:acquire()end;function c.rwLock:unlockWrite()a(1,self,\"rwlock\")self.globalLock:release()end;function c.lockGuard(i,j,...)a(1,i,\"mutex\")a(2,j,\"function\")i:lock()local k=table.pack(pcall(j,...))i:unlock()if not k[1]then error(k[2],0)end;return table.unpack(k,2,k.n)end;return c\nterminal.lua/   0           0     0     644     4515      `\nlocal a=require\"expect\"local b=require\"keys\"local c=require\"util\"local d={}d.colors={white=0,orange=1,magenta=2,lightBlue=3,yellow=4,lime=5,pink=6,gray=7,grey=7,lightGray=8,lightGrey=8,cyan=9,purple=10,blue=11,brown=12,green=13,red=14,black=15}d.colours=d.colors;function d.toEscape(e,f)a(1,e,\"number\")a(2,f,\"boolean\",\"nil\")a.range(e,0,15)local g=37-e%8;if e<8 then g=g+60 end;if f then g=g+10 end;return\"\\x1b[\"..g..\"m\"end;function d.write(...)return c.syscall.write(...)end;function d.writeerr(...)return c.syscall.writeerr(...)end;function d.read(g)a(1,g,\"number\")return c.syscall.read(g)end;function d.readline()return c.syscall.readline()end;function d.readline2(h,i)a(1,h,\"table\",\"nil\")a(2,i,\"function\",\"nil\")local j=\"\"local k=1;local l=0;local m;local n,o;d.termctl{echo=false}while true do local p,q=coroutine.yield()if p==\"char\"then if n and n[o]and q.character==n[o]:sub(-1)then n=nil else n=nil;if k<=#j then d.write(\"\\x1b[@\"..q.character)j=j:sub(1,k-1)..q.character..j:sub(k)else d.write(q.character)j=j..q.character end;k=k+1 end elseif p==\"key\"then if q.keycode==b.enter then d.termctl{echo=true}if k<=#j then d.write(\"\\x1b[\"..#j-k+1 ..\"C\")end;d.write(\"\\n\")d.readline()return j elseif q.keycode==b.d and q.ctrlHeld and not q.altHeld and not q.shiftHeld then d.termctl{echo=true}return d.readline()elseif q.keycode==b.backspace and k>1 then n=nil;d.write(\"\\x1b[D\\x1b[P\")j=j:sub(1,k-2)..j:sub(k)k=k-1 elseif q.keycode==b.delete and k<=#j then n=nil;d.write(\"\\x1b[P\")j=j:sub(1,k-1)..j:sub(k+1)elseif q.keycode==b.left and k>1 then n=nil;d.write(\"\\x1b[D\")k=k-1 elseif q.keycode==b.right and k<=#j then n=nil;d.write(\"\\x1b[C\")k=k+1 elseif q.keycode==b.up and h and l<#h then n=nil;if k>1 then d.write(\"\\x1b[\"..k-1 ..\"D\")end;d.write(\"\\x1b[\"..#j..\"P\")if l==0 then m=j end;l=l+1;j=h[l]d.write(j)k=#j+1 elseif q.keycode==b.down and h and l>0 then n=nil;if k>1 then d.write(\"\\x1b[\"..k-1 ..\"D\")end;d.write(\"\\x1b[\"..#j..\"P\")l=l-1;if l==0 then j=m else j=h[l]end;d.write(j)k=#j+1 elseif q.keycode==b.tab and i then if n and#n>0 then d.write(\"\\x1b[\"..#n[o]..\"D\\x1b[\"..#n[o]..\"P\")j=j:sub(1,k-#n[o]-1)..j:sub(k)k=k-#n[o]o=o%#n+1 else n=i(j:sub(1,k-1))o=1 end;if n[o]then d.write(\"\\x1b[\"..#n[o]..\"@\"..n[o])j=j:sub(1,k-1)..n[o]..j:sub(k)k=k+#n[o]end end elseif p==\"paste\"then n=nil;if k<=#j then d.write(\"\\x1b[\"..#q.text..\"@\"..q.text)j=j:sub(1,k-1)..q.text..j:sub(k)k=k+#q.text else d.write(q.text)j=j..q.text end;k=k+#q.text end end end;function d.termctl(r)a(1,r,\"table\",\"nil\")if r then a.field(r,\"cbreak\",\"boolean\",\"nil\")a.field(r,\"delay\",\"boolean\",\"nil\")a.field(r,\"echo\",\"boolean\",\"nil\")a.field(r,\"keypad\",\"boolean\",\"nil\")a.field(r,\"nlcr\",\"boolean\",\"nil\")a.field(r,\"raw\",\"boolean\",\"nil\")end;return c.syscall.termctl(r)end;function d.openterm()return c.syscall.openterm()end;function d.opengfx()return c.syscall.opengfx()end;function d.mktty(s,t)a(1,s,\"number\")a(2,t,\"number\")return c.syscall.mktty(s,t)end;function d.stdin(u)a(1,u,\"number\",\"table\",\"nil\")return c.syscall.stdin(u)end;function d.stdout(u)a(1,u,\"number\",\"table\",\"nil\")return c.syscall.stdout(u)end;function d.stderr(u)a(1,u,\"number\",\"table\",\"nil\")return c.syscall.stderr(u)end;function d.istty()return c.syscall.istty()end;function d.termsize()return c.syscall.termsize()end;d.getSize=d.termsize;local v={}function v.close()end;function v.write(w)end;function v.blit(w,x,y)end;function v.clear()end;function v.clearLine()end;function v.getCursorPos()end;function v.setCursorPos(z,A)end;function v.getCursorBlink()end;function v.setCursorBlink(B)end;function v.isColor()end;function v.getSize()end;function v.scroll(C)end;function v.getTextColor()end;function v.setTextColor(e)end;function v.getBackgroundColor()end;function v.setBackgroundColor(e)end;function v.getPaletteColor(e)end;function v.setPaletteColor(e,D,E,F)end;function v.getLine(A)end;local G={}function G.close()end;function G.getSize()end;function G.clear()end;function G.getPaletteColor(e)end;function G.setPaletteColor(e,D,E,F)end;function G.getPixel(z,A)end;function G.setPixel(z,A,e)end;function G.getPixels(z,A,s,t,H)end;function G.drawPixels(z,A,I,s,t)end;function G.getFrozen()end;function G.setFrozen(J)end;local K={isTTY=true,flags={cbreak=false,delay=true,echo=true,keypad=false,nlcr=true,raw=false},cursor={x=1,y=1},cursorBlink=true,colors={fg='0',bg='f',bold=false},size={width=51,height=19},dirtyLines={},palette={},dirtyPalette={},buffer=\"\",preBuffer=\"\",isLocked=false,isGraphics=false,textBuffer={},graphicsBuffer={},frontmostProcess=nil,processList={},eof=false}return d\n\nutil.lua/       0           0     0     644     6676      `\nlocal a=require\"expect\"local b={}b.syscall=setmetatable({},{__index=function(self,c)return function(...)local d=table.pack(coroutine.yield(\"syscall\",c,...))if d[1]then return table.unpack(d,2,d.n)else error(d[2],2)end end end,__newindex=function()end})function b.argparse(e,...)a(1,e,\"table\")a.field(e,\"\",\"table\",\"nil\")local d={}local f;local g=e[\"\"]or{}for h,i in ipairs{...}do if f then if e[f]==\"number\"then d[f]=tonumber(i)if not d[f]then return nil,\"parameter passed to argument '\"..f..\"' is not a number\"end elseif e[f]==\"multiple\"then d[f]=d[f]or{}d[f][#d[f]+1]=i elseif e[f]==\"multiple number\"then i=tonumber(i)if not i then return nil,\"parameter passed to argument '\"..f..\"' is not a number\"end;d[f]=d[f]or{}d[f][#d[f]+1]=i else d[f]=i end;f=nil elseif i:match\"^%-+$\"then local j=table.pack(...)local k=i==\"-\"and#d+1 or#d;for l=i==\"-\"and 0 or 1,j.n-h do d[k+l]=j[h+l]end;break elseif i:sub(1,2)==\"--\"then local m=i:sub(3)while type(e[m])==\"string\"and e[m]:match\"^@\"do m=e[m]:sub(2)end;if e[m]then f=m elseif e[m]==false then d[m]=true else return nil,\"unrecognized argument '--\"..m..\"'\"end elseif i:sub(1,1)==\"-\"then for m in i:sub(2):gmatch\".\"do while type(e[m])==\"string\"and e[m]:match\"^@\"do m=e[m]:sub(2)end;if e[m]then if f then return nil,\"no parameter passed to argument '\"..f..\"'\"end;f=m elseif e[m]==false then d[m]=true else return nil,\"unrecognized argument '-\"..m..\"'\"end end else if g.stopProcessingOnPositionalArgument then local j=table.pack(...)local k=#d+1;for l=0,j.n-h do d[k+l]=j[h+l]end;break else d[#d+1]=i end end end;if f then return nil,\"no parameter passed to argument '\"..f..\"'\"end;return d end;function b.timer(n)a(1,n,\"number\")return b.syscall.timer(n)end;function b.alarm(n)a(1,n,\"number\")return b.syscall.alarm(n)end;function b.cancel(o)a(1,o,\"number\")return b.syscall.cancel(o)end;function b.sleep(n)a(1,n,\"number\")local p=b.syscall.timer(n)repeat local q,r=coroutine.yield()until q==\"timer\"and r.id==p end;function b.pullEvent()return coroutine.yield()end;function b.filterEvent(...)local s={...}for h,t in ipairs(s)do a(h,t,\"string\")end;while true do local u,r=coroutine.yield()for v,t in ipairs(s)do if u==t then return u,r end end end end;function b.queueEvent(u,r)a(1,u,\"string\")a(2,r,\"table\")return b.syscall.queueEvent(u,r)end;function b.split(w,x,y)a(1,w,\"string\")a(2,x,\"string\",\"nil\")local z={}if y then local k,m=1,w:find(\"[\"..x..\"]\")while k do z[#z+1]=w:sub(k,m and m-1)k=m and m+1;m=w:find(\"[\"..x..\"]\",k)end else for A in w:gmatch(\"[^\"..(x or\"%s\")..\"]+\")do z[#z+1]=A end end;return z end;function b.copy(B)if type(B)==\"table\"then local d=setmetatable({},deepcopy(getmetatable(B)))for C,t in pairs(B)do d[deepcopy(C)]=deepcopy(t)end;return d else return B end end;local D={}function b.addEventListener(u,E)a(1,u,\"string\")a(2,E,\"function\")D[u]=D[u]or{}D[u][#D[u]+1]=E end;function b.removeEventListener(u,E)a(1,u,\"string\")a(2,E,\"function\")if D[u]then for C,t in ipairs(D[u])do if t==E then table.remove(D[u],C)return end end end end;function b.runEvents()while true do local u,r=coroutine.yield()if D[u]then for v,t in ipairs(D[u])do local F,G=pcall(t,u,r)if not F then return G end;if G then break end end end end end;function b.startEvents()return b.syscall.newthread(b.runEvents)end;function b.type(B)local z=type(B)if z==\"table\"then local H=getmetatable(B)if H and H.__name then return H.__name end end;return z end;local I={[0xEDB88320]={[0]=0x00000000,0x77073096,0xee0e612c,0x990951ba,0x076dc419,0x706af48f,0xe963a535,0x9e6495a3,0x0edb8832,0x79dcb8a4,0xe0d5e91e,0x97d2d988,0x09b64c2b,0x7eb17cbd,0xe7b82d07,0x90bf1d91,0x1db71064,0x6ab020f2,0xf3b97148,0x84be41de,0x1adad47d,0x6ddde4eb,0xf4d4b551,0x83d385c7,0x136c9856,0x646ba8c0,0xfd62f97a,0x8a65c9ec,0x14015c4f,0x63066cd9,0xfa0f3d63,0x8d080df5,0x3b6e20c8,0x4c69105e,0xd56041e4,0xa2677172,0x3c03e4d1,0x4b04d447,0xd20d85fd,0xa50ab56b,0x35b5a8fa,0x42b2986c,0xdbbbc9d6,0xacbcf940,0x32d86ce3,0x45df5c75,0xdcd60dcf,0xabd13d59,0x26d930ac,0x51de003a,0xc8d75180,0xbfd06116,0x21b4f4b5,0x56b3c423,0xcfba9599,0xb8bda50f,0x2802b89e,0x5f058808,0xc60cd9b2,0xb10be924,0x2f6f7c87,0x58684c11,0xc1611dab,0xb6662d3d,0x76dc4190,0x01db7106,0x98d220bc,0xefd5102a,0x71b18589,0x06b6b51f,0x9fbfe4a5,0xe8b8d433,0x7807c9a2,0x0f00f934,0x9609a88e,0xe10e9818,0x7f6a0dbb,0x086d3d2d,0x91646c97,0xe6635c01,0x6b6b51f4,0x1c6c6162,0x856530d8,0xf262004e,0x6c0695ed,0x1b01a57b,0x8208f4c1,0xf50fc457,0x65b0d9c6,0x12b7e950,0x8bbeb8ea,0xfcb9887c,0x62dd1ddf,0x15da2d49,0x8cd37cf3,0xfbd44c65,0x4db26158,0x3ab551ce,0xa3bc0074,0xd4bb30e2,0x4adfa541,0x3dd895d7,0xa4d1c46d,0xd3d6f4fb,0x4369e96a,0x346ed9fc,0xad678846,0xda60b8d0,0x44042d73,0x33031de5,0xaa0a4c5f,0xdd0d7cc9,0x5005713c,0x270241aa,0xbe0b1010,0xc90c2086,0x5768b525,0x206f85b3,0xb966d409,0xce61e49f,0x5edef90e,0x29d9c998,0xb0d09822,0xc7d7a8b4,0x59b33d17,0x2eb40d81,0xb7bd5c3b,0xc0ba6cad,0xedb88320,0x9abfb3b6,0x03b6e20c,0x74b1d29a,0xead54739,0x9dd277af,0x04db2615,0x73dc1683,0xe3630b12,0x94643b84,0x0d6d6a3e,0x7a6a5aa8,0xe40ecf0b,0x9309ff9d,0x0a00ae27,0x7d079eb1,0xf00f9344,0x8708a3d2,0x1e01f268,0x6906c2fe,0xf762575d,0x806567cb,0x196c3671,0x6e6b06e7,0xfed41b76,0x89d32be0,0x10da7a5a,0x67dd4acc,0xf9b9df6f,0x8ebeeff9,0x17b7be43,0x60b08ed5,0xd6d6a3e8,0xa1d1937e,0x38d8c2c4,0x4fdff252,0xd1bb67f1,0xa6bc5767,0x3fb506dd,0x48b2364b,0xd80d2bda,0xaf0a1b4c,0x36034af6,0x41047a60,0xdf60efc3,0xa867df55,0x316e8eef,0x4669be79,0xcb61b38c,0xbc66831a,0x256fd2a0,0x5268e236,0xcc0c7795,0xbb0b4703,0x220216b9,0x5505262f,0xc5ba3bbe,0xb2bd0b28,0x2bb45a92,0x5cb36a04,0xc2d7ffa7,0xb5d0cf31,0x2cd99e8b,0x5bdeae1d,0x9b64c2b0,0xec63f226,0x756aa39c,0x026d930a,0x9c0906a9,0xeb0e363f,0x72076785,0x05005713,0x95bf4a82,0xe2b87a14,0x7bb12bae,0x0cb61b38,0x92d28e9b,0xe5d5be0d,0x7cdcefb7,0x0bdbdf21,0x86d3d2d4,0xf1d4e242,0x68ddb3f8,0x1fda836e,0x81be16cd,0xf6b9265b,0x6fb077e1,0x18b74777,0x88085ae6,0xff0f6a70,0x66063bca,0x11010b5c,0x8f659eff,0xf862ae69,0x616bffd3,0x166ccf45,0xa00ae278,0xd70dd2ee,0x4e048354,0x3903b3c2,0xa7672661,0xd06016f7,0x4969474d,0x3e6e77db,0xaed16a4a,0xd9d65adc,0x40df0b66,0x37d83bf0,0xa9bcae53,0xdebb9ec5,0x47b2cf7f,0x30b5ffe9,0xbdbdf21c,0xcabac28a,0x53b39330,0x24b4a3a6,0xbad03605,0xcdd70693,0x54de5729,0x23d967bf,0xb3667a2e,0xc4614ab8,0x5d681b02,0x2a6f2b94,0xb40bbe37,0xc30c8ea1,0x5a05df1b,0x2d02ef8d}}function b.crc32(w,J,K)a(1,w,\"string\")J=a(2,J,\"table\",\"number\",\"nil\")or 0xEDB88320;K=a(3,K,\"number\",\"nil\")or 0xFFFFFFFF;local L=type(J)==\"table\"and J or I[J]if not L then L={}for h=0,255 do local M=h;for v=1,8 do if bit32.btest(M,1)then M=bit32.bxor(bit32.rshift(M,1),J)else M=bit32.rshift(M,1)end end;L[h]=M end;I[J]=L end;for h=1,#w do K=bit32.bxor(L[bit32.band(bit32.bxor(w:byte(h),bit32.band(K,0xFF)))],bit32.rshift(K,8))end;return bit32.bnot(K)end;return b\n",created=1704748611483,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=75132},["tar.lua"]={modified=1704748612779,data="local a=require\"system.filesystem\"local function b(c)return string.match(c,'^()[%s%z]*$')and''or string.match(c,'^[%s%z]*(.*[^%s%z])')end;local function d(e,f,g)return string.len(e)<f and string.sub(e,1,f)..string.rep(g or\" \",f-string.len(e))or e end;local function h(i,j,...)if j and i[j]==nil then i[j]={}end;return j~=nil and h(i[j],...)or i end;local function k(e,l)local i={}for c in string.gmatch(e,\"([^\"..(l or\"%s\")..\"]+)\")do table.insert(i,c)end;return i end;local function m(n)return 0x38+(n.worldPermissions.read and 4 or 0)+(n.worldPermissions.write and 2 or 0)+(n.worldPermissions.execute and 1 or 0)+(n.permissions[n.owner].read and 256 or 0)+(n.permissions[n.owner].write and 128 or 0)+(n.permissions[n.owner].execute and 64 or 0)end;local o={verbosity=0,ignore_zero=false}function o.unserialize(p)local q={}local r={}for s,t in pairs(p)do local u=k(t.name,\"/\")local v=table.remove(u,table.maxn(u))local w=h(q,table.unpack(u))if t.type==0 or t.type==7 then w[v]=t elseif t.type==1 or t.type==2 then table.insert(r,t)elseif t.type==5 then w[v]={[\"//\"]=t}end end;for s,t in pairs(r)do local u=k(t.name,\"/\")local v=table.remove(u,table.maxn(u))h(q,table.unpack(u))[v]=h(q,table.unpack(k(t.link,\"/\")))end;return q end;function o.serialize(p)local q=p[\"//\"]~=nil and#p[\"//\"]>0 and{p[\"//\"]}or{}for s,t in pairs(p)do if s~=\"//\"then if t[\"//\"]~=nil or t.name==nil then local i=table.maxn(q)for x,y in ipairs(o.serialize(t))do q[i+x]=y end else table.insert(q,t)end end end;return q end;function o.load(z,A,B)if not B and not a.exists(z)then error(\"Path does not exist\",2)end;local C;if B then local c=1;C={read=function(D)if D then c=c+D;return string.sub(z,c-D,c-1)end;c=c+1;return string.byte(string.sub(z,c-1,c-1))end,close=function()end,seek=true}else C=a.open(z,\"rb\")end;local E=C.read;local F=0;local G=0;C.read=function(g)g=g or 1;if g<1 then return end;local q=nil;q=E(g)for H in q:gmatch(\".\")do F=F+H:byte()end;G=G+g;return q end;local q={}local I=0;while true do local p={}F=0;p.name=C.read(100)assert(G%512==100)if p.name==nil then break elseif p.name==string.rep(\"\\0\",100)then C.read(412)assert(G%512==0)I=I+1;if I==2 and not o.ignore_zero then break end else p.name=b(p.name)p.mode=tonumber(b(C.read(8)),8)p.owner=tonumber(b(C.read(8)),8)p.group=tonumber(b(C.read(8)),8)local J=tonumber(b(C.read(12)),8)p.timestamp=tonumber(b(C.read(12)),8)local K=F;local L=tonumber(b(C.read(8)),8)F=K+256;local i=C.read()p.type=tonumber(i==\"\\0\"and\"0\"or i)or i;p.link=b(C.read(100))if b(C.read(6))==\"ustar\"then C.read(2)p.ownerName=b(C.read(32))p.groupName=b(C.read(32))p.deviceNumber={tonumber(b(C.read(8))),tonumber(b(C.read(8)))}if p.deviceNumber[1]==nil and p.deviceNumber[2]==nil then p.deviceNumber=nil end;p.name=b(C.read(155))..p.name end;C.read(512-G%512)assert(G%512==0)if F~=L then print(\"Warning: checksum mismatch for \"..p.name)end;if J~=nil then if J==0 then p.data=\"\"else p.data=C.read(J)or\"\"if J%512~=0 then C.read(512-G%512)end end end;assert(G%512==0)table.insert(q,p)end end;C.close()return A and q or o.unserialize(q)end;function o.extract(p,z,M)a.mkdir(z)local r={}for s,t in pairs(p)do if s~=\"//\"then local N=a.combine(z,s)if t[\"//\"]~=nil then local x=o.extract(t,N,true)for O,y in pairs(x)do table.insert(r,y)end elseif t.type==1 or t.type==2 then table.insert(r,t)elseif t.type==0 or t.type==7 then local C=a.open(N,\"wb\")C.write(t.data)C.close()if t.owner~=nil then a.chmod(N,nil,bit32.band(t.mode,7))if t.ownerName~=nil and t.ownerName~=\"\"then a.chmod(N,t.ownerName,bit32.band(bit32.rshift(t.mode,3),7))a.chown(N,t.ownerName)elseif t.owner==0 then a.chmod(N,\"root\",bit32.band(bit32.rshift(t.mode,3),7))a.chown(N,\"root\")end end elseif t.type~=nil then print(\"Unimplemented type \"..t.type)end;if o.verbosity>0 then print((t[\"//\"]and t[\"//\"].name or t.name or\"?\")..\" => \"..(N or\"?\"))end end end;if M then return r else for s,t in pairs(r)do end end end;function o.read(P,N)local z=a.combine(P,N)local n=a.stat(z)if not n then return nil end;local C=a.open(z,\"rb\")local q={name=N,mode=m(n),owner=0,group=0,timestamp=n.modified,type=0,link=\"\",ownerName=n.owner,groupName=\"\",deviceNumber=nil,data=C.readAll()}C.close()return q end;function o.pack(P,z)local n=a.stat(a.combine(P,z))if n.type~=\"directory\"then return o.read(P,z)end;local q={[\"//\"]={name=z..\"/\",mode=m(n),owner=0,group=0,timestamp=n.modified,type=5,link=\"\",ownerName=n.owner,groupName=\"\",deviceNumber=nil,data=nil}}if string.sub(P,-1)==\"/\"then P=string.sub(P,1,-1)end;if z and string.sub(z,1,1)==\"/\"then z=string.sub(z,2)end;if z and string.sub(z,-1)==\"/\"then z=string.sub(z,1,-1)end;local N=z and P..\"/\"..z or P;for s,t in pairs(a.list(N))do if a.isDir(a.combine(N,t))then q[t]=o.pack(P,z and z..\"/\"..t or t)else q[t]=o.read(P,z and z..\"/\"..t or t)end;if o.verbosity>0 then print(a.combine(N,t)..\" => \"..(z and z..\"/\"..t or t))end end;return q end;function o.save(p,z,A)if not A then p=o.serialize(p)end;local Q=z==nil;local C;local G=0;if not Q then C=a.open(z,\"wb\")local R=C.write;C.write=function(e)for g in string.gmatch(e,\".\")do R(string.byte(g))end;G=G+string.len(e)end else C=\"\"end;for s,t in pairs(p)do local S=\"\"S=S..d(string.sub(t.name,-100),100,\"\\0\")S=S..(t.mode and string.format(\"%07o\\0\",t.mode)or string.rep(\"\\0\",8))S=S..(t.owner and string.format(\"%07o\\0\",t.owner)or string.rep(\"\\0\",8))S=S..(t.group and string.format(\"%07o\\0\",t.group)or string.rep(\"\\0\",8))S=S..(t.data and string.format(\"%011o\\0\",string.len(t.data))or string.rep(\"0\",11)..\"\\0\")S=S..(t.timestamp and string.format(\"%011o\\0\",t.timestamp)or string.rep(\"\\0\",12))S=S..t.type;S=S..(t.link and d(t.link,100,\"\\0\")or string.rep(\"\\0\",100))S=S..\"ustar  \\0\"S=S..(t.ownerName and d(t.ownerName,32,\"\\0\")or string.rep(\"\\0\",32))S=S..(t.groupName and d(t.groupName,32,\"\\0\")or string.rep(\"\\0\",32))S=S..(t.deviceNumber and t.deviceNumber[1]and string.format(\"%07o\\0\",t.deviceNumber[1])or string.rep(\"\\0\",8))S=S..(t.deviceNumber and t.deviceNumber[2]and string.format(\"%07o\\0\",t.deviceNumber[2])or string.rep(\"\\0\",8))S=S..(string.len(t.name)>100 and d(string.sub(t.name,1,-101),155,\"\\0\")or string.rep(\"\\0\",155))if string.len(S)<504 then S=S..string.rep(\"\\0\",504-string.len(S))end;local F=256;for g in string.gmatch(S,\".\")do F=F+string.byte(g)end;S=string.sub(S,1,148)..string.format(\"%06o\\0 \",F)..string.sub(S,149)if Q then C=C..S else C.write(S)end;if t.data~=nil and t.data~=\"\"then if Q then C=C..d(t.data,math.ceil(string.len(t.data)/512)*512,\"\\0\")else C.write(d(t.data,math.ceil(string.len(t.data)/512)*512,\"\\0\"))end end end;if Q then C=C..string.rep(\"\\0\",1024)else C.write(string.rep(\"\\0\",1024))end;if Q then C=C..string.rep(\"\\0\",10240-string.len(C)%10240)else C.write(string.rep(\"\\0\",10240-G%10240))end;if not Q then C.close()end;if Q then return C end end;return o\n",created=1704748612789,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=6722},["startmgr.lua"]={modified=1704748612667,data="local a=require\"system.expect\"local b=require\"system.ipc\"local c=require\"system.process\"local d={}local function e(f,g,h)h=h or c.getuser()local i=b.lookup(h==\"root\"and\"ServiceManager\"or\"ServiceManager.\"..h)if not i then error(\"Could not connect to service manager\",2)end;b.sendEvent(i,\"startmgr.request\",{func=f,param=g})while true do local j,k=b.receiveEvent(i,\"startmgr.response\",5)if not k then error(\"Timed out waiting for service manager\",2)end;if k.func==f then if k.ok then return table.unpack(k.result)else error(k.error,3)end end end end;function d.start(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"start\",l,h)end;function d.stop(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"stop\",l,h)end;function d.kill(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"kill\",l,h)end;function d.restart(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"restart\",l,h)end;function d.reload(l,h)a(1,l,\"string\",\"nil\")a(2,h,\"string\",\"nil\")return e(\"reload\",l,h)end;function d.add(m,h)a(1,m,\"string\")a(2,h,\"string\",\"nil\")return e(\"add\",m,h)end;function d.remove(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"remove\",l,h)end;function d.list(h)a(1,h,\"string\",\"nil\")return e(\"list\",nil,h)end;function d.status(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"status\",l,h)end;function d.install(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"install\",l,h)end;function d.uninstall(l,h)a(1,l,\"string\")a(2,h,\"string\",\"nil\")return e(\"uninstall\",l,h)end;function d.shutdown()if c.getuser()~=\"root\"then error(\"Permission denied\")end;return e(\"shutdown\",{},\"root\")end;function d.reboot()if c.getuser()~=\"root\"then error(\"Permission denied\")end;return e(\"reboot\",{},\"root\")end;return d\n",created=1704748612686,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1682},modules={modified=1704748612573,created=1704748612573,contents={["luz.lua"]={modified=1704748611568,data="if not PHOENIX_VERSION and not entries then error(\"This must be loaded as a kernel module.\")end;if entries then local a,b=...local c=dofile(fs.combine(fs.getDir(b),\"../luz/decompress.lua\"))function cmds.kernel(d)bootcfg.fn=unbios;bootcfg.args={d.path}local e=fs.open(d.path,\"rb\")if e then if e.read(5)==\"\\27LuzQ\"then local f=\"\\27LuzQ\"..e.readAll()e.close()print(\"Loading \"..d.path..\"...\")bootcfg.args={assert(load(c(f),\"@\"..d.path,\"t\",_G))}else e.close()end end end else local g=filesystem.stat(KERNEL,\"/lib/luz/decompress.lua\")if not g then error(\"Could not find Luz modules\")end;if g.worldPermissions.write then error(\"Unsafe permissions on /lib/luz/decompress.lua (must not be world-writable)\")end;for h,i in pairs(g.permissions)do if h~=\"root\"and i.write then error(\"Unsafe permissions on /lib/luz/decompress.lua (writable by non-root user)\")end end;local c=dofile(\"/lib/luz/decompress.lua\")local function j(f,k,l,m)if f:sub(1,5)~=\"\\27LuzQ\"then return nil end;return load(c(f),k,\"t\",m)end;addProcessLoader(j)syslog.log({module=\"luz\"},\"Registered Luz files as executable\")return{unload=function()removeProcessLoader(j)end}end\n",created=1704748611576,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1129},["fuse.lua"]={modified=1704748611043,data="local a={}function a:new(b,c,d)if type(d.fs)~=\"string\"then error(\"Missing filesystem type (fs option)\")end;local e;if d.fs:find\"/\"then e=d.fs else e=\"/lib/fuse/\"..d.fs..\".lua\"end;d.fs=nil;local f,g=userModeCallback(b,function()return assert(loadfile(e))(c,d)end)if not f then error(\"Could not create filesystem: \"..g)end;if type(g)~=\"table\"then error(\"Error creating filesystem\")end;local h={}local i=debug.getmetatable(g)if i and type(i.__index)==\"table\"then h={open=rawget(i.__index,\"open\"),list=rawget(i.__index,\"list\"),stat=rawget(i.__index,\"stat\"),remove=rawget(i.__index,\"remove\"),rename=rawget(i.__index,\"rename\"),mkdir=rawget(i.__index,\"mkdir\"),link=rawget(i.__index,\"link\"),mkfifo=rawget(i.__index,\"mkfifo\"),chmod=rawget(i.__index,\"chmod\"),chown=rawget(i.__index,\"chown\"),unmount=rawget(i.__index,\"unmount\"),init=rawget(i.__index,\"init\")}end;h.open=rawget(g,\"open\")or h.open;h.list=rawget(g,\"list\")or h.list;h.stat=rawget(g,\"stat\")or h.stat;h.remove=rawget(g,\"remove\")or h.remove;h.rename=rawget(g,\"rename\")or h.rename;h.mkdir=rawget(g,\"mkdir\")or h.mkdir;h.link=rawget(g,\"link\")or h.link;h.mkfifo=rawget(g,\"mkfifo\")or h.mkfifo;h.chmod=rawget(g,\"chmod\")or h.chmod;h.chown=rawget(g,\"chown\")or h.chown;h.unmount=rawget(g,\"unmount\")or h.unmount;h.init=rawget(g,\"init\")or h.init;local j=setmetatable({origin=e,path=c,fs=g,methods=h,options=d,running=true},{__index=self})j.process=processes[syscalls.fork(b,nil,function()while j.running do coroutine.yield()end end,\"[fuse \"..e..\"]\")]j.process.threads[0].status=\"paused\"syscalls.stdin(j.process,nil,nil)syscalls.stdout(j.process,nil,nil)syscalls.stderr(j.process,nil,nil)if h.init then userModeCallback(j.process,h.init,g,syscalls.getpinfo(j.process,nil,b.id))end;return j end;function a:open(b,c,k)if not self.methods.open then error(\"Filesystem is missing method 'open'\")end;local l,m;assert(userModeCallback(self.process,function(n)l,m=self.methods.open(self.fs,n,c,k)end,syscalls.getpinfo(self.process,nil,b.id)))if type(l)==\"string\"then return filesystem.readhandle(b,l,m)elseif type(l)==\"function\"then return filesystem.writehandle(b,l,m)else return l,m end end;function a:list(b,c)if not self.methods.list then error(\"Filesystem is missing method 'list'\")end;return select(2,assert(userModeCallback(self.process,self.methods.list,self.fs,syscalls.getpinfo(self.process,nil,b.id),c)))end;function a:stat(b,c,o)if not self.methods.stat then error(\"Filesystem is missing method 'stat'\")end;return select(2,assert(userModeCallback(self.process,self.methods.stat,self.fs,syscalls.getpinfo(self.process,nil,b.id),c,o)))end;function a:remove(b,c)if not self.methods.remove then error(\"Filesystem is missing method 'remove'\")end;assert(userModeCallback(self.process,self.methods.remove,self.fs,syscalls.getpinfo(self.process,nil,b.id),c))end;function a:rename(b,c,p)if not self.methods.rename then error(\"Filesystem is missing method 'rename'\")end;assert(userModeCallback(self.process,self.methods.rename,self.fs,syscalls.getpinfo(self.process,nil,b.id),c,p))end;function a:mkdir(b,c)if not self.methods.mkdir then error(\"Filesystem is missing method 'mkdir'\")end;assert(userModeCallback(self.process,self.methods.mkdir,self.fs,syscalls.getpinfo(self.process,nil,b.id),c))end;function a:link(b,c,q)if not self.methods.link then error(\"Filesystem is missing method 'link'\")end;assert(userModeCallback(self.process,self.methods.link,self.fs,syscalls.getpinfo(self.process,nil,b.id),c,q))end;function a:mkfifo(b,c)if not self.methods.mkfifo then error(\"Filesystem is missing method 'mkfifo'\")end;assert(userModeCallback(self.process,self.methods.mkfifo,self.fs,syscalls.getpinfo(self.process,nil,b.id),c))end;function a:chmod(b,c,r,k)if not self.methods.chmod then error(\"Filesystem is missing method 'chmod'\")end;assert(userModeCallback(self.process,self.methods.chmod,self.fs,syscalls.getpinfo(self.process,nil,b.id),c,r,k))end;function a:chown(b,c,s)if not self.methods.chown then error(\"Filesystem is missing method 'chown'\")end;assert(userModeCallback(self.process,self.methods.chown,self.fs,syscalls.getpinfo(self.process,nil,b.id),c,s))end;function a:info()return self.origin:match\"[^/]*$\":gsub(\"%.lua$\",\"\"),self.path,self.options end;function a:unmount(b)if self.methods.unmount then userModeCallback(self.process,self.methods.unmount,syscalls.getpinfo(self.process,nil,b.id))end;self.running=false;self.process.threads[0].status=\"suspended\"self.process.eventQueue[#self.process.eventQueue+1]={\"resume\",{}}end;filesystems.fuse=a;syslog.log({module=\"fuse\"},\"FUSE is now loaded\")return{unload=function()filesystems.fuse=nil end}\n",created=1704748611053,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=4584},["spanfs.lua"]={modified=1704748612551,data="if not PHOENIX_VERSION then error(\"This file must be loaded as a kernel module.\")end;if not filesystem.readhandle then error(\"This module requires Phoenix 0.0.4 or later.\")end;do local _={disks={[0]=\"/disk\",\"/disk2\",\"/disk1\",\"/disk3\"},uuid=\"7f747493-a515-4dbd-bc63-b74070882b24\",name=\"Test span\",index={meta={size=0,created=0,modified=0,type=\"directory\",owner=\"root\",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={[\"test.txt\"]={meta={size=13,created=0,modified=0,type=\"file\",owner=\"root\",permissions={root={read=true,write=true,execute=false}},worldPermissions={read=true,write=false,execute=false},setuser=false},uuid=\"0de93ec6-2cf9-491c-bc59-04a9977606f9\",ids={2,1},checksum=\"6b72b48f\"}}}}end;local a={[0]=0x00000000,0x77073096,0xee0e612c,0x990951ba,0x076dc419,0x706af48f,0xe963a535,0x9e6495a3,0x0edb8832,0x79dcb8a4,0xe0d5e91e,0x97d2d988,0x09b64c2b,0x7eb17cbd,0xe7b82d07,0x90bf1d91,0x1db71064,0x6ab020f2,0xf3b97148,0x84be41de,0x1adad47d,0x6ddde4eb,0xf4d4b551,0x83d385c7,0x136c9856,0x646ba8c0,0xfd62f97a,0x8a65c9ec,0x14015c4f,0x63066cd9,0xfa0f3d63,0x8d080df5,0x3b6e20c8,0x4c69105e,0xd56041e4,0xa2677172,0x3c03e4d1,0x4b04d447,0xd20d85fd,0xa50ab56b,0x35b5a8fa,0x42b2986c,0xdbbbc9d6,0xacbcf940,0x32d86ce3,0x45df5c75,0xdcd60dcf,0xabd13d59,0x26d930ac,0x51de003a,0xc8d75180,0xbfd06116,0x21b4f4b5,0x56b3c423,0xcfba9599,0xb8bda50f,0x2802b89e,0x5f058808,0xc60cd9b2,0xb10be924,0x2f6f7c87,0x58684c11,0xc1611dab,0xb6662d3d,0x76dc4190,0x01db7106,0x98d220bc,0xefd5102a,0x71b18589,0x06b6b51f,0x9fbfe4a5,0xe8b8d433,0x7807c9a2,0x0f00f934,0x9609a88e,0xe10e9818,0x7f6a0dbb,0x086d3d2d,0x91646c97,0xe6635c01,0x6b6b51f4,0x1c6c6162,0x856530d8,0xf262004e,0x6c0695ed,0x1b01a57b,0x8208f4c1,0xf50fc457,0x65b0d9c6,0x12b7e950,0x8bbeb8ea,0xfcb9887c,0x62dd1ddf,0x15da2d49,0x8cd37cf3,0xfbd44c65,0x4db26158,0x3ab551ce,0xa3bc0074,0xd4bb30e2,0x4adfa541,0x3dd895d7,0xa4d1c46d,0xd3d6f4fb,0x4369e96a,0x346ed9fc,0xad678846,0xda60b8d0,0x44042d73,0x33031de5,0xaa0a4c5f,0xdd0d7cc9,0x5005713c,0x270241aa,0xbe0b1010,0xc90c2086,0x5768b525,0x206f85b3,0xb966d409,0xce61e49f,0x5edef90e,0x29d9c998,0xb0d09822,0xc7d7a8b4,0x59b33d17,0x2eb40d81,0xb7bd5c3b,0xc0ba6cad,0xedb88320,0x9abfb3b6,0x03b6e20c,0x74b1d29a,0xead54739,0x9dd277af,0x04db2615,0x73dc1683,0xe3630b12,0x94643b84,0x0d6d6a3e,0x7a6a5aa8,0xe40ecf0b,0x9309ff9d,0x0a00ae27,0x7d079eb1,0xf00f9344,0x8708a3d2,0x1e01f268,0x6906c2fe,0xf762575d,0x806567cb,0x196c3671,0x6e6b06e7,0xfed41b76,0x89d32be0,0x10da7a5a,0x67dd4acc,0xf9b9df6f,0x8ebeeff9,0x17b7be43,0x60b08ed5,0xd6d6a3e8,0xa1d1937e,0x38d8c2c4,0x4fdff252,0xd1bb67f1,0xa6bc5767,0x3fb506dd,0x48b2364b,0xd80d2bda,0xaf0a1b4c,0x36034af6,0x41047a60,0xdf60efc3,0xa867df55,0x316e8eef,0x4669be79,0xcb61b38c,0xbc66831a,0x256fd2a0,0x5268e236,0xcc0c7795,0xbb0b4703,0x220216b9,0x5505262f,0xc5ba3bbe,0xb2bd0b28,0x2bb45a92,0x5cb36a04,0xc2d7ffa7,0xb5d0cf31,0x2cd99e8b,0x5bdeae1d,0x9b64c2b0,0xec63f226,0x756aa39c,0x026d930a,0x9c0906a9,0xeb0e363f,0x72076785,0x05005713,0x95bf4a82,0xe2b87a14,0x7bb12bae,0x0cb61b38,0x92d28e9b,0xe5d5be0d,0x7cdcefb7,0x0bdbdf21,0x86d3d2d4,0xf1d4e242,0x68ddb3f8,0x1fda836e,0x81be16cd,0xf6b9265b,0x6fb077e1,0x18b74777,0x88085ae6,0xff0f6a70,0x66063bca,0x11010b5c,0x8f659eff,0xf862ae69,0x616bffd3,0x166ccf45,0xa00ae278,0xd70dd2ee,0x4e048354,0x3903b3c2,0xa7672661,0xd06016f7,0x4969474d,0x3e6e77db,0xaed16a4a,0xd9d65adc,0x40df0b66,0x37d83bf0,0xa9bcae53,0xdebb9ec5,0x47b2cf7f,0x30b5ffe9,0xbdbdf21c,0xcabac28a,0x53b39330,0x24b4a3a6,0xbad03605,0xcdd70693,0x54de5729,0x23d967bf,0xb3667a2e,0xc4614ab8,0x5d681b02,0x2a6f2b94,0xb40bbe37,0xc30c8ea1,0x5a05df1b,0x2d02ef8d}local function b(c,d)d=d and bit32.bnot(d)or 0xFFFFFFFF;for e=1,#c do d=bit32.bxor(a[bit32.band(bit32.bxor(c:byte(e),bit32.band(d,0xFF)))],bit32.rshift(d,8))end;return bit32.bnot(d)end;local function f()return('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'):gsub('[xy]',function(g)local h=g=='x'and math.random(0,0xf)or math.random(8,0xb)return('%x'):format(h)end)end;local function i(j,k)local l=fs.combine(j.root,k:sub(1,1)==\"/\"and\"\"or j.dir,k)if\"/\"..l..\"/\"~=j.root and l:find(j.root:sub(2),1,true)~=1 then error(k..\": No such file or directory\",4)end;return l end;local m={}local n={file=0,link=2,directory=5,fifo=6,[0]=\"file\",[2]=\"link\",[5]=\"directory\",[6]=\"fifo\"}local function o(p)local q=(\"<I\"):unpack(p.read(4))local r=p.read(q)local s={meta={permissions={}}}local type,t,u,v,w;s.meta.size,s.meta.created,s.meta.modified,type,t,u,s.meta.owner,v,w=(\"<II8I8BBs2s2B\"):unpack(r)s.meta.type=n[type]s.meta.setuser=bit32.btest(t,0x80)s.meta.worldPermissions={read=bit32.btest(t,4),write=bit32.btest(t,2),execute=bit32.btest(t,1)}for _=1,v do local x,y;x,y,w=(\"<s2B\"):unpack(r,w)s.meta.permissions[x]={read=bit32.btest(y,4),write=bit32.btest(y,2),execute=bit32.btest(y,1)}end;if type==0 then local z=p.read(16)s.uuid=z:gsub(\".\",function(g)return(\"%02x\"):format(g:byte())end):gsub(\"(%x%x%x%x%x%x%x%x)(%x%x%x%x)(%x%x%x%x)(%x%x%x%x)(%x%x%x%x%x%x%x%x%x%x%x%x)\",\"%1-%2-%3-%4-%5\")local A=(\"<H\"):unpack(p.read(2))s.ids={(\"<\"..(\"H\"):rep(A)):unpack(p.read(A*2))}s.ids[#s.ids]=nil;s.checksum=(\"<I\"):unpack(p.read(4))elseif type==2 then local B=(\"<H\"):unpack(p.read(2))s.link=p.read(B)elseif type==5 then local C=(\"<I\"):unpack(p.read(4))s.contents={}for _=1,C do local D,E=o(p)s.contents[D]=E end end;return u,s end;local function F(p,s,u)local G=\"\"local v=0;for H,h in pairs(s.meta.permissions)do v=v+1;G=G..(\"<s2B\"):pack(H,(h.read and 4 or 0)+(h.write and 2 or 0)+(h.execute and 1 or 0))end;local I=(\"<II8I8BBs2s2B\"):pack(s.meta.size,s.meta.created,s.meta.modified,n[s.meta.type],(s.meta.setuser and 128 or 0)+(s.meta.worldPermissions.read and 4 or 0)+(s.meta.worldPermissions.write and 2 or 0)+(s.meta.worldPermissions.execute and 1 or 0),u or\"\",s.meta.owner,v)..G;p.write((\"<I\"):pack(#I)..I)if s.meta.type==\"file\"then p.write(s.uuid:gsub(\"%-\",\"\"):gsub(\"%x%x\",function(J)return string.char(tonumber(J,16))end)..(\"<\"..(\"H\"):rep(#s.ids+1)):pack(#s.ids,table.unpack(s.ids))..(\"<I\"):pack(s.checksum))elseif s.meta.type==\"link\"then p.write((\"<s2\"):pack(s.link))elseif s.meta.type==\"directory\"then local D=0;for _ in pairs(s.contents)do D=D+1 end;p.write((\"<I4\"):pack(D))for H,h in pairs(s.contents)do F(p,h,H)end end end;local function K(q,L,M)q=math.max(q,500)local N,O={},{}for _,h in ipairs(M)do O[h]=true end;for _,h in ipairs(L)do if not O[h]and h.space>=500 then N[#N+1]=h end end;table.sort(N,function(P,Q)if P.space==Q.space then return P.id>Q.id else return P.space>Q.space end end)local R={}while q>N[1].space do R[N[1].id]=N[1].space;q=q-N[1].space;table.remove(N,1)if#N==0 then return nil end end;if q==0 then return R end;table.sort(N,function(P,Q)if P.space==Q.space then return P.id>Q.id else return P.space>Q.space end end)for e=#N,1,-1 do if q<N[e].space then R[N[e].id]=q;return R end end;return nil end;function m:_write_meta()local p=assert(fs.open(fs.combine(self.disks[0],\"index\"),\"wb\"))F(p,self.index,self.name)p.close()end;function m:getpath(x,k,S)local T=self.index;local U=split(fs.combine(k),\"/\\\\\")for e,l in ipairs(U)do if not T then return nil elseif T.meta.type~=\"directory\"then error(\"Not a directory\",2)elseif T.meta.permissions[x]then if not T.meta.permissions[x].execute then error(\"Permission denied\",2)end elseif not T.meta.worldPermissions.execute then error(\"Permission denied\",2)end;T=T.contents[l]if T and T.meta.type==\"link\"and not(S and e==#U)then error{link=true,path=filesystem.combine(T.link,table.unpack(U,e+1)),orig=k}end end;return T end;function m:setpath(x,k,r,S)local T=self.index;local E=split(k,\"/\\\\\")local V=E[#E]E[#E]=nil;for e,l in ipairs(E)do if T.meta.type~=\"directory\"then error(\"Not a directory\",2)elseif T.meta.permissions[x]then if not T.meta.permissions[x].execute then error(\"Permission denied\",2)end elseif not T.meta.worldPermissions.execute then error(\"Permission denied\",2)end;if not T.contents[l]then T.contents[l]={meta={type=\"directory\",owner=T.meta.owner,permissions=deepcopy(T.meta.permissions),worldPermissions=deepcopy(T.meta.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\"},contents={}}end;T=T.contents[l]if T and T.meta.type==\"link\"then error{link=true,path=filesystem.combine(T.link,table.unpack(E,e+1)),orig=k}end end;if T.meta.type~=\"directory\"then error(\"Not a directory\",2)elseif x~=\"root\"then if T.meta.permissions[x]then if not T.meta.permissions[x].execute then error(\"Permission denied\",2)end elseif not T.meta.worldPermissions.execute then error(\"Permission denied\",2)end end;if not S and T.contents[V]and T.contents[V].type==\"link\"then error{link=true,path=T.contents[V].link,orig=k}end;T.contents[V]=r;self:_write_meta()end;function m:new(j,k,W)if k:match\"^/\"then k=k:gsub(\"/%.spanfs$\",\"\"):gsub(\"/index$\",\"\")local p=assert(fs.open(fs.combine(k,\".spanfs\"),\"r\"))p.readLine()k=p.readLine()p.close()end;local X=setmetatable({disks={},index={},id={}},{__index=self})local z,u=false,false;if k:match\"^%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x$\"then z=k else u=k end;for _,Y in ipairs{hardware.find(\"drive\")}do local Z=hardware.call(j,Y,\"getMountPath\")if Z then local p=fs.open(fs.combine(Z,\".spanfs\"),\"r\")if p then local D,a0,a1=p.readLine(),p.readLine(),p.readLine()if D==u or a0==z then X.name,X.uuid,X.disks[tonumber(a1)]=D,a0,Z end;p.close()end end end;if#X.disks==0 then error(\"Could not find span '\"..(u or z)..\"'\",2)end;if not X.disks[0]then error(\"Could not find index disk for span '\"..(u or z)..\"'\",2)end;local p,a2=fs.open(fs.combine(X.disks[0],\"index\"),\"rb\")if p then _,X.index=o(p)else syslog.log({level=\"warning\",module=\"spanfs\"},\"Could not open index file for reading on span '\"..(u or z)..\"':\",a2,\". Initializing empty span.\")X.index={meta={size=0,created=os.epoch\"utc\",modified=os.epoch\"utc\",type=\"directory\",owner=j.user,permissions={[j.user]={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}}end;return X end;function m:_open_internal(j,k,a3)local a4,fs,do_syscall,ipairs,assert,pairs,a5=os.epoch,fs,do_syscall,ipairs,assert,pairs,string.sub;local s=self:getpath(j.user,k)if not s then return nil,\"No such file\"end;if a3==\"r\"or a3==\"rb\"then local r=\"\"for _,h in ipairs(s.ids)do if not self.disks[h]then return nil,\"Disk ID \"..h..\" is required by file but not available\"end;local p,a2=fs.open(fs.combine(self.disks[h],s.uuid),\"rb\")if not p then return nil,\"Could not open part on disk ID \"..h..\" (\"..self.disks[h]..\"): \"..a2 end;r=r..(p.readAll()or\"\")p.close()end;local a6=b(r)if a6~=s.checksum then return nil,\"Checksum failed\"end;return filesystem.readhandle(j,r,a3==\"rb\")elseif a3==\"w\"or a3==\"wb\"or#s.ids==0 and(a3==\"a\"or a3==\"ab\")then for _,h in ipairs(s.ids)do fs.delete(fs.combine(self.disks[h],s.uuid))end;s.uuid=f()s.ids={}s.checksum=0;s.meta.modified=a4\"utc\"local a7={}local a8,a9=self.id,self.disks;return filesystem.writehandle(j,function(aa,ab)local a6=b(aa,ab and 0 or s.checksum)if#aa==0 then if ab then s.meta.size=0 end;s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)return end;if#a7~=0 then if ab then for _,h in ipairs(a7)do local a1=a5(aa,1,#h.data)if a1~=h.data then local p=assert(fs.open(fs.combine(a9[h.id],s.uuid),\"wb\"))p.write(a1)p.close()h.data=a1 end;aa=a5(aa,#h.data+1)end;if#aa==0 then if ab then s.meta.size=#aa else s.meta.size=s.meta.size+#aa end;s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)return end end;local ac=fs.getFreeSpace(a9[s.ids[#s.ids]])if ac>0 then local a1=a5(aa,1,ac)local p=assert(fs.open(fs.combine(a9[s.ids[#s.ids]],s.uuid),\"ab\"))p.write(a1)p.close()a7[#a7].data=a7[#a7].data..a1;if ac>#aa then if ab then s.meta.size=#aa else s.meta.size=s.meta.size+#aa end;s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)return end;aa=a5(aa,ac+1)end end;local N={}for e,h in pairs(a9)do if e~=0 then N[#N+1]={id=e,space=fs.getFreeSpace(h)}end end;local ad=K(#aa,N,s.ids)if not ad then if not ab then ab=true;local I=\"\"for _,h in ipairs(a7)do I=I..h.data;for _,ae in ipairs(N)do if ae==h.id then ae.space=ae.space-#h.data end end end;aa=I..aa end;ad=K(#aa,N,{})if not ad then error(\"Out of space\",2)end;for _,h in ipairs(s.ids)do fs.delete(fs.combine(a9[h],s.uuid))end;a7={}s.ids={}end;for e,h in pairs(ad)do local a1=a5(aa,1,h)local p=assert(fs.open(fs.combine(a9[e],s.uuid),\"wb\"))p.write(a1)p.close()a7[#a7+1]={data=a1,id=e}s.ids[#s.ids+1]=e;aa=a5(aa,h+1)end;if ab then s.meta.size=#aa else s.meta.size=s.meta.size+#aa end;s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)end,a3==\"wb\")elseif a3==\"a\"or a3==\"ab\"then local af;do local p=fs.open(fs.combine(self.disks[s.ids[#s.ids]],s.uuid),\"rb\")if p then af=p.readAll()or\"\"p.close()else af=\"\"end end;local a7={{id=s.ids[#s.ids],data=af,offset=#af}}local ag=s.checksum;local ah=s.meta.size;local a8,a9=self.id,self.disks;return filesystem.writehandle(j,function(aa,ab)local a6=b(aa,ab and ag or s.checksum)if#aa==0 then s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)return end;if ab then for _,h in ipairs(a7)do local a1=h.offset and h.data:sub(1,h.offset)..a5(aa,1,#h.data-h.offset)or a5(aa,1,#h.data)if a1~=h.data then local p=assert(fs.open(fs.combine(a9[h.id],s.uuid),\"wb\"))p.write(a1)p.close()h.data=a1 end;aa=a5(aa,#h.data-(h.offset or 0)+1)end;if#aa==0 then if ab then s.meta.size=ah+#aa else s.meta.size=s.meta.size+#aa end;s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)return end end;local ac=fs.getFreeSpace(a9[s.ids[#s.ids]])if ac>0 then local a1=a5(aa,1,ac)local p=assert(fs.open(fs.combine(a9[s.ids[#s.ids]],s.uuid),\"ab\"))p.write(a1)p.close()a7[#a7].data=a7[#a7].data..a1;if ac>#aa then if ab then s.meta.size=ah+#aa else s.meta.size=s.meta.size+#aa end;s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)return end;aa=a5(aa,ac+1)end;local N={}for e,h in pairs(a9)do if e~=0 then N[#N+1]={id=e,space=fs.getFreeSpace(h)}end end;local ad=K(#aa,N,s.ids)if not ad then local ai=\"\"for _,h in ipairs(s.ids)do local aj=false;for _,ae in ipairs(a7)do if ae.id==h then aj=true;break end end;if aj then break end;local p=assert(fs.open(fs.combine(a9[h],s.uuid),\"rb\"))ai=ai..(p.readAll()or\"\")p.close()end;if ab then aa=ai..a5(a7[1].data,1,a7[1].offset)..aa else ab=true;local I=\"\"for _,h in ipairs(a7)do I=I..h.data;for _,ae in ipairs(N)do if ae==h.id then ae.space=ae.space-#h.data end end end;aa=ai..I..aa end;ad=K(#aa,N,{})if not ad then error(\"Out of space\",2)end;for _,h in ipairs(s.ids)do fs.delete(fs.combine(a9[h],s.uuid))end;a7={}s.ids={}ah=0 end;for e,h in pairs(ad)do local a1=a5(aa,1,h)local p=assert(fs.open(fs.combine(a9[e],s.uuid),\"wb\"))p.write(a1)p.close()a7[#a7+1]={data=a1,id=e}aa=a5(aa,h+1)end;if ab then s.meta.size=ah+#aa else s.meta.size=s.meta.size+#aa end;s.meta.modified=a4\"utc\"s.checksum=a6;do_syscall(\"callmodule\",\"spanfs\",\"_write_meta\",a8)end,a3==\"ab\")else return nil,\"Invalid mode\"end end;function m:open(j,k,a3)local ak,al=pcall(self.stat,self,j,k)if not ak then if type(al)==\"table\"then error(al)end;return nil,al elseif not al then if a3:sub(1,1)==\"w\"or a3:sub(1,1)==\"a\"then local am,an=pcall(self.stat,self,j,fs.getDir(k))if not am or not an then if type(an)==\"table\"then error(an)end;local ao,a2=pcall(self.mkdir,self,j,fs.getDir(k))if not ao then if type(a2)==\"table\"then error(a2)end;return nil,a2:gsub(\"kernel:%d: \",\"\")end;an=self:stat(j,fs.getDir(k))end;if j.user~=\"root\"then local G=an.permissions[j.user]or an.worldPermissions;if not G.write then return nil,\"Permission denied\"end end;local ap={type=\"file\",size=0,owner=j.user,permissions=deepcopy(an.permissions),worldPermissions=deepcopy(an.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\"}local T=ap.permissions[an.owner]ap.permissions[an.owner]=nil;ap.permissions[j.user]=T;self:setpath(j.user,k,{meta=ap,uuid=f(),ids={},checksum=0})return self:_open_internal(j,k,a3)else return nil,\"File not found\"end elseif al.type==\"directory\"then return nil,\"Is a directory\"end;if j.user~=\"root\"then local G=al.permissions[j.user]or al.worldPermissions;if a3:sub(1,1)==\"r\"and not G.read or(a3:sub(1,1)==\"w\"or a3:sub(1,1)==\"a\")and not G.write then return nil,\"Permission denied\"end end;if al.type==\"fifo\"then local ap=self:getpath(j.user,k)local aq=fifos[ap]if not aq then aq={data=\"\"}fifos[ap]=aq end;return filesystem.fifohandle(j,aq,a3)end;return self:_open_internal(j,k,a3)end;function m:list(j,k)local r=self:getpath(j.user,k)if not r or r.meta.type~=\"directory\"then error(k..\": Not a directory\",2)end;if j.user~=\"root\"then local G=r.meta.permissions[j.user]or r.meta.worldPermissions;if not G.read then error(k..\": Permission denied\",2)end end;local R={}for H in pairs(r.contents)do R[#R+1]=H end;table.sort(R)return R end;function m:stat(j,k,S)local r=self:getpath(j.user,k,S)if not r then return nil,\"No such file or directory\"end;local ar,as=0,0;for e,h in pairs(self.disks)do if e~=0 then ar,as=ar+fs.getCapacity(h),as+fs.getFreeSpace(h)end end;return{size=r.meta.size,type=r.meta.type,created=r.meta.created,modified=r.meta.modified,owner=r.meta.owner,permissions=deepcopy(r.meta.permissions),worldPermissions=deepcopy(r.meta.worldPermissions),setuser=r.meta.setuser,capacity=ar,freeSpace=as,link=r.link,special={}}end;function m:remove(j,k)local at=self:getpath(j.user,fs.getDir(k))local u=fs.getName(k)if not at or at.meta.type~=\"directory\"or not at.contents[u]then return end;if j.user~=\"root\"and not(at.meta.permissions[j.user]or at.meta.worldPermissions).write then error(k..\": Permission denied\",2)end;local r=at.contents[u]if j.user~=\"root\"and not(r.meta.permissions[j.user]or r.meta.worldPermissions).write then error(k..\": Permission denied\",2)end;local function au(I)local G=I.meta.permissions[j.user]or I.meta.worldPermissions;if j.user~=\"root\"and not G.write then error(k..\": Permission denied\",3)end;if I.meta.type==\"directory\"then if j.user~=\"root\"and not G.read then error(k..\": Permission denied\",3)end;for _,h in pairs(I.contents)do au(h)end end end;au(r)local function av(s)if s.meta.type==\"directory\"then for _,h in pairs(s.contents)do av(h)end elseif s.meta.type==\"file\"then for _,h in pairs(self.disks)do fs.delete(fs.combine(h,s.uuid))end end end;av(r)at.contents[u]=nil;at.meta.modified=os.epoch\"utc\"self:_write_meta()end;function m:rename(j,aw,ax)local ay=self:getpath(j.user,fs.getDir(aw))local az=fs.getName(aw)if not ay or ay.meta.type~=\"directory\"or not ay.contents[az]then error(aw..\": No such file or directory\",2)end;if j.user~=\"root\"and not(fparen.metat.permissions[j.user]or ay.meta.worldPermissions).write then error(aw..\": Permission denied\",2)end;local aA=ay.contents[az]if j.user~=\"root\"and not(aA.permissions[j.user]or aA.worldPermissions).write then error(aw..\": Permission denied\",2)end;local aB=self:getpath(j.user,fs.getDir(ax))local aC=fs.getName(ax)if not aB or aB.meta.type~=\"directory\"then error(ax..\": No such file or directory\",2)end;if j.user~=\"root\"and not(aB.meta.permissions[j.user]or aB.meta.worldPermissions).write then error(ax..\": Permission denied\",2)end;local aD=aB.contents[aC]if aD then error(ax..\": File already exists\",2)end;aB.contents[aC],ay.contents[az]=aA,nil;local aE=os.epoch\"utc\"ay.meta.modified,aB.meta.modified=aE,aE end;function m:mkdir(j,k)local T=self.index;for _,l in ipairs(split(k,\"/\\\\\"))do local G=T.meta.permissions[j.user]or T.meta.worldPermissions;if T.meta.type~=\"directory\"then error(k..\": File exists\",2)elseif j.user~=\"root\"and not G.execute then error(k..\": Permission denied\",2)end;if not T.contents[l]then if j.user~=\"root\"and not G.write then error(k..\": Permission denied\",2)end;T.contents[l]={meta={type=\"directory\",size=0,owner=T.meta.owner,permissions=deepcopy(T.meta.permissions),worldPermissions=deepcopy(T.meta.worldPermissions),created=os.epoch\"utc\",modified=os.epoch\"utc\"},contents={}}T.meta.modified=os.epoch\"utc\"end;T=T.contents[l]end;self:_write_meta()end;function m:link(j,k,aF)local al=self:stat(j,k)if al then error(k..\": File exists\",2)end;local am,an=pcall(self.stat,self,j,fs.getDir(k))if not am or not an then if type(an)==\"table\"then error(an)end;local ao,a2=pcall(self.mkdir,self,j,fs.getDir(k))if not ao then if type(a2)==\"table\"then error(a2)end;return nil,type(a2)==\"string\"and a2:gsub(\"kernel:%d: \",\"\")or a2 end;an=self:stat(j,fs.getDir(k))end;self:setpath(j.user,k,{meta={type=\"link\",size=0,owner=j.user,permissions=deepcopy(an.permissions),worldPermissions=deepcopy(an.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\"},link=aF},true)end;function m:mkfifo(j,k)local al=self:stat(j,k)if al then error(k..\": File exists\",2)end;local am,an=pcall(self.stat,self,j,fs.getDir(k))if not am or not an then if type(an)==\"table\"then error(an)end;local ao,a2=pcall(self.mkdir,self,j,fs.getDir(k))if not ao then if type(a2)==\"table\"then error(a2)end;return nil,type(a2)==\"string\"and a2:gsub(\"kernel:%d: \",\"\")or a2 end;an=self:stat(j,fs.getDir(k))end;self:setpath(j.user,k,{meta={type=\"fifo\",size=0,owner=j.user,permissions=deepcopy(an.permissions),worldPermissions=deepcopy(an.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\"}},true)end;function m:chmod(j,k,x,a3)local al=self:getpath(j.user,k,true)if not al then error(k..\": No such file or directory\",2)end;if not al.meta.owner or j.user~=\"root\"and j.user~=al.meta.owner then error(k..\": Permission denied\",2)end;local G;if x==nil then G=al.meta.worldPermissions else G=al.meta.permissions[x]if not G then G=deepcopy(al.meta.worldPermissions)al.meta.permissions[x]=G end end;if type(a3)==\"string\"then if a3:match\"^[%+%-=][rwxs]+$\"then local aG=a3:sub(1,1)local T={}for g in a3:gmatch(\"[rwxs]\")do if g==\"r\"then T.read=true elseif g==\"w\"then T.write=true elseif g==\"s\"then T.setuser=true else T.execute=true end end;if aG==\"+\"then if T.read then G.read=true end;if T.write then G.write=true end;if T.execute then G.execute=true end;if T.setuser then al.meta.setuser=true end elseif aG==\"-\"then if T.read then G.read=false end;if T.write then G.write=false end;if T.execute then G.execute=false end;if T.setuser then al.meta.setuser=false end else G.read=T.read or false;G.write=T.write or false;G.execute=T.execute or false;al.meta.setuser=T.setuser or false end else G.read=a3:sub(1,1)~=\"-\"G.write=a3:sub(2,2)~=\"-\"G.execute=a3:sub(3,3)~=\"-\"al.meta.setuser=a3:sub(3,3)==\"s\"end elseif type(a3)==\"number\"then al.meta.setuser=bit32.btest(a3,8)G.read=bit32.btest(a3,4)G.write=bit32.btest(a3,2)G.execute=bit32.btest(a3,1)else if a3.read~=nil then G.read=a3.read end;if a3.write~=nil then G.write=a3.write end;if a3.execute~=nil then G.execute=a3.execute end;if a3.setuser~=nil then al.meta.setuser=a3.setuser end end;self:_write_meta()end;function m:chown(j,k,aH)local al=self:getpath(j.user,k,true)if not al then error(k..\": No such file or directory\",2)end;if not al.meta.owner or j.user~=\"root\"and j.user~=al.meta.owner then error(k..\": Permission denied\",2)end;al.meta.owner=aH;al.meta.setuser=false;self:_write_meta()end;function m:info()return\"spanfs\",self.uuid,{}end;filesystems.spanfs=m;syslog.log({module=\"spanfs\"},\"spanfs is now loaded\")return{_write_meta=function(j,aI,a8)for _,h in pairs(mounts)do if h.id==a8 then return m._write_meta(h)end end;error(\"Invalid mount handle\")end,info=function(j,aI,k)expect(1,k,\"string\")k=i(j,k)local aG=mounts[k]if not aG then error(k..\": No such mount\",2)end;if aG:info()~=\"spanfs\"then error(k..\": Not a spanfs filesystem\",2)end;local aJ={}for _,Y in ipairs{hardware.find(\"drive\")}do local l=hardware.call(j,Y,\"getMountPath\")if l then aJ[l]=Y.uuid end end;local R={disks={},name=aG.name,uuid=aG.uuid}R.freeindex=fs.getFreeSpace(aG.disks[0])for e,h in pairs(aG.disks)do if e~=0 then R.disks[e]={device=aJ[h],space=fs.getFreeSpace(h)}end end;return R end,unload=function()filesystems.spanfs=nil end}\n",created=1704748612573,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=23852}},owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},["diff.lua"]={modified=1704748610671,data="local a={}SKIP_SEPARATOR=true;IN=\"in\"OUT=\"out\"SAME=\"same\"local function b(c,d,e)d=d or\"%s+\"local f={}local g=1;local h,i=c:find(d,g)while h do table.insert(f,c:sub(g,h-1))if not e then table.insert(f,c:sub(h,i))end;g=i+1;h,i=c:find(d,g)end;if c:sub(g)~=\"\"then table.insert(f,c:sub(g))end;return f end;function a.quick_LCS(j,k)local l=#j;local m=#k;local n={}local setmetatable=setmetatable;local o={__index=function(p,q)p[q]=0;return 0 end}local r={__index=function(p,q)local s={}setmetatable(s,o)p[q]=s;return s end}setmetatable(n,r)local t=math.max;for u=1,l+1 do local v=n[u+1]local w=n[u]for x=1,m+1 do if j[u-1]==k[x-1]then v[x+1]=w[x]+1 else v[x+1]=t(v[x],w[x+1])end end end;return n end;local function y(c)c=c:gsub(\"&\",\"&amp;\"):gsub(\">\",\"&gt;\"):gsub(\"<\",\"&lt;\")c=c:gsub(\"\\\"\",\"&quot;\")return c end;function a.format_as_html(z)local A=\"\"local B,C;for u,D in ipairs(z)do B=y(D[1])C=D[2]if C==\"in\"then A=A..\"<ins>\"..B..\"</ins>\"elseif C==\"out\"then A=A..\"<del>\"..B..\"</del>\"else A=A..B end end;return A end;function a.diff(E,F,d)assert(E)assert(F)F=b(F,d)E=b(E,d)local G=\"\"local H=\"\"while E[1]and E[1]==F[1]do local B=table.remove(E,1)table.remove(F,1)G=G..B end;while E[#E]and E[#E]==F[#F]do local B=table.remove(E)table.remove(F)H=B..H end;local I={put=function(self,B,J)table.insert(self,{B,J})end,ins=function(self,B)self:put(B,IN)end,del=function(self,B)self:put(B,OUT)end,same=function(self,B)if B then self:put(B,SAME)end end}I:same(H)local function K(n,E,F,u,x)local L=E[u]local M=F[x]if u>=1 and x>=1 and L==M then I:same(L)return K(n,E,F,u-1,x-1)else local N=n[u][x-1]local O=n[u-1][x]if x>=1 and(u==0 or N>=O)then I:ins(M)return K(n,E,F,u,x-1)elseif u>=1 and(x==0 or N<O)then I:del(L)return K(n,E,F,u-1,x)end end end;K(a.quick_LCS(E,F),E,F,#E+1,#F+1)I:same(G)local a={}for u=#I,1,-1 do table.insert(a,I[u])end;a.to_html=a.format_as_html;return a end;return a\n",created=1704748610673,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1871}},owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},var={modified=1704748610119,created=1704748610119,contents={log={modified=1704748610119,created=1704748610119,contents={["default.log"]={modified=1704748613205,data="[Jan 08 16:16:50] kernel[0] [Info]: Starting Phoenix version 0.0.5 PRERELEASE NONFREE Mon Jan  8 16:13:54 2024 PREEMPT\n[Jan 08 16:16:50] kernel[0] [Info]: Initialized system logger\n[Jan 08 16:16:50] kernel[0] [Info]: System started at 1704748610137 on computer 45\n[Jan 08 16:16:50] kernel[0] [Info]: Computer host is ComputerCraft 1.109.2 (CraftOS-PC v2.8)\n[Jan 08 16:16:50] kernel[0] [Debug]: Key table sizes: 211 46\n[Jan 08 16:16:50] kernel[0] [Info]: Loading kernel modules from /lib/modules\n[Jan 08 16:16:50] kernel[0] [Info]: Loading kernel module spanfs from /lib/modules/spanfs.lua\n[Jan 08 16:16:50] kernel[0] (spanfs) [Info]: spanfs is now loaded\n[Jan 08 16:16:50] kernel[0] (Hardware) [Info]: Registered device with type computer on device / using driver root\n[Jan 08 16:16:50] kernel[0] (Hardware) [Info]: Added new device at /redstone\n[Jan 08 16:16:50] kernel[0] (Hardware) [Info]: Added new device at /redstone/top\n[Jan 08 16:16:50] kernel[0] (Hardware) [Info]: Registered device with type redstone on device /redstone/top using driver root_redstone\n[Jan 08 16:16:50] kernel[0] (Hardware) [Info]: Added new device at /redstone/bottom\n[Jan 08 16:16:50] kernel[0] (Hardware) [Info]: Registered device with type redstone on device /redstone/bottom using driver root_redstone\n[Jan 08 16:16:50] kernel[0] (Hardware) [Info]: Added new device at /redstone/left\n[Jan 08 16:16:50] kernel[0] (Hardware) [Info]: Registered device with type redstone on device /redstone/left using driver root_redstone\n[Jan 08 16:16:50] kernel[0] (Hardware) [Info]: Added new device at /redstone/right\n[Jan 08 16:16:50] kernel[0] (Hardware) [Info]: Registered device with type redstone on device /redstone/right using driver root_redstone\n[Jan 08 16:16:50] kernel[0] (Hardware) [Info]: Added new device at /redstone/front\n[Jan 08 16:16:50] kernel[0] (Hardware) [Info]: Registered device with type redstone on device /redstone/front using driver root_redstone\n[Jan 08 16:16:50] kernel[0] (Hardware) [Info]: Added new device at /redstone/back\n[Jan 08 16:16:50] kernel[0] (Hardware) [Info]: Registered device with type redstone on device /redstone/back using driver root_redstone\n[Jan 08 16:16:50] kernel[0] (Hardware) [Info]: Added new device at /lo\n[Jan 08 16:16:50] kernel[0] (Hardware) [Info]: Registered device with type modem on device /lo using driver loopback_modem\n[Jan 08 16:16:50] kernel[0] [Info]: Configured IP for loopback device\n[Jan 08 16:16:50] kernel[0] [Info]: Starting init from /mkramfs_stage2.lua\n[Jan 08 16:16:50] kernel[0] [Debug]: Reaping process 2 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:50] kernel[0] [Debug]: Creating link /etc/startmgr/system/startup.service.wants/automount.service  =>  /etc/startmgr/system/automount.service\n[Jan 08 16:16:50] kernel[0] [Debug]: Reaping process 4 (/var/lib/dpkg/info/baseutils.postinst)\n[Jan 08 16:16:50] kernel[0] [Debug]: Reaping process 3 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:50] kernel[0] [Debug]: Reaping process 5 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:50] kernel[0] [Debug]: Reaping process 6 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:50] kernel[0] [Debug]: Reaping process 7 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:50] kernel[0] [Debug]: Creating link /etc/startmgr/system/startup.service.wants/diskmgr.service  =>  /etc/startmgr/system/diskmgr.service\n[Jan 08 16:16:50] kernel[0] [Debug]: Reaping process 8 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:50] kernel[0] [Debug]: Reaping process 10 (/bin/man.lua)\n[Jan 08 16:16:50] kernel[0] [Debug]: Reaping process 9 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:50] kernel[0] [Debug]: Reaping process 12 (/bin/man.lua)\n[Jan 08 16:16:50] kernel[0] [Debug]: Reaping process 11 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:51] kernel[0] [Debug]: Reaping process 14 (/bin/man.lua)\n[Jan 08 16:16:51] kernel[0] [Debug]: Reaping process 13 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:51] kernel[0] [Debug]: Reaping process 16 (/bin/man.lua)\n[Jan 08 16:16:51] kernel[0] [Debug]: Reaping process 15 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:51] kernel[0] [Debug]: Reaping process 18 (/bin/man.lua)\n[Jan 08 16:16:51] kernel[0] [Debug]: Reaping process 17 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:51] kernel[0] [Debug]: Reaping process 19 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:51] kernel[0] [Debug]: Reaping process 20 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:51] kernel[0] [Debug]: Reaping process 21 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:51] kernel[0] [Debug]: Reaping process 22 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:51] kernel[0] [Debug]: Reaping process 23 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:51] kernel[0] [Debug]: Reaping process 24 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:52] kernel[0] [Debug]: Reaping process 26 (/bin/man.lua)\n[Jan 08 16:16:52] kernel[0] [Debug]: Reaping process 25 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:52] kernel[0] [Debug]: Reaping process 27 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:52] kernel[0] [Debug]: Reaping process 28 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:52] kernel[0] [Debug]: Reaping process 30 (/bin/man.lua)\n[Jan 08 16:16:52] kernel[0] [Debug]: Reaping process 29 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:52] kernel[0] [Debug]: Reaping process 32 (/bin/man.lua)\n[Jan 08 16:16:52] kernel[0] [Debug]: Reaping process 31 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:52] kernel[0] [Debug]: Reaping process 34 (/bin/man.lua)\n[Jan 08 16:16:52] kernel[0] [Debug]: Reaping process 33 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:52] kernel[0] [Debug]: Reaping process 35 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:53] kernel[0] [Debug]: Creating link /etc/startmgr/system/startup.service.wants/login.service  =>  /etc/startmgr/system/login.service\n[Jan 08 16:16:53] kernel[0] [Debug]: Reaping process 37 (/var/lib/dpkg/info/usermgr.postinst)\n[Jan 08 16:16:53] kernel[0] [Debug]: Reaping process 38 (/bin/man.lua)\n[Jan 08 16:16:53] kernel[0] [Debug]: Reaping process 36 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:53] kernel[0] [Debug]: Reaping process 40 (/bin/man.lua)\n[Jan 08 16:16:53] kernel[0] [Debug]: Reaping process 39 (/usr/bin/dpkg.lua)\n[Jan 08 16:16:53] kernel[0] [Debug]: linking root/etc/startmgr/system/startup.service.wants/automount.service to /etc/startmgr/system/automount.service\n[Jan 08 16:16:53] kernel[0] [Debug]: linking root/etc/startmgr/system/startup.service.wants/automount.service to /etc/startmgr/system/automount.service\n[Jan 08 16:16:53] kernel[0] [Debug]: linking root/etc/startmgr/system/startup.service.wants/diskmgr.service to /etc/startmgr/system/diskmgr.service\n[Jan 08 16:16:53] kernel[0] [Debug]: linking root/etc/startmgr/system/startup.service.wants/diskmgr.service to /etc/startmgr/system/diskmgr.service\n[Jan 08 16:16:53] kernel[0] [Debug]: linking root/etc/startmgr/system/startup.service.wants/login.service to /etc/startmgr/system/login.service\n[Jan 08 16:16:53] kernel[0] [Debug]: linking root/etc/startmgr/system/startup.service.wants/login.service to /etc/startmgr/system/login.service\n",created=1704748613205,setuser=false,worldPermissions={execute=true,write=false,read=true},owner="root",type="file",permissions={root={execute=true,write=true,read=true}},size=6782}},setuser=false,worldPermissions={execute=true,write=false,read=true},owner="root",type="directory",permissions={root={execute=true,write=true,read=true}},size=0},lib={modified=1704748610117,created=1704748610117,contents={dpkg={modified=1704748613143,created=1704748613143,contents={["status-old"]={modified=1704748613173,data="Package: libdeflate\nVersion: 1.0.2-1\nPriority: optional\nArchitecture: phoenix\nStatus: install ok installed\nSection: libraries\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: DEFLATE/zlib compression library\n Provides compression and decompression for DEFLATEformatted archives, including zlib and gzip files.\n\nPackage: dhcpmgr\nVersion: 0.1-1\nPriority: optional\nArchitecture: phoenix\nSection: net\nStatus: install ok installed\nDepends: libsystem\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: DHCP server manager for Phoenix\n Implements a Dynamic Host Configuration Protocolserver, which allocates and assigns IP addressesto computers on a network.\n\nPackage: spanfs\nVersion: 0.1-1\nStatus: install ok installed\nSection: kernel\nArchitecture: phoenix\nPriority: optional\nDepends: libsystem\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Spanning filesystem kernel module & utilities\n spanfs provides a RAID-like spanning filesystemthat allows concatenating multiple disk drivesinto a single large virtual disk. One disk storesan index file containing the filesystem structure,and the file data is spread across the rest of thedisks.\n\nPackage: initrd-utils\nVersion: 0.1-1\nStatus: install ok installed\nRequires: libsystem\nPriority: optional\nArchitecture: phoenix\nSection: admin\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: initrd management tools\n Contains a collection of utility programs to createand manage initial ramdisk (initrd) files.\n\nPackage: netmgr\nVersion: 0.1-1\nPriority: optional\nArchitecture: phoenix\nSection: net\nStatus: install ok installed\nDepends: libsystem\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Network manager service\n Background manager that automatically configuresnetworking on all available modems.\n\nPackage: libsystem\nVersion: 0.1.4-1\nPriority: required\nArchitecture: phoenix\nSection: libraries\nStatus: install ok installed\nEssential: yes\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: System libraries for Phoenix\n Provides convenient wrapper functions for usingPhoenix syscalls, as well as various usefulcomponents for programs.\n\nPackage: tar\nVersion: 1.0.1-1\nStatus: install ok installed\nSection: utils\nArchitecture: phoenix\nPriority: important\nDepends: libsystem\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: TAR archive format library and program\n Allows creating and extracting TAR archives.\n\nPackage: phoenix-docs\nVersion: 0.0.4-1\nPriority: optional\nArchitecture: all\nStatus: install ok installed\nSection: doc\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Documentation files for Phoenix\n Contains manual files for Phoenix syscalls andkernel API functions, libsystem modules, andbaseutils programs. These are separated from themain packages to save space.\n\nPackage: ftp\nVersion: 0.1-1\nSection: net\nArchitecture: phoenix\nRecommends: fuse, usermgr, startmgr\nPriority: optional\nStatus: install ok installed\nDepends: libsystem, sha2\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: RFC 959-compliant FTP client & server\n Implements the FTP protocol on top of Phoenixsockets. Includes an object-oriented library formanaging clients and servers, as well as a smallserver manager for FTP access, and a FUSEfilesystem for mounting FTP shares locally.\n\nPackage: startmgr\nVersion: 0.1.1-1\nStatus: install ok installed\nSection: admin\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nArchitecture: phoenix\nPriority: standard\nDepends: libsystem\nEssential: yes\nDescription: Phoenix service manager and init system\n Provides automatic service management facilitiesfor Phoenix systems.\n\nPackage: muxzcat\nVersion: 1.0-2\nPriority: optional\nArchitecture: phoenix\nStatus: install ok installed\nSection: libraries\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: LZMA/XZ decompression library\n Provides functions for decompressing LZMA and XZformat compressed files.\n\nPackage: fuse\nVersion: 0.1-1\nPriority: optional\nArchitecture: phoenix\nStatus: install ok installed\nSection: kernel\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Filesystem in userspace module\n fuse implements filesystems in userspace, allowingfilesystems to be implemented without using kernelmodules.\n\nPackage: luz\nVersion: 0.1-1\nPriority: optional\nArchitecture: phoenix\nSection: libraries\nStatus: install ok installed\nDepends: libdeflate\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Lua compression algorithm\n Efficient compressor for Lua scripts. Includes ashared library, a command-line utility to compressand decompress Lua files, and a kernel module toallow direct execution of Luz files.\n\nPackage: dpkg\nVersion: 0.2.3-1\nStatus: install ok installed\nSection: admin\nArchitecture: phoenix\nPriority: required\nDepends: ar, diff, libdeflate, libsystem, muxzcat, sha2, tar\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Debian Package Manager for Phoenix\n A port of the Debian Package Manager to thePhoenix operating system, written in Lua.\n\nPackage: ar\nVersion: 1.1-1\nStatus: install ok installed\nSection: utils\nArchitecture: phoenix\nPriority: standard\nDepends: libsystem\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: ar archive format library and program\n Allows creating and extracting ar/.a archives.\n\nPackage: libcraftos\nVersion: 0.2.2-1\nPriority: optional\nArchitecture: phoenix\nStatus: install ok installed\nSection: libraries\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: CraftOS compatibility library\n Provides CraftOS shim functions to allow runningCraftOS programs on Phoenix.\n\nPackage: pxboot\nVersion: 0.1.3-1\nPriority: required\nArchitecture: phoenix\nSection: admin\nStatus: install ok installed\nEssential: yes\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Multipurpose bootloader for ComputerCraft\n A bootloader for ComputerCraft operating systemswith built-in UnBIOS functionality, a configurableselection menu, and more. Designed for Phoenix,but supports other OSes as well, including CraftOS.\n\nPackage: usermgr\nVersion: 0.1.2-1\nRequires: libsystem\nEssential: yes\nArchitecture: phoenix\nPriority: standard\nSection: admin\nStatus: install ok installed\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: user account manager\n Manager service to handle user accounts, includinglogin, passwords, creation, and deletion.\n\nPackage: netutils\nVersion: 0.1-1\nStatus: install ok installed\nSection: net\nArchitecture: phoenix\nPriority: optional\nDepends: libsystem\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Network configuration utilities\n Provides a set of programs to configure the systemnetworking layer.\n\nPackage: diskmgr\nVersion: 1.0-1\nStatus: install ok installed\nRequires: libsystem\nPriority: standard\nArchitecture: phoenix\nSection: utils\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: disk auto mounting manager\n Manager service to handle automatically mountingattached disks.\n\nPackage: sha2\nVersion: 12-2\nStatus: install ok installed\nRequires: libsystem\nPriority: optional\nArchitecture: phoenix\nSection: libraries\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: SHA-1, SHA-2, SHA-3, BLAKE2 and BLAKE3 functions written in pure Lua and optimized for speed.\n This module contains functions to calculate SHA digest:   MD5, SHA-1,   SHA-224, SHA-256, SHA-512/224, SHA-512/256, SHA-384, SHA-512,   SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, SHAKE256,   HMAC,   BLAKE2b, BLAKE2s, BLAKE2bp, BLAKE2sp, BLAKE2Xb, BLAKE2Xs,   BLAKE3, BLAKE3_KDFWritten in pure Lua.Compatible with:   Lua 5.1, Lua 5.2, Lua 5.3, Lua 5.4, Fengari, LuaJIT 2.0/2.1 (any CPU endianness).Main feature of this module: it was heavily optimized for speed.For every Lua version the module contains particular implementation branch to get benefits from version-specific features.   - branch for Lua 5.1 (emulating bitwise operators using look-up table)   - branch for Lua 5.2 (using bit32/bit library), suitable for both Lua 5.2 with native \"bit32\" and Lua 5.1 with external library \"bit\"   - branch for Lua 5.3/5.4 (using native 64-bit bitwise operators)   - branch for Lua 5.3/5.4 (using native 32-bit bitwise operators) for Lua built with LUA_INT_TYPE=LUA_INT_INT   - branch for LuaJIT without FFI library (useful in a sandboxed environment)   - branch for LuaJIT x86 without FFI library (LuaJIT x86 has oddity because of lack of CPU registers)   - branch for LuaJIT 2.0 with FFI library (bit.* functions work only with Lua numbers)   - branch for LuaJIT 2.1 with FFI library (bit.* functions can work with \"int64_t\" arguments)\n\nPackage: baseutils\nVersion: 0.2-1\nPriority: important\nArchitecture: phoenix\nSection: utils\nStatus: install ok installed\nDepends: libsystem\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: base utility set for Phoenix\n Contains a standard set of POSIX utilities for Phoenix.\n\nPackage: ccryptolib\nVersion: 1.0.1-1\nStatus: install ok installed\nSection: libraries\nArchitecture: phoenix\nPriority: optional\nDepends: libsystem\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: cryptography library for Phoenix\n An integrated collection of cryptographic primitives written in Lua usingthe ComputerCraft/Phoenix system API.\n\nPackage: diff\nVersion: 1.0-1\nStatus: install ok installed\nSection: utils\nArchitecture: phoenix\nPriority: important\nDepends: libsystem\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: File comparison library and utility\n Provides a library for comparing files, as well asprograms for comparing and patching using the lib.\n\nPackage: typescript\nVersion: 1.16.1-1\nHomepage: https://typescript-to-lua.github.io\nPriority: optional\nArchitecture: phoenix\nSection: libraries\nStatus: install ok installed\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: TypeScriptToLua library features bundle\n Provides important polyfills to allow TypeScript code to run on Lua platforms.To use, set \"luaLibImport\" to \"require\" in tsconfig.json, and either set\"luaLibName\" to \"typescript\" (requires @jackmacwindows/typescript-to-lua), orreplace `require(\"lualib-bundle\")` with `require(\"typescript\")` in generatedfiles.\n\n",created=1704748613173,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=10403},info={modified=1704748613141,created=1704748613141,contents={["pxboot.conffiles"]={modified=1704748612342,data="/boot/config.lua\n",created=1704748612342,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=17},["typescript.list"]={modified=1704748612889,data="/\n/lib/\n/lib/typescript.lua\n",created=1704748612889,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=28},["luz.conffiles"]={modified=1704748611569,data="",created=1704748611569,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=0},["diff.list"]={modified=1704748610672,data="/\n/bin/\n/lib/\n/lib/diff.lua\n",created=1704748610672,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=28},["diskmgr.conffiles"]={modified=1704748610717,data="",created=1704748610717,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=0},["usermgr.list"]={modified=1704748613021,data="/\n/etc/\n/etc/motd\n/etc/passwd\n/etc/shadow\n/etc/skel/\n/etc/skel/.cashrc\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/login.service\n/etc/startmgr/system/startup.service.wants/\n/etc/startmgr/system/usermgr.service\n/usr/\n/usr/bin/\n/usr/bin/login.lua\n/usr/bin/passwd.lua\n/usr/bin/su.lua\n/usr/bin/sudo.lua\n/usr/bin/useradd.lua\n/usr/bin/userdel.lua\n/usr/bin/usermod.lua\n/usr/lib/\n/usr/lib/usermgr.lua\n/usr/libexec/\n/usr/libexec/usermgr.lua\n/usr/share/\n/usr/share/man/\n/usr/share/man/man1/\n/usr/share/man/man1/login.md\n/usr/share/man/man1/passwd.md\n/usr/share/man/man1/su.md\n/usr/share/man/man1/sudo.md\n/usr/share/man/man3/\n/usr/share/man/man3/usermgr.md\n/usr/share/man/man5/\n/usr/share/man/man5/motd.md\n/usr/share/man/man5/passwd.md\n/usr/share/man/man5/shadow.md\n/usr/share/man/man8/\n/usr/share/man/man8/useradd.md\n/usr/share/man/man8/userdel.md\n/usr/share/man/man8/usermgr.md\n/usr/share/man/man8/usermod.md\n/etc/startmgr/system/startup.service.wants/login.service\n",created=1704748613021,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=971},["libdeflate.md5sums"]={modified=1704748611333,data="064cbb9bd225cc296c44ef60974315fe  usr/share/typescript/libdeflate/tsconfig.json\n276efa4f0c1f434ab142bd1d53588091  usr/share/typescript/libdeflate/index.d.ts\nac0f47ccf0ad97f990b37ee1b4f1e710  usr/share/typescript/libdeflate/package.json\n61a11f1b095de6ecf98a981e4e84be8c  usr/bin/gzip.lua\n9ab27810840ddae0b90ef4d0bc39d960  usr/lib/LibDeflate.lua\n",created=1704748611333,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=344},["pxboot.md5sums"]={modified=1704748612342,data="68b329da9893e34099c7d8ad5cb9c940  boot/config.lua\n59333490fc59f5e7b3f71cbe20a24ca5  boot/pxboot.lua\nbdb340a10570edcffedc694989ec8ffc  boot/config.lua.d/99-craftos.lua\n",created=1704748612342,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=167},["usermgr.md5sums"]={modified=1704748613022,data="30ad13f1feab0ef81ec18681b7169906  usr/bin/useradd.lua\n1953929dcde52061f67ee4bc1b58a580  usr/bin/userdel.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/usermod.md\n82623dc508d076c29b0bb73deb041330  usr/lib/usermgr.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/useradd.md\n4adde33f29a34744772eeb0c470d34cf  usr/bin/usermod.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/sudo.md\n6889f3f36a1656f227e07725ff744a4f  usr/bin/passwd.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/login.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/usermgr.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man5/passwd.md\nd41d8cd98f00b204e9800998ecf8427e  etc/shadow\na5753c9417f97ba3db5643e832d4081e  etc/motd\nd41d8cd98f00b204e9800998ecf8427e  etc/passwd\n347b4ebeab0ca5ff710065ae20ebe0cc  usr/bin/sudo.lua\naf3c31f5dad89603d41beb445629bdb9  etc/skel/.cashrc\n411b0f50d7cf8abf5dfefce9268fbe62  etc/startmgr/system/login.service\n20e62d30ab6ebfe3b09bb0356c20e458  etc/startmgr/system/usermgr.service\naf38a0fd306e366e0b804ff0b46674a1  usr/libexec/usermgr.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man5/motd.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/passwd.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/userdel.md\nb9639d9007a11093ec18491955fa1e73  usr/bin/login.lua\n8e3f4a32f644fb9e3bf1cf03bf409ed1  usr/bin/su.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man3/usermgr.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/su.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man5/shadow.md\n",created=1704748613022,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1553},["diskmgr.md5sums"]={modified=1704748610717,data="bef0900b5d48f903c15177c062b52e35  usr/libexec/diskmgr.lua\n52dfeac33b5887d026695dff5dc9dbac  etc/startmgr/system/diskmgr.service\n",created=1704748610717,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=128},["baseutils.list"]={modified=1704748610396,data="/\n/bin/\n/bin/apropos.lua\n/bin/attach.lua\n/bin/basename.lua\n/bin/cal.lua\n/bin/cash.lua\n/bin/cat.lua\n/bin/cd.lua\n/bin/chmod.lua\n/bin/chown.lua\n/bin/chroot.lua\n/bin/cksum.lua\n/bin/clear.lua\n/bin/cmp.lua\n/bin/comm.lua\n/bin/compress.lua\n/bin/cp.lua\n/bin/curl.lua\n/bin/date.lua\n/bin/df.lua\n/bin/dirname.lua\n/bin/dj.lua\n/bin/du.lua\n/bin/echo.lua\n/bin/eject.lua\n/bin/env.lua\n/bin/expand.lua\n/bin/expr.lua\n/bin/false.lua\n/bin/halt.lua\n/bin/id.lua\n/bin/kill.lua\n/bin/label.lua\n/bin/less.lua\n/bin/link.lua\n/bin/logger.lua\n/bin/ls.lua\n/bin/lsdev.lua\n/bin/lua.lua\n/bin/man.lua\n/bin/mkdir.lua\n/bin/mkfifo.lua\n/bin/mount.lua\n/bin/mv.lua\n/bin/nano.lua\n/bin/nice.lua\n/bin/nm.lua\n/bin/printf.lua\n/bin/ps.lua\n/bin/pwd.lua\n/bin/reboot.lua\n/bin/redstone.lua\n/bin/renice.lua\n/bin/rm.lua\n/bin/rmdir.lua\n/bin/screenfetch.lua\n/bin/sh.lua\n/bin/sleep.lua\n/bin/touch.lua\n/bin/true.lua\n/bin/tty.lua\n/bin/uname.lua\n/bin/uncompress.lua\n/bin/unlink.lua\n/bin/unmount.lua\n/bin/whoami.lua\n/etc/\n/etc/fstab\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/automount.service\n/etc/startmgr/system/startup.service.wants/\n/etc/startmgr/system/startup.service.wants/automount.service\n",created=1704748610396,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1152},["ar.md5sums"]={modified=1704748610205,data="2257836c7b93df60339c346161a45bc0  lib/ar.lua\n313f5e82958c0d8f26b6167440648acd  bin/ar.lua\n",created=1704748610205,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=90},["libdeflate.conffiles"]={modified=1704748611333,data="",created=1704748611333,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=0},["tar.conffiles"]={modified=1704748612788,data="",created=1704748612788,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=0},["libcraftos.list"]={modified=1704748611248,data="/\n/bin/\n/bin/craftos.lua\n/bin/shell.lua\n/lib/\n/lib/libcc.a\n/lib/libcraftos.a\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man1/\n/usr/share/man/man1/craftos.md\n/usr/share/man/man1/shell.md\n",created=1704748611248,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=192},["usermgr.postinst"]={modified=1704748613022,data="if ... == \"configure\" then\n    coroutine.yield(\"syscall\", \"chmod\", \"/usr/bin/login.lua\", nil, {setuser = true})\n    coroutine.yield(\"syscall\", \"chmod\", \"/usr/bin/passwd.lua\", nil, {setuser = true})\n    coroutine.yield(\"syscall\", \"chmod\", \"/usr/bin/su.lua\", nil, {setuser = true})\n    coroutine.yield(\"syscall\", \"chmod\", \"/usr/bin/sudo.lua\", nil, {setuser = true})\n    return true\nelse return true end",created=1704748613022,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=400},["libsystem.list"]={modified=1704748611482,data="/\n/lib/\n/lib/libsystem.a\n/usr/\n/usr/share/\n/usr/share/typescript/\n/usr/share/typescript/libsystem/\n/usr/share/typescript/libsystem/events.d.ts\n/usr/share/typescript/libsystem/expect.d.ts\n/usr/share/typescript/libsystem/filesystem.d.ts\n/usr/share/typescript/libsystem/framebuffer.d.ts\n/usr/share/typescript/libsystem/graphics.d.ts\n/usr/share/typescript/libsystem/hardware.d.ts\n/usr/share/typescript/libsystem/index.d.ts\n/usr/share/typescript/libsystem/ipc.d.ts\n/usr/share/typescript/libsystem/keys.d.ts\n/usr/share/typescript/libsystem/log.d.ts\n/usr/share/typescript/libsystem/network.d.ts\n/usr/share/typescript/libsystem/package.json\n/usr/share/typescript/libsystem/pretty.d.ts\n/usr/share/typescript/libsystem/process.d.ts\n/usr/share/typescript/libsystem/serialization.d.ts\n/usr/share/typescript/libsystem/sync.d.ts\n/usr/share/typescript/libsystem/terminal.d.ts\n/usr/share/typescript/libsystem/tsconfig.json\n/usr/share/typescript/libsystem/util.d.ts\n",created=1704748611482,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=949},["phoenix-docs.conffiles"]={modified=1704748612198,data="",created=1704748612198,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=0},["baseutils.md5sums"]={modified=1704748610396,data="3f3c71d1bccbde885221c4b14d9ea111  bin/cal.lua\ne37948d8fe2173d8aed103b254c62d1f  bin/tty.lua\n9cef8a2758c30e387122857d87f120a3  bin/nice.lua\n822d221ba295280690311191dc59116c  bin/mv.lua\nc1821d21f33e68c32514f1a1b47e332b  bin/rmdir.lua\nd7b659299185af45cce85813753429bd  bin/renice.lua\n1c3eb4de206e2d9e1c901daa830b358e  bin/redstone.lua\ndd5fbf031731db755455e1f38629c4d1  bin/chown.lua\n987d142e32bf4435302ea980d722f662  bin/chroot.lua\na200214f00028170ec84b4bac4ab2d65  bin/mkdir.lua\n0f10a6f7c075b3a617909ead335f4d98  bin/uname.lua\nf440e472d544d26738a6525dfa90b75d  bin/env.lua\nad5fba84720b513d6f26372dd5b5ab28  bin/comm.lua\n94acf0509749ce1c89dfc0fdef87999e  bin/id.lua\n51f8cdc2583e09f579c03b6ef5062e73  bin/attach.lua\n2ac45dc44e5c5fbe6d5074c8a7920d6f  bin/mount.lua\na0acb3bbd7647ffc42881b5b1f652101  bin/false.lua\nb6f9425e648bbe725388f999543121fe  bin/link.lua\nc2a7b0aebf221a4b99d35e5960f2fb95  bin/cksum.lua\nbac687f4efd22b8d455f1c76a78a3e9a  bin/chmod.lua\n6cf0176b6703a4c406cea8c00bab5f99  bin/sleep.lua\ne1fd3abb99d7ba394544afdd8bc3219f  bin/apropos.lua\n7e38b7acf96e039b14919857ca2dfff0  bin/echo.lua\n157c726b4783bd2673d2cba23237a907  bin/man.lua\n19a7ed0f8311b94f930979801ee228e3  bin/kill.lua\nd58ed7910c0ba7ba878abc6b05f6048e  bin/screenfetch.lua\naec4174943d2ec4e79d75872f627417c  bin/logger.lua\n2102f2892490510c6e9e544cdf3b7d0a  bin/lua.lua\n5e2f6f33e2ae0953eff784bc9d151adb  bin/true.lua\n4cf589c746eec22552853c5e16159c41  bin/cp.lua\n714914be6658567665f655a1022cc8ce  bin/dj.lua\nef798e1b9b0a0fc28f350411eb197935  bin/reboot.lua\n386461ecb77eda2da55fc1f7f1930dec  bin/printf.lua\naf6fa5fb651bfc8b592147b8d24edb63  bin/compress.lua\n35a3925e059a2329500a5653892ebde5  bin/sh.lua\n28cd84b2857ade19e4b5999e32e5a977  bin/ps.lua\na47b79d65900867e04baeb6e74b981aa  bin/basename.lua\n0162e4fb0aa8420b1f0e1535d0db3b91  bin/rm.lua\n5f3e5fc2df2c1b1dc90da5a2f2eee0e4  etc/fstab\n69c9945d22bca607f5fc6fd9e9c0d8d6  etc/startmgr/system/automount.service\nd0b417ad3ed2f618495a08ac7ccdfbc7  bin/unlink.lua\n35f1f8cc65e3946559a835134046bf21  bin/dirname.lua\ned2b6fdd6beca77514505804a2a73769  bin/lsdev.lua\nb01fc398510a4f29b9f20688da4c8416  bin/date.lua\nf979bb61d1ec11feadbf75599f242e8a  bin/eject.lua\n37b20313032486367bc1355219ad3df0  bin/label.lua\ne73afa8bb012520a303ca3848e7f1a76  bin/unmount.lua\n92ce61ebeec4cf62b1d20c5818f4a06a  bin/whoami.lua\n47df5ee3376c8d52c08065546dd944df  bin/cd.lua\n469245890049f26bfb8b637caa23f4f7  bin/mkfifo.lua\n542c77812b077d1c5cb37f86a8fc95cb  bin/curl.lua\na405b344188c49650c4271f25a7ab484  bin/pwd.lua\nef8b2b3d019a3599cbed101638862f4a  bin/uncompress.lua\nc5d8cb7436d8ad18d06d999ac0465340  bin/nano.lua\n41390f5b9ef52688391812ce84611224  bin/nm.lua\nda5ce367b0a4c3af6d41af201ef276d4  bin/du.lua\n22dc5bb80fb08df6b1eb3f56a23f4a7a  bin/expr.lua\n517599d164412eaf63b10648690a16aa  bin/cat.lua\nb69c77d83e435be6662c9c57675beb4b  bin/cash.lua\n71c3a28801bfa5038fbae9aa13bbf34f  bin/halt.lua\nda90b4a2e20894b5073ddff29644823f  bin/df.lua\n7bc6b5e904c9e9a3b895d107a7fd7494  bin/touch.lua\ndb653efad0b708300165886068c5120f  bin/less.lua\ne03ef0f14153ee028a78157730d8720d  bin/cmp.lua\n6f1593ad1511d26efa3b5c696a7df2b2  bin/clear.lua\n987e5f6bb8457528c7ddb9027544b038  bin/expand.lua\nacf6d2b7ac1266c67d843a2dc73d95a6  bin/ls.lua\n",created=1704748610396,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=3207},["fuse.list"]={modified=1704748611051,data="/\n/lib/\n/lib/modules/\n/lib/modules/fuse.lua\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man7/\n/usr/share/man/man7/fuse.md\n",created=1704748611051,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=127},["netutils.conffiles"]={modified=1704748611764,data="",created=1704748611764,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=0},["spanfs.conffiles"]={modified=1704748612572,data="",created=1704748612572,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=0},["libdeflate.list"]={modified=1704748611333,data="/\n/usr/\n/usr/bin/\n/usr/bin/gzip.lua\n/usr/lib/\n/usr/lib/LibDeflate.lua\n/usr/share/\n/usr/share/typescript/\n/usr/share/typescript/libdeflate/\n/usr/share/typescript/libdeflate/index.d.ts\n/usr/share/typescript/libdeflate/package.json\n/usr/share/typescript/libdeflate/tsconfig.json\n",created=1704748611333,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=276},["netmgr.conffiles"]={modified=1704748611704,data="/etc/network.conf\n",created=1704748611704,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=18},["sha2.list"]={modified=1704748612469,data="/\n/usr/\n/usr/bin/\n/usr/bin/b2sum.lua\n/usr/bin/md5sum.lua\n/usr/bin/sha1sum.lua\n/usr/bin/sha224sum.lua\n/usr/bin/sha256sum.lua\n/usr/bin/sha384sum.lua\n/usr/bin/sha512sum.lua\n/usr/bin/shasum.lua\n/usr/lib/\n/usr/lib/sha2.lua\n/usr/share/\n/usr/share/typescript/\n/usr/share/typescript/sha2/\n/usr/share/typescript/sha2/index.d.ts\n/usr/share/typescript/sha2/package.json\n/usr/share/typescript/sha2/tsconfig.json\n",created=1704748612469,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=400},["dpkg.md5sums"]={modified=1704748610866,data="8ed0455495f6d0c4456249006281b069  usr/bin/dpkg-deb.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/components.md\n101c6d15615ceae8cda8691971362081  usr/lib/dpkg/control.lua\n76fe1d9953d075f6811758c949da30d2  usr/lib/dpkg/deb.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/dpkg.md\nba58b004afcc6edbe9f409f5b0877d33  usr/bin/dpkg-divert.lua\naab6bf7c06734a559f26f40128f89df0  usr/bin/components.lua\n94f3f1673bbfa8596df3c7bd66bdb444  usr/bin/dpkg.lua\nd5e27e7174a1fea197a7f2d6a4fe2335  usr/bin/dpkg-query.lua\nc5a104541816bf417df68eabccb0c1ce  usr/lib/dpkg/query.lua\n0b9e4c3020d8d775a34920b3098eb458  usr/lib/dpkg/divert.lua\n10b243ea7abc193307ab9e9d3888b184  usr/lib/dpkg/init.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/update.md\n574441cf032742c0a1b4a662b44d5f29  usr/lib/dpkg/trigger.lua\n637f90e0ca1924d17008cf6073e19887  usr/bin/dpkg-trigger.lua\nddb74df4a7ad2b15c614ab754ee5f4a9  usr/bin/update.lua\n",created=1704748610866,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=925},["netmgr.list"]={modified=1704748611704,data="/\n/etc/\n/etc/network.conf\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/netmgr.service\n/usr/\n/usr/libexec/\n/usr/libexec/netmgr.lua\n",created=1704748611704,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=143},["dhcpmgr.md5sums"]={modified=1704748610629,data="b5e4fca80d752e66aaaf5d6be6510dc6  etc/dhcpmgr.conf\nc9b77515c9fde19048354bf38a093ab8  etc/startmgr/system/dhcpmgr.service\n1ccd02aa7f7997926a9bb564d00fdc34  usr/libexec/dhcpmgr.lua\n",created=1704748610629,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=179},["diff.md5sums"]={modified=1704748610672,data="c861d0c4f89d14b794beb174269bcede  lib/diff.lua\n",created=1704748610672,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=47},["tar.list"]={modified=1704748612787,data="/\n/bin/\n/bin/tar.lua\n/lib/\n/lib/tar.lua\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man1/\n/usr/share/man/man1/tar.md\n",created=1704748612787,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=122},["ccryptolib.md5sums"]={modified=1704748610572,data="8976c6383e5ad7b587dd60b8e16fe20d  usr/share/typescript/ccryptolib/ed25519.d.ts\n6e3b0c97cf46b0b72d838037cbf4ace9  usr/share/typescript/ccryptolib/blake3.d.ts\nab8c5886cc8ed23d0a0c405c639b25c7  usr/share/typescript/ccryptolib/sha256.d.ts\n294c2836f74ffb9ae936666ac6ab176e  usr/share/typescript/ccryptolib/index.d.ts\ne98988a8826acfd18f392243edba00e5  usr/share/typescript/ccryptolib/aead.d.ts\n69b877277a60dc5f128cb50d7671c915  usr/share/typescript/ccryptolib/random.d.ts\n7aa797e9f81d4e41101eaaa5cf1deec1  usr/share/typescript/ccryptolib/poly1305.d.ts\n1396625a1ae5bf8b50c7053e802a8494  usr/share/typescript/ccryptolib/chacha20.d.ts\n85eda638ad0aa0ba77a6aacd57ae1fc7  usr/share/typescript/ccryptolib/x25519.d.ts\n3cf2efa9d171a48b1b8d0f4d874545a0  usr/share/typescript/ccryptolib/util.d.ts\n1eca92cc1d3276cb7db9727d4958a822  usr/share/typescript/ccryptolib/package.json\n064cbb9bd225cc296c44ef60974315fe  usr/share/typescript/ccryptolib/tsconfig.json\na9d54cf3ed810190b1a9d7c041d24210  usr/lib/libccryptolib.a\n",created=1704748610572,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=997},["diskmgr.list"]={modified=1704748610717,data="/\n/etc/\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/diskmgr.service\n/etc/startmgr/system/startup.service.wants/\n/usr/\n/usr/libexec/\n/usr/libexec/diskmgr.lua\n/etc/startmgr/system/startup.service.wants/diskmgr.service\n",created=1704748610717,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=230},["phoenix-docs.md5sums"]={modified=1704748612199,data="06124b31ba7e667b1618f4f0f993456a  usr/share/man/man2/devunlock.md\ndd26ad844296daa48ce9824f78112145  usr/share/man/man2/unlockmutex.md\n2e226e3b72e730965dd894189fa98b45  usr/share/man/man2/devcall.md\n05279006f5323ad189eaa20c795a8fe4  usr/share/man/man2/connect.md\n468f1c781f256e30f3f7fdeeac94b6bf  usr/share/man/man2/mountlist.md\n6fc3507c68de16d6909370c3e2b0eeb6  usr/share/man/man2/signal.md\na594570023aefc380e2ffeb3cce0c052  usr/share/man/man2/combine.md\n7ac41cc3c74aa8163d90e4614d492e75  usr/share/man/man3/system.util.md\nd0996ceaa773d903957e6e9619641906  usr/share/man/man2/devproperties.md\n28291760a2e4b96be1171acc644c5d6e  usr/share/man/man3/system.hardware.md\n696a2040bc36af8af6ad66fe78433ae7  usr/share/man/man3/system.process.md\n97d3a6b6fa05ad9d5abad1d52032952d  usr/share/man/man2/alarm.md\nb48e433d717c524cc10da33c4c23472b  usr/share/man/man2/remove.md\n05b2b6ce596d1911ecc622e0d91c03d4  usr/share/man/man2/cchost.md\n132985fdf367e06d1c55fdb223876ce0  usr/share/man/man2/sendEvent.md\n791883f15b0b6d761feeee712293d767  usr/share/man/man3/system.sync.md\nbafeb327ddff1f91ee06ec03d87f06b3  usr/share/man/man3/system.ipc.md\n3f9fd39c8c546bd480bc96cde4ce451f  usr/share/man/man2/devfind.md\ne741c0b7f30cf6ac9b7ee24923645449  usr/share/man/man2/devlisten.md\ne15a8b674e3b2317a49f49c68dffbf37  usr/share/man/man2/unlisten.md\nda74496fbe0ae2de16e985af5eaf7367  usr/share/man/man2/listmodules.md\n338b606dbe6b417f1e6eee5d61042d13  usr/share/man/man2/rename.md\n4346c291bae58e8d989ebe3101ee7338  usr/share/man/man2/timer.md\n37c295514dbf251035461e407ec667b3  usr/share/man/man3/system.expect.md\ne9fcc0a2c89dd521a771880001556e07  usr/share/man/man2/chroot.md\n5cab43ff97f5780078c29e9f75cad7b5  usr/share/man/man2/_template.md\nd181c9ee13a5868c6b636b035eef1f27  usr/share/man/man2/open.md\n2efd87231f058c6ff1d2954ac15f3a26  usr/share/man/man2/mkdir.md\n3af4e3ce46827777ebc9a72faadc8656  usr/share/man/man2/timeacquiresemaphore.md\nea033221bc9037a8519781148c3e36b9  usr/share/man/man2/arplist.md\ncb5483b392e5196c755d8f4fb3bb6d5d  usr/share/man/man2/loadCraftOSAPI.md\ne6e6e85c1c165f256ac8529611f99129  usr/share/man/man2/netcontrol.md\nf4ab4a41e3fa302d47096ea8534aed80  usr/share/man/man2/mount.md\ndafda555c67469ef269165d080d4f537  usr/share/man/man2/kill.md\n927b9673495ee1ab6372804aaffb0602  usr/share/man/man2/link.md\n998c1f99fc18bb138afb96f8a290829b  usr/share/man/man2/stat.md\n2cc2c7a42459d2e32c6bc49a9d2d4021  usr/share/man/man2/chown.md\na9af46d4ab2b6d36714d9177510e26ca  usr/share/man/man3/system.terminal.md\nca0bfb454428824d3b9adbb2ad49175f  usr/share/man/man2/unloadmodule.md\n0df54115cb3ece67b17c2d74a9c7c42a  usr/share/man/man2/ipconfig.md\n9de4abbd2b0da2b14c5da9dbf81bc23c  usr/share/man/man2/arpset.md\n567d15c62ba1bef2a7d1455df96abb3d  usr/share/man/man2/devinfo.md\n911e57faab1316f11d584a94eca7eefd  usr/share/man/man9/kernel.md\nee2402f90c4ad6d76fbb8d79514463ec  usr/share/man/man2/timelockmutex.md\n5f19cc0f6ab4148ba9335d6e814d8356  usr/share/man/man2/callmodule.md\n49d3e4050d1082830f48ad6967eae91f  usr/share/man/man3/system.pretty.md\n153307238fe3c50cd989e29fcf673cc8  usr/share/man/man2/checkuri.md\n9d644b65cd00553301c202322b78ecf3  usr/share/man/man2/version.md\n2501ef2ed4f1fbdf54649e4920f1b584  usr/share/man/man3/system.log.md\n278ed6f961df2429b512436974dbbde6  usr/share/man/man2/lockmutex.md\n1e3f6c4fe095b7dfcc595a0493101f29  usr/share/man/man2/kernargs.md\nfa70b112de755bca55aeed95aefceae6  usr/share/man/man3/system.filesystem.md\nab2514f962bed9c4833e34cda902fed7  usr/share/man/man3/system.framebuffer.md\n0389a13f78cfe99d7bc6e7d1972b27f8  usr/share/man/man2/devalias.md\nfe185470ef69904cd06ff581fea471fb  usr/share/man/man2/cancel.md\n1bef5a63b0fe7719b02a57aa85b65f41  usr/share/man/man2/loadmodule.md\nf9b544105798e40052a32bc6e997de7c  usr/share/man/man2/uptime.md\nf3afcb4b2f99ed91a29178f38323f345  usr/share/man/man2/devlookup.md\n969be2cabd57377208f2fcc306f4e390  usr/share/man/man3/system.graphics.md\nd69b17d40fc99325335341dc5c80fd36  usr/share/man/man2/detach.md\n8e7e90089d0ba1d260e65c8fef1d6882  usr/share/man/man2/devmethods.md\nfaa2cb304a8d49cf6d1ef8a3e03f8e4d  usr/share/man/man3/system.network.md\n78d09c5fb0699148ad0f03f55e1aa0dd  usr/share/man/man2/netevent.md\n0d28ca0a43641a8e25ea4f57ba9c53a3  usr/share/man/man2/routedel.md\n3392e744c6cf94bf74a63cd1ee0f8472  usr/share/man/man2/routeadd.md\nc3d0d69b999f47463b8e679e2d04651d  usr/share/man/man1/logger.md\n2e0a0cdc9d2ade4fbe183999475535ac  usr/share/man/man2/routelist.md\n9acb7f91203c9ea3969f7830ad4bd6a5  usr/share/man/man3/system.serialization.md\na04eafd5194d4bf030b1f98a92b71e64  usr/share/man/man2/queueEvent.md\n005fc8770f15afd6e1c2422202eeb837  usr/share/man/man2/devchildren.md\n300a370b5355fc236a4e3bcd5ce6e771  usr/share/man/man2/listen.md\nd0e27457aa68149eb780fe1b63977a9a  usr/share/man/man2/chmod.md\ne63ea2179e036d83f3d5f37aec41a229  usr/share/man/man2/attach.md\n1580cca776cbe49c5a7e738522f88bd1  usr/share/man/man2/unmount.md\n90939a50982f279ff8bc78b7feb98d84  usr/share/man/man2/list.md\n5e4ac8f69342bd5e07b28d77bc4aebca  usr/share/man/man2/releasesemaphore.md\n3aecf75563c43ac627904e5557db6d93  usr/share/man/man2/acquiresemaphore.md\nd18a93b14fed71208f5f8aa3acd3626c  usr/share/man/man2/mkfifo.md\n9d542afcd7482e1c80531b8b987c2d8a  usr/share/man/man3/system.keys.md\nf92254ae8278c8f48402cd0a6e3ab2c3  usr/share/man/man2/devlock.md\n005eb4b4db66b177c3a09068c7d5e5c8  usr/share/man/man2/trylockmutex.md\n",created=1704748612199,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=5356},["dhcpmgr.list"]={modified=1704748610629,data="/\n/etc/\n/etc/dhcpmgr.conf\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/dhcpmgr.service\n/usr/\n/usr/libexec/\n/usr/libexec/dhcpmgr.lua\n",created=1704748610629,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=145},["pxboot.list"]={modified=1704748612341,data="/\n/boot/\n/boot/config.lua\n/boot/config.lua.d/\n/boot/config.lua.d/99-craftos.lua\n/boot/pxboot.lua\n",created=1704748612341,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=97},["fuse.conffiles"]={modified=1704748611051,data="",created=1704748611051,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=0},["baseutils.triggers"]={modified=1704748610398,data="interest /usr/share/man",created=1704748610398,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=23},["muxzcat.conffiles"]={modified=1704748611645,data="",created=1704748611645,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=0},["dhcpmgr.conffiles"]={modified=1704748610629,data="/etc/dhcpmgr.conf\n",created=1704748610629,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=18},["yahtcc.list"]={modified=1704748613141,data="/\n/usr/\n/usr/bin/\n/usr/bin/yahtcc.lua\n/usr/share/\n/usr/share/man/\n/usr/share/man/man6/\n/usr/share/man/man6/yahtcc.md\n",created=1704748613141,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=117},["netutils.list"]={modified=1704748611763,data="/\n/usr/\n/usr/bin/\n/usr/bin/arp.lua\n/usr/bin/dhclient.lua\n/usr/bin/ifconfig.lua\n/usr/bin/nc.lua\n/usr/bin/ping.lua\n/usr/bin/route.lua\n",created=1704748611763,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=132},["muxzcat.md5sums"]={modified=1704748611645,data="92cbddaa393ab1a082be221043df4f03  usr/share/typescript/muxzcat/package.json\n120f81a062860522a5270e7e27358d90  usr/share/typescript/muxzcat/index.d.ts\ndded8eb9f482a41f6db65e6a30f501b8  usr/bin/unxz.lua\n3856053135fee8c5ecc4821c31861023  usr/lib/muxzcat.lua\n064cbb9bd225cc296c44ef60974315fe  usr/share/typescript/muxzcat/tsconfig.json\n",created=1704748611645,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=332},["ftp.conffiles"]={modified=1704748610979,data="/etc/ftpmgr.conf\n",created=1704748610979,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=17},["yahtcc.md5sums"]={modified=1704748613141,data="32f4ff232b0ae7535cc9bdbd16d6649e  usr/share/man/man6/yahtcc.md\nd8e5bc545009c73a7a15ed2cfd9da260  usr/bin/yahtcc.lua\n",created=1704748613141,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=116},["yahtcc.conffiles"]={modified=1704748613141,data="",created=1704748613141,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=0},["usermgr.conffiles"]={modified=1704748613022,data="/etc/passwd\n/etc/shadow\n/etc/motd\n/etc/skel/.cashrc\n",created=1704748613022,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=52},["typescript.md5sums"]={modified=1704748612890,data="099b76c30cfe01c3f410c9e635889f87  lib/typescript.lua\n",created=1704748612890,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=53},["tar.md5sums"]={modified=1704748612788,data="8d5cffca8266e5a47fe9522c4388a306  lib/tar.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/tar.md\n30746ebcd4553deb0b26ceee80967a53  bin/tar.lua\n",created=1704748612788,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=152},["typescript.conffiles"]={modified=1704748612889,data="",created=1704748612889,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=0},["startmgr.md5sums"]={modified=1704748612685,data="2f681b48d8fd9ea8060c31a931c7f6c1  sbin/init.lua\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/startctl.md\n02794145e8ba948a089985bb283f3dcc  sbin/startctl.lua\n1f6093323d818261b3fc4d0db3966e66  etc/startmgr/system/startup.service\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/startmgr.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man1/shutdown.md\n99a9872f41e5aae13ed404f4b1fb6a0b  sbin/shutdown.lua\nd2439cbe3dccf4c8e86575b5ef2d19b3  lib/startmgr.lua\n",created=1704748612685,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=468},["phoenix-docs.list"]={modified=1704748612198,data="/\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man1/\n/usr/share/man/man1/logger.md\n/usr/share/man/man2/\n/usr/share/man/man2/_template.md\n/usr/share/man/man2/acquiresemaphore.md\n/usr/share/man/man2/alarm.md\n/usr/share/man/man2/arplist.md\n/usr/share/man/man2/arpset.md\n/usr/share/man/man2/attach.md\n/usr/share/man/man2/callmodule.md\n/usr/share/man/man2/cancel.md\n/usr/share/man/man2/cchost.md\n/usr/share/man/man2/checkuri.md\n/usr/share/man/man2/chmod.md\n/usr/share/man/man2/chown.md\n/usr/share/man/man2/chroot.md\n/usr/share/man/man2/combine.md\n/usr/share/man/man2/connect.md\n/usr/share/man/man2/detach.md\n/usr/share/man/man2/devalias.md\n/usr/share/man/man2/devcall.md\n/usr/share/man/man2/devchildren.md\n/usr/share/man/man2/devfind.md\n/usr/share/man/man2/devinfo.md\n/usr/share/man/man2/devlisten.md\n/usr/share/man/man2/devlock.md\n/usr/share/man/man2/devlookup.md\n/usr/share/man/man2/devmethods.md\n/usr/share/man/man2/devproperties.md\n/usr/share/man/man2/devunlock.md\n/usr/share/man/man2/ipconfig.md\n/usr/share/man/man2/kernargs.md\n/usr/share/man/man2/kill.md\n/usr/share/man/man2/link.md\n/usr/share/man/man2/list.md\n/usr/share/man/man2/listen.md\n/usr/share/man/man2/listmodules.md\n/usr/share/man/man2/loadCraftOSAPI.md\n/usr/share/man/man2/loadmodule.md\n/usr/share/man/man2/lockmutex.md\n/usr/share/man/man2/mkdir.md\n/usr/share/man/man2/mkfifo.md\n/usr/share/man/man2/mount.md\n/usr/share/man/man2/mountlist.md\n/usr/share/man/man2/netcontrol.md\n/usr/share/man/man2/netevent.md\n/usr/share/man/man2/open.md\n/usr/share/man/man2/queueEvent.md\n/usr/share/man/man2/releasesemaphore.md\n/usr/share/man/man2/remove.md\n/usr/share/man/man2/rename.md\n/usr/share/man/man2/routeadd.md\n/usr/share/man/man2/routedel.md\n/usr/share/man/man2/routelist.md\n/usr/share/man/man2/sendEvent.md\n/usr/share/man/man2/signal.md\n/usr/share/man/man2/stat.md\n/usr/share/man/man2/timeacquiresemaphore.md\n/usr/share/man/man2/timelockmutex.md\n/usr/share/man/man2/timer.md\n/usr/share/man/man2/trylockmutex.md\n/usr/share/man/man2/unlisten.md\n/usr/share/man/man2/unloadmodule.md\n/usr/share/man/man2/unlockmutex.md\n/usr/share/man/man2/unmount.md\n/usr/share/man/man2/uptime.md\n/usr/share/man/man2/version.md\n/usr/share/man/man3/\n/usr/share/man/man3/system.expect.md\n/usr/share/man/man3/system.filesystem.md\n/usr/share/man/man3/system.framebuffer.md\n/usr/share/man/man3/system.graphics.md\n/usr/share/man/man3/system.hardware.md\n/usr/share/man/man3/system.ipc.md\n/usr/share/man/man3/system.keys.md\n/usr/share/man/man3/system.log.md\n/usr/share/man/man3/system.network.md\n/usr/share/man/man3/system.pretty.md\n/usr/share/man/man3/system.process.md\n/usr/share/man/man3/system.serialization.md\n/usr/share/man/man3/system.sync.md\n/usr/share/man/man3/system.terminal.md\n/usr/share/man/man3/system.util.md\n/usr/share/man/man9/\n/usr/share/man/man9/kernel.md\n",created=1704748612198,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=2803},["ccryptolib.list"]={modified=1704748610572,data="/\n/usr/\n/usr/lib/\n/usr/lib/libccryptolib.a\n/usr/share/\n/usr/share/typescript/\n/usr/share/typescript/ccryptolib/\n/usr/share/typescript/ccryptolib/aead.d.ts\n/usr/share/typescript/ccryptolib/blake3.d.ts\n/usr/share/typescript/ccryptolib/chacha20.d.ts\n/usr/share/typescript/ccryptolib/ed25519.d.ts\n/usr/share/typescript/ccryptolib/index.d.ts\n/usr/share/typescript/ccryptolib/package.json\n/usr/share/typescript/ccryptolib/poly1305.d.ts\n/usr/share/typescript/ccryptolib/random.d.ts\n/usr/share/typescript/ccryptolib/sha256.d.ts\n/usr/share/typescript/ccryptolib/tsconfig.json\n/usr/share/typescript/ccryptolib/util.d.ts\n/usr/share/typescript/ccryptolib/x25519.d.ts\n",created=1704748610572,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=655},["startmgr.list"]={modified=1704748612684,data="/\n/etc/\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/startup.service\n/lib/\n/lib/startmgr.lua\n/sbin/\n/sbin/init.lua\n/sbin/shutdown.lua\n/sbin/startctl.lua\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man1/\n/usr/share/man/man1/shutdown.md\n/usr/share/man/man1/startctl.md\n/usr/share/man/man1/startmgr.md\n/usr/share/man/man3/\n",created=1704748612684,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=338},["initrd-utils.list"]={modified=1704748611124,data="/\n/etc/\n/etc/initrd/\n/etc/initrd/hooks.d/\n/etc/initrd/hooks.d/00-modules.lua\n/etc/initrd/hooks.d/01-files.lua\n/etc/initrd/hooks.d/05-shell.lua\n/etc/initrd/hooks.d/10-init.lua\n/etc/initrd/initrd.conf\n/usr/\n/usr/bin/\n/usr/bin/mktablefs.lua\n/usr/bin/update-initrd.lua\n/usr/share/\n/usr/share/man/\n/usr/share/man/man8/\n/usr/share/man/man8/update-initrd.md\n",created=1704748611124,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=351},["startmgr.conffiles"]={modified=1704748612684,data="",created=1704748612684,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=0},["ftp.list"]={modified=1704748610979,data="/\n/etc/\n/etc/ftpmgr.conf\n/etc/startmgr/\n/etc/startmgr/system/\n/etc/startmgr/system/ftpmgr.service\n/lib/\n/lib/fuse/\n/lib/fuse/ftp.lua\n/usr/\n/usr/lib/\n/usr/lib/ftp.lua\n/usr/libexec/\n/usr/libexec/ftpmgr.lua\n/usr/share/\n/usr/share/man/\n/usr/share/man/man3/\n/usr/share/man/man3/ftp.md\n/usr/share/man/man5/\n/usr/share/man/man5/ftpmgr.conf.md\n/usr/share/man/man8/\n/usr/share/man/man8/ftpmgr.md\n",created=1704748610979,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=387},["dpkg.conffiles"]={modified=1704748610865,data="",created=1704748610865,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=0},["luz.list"]={modified=1704748611569,data="/\n/bin/\n/bin/luz.lua\n/lib/\n/lib/luz/\n/lib/luz/compress.lua\n/lib/luz/decompress.lua\n/lib/luz/lex.lua\n/lib/luz/lz77.lua\n/lib/luz/maketree.lua\n/lib/luz/minify.lua\n/lib/luz/token_encode_map.lua\n/lib/modules/\n/lib/modules/luz.lua\n",created=1704748611569,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=225},["spanfs.list"]={modified=1704748612572,data="/\n/lib/\n/lib/modules/\n/lib/modules/spanfs.lua\n/sbin/\n/sbin/mkspanfs.lua\n/sbin/spanadd.lua\n/sbin/spaninfo.lua\n/usr/\n/usr/share/\n/usr/share/man/\n/usr/share/man/man7/\n/usr/share/man/man7/spanfs.md\n/usr/share/man/man8/\n/usr/share/man/man8/mkspanfs.md\n/usr/share/man/man8/spanadd.md\n/usr/share/man/man8/spaninfo.md\n",created=1704748612572,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=310},["libcraftos.conffiles"]={modified=1704748611248,data="",created=1704748611248,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=0},["libcraftos.md5sums"]={modified=1704748611249,data="2491e895910d32c9f82fcb6541fd3e34  bin/craftos.lua\n96654d5385d7f6f6cd4df591b4187f0a  usr/share/man/man1/shell.md\n41d06e951eb67ce6a962d2e32f2a22f9  lib/libcraftos.a\n191ca4cf0fc3b7d0362f3caecf2ef411  lib/libcc.a\n2ae28cfcf7043e98dfa59e3899d6a837  usr/share/man/man1/craftos.md\n254d1461a35ee297995f9da936cd60e5  bin/shell.lua\n",created=1704748611249,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=321},["initrd-utils.md5sums"]={modified=1704748611124,data="d41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/update-initrd.md\n4c2f99a6afc19bce3295a727ed5e8eb7  usr/bin/update-initrd.lua\nd8b1a2233c15c3046f0487033043371f  etc/initrd/hooks.d/01-files.lua\n9db39ca3f02b2edaf85d3592a5286fa2  etc/initrd/hooks.d/05-shell.lua\n0fddcca5345e03354ce487ac30956628  etc/initrd/initrd.conf\n9e3969cffb4e6f97ccde4da9c8e8a72e  usr/bin/mktablefs.lua\n16e35d7b06430c18002fdaaa097793c5  etc/initrd/hooks.d/10-init.lua\nc737755eb7c50bccabd06de16ac53c0b  etc/initrd/hooks.d/00-modules.lua\n",created=1704748611124,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=508},["sha2.md5sums"]={modified=1704748612469,data="5b6687a44f299b26cb8e8d97b0469fd4  usr/bin/sha512sum.lua\nf1245ba271f47d6318e39fac55a96258  usr/bin/sha1sum.lua\n88b53fee64630fb7bbfa178142d1c92d  usr/bin/sha384sum.lua\n89854efcea24687d4f30272d0225950a  usr/bin/sha224sum.lua\nfd7898467beac7ef6758c8d3705bc210  usr/share/typescript/sha2/index.d.ts\n7ef0d716bdb5af0519dbfacf10d9c8cf  usr/share/typescript/sha2/package.json\n064cbb9bd225cc296c44ef60974315fe  usr/share/typescript/sha2/tsconfig.json\n3d3f60e38d1e37fea659736e340ddeb9  usr/bin/b2sum.lua\n44304a9aa632161afa6524d6bc03e42a  usr/bin/sha256sum.lua\n368538cdc6f626d57abd0198700058d3  usr/bin/shasum.lua\n0b23c04f92d6d68601b90ebc0acdba3d  usr/bin/md5sum.lua\n124dbf6c8623dbc523f29b8c2a7a366c  usr/lib/sha2.lua\n",created=1704748612469,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=705},["fuse.md5sums"]={modified=1704748611052,data="4f70313f4c99be264d2232cec45c8ad5  lib/modules/fuse.lua\n09dc6c64b9805a78c159c544f2ac9560  usr/share/man/man7/fuse.md\n",created=1704748611052,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=116},["sha2.conffiles"]={modified=1704748612469,data="",created=1704748612469,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=0},["ccryptolib.conffiles"]={modified=1704748610572,data="",created=1704748610572,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=0},["netmgr.md5sums"]={modified=1704748611704,data="267be66198676aa26de44f8e8a1bc207  etc/network.conf\n5f6e8b6f9644d4c54ffdc86d004201a5  etc/startmgr/system/netmgr.service\n686188258ec8255c3ce3168f22d8b408  usr/libexec/netmgr.lua\n",created=1704748611704,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=177},["netutils.md5sums"]={modified=1704748611764,data="f7aabeec00376eb5e12643392fb5abae  usr/bin/arp.lua\ne8fe3e8b26edb804f8bef0b17e9e6afb  usr/bin/dhclient.lua\n41c9783bf056efa1345e0e058ed4d63a  usr/bin/ifconfig.lua\n158a50065b8d605ce928a75ed7b83d98  usr/bin/route.lua\n68b329da9893e34099c7d8ad5cb9c940  usr/bin/nc.lua\n5881edfd5fc61aaea57986174d5e1a8c  usr/bin/ping.lua\n",created=1704748611764,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=312},["ftp.md5sums"]={modified=1704748610980,data="0d311fd801635be99833577c8317072a  usr/share/man/man5/ftpmgr.conf.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man8/ftpmgr.md\nd41d8cd98f00b204e9800998ecf8427e  usr/share/man/man3/ftp.md\ndaf955dbbcdcad648af2ad9d52a11cb8  etc/startmgr/system/ftpmgr.service\n4aba04dbe8f09fe6cf5c0f50e6829d8b  etc/ftpmgr.conf\nf7eee84fbfba58fd5f9e02fd4fce6975  usr/libexec/ftpmgr.lua\n1630d6d240408784b2e1b316ed4cd942  lib/fuse/ftp.lua\n7a760cd3b26ac36fa0e8934aabb0fb93  usr/lib/ftp.lua\n",created=1704748610980,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=468},["muxzcat.list"]={modified=1704748611645,data="/\n/usr/\n/usr/bin/\n/usr/bin/unxz.lua\n/usr/lib/\n/usr/lib/muxzcat.lua\n/usr/share/\n/usr/share/typescript/\n/usr/share/typescript/muxzcat/\n/usr/share/typescript/muxzcat/index.d.ts\n/usr/share/typescript/muxzcat/package.json\n/usr/share/typescript/muxzcat/tsconfig.json\n",created=1704748611645,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=261},["baseutils.postinst"]={modified=1704748610398,data="if ... == \"triggered\" then return coroutine.yield(\"syscall\", \"exec\", \"/bin/man.lua\", \"-u\") end",created=1704748610398,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=94},["initrd-utils.conffiles"]={modified=1704748611124,data="/etc/initrd/initrd.conf\n",created=1704748611124,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=24},["spanfs.md5sums"]={modified=1704748612572,data="125e008924e81e287b896ca534c39a9c  sbin/mkspanfs.lua\n1e86a7b4870ab26673ba335f84cb43a2  usr/share/man/man8/spaninfo.md\n0d26312bc80245eb751c67282895fe12  lib/modules/spanfs.lua\n7c5d3c8cf149d4e6a14f4f43ccf95e1b  usr/share/man/man8/spanadd.md\n842808b46a8b1f43ccc3960ca1eea0ab  usr/share/man/man8/mkspanfs.md\n12ae0eecfc9726d37b739bbfabd91fa4  sbin/spanadd.lua\nda4cc0b9de4f274cde762fdcf4960a78  usr/share/man/man7/spanfs.md\n1500428c94799e469bf39de9cfe1d6b7  sbin/spaninfo.lua\n",created=1704748612572,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=469},["ar.list"]={modified=1704748610205,data="/\n/bin/\n/bin/ar.lua\n/lib/\n/lib/ar.lua\n",created=1704748610205,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=38},["dpkg.list"]={modified=1704748610865,data="/\n/usr/\n/usr/bin/\n/usr/bin/components.lua\n/usr/bin/dpkg-deb.lua\n/usr/bin/dpkg-divert.lua\n/usr/bin/dpkg-query.lua\n/usr/bin/dpkg-trigger.lua\n/usr/bin/dpkg.lua\n/usr/bin/update.lua\n/usr/lib/\n/usr/lib/dpkg/\n/usr/lib/dpkg/control.lua\n/usr/lib/dpkg/deb.lua\n/usr/lib/dpkg/divert.lua\n/usr/lib/dpkg/init.lua\n/usr/lib/dpkg/query.lua\n/usr/lib/dpkg/trigger.lua\n/usr/share/\n/usr/share/man/\n/usr/share/man/man8/\n/usr/share/man/man8/components.md\n/usr/share/man/man8/dpkg.md\n/usr/share/man/man8/update.md\n",created=1704748610865,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=489},["baseutils.conffiles"]={modified=1704748610396,data="/etc/fstab\n",created=1704748610396,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=11},["libsystem.conffiles"]={modified=1704748611482,data="",created=1704748611482,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=0},["luz.md5sums"]={modified=1704748611570,data="a9979c022975187f0dc8945a0d4cc1c6  lib/luz/compress.lua\nbf692665ff81a957298f784d7bf73531  lib/luz/token_encode_map.lua\nc6f4c9d10659f0a6438e22e0a787d573  lib/luz/decompress.lua\n2f4c8200e228ef34efece3e66286d41c  lib/modules/luz.lua\ncfaab46b772f6efe1fe86af611a8ba7f  lib/luz/maketree.lua\n802f60c677e8859a1e515169219c5f8f  bin/luz.lua\n12b1258d8ec144f602549a2e0f79a809  lib/luz/minify.lua\n9654f6e61a1f848f18834d44b4a622c2  lib/luz/lex.lua\n16f1b23c5035e2dc69e08a69501bfd72  lib/luz/lz77.lua\n",created=1704748611570,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=484},["libsystem.md5sums"]={modified=1704748611482,data="13f809f9dc9bf7dd58d94a1bdad99397  usr/share/typescript/libsystem/keys.d.ts\n6f8db86201e70c32e9b6d1f813218ad0  usr/share/typescript/libsystem/graphics.d.ts\naa2b200db77d37b61d8690f3391f7557  usr/share/typescript/libsystem/process.d.ts\n320586c5b467a003dd3177db641f5c2d  usr/share/typescript/libsystem/sync.d.ts\n4fa314ff644018cb8838f1e213ea8d9d  usr/share/typescript/libsystem/expect.d.ts\na2ea645869133f7ab6dfe6961bcccb1a  usr/share/typescript/libsystem/pretty.d.ts\nfc0ae55e645bdd157c4829244b1bb4ef  usr/share/typescript/libsystem/index.d.ts\n9e76ea5763ad7ae1901a11abb0bbdc07  usr/share/typescript/libsystem/log.d.ts\n9cbd96707e27bcefacbc75bf87cc5573  usr/share/typescript/libsystem/util.d.ts\n573b75065dda60741916857cf7b17513  usr/share/typescript/libsystem/framebuffer.d.ts\nc9eb82297fb15bf2d7cca40aec7eba53  usr/share/typescript/libsystem/serialization.d.ts\n064cbb9bd225cc296c44ef60974315fe  usr/share/typescript/libsystem/tsconfig.json\ne58516eeb3bc4090706326acf586cc71  usr/share/typescript/libsystem/hardware.d.ts\nb51c51f34b72861f252b257113f490d4  usr/share/typescript/libsystem/terminal.d.ts\n88077c468ece7574893942fbeb1f1a62  usr/share/typescript/libsystem/ipc.d.ts\n697ac27490e74cf0201d00488b6d2453  usr/share/typescript/libsystem/events.d.ts\nd4149febf0e46849e9cfd9bff0c818d2  usr/share/typescript/libsystem/package.json\n12474a892bb1d30f64e1f274e9c3a73b  usr/share/typescript/libsystem/network.d.ts\n660b438ba4df26a007ad0d8baa54cfed  lib/libsystem.a\nd81e7cf55c0a24ff3a58f916c5b10b96  usr/share/typescript/libsystem/filesystem.d.ts\n",created=1704748611482,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1527},["diff.conffiles"]={modified=1704748610672,data="",created=1704748610672,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=0},["ar.conffiles"]={modified=1704748610205,data="",created=1704748610205,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=0}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},status={modified=1704748613174,data="Package: libdeflate\nVersion: 1.0.2-1\nPriority: optional\nArchitecture: phoenix\nStatus: install ok installed\nSection: libraries\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: DEFLATE/zlib compression library\n Provides compression and decompression for DEFLATEformatted archives, including zlib and gzip files.\n\nPackage: dhcpmgr\nVersion: 0.1-1\nStatus: install ok installed\nSection: net\nArchitecture: phoenix\nPriority: optional\nDepends: libsystem\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: DHCP server manager for Phoenix\n Implements a Dynamic Host Configuration Protocolserver, which allocates and assigns IP addressesto computers on a network.\n\nPackage: spanfs\nVersion: 0.1-1\nPriority: optional\nArchitecture: phoenix\nSection: kernel\nStatus: install ok installed\nDepends: libsystem\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Spanning filesystem kernel module & utilities\n spanfs provides a RAID-like spanning filesystemthat allows concatenating multiple disk drivesinto a single large virtual disk. One disk storesan index file containing the filesystem structure,and the file data is spread across the rest of thedisks.\n\nPackage: initrd-utils\nVersion: 0.1-1\nStatus: install ok installed\nRequires: libsystem\nSection: admin\nArchitecture: phoenix\nPriority: optional\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: initrd management tools\n Contains a collection of utility programs to createand manage initial ramdisk (initrd) files.\n\nPackage: netmgr\nVersion: 0.1-1\nStatus: install ok installed\nSection: net\nArchitecture: phoenix\nPriority: optional\nDepends: libsystem\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Network manager service\n Background manager that automatically configuresnetworking on all available modems.\n\nPackage: libsystem\nVersion: 0.1.4-1\nStatus: install ok installed\nSection: libraries\nArchitecture: phoenix\nPriority: required\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nEssential: yes\nDescription: System libraries for Phoenix\n Provides convenient wrapper functions for usingPhoenix syscalls, as well as various usefulcomponents for programs.\n\nPackage: tar\nVersion: 1.0.1-1\nPriority: important\nArchitecture: phoenix\nSection: utils\nStatus: install ok installed\nDepends: libsystem\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: TAR archive format library and program\n Allows creating and extracting TAR archives.\n\nPackage: phoenix-docs\nVersion: 0.0.4-1\nPriority: optional\nArchitecture: all\nStatus: install ok installed\nSection: doc\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Documentation files for Phoenix\n Contains manual files for Phoenix syscalls andkernel API functions, libsystem modules, andbaseutils programs. These are separated from themain packages to save space.\n\nPackage: ftp\nVersion: 0.1-1\nStatus: install ok installed\nPriority: optional\nArchitecture: phoenix\nRecommends: fuse, usermgr, startmgr\nSection: net\nDepends: libsystem, sha2\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: RFC 959-compliant FTP client & server\n Implements the FTP protocol on top of Phoenixsockets. Includes an object-oriented library formanaging clients and servers, as well as a smallserver manager for FTP access, and a FUSEfilesystem for mounting FTP shares locally.\n\nPackage: startmgr\nVersion: 0.1.1-1\nPriority: standard\nEssential: yes\nArchitecture: phoenix\nSection: admin\nStatus: install ok installed\nDepends: libsystem\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Phoenix service manager and init system\n Provides automatic service management facilitiesfor Phoenix systems.\n\nPackage: muxzcat\nVersion: 1.0-2\nPriority: optional\nArchitecture: phoenix\nStatus: install ok installed\nSection: libraries\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: LZMA/XZ decompression library\n Provides functions for decompressing LZMA and XZformat compressed files.\n\nPackage: fuse\nVersion: 0.1-1\nPriority: optional\nArchitecture: phoenix\nStatus: install ok installed\nSection: kernel\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Filesystem in userspace module\n fuse implements filesystems in userspace, allowingfilesystems to be implemented without using kernelmodules.\n\nPackage: luz\nVersion: 0.1-1\nStatus: install ok installed\nSection: libraries\nArchitecture: phoenix\nPriority: optional\nDepends: libdeflate\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Lua compression algorithm\n Efficient compressor for Lua scripts. Includes ashared library, a command-line utility to compressand decompress Lua files, and a kernel module toallow direct execution of Luz files.\n\nPackage: dpkg\nVersion: 0.2.3-1\nPriority: required\nArchitecture: phoenix\nSection: admin\nStatus: install ok installed\nDepends: ar, diff, libdeflate, libsystem, muxzcat, sha2, tar\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Debian Package Manager for Phoenix\n A port of the Debian Package Manager to thePhoenix operating system, written in Lua.\n\nPackage: ar\nVersion: 1.1-1\nPriority: standard\nArchitecture: phoenix\nSection: utils\nStatus: install ok installed\nDepends: libsystem\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: ar archive format library and program\n Allows creating and extracting ar/.a archives.\n\nPackage: yahtcc\nVersion: 1.0-2\nStatus: install ok installed\nRequires: libsystem\nArchitecture: phoenix\nSection: games\nPriority: optional\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Yahtzee game for Phoenix\n Yahtzee game for Phoenix\n\nPackage: libcraftos\nVersion: 0.2.2-1\nPriority: optional\nArchitecture: phoenix\nStatus: install ok installed\nSection: libraries\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: CraftOS compatibility library\n Provides CraftOS shim functions to allow runningCraftOS programs on Phoenix.\n\nPackage: pxboot\nVersion: 0.1.3-1\nStatus: install ok installed\nSection: admin\nArchitecture: phoenix\nPriority: required\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nEssential: yes\nDescription: Multipurpose bootloader for ComputerCraft\n A bootloader for ComputerCraft operating systemswith built-in UnBIOS functionality, a configurableselection menu, and more. Designed for Phoenix,but supports other OSes as well, including CraftOS.\n\nPackage: typescript\nVersion: 1.16.1-1\nStatus: install ok installed\nHomepage: https://typescript-to-lua.github.io\nSection: libraries\nArchitecture: phoenix\nPriority: optional\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: TypeScriptToLua library features bundle\n Provides important polyfills to allow TypeScript code to run on Lua platforms.To use, set \"luaLibImport\" to \"require\" in tsconfig.json, and either set\"luaLibName\" to \"typescript\" (requires @jackmacwindows/typescript-to-lua), orreplace `require(\"lualib-bundle\")` with `require(\"typescript\")` in generatedfiles.\n\nPackage: diskmgr\nVersion: 1.0-1\nStatus: install ok installed\nRequires: libsystem\nSection: utils\nArchitecture: phoenix\nPriority: standard\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: disk auto mounting manager\n Manager service to handle automatically mountingattached disks.\n\nPackage: netutils\nVersion: 0.1-1\nPriority: optional\nArchitecture: phoenix\nSection: net\nStatus: install ok installed\nDepends: libsystem\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: Network configuration utilities\n Provides a set of programs to configure the systemnetworking layer.\n\nPackage: sha2\nVersion: 12-2\nStatus: install ok installed\nRequires: libsystem\nSection: libraries\nArchitecture: phoenix\nPriority: optional\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: SHA-1, SHA-2, SHA-3, BLAKE2 and BLAKE3 functions written in pure Lua and optimized for speed.\n This module contains functions to calculate SHA digest:   MD5, SHA-1,   SHA-224, SHA-256, SHA-512/224, SHA-512/256, SHA-384, SHA-512,   SHA3-224, SHA3-256, SHA3-384, SHA3-512, SHAKE128, SHAKE256,   HMAC,   BLAKE2b, BLAKE2s, BLAKE2bp, BLAKE2sp, BLAKE2Xb, BLAKE2Xs,   BLAKE3, BLAKE3_KDFWritten in pure Lua.Compatible with:   Lua 5.1, Lua 5.2, Lua 5.3, Lua 5.4, Fengari, LuaJIT 2.0/2.1 (any CPU endianness).Main feature of this module: it was heavily optimized for speed.For every Lua version the module contains particular implementation branch to get benefits from version-specific features.   - branch for Lua 5.1 (emulating bitwise operators using look-up table)   - branch for Lua 5.2 (using bit32/bit library), suitable for both Lua 5.2 with native \"bit32\" and Lua 5.1 with external library \"bit\"   - branch for Lua 5.3/5.4 (using native 64-bit bitwise operators)   - branch for Lua 5.3/5.4 (using native 32-bit bitwise operators) for Lua built with LUA_INT_TYPE=LUA_INT_INT   - branch for LuaJIT without FFI library (useful in a sandboxed environment)   - branch for LuaJIT x86 without FFI library (LuaJIT x86 has oddity because of lack of CPU registers)   - branch for LuaJIT 2.0 with FFI library (bit.* functions work only with Lua numbers)   - branch for LuaJIT 2.1 with FFI library (bit.* functions can work with \"int64_t\" arguments)\n\nPackage: baseutils\nVersion: 0.2-1\nStatus: install ok installed\nSection: utils\nArchitecture: phoenix\nPriority: important\nDepends: libsystem\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: base utility set for Phoenix\n Contains a standard set of POSIX utilities for Phoenix.\n\nPackage: ccryptolib\nVersion: 1.0.1-1\nPriority: optional\nArchitecture: phoenix\nSection: libraries\nStatus: install ok installed\nDepends: libsystem\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: cryptography library for Phoenix\n An integrated collection of cryptographic primitives written in Lua usingthe ComputerCraft/Phoenix system API.\n\nPackage: diff\nVersion: 1.0-1\nPriority: important\nArchitecture: phoenix\nSection: utils\nStatus: install ok installed\nDepends: libsystem\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nDescription: File comparison library and utility\n Provides a library for comparing files, as well asprograms for comparing and patching using the lib.\n\nPackage: usermgr\nVersion: 0.1.2-1\nStatus: install ok installed\nRequires: libsystem\nSection: admin\nArchitecture: phoenix\nMaintainer: JackMacWindows <jackmacwindowslinux@gmail.com>\nPriority: standard\nEssential: yes\nDescription: user account manager\n Manager service to handle user accounts, includinglogin, passwords, creation, and deletion.\n\n",created=1704748613174,setuser=false,worldPermissions={execute=true,write=false,read=true},owner="root",type="file",permissions={root={execute=true,write=true,read=true}},size=10663},triggers={modified=1704748613173,created=1704748613173,contents={Unincorp={modified=1704748613171,data="",created=1704748613172,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=0},File={modified=1704748610397,data="/usr/share/man baseutils\n",created=1704748610397,setuser=false,worldPermissions={execute=true,write=false,read=true},owner="root",type="file",permissions={root={execute=true,write=true,read=true}},size=25}},owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0}},owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0}},owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0}},owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},home={modified=1704748613177,created=1704748613177,contents={phoenix={modified=1704748613178,created=1704748613178,contents={[".cashrc"]={modified=1704748613178,data="PS1=\"\\033[1;32m\\u@\\h\\033[39m:\\033[34m\\W\\033[0m\\$ \"",created=1704748613178,owner="phoenix",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=50}},owner="phoenix",setuser=false,worldPermissions={execute=true,write=false,read=true},type="directory",permissions={phoenix={execute=true,write=true,read=true},root={execute=true,write=true,read=true}},size=0}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},usr={modified=1704748610628,created=1704748610628,contents={lib={modified=1704748613030,created=1704748613030,contents={["libccryptolib.a"]={modified=1704748610560,data="!<arch>\n//              0           0     0     666     109       `\ninternal_curve25519.lua\ninternal_edwards25519.lua\ninternal_packing.lua\ninternal_sha512.lua\ninternal_util.lua\n\naead.lua/       1686753801  0     0     775     3826      `\n--- The ChaCha20Poly1305AEAD authenticated encryption with associated data (AEAD) construction.\n\nlocal expect   = require \"system.expect\".expect\nlocal lassert = require \"internal_util\".lassert\nlocal packing  = require \"internal_packing\"\nlocal chacha20 = require \"chacha20\"\nlocal poly1305 = require \"poly1305\"\n\nlocal p8x1, fmt8x1 = packing.compilePack(\"<I8\")\nlocal u4x4, fmt4x4 = packing.compileUnpack(\"<I4I4I4I4\")\nlocal bxor = bit32.bxor\n\n--- Encrypts a message.\n--- @param key string A 32-byte random key.\n--- @param nonce string A 12-byte per-message unique nonce.\n--- @param message string The message to be encrypted.\n--- @param aad string aad Arbitrary associated data to also authenticate.\n--- @param rounds number? The number of ChaCha20 rounds to use. Defaults to 20.\n--- @return string ctx The ciphertext.\n--- @return string tag The 16-byte authentication tag.\nlocal function encrypt(key, nonce, message, aad, rounds)\n    expect(1, key, \"string\")\n    lassert(#key == 32, \"key length must be 32\", 2)\n    expect(2, nonce, \"string\")\n    lassert(#nonce == 12, \"nonce length must be 12\", 2)\n    expect(3, message, \"string\")\n    expect(4, aad, \"string\")\n    rounds = expect(5, rounds, \"number\", \"nil\") or 20\n    lassert(rounds % 2 == 0, \"round number must be even\", 2)\n    lassert(rounds >= 8, \"round number must be no smaller than 8\", 2)\n    lassert(rounds <= 20, \"round number must be no larger than 20\", 2)\n\n    -- Generate auth key and encrypt.\n    local msgLong = (\"\\0\"):rep(64) .. message\n    local ctxLong = chacha20.crypt(key, nonce, msgLong, rounds, 0)\n    local authKey = ctxLong:sub(1, 32)\n    local ciphertext = ctxLong:sub(65)\n\n    -- Authenticate.\n    local pad1 = (\"\\0\"):rep(-#aad % 16)\n    local pad2 = (\"\\0\"):rep(-#ciphertext % 16)\n    local aadLen = p8x1(\"<I8\", #aad)\n    local ctxLen = p8x1(\"<I8\", #ciphertext)\n    local combined = aad .. pad1 .. ciphertext .. pad2 .. aadLen .. ctxLen\n    local tag = poly1305.mac(authKey, combined)\n\n    return ciphertext, tag\nend\n\n--- Decrypts a message.\n--- @param key string The key used on encryption.\n--- @param nonce string The nonce used on encryption.\n--- @param ciphertext string The ciphertext to be decrypted.\n--- @param aad string The arbitrary associated data used on encryption.\n--- @param tag string The authentication tag returned on encryption.\n--- @param rounds number The number of rounds used on encryption.\n--- @return string? msg The decrypted plaintext. Or nil on auth failure.\nlocal function decrypt(key, nonce, tag, ciphertext, aad, rounds)\n    expect(1, key, \"string\")\n    lassert(#key == 32, \"key length must be 32\", 2)\n    expect(2, nonce, \"string\")\n    lassert(#nonce == 12, \"nonce length must be 12\", 2)\n    expect(3, tag, \"string\")\n    lassert(#tag == 16, \"tag length must be 16\", 2)\n    expect(4, ciphertext, \"string\")\n    expect(5, aad, \"string\")\n    rounds = expect(6, rounds, \"number\", \"nil\") or 20\n    lassert(rounds % 2 == 0, \"round number must be even\", 2)\n    lassert(rounds >= 8, \"round number must be no smaller than 8\", 2)\n    lassert(rounds <= 20, \"round number must be no larger than 20\", 2)\n\n    -- Generate auth key.\n    local authKey = chacha20.crypt(key, nonce, (\"\\0\"):rep(32), rounds, 0)\n\n    -- Check tag.\n    local pad1 = (\"\\0\"):rep(-#aad % 16)\n    local pad2 = (\"\\0\"):rep(-#ciphertext % 16)\n    local aadLen = p8x1(fmt8x1, #aad)\n    local ctxLen = p8x1(fmt8x1, #ciphertext)\n    local combined = aad .. pad1 .. ciphertext .. pad2 .. aadLen .. ctxLen\n    local t1, t2, t3, t4 = u4x4(fmt4x4, tag, 1)\n    local u1, u2, u3, u4 = u4x4(fmt4x4, poly1305.mac(authKey, combined), 1)\n    local eq = bxor(t1, u1) + bxor(t2, u2) + bxor(t3, u3) + bxor(t4, u4)\n    if eq ~= 0 then return nil end\n\n    -- Decrypt\n    return chacha20.crypt(key, nonce, ciphertext, rounds)\nend\n\nreturn {\n    encrypt = encrypt,\n    decrypt = decrypt,\n}\nblake3.lua/     1686753801  0     0     775     8899      `\n--- The BLAKE3 cryptographic hash function.\n\nlocal expect = require \"system.expect\".expect\nlocal lassert = require \"internal_util\".lassert\nlocal packing = require \"internal_packing\"\n\nlocal unpack = unpack or table.unpack\nlocal bxor = bit32.bxor\nlocal rol = bit32.lrotate\nlocal p16x4, fmt16x4 = packing.compilePack(\"<I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\")\nlocal u16x4 = packing.compileUnpack(fmt16x4)\nlocal u8x4, fmt8x4 = packing.compileUnpack(\"<I4I4I4I4I4I4I4I4\")\n\nlocal CHUNK_START = 0x01\nlocal CHUNK_END = 0x02\nlocal PARENT = 0x04\nlocal ROOT = 0x08\nlocal KEYED_HASH = 0x10\nlocal DERIVE_KEY_CONTEXT = 0x20\nlocal DERIVE_KEY_MATERIAL = 0x40\n\nlocal IV = {\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,\n    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n}\n\nlocal function compress(h, msg, t, v14, v15, full)\n    local h00, h01, h02, h03, h04, h05, h06, h07 = unpack(h)\n    local v00, v01, v02, v03 = h00, h01, h02, h03\n    local v04, v05, v06, v07 = h04, h05, h06, h07\n    local v08, v09, v10, v11 = 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a\n    local v12 = t % 2 ^ 32\n    local v13 = (t - v12) * 2 ^ -32\n\n    local m00, m01, m02, m03, m04, m05, m06, m07,\n          m08, m09, m10, m11, m12, m13, m14, m15 = unpack(msg)\n\n    local tmp\n    for i = 1, 7 do\n        v00 = v00 + v04 + m00 v12 = rol(bxor(v12, v00), 16)\n        v08 = v08 + v12       v04 = rol(bxor(v04, v08), 20)\n        v00 = v00 + v04 + m01 v12 = rol(bxor(v12, v00), 24)\n        v08 = v08 + v12       v04 = rol(bxor(v04, v08), 25)\n\n        v01 = v01 + v05 + m02 v13 = rol(bxor(v13, v01), 16)\n        v09 = v09 + v13       v05 = rol(bxor(v05, v09), 20)\n        v01 = v01 + v05 + m03 v13 = rol(bxor(v13, v01), 24)\n        v09 = v09 + v13       v05 = rol(bxor(v05, v09), 25)\n\n        v02 = v02 + v06 + m04 v14 = rol(bxor(v14, v02), 16)\n        v10 = v10 + v14       v06 = rol(bxor(v06, v10), 20)\n        v02 = v02 + v06 + m05 v14 = rol(bxor(v14, v02), 24)\n        v10 = v10 + v14       v06 = rol(bxor(v06, v10), 25)\n\n        v03 = v03 + v07 + m06 v15 = rol(bxor(v15, v03), 16)\n        v11 = v11 + v15       v07 = rol(bxor(v07, v11), 20)\n        v03 = v03 + v07 + m07 v15 = rol(bxor(v15, v03), 24)\n        v11 = v11 + v15       v07 = rol(bxor(v07, v11), 25)\n\n        v00 = v00 + v05 + m08 v15 = rol(bxor(v15, v00), 16)\n        v10 = v10 + v15       v05 = rol(bxor(v05, v10), 20)\n        v00 = v00 + v05 + m09 v15 = rol(bxor(v15, v00), 24)\n        v10 = v10 + v15       v05 = rol(bxor(v05, v10), 25)\n\n        v01 = v01 + v06 + m10 v12 = rol(bxor(v12, v01), 16)\n        v11 = v11 + v12       v06 = rol(bxor(v06, v11), 20)\n        v01 = v01 + v06 + m11 v12 = rol(bxor(v12, v01), 24)\n        v11 = v11 + v12       v06 = rol(bxor(v06, v11), 25)\n\n        v02 = v02 + v07 + m12 v13 = rol(bxor(v13, v02), 16)\n        v08 = v08 + v13       v07 = rol(bxor(v07, v08), 20)\n        v02 = v02 + v07 + m13 v13 = rol(bxor(v13, v02), 24)\n        v08 = v08 + v13       v07 = rol(bxor(v07, v08), 25)\n\n        v03 = v03 + v04 + m14 v14 = rol(bxor(v14, v03), 16)\n        v09 = v09 + v14       v04 = rol(bxor(v04, v09), 20)\n        v03 = v03 + v04 + m15 v14 = rol(bxor(v14, v03), 24)\n        v09 = v09 + v14       v04 = rol(bxor(v04, v09), 25)\n\n        if i ~= 7 then\n            tmp = m02\n            m02 = m03\n            m03 = m10\n            m10 = m12\n            m12 = m09\n            m09 = m11\n            m11 = m05\n            m05 = m00\n            m00 = tmp\n\n            tmp = m06\n            m06 = m04\n            m04 = m07\n            m07 = m13\n            m13 = m14\n            m14 = m15\n            m15 = m08\n            m08 = m01\n            m01 = tmp\n        end\n    end\n\n    if full then\n        return {\n            bxor(v00, v08), bxor(v01, v09), bxor(v02, v10), bxor(v03, v11),\n            bxor(v04, v12), bxor(v05, v13), bxor(v06, v14), bxor(v07, v15),\n            bxor(v08, h00), bxor(v09, h01), bxor(v10, h02), bxor(v11, h03),\n            bxor(v12, h04), bxor(v13, h05), bxor(v14, h06), bxor(v15, h07),\n        }\n    else\n        return {\n            bxor(v00, v08), bxor(v01, v09), bxor(v02, v10), bxor(v03, v11),\n            bxor(v04, v12), bxor(v05, v13), bxor(v06, v14), bxor(v07, v15),\n        }\n    end\nend\n\nlocal function merge(cvl, cvr)\n    for i = 1, 8 do cvl[i + 8] = cvr[i] end\n    return cvl\nend\n\nlocal function blake3(iv, flags, msg, len)\n    -- Set up the state.\n    local stateCvs = {}\n    local stateCv = iv\n    local stateT = 0\n    local stateN = 0\n    local stateStart = CHUNK_START\n    local stateEnd = 0\n\n    -- Digest complete blocks.\n    for i = 1, #msg - 64, 64 do\n        -- Compress the block.\n        local block = {u16x4(fmt16x4, msg, i)}\n        local stateFlags = flags + stateStart + stateEnd\n        stateCv = compress(stateCv, block, stateT, 64, stateFlags)\n        stateStart = 0\n        stateN = stateN + 1\n\n        if stateN == 15 then\n            -- Last block in chunk.\n            stateEnd = CHUNK_END\n        elseif stateN == 16 then\n            -- Chunk complete, merge.\n            local mergeCv = stateCv\n            local mergeAmt = stateT + 1\n            while mergeAmt % 2 == 0 do\n                local block = merge(table.remove(stateCvs), mergeCv)\n                mergeCv = compress(iv, block, 0, 64, flags + PARENT)\n                mergeAmt = mergeAmt / 2\n            end\n\n            -- Push back.\n            table.insert(stateCvs, mergeCv)\n\n            -- Update state back to next chunk.\n            stateCv = iv\n            stateT = stateT + 1\n            stateN = 0\n            stateStart = CHUNK_START\n            stateEnd = 0\n        end\n    end\n\n    -- Pad the last message block.\n    local lastLen = #msg == 0 and 0 or (#msg - 1) % 64 + 1\n    local padded = msg:sub(-lastLen) .. (\"\\0\"):rep(64)\n    local last = {u16x4(fmt16x4, padded, 1)}\n\n    -- Prepare output expansion state.\n    local outCv, outBlock, outLen, outFlags\n    if stateT > 0 then\n        -- Root is a parent, digest last block now and merge parents.\n        local stateFlags = flags + stateStart + CHUNK_END\n        local mergeCv = compress(stateCv, last, stateT, lastLen, stateFlags)\n        for i = #stateCvs, 2, -1 do\n            local block = merge(stateCvs[i], mergeCv)\n            mergeCv = compress(iv, block, 0, 64, flags + PARENT)\n        end\n\n        -- Set output state.\n        outCv = iv\n        outBlock = merge(stateCvs[1], mergeCv)\n        outLen = 64\n        outFlags = flags + ROOT + PARENT\n    else\n        -- Root block is in the first chunk, set output state.\n        outCv = stateCv\n        outBlock = last\n        outLen = lastLen\n        outFlags = flags + stateStart + CHUNK_END + ROOT\n    end\n\n    -- Expand output.\n    local out = {}\n    for i = 0, len / 64 do\n        local md = compress(outCv, outBlock, i, outLen, outFlags, true)\n        out[i + 1] = p16x4(fmt16x4, unpack(md))\n    end\n\n    return table.concat(out):sub(1, len)\nend\n\n--- Hashes data using BLAKE3.\n--- @param message string The input message.\n--- @param len number? The desired hash length, in bytes. Defaults to 32.\n--- @return string hash The hash.\nlocal function digest(message, len)\n    expect(1, message, \"string\")\n    len = expect(2, len, \"number\", \"nil\") or 32\n    lassert(len % 1 == 0, \"desired output length must be an integer\", 2)\n    lassert(len >= 1, \"desired output length must be positive\", 2)\n    return blake3(IV, 0, message, len)\nend\n\n--- Performs a keyed hash.\n--- @param key string A 32-byte random key.\n--- @param message string The input message.\n--- @param len number? The desired hash length, in bytes. Defaults to 32.\n--- @return string hash The keyed hash.\nlocal function digestKeyed(key, message, len)\n    expect(1, key, \"string\")\n    lassert(#key == 32, \"key length must be 32\", 2)\n    expect(2, message, \"string\")\n    len = expect(3, len, \"number\", \"nil\") or 32\n    lassert(len % 1 == 0, \"desired output length must be an integer\", 2)\n    lassert(len >= 1, \"desired output length must be positive\", 2)\n    return blake3({u8x4(fmt8x4, key, 1)}, KEYED_HASH, message, len)\nend\n\n--- Makes a context-based key derivation function (KDF).\n--- @param context string The context for the KDF.\n--- @return fun(material: string, len: number?): string kdf The KDF.\nlocal function deriveKey(context)\n    expect(1, context, \"string\")\n    local iv = {u8x4(fmt8x4, blake3(IV, DERIVE_KEY_CONTEXT, context, 32), 1)}\n\n    --- Derives a key.\n    --- @param material string The keying material.\n    --- @param len number? The desired hash length, in bytes. Defaults to 32.\n    return function(material, len)\n        expect(1, material, \"string\")\n        len = expect(2, len, \"number\", \"nil\") or 32\n        lassert(len % 1 == 0, \"desired output length must be an integer\", 2)\n        lassert(len >= 1, \"desired output length must be positive\", 2)\n        return blake3(iv, DERIVE_KEY_MATERIAL, material, len)\n    end\nend\n\nreturn {\n    digest = digest,\n    digestKeyed = digestKeyed,\n    deriveKey = deriveKey,\n}\n\nchacha20.lua/   1686753801  0     0     775     5131      `\n--- The ChaCha20 stream cipher.\n\nlocal expect  = require \"system.expect\".expect\nlocal lassert = require \"internal_util\".lassert\nlocal packing = require \"internal_packing\"\n\nlocal bxor = bit32.bxor\nlocal rol = bit32.lrotate\nlocal u8x4, fmt8x4 = packing.compileUnpack(\"<I4I4I4I4I4I4I4I4\")\nlocal u3x4, fmt3x4 = packing.compileUnpack(\"<I4I4I4\")\nlocal p16x4, fmt16x4 = packing.compilePack(\"<I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\")\nlocal u16x4 = packing.compileUnpack(fmt16x4)\n\n--- Encrypts/Decrypts data using ChaCha20.\n--- @param key string A 32-byte random key.\n--- @param nonce string A 12-byte per-message unique nonce.\n--- @param message string A plaintext or ciphertext.\n--- @param rounds number? The number of ChaCha20 rounds to use. Defaults to 20.\n--- @param offset number? The block offset to generate the keystream at. Defaults to 1.\n--- @return string out The resulting ciphertext or plaintext.\nlocal function crypt(key, nonce, message, rounds, offset)\n    expect(1, key, \"string\")\n    lassert(#key == 32, \"key length must be 32\", 2)\n    expect(2, nonce, \"string\")\n    lassert(#nonce == 12, \"nonce length must be 12\", 2)\n    expect(3, message, \"string\")\n    rounds = expect(4, rounds, \"number\", \"nil\") or 20\n    lassert(rounds % 2 == 0, \"round number must be even\", 2)\n    lassert(rounds >= 8, \"round number must be no smaller than 8\", 2)\n    lassert(rounds <= 20, \"round number must be no larger than 20\", 2)\n    offset = expect(5, offset, \"number\", \"nil\") or 1\n    lassert(offset % 1 == 0, \"offset must be an integer\", 2)\n    lassert(offset >= 0, \"offset must be nonnegative\", 2)\n    lassert(#message + 64 * offset <= 2 ^ 38, \"offset too large\", 2)\n\n    -- Build the state block.\n    local i0, i1, i2, i3 = 0x61707865, 0x3320646e, 0x79622d32, 0x6b206574\n    local k0, k1, k2, k3, k4, k5, k6, k7 = u8x4(fmt8x4, key, 1)\n    local cr, n0, n1, n2 = offset, u3x4(fmt3x4, nonce, 1)\n\n    -- Pad the message.\n    local padded = message .. (\"\\0\"):rep(-#message % 64)\n\n    -- Expand and combine.\n    local out = {}\n    local idx = 1\n    for i = 1, #padded / 64 do\n        -- Copy the block.\n        local s00, s01, s02, s03 = i0, i1, i2, i3\n        local s04, s05, s06, s07 = k0, k1, k2, k3\n        local s08, s09, s10, s11 = k4, k5, k6, k7\n        local s12, s13, s14, s15 = cr, n0, n1, n2\n\n        -- Iterate.\n        for _ = 1, rounds, 2 do\n            s00 = s00 + s04 s12 = rol(bxor(s12, s00), 16)\n            s08 = s08 + s12 s04 = rol(bxor(s04, s08), 12)\n            s00 = s00 + s04 s12 = rol(bxor(s12, s00), 8)\n            s08 = s08 + s12 s04 = rol(bxor(s04, s08), 7)\n\n            s01 = s01 + s05 s13 = rol(bxor(s13, s01), 16)\n            s09 = s09 + s13 s05 = rol(bxor(s05, s09), 12)\n            s01 = s01 + s05 s13 = rol(bxor(s13, s01), 8)\n            s09 = s09 + s13 s05 = rol(bxor(s05, s09), 7)\n\n            s02 = s02 + s06 s14 = rol(bxor(s14, s02), 16)\n            s10 = s10 + s14 s06 = rol(bxor(s06, s10), 12)\n            s02 = s02 + s06 s14 = rol(bxor(s14, s02), 8)\n            s10 = s10 + s14 s06 = rol(bxor(s06, s10), 7)\n\n            s03 = s03 + s07 s15 = rol(bxor(s15, s03), 16)\n            s11 = s11 + s15 s07 = rol(bxor(s07, s11), 12)\n            s03 = s03 + s07 s15 = rol(bxor(s15, s03), 8)\n            s11 = s11 + s15 s07 = rol(bxor(s07, s11), 7)\n\n            s00 = s00 + s05 s15 = rol(bxor(s15, s00), 16)\n            s10 = s10 + s15 s05 = rol(bxor(s05, s10), 12)\n            s00 = s00 + s05 s15 = rol(bxor(s15, s00), 8)\n            s10 = s10 + s15 s05 = rol(bxor(s05, s10), 7)\n\n            s01 = s01 + s06 s12 = rol(bxor(s12, s01), 16)\n            s11 = s11 + s12 s06 = rol(bxor(s06, s11), 12)\n            s01 = s01 + s06 s12 = rol(bxor(s12, s01), 8)\n            s11 = s11 + s12 s06 = rol(bxor(s06, s11), 7)\n\n            s02 = s02 + s07 s13 = rol(bxor(s13, s02), 16)\n            s08 = s08 + s13 s07 = rol(bxor(s07, s08), 12)\n            s02 = s02 + s07 s13 = rol(bxor(s13, s02), 8)\n            s08 = s08 + s13 s07 = rol(bxor(s07, s08), 7)\n\n            s03 = s03 + s04 s14 = rol(bxor(s14, s03), 16)\n            s09 = s09 + s14 s04 = rol(bxor(s04, s09), 12)\n            s03 = s03 + s04 s14 = rol(bxor(s14, s03), 8)\n            s09 = s09 + s14 s04 = rol(bxor(s04, s09), 7)\n        end\n\n        -- Decode message block.\n        local m00, m01, m02, m03, m04, m05, m06, m07\n        local m08, m09, m10, m11, m12, m13, m14, m15\n\n        m00, m01, m02, m03, m04, m05, m06, m07,\n        m08, m09, m10, m11, m12, m13, m14, m15, idx =\n            u16x4(fmt16x4, padded, idx)\n\n        -- Feed-forward and combine.\n        out[i] = p16x4(fmt16x4,\n            bxor(m00, s00 + i0), bxor(m01, s01 + i1),\n            bxor(m02, s02 + i2), bxor(m03, s03 + i3),\n            bxor(m04, s04 + k0), bxor(m05, s05 + k1),\n            bxor(m06, s06 + k2), bxor(m07, s07 + k3),\n            bxor(m08, s08 + k4), bxor(m09, s09 + k5),\n            bxor(m10, s10 + k6), bxor(m11, s11 + k7),\n            bxor(m12, s12 + cr), bxor(m13, s13 + n0),\n            bxor(m14, s14 + n1), bxor(m15, s15 + n2)\n        )\n\n        -- Increment counter.\n        cr = cr + 1\n    end\n\n    return table.concat(out):sub(1, #message)\nend\n\nreturn {\n    crypt = crypt,\n}\n\ned25519.lua/    1686753801  0     0     775     2571      `\n--- The Ed25519 digital signature scheme.\n\nlocal expect = require \"system.expect\".expect\nlocal lassert = require \"internal_util\".lassert\nlocal fq     = require \"internal_fq\"\nlocal sha512 = require \"internal_sha512\"\nlocal ed     = require \"internal_edwards25519\"\nlocal random = require \"random\"\n\n--- Computes a public key from a secret key.\n--- @param sk string A random 32-byte secret key.\n--- @return string pk The matching 32-byte public key.\nlocal function publicKey(sk)\n    expect(1, sk, \"string\")\n    assert(#sk == 32, \"secret key length must be 32\")\n\n    local h = sha512.digest(sk)\n    local x = fq.decodeClamped(h:sub(1, 32))\n\n    return ed.encode(ed.mulG(fq.bits(x)))\nend\n\n--- Signs a message.\n--- @param sk string The signer's secret key.\n--- @param pk string The signer's public key.\n--- @param msg string The message to be signed.\n--- @return string sig The 64-byte signature on the message.\nlocal function sign(sk, pk, msg)\n    expect(1, sk, \"string\")\n    lassert(#sk == 32, \"secret key length must be 32\", 2)\n    expect(2, pk, \"string\")\n    lassert(#pk == 32, \"public key length must be 32\", 2)\n    expect(3, msg, \"string\")\n\n    -- Secret key.\n    local h = sha512.digest(sk)\n    local x = fq.decodeClamped(h:sub(1, 32))\n\n    -- Commitment.\n    local k = fq.decodeWide(random.random(64))\n    local r = ed.mulG(fq.bits(k))\n    local rStr = ed.encode(r)\n\n    -- Challenge.\n    local e = fq.decodeWide(sha512.digest(rStr .. pk .. msg))\n\n    -- Response.\n    local m = fq.decodeWide(random.random(64))\n    local s = fq.sub(fq.add(k, fq.mul(fq.add(x, m), e)), fq.mul(m, e))\n    local sStr = fq.encode(s)\n\n    return rStr .. sStr\nend\n\n--- Verifies a signature on a message.\n--- @param pk string The signer's public key.\n--- @param msg string The signed message.\n--- @param sig string The alleged signature.\n--- @return boolean valid Whether the signature is valid or not.\nlocal function verify(pk, msg, sig)\n    expect(1, pk, \"string\")\n    lassert(#pk == 32, \"public key length must be 32\", 2) --- @cast pk String32\n    expect(2, msg, \"string\")\n    expect(3, sig, \"string\")\n    lassert(#sig == 64, \"signature length must be 64\", 2)\n\n    local y = ed.decode(pk)\n    if not y then return false end\n\n    local rStr = sig:sub(1, 32)\n    local sStr = sig:sub(33)\n\n    local e = fq.decodeWide(sha512.digest(rStr .. pk .. msg))\n\n    local gs = ed.mulG(fq.bits(fq.decode(sStr)))\n    local ye = ed.mul(y, fq.bits(e))\n    local rv = ed.sub(gs, ed.niels(ye))\n\n    return ed.encode(rv) == rStr\nend\n\nreturn {\n    publicKey = publicKey,\n    sign = sign,\n    verify = verify,\n}\n\npoly1305.lua/   1686753801  0     0     775     4556      `\n--- The Poly1305 one-time authenticator.\n\nlocal expect  = require \"system.expect\".expect\nlocal lassert = require \"internal_util\".lassert\nlocal packing = require \"internal_packing\"\n\nlocal u4x4, fmt4x4 = packing.compileUnpack(\"<I4I4I4I4\")\nlocal p4x4 = packing.compilePack(fmt4x4)\n\n--- Computes a Poly1305 message authentication code.\n--- @param key string A 32-byte single-use random key.\n--- @param message string The message to authenticate.\n--- @return string tag The 16-byte authentication tag.\nlocal function mac(key, message)\n    expect(1, key, \"string\")\n    lassert(#key == 32, \"key length must be 32\", 2)\n    expect(2, message, \"string\")\n\n    -- Pad message.\n    local pbplen = #message - 15\n    if #message % 16 ~= 0 or #message == 0 then\n        message = message .. \"\\1\"\n        message = message .. (\"\\0\"):rep(-#message % 16)\n    end\n\n    -- Decode r.\n    local R0, R1, R2, R3 = u4x4(fmt4x4, key, 1)\n\n    -- Clamp and shift.\n    R0 = R0 % 2 ^ 28\n    R1 = (R1 - R1 % 4) % 2 ^ 28 * 2 ^ 32\n    R2 = (R2 - R2 % 4) % 2 ^ 28 * 2 ^ 64\n    R3 = (R3 - R3 % 4) % 2 ^ 28 * 2 ^ 96\n\n    -- Split.\n    local r0 = R0 % 2 ^ 18   local r1 = R0 - r0\n    local r2 = R1 % 2 ^ 50   local r3 = R1 - r2\n    local r4 = R2 % 2 ^ 82   local r5 = R2 - r4\n    local r6 = R3 % 2 ^ 112  local r7 = R3 - r6\n\n    -- Generate scaled key.\n    local S1 = 5 / 2 ^ 130 * R1\n    local S2 = 5 / 2 ^ 130 * R2\n    local S3 = 5 / 2 ^ 130 * R3\n\n    -- Split.\n    local s2 = S1 % 2 ^ -80  local s3 = S1 - s2\n    local s4 = S2 % 2 ^ -48  local s5 = S2 - s4\n    local s6 = S3 % 2 ^ -16  local s7 = S3 - s6\n\n    local h0, h1, h2, h3, h4, h5, h6, h7 = 0, 0, 0, 0, 0, 0, 0, 0\n\n    for i = 1, #message, 16 do\n        -- Decode message block.\n        local m0, m1, m2, m3 = u4x4(fmt4x4, message, i)\n\n        -- Shift message and add.\n        local x0 = h0 + h1 + m0\n        local x2 = h2 + h3 + m1 * 2 ^ 32\n        local x4 = h4 + h5 + m2 * 2 ^ 64\n        local x6 = h6 + h7 + m3 * 2 ^ 96\n\n        -- Apply per-block padding when applicable.\n        if i <= pbplen then x6 = x6 + 2 ^ 128 end\n\n        -- Multiply\n        h0 = x0 * r0 + x2 * s6 + x4 * s4 + x6 * s2\n        h1 = x0 * r1 + x2 * s7 + x4 * s5 + x6 * s3\n        h2 = x0 * r2 + x2 * r0 + x4 * s6 + x6 * s4\n        h3 = x0 * r3 + x2 * r1 + x4 * s7 + x6 * s5\n        h4 = x0 * r4 + x2 * r2 + x4 * r0 + x6 * s6\n        h5 = x0 * r5 + x2 * r3 + x4 * r1 + x6 * s7\n        h6 = x0 * r6 + x2 * r4 + x4 * r2 + x6 * r0\n        h7 = x0 * r7 + x2 * r5 + x4 * r3 + x6 * r1\n\n        -- Carry.\n        local y0 = h0 + 3 * 2 ^ 69  - 3 * 2 ^ 69   h0 = h0 - y0  h1 = h1 + y0\n        local y1 = h1 + 3 * 2 ^ 83  - 3 * 2 ^ 83   h1 = h1 - y1  h2 = h2 + y1\n        local y2 = h2 + 3 * 2 ^ 101 - 3 * 2 ^ 101  h2 = h2 - y2  h3 = h3 + y2\n        local y3 = h3 + 3 * 2 ^ 115 - 3 * 2 ^ 115  h3 = h3 - y3  h4 = h4 + y3\n        local y4 = h4 + 3 * 2 ^ 133 - 3 * 2 ^ 133  h4 = h4 - y4  h5 = h5 + y4\n        local y5 = h5 + 3 * 2 ^ 147 - 3 * 2 ^ 147  h5 = h5 - y5  h6 = h6 + y5\n        local y6 = h6 + 3 * 2 ^ 163 - 3 * 2 ^ 163  h6 = h6 - y6  h7 = h7 + y6\n        local y7 = h7 + 3 * 2 ^ 181 - 3 * 2 ^ 181  h7 = h7 - y7\n\n        -- Reduce carry overflow into first limb.\n        h0 = h0 + 5 / 2 ^ 130 * y7\n    end\n\n    -- Carry canonically.\n    local c0 = h0 % 2 ^ 16   h1 = h0 - c0 + h1\n    local c1 = h1 % 2 ^ 32   h2 = h1 - c1 + h2\n    local c2 = h2 % 2 ^ 48   h3 = h2 - c2 + h3\n    local c3 = h3 % 2 ^ 64   h4 = h3 - c3 + h4\n    local c4 = h4 % 2 ^ 80   h5 = h4 - c4 + h5\n    local c5 = h5 % 2 ^ 96   h6 = h5 - c5 + h6\n    local c6 = h6 % 2 ^ 112  h7 = h6 - c6 + h7\n    local c7 = h7 % 2 ^ 130\n\n    -- Reduce carry overflow.\n    h0 = c0 + 5 / 2 ^ 130 * (h7 - c7)\n    c0 = h0 % 2 ^ 16\n    c1 = h0 - c0 + c1\n\n    -- Canonicalize.\n    if      c7 == 0x3ffff * 2 ^ 112\n        and c6 == 0xffff * 2 ^ 96\n        and c5 == 0xffff * 2 ^ 80\n        and c4 == 0xffff * 2 ^ 64\n        and c3 == 0xffff * 2 ^ 48\n        and c2 == 0xffff * 2 ^ 32\n        and c1 == 0xffff * 2 ^ 16\n        and c0 >= 0xfffb\n    then\n        c7, c6, c5, c4, c3, c2, c1, c0 = 0, 0, 0, 0, 0, 0, 0, c0 - 0xfffb\n    end\n\n    -- Decode s.\n    local s0, s1, s2, s3 = u4x4(fmt4x4, key, 17)\n\n    -- Add.\n    local t0 =           s0          + c0 + c1  local u0 = t0 % 2 ^ 32\n    local t1 = t0 - u0 + s1 * 2 ^ 32 + c2 + c3  local u1 = t1 % 2 ^ 64\n    local t2 = t1 - u1 + s2 * 2 ^ 64 + c4 + c5  local u2 = t2 % 2 ^ 96\n    local t3 = t2 - u2 + s3 * 2 ^ 96 + c6 + c7  local u3 = t3 % 2 ^ 128\n\n    -- Encode.\n    return p4x4(fmt4x4, u0, u1 / 2 ^ 32, u2 / 2 ^ 64, u3 / 2 ^ 96)\nend\n\nreturn {\n    mac = mac,\n}\nrandom.lua/     1689962612  0     0     775     1472      `\nlocal expect   = require \"system.expect\".expect\nlocal blake3   = require \"blake3\"\nlocal chacha20 = require \"chacha20\"\nlocal util     = require \"internal_util\"\n\nlocal lassert = util.lassert\n\n-- Extract local context.\nlocal ctx = {\n    \"ccryptolib 2023-04-11T19:43Z random.lua initialization context\",\n    os.time() * 1000,\n    os.time(\"ingame\") * 1000,\n    math.random(0, 2 ^ 24 - 1),\n    math.random(0, 2 ^ 24 - 1),\n    tostring({}),\n    tostring({}),\n}\n\nlocal state = blake3.digest(table.concat(ctx, \"|\"))\nlocal initialized = false\n\n--- Mixes entropy into the generator, and marks it as initialized.\n--- @param seed string The seed data.\nlocal function init(seed)\n    expect(1, seed, \"string\")\n    state = blake3.digestKeyed(state, seed)\n    initialized = true\nend\n\n--- Mixes extra entropy into the generator state.\n--- @param data string The additional entropy to mix.\nlocal function mix(data)\n    expect(1, data, \"string\")\n    state = blake3.digestKeyed(state, data)\nend\n\n--- Generates random bytes.\n--- @param len number The desired output length.\n--- @return string bytes \nlocal function random(len)\n    expect(1, len, \"number\")\n    lassert(initialized, \"attempt to use an uninitialized random generator\", 2)\n    local msg = (\"\\0\"):rep(math.max(len, 0) + 32)\n    local nonce = (\"\\0\"):rep(12)\n    local out = chacha20.crypt(state, nonce, msg, 8, 0)\n    state = out:sub(1, 32)\n    return out:sub(33)\nend\n\nreturn {\n    init = init,\n    mix = mix,\n    random = random,\n}\nsha256.lua/     1686753801  0     0     775     4525      `\n--- The SHA256 cryptographic hash function.\n\nlocal expect  = require \"system.expect\".expect\nlocal lassert = require \"internal_util\".lassert\nlocal packing = require \"internal_packing\"\n\nlocal rol = bit32.lrotate\nlocal shr = bit32.rshift\nlocal bxor = bit32.bxor\nlocal bnot = bit32.bnot\nlocal band = bit32.band\nlocal unpack = unpack or table.unpack\nlocal p1x8, fmt1x8 = packing.compilePack(\">I8\")\nlocal p16x4, fmt16x4 = packing.compilePack(\">I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\")\nlocal u16x4 = packing.compileUnpack(fmt16x4)\nlocal p8x4, fmt8x4 = packing.compilePack(\">I4I4I4I4I4I4I4I4\")\nlocal u8x4 = packing.compileUnpack(fmt8x4)\n\nlocal function primes(n, exp)\n    local out = {}\n    local p = 2\n    for i = 1, n do\n        out[i] = bxor(p ^ exp % 1 * 2 ^ 32)\n        repeat p = p + 1 until 2 ^ p % p == 2\n    end\n    return out\nend\n\nlocal K = primes(64, 1 / 3)\n\nlocal h0 = primes(8, 1 / 2)\n\nlocal function compress(h, w)\n    local h0, h1, h2, h3, h4, h5, h6, h7 = unpack(h)\n    local K = K\n\n    -- Message schedule.\n    for j = 17, 64 do\n        local wf = w[j - 15]\n        local w2 = w[j - 2]\n        local s0 = bxor(rol(wf, 25), rol(wf, 14), shr(wf, 3))\n        local s1 = bxor(rol(w2, 15), rol(w2, 13), shr(w2, 10))\n        w[j] = w[j - 16] + s0 + w[j - 7] + s1\n    end\n\n    -- Block.\n    local a, b, c, d, e, f, g, h = h0, h1, h2, h3, h4, h5, h6, h7\n    for j = 1, 64 do\n        local s1 = bxor(rol(e, 26), rol(e, 21), rol(e, 7))\n        local ch = bxor(band(e, f), band(bnot(e), g))\n        local temp1 = h + s1 + ch + K[j] + w[j]\n        local s0 = bxor(rol(a, 30), rol(a, 19), rol(a, 10))\n        local maj = bxor(band(a, b), band(a, c), band(b, c))\n        local temp2 = s0 + maj\n\n        h = g\n        g = f\n        f = e\n        e = d + temp1\n        d = c\n        c = b\n        b = a\n        a = temp1 + temp2\n    end\n\n    return {\n        (h0 + a) % 2 ^ 32,\n        (h1 + b) % 2 ^ 32,\n        (h2 + c) % 2 ^ 32,\n        (h3 + d) % 2 ^ 32,\n        (h4 + e) % 2 ^ 32,\n        (h5 + f) % 2 ^ 32,\n        (h6 + g) % 2 ^ 32,\n        (h7 + h) % 2 ^ 32,\n    }\nend\n\n--- Hashes data using SHA256.\n--- @param data string Input bytes.\n--- @return string hash The 32-byte hash value.\nlocal function digest(data)\n    expect(1, data, \"string\")\n\n    -- Pad input.\n    local bitlen = #data * 8\n    local padlen = -(#data + 9) % 64\n    data = data .. \"\\x80\" .. (\"\\0\"):rep(padlen) .. p1x8(fmt1x8, bitlen)\n\n    -- Digest.\n    local h = h0\n    for i = 1, #data, 64 do\n        h = compress(h, {u16x4(fmt16x4, data, i)})\n    end\n\n    return p8x4(fmt8x4, unpack(h))\nend\n\n-- Reports once every ~10ms on a standard CCEmuX emulator.\nlocal PBKDF2_CB_ITERATIONS = 50\n\n--- Hashes a password using PBKDF2-HMAC-SHA256.\n--- @param password string The password to hash.\n--- @param salt string The password's salt.\n--- @param iter number The number of iterations to perform.\n--- @param progress fun(iter: number)? An optional function to periodically call with the current iteration number as argument.\n--- @return string dk The 32-byte derived key.\nlocal function pbkdf2(password, salt, iter, progress)\n    expect(1, password, \"string\")\n    expect(2, salt, \"string\")\n    expect(3, iter, \"number\")\n    lassert(iter % 1 == 0, \"iteration number must be an integer\", 2)\n    lassert(iter > 0, \"iteration number must be positive\", 2)\n    expect(4, progress, \"function\", \"nil\")\n\n    -- Pad password.\n    if #password > 64 then password = digest(password) end\n    password = {u16x4(fmt16x4, password .. (\"\\0\"):rep(64), 1)}\n\n    -- Compute password blocks.\n    local ikp = {}\n    local okp = {}\n    for i = 1, 16 do\n        ikp[i] = bxor(password[i], 0x36363636)\n        okp[i] = bxor(password[i], 0x5c5c5c5c)\n    end\n\n    local hikp = compress(h0, ikp)\n    local hokp = compress(h0, okp)\n\n    -- 96-byte padding.\n    local pad96 = {2 ^ 31, 0, 0, 0, 0, 0, 0, 0x300}\n\n    -- First iteration.\n    local pre = p16x4(fmt16x4, unpack(ikp))\n    local hs = {u8x4(fmt8x4, digest(pre .. salt .. \"\\0\\0\\0\\1\"), 1)}\n    for i = 1, 8 do hs[i + 8] = pad96[i] end\n    hs = compress(hokp, hs)\n\n    -- Second iteration onwards.\n    local out = {unpack(hs)}\n    for i = 2, iter do\n        for j = 1, 8 do hs[j + 8] = pad96[j] end\n        hs = compress(hikp, hs)\n        for j = 1, 8 do hs[j + 8] = pad96[j] end\n        hs = compress(hokp, hs)\n        for j = 1, 8 do out[j] = bxor(out[j], hs[j]) end\n        if progress and i % PBKDF2_CB_ITERATIONS == 0 then progress(i) end\n    end\n\n    return p8x4(fmt8x4, unpack(out))\nend\n\nreturn {\n    digest = digest,\n    pbkdf2 = pbkdf2,\n}\n\nutil.lua/       1689962727  0     0     775     1294      `\n--- General utilities for handling byte strings.\n\nlocal expect = require \"system.expect\".expect\nlocal random = require \"random\"\nlocal poly1305 = require \"poly1305\"\n\n--- Returns the hexadecimal version of a string.\n--- @param str string A string.\n--- @return string hex The hexadecimal version of the string.\nlocal function toHex(str)\n    expect(1, str, \"string\")\n    return (\"%02x\"):rep(#str):format(str:byte(1, -1))\nend\n\n--- Converts back a string from hexadecimal.\n--- @param hex string A hexadecimal string.\n--- @return string? str The original string, or nil if the input is invalid.\nlocal function fromHex(hex)\n    expect(1, hex, \"string\")\n    local out = {}\n    local n = 0\n    for c in hex:gmatch(\"%x%x\") do\n        n = n + 1\n        out[n] = tonumber(c, 16)\n    end\n    if 2 * n == #hex then return string.char(table.unpack(out)) end\nend\n\n--- Compares two strings while mitigating secret leakage through timing.\n--- @param a string\n--- @param b string\n--- @return boolean eq Whether a == b.\nlocal function compare(a, b)\n    expect(1, a, \"string\")\n    expect(2, b, \"string\")\n    if #a ~= #b then return false end\n    local kaux = random.random(32)\n    return poly1305.mac(kaux, a) == poly1305.mac(kaux, b)\nend\n\nreturn {\n    toHex = toHex,\n    fromHex = fromHex,\n    compare = compare,\n}\nx25519.lua/     1686753801  0     0     775     1809      `\n--- The X25519 key exchange scheme.\n\nlocal expect = require \"system.expect\".expect\nlocal lassert = require \"internal_util\".lassert\nlocal util = require \"internal_util\"\nlocal c25 = require \"internal_curve25519\"\n\n--- Computes the public key from a secret key.\n--- @param sk string A random 32-byte secret key.\n--- @return string pk The matching public key.\nlocal function publicKey(sk)\n    expect(1, sk, \"string\")\n    assert(#sk == 32, \"secret key length must be 32\")\n    return c25.encode(c25.scale(c25.mulG(util.bits(sk))))\nend\n\n--- Performs the key exchange.\n--- @param sk string A Curve25519 secret key.\n--- @param pk string A public key, usually derived from someone else's secret key.\n--- @return string ss The 32-byte shared secret between both keys.\nlocal function exchange(sk, pk)\n    expect(1, sk, \"string\")\n    lassert(#sk == 32, \"secret key length must be 32\", 2)\n    expect(2, pk, \"string\")\n    lassert(#pk == 32, \"public key length must be 32\", 2) --- @cast pk String32\n    return c25.encode(c25.scale(c25.ladder8(c25.decode(pk), util.bits8(sk))))\nend\n\n--- Performs the key exchange, but decoding the public key as an Edwards25519\n--- point, using the birational map.\n--- @param sk string A Curve25519 secret key\n--- @param pk string An Edwards25519 public key, usually derived from someone else's secret  key.\n--- @return string ss The 32-byte shared secret between both keys.\nlocal function exchangeEd(sk, pk)\n    expect(1, sk, \"string\")\n    lassert(#sk == 32, \"secret key length must be 32\", 2)\n    expect(2, pk, \"string\")\n    lassert(#pk == 32, \"public key length must be 32\", 2) --- @cast pk String32\n    return c25.encode(c25.scale(c25.ladder8(c25.decodeEd(pk), util.bits8(sk))))\nend\n\nreturn {\n    publicKey = publicKey,\n    exchange = exchange,\n    _EXPERIMENTAL_exchangeEd = exchangeEd,\n}\n\nx25519c.lua/    1686753801  0     0     775     8292      `\nlocal expect = require \"system.expect\".expect\nlocal lassert = require \"internal_util\".lassert\nlocal fq     = require \"internal_fq\"\nlocal fp     = require \"internal_fp\"\nlocal c25    = require \"internal_curve25519\"\nlocal ed     = require \"internal_edwards25519\"\nlocal sha512 = require \"internal_sha512\"\nlocal random = require \"random\"\n\n--- Masks an exchange secret key.\n--- @param sk string A random 32-byte Curve25519 secret key.\n--- @return string msk A masked secret key.\nlocal function maskX(sk)\n    expect(1, sk, \"string\")\n    lassert(#sk == 32, \"secret key length must be 32\", 2)\n    local mask = random.random(32)\n    local x = fq.decodeClamped(sk)\n    local r = fq.decodeClamped(mask)\n    local xr = fq.sub(x, r)\n    return fq.encode(xr) .. mask\nend\n\n--- Masks a signature secret key.\n--- @param sk string A random 32-byte Edwards25519 secret key.\n--- @return string msk A masked secret key.\nfunction maskS(sk)\n    expect(1, sk, \"string\")\n    lassert(#sk == 32, \"secret key length must be 32\", 2)\n    return maskX(sha512.digest(sk):sub(1, 32))\nend\n\n--- Rerandomizes the masking on a masked key.\n--- @param msk string A masked secret key.\n--- @return string msk The same secret key, but with another mask.\nlocal function remask(msk)\n    expect(1, msk, \"string\")\n    lassert(#msk == 64, \"masked secret key length must be 64\", 2)\n    local newMask = random.random(32)\n    local xr = fq.decode(msk:sub(1, 32))\n    local r = fq.decodeClamped(msk:sub(33))\n    local s = fq.decodeClamped(newMask)\n    local xs = fq.add(xr, fq.sub(r, s))\n    return fq.encode(xs) .. newMask\nend\n\n--- Returns the ephemeral exchange secret key of this masked key.\n--- This is the second secret key in the \"double key exchange\" in @{exchange},\n--- the first being the key that has been masked. The ephemeral key changes\n--- every time @{remask} is called.\n--- @param msk string A masked secret key.\n--- @return string esk The ephemeral half of the masked secret key.\nlocal function ephemeralSk(msk)\n    expect(1, msk, \"string\")\n    lassert(#msk == 64, \"masked secret key length must be 64\", 2)\n    return msk:sub(33)\nend\n\nlocal function exchangeOnPoint(sk, P)\n    local xr = fq.decode(sk:sub(1, 32))\n    local r = fq.decodeClamped(sk:sub(33))\n    local rP, xrP, dP = c25.prac(P, fq.makeRuleset(fq.eighth(r), fq.eighth(xr)))\n\n    -- Return early if P has small order or if r = xr. (1)\n    if not rP then\n        local out = fp.encode(fp.num(0))\n        return out, out\n    end\n\n    local xP = c25.dadd(dP, rP, xrP)\n\n    -- Extract coordinates for scaling.\n    local Px, Pz = P[1], P[2]\n    local xPx, xPz = xP[1], xP[2]\n    local rPx, rPz = rP[1], rP[2]\n\n    -- Ensure all Z coordinates are squares.\n    Px, Pz = fp.mul(Px, Pz), fp.square(Pz)\n    xPx, xPz = fp.mul(xPx, xPz), fp.square(xPz)\n    rPx, rPz = fp.mul(rPx, rPz), fp.square(rPz)\n\n    -- We're splitting the secret x into (x - r (mod q), r). The multiplication\n    -- adds them back together, but this only works if P's order is q, which is\n    -- not the case on the twist.\n    -- As a result, we need to check if P is on the twist and return 0 so as to\n    -- not leak part of x. We do this by checking the curve equation against P.\n    -- The projective equation for curve25519 is Y\194\178Z = X(X\194\178 + AXZ + Z\194\178). Since Z\n    -- is a square, checking validity means checking the right-hand side to be a\n    -- square.\n    local Px2 = fp.square(Px)\n    local Pz2 = fp.square(Pz)\n    local Pxz = fp.mul(Px, Pz)\n    local APxz = fp.kmul(Pxz, 486662)\n    local rhs = fp.mul(Px, fp.add(Px2, fp.carry(fp.add(APxz, Pz2))))\n\n    -- Find the square root of 1 / (rhs * xPz * rPz).\n    -- Neither rPz, xPz, nor rhs are 0:\n    -- - If rhs was 0, then P would be low order, which would return at (1).\n    -- - Since P isn't low order, clamping prevents the ladder from returning O.\n    -- Since we've just squared both xPz and rPz, the root will exist iff rhs is\n    -- a square. This checks the curve equation, so we're done.\n    local root = fp.sqrtDiv(fp.num(1), fp.mul(fp.mul(xPz, rPz), rhs))\n    if not root then\n        local out = fp.encode(fp.num(0))\n        return out, out\n    end\n\n    -- Get the inverses of both Z values.\n    local xPzrPzInv = fp.mul(fp.square(root), rhs)\n    local xPzInv = fp.mul(xPzrPzInv, rPz)\n    local rPzInv = fp.mul(xPzrPzInv, xPz)\n\n    -- Finish scaling and encode the output.\n    return fp.encode(fp.mul(xPx, xPzInv)), fp.encode(fp.mul(rPx, rPzInv))\nend\n\n--- Returns the X25519 public key of this masked key.\n--- @param msk string A masked secret key.\nlocal function publicKeyX(msk)\n    expect(1, msk, \"string\")\n    lassert(#msk == 64, \"masked secret key length must be 64\", 2)\n    return (exchangeOnPoint(msk, c25.G))\nend\n\n--- Returns the Ed25519 public key of this masked key.\n--- @param msk string A masked secret key.\n--- @return string pk The Ed25519 public key matching this masked key.\nlocal function publicKeyS(msk)\n    expect(1, msk, \"string\")\n    lassert(#msk == 64, \"masked secret key length must be 64\", 2)\n    local xr = fq.decode(msk:sub(1, 32))\n    local r = fq.decodeClamped(msk:sub(33))\n    local y = ed.add(ed.mulG(fq.bits(xr)), ed.niels(ed.mulG(fq.bits(r))))\n    return ed.encode(ed.scale(y))\nend\n\n--- Performs a double key exchange.\n---\n--- Returns 0 if the input public key has small order or if it isn't in the base\n--- curve. This is different from standard X25519, which performs the exchange\n--- even on the twist.\n---\n--- May incorrectly return 0 with negligible chance if the mask happens to match\n--- the masked key. I haven't checked if clamping prevents that from happening.\n---\n--- @param sk string A masked secret key.\n--- @param pk string An X25519 public key.\n--- @return string sss The shared secret between the public key and the static half of the masked key.\n--- @return string sse The shared secret betwen the public key and the ephemeral half of the masked key.\nlocal function exchangeX(sk, pk)\n    expect(1, sk, \"string\")\n    lassert(#sk == 64, \"masked secret key length must be 64\", 2)\n    expect(2, pk, \"string\")\n    lassert(#pk == 32, \"public key length must be 32\", 2) --- @cast pk String32\n    return exchangeOnPoint(sk, c25.decode(pk))\nend\n\n--- Performs an exchange against an Ed25519 key.\n---\n--- This is done by converting the key into X25519 before passing it to the\n--- regular exchange. Using this function on the result of @{signaturePk} leads\n--- to the same value as using @{exchange} on the result of @{exchangePk}.\n---\n--- @param sk string A masked secret key.\n--- @param pk string An Ed25519 public key.\n--- @return string sss The shared secret between the public key and the static half of the masked key.\n--- @return string sse The shared secret betwen the public key and the ephemeral half of the masked key.\nlocal function exchangeS(sk, pk)\n    expect(1, sk, \"string\")\n    lassert(#sk == 64, \"masked secret key length must be 64\", 2)\n    expect(2, pk, \"string\")\n    lassert(#pk == 32, \"public key length must be 32\", 2) --- @cast pk String32\n    return exchangeOnPoint(sk, c25.decodeEd(pk))\nend\n\n--- Signs a message using Ed25519.\n--- @param sk string A masked secret key.\n--- @param pk string The Ed25519 public key matching the secret key.\n--- @param msg string A message to sign.\n--- @return string sig The signature on the message.\nlocal function sign(sk, pk, msg)\n    expect(1, sk, \"string\")\n    lassert(#sk == 64, \"masked secret key length must be 64\", 2)\n    expect(2, pk, \"string\")\n    lassert(#pk == 32, \"public key length must be 32\", 2)\n    expect(3, msg, \"string\")\n\n    -- Secret key.\n    local xr = fq.decode(sk:sub(1, 32))\n    local r = fq.decodeClamped(sk:sub(33))\n\n    -- Commitment.\n    local k = fq.decodeWide(random.random(64))\n    local rStr = ed.encode(ed.mulG(fq.bits(k)))\n\n    -- Challenge.\n    local e = fq.decodeWide(sha512.digest(rStr .. pk .. msg))\n\n    -- Response.\n    local s = fq.add(fq.add(k, fq.mul(xr, e)), fq.mul(r, e))\n    local sStr = fq.encode(s)\n\n    return rStr .. sStr\nend\n\nreturn {\n    _EXPERIMENTAL_maskX = maskX,\n    _EXPERIMENTAL_maskS = maskS,\n    _EXPERIMENTAL_remask = remask,\n    _EXPERIMENTAL_publicKeyX = publicKeyX,\n    _EXPERIMENTAL_ephemeralSk = ephemeralSk,\n    _EXPERIMENTAL_publicKeyS = publicKeyS,\n    _EXPERIMENTAL_exchangeX = exchangeX,\n    _EXPERIMENTAL_exchangeS = exchangeS,\n    _EXPERIMENTAL_sign = sign,\n}\n/0              1686753801  0     0     775     9756      `\n--- Point arithmetic on the Curve25519 Montgomery curve.\n\nlocal fp = require \"internal_fp\"\nlocal ed = require \"internal_edwards25519\"\nlocal random = require \"random\"\n\n--- @class MtPoint A point class on Curve25519, in XZ coordinates.\n--- @field [1] number[] The X coordinate.\n--- @field [2] number[] The Z coordinate.\n\n--- Doubles a point.\n--- @param P1 MtPoint The point to double.\n--- @return MtPoint P2 P1 + P1.\nlocal function double(P1)\n    local x1, z1 = P1[1], P1[2]\n    local a = fp.add(x1, z1)\n    local aa = fp.square(a)\n    local b = fp.sub(x1, z1)\n    local bb = fp.square(b)\n    local c = fp.sub(aa, bb)\n    local x3 = fp.mul(aa, bb)\n    local z3 = fp.mul(c, fp.add(bb, fp.kmul(c, 121666)))\n    return {x3, z3}\nend\n\n--- Computes differential addition on two points.\n--- @param DP MtPoint P1 - P2.\n--- @param P1 MtPoint The first point to add.\n--- @param P2 MtPoint The second point to add.\n--- @return MtPoint P3 P1 + P2.\nlocal function dadd(DP, P1, P2)\n    local dx, dz = DP[1], DP[2]\n    local x1, z1 = P1[1], P1[2]\n    local x2, z2 = P2[1], P2[2]\n    local a = fp.add(x1, z1)\n    local b = fp.sub(x1, z1)\n    local c = fp.add(x2, z2)\n    local d = fp.sub(x2, z2)\n    local da = fp.mul(d, a)\n    local cb = fp.mul(c, b)\n    local x3 = fp.mul(dz, fp.square(fp.add(da, cb)))\n    local z3 = fp.mul(dx, fp.square(fp.sub(da, cb)))\n    return {x3, z3}\nend\n\n--- Performs a step on the Montgomery ladder.\n--- @param DP MtPoint P1 - P2.\n--- @param P1 MtPoint The first point.\n--- @param P2 MtPoint The second point.\n--- @return MtPoint P3 2A\n--- @return MtPoint P4 A + B\nlocal function step(DP, P1, P2)\n    local dx, dz = DP[1], DP[2]\n    local x1, z1 = P1[1], P1[2]\n    local x2, z2 = P2[1], P2[2]\n    local a = fp.add(x1, z1)\n    local aa = fp.square(a)\n    local b = fp.sub(x1, z1)\n    local bb = fp.square(b)\n    local e = fp.sub(aa, bb)\n    local c = fp.add(x2, z2)\n    local d = fp.sub(x2, z2)\n    local da = fp.mul(d, a)\n    local cb = fp.mul(c, b)\n    local x4 = fp.mul(dz, fp.square(fp.add(da, cb)))\n    local z4 = fp.mul(dx, fp.square(fp.sub(da, cb)))\n    local x3 = fp.mul(aa, bb)\n    local z3 = fp.mul(e, fp.add(bb, fp.kmul(e, 121666)))\n    return {x3, z3}, {x4, z4}\nend\n\nlocal function ladder(DP, bits)\n    local P = {fp.num(1), fp.num(0)}\n    local Q = DP\n\n    for i = #bits, 1, -1 do\n        if bits[i] == 0 then\n            P, Q = step(DP, P, Q)\n        else\n            Q, P = step(DP, Q, P)\n        end\n    end\n\n    return P\nend\n\n--- Performs a scalar multiplication operation with multiplication by 8.\n--- @param P MtPoint The base point.\n--- @param bits number[] The scalar multiplier, in little-endian bits.\n--- @return MtPoint product The product, multiplied by 8.\nlocal function ladder8(P, bits)\n    -- Randomize.\n    local rf = fp.decode(random.random(32) --[[@as String32, length is given]])\n    P = {fp.mul(P[1], rf), fp.mul(P[2], rf)}\n\n    -- Multiply.\n    return double(double(double(ladder(P, bits))))\nend\n\n--- Scales a point's coordinates.\n--- @param P MtPoint The input point.\n--- @return MtPoint Q The same point P, but with Z = 1.\nlocal function scale(P)\n    return {fp.mul(P[1], fp.invert(P[2])), fp.num(1)}\nend\n\n--- Encodes a scaled point.\n--- @param P MtPoint The scaled point to encode.\n--- @return string encoded P, encoded into a 32-byte string.\nlocal function encode(P)\n    return fp.encode(P[1])\nend\n\n--- Decodes a point.\n--- @param str String32 A 32-byte encoded point.\n--- @return MtPoint pt The decoded point.\nlocal function decode(str)\n    return {fp.decode(str), fp.num(1)}\nend\n\n--- Decodes an Edwards25519 encoded point into Curve25519, ignoring the sign.\n---\n--- There is a single exception: The identity point (0, 1), which gets mapped\n--- into the 2-torsion point (0, 0), which isn't the identity of Curve25519.\n---\n--- @param str String32 A 32-byte encoded Edwards25519 point.\n--- @return MtPoint pt The decoded point, mapped into Curve25519.\nlocal function decodeEd(str)\n    local y = fp.decode(str)\n    local n = fp.carry(fp.add(fp.num(1), y))\n    local d = fp.carry(fp.sub(fp.num(1), y))\n    if fp.eqz(d) then\n        return {fp.num(0), fp.num(1)}\n    else\n        return {n, d}\n    end\nend\n\n--- Performs a scalar multiplication by the base point G.\n--- @param bits number[] The scalar multiplier, in little-endian bits.\n--- @return MtPoint product The product point.\nlocal function mulG(bits)\n    -- Multiply by G on Edwards25519.\n    local P = ed.mulG(bits)\n\n    -- Use the birational map to get the point on Curve25519.\n    -- Never fails since G is in the large group, and the exponent is clamped.\n    local Py, Pz = P[2], P[3]\n    local Rx = fp.carry(fp.add(Py, Pz))\n    local Rz = fp.carry(fp.sub(Pz, Py))\n\n    return {Rx, Rz}\nend\n\n--- Computes a twofold product from a ruleset.\n---\n--- Returns nil if any of the results would be equal to the identity.\n---\n--- @param P MtPoint The base point.\n--- @param ruleset __TYPE_TODO The ruleset generated by scalars m, n.\n--- @return MtPoint? A [8m]P.\n--- @return MtPoint? B [8n]P.\n--- @return MtPoint? C [8m]P - [8n]P.\nlocal function prac(P, ruleset)\n    -- Randomize.\n    local rf = fp.decode(random.random(32) --[[@as String32, length is given]])\n    local A = {fp.mul(P[1], rf), fp.mul(P[2], rf)}\n\n    -- Start the base at [8]P.\n    local A = double(double(double(A)))\n\n    -- Throw away small order points.\n    if fp.eqz(A[2]) then return end\n\n    -- Now e = d = gcd(m, n).\n    -- Update A from [8]P to [8 * gcd(m, n)]P.\n    A = ladder(A, ruleset[1])\n\n    -- Reject rulesets where m = n.\n    local rules = ruleset[2]\n    if #rules == 0 then return end\n\n    -- Evaluate the first rule.\n    -- Since e = d, this means A - B = C = O. Differential addition fails when\n    -- C = O, so we need to treat this case specially.\n    -- Note that rules 0 and 1 never happen last, since the algorithm would stop\n    -- one step earlier if they did:\n    -- - If after rule 0 we had e = d, then (d, e) \226\134\146 (e, d) would also mean that\n    --   e = d, so it stops one step earlier.\n    -- - If after rule 1 we had e = d, then (d, e) \226\134\146 ((2d - e)/3, (2e - d)/3)\n    --   would mean that (2d - e)/3 = (2e - d)/3, thus 2d - e = 2e - d, thus\n    --   3d = 3e, thus d = e, so it stops one step earlier.\n    local B, C\n    local rule = rules[#rules]\n    if rule == 2 then\n        -- (A, B, C) \226\134\144 (2A + B, B, 2A) = (3A, A, 2A)\n        local A2 = double(A)\n        A, B, C = dadd(A, A2, A), A, A2\n    elseif rule == 3 or rule == 5 then\n        -- (A, B, C) \226\134\144 (A + B, B, A) = (2A, A, A)\n        -- or (A, B, C) \226\134\144 (2A, B, 2A - B) = (2A, A, A)\n        A, B, C = double(A), A, A\n    elseif rule == 6 then\n        -- (A, B, C) \226\134\144 (3A + 3B, B, 3A + 2B) = (6A, A, 5A)\n        local A2 = double(A)\n        local A3 = dadd(A, A2, A)\n        A, B, C = double(A3), A, dadd(A, A3, A2)\n    elseif rule == 7 then\n        -- (A, B, C) \226\134\144 (3A + 2B, B, 3A + B) = (5A, A, 4A)\n        local A2 = double(A)\n        local A3 = dadd(A, A2, A)\n        local A4 = double(A2)\n        A, B, C = dadd(A3, A4, A), A, A4\n    elseif rule == 8 then\n        -- (A, B, C) \226\134\144 (3A + B, B, 3A) = (4A, A, 3A)\n        local A2 = double(A)\n        local A3 = dadd(A, A2, A)\n        A, B, C = double(A2), A, A3\n    else\n        -- (A, B, C) \226\134\144 (A, 2B, A - 2B) = (A, 2A, A)\n        A, B, C = A, double(A), A\n    end\n\n    -- Evaluate the other rules.\n    -- Let's assume addition is undefined here, this happens when A - B = O.\n    -- Since A = [d]P and B = [e]P, A = B happens when:\n    -- (1) P is on the large order base group and d \226\137\161 e (mod q).\n    -- (2) P is on the large order twist group and d \226\137\161 e (mod q').\n    -- (3) P is on a small order group.\n    -- Case (3) never happens since we throw small order points away above.\n    -- Since 0 \226\137\164 {d, e} < q < q', a modular equivalence here means an integer\n    -- equivalence. Therefore d = e.\n    -- However, the ruleset stops when d = e, therefore the algorithm must have\n    -- stopped earlier than when it did. Contradiction.\n    -- Therefore, addition is always defined.\n    -- Furthermore, the PRAC invariants mean that this product is the same as\n    -- if the points were multiplied separately.\n    for i = #rules - 1, 1, -1 do\n        local rule = rules[i]\n        if rule == 0 then\n            -- (A, B, C) \226\134\144 (B, A, B - A)\n            A, B = B, A\n        elseif rule == 1 then\n            -- (A, B, C) \226\134\144 (2A + B, A + 2B, A - B)\n            local AB = dadd(C, A, B)\n            A, B = dadd(B, AB, A), dadd(A, AB, B)\n        elseif rule == 2 then\n            -- (A, B, C) \226\134\144 (2A + B, B, 2A)\n            A, C = dadd(B, dadd(C, A, B), A), double(A)\n        elseif rule == 3 then\n            -- (A, B, C) \226\134\144 (A + B, B, A)\n            A, C = dadd(C, A, B), A\n        elseif rule == 5 then\n            -- (A, B, C) \226\134\144 (2A, B, 2A - B)\n            A, C = double(A), dadd(B, A, C)\n        elseif rule == 6 then\n            -- (A, B, C) \226\134\144 (3A + 3B, B, 3A + 2B)\n            local AB = dadd(C, A, B)\n            local AABB = double(AB)\n            A, C = dadd(AB, AABB, AB), dadd(dadd(A, AB, B), AABB, A)\n        elseif rule == 7 then\n            -- (A, B, C) \226\134\144 (3A + 2B, B, 3A + B)\n            local AB = dadd(C, A, B)\n            local AAB = dadd(B, AB, A)\n            A, C = dadd(A, AAB, AB), dadd(AB, AAB, A)\n        elseif rule == 8 then\n            -- (A, B, C) \226\134\144 (3A + B, B, 3A)\n            local AA = double(A)\n            A, C = dadd(C, AA, dadd(C, A, B)), dadd(A, AA, A)\n        else\n            -- (A, B, C) \226\134\144 (A, 2B, A - 2B)\n            B, C = double(B), dadd(A, C, B)\n        end\n    end\n\n    return A, B, C\nend\n\nreturn {\n    G = {fp.num(9), fp.num(1)},\n    dadd = dadd,\n    scale = scale,\n    encode = encode,\n    decode = decode,\n    decodeEd = decodeEd,\n    ladder8 = ladder8,\n    mulG = mulG,\n    prac = prac,\n}\n/24             1686753801  0     0     775     8834      `\n--- Point arithmetic on the Edwards25519 Edwards curve.\n\nlocal fp = require \"internal_fp\"\n\nlocal unpack = unpack or table.unpack\n\n--- @class EdPoint A point on Edwards25519, in extended coordinates.\n--- @field [1] number[] The X coordinate.\n--- @field [2] number[] The Y coordinate.\n--- @field [3] number[] The Z coordinate.\n--- @field [4] number[] The T coordinate.\n\n--- @class NsPoint A point on Edwards25519, in Niels' coordinates.\n--- @field [1] number[] Preprocessed Y + X.\n--- @field [2] number[] Preprocessed Y - X.\n--- @field [3] number[] Preprocessed 2Z.\n--- @field [4] number[] Preprocessed 2DT.\n\nlocal D = fp.mul(fp.num(-121665), fp.invert(fp.num(121666)))\nlocal K = fp.kmul(D, 2)\n\n--- @type EdPoint\nlocal O = {fp.num(0), fp.num(1), fp.num(1), fp.num(0)}\nlocal G = nil\n\n--- Doubles a point.\n--- @param P1 EdPoint The point to double.\n--- @return EdPoint P2 P1 + P1.\nlocal function double(P1)\n    -- Unsoundness: fp.sub(g, e), and fp.sub(d, i) break fp.sub's contract since\n    -- it doesn't accept an fp2. Although not ideal, in practice this doesn't\n    -- matter since fp.carry handles the larger sum.\n    local P1x, P1y, P1z = unpack(P1)\n    local a = fp.square(P1x)\n    local b = fp.square(P1y)\n    local c = fp.square(P1z)\n    local d = fp.add(c, c)\n    local e = fp.add(a, b)\n    local f = fp.add(P1x, P1y)\n    local g = fp.square(f)\n    local h = fp.carry(fp.sub(g, e))\n    local i = fp.sub(b, a)\n    local j = fp.carry(fp.sub(d, i))\n    local P3x = fp.mul(h, j)\n    local P3y = fp.mul(i, e)\n    local P3z = fp.mul(j, i)\n    local P3t = fp.mul(h, e)\n    return {P3x, P3y, P3z, P3t}\nend\n\n--- Adds two points.\n--- @param P1 EdPoint The first summand point.\n--- @param N2 NsPoint The second summand point.\n--- @return EdPoint P3 P1 + P2, where N2 = niels(P2).\nlocal function add(P1, N2)\n    local P1x, P1y, P1z, P1t = unpack(P1)\n    local N1p, N1m, N1z, N1t = unpack(N2)\n    local a = fp.sub(P1y, P1x)\n    local b = fp.mul(a, N1m)\n    local c = fp.add(P1y, P1x)\n    local d = fp.mul(c, N1p)\n    local e = fp.mul(P1t, N1t)\n    local f = fp.mul(P1z, N1z)\n    local g = fp.sub(d, b)\n    local h = fp.sub(f, e)\n    local i = fp.add(f, e)\n    local j = fp.add(d, b)\n    local P3x = fp.mul(g, h)\n    local P3y = fp.mul(i, j)\n    local P3z = fp.mul(h, i)\n    local P3t = fp.mul(g, j)\n    return {P3x, P3y, P3z, P3t}\nend\n\n--- Subtracts one point from another.\n--- @param P1 EdPoint The first summand point.\n--- @param N2 NsPoint The second summand point.\n--- @return EdPoint P3 P1 - P2, where N2 = niels(P2).\nlocal function sub(P1, N2)\n    local P1x, P1y, P1z, P1t = unpack(P1)\n    local N1p, N1m, N1z, N1t = unpack(N2)\n    local a = fp.sub(P1y, P1x)\n    local b = fp.mul(a, N1p)\n    local c = fp.add(P1y, P1x)\n    local d = fp.mul(c, N1m)\n    local e = fp.mul(P1t, N1t)\n    local f = fp.mul(P1z, N1z)\n    local g = fp.sub(d, b)\n    local h = fp.add(f, e)\n    local i = fp.sub(f, e)\n    local j = fp.add(d, b)\n    local P3x = fp.mul(g, h)\n    local P3y = fp.mul(i, j)\n    local P3z = fp.mul(h, i)\n    local P3t = fp.mul(g, j)\n    return {P3x, P3y, P3z, P3t}\nend\n\n--- Computes the Niels representation of a point.\n--- @param P1 EdPoint The input point.\n--- @return NsPoint N1 Niels' precomputation applied to P1.\nlocal function niels(P1)\n    local P1x, P1y, P1z, P1t = unpack(P1)\n    local N3p = fp.add(P1y, P1x)\n    local N3m = fp.sub(P1y, P1x)\n    local N3z = fp.add(P1z, P1z)\n    local N3t = fp.mul(P1t, K)\n    return {N3p, N3m, N3z, N3t}\nend\n\n--- Scales a point.\n--- @param P1 EdPoint The input point.\n--- @return EdPoint P2 The same point as P1, but with Z = 1.\nlocal function scale(P1)\n    local P1x, P1y, P1z = unpack(P1)\n    local zInv = fp.invert(P1z)\n    local P3x = fp.mul(P1x, zInv)\n    local P3y = fp.mul(P1y, zInv)\n    local P3z = fp.num(1)\n    local P3t = fp.mul(P3x, P3y)\n    return {P3x, P3y, P3z, P3t}\nend\n\n--- Encodes a scaled point.\n--- @param P1 EdPoint The scaled point to encode.\n--- @return string out P1 encoded as a 32-byte string.\nlocal function encode(P1)\n    P1 = scale(P1)\n    local P1x, P1y = unpack(P1)\n    local y = fp.encode(P1y)\n    local xBit = fp.canonicalize(P1x)[1] % 2\n    return y:sub(1, -2) .. string.char(y:byte(-1) + xBit * 128)\nend\n\n--- Decodes a point.\n--- @param str String32 A 32-byte encoded point.\n--- @return EdPoint? P1 The decoded point, or nil if it isn't on the curve.\nlocal function decode(str)\n    local P3y = fp.decode(str)\n    local a = fp.square(P3y)\n    local b = fp.sub(a, fp.num(1))\n    local c = fp.mul(a, D)\n    local d = fp.add(c, fp.num(1))\n    local P3x = fp.sqrtDiv(b, d)\n    if not P3x then return nil end\n    local xBit = fp.canonicalize(P3x)[1] % 2\n    if xBit ~= bit32.extract(str:byte(-1), 7) then\n        P3x = fp.carry(fp.neg(P3x))\n    end\n    local P3z = fp.num(1)\n    local P3t = fp.mul(P3x, P3y)\n    return {P3x, P3y, P3z, P3t}\nend\n\nG = decode(\"Xfffffffffffffffffffffffffffffff\") --[[@as EdPoint, G is valid]]\n\n--- Transforms little-endian bits into a signed radix-2^w form.\n--- @param bits number[]\n--- @param w number Log2 of the radix, must be at least 1.\n--- @return number[]\nlocal function signedRadixW(bits, w)\n    -- TODO Find a more elegant way of doing this.\n    local wPow = 2 ^ w\n    local wPowh = wPow / 2\n    local out = {}\n    local acc = 0\n    local mul = 1\n    for i = 1, #bits do\n        acc = acc + bits[i] * mul\n        mul = mul * 2\n        while i == #bits and acc > 0 or mul > wPow do\n            local rem = acc % wPow\n            if rem >= wPowh then rem = rem - wPow end\n            acc = (acc - rem) / wPow\n            mul = mul / wPow\n            out[#out + 1] = rem\n        end\n    end\n    return out\nend\n\n--- Computes a multiplication table for radix-2^w form multiplication.\n--- @param P EdPoint The base point.\n--- @param w number Log2 of the radix, must be at least 1.\n--- @return NsPoint[][]\nlocal function radixWTable(P, w)\n    local out = {}\n    for i = 1, math.ceil(256 / w) do\n        local row = {niels(P)}\n        for j = 2, 2 ^ w / 2 do\n            P = add(P, row[1])\n            row[j] = niels(P)\n        end\n        out[i] = row\n        P = double(P)\n    end\n    return out\nend\n\n--- The radix logarithm of the precomputed table for G.\nlocal G_W = 5\n\n--- The precomputed multiplication table for G.\nlocal G_TABLE = radixWTable(G, G_W)\n\n--- Transforms little-endian bits into a signed radix-2^w non-adjacent form.\n---\n--- The returned array contains a 0 whenever a single doubling is needed, or an\n--- odd integer when an addition with a multiple of the base is needed.\n---\n--- @param bits number[]\n--- @param w number Log2 of the radix, must be at least 1.\n--- @return number[]\nlocal function wNaf(bits, w)\n    -- TODO Find a more elegant way of doing this.\n    local wPow = 2 ^ w\n    local wPowh = wPow / 2\n    local out = {}\n    local acc = 0\n    local mul = 1\n    for i = 1, #bits do\n        acc = acc + bits[i] * mul\n        mul = mul * 2\n        while i == #bits and acc > 0 or mul > wPow do\n            if acc % 2 == 0 then\n                acc = acc / 2\n                mul = mul / 2\n                out[#out + 1] = 0\n            else\n                local rem = acc % wPow\n                if rem >= wPowh then rem = rem - wPow end\n                acc = acc - rem\n                out[#out + 1] = rem\n            end\n        end\n    end\n    while out[#out] == 0 do out[#out] = nil end\n    return out\nend\n\n--- Computes a multiplication table for wNAF form multiplication.\n--- @param P EdPoint The base point.\n--- @param w number Log2 of the radix, must be at least 1.\n--- @return NsPoint[]\nlocal function WNAFTable(P, w)\n    local dP = double(P)\n    local out = {niels(P)}\n    for i = 3, 2 ^ w, 2 do\n        out[i] = niels(add(dP, out[i - 2]))\n    end\n    return out\nend\n\n--- Performs a scalar multiplication by the base point G.\n--- @param bits number[] The scalar multiplicand little-endian bits.\n--- @return EdPoint\nlocal function mulG(bits)\n    local sw = signedRadixW(bits, G_W)\n    local R = O\n    for i = 1, #sw do\n        local b = sw[i]\n        if b > 0 then\n            R = add(R, G_TABLE[i][b])\n        elseif b < 0 then\n            R = sub(R, G_TABLE[i][-b])\n        end\n    end\n    return R\nend\n\n--- Performs a scalar multiplication operation.\n--- @param P EdPoint The base point.\n--- @param bits number[] The scalar multiplicand little-endian bits.\n--- @return EdPoint\nlocal function mul(P, bits)\n    local naf = wNaf(bits, 5)\n    local tbl = WNAFTable(P, 5)\n    local R = O\n    for i = #naf, 1, -1 do\n        local b = naf[i]\n        if b == 0 then\n            R = double(R)\n        elseif b > 0 then\n            R = add(R, tbl[b])\n        else\n            R = sub(R, tbl[-b])\n        end\n    end\n    return R\nend\n\nreturn {\n    double = double,\n    add = add,\n    sub = sub,\n    niels = niels,\n    scale = scale,\n    encode = encode,\n    decode = decode,\n    mulG = mulG,\n    mul = mul,\n}\ninternal_fp.lua/1686753801  0     0     775     20742     `\n--- Arithmetic on Curve25519's base field.\n\nlocal packing = require \"internal_packing\"\n\nlocal unpack = unpack or table.unpack\nlocal ufp, fmtfp = packing.compileUnpack(\"<I3I3I2I3I3I2I3I3I2I3I3I2\")\n\n--- @class Fq An element of the field of integers modulo 2\194\178\226\129\181\226\129\181 - 19.\n\n--- @class FpR2: Fq An Fp element with limbs inside twice the standard range.\n\n--- @class FpR1: FpR2 An Fp element with limbs inside the standard range. See\n--- the Curve25519 polynomial representation for more info around this.\n\n--- The modular square root of -1.\n--- @type FpR1\nlocal I = {\n    0958640 * 2 ^ 0,\n    0826664 * 2 ^ 22,\n    1613251 * 2 ^ 43,\n    1041528 * 2 ^ 64,\n    0013673 * 2 ^ 85,\n    0387171 * 2 ^ 107,\n    1824679 * 2 ^ 128,\n    0313839 * 2 ^ 149,\n    0709440 * 2 ^ 170,\n    0122635 * 2 ^ 192,\n    0262782 * 2 ^ 213,\n    0712905 * 2 ^ 234,\n}\n\n--- Converts a Lua number to an element.\n--- @param n number A number n in [0..2\194\178\194\178).\n--- @return FpR1 out The number as an element.\nlocal function num(n)\n    return {n, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\nend\n\n--- Negates an element.\n--- @param a FpR1\n--- @return FpR1 out -a.\nlocal function neg(a)\n    local a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10, a11 = unpack(a)\n    return {\n        -a00,\n        -a01,\n        -a02,\n        -a03,\n        -a04,\n        -a05,\n        -a06,\n        -a07,\n        -a08,\n        -a09,\n        -a10,\n        -a11,\n    }\nend\n\n--- Adds two elements.\n--- @param a FpR1\n--- @param b FpR1\n--- @return FpR2 out a + b.\nlocal function add(a, b)\n    local a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10, a11 = unpack(a)\n    local b00, b01, b02, b03, b04, b05, b06, b07, b08, b09, b10, b11 = unpack(b)\n    return {\n        a00 + b00,\n        a01 + b01,\n        a02 + b02,\n        a03 + b03,\n        a04 + b04,\n        a05 + b05,\n        a06 + b06,\n        a07 + b07,\n        a08 + b08,\n        a09 + b09,\n        a10 + b10,\n        a11 + b11,\n    }\nend\n\n--- Subtracts an element from another.\n--- @param a FpR1\n--- @param b FpR1\n--- @return FpR2 out a - b.\nlocal function sub(a, b)\n    local a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10, a11 = unpack(a)\n    local b00, b01, b02, b03, b04, b05, b06, b07, b08, b09, b10, b11 = unpack(b)\n    return {\n        a00 - b00,\n        a01 - b01,\n        a02 - b02,\n        a03 - b03,\n        a04 - b04,\n        a05 - b05,\n        a06 - b06,\n        a07 - b07,\n        a08 - b08,\n        a09 - b09,\n        a10 - b10,\n        a11 - b11,\n    }\nend\n\n--- Carries an element. Also performs a small reduction modulo p.\n--- @param a FpR2 The element to carry.\n--- @return FpR1 out The same element as a but in a tighter range.\nlocal function carry(a)\n    local a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10, a11 = unpack(a)\n    local c00, c01, c02, c03, c04, c05, c06, c07, c08, c09, c10, c11\n\n    c11 = a11 + 3 * 2 ^ 306 - 3 * 2 ^ 306  a00 = a00 + 19 / 2 ^ 255 * c11\n\n    c00 = a00 + 3 * 2 ^ 73  - 3 * 2 ^ 73   a01 = a01 + c00\n    c01 = a01 + 3 * 2 ^ 94  - 3 * 2 ^ 94   a02 = a02 + c01\n    c02 = a02 + 3 * 2 ^ 115 - 3 * 2 ^ 115  a03 = a03 + c02\n    c03 = a03 + 3 * 2 ^ 136 - 3 * 2 ^ 136  a04 = a04 + c03\n    c04 = a04 + 3 * 2 ^ 158 - 3 * 2 ^ 158  a05 = a05 + c04\n    c05 = a05 + 3 * 2 ^ 179 - 3 * 2 ^ 179  a06 = a06 + c05\n    c06 = a06 + 3 * 2 ^ 200 - 3 * 2 ^ 200  a07 = a07 + c06\n    c07 = a07 + 3 * 2 ^ 221 - 3 * 2 ^ 221  a08 = a08 + c07\n    c08 = a08 + 3 * 2 ^ 243 - 3 * 2 ^ 243  a09 = a09 + c08\n    c09 = a09 + 3 * 2 ^ 264 - 3 * 2 ^ 264  a10 = a10 + c09\n    c10 = a10 + 3 * 2 ^ 285 - 3 * 2 ^ 285  a11 = a11 - c11 + c10\n\n    c11 = a11 + 3 * 2 ^ 306 - 3 * 2 ^ 306\n\n    return {\n        a00 - c00 + 19 / 2 ^ 255 * c11,\n        a01 - c01,\n        a02 - c02,\n        a03 - c03,\n        a04 - c04,\n        a05 - c05,\n        a06 - c06,\n        a07 - c07,\n        a08 - c08,\n        a09 - c09,\n        a10 - c10,\n        a11 - c11,\n    }\nend\n\n--- Returns the canoncal representative of a modp number.\n---\n--- Some elements can be represented by two different arrays of floats. This\n--- returns the canonical element of the represented equivalence class. We\n--- define an element as canonical if it's the smallest nonnegative number in\n--- its class.\n---\n--- @param a FpR2\n--- @return FpR1 out A canonical element a' \226\137\161 a (mod p).\nlocal function canonicalize(a)\n    local a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10, a11 = unpack(a)\n    local c00, c01, c02, c03, c04, c05, c06, c07, c08, c09, c10, c11\n\n    -- Perform an euclidean reduction.\n    -- TODO Range check.\n    c00 = a00 % 2 ^ 22   a01 = a00 - c00 + a01\n    c01 = a01 % 2 ^ 43   a02 = a01 - c01 + a02\n    c02 = a02 % 2 ^ 64   a03 = a02 - c02 + a03\n    c03 = a03 % 2 ^ 85   a04 = a03 - c03 + a04\n    c04 = a04 % 2 ^ 107  a05 = a04 - c04 + a05\n    c05 = a05 % 2 ^ 128  a06 = a05 - c05 + a06\n    c06 = a06 % 2 ^ 149  a07 = a06 - c06 + a07\n    c07 = a07 % 2 ^ 170  a08 = a07 - c07 + a08\n    c08 = a08 % 2 ^ 192  a09 = a08 - c08 + a09\n    c09 = a09 % 2 ^ 213  a10 = a09 - c09 + a10\n    c10 = a10 % 2 ^ 234  a11 = a10 - c10 + a11\n    c11 = a11 % 2 ^ 255  c00 = c00 + 19 / 2 ^ 255 * (a11 - c11)\n\n    -- Canonicalize.\n    if      c11 / 2 ^ 234 == 2 ^ 21 - 1\n        and c10 / 2 ^ 213 == 2 ^ 21 - 1\n        and c09 / 2 ^ 192 == 2 ^ 21 - 1\n        and c08 / 2 ^ 170 == 2 ^ 22 - 1\n        and c07 / 2 ^ 149 == 2 ^ 21 - 1\n        and c06 / 2 ^ 128 == 2 ^ 21 - 1\n        and c05 / 2 ^ 107 == 2 ^ 21 - 1\n        and c04 / 2 ^ 85  == 2 ^ 22 - 1\n        and c03 / 2 ^ 64  == 2 ^ 21 - 1\n        and c02 / 2 ^ 43  == 2 ^ 21 - 1\n        and c01 / 2 ^ 22  == 2 ^ 21 - 1\n        and c00 >= 2 ^ 22 - 19\n    then\n        return {19 - 2 ^ 22 + c00, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\n    else\n        return {c00, c01, c02, c03, c04, c05, c06, c07, c08, c09, c10, c11}\n    end\nend\n\n--- Returns whether two elements are the same.\n--- @param a FpR1\n--- @param b FpR1\n--- @return boolean eq Whether a \226\137\161 b (mod p).\nlocal function eq(a, b)\n    local c = canonicalize(sub(a, b))\n    for i = 1, 12 do if c[i] ~= 0 then return false end end\n    return true\nend\n\n--- Multiplies two elements.\n--- @param a FpR2\n--- @param b FpR2\n--- @return FpR1 c An element such that c \226\137\161 a \195\151 b (mod p).\nlocal function mul(a, b)\n    local a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10, a11 = unpack(a)\n    local b00, b01, b02, b03, b04, b05, b06, b07, b08, b09, b10, b11 = unpack(b)\n    local c00, c01, c02, c03, c04, c05, c06, c07, c08, c09, c10, c11\n\n    -- Multiply high half into c00..c11.\n    c00 = a11 * b01\n        + a10 * b02\n        + a09 * b03\n        + a08 * b04\n        + a07 * b05\n        + a06 * b06\n        + a05 * b07\n        + a04 * b08\n        + a03 * b09\n        + a02 * b10\n        + a01 * b11\n    c01 = a11 * b02\n        + a10 * b03\n        + a09 * b04\n        + a08 * b05\n        + a07 * b06\n        + a06 * b07\n        + a05 * b08\n        + a04 * b09\n        + a03 * b10\n        + a02 * b11\n    c02 = a11 * b03\n        + a10 * b04\n        + a09 * b05\n        + a08 * b06\n        + a07 * b07\n        + a06 * b08\n        + a05 * b09\n        + a04 * b10\n        + a03 * b11\n    c03 = a11 * b04\n        + a10 * b05\n        + a09 * b06\n        + a08 * b07\n        + a07 * b08\n        + a06 * b09\n        + a05 * b10\n        + a04 * b11\n    c04 = a11 * b05\n        + a10 * b06\n        + a09 * b07\n        + a08 * b08\n        + a07 * b09\n        + a06 * b10\n        + a05 * b11\n    c05 = a11 * b06\n        + a10 * b07\n        + a09 * b08\n        + a08 * b09\n        + a07 * b10\n        + a06 * b11\n    c06 = a11 * b07\n        + a10 * b08\n        + a09 * b09\n        + a08 * b10\n        + a07 * b11\n    c07 = a11 * b08\n        + a10 * b09\n        + a09 * b10\n        + a08 * b11\n    c08 = a11 * b09\n        + a10 * b10\n        + a09 * b11\n    c09 = a11 * b10\n        + a10 * b11\n    c10 = a11 * b11\n\n    -- Multiply low half with reduction into c00..c11.\n    c00 = c00 * (19 / 2 ^ 255)\n        + a00 * b00\n    c01 = c01 * (19 / 2 ^ 255)\n        + a01 * b00\n        + a00 * b01\n    c02 = c02 * (19 / 2 ^ 255)\n        + a02 * b00\n        + a01 * b01\n        + a00 * b02\n    c03 = c03 * (19 / 2 ^ 255)\n        + a03 * b00\n        + a02 * b01\n        + a01 * b02\n        + a00 * b03\n    c04 = c04 * (19 / 2 ^ 255)\n        + a04 * b00\n        + a03 * b01\n        + a02 * b02\n        + a01 * b03\n        + a00 * b04\n    c05 = c05 * (19 / 2 ^ 255)\n        + a05 * b00\n        + a04 * b01\n        + a03 * b02\n        + a02 * b03\n        + a01 * b04\n        + a00 * b05\n    c06 = c06 * (19 / 2 ^ 255)\n        + a06 * b00\n        + a05 * b01\n        + a04 * b02\n        + a03 * b03\n        + a02 * b04\n        + a01 * b05\n        + a00 * b06\n    c07 = c07 * (19 / 2 ^ 255)\n        + a07 * b00\n        + a06 * b01\n        + a05 * b02\n        + a04 * b03\n        + a03 * b04\n        + a02 * b05\n        + a01 * b06\n        + a00 * b07\n    c08 = c08 * (19 / 2 ^ 255)\n        + a08 * b00\n        + a07 * b01\n        + a06 * b02\n        + a05 * b03\n        + a04 * b04\n        + a03 * b05\n        + a02 * b06\n        + a01 * b07\n        + a00 * b08\n    c09 = c09 * (19 / 2 ^ 255)\n        + a09 * b00\n        + a08 * b01\n        + a07 * b02\n        + a06 * b03\n        + a05 * b04\n        + a04 * b05\n        + a03 * b06\n        + a02 * b07\n        + a01 * b08\n        + a00 * b09\n    c10 = c10 * (19 / 2 ^ 255)\n        + a10 * b00\n        + a09 * b01\n        + a08 * b02\n        + a07 * b03\n        + a06 * b04\n        + a05 * b05\n        + a04 * b06\n        + a03 * b07\n        + a02 * b08\n        + a01 * b09\n        + a00 * b10\n    c11 = a11 * b00\n        + a10 * b01\n        + a09 * b02\n        + a08 * b03\n        + a07 * b04\n        + a06 * b05\n        + a05 * b06\n        + a04 * b07\n        + a03 * b08\n        + a02 * b09\n        + a01 * b10\n        + a00 * b11\n\n    -- Carry and reduce.\n    a10 = c10 + 3 * 2 ^ 285 - 3 * 2 ^ 285  c11 = c11 + a10\n    a11 = c11 + 3 * 2 ^ 306 - 3 * 2 ^ 306  c00 = c00 + 19 / 2 ^ 255 * a11\n\n    a00 = c00 + 3 * 2 ^ 73  - 3 * 2 ^ 73   c01 = c01 + a00\n    a01 = c01 + 3 * 2 ^ 94  - 3 * 2 ^ 94   c02 = c02 + a01\n    a02 = c02 + 3 * 2 ^ 115 - 3 * 2 ^ 115  c03 = c03 + a02\n    a03 = c03 + 3 * 2 ^ 136 - 3 * 2 ^ 136  c04 = c04 + a03\n    a04 = c04 + 3 * 2 ^ 158 - 3 * 2 ^ 158  c05 = c05 + a04\n    a05 = c05 + 3 * 2 ^ 179 - 3 * 2 ^ 179  c06 = c06 + a05\n    a06 = c06 + 3 * 2 ^ 200 - 3 * 2 ^ 200  c07 = c07 + a06\n    a07 = c07 + 3 * 2 ^ 221 - 3 * 2 ^ 221  c08 = c08 + a07\n    a08 = c08 + 3 * 2 ^ 243 - 3 * 2 ^ 243  c09 = c09 + a08\n    a09 = c09 + 3 * 2 ^ 264 - 3 * 2 ^ 264  c10 = c10 - a10 + a09\n    a10 = c10 + 3 * 2 ^ 285 - 3 * 2 ^ 285  c11 = c11 - a11 + a10\n\n    a11 = c11 + 3 * 2 ^ 306 - 3 * 2 ^ 306\n\n    return {\n        c00 - a00 + 19 / 2 ^ 255 * a11,\n        c01 - a01,\n        c02 - a02,\n        c03 - a03,\n        c04 - a04,\n        c05 - a05,\n        c06 - a06,\n        c07 - a07,\n        c08 - a08,\n        c09 - a09,\n        c10 - a10,\n        c11 - a11,\n    }\nend\n\n--- Squares an element.\n--- @param a FpR2\n--- @return FpR1 b An element such that b \226\137\161 a\194\178 (mod p).\nlocal function square(a)\n    local a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10, a11 = unpack(a)\n    local d00, d01, d02, d03, d04, d05, d06, d07, d08, d09, d10\n    local c00, c01, c02, c03, c04, c05, c06, c07, c08, c09, c10, c11\n\n    -- Compute 2a.\n    d00 = a00 + a00\n    d01 = a01 + a01\n    d02 = a02 + a02\n    d03 = a03 + a03\n    d04 = a04 + a04\n    d05 = a05 + a05\n    d06 = a06 + a06\n    d07 = a07 + a07\n    d08 = a08 + a08\n    d09 = a09 + a09\n    d10 = a10 + a10\n\n    -- Multiply high half into c00..c11.\n    c00 = a11 * d01\n        + a10 * d02\n        + a09 * d03\n        + a08 * d04\n        + a07 * d05\n        + a06 * a06\n    c01 = a11 * d02\n        + a10 * d03\n        + a09 * d04\n        + a08 * d05\n        + a07 * d06\n    c02 = a11 * d03\n        + a10 * d04\n        + a09 * d05\n        + a08 * d06\n        + a07 * a07\n    c03 = a11 * d04\n        + a10 * d05\n        + a09 * d06\n        + a08 * d07\n    c04 = a11 * d05\n        + a10 * d06\n        + a09 * d07\n        + a08 * a08\n    c05 = a11 * d06\n        + a10 * d07\n        + a09 * d08\n    c06 = a11 * d07\n        + a10 * d08\n        + a09 * a09\n    c07 = a11 * d08\n        + a10 * d09\n    c08 = a11 * d09\n        + a10 * a10\n    c09 = a11 * d10\n    c10 = a11 * a11\n\n    -- Multiply low half with reduction into c00..c11.\n    c00 = c00 * (19 / 2 ^ 255)\n        + a00 * a00\n    c01 = c01 * (19 / 2 ^ 255)\n        + a01 * d00\n    c02 = c02 * (19 / 2 ^ 255)\n        + a02 * d00\n        + a01 * a01\n    c03 = c03 * (19 / 2 ^ 255)\n        + a03 * d00\n        + a02 * d01\n    c04 = c04 * (19 / 2 ^ 255)\n        + a04 * d00\n        + a03 * d01\n        + a02 * a02\n    c05 = c05 * (19 / 2 ^ 255)\n        + a05 * d00\n        + a04 * d01\n        + a03 * d02\n    c06 = c06 * (19 / 2 ^ 255)\n        + a06 * d00\n        + a05 * d01\n        + a04 * d02\n        + a03 * a03\n    c07 = c07 * (19 / 2 ^ 255)\n        + a07 * d00\n        + a06 * d01\n        + a05 * d02\n        + a04 * d03\n    c08 = c08 * (19 / 2 ^ 255)\n        + a08 * d00\n        + a07 * d01\n        + a06 * d02\n        + a05 * d03\n        + a04 * a04\n    c09 = c09 * (19 / 2 ^ 255)\n        + a09 * d00\n        + a08 * d01\n        + a07 * d02\n        + a06 * d03\n        + a05 * d04\n    c10 = c10 * (19 / 2 ^ 255)\n        + a10 * d00\n        + a09 * d01\n        + a08 * d02\n        + a07 * d03\n        + a06 * d04\n        + a05 * a05\n    c11 = a11 * d00\n        + a10 * d01\n        + a09 * d02\n        + a08 * d03\n        + a07 * d04\n        + a06 * d05\n\n    -- Carry and reduce.\n    a10 = c10 + 3 * 2 ^ 285 - 3 * 2 ^ 285  c11 = c11 + a10\n    a11 = c11 + 3 * 2 ^ 306 - 3 * 2 ^ 306  c00 = c00 + 19 / 2 ^ 255 * a11\n\n    a00 = c00 + 3 * 2 ^ 73  - 3 * 2 ^ 73   c01 = c01 + a00\n    a01 = c01 + 3 * 2 ^ 94  - 3 * 2 ^ 94   c02 = c02 + a01\n    a02 = c02 + 3 * 2 ^ 115 - 3 * 2 ^ 115  c03 = c03 + a02\n    a03 = c03 + 3 * 2 ^ 136 - 3 * 2 ^ 136  c04 = c04 + a03\n    a04 = c04 + 3 * 2 ^ 158 - 3 * 2 ^ 158  c05 = c05 + a04\n    a05 = c05 + 3 * 2 ^ 179 - 3 * 2 ^ 179  c06 = c06 + a05\n    a06 = c06 + 3 * 2 ^ 200 - 3 * 2 ^ 200  c07 = c07 + a06\n    a07 = c07 + 3 * 2 ^ 221 - 3 * 2 ^ 221  c08 = c08 + a07\n    a08 = c08 + 3 * 2 ^ 243 - 3 * 2 ^ 243  c09 = c09 + a08\n    a09 = c09 + 3 * 2 ^ 264 - 3 * 2 ^ 264  c10 = c10 - a10 + a09\n    a10 = c10 + 3 * 2 ^ 285 - 3 * 2 ^ 285  c11 = c11 - a11 + a10\n\n    a11 = c11 + 3 * 2 ^ 306 - 3 * 2 ^ 306\n\n    return {\n        c00 - a00 + 19 / 2 ^ 255 * a11,\n        c01 - a01,\n        c02 - a02,\n        c03 - a03,\n        c04 - a04,\n        c05 - a05,\n        c06 - a06,\n        c07 - a07,\n        c08 - a08,\n        c09 - a09,\n        c10 - a10,\n        c11 - a11,\n    }\nend\n\n--- Multiplies an element by a number.\n--- @param a FpR2\n--- @param k number A number in [0..2\194\178\194\178).\n--- @return FpR1 c An element such that c \226\137\161 a \195\151 k (mod p).\nlocal function kmul(a, k)\n    local a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10, a11 = unpack(a)\n    local c00, c01, c02, c03, c04, c05, c06, c07, c08, c09, c10, c11\n\n    -- TODO Range check.\n    a00 = a00 * k\n    a01 = a01 * k\n    a02 = a02 * k\n    a03 = a03 * k\n    a04 = a04 * k\n    a05 = a05 * k\n    a06 = a06 * k\n    a07 = a07 * k\n    a08 = a08 * k\n    a09 = a09 * k\n    a10 = a10 * k\n    a11 = a11 * k\n\n    c11 = a11 + 3 * 2 ^ 306 - 3 * 2 ^ 306  a00 = a00 + 19 / 2 ^ 255 * c11\n\n    c00 = a00 + 3 * 2 ^ 73  - 3 * 2 ^ 73   a01 = a01 + c00\n    c01 = a01 + 3 * 2 ^ 94  - 3 * 2 ^ 94   a02 = a02 + c01\n    c02 = a02 + 3 * 2 ^ 115 - 3 * 2 ^ 115  a03 = a03 + c02\n    c03 = a03 + 3 * 2 ^ 136 - 3 * 2 ^ 136  a04 = a04 + c03\n    c04 = a04 + 3 * 2 ^ 158 - 3 * 2 ^ 158  a05 = a05 + c04\n    c05 = a05 + 3 * 2 ^ 179 - 3 * 2 ^ 179  a06 = a06 + c05\n    c06 = a06 + 3 * 2 ^ 200 - 3 * 2 ^ 200  a07 = a07 + c06\n    c07 = a07 + 3 * 2 ^ 221 - 3 * 2 ^ 221  a08 = a08 + c07\n    c08 = a08 + 3 * 2 ^ 243 - 3 * 2 ^ 243  a09 = a09 + c08\n    c09 = a09 + 3 * 2 ^ 264 - 3 * 2 ^ 264  a10 = a10 + c09\n    c10 = a10 + 3 * 2 ^ 285 - 3 * 2 ^ 285  a11 = a11 - c11 + c10\n\n    c11 = a11 + 3 * 2 ^ 306 - 3 * 2 ^ 306\n\n    return {\n        a00 - c00 + 19 / 2 ^ 255 * c11,\n        a01 - c01,\n        a02 - c02,\n        a03 - c03,\n        a04 - c04,\n        a05 - c05,\n        a06 - c06,\n        a07 - c07,\n        a08 - c08,\n        a09 - c09,\n        a10 - c10,\n        a11 - c11\n    }\nend\n\n--- Squares an element n times.\n--- @param a FpR2\n--- @param n number The number of times to square a.\n--- @return FpR1 c A number c such that c \226\137\161 a ^ 2 ^ n (mod p).\nlocal function nsquare(a, n)\n    for _ = 1, n do a = square(a) end\n    return a\nend\n\n--- Computes the inverse of an element.\n---\n--- Performance: 11 multiplications and 252 squarings.\n---\n--- @param a FpR2\n--- @return FpR1 c An element such that c \226\137\161 a\226\129\187\194\185 (mod p), or 0 if c doesn't exist.\nlocal function invert(a)\n    local a2 = square(a)\n    local a9 = mul(a, nsquare(a2, 2))\n    local a11 = mul(a9, a2)\n\n    local x5 = mul(square(a11), a9)\n    local x10 = mul(nsquare(x5, 5), x5)\n    local x20 = mul(nsquare(x10, 10), x10)\n    local x40 = mul(nsquare(x20, 20), x20)\n    local x50 = mul(nsquare(x40, 10), x10)\n    local x100 = mul(nsquare(x50, 50), x50)\n    local x200 = mul(nsquare(x100, 100), x100)\n    local x250 = mul(nsquare(x200, 50), x50)\n\n    return mul(nsquare(x250, 5), a11)\nend\n\n--- Returns an element x that satisfies vx\194\178 = u.\n---\n--- Note that when v = 0, the returned element can take any value.\n---\n--- @param u FpR2\n--- @param v FpR2\n--- @return FpR1? x An element such that vx\194\178 \226\137\161 u (mod p), if it exists.\nlocal function sqrtDiv(u, v)\n    u = carry(u)\n\n    local v2 = square(v)\n    local v3 = mul(v, v2)\n    local v6 = square(v3)\n    local v7 = mul(v, v6)\n    local uv7 = mul(u, v7)\n\n    local x2 = mul(square(uv7), uv7)\n    local x4 = mul(nsquare(x2, 2), x2)\n    local x8 = mul(nsquare(x4, 4), x4)\n    local x16 = mul(nsquare(x8, 8), x8)\n    local x18 = mul(nsquare(x16, 2), x2)\n    local x32 = mul(nsquare(x16, 16), x16)\n    local x50 = mul(nsquare(x32, 18), x18)\n    local x100 = mul(nsquare(x50, 50), x50)\n    local x200 = mul(nsquare(x100, 100), x100)\n    local x250 = mul(nsquare(x200, 50), x50)\n    local pr = mul(nsquare(x250, 2), uv7)\n\n    local uv3 = mul(u, v3)\n    local b = mul(uv3, pr)\n    local b2 = square(b)\n    local vb2 = mul(v, b2)\n\n    if not eq(vb2, u) then\n        -- Found sqrt(-u/v), multiply by i.\n        b = mul(b, I)\n        b2 = square(b)\n        vb2 = mul(v, b2)\n    end\n\n    if eq(vb2, u) then\n        return b\n    else\n        return nil\n    end\nend\n\n--- @class String32: string A string with length equal to 32 bytes.\n\n--- Encodes an element in little-endian.\n--- @param a FpR1\n--- @return String32 out The 32-byte canonical encoding of a.\nlocal function encode(a)\n    a = canonicalize(a)\n    local a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10, a11 = unpack(a)\n\n    local bytes = {}\n    local acc = a00\n\n    local function putBytes(n)\n        for _ = 1, n do\n            local byte = acc % 256\n            bytes[#bytes + 1] = byte\n            acc = (acc - byte) / 256\n        end\n    end\n\n    putBytes(2) acc = acc + a01 / 2 ^ 16\n    putBytes(3) acc = acc + a02 / 2 ^ 40\n    putBytes(3) acc = acc + a03 / 2 ^ 64\n    putBytes(2) acc = acc + a04 / 2 ^ 80\n    putBytes(3) acc = acc + a05 / 2 ^ 104\n    putBytes(3) acc = acc + a06 / 2 ^ 128\n    putBytes(2) acc = acc + a07 / 2 ^ 144\n    putBytes(3) acc = acc + a08 / 2 ^ 168\n    putBytes(3) acc = acc + a09 / 2 ^ 192\n    putBytes(2) acc = acc + a10 / 2 ^ 208\n    putBytes(3) acc = acc + a11 / 2 ^ 232\n    putBytes(3)\n\n    return string.char(unpack(bytes)) --[[@as String32, putBytes sums to 32]]\nend\n\n--- Decodes an element in little-endian.\n--- @param b String32 A 32-byte string, the most-significant bit is discarded.\n--- @return FpR1 out The decoded element. It may not be canonical.\nlocal function decode(b)\n    local w00, w01, w02, w03, w04, w05, w06, w07, w08, w09, w10, w11 =\n        ufp(fmtfp, b, 1)\n\n    w11 = w11 % 2 ^ 15\n\n    return carry {\n        w00,\n        w01 * 2 ^ 24,\n        w02 * 2 ^ 48,\n        w03 * 2 ^ 64,\n        w04 * 2 ^ 88,\n        w05 * 2 ^ 112,\n        w06 * 2 ^ 128,\n        w07 * 2 ^ 152,\n        w08 * 2 ^ 176,\n        w09 * 2 ^ 192,\n        w10 * 2 ^ 216,\n        w11 * 2 ^ 240,\n    }\nend\n\n--- Checks if the given element is equal to 0.\n--- @param a FpR2\n--- @return boolean eqz Whether a \226\137\161 0 (mod p).\nlocal function eqz(a)\n    local c = canonicalize(a)\n    local c00, c01, c02, c03, c04, c05, c06, c07, c08, c09, c10, c11 = unpack(c)\n    return c00 + c01 + c02 + c03 + c04 + c05 + c06 + c07 + c08 + c09 + c10 + c11\n        == 0\nend\n\nreturn {\n    num = num,\n    neg = neg,\n    add = add,\n    sub = sub,\n    kmul = kmul,\n    mul = mul,\n    canonicalize = canonicalize,\n    square = square,\n    carry = carry,\n    invert = invert,\n    sqrtDiv = sqrtDiv,\n    encode = encode,\n    decode = decode,\n    eqz = eqz,\n}\ninternal_fq.lua/1686753801  0     0     775     10868     `\n--- Arithmetic on Curve25519's scalar field.\n\nlocal mp = require \"internal_mp\"\nlocal util = require \"internal_util\"\nlocal packing = require \"internal_packing\"\n\nlocal unpack = unpack or table.unpack\nlocal pfq, fmtfq = packing.compilePack(\"<I3I3I3I3I3I3I3I3I3I3I2\")\nlocal ufq = packing.compileUnpack(fmtfq)\nlocal ufql, fmtfql = packing.compileUnpack(\"<I3I3I3I3I3I3I3I3I3I3I3\")\nlocal ufqh, fmtfqh = packing.compileUnpack(\"<I3I3I3I3I3I3I3I3I3I3I1\")\n\n--- The scalar field's order, q = 2\194\178\226\129\181\194\178 + 27742317777372353535851937790883648493.\nlocal Q = {\n    16110573,\n    06494812,\n    14047250,\n    10680220,\n    14612958,\n    00000020,\n    00000000,\n    00000000,\n    00000000,\n    00000000,\n    00004096,\n}\n\n--- The first Montgomery precomputed constant, -q\226\129\187\194\185 mod 2\194\178\226\129\182\226\129\180.\nlocal T0 = {\n    05537307,\n    01942290,\n    16765621,\n    16628356,\n    10618610,\n    07072433,\n    03735459,\n    01369940,\n    15276086,\n    13038191,\n    13409718,\n}\n\n--- The second Montgomery precomputed constant, 2\226\129\181\194\178\226\129\184 mod q.\nlocal T1 = {\n    11711996,\n    01747860,\n    08326961,\n    03814718,\n    01859974,\n    13327461,\n    16105061,\n    07590423,\n    04050668,\n    08138906,\n    00000283,\n}\n\nlocal T8 = {\n    5110253,\n    3039345,\n    2503500,\n    11779568,\n    15416472,\n    16766550,\n    16777215,\n    16777215,\n    16777215,\n    16777215,\n    4095,\n}\n\nlocal ZERO = mp.num(0)\n\n--- Reduces a number modulo q.\n--\n-- @tparam {number...} a A number a < 2q as 11 limbs in [0..2\194\178\226\129\181).\n-- @treturn {number...} a mod q as 11 limbs in [0..2\194\178\226\129\180).\n--\nlocal function reduce(a)\n    local c = mp.sub(a, Q)\n\n    -- Return carry(a) if a < q.\n    if mp.approx(c) < 0 then return (mp.carry(a)) end\n\n    -- c >= q means c - q >= 0.\n    -- Since q < 2\194\178\226\129\184\226\129\184, c < 2q means c - q < q < 2\194\178\226\129\184\226\129\184.\n    -- c's limbs fit in (-2\194\178\226\129\182..2\194\178\226\129\182), since subtraction adds at most one bit.\n    return (mp.carry(c)) -- cc < q implies that the carry number is 0.\nend\n\n--- Adds two scalars mod q.\n--\n-- If the two operands are in Montgomery form, returns the correct result also\n-- in Montgomery form, since (2\194\178\226\129\182\226\129\180 \195\151 a) + (2\194\178\226\129\182\226\129\180 \195\151 b) \226\137\161 2\194\178\226\129\182\226\129\180 \195\151 (a + b) (mod q).\n--\n-- @tparam {number...} a A number a < q as 11 limbs in [0..2\194\178\226\129\180).\n-- @tparam {number...} b A number b < q as 11 limbs in [0..2\194\178\226\129\180).\n-- @treturn {number...} a + b mod q as 11 limbs in [0..2\194\178\226\129\180).\n--\nlocal function add(a, b)\n    return reduce(mp.add(a, b))\nend\n\n--- Negates a scalar mod q.\n--\n-- @tparam {number...} a A number a < q as 11 limbs in [0..2\194\178\226\129\180).\n-- @treturn {number...} -a mod q as 11 limbs in [0..2\194\178\226\129\180).\n--\nlocal function neg(a)\n    return reduce(mp.sub(Q, a))\nend\n\n--- Subtracts scalars mod q.\n--\n-- If the two operands are in Montgomery form, returns the correct result also\n-- in Montgomery form, since (2\194\178\226\129\182\226\129\180 \195\151 a) - (2\194\178\226\129\182\226\129\180 \195\151 b) \226\137\161 2\194\178\226\129\182\226\129\180 \195\151 (a - b) (mod q).\n--\n-- @tparam {number...} a A number a < q as 11 limbs in [0..2\194\178\226\129\180).\n-- @tparam {number...} b A number b < q as 11 limbs in [0..2\194\178\226\129\180).\n-- @treturn {number...} a - b mod q as 11 limbs in [0..2\194\178\226\129\180).\n--\nlocal function sub(a, b)\n    return add(a, neg(b))\nend\n\n--- Given two scalars a and b, computes 2\226\129\187\194\178\226\129\182\226\129\180 \195\151 a \195\151 b mod q.\n--\n-- @tparam {number...} a A number a as 11 limbs in [0..2\194\178\226\129\180).\n-- @tparam {number...} b A number b < q as 11 limbs in [0..2\194\178\226\129\180).\n-- @treturn {number...} 2\226\129\187\194\178\226\129\182\226\129\180 \195\151 a \195\151 b mod q as 11 limbs in [0..2\194\178\226\129\180).\n--\nlocal function mul(a, b)\n    local t0, t1 = mp.mul(a, b)\n    local mq0, mq1 = mp.mul(mp.lmul(t0, T0), Q)\n    local _, s1 = mp.dwadd(t0, t1, mq0, mq1)\n    return reduce(s1)\nend\n\n--- Converts a scalar into Montgomery form.\n--\n-- @tparam {number...} a A number a as 11 limbs in [0..2\194\178\226\129\180).\n-- @treturn {number...} 2\194\178\226\129\182\226\129\180 \195\151 a mod q as 11 limbs in [0..2\194\178\226\129\180).\n--\nlocal function montgomery(a)\n    -- 0 \226\137\164 a < 2\194\178\226\129\182\226\129\180 and 0 \226\137\164 T1 < q.\n    return mul(a, T1)\nend\n\n--- Converts a scalar from Montgomery form.\n--\n-- @tparam {number...} a A number a < q as 11 limbs in [0..2\194\178\226\129\180).\n-- @treturn {number...} 2\226\129\187\194\178\226\129\182\226\129\180 \195\151 a mod q as 11 limbs in [0..2\194\178\226\129\180).\n--\nlocal function demontgomery(a)\n    -- It's REDC all over again except b is 1.\n    local mq0, mq1 = mp.mul(mp.lmul(a, T0), Q)\n    local _, s1 = mp.dwadd(a, ZERO, mq0, mq1)\n    return reduce(s1)\nend\n\n--- Encodes a scalar.\n--\n-- @tparam {number...} a A number 2\194\178\226\129\182\226\129\180 \195\151 a mod q as 11 limbs in [0..2\194\178\226\129\180).\n-- @treturn string The 32-byte string encoding of a.\n--\nlocal function encode(a)\n    return pfq(fmtfq, unpack(demontgomery(a)))\nend\n\n--- Decodes a scalar.\n--\n-- @tparam string str A 32-byte string encoding some little-endian number a.\n-- @treturn {number...} 2\194\178\226\129\182\226\129\180 \195\151 a mod q as 11 limbs in [0..2\194\178\226\129\180).\n--\nlocal function decode(str)\n    local dec = {ufq(fmtfq, str, 1)} dec[12] = nil\n    return montgomery(dec)\nend\n\n--- Decodes a scalar from a \"wide\" string.\n--\n-- @tparam string str A 64-byte string encoding some little-endian number a.\n-- @treturn {number...} 2\194\178\226\129\182\226\129\180 \195\151 a mod q as 11 limbs in [0..2\194\178\226\129\180).\n--\nlocal function decodeWide(str)\n    local low = {ufql(fmtfql, str, 1)} low[12] = nil\n    local high = {ufqh(fmtfqh, str, 34)} high[12] = nil\n    return add(montgomery(low), montgomery(montgomery(high)))\nend\n\n--- Decodes a scalar using the X25519/Ed25519 bit clamping scheme.\n--\n-- @tparam string str A 32-byte string encoding some little-endian number a.\n-- @treturn {number...} 2\194\178\226\129\182\226\129\180 \195\151 clamp(a) mod q as 11 limbs in [0..2\194\178\226\129\180).\n--\nlocal function decodeClamped(str)\n    -- Decode.\n    local words = {ufq(fmtfq, str, 1)} words[12] = nil\n\n    -- Clamp.\n    words[1] = bit32.band(words[1], 0xfffff8)\n    words[11] = bit32.band(words[11], 0x7fff)\n    words[11] = bit32.bor(words[11], 0x4000)\n\n    return montgomery(words)\nend\n\n--- Divides a scalar by 8.\n--\n-- @tparam {number...} 2\194\178\226\129\182\226\129\180 \195\151 a mod q as 11 limbs in [0..2\194\178\226\129\180).\n-- @treturn {number...} 2\194\178\226\129\182\226\129\181 \195\151 a \195\183 8 mod q as 11 limbs in [0..2\194\178\226\129\180).\nlocal function eighth(a)\n    return mul(a, T8)\nend\n\n--- Returns a scalar in binary.\n--\n-- @tparam {number...} a A number a < q as 11 limbs in [0..2\194\178\226\129\180).\n-- @treturn {number...} 2\226\129\187\194\178\226\129\182\226\129\180 \195\151 a mod q as 253 bits.\n--\nlocal function bits(a)\n    local out = util.rebaseLE(demontgomery(a), 2 ^ 24, 2)\n    for i = 254, 289 do out[i] = nil end\n    return out\nend\n\n--- Makes a PRAC ruleset from a pair of scalars.\n--\n-- For more information see section 3.3 of Speeding up subgroup cryptosystems:\n-- Martijn Stam. Speeding up subgroup cryptosystems. PhD thesis, Technische\n-- Universiteit Eindhoven, 2003. https://dx.doi.org/10.6100/IR564670.\n--\n-- @tparam {number...} a A scalar 2\194\178\226\129\182\226\129\180 \195\151 a mod q as 11 limbs in [0..2\194\178\226\129\180).\n-- @tparam {number...} b A scalar 2\194\178\226\129\182\226\129\180 \195\151 b mod q as 11 limbs in [0..2\194\178\226\129\180).\n-- @treturn {{number...}, {number...}} The generated ruleset.\n--\nlocal function makeRuleset(a, b)\n    -- The numbers in raw multiprecision tables.\n    local dt = demontgomery(a) -- (-2\194\178\226\129\180..2\194\178\226\129\180)\n    local et = demontgomery(b) -- (-2\194\178\226\129\180..2\194\178\226\129\180)\n    local ft = mp.sub(dt, et)  -- (-2\194\178\226\129\181..2\194\178\226\129\181)\n\n    -- Residue classes of (d, e) modulo 2.\n    local d2 = mp.mod2(dt)\n    local e2 = mp.mod2(et)\n\n    -- Residue classes of (d, e) modulo 3.\n    local d3 = mp.mod3(dt)\n    local e3 = mp.mod3(et)\n\n    -- (e, d - e) in limited-precision floating-point numbers.\n    local ef = mp.approx(et)\n    local ff = mp.approx(ft)\n\n    -- Lookup table for inversions and halvings modulo 3.\n    local lut3 = {[0] = 0, 2, 1}\n\n    local rules = {}\n    while ff ~= 0 do\n        if ff < 0 then\n            -- M0. d < e\n            rules[#rules + 1] = 0\n            -- (d, e) \226\134\144 (e, d)\n            dt, et = et, dt\n            d2, e2 = e2, d2\n            d3, e3 = e3, d3\n            ef = mp.approx(et)\n            ft = mp.sub(dt, et)\n            ff = -ff\n        elseif 4 * ff < ef and d3 == lut3[e3] then\n            -- M1. e < d \226\137\164 5/4 e, d \226\137\161 -e (mod 3)\n            rules[#rules + 1] = 1\n            -- (d, e) \226\134\144 ((2d - e)/3, (2e - d)/3)\n            dt, et = mp.third(mp.add(dt, ft)), mp.third(mp.sub(et, ft))\n            d2, e2 = e2, d2\n            d3, e3 = mp.mod3(dt), mp.mod3(et)\n            ef = mp.approx(et)\n        elseif 4 * ff < ef and d2 == e2 and d3 == e3 then\n            -- M2. e < d \226\137\164 5/4 e, d \226\137\161 e (mod 6)\n            rules[#rules + 1] = 2\n            -- (d, e) \226\134\144 ((d - e)/2, e)\n            dt = mp.half(ft)\n            d2 = mp.mod2(dt)\n            d3 = lut3[(d3 - e3) % 3]\n            ft = mp.sub(dt, et)\n            ff = mp.approx(ft)\n        elseif ff < 3 * ef then\n            -- M3. d \226\137\164 4e\n            rules[#rules + 1] = 3\n            -- (d, e) \226\134\144 (d - e, e)\n            dt = mp.carryWeak(ft)\n            d2 = (d2 - e2) % 2\n            d3 = (d3 - e3) % 3\n            ft = mp.sub(dt, et)\n            ff = mp.approx(ft)\n        elseif d2 == e2 then\n            -- M4. d \226\137\161 e (mod 2)\n            rules[#rules + 1] = 2\n            -- (d, e) \226\134\144 ((d - e)/2, e)\n            dt = mp.half(ft)\n            d2 = mp.mod2(dt)\n            d3 = lut3[(d3 - e3) % 3]\n            ft = mp.sub(dt, et)\n            ff = mp.approx(ft)\n        elseif d2 == 0 then\n            -- M5. d \226\137\161 0 (mod 2)\n            rules[#rules + 1] = 5\n            -- (d, e) \226\134\144 (d/2, e)\n            dt = mp.half(dt)\n            d2 = mp.mod2(dt)\n            d3 = lut3[d3]\n            ft = mp.sub(dt, et)\n            ff = mp.approx(ft)\n        elseif d3 == 0 then\n            -- M6. d \226\137\161 0 (mod 3)\n            rules[#rules + 1] = 6\n            -- (d, e) \226\134\144 (d/3 - e, e)\n            dt = mp.carryWeak(mp.sub(mp.third(dt), et))\n            d2 = (d2 - e2) % 2\n            d3 = mp.mod3(dt)\n            ft = mp.sub(dt, et)\n            ff = mp.approx(ft)\n        elseif d3 == lut3[e3] then\n            -- M7. d \226\137\161 -e (mod 3)\n            rules[#rules + 1] = 7\n            -- (d, e) \226\134\144 ((d - 2e)/3, e)\n            dt = mp.third(mp.sub(ft, et))\n            d3 = mp.mod3(dt)\n            ft = mp.sub(dt, et)\n            ff = mp.approx(ft)\n        elseif d3 == e3 then\n            -- M8. d \226\137\161 e (mod 3)\n            rules[#rules + 1] = 8\n            -- (d, e) \226\134\144 ((d - e)/3, e)\n            dt = mp.third(ft)\n            d2 = (d2 - e2) % 2\n            d3 = mp.mod3(dt)\n            ft = mp.sub(dt, et)\n            ff = mp.approx(ft)\n        else\n            -- M9. e \226\137\161 0 (mod 2)\n            rules[#rules + 1] = 9\n            -- (d, e) \226\134\144 (d, e/2)\n            et = mp.half(et)\n            e2 = mp.mod2(et)\n            e3 = lut3[e3]\n            ef = mp.approx(et)\n            ft = mp.sub(dt, et)\n            ff = mp.approx(ft)\n        end\n    end\n\n    local ubits = util.rebaseLE(dt, 2 ^ 24, 2)\n    while ubits[#ubits] == 0 do ubits[#ubits] = nil end\n\n    return {ubits, rules}\nend\n\nreturn {\n    add = add,\n    sub = sub,\n    mul = mul,\n    encode = encode,\n    decode = decode,\n    decodeWide = decodeWide,\n    decodeClamped = decodeClamped,\n    eighth = eighth,\n    bits = bits,\n    makeRuleset = makeRuleset,\n}\ninternal_mp.lua/1686753801  0     0     775     9778      `\n--- Multi-precision arithmetic on 264-bit integers.\n\nlocal unpack = unpack or table.unpack\n\n--- A little-endian big integer of width 11 in (-2\226\129\181\194\178..2\226\129\181\194\178).\n--- @class MpSW11L52\n\n--- A little-endian big integer of width 11 in (-2\194\178\226\129\180, 2\194\178\226\129\180).\n--- @class MpSW11L24: MpSW11L52\n\n--- A little-endian big integer of width 11 in [0..2\194\178\226\129\180).\n--- @class MpUW11L24: MpSW11L24\n\n--- Carries a number in base 2\194\178\226\129\180 into a signed limb form.\n--- @param a MpSW11L52\n--- @return MpSW11L24 low The carried low limbs.\n--- @return number carry The overflowed carry.\nlocal function carryWeak(a)\n    local a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10 = unpack(a)\n\n    local h00 = a00 + 3 * 2 ^ 75 - 3 * 2 ^ 75 a01 = a01 + h00 * 2 ^ -24\n    local h01 = a01 + 3 * 2 ^ 75 - 3 * 2 ^ 75 a02 = a02 + h01 * 2 ^ -24\n    local h02 = a02 + 3 * 2 ^ 75 - 3 * 2 ^ 75 a03 = a03 + h02 * 2 ^ -24\n    local h03 = a03 + 3 * 2 ^ 75 - 3 * 2 ^ 75 a04 = a04 + h03 * 2 ^ -24\n    local h04 = a04 + 3 * 2 ^ 75 - 3 * 2 ^ 75 a05 = a05 + h04 * 2 ^ -24\n    local h05 = a05 + 3 * 2 ^ 75 - 3 * 2 ^ 75 a06 = a06 + h05 * 2 ^ -24\n    local h06 = a06 + 3 * 2 ^ 75 - 3 * 2 ^ 75 a07 = a07 + h06 * 2 ^ -24\n    local h07 = a07 + 3 * 2 ^ 75 - 3 * 2 ^ 75 a08 = a08 + h07 * 2 ^ -24\n    local h08 = a08 + 3 * 2 ^ 75 - 3 * 2 ^ 75 a09 = a09 + h08 * 2 ^ -24\n    local h09 = a09 + 3 * 2 ^ 75 - 3 * 2 ^ 75 a10 = a10 + h09 * 2 ^ -24\n    local h10 = a10 + 3 * 2 ^ 75 - 3 * 2 ^ 75\n\n    return {\n        a00 - h00,\n        a01 - h01,\n        a02 - h02,\n        a03 - h03,\n        a04 - h04,\n        a05 - h05,\n        a06 - h06,\n        a07 - h07,\n        a08 - h08,\n        a09 - h09,\n        a10 - h10,\n    }, h10 * 2 ^ -24\nend\n\n--- Carries a number in base 2\194\178\226\129\180.\n--- @param a MpSW11L52\n--- @return MpUW11L24 low The low 11 limbs of the output.\n--- @return number carry The overflow carry.\nlocal function carry(a)\n    local a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10 = unpack(a)\n\n    local l00 = a00 % 2 ^ 24 a01 = a01 + (a00 - l00) * 2 ^ -24\n    local l01 = a01 % 2 ^ 24 a02 = a02 + (a01 - l01) * 2 ^ -24\n    local l02 = a02 % 2 ^ 24 a03 = a03 + (a02 - l02) * 2 ^ -24\n    local l03 = a03 % 2 ^ 24 a04 = a04 + (a03 - l03) * 2 ^ -24\n    local l04 = a04 % 2 ^ 24 a05 = a05 + (a04 - l04) * 2 ^ -24\n    local l05 = a05 % 2 ^ 24 a06 = a06 + (a05 - l05) * 2 ^ -24\n    local l06 = a06 % 2 ^ 24 a07 = a07 + (a06 - l06) * 2 ^ -24\n    local l07 = a07 % 2 ^ 24 a08 = a08 + (a07 - l07) * 2 ^ -24\n    local l08 = a08 % 2 ^ 24 a09 = a09 + (a08 - l08) * 2 ^ -24\n    local l09 = a09 % 2 ^ 24 a10 = a10 + (a09 - l09) * 2 ^ -24\n    local l10 = a10 % 2 ^ 24\n    local h10 = (a10 - l10) * 2 ^ -24\n\n    return {l00, l01, l02, l03, l04, l05, l06, l07, l08, l09, l10}, h10\nend\n\n--- Adds two numbers.\n--- @param a MpSW11L24\n--- @param b MpSW11L24\n--- @return MpSW11L52 c a + b\nlocal function add(a, b)\n    local a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10 = unpack(a)\n    local b00, b01, b02, b03, b04, b05, b06, b07, b08, b09, b10 = unpack(b)\n\n    return {\n        a00 + b00,\n        a01 + b01,\n        a02 + b02,\n        a03 + b03,\n        a04 + b04,\n        a05 + b05,\n        a06 + b06,\n        a07 + b07,\n        a08 + b08,\n        a09 + b09,\n        a10 + b10,\n    }\nend\n\n--- Subtracts a number from another.\n--- @param a MpSW11L24\n--- @param b MpSW11L24\n--- @return MpSW11L52 c a - b\nlocal function sub(a, b)\n    local a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10 = unpack(a)\n    local b00, b01, b02, b03, b04, b05, b06, b07, b08, b09, b10 = unpack(b)\n\n    return {\n        a00 - b00,\n        a01 - b01,\n        a02 - b02,\n        a03 - b03,\n        a04 - b04,\n        a05 - b05,\n        a06 - b06,\n        a07 - b07,\n        a08 - b08,\n        a09 - b09,\n        a10 - b10,\n    }\nend\n\n--- Computes the lower half of a product between two numbers.\n--- @param a MpUW11L24\n--- @param b MpUW11L24\n--- @return MpUW11L24 c a \195\151 b (mod 2\194\178\226\129\182\226\129\180)\n--- @return number carry \226\140\138a \195\151 b \195\183 2\194\178\226\129\182\226\129\180\226\140\139\nlocal function lmul(a, b)\n    local a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10 = unpack(a)\n    local b00, b01, b02, b03, b04, b05, b06, b07, b08, b09, b10 = unpack(b)\n\n    return carry {\n        a00 * b00,\n        a01 * b00 + a00 * b01,\n        a02 * b00 + a01 * b01 + a00 * b02,\n        a03 * b00 + a02 * b01 + a01 * b02 + a00 * b03,\n        a04 * b00 + a03 * b01 + a02 * b02 + a01 * b03 + a00 * b04,\n        a05 * b00 + a04 * b01 + a03 * b02 + a02 * b03 + a01 * b04 + a00 * b05,\n        a06 * b00 + a05 * b01 + a04 * b02 + a03 * b03 + a02 * b04 + a01 * b05 + a00 * b06,\n        a07 * b00 + a06 * b01 + a05 * b02 + a04 * b03 + a03 * b04 + a02 * b05 + a01 * b06 + a00 * b07,\n        a08 * b00 + a07 * b01 + a06 * b02 + a05 * b03 + a04 * b04 + a03 * b05 + a02 * b06 + a01 * b07 + a00 * b08,\n        a09 * b00 + a08 * b01 + a07 * b02 + a06 * b03 + a05 * b04 + a04 * b05 + a03 * b06 + a02 * b07 + a01 * b08 + a00 * b09,\n        a10 * b00 + a09 * b01 + a08 * b02 + a07 * b03 + a06 * b04 + a05 * b05 + a04 * b06 + a03 * b07 + a02 * b08 + a01 * b09 + a00 * b10,\n    }\nend\n\n--- Computes the a product between two numbers.\n--- @param a MpUW11L24\n--- @param b MpUW11L24\n--- @return MpUW11L24 low The low 11 limbs of a \195\151 b.\n--- @return MpUW11L24 high The high 11 limbs of a \195\151 b.\nlocal function mul(a, b)\n    local low, of = lmul(a, b)\n\n    local _, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10 = unpack(a)\n    local _, b01, b02, b03, b04, b05, b06, b07, b08, b09, b10 = unpack(b)\n\n    -- The carry is always 0.\n    return low, (carry {\n        of + a10 * b01 + a09 * b02 + a08 * b03 + a07 * b04 + a06 * b05 + a05 * b06 + a04 * b07 + a03 * b08 + a02 * b09 + a01 * b10,\n        a10 * b02 + a09 * b03 + a08 * b04 + a07 * b05 + a06 * b06 + a05 * b07 + a04 * b08 + a03 * b09 + a02 * b10,\n        a10 * b03 + a09 * b04 + a08 * b05 + a07 * b06 + a06 * b07 + a05 * b08 + a04 * b09 + a03 * b10,\n        a10 * b04 + a09 * b05 + a08 * b06 + a07 * b07 + a06 * b08 + a05 * b09 + a04 * b10,\n        a10 * b05 + a09 * b06 + a08 * b07 + a07 * b08 + a06 * b09 + a05 * b10,\n        a10 * b06 + a09 * b07 + a08 * b08 + a07 * b09 + a06 * b10,\n        a10 * b07 + a09 * b08 + a08 * b09 + a07 * b10,\n        a10 * b08 + a09 * b09 + a08 * b10,\n        a10 * b09 + a09 * b10,\n        a10 * b10,\n        0\n    })\nend\n\n--- Computes a double-width sum of two numbers.\n--- @param a0 MpUW11L24 The low 11 limbs of a.\n--- @param a1 MpUW11L24 The high 11 limbs of a.\n--- @param b0 MpUW11L24 The low 11 limbs of b.\n--- @param b1 MpUW11L24 The high 11 limbs of b.\n--- @return MpUW11L24 c0 The low 11 limbs of a + b.\n--- @return MpUW11L24 c1 The high 11 limbs of a + b.\n--- @return number The carry.\nlocal function dwadd(a0, a1, b0, b1)\n    local low, c = carry(add(a0, b0))\n    local high = add(a1, b1)\n    high[1] = high[1] + c\n    return low, carry(high)\nend\n\n--- Computes half of a number.\n--- @param a MpSW11L24 The number to halve, must be even.\n--- @return MpSW11L24 c a \195\183 2\nlocal function half(a)\n    local a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10 = unpack(a)\n\n    return (carryWeak {\n        a00 * 0.5 + a01 * 2 ^ 23,\n        a02 * 2 ^ 23,\n        a03 * 2 ^ 23,\n        a04 * 2 ^ 23,\n        a05 * 2 ^ 23,\n        a06 * 2 ^ 23,\n        a07 * 2 ^ 23,\n        a08 * 2 ^ 23,\n        a09 * 2 ^ 23,\n        a10 * 2 ^ 23,\n        0,\n    })\nend\n\n--- Computes a third of a number.\n--- @param a MpSW11L24 The number to divide, must be a multiple of 3.\n--- @return MpSW11L24 c a \195\183 3\nlocal function third(a)\n    local a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10 = unpack(a)\n\n    local d00 = a00 * 0xaaaaaa\n    local d01 = a01 * 0xaaaaaa + d00\n    local d02 = a02 * 0xaaaaaa + d01\n    local d03 = a03 * 0xaaaaaa + d02\n    local d04 = a04 * 0xaaaaaa + d03\n    local d05 = a05 * 0xaaaaaa + d04\n    local d06 = a06 * 0xaaaaaa + d05\n    local d07 = a07 * 0xaaaaaa + d06\n    local d08 = a08 * 0xaaaaaa + d07\n    local d09 = a09 * 0xaaaaaa + d08\n    local d10 = a10 * 0xaaaaaa + d09\n\n    -- We compute the modular division mod 2\194\178\226\129\182\226\129\180. The carry isn't 0 but it isn't\n    -- part of a \195\183 3 either.\n    return (carryWeak {\n        a00 + d00,\n        a01 + d01,\n        a02 + d02,\n        a03 + d03,\n        a04 + d04,\n        a05 + d05,\n        a06 + d06,\n        a07 + d07,\n        a08 + d08,\n        a09 + d09,\n        a10 + d10,\n    })\nend\n\n--- Computes a number modulo 2.\n--- @param a MpSW11L24\n--- @return number c a mod 2.\nlocal function mod2(a)\n    return a[1] % 2\nend\n\n--- Computes a number modulo 3.\n--- @param a MpSW11L24\n--- @return number c a mod 3.\nlocal function mod3(a)\n    local a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10 = unpack(a)\n    return (a00 + a01 + a02 + a03 + a04 + a05 + a06 + a07 + a08 + a09 + a10) % 3\nend\n\n--- Computes a double representing the most-significant bits of a number.\n--- @param a MpSW11L52\n--- @return number c A floating-point approximation for the value of a.\nlocal function approx(a)\n    local a00, a01, a02, a03, a04, a05, a06, a07, a08, a09, a10 = unpack(a)\n    return a00\n         + a01 * 2 ^ 24\n         + a02 * 2 ^ 48\n         + a03 * 2 ^ 72\n         + a04 * 2 ^ 96\n         + a05 * 2 ^ 120\n         + a06 * 2 ^ 144\n         + a07 * 2 ^ 168\n         + a08 * 2 ^ 192\n         + a09 * 2 ^ 216\n         + a10 * 2 ^ 240\nend\n\n--- Compares two numbers for ordering.\n--- @param a MpSW11L24\n--- @param b MpSW11L24\n--- @return number ord Some number with ord < 0 iff a < b and ord = 0 iff a = b.\nlocal function cmp(a, b)\n    return approx(sub(a, b))\nend\n\nlocal function num(a)\n    return {a, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}\nend\n\nreturn {\n    carry = carry,\n    carryWeak = carryWeak,\n    add = add,\n    sub = sub,\n    dwadd = dwadd,\n    lmul = lmul,\n    mul = mul,\n    half = half,\n    third = third,\n    mod2 = mod2,\n    mod3 = mod3,\n    approx = approx,\n    cmp = cmp,\n    num = num,\n}\n/50             1689962612  0     0     775     5343      `\n--- High-performance binary packing of integers.\n---\n--- Remark (and warning):\n--- For performance reasons, **the generated functions do not check types,\n--- lengths, nor ranges**. You must ensure that the passed arguments are\n--- well-formed and respect the format string yourself.\n\nlocal fmt = string.format\n\nlocal function mkPack(words, BE)\n    local out = \"local C=string.char return function(_,\"\n    local nb = 0\n    for i = 1, #words do\n        out = out .. fmt(\"n%d,\", i)\n        nb = nb + words[i]\n    end\n    out = out:sub(1, -2) .. \")local \"\n    for i = 1, nb do\n        out = out .. fmt(\"b%d,\", i)\n    end\n    out = out:sub(1, -2) .. \" \"\n    local bi = 1\n    for i = 1, #words do\n        for _ = 1, words[i] - 1 do\n            out = out .. fmt(\"b%d=n%d%%2^8 n%d=(n%d-b%d)*2^-8 \", bi, i, i, i, bi)\n            bi = bi + 1\n        end\n        bi = bi + 1\n    end\n    out = out .. \"return C(\"\n    bi = 1\n    if not BE then\n        for i = 1, #words do\n            for _ = 1, words[i] - 1 do\n                out = out .. fmt(\"b%d,\", bi)\n                bi = bi + 1\n            end\n            out = out .. fmt(\"n%d%%2^8,\", i)\n            bi = bi + 1\n        end\n    else\n        for i = 1, #words do\n            out = out .. fmt(\"n%d%%2^8,\", i)\n            bi = bi + words[i] - 2\n            for _ = 1, words[i] - 1 do\n                out = out .. fmt(\"b%d,\", bi)\n                bi = bi - 1\n            end\n            bi = bi + words[i] + 1\n        end\n    end\n    out = out:sub(1, -2) .. \")end\"\n    return load(out)()\nend\n\nlocal function mkUnpack(words, BE)\n    local out = \"local B=string.byte return function(_,s,i)local \"\n    local bi = 1\n    if not BE then\n        for i = 1, #words do\n            for _ = 1, words[i] do\n                out = out .. fmt(\"b%d,\", bi)\n                bi = bi + 1\n            end\n        end\n    else\n        for i = 1, #words do\n            bi = bi + words[i] - 1\n            for _ = 1, words[i] do\n                out = out .. fmt(\"b%d,\", bi)\n                bi = bi - 1\n            end\n            bi = bi + words[i] + 1\n        end\n    end\n    out = out:sub(1, -2) .. fmt(\"=B(s,i,i+%d)return \", bi - 2)\n    bi = 1\n    for i = 1, #words do\n        out = out .. fmt(\"b%d\", bi)\n        bi = bi + 1\n        for j = 2, words[i] do\n            out = out .. fmt(\"+b%d*2^%d\", bi, 8 * j - 8)\n            bi = bi + 1\n        end\n        out = out .. \",\"\n    end\n    out = out .. fmt(\"i+%d end\", bi - 1)\n    return load(out)()\nend\n\n-- Check whether string.pack is implemented in a high-speed language.\nif not string.pack or pcall(string.dump, string.pack) then\n    local function compile(fmt, fn)\n        local e = assert(fmt:match(\"^([><])I[I%d]+$\"), \"invalid format string\")\n        local w = {}\n        for i in fmt:gmatch(\"I([%d]+)\") do\n            local n = tonumber(i) or 4\n            assert(n > 0 and n <= 16, \"integral size out of limits\")\n            w[#w + 1] = n\n        end\n        return fn(w, e == \">\")\n    end\n\n    local packCache = {}\n    local unpackCache = {}\n\n    -- I CAN'T EVEN WITH THIS EXTENSION, WHY CAN'T IT HANDLE MORE THAN A SINGLE\n    -- LINE OF RETURN DESCRIPTION? LOOK AT IT!!! THE COMMENT GOES OVER THERE ------------------------------------------------------------------> look! \226\134\147 \226\134\147 \226\134\147\n\n    --- (string.pack is nil) Compiles a binary packing function.\n    ---\n    --- Errors if the format string is invalid or has an invalid integral size,\n    --- or if the compiled function turns out too large.\n    ---\n    --- @param fmt string A string matched by `^([><])I[I%d]+$`.\n    --- @return fun(_ignored: any, ...: any): string pack A function that behaves like an unsafe version of `string.pack` for the given format string.\n    --- @return string fmt\n    local function compilePack(fmt)\n        if not packCache[fmt] then\n            packCache[fmt] = compile(fmt, mkPack)\n        end\n        return packCache[fmt], fmt\n    end\n\n    --- (string.pack is nil) Compiles a binary unpacking function.\n    ---\n    --- Errors if the format string is invalid or has an invalid integral size,\n    --- or if the compiled function turns out too large.\n    ---\n    --- @param fmt string A string matched by `^([><])I[I%d]+$`.\n    --- @return fun(_ignored: any, str: string, pos: number) unpack A function that behaves like an unsafe version of `string.unpack` for the given format string. Note that the third argument isn't optional.\n    --- @return string fmt\n    local function compileUnpack(fmt)\n        if not unpackCache[fmt] then\n            unpackCache[fmt] = compile(fmt, mkUnpack)\n        end\n        return unpackCache[fmt], fmt\n    end\n\n    return {\n        compilePack = compilePack,\n        compileUnpack = compileUnpack,\n    }\nelse\n    --- (string.pack isn't nil) It's string.pack! It returns string.pack!\n    --- @param fmt string\n    --- @return fun(fmt: string, ...: any): string pack string.pack!\n    --- @return string fmt\n    local function compilePack(fmt) return string.pack, fmt end\n\n    --- (string.pack isn't nil) It's string.unpack! It returns string.unpack!\n    --- @param fmt string\n    --- @return fun(fmt: string, str: string, pos: number) unpack string.unpack!\n    --- @return string fmt\n    local function compileUnpack(fmt) return string.unpack, fmt end\n\n    return {\n        compilePack = compilePack,\n        compileUnpack = compileUnpack,\n    }\nend\n\n/71             1686753801  0     0     775     6832      `\n--- The SHA512 cryptographic hash function.\n\nlocal expect  = require \"system.expect\".expect\nlocal packing = require \"internal_packing\"\n\nlocal shl = bit32.lshift\nlocal shr = bit32.rshift\nlocal bxor = bit32.bxor\nlocal bnot = bit32.bnot\nlocal band = bit32.band\nlocal p1x16, fmt1x16 = packing.compilePack(\">I16\")\nlocal p16x4, fmt16x4 = packing.compilePack(\">I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\")\nlocal u32x4, fmt32x4 = packing.compileUnpack(\">I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4I4\")\n\nlocal function carry64(a1, a0)\n    local r0 = a0 % 2 ^ 32\n    a1 = a1 + (a0 - r0) / 2 ^ 32\n    return a1 % 2 ^ 32, r0\nend\n\nlocal K = {\n    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f,\n    0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,\n    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242,\n    0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,\n    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235,\n    0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,\n    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275,\n    0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,\n    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f,\n    0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,\n    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc,\n    0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,\n    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6,\n    0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,\n    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218,\n    0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,\n    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99,\n    0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,\n    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc,\n    0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,\n    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915,\n    0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,\n    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba,\n    0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,\n    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc,\n    0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,\n    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817,\n}\n\n--- Hashes data bytes using SHA512.\n--- @param data string The input data.\n--- @return string hash The 64-byte hash value.\nlocal function digest(data)\n    expect(1, data, \"string\")\n\n    -- Pad input.\n    local bitlen = #data * 8\n    local padlen = -(#data + 17) % 128\n    data = data .. \"\\x80\" .. (\"\\0\"):rep(padlen) .. p1x16(fmt1x16, bitlen)\n\n    -- Initialize state.\n    local h01, h00 = 0x6a09e667, 0xf3bcc908\n    local h11, h10 = 0xbb67ae85, 0x84caa73b\n    local h21, h20 = 0x3c6ef372, 0xfe94f82b\n    local h31, h30 = 0xa54ff53a, 0x5f1d36f1\n    local h41, h40 = 0x510e527f, 0xade682d1\n    local h51, h50 = 0x9b05688c, 0x2b3e6c1f\n    local h61, h60 = 0x1f83d9ab, 0xfb41bd6b\n    local h71, h70 = 0x5be0cd19, 0x137e2179\n\n    -- Digest.\n    for i = 1, #data, 128 do\n        local w = {u32x4(fmt32x4, data, i)}\n\n        -- Message schedule.\n        for j = 33, 160, 2 do\n            local wf1, wf0 = w[j - 30], w[j - 29]\n            local t1 = shr(wf1, 1) + shl(wf0, 31)\n            local t0 = shr(wf0, 1) + shl(wf1, 31)\n            local u1 = shr(wf1, 8) + shl(wf0, 24)\n            local u0 = shr(wf0, 8) + shl(wf1, 24)\n            local v1 = shr(wf1, 7)\n            local v0 = shr(wf0, 7) + shl(wf1, 25)\n\n            local w21, w20 = w[j - 4], w[j - 3]\n            local w1 = shr(w21, 19) + shl(w20, 13)\n            local w0 = shr(w20, 19) + shl(w21, 13)\n            local x0 = shr(w21, 29) + shl(w20, 3)\n            local x1 = shr(w20, 29) + shl(w21, 3)\n            local y1 = shr(w21, 6)\n            local y0 = shr(w20, 6) + shl(w21, 26)\n\n            local r1, r0 =\n                w[j - 32] + bxor(t1, u1, v1) + w[j - 14] + bxor(w1, x1, y1),\n                w[j - 31] + bxor(t0, u0, v0) + w[j - 13] + bxor(w0, x0, y0)\n\n            w[j], w[j + 1] = carry64(r1, r0)\n        end\n\n        -- Block function.\n        local a1, a0 = h01, h00\n        local b1, b0 = h11, h10\n        local c1, c0 = h21, h20\n        local d1, d0 = h31, h30\n        local e1, e0 = h41, h40\n        local f1, f0 = h51, h50\n        local g1, g0 = h61, h60\n        local h1, h0 = h71, h70\n        for j = 1, 160, 2 do\n            local t1 = shr(e1, 14) + shl(e0, 18)\n            local t0 = shr(e0, 14) + shl(e1, 18)\n            local u1 = shr(e1, 18) + shl(e0, 14)\n            local u0 = shr(e0, 18) + shl(e1, 14)\n            local v0 = shr(e1, 9) + shl(e0, 23)\n            local v1 = shr(e0, 9) + shl(e1, 23)\n            local s11 = bxor(t1, u1, v1)\n            local s10 = bxor(t0, u0, v0)\n\n            local ch1 = bxor(band(e1, f1), band(bnot(e1), g1))\n            local ch0 = bxor(band(e0, f0), band(bnot(e0), g0))\n\n            local temp11 = h1 + s11 + ch1 + K[j] + w[j]\n            local temp10 = h0 + s10 + ch0 + K[j + 1] + w[j + 1]\n\n            local w1 = shr(a1, 28) + shl(a0, 4)\n            local w0 = shr(a0, 28) + shl(a1, 4)\n            local x0 = shr(a1, 2) + shl(a0, 30)\n            local x1 = shr(a0, 2) + shl(a1, 30)\n            local y0 = shr(a1, 7) + shl(a0, 25)\n            local y1 = shr(a0, 7) + shl(a1, 25)\n            local s01 = bxor(w1, x1, y1)\n            local s00 = bxor(w0, x0, y0)\n\n            local maj1 = bxor(band(a1, b1), band(a1, c1), band(b1, c1))\n            local maj0 = bxor(band(a0, b0), band(a0, c0), band(b0, c0))\n\n            local temp21 = s01 + maj1\n            local temp20 = s00 + maj0\n\n            h1 = g1  h0 = g0\n            g1 = f1  g0 = f0\n            f1 = e1  f0 = e0\n            e1, e0 = carry64(d1 + temp11, d0 + temp10)\n            d1 = c1  d0 = c0\n            c1 = b1  c0 = b0\n            b1 = a1  b0 = a0\n            a1, a0 = carry64(temp11 + temp21, temp10 + temp20)\n        end\n\n        h01, h00 = carry64(h01 + a1, h00 + a0)\n        h11, h10 = carry64(h11 + b1, h10 + b0)\n        h21, h20 = carry64(h21 + c1, h20 + c0)\n        h31, h30 = carry64(h31 + d1, h30 + d0)\n        h41, h40 = carry64(h41 + e1, h40 + e0)\n        h51, h50 = carry64(h51 + f1, h50 + f0)\n        h61, h60 = carry64(h61 + g1, h60 + g0)\n        h71, h70 = carry64(h71 + h1, h70 + h0)\n    end\n\n    return p16x4(fmt16x4,\n        h01, h00, h11, h10, h21, h20, h31, h30,\n        h41, h40, h51, h50, h61, h60, h71, h70\n    )\nend\n\nreturn {\n    digest = digest,\n}\n/91             1686753801  0     0     775     1843      `\nlocal function lassert(val, err, level)\n    if not val then error(err, level + 1) end\n    return val\nend\n\n--- Converts a little-endian array from one power-of-two base to another.\n--- @param a number[] The array to convert, in little-endian.\n--- @param base1 number The base to convert from. Must be a power of 2.\n--- @param base2 number The base to convert to. Must be a power of 2.\n--- @return number[]\nlocal function rebaseLE(a, base1, base2) -- TODO Write contract properly.\n    local out = {}\n    local outlen = 1\n    local acc = 0\n    local mul = 1\n    for i = 1, #a do\n        acc = acc + a[i] * mul\n        mul = mul * base1\n        while mul >= base2 do\n            local rem = acc % base2\n            acc = (acc - rem) / base2\n            mul = mul / base2\n            out[outlen] = rem\n            outlen = outlen + 1\n        end\n    end\n    if mul > 0 then\n        out[outlen] = acc\n    end\n    return out\nend\n\n--- Decodes bits with X25519/Ed25519 exponent clamping.\n--- @param str string The 32-byte encoded exponent.\n--- @return number[] bits The decoded clamped bits.\nlocal function bits(str)\n    -- Decode.\n    local bytes = {str:byte(1, 32)}\n    local out = {}\n    for i = 1, 32 do\n        local byte = bytes[i]\n        for j = -7, 0 do\n            local bit = byte % 2\n            out[8 * i + j] = bit\n            byte = (byte - bit) / 2\n        end\n    end\n\n    -- Clamp.\n    out[1] = 0\n    out[2] = 0\n    out[3] = 0\n    out[255] = 1\n    out[256] = 0\n\n    return out\nend\n\n--- Decodes bits with X25519/Ed25519 exponent clamping and division by 8.\n--- @param str string The 32-byte encoded exponent.\n--- @return number[] bits The decoded clamped bits, divided by 8.\nlocal function bits8(str)\n    return {unpack(bits(str), 4)}\nend\n\nreturn {\n    lassert = lassert,\n    rebaseLE = rebaseLE,\n    bits = bits,\n    bits8 = bits8,\n}\n\n",created=1704748610573,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=117636},["LibDeflate.lua"]={modified=1704748611329,data="local a;do local b=\"1.0.2-release\"local c=\"LibDeflate\"local d=3;local e=\"LibDeflate \"..b..\" Copyright (C) 2018-2021 Haoqian He.\"..\" Licensed under the zlib License\"if LibStub then local f,g=LibStub:GetLibrary(c,true)if f and g and g>=d then return f else a=LibStub:NewLibrary(c,d)end else a={}end;a._VERSION=b;a._MAJOR=c;a._MINOR=d;a._COPYRIGHT=e end;local assert=assert;local error=error;local pairs=pairs;local h=string.byte;local i=string.char;local j=string.find;local k=string.gsub;local l=string.sub;local m=table.concat;local n=table.sort;local tostring=tostring;local type=type;local o={}local p={}local q={}local r={}local s={}local t={}local u={}local v={}local w={}local x={3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258}local y={0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0}local z={[0]=1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577}local A={[0]=0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13}local B={16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15}local C;local D;local E;local F;local G;local H;local I;local J;for K=0,255 do p[K]=i(K)end;do local L=1;for K=0,32 do o[K]=L;L=L*2 end end;for K=1,9 do q[K]={}for M=0,o[K+1]-1 do local N=0;local O=M;for P=1,K do N=N-N%2+((N%2==1 or O%2==1)and 1 or 0)O=(O-O%2)/2;N=N*2 end;q[K][M]=(N-N%2)/2 end end;do local Q=18;local R=16;local S=265;local T=1;for U=3,258 do if U<=10 then r[U]=U+254;t[U]=0 elseif U==258 then r[U]=285;t[U]=0 else if U>Q then Q=Q+R;R=R*2;S=S+4;T=T+1 end;local V=U-Q-1+R/2;r[U]=(V-V%(R/8))/(R/8)+S;t[U]=T;s[U]=V%(R/8)end end end;do u[1]=0;u[2]=1;w[1]=0;w[2]=0;local Q=3;local R=4;local W=2;local T=0;for X=3,256 do if X>R then Q=Q*2;R=R*2;W=W+2;T=T+1 end;u[X]=X<=Q and W or W+1;w[X]=T<0 and 0 or T;if R>=8 then v[X]=(X-R/2-1)%(R/4)end end end;local Y,Z,_,a0,a1=bit32.band,bit32.bnot,bit32.bxor,bit32.lshift,bit32.rshift;local a2=0xEDB88320;local function a3(a4)local a5={}local V=setmetatable({},a5)function a5:__index(a6)local a7=a4(a6)V[a6]=a7;return a7 end;return V end;local a8=a3(function(K)local a9=K;for P=1,8 do local R=Y(a9,1)a9=a1(a9,1)if R==1 then a9=_(a9,a2)end end;return a9 end)local function aa(ab,a9)a9=Z(a9 or 0)local ac=a1(a9,8)local ad=a8[_(a9%256,ab)]return Z(_(ac,ad))end;local function ae(af,a9)a9=a9 or 0;for K=1,#af do a9=aa(af:byte(K),a9)end;return a9 end;function a:CRC32(af,a9)if type(af)=='string'then return ae(af,a9)else return aa(af,a9)end end;function a:Adler32(ag)if type(ag)~=\"string\"then error((\"Usage: LibDeflate:Adler32(str):\"..\" 'str' - string expected got '%s'.\"):format(type(ag)),2)end;local ah=#ag;local K=1;local Q=1;local R=0;while K<=ah-15 do local ai,aj,ak,al,am,an,ao,ap,aq,ar,as,at,au,av,aw,ax=h(ag,K,K+15)R=(R+16*Q+16*ai+15*aj+14*ak+13*al+12*am+11*an+10*ao+9*ap+8*aq+7*ar+6*as+5*at+4*au+3*av+2*aw+ax)%65521;Q=(Q+ai+aj+ak+al+am+an+ao+ap+aq+ar+as+at+au+av+aw+ax)%65521;K=K+16 end;while K<=ah do local ay=h(ag,K,K)Q=(Q+ay)%65521;R=(R+Q)%65521;K=K+1 end;return(R*65536+Q)%4294967296 end;local function az(aA,aB)return aA%4294967296==aB%4294967296 end;function a:CreateDictionary(ag,ah,aC)if type(ag)~=\"string\"then error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\"..\" 'str' - string expected got '%s'.\"):format(type(ag)),2)end;if type(ah)~=\"number\"then error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\"..\" 'strlen' - number expected got '%s'.\"):format(type(ah)),2)end;if type(aC)~=\"number\"then error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\"..\" 'adler32' - number expected got '%s'.\"):format(type(aC)),2)end;if ah~=#ag then error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\"..\" 'strlen' does not match the actual length of 'str'.\"..\" 'strlen': %u, '#str': %u .\"..\" Please check if 'str' is modified unintentionally.\"):format(ah,#ag))end;if ah==0 then error(\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\"..\" 'str' - Empty string is not allowed.\",2)end;if ah>32768 then error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\"..\" 'str' - string longer than 32768 bytes is not allowed.\"..\" Got %d bytes.\"):format(ah),2)end;local aD=self:Adler32(ag)if not az(aC,aD)then error((\"Usage: LibDeflate:CreateDictionary(str, strlen, adler32):\"..\" 'adler32' does not match the actual adler32 of 'str'.\"..\" 'adler32': %u, 'Adler32(str)': %u .\"..\" Please check if 'str' is modified unintentionally.\"):format(aC,aD))end;local aE={}aE.adler32=aC;aE.hash_tables={}aE.string_table={}aE.strlen=ah;local aF=aE.string_table;local aG=aE.hash_tables;aF[1]=h(ag,1,1)aF[2]=h(ag,2,2)if ah>=3 then local K=1;local aH=aF[1]*256+aF[2]while K<=ah-2-3 do local ai,aj,ak,al=h(ag,K+2,K+5)aF[K+2]=ai;aF[K+3]=aj;aF[K+4]=ak;aF[K+5]=al;aH=(aH*256+ai)%16777216;local V=aG[aH]if not V then V={}aG[aH]=V end;V[#V+1]=K-ah;K=K+1;aH=(aH*256+aj)%16777216;V=aG[aH]if not V then V={}aG[aH]=V end;V[#V+1]=K-ah;K=K+1;aH=(aH*256+ak)%16777216;V=aG[aH]if not V then V={}aG[aH]=V end;V[#V+1]=K-ah;K=K+1;aH=(aH*256+al)%16777216;V=aG[aH]if not V then V={}aG[aH]=V end;V[#V+1]=K-ah;K=K+1 end;while K<=ah-2 do local ay=h(ag,K+2)aF[K+2]=ay;aH=(aH*256+ay)%16777216;local V=aG[aH]if not V then V={}aG[aH]=V end;V[#V+1]=K-ah;K=K+1 end end;return aE end;local function aI(aE)if type(aE)~=\"table\"then return false,(\"'dictionary' - table expected got '%s'.\"):format(type(aE))end;if type(aE.adler32)~=\"number\"or type(aE.string_table)~=\"table\"or type(aE.strlen)~=\"number\"or aE.strlen<=0 or aE.strlen>32768 or aE.strlen~=#aE.string_table or type(aE.hash_tables)~=\"table\"then return false,(\"'dictionary' - corrupted dictionary.\"):format(type(aE))end;return true,\"\"end;local aJ={[0]={false,nil,0,0,0},[1]={false,nil,4,8,4},[2]={false,nil,5,18,8},[3]={false,nil,6,32,32},[4]={true,4,4,16,16},[5]={true,8,16,32,32},[6]={true,8,16,128,128},[7]={true,8,32,128,256},[8]={true,32,128,258,1024},[9]={true,32,258,258,4096}}local function aK(ag,aL,aE,aM,aN)if type(ag)~=\"string\"then return false,(\"'str' - string expected got '%s'.\"):format(type(ag))end;if aL then local aO,aP=aI(aE)if not aO then return false,aP end end;if aM then local aQ=type(aN)if aQ~=\"nil\"and aQ~=\"table\"then return false,(\"'configs' - nil or table expected got '%s'.\"):format(type(aN))end;if aQ==\"table\"then for a6,a7 in pairs(aN)do if a6~=\"level\"and a6~=\"strategy\"then return false,(\"'configs' - unsupported table key in the configs: '%s'.\"):format(a6)elseif a6==\"level\"and not aJ[a7]then return false,(\"'configs' - unsupported 'level': %s.\"):format(tostring(a7))elseif a6==\"strategy\"and a7~=\"fixed\"and a7~=\"huffman_only\"and a7~=\"dynamic\"then return false,(\"'configs' - unsupported 'strategy': '%s'.\"):format(tostring(a7))end end end end;return true,\"\"end;local aR=0;local aS=1;local aT=2;local aU=3;local function aV()local aW=0;local aX=0;local aY=0;local aZ=0;local a_={}local b0={}local function b1(O,T)aX=aX+O*o[aY]aY=aY+T;aZ=aZ+T;if aY>=32 then aW=aW+1;a_[aW]=p[aX%256]..p[(aX-aX%256)/256%256]..p[(aX-aX%65536)/65536%256]..p[(aX-aX%16777216)/16777216%256]local b2=o[32-aY+T]aX=(O-O%b2)/b2;aY=aY-32 end end;local function b3(ag)for P=1,aY,8 do aW=aW+1;a_[aW]=i(aX%256)aX=(aX-aX%256)/256 end;aY=0;aW=aW+1;a_[aW]=ag;aZ=aZ+#ag*8 end;local function b4(b5)if b5==aU then return aZ end;if b5==aS or b5==aT then local b6=(8-aY%8)%8;if aY>0 then aX=aX-o[aY]+o[aY+b6]for P=1,aY,8 do aW=aW+1;a_[aW]=p[aX%256]aX=(aX-aX%256)/256 end;aX=0;aY=0 end;if b5==aT then aZ=aZ+b6;return aZ end end;local b7=m(a_)a_={}aW=0;b0[#b0+1]=b7;if b5==aR then return aZ else return aZ,m(b0)end end;return b1,b3,b4 end;local function b8(b9,ba,bb)bb=bb+1;b9[bb]=ba;local O=ba[1]local bc=bb;local bd=(bc-bc%2)/2;while bd>=1 and b9[bd][1]>O do local V=b9[bd]b9[bd]=ba;b9[bc]=V;bc=bd;bd=(bd-bd%2)/2 end end;local function be(b9,bb)local bf=b9[1]local ba=b9[bb]local O=ba[1]b9[1]=ba;b9[bb]=bf;bb=bb-1;local bc=1;local bg=bc*2;local bh=bg+1;while bg<=bb do local bi=b9[bg]if bh<=bb and b9[bh][1]<bi[1]then local bj=b9[bh]if bj[1]<O then b9[bh]=ba;b9[bc]=bj;bc=bh;bg=bc*2;bh=bg+1 else break end else if bi[1]<O then b9[bg]=ba;b9[bc]=bi;bc=bg;bg=bc*2;bh=bg+1 else break end end end;return bf end;local function bk(bl,bm,bn,bo)local bp=0;local bq={}local br={}for T=1,bo do bp=(bp+(bl[T-1]or 0))*2;bq[T]=bp end;for bs=0,bn do local T=bm[bs]if T then bp=bq[T]bq[T]=bp+1;if T<=9 then br[bs]=q[T][bp]else local N=0;for P=1,T do N=N-N%2+((N%2==1 or bp%2==1)and 1 or 0)bp=(bp-bp%2)/2;N=N*2 end;br[bs]=(N-N%2)/2 end end end;return br end;local function bt(Q,R)return Q[1]<R[1]or Q[1]==R[1]and Q[2]<R[2]end;local function bu(bv,bo,bn)local bb;local bw=-1;local bx={}local b9={}local bm={}local by={}local bl={}local bz=0;for bs,bA in pairs(bv)do bz=bz+1;bx[bz]={bA,bs}end;if bz==0 then return{},{},-1 elseif bz==1 then local bs=bx[1][2]bm[bs]=1;by[bs]=0;return bm,by,bs else n(bx,bt)bb=bz;for K=1,bb do b9[K]=bx[K]end;while bb>1 do local bB=be(b9,bb)bb=bb-1;local bC=be(b9,bb)bb=bb-1;local bD={bB[1]+bC[1],-1,bB,bC}b8(b9,bD,bb)bb=bb+1 end;local bE=0;local bF={b9[1],0,0,0}local bG=1;local bH=1;b9[1][1]=0;while bH<=bG do local ba=bF[bH]local T=ba[1]local bs=ba[2]local bi=ba[3]local bj=ba[4]if bi then bG=bG+1;bF[bG]=bi;bi[1]=T+1 end;if bj then bG=bG+1;bF[bG]=bj;bj[1]=T+1 end;bH=bH+1;if T>bo then bE=bE+1;T=bo end;if bs>=0 then bm[bs]=T;bw=bs>bw and bs or bw;bl[T]=(bl[T]or 0)+1 end end;if bE>0 then repeat local T=bo-1;while(bl[T]or 0)==0 do T=T-1 end;bl[T]=bl[T]-1;bl[T+1]=(bl[T+1]or 0)+2;bl[bo]=bl[bo]-1;bE=bE-2 until bE<=0;bH=1;for T=bo,1,-1 do local bI=bl[T]or 0;while bI>0 do local bs=bx[bH][2]bm[bs]=T;bI=bI-1;bH=bH+1 end end end;by=bk(bl,bm,bn,bo)return bm,by,bw end end;local function bJ(bK,bL,bM,bN)local bO=0;local bP={}local bQ={}local bR=0;local bS={}local bT=nil;local bA=0;bN=bN<0 and 0 or bN;local bU=bL+bN+1;for W=0,bU+1 do local U=W<=bL and(bK[W]or 0)or(W<=bU and(bM[W-bL-1]or 0)or nil)if U==bT then bA=bA+1;if U~=0 and bA==6 then bO=bO+1;bP[bO]=16;bR=bR+1;bS[bR]=3;bQ[16]=(bQ[16]or 0)+1;bA=0 elseif U==0 and bA==138 then bO=bO+1;bP[bO]=18;bR=bR+1;bS[bR]=127;bQ[18]=(bQ[18]or 0)+1;bA=0 end else if bA==1 then bO=bO+1;bP[bO]=bT;bQ[bT]=(bQ[bT]or 0)+1 elseif bA==2 then bO=bO+1;bP[bO]=bT;bO=bO+1;bP[bO]=bT;bQ[bT]=(bQ[bT]or 0)+2 elseif bA>=3 then bO=bO+1;local bV=bT~=0 and 16 or(bA<=10 and 17 or 18)bP[bO]=bV;bQ[bV]=(bQ[bV]or 0)+1;bR=bR+1;bS[bR]=bA<=10 and bA-3 or bA-11 end;bT=U;if U and U~=0 then bO=bO+1;bP[bO]=U;bQ[U]=(bQ[U]or 0)+1;bA=0 else bA=1 end end end;return bP,bS,bQ end;local function bW(ag,V,bX,bY,bZ)local K=bX-bZ;while K<=bY-15-bZ do V[K],V[K+1],V[K+2],V[K+3],V[K+4],V[K+5],V[K+6],V[K+7],V[K+8],V[K+9],V[K+10],V[K+11],V[K+12],V[K+13],V[K+14],V[K+15]=h(ag,K+bZ,K+15+bZ)K=K+16 end;while K<=bY-bZ do V[K]=h(ag,K+bZ,K+bZ)K=K+1 end;return V end;local function b_(c0,aF,aG,c1,c2,bZ,aE)local c3=aJ[c0]local c4,c5,c6,c7,c8=c3[1],c3[2],c3[3],c3[4],c3[5]local c9=not c4 and c6 or 2147483646;local ca=c8-c8%4/4;local aH;local cb;local cc;local cd=0;if aE then cb=aE.hash_tables;cc=aE.string_table;cd=aE.strlen;assert(c1==1)if c2>=c1 and cd>=2 then aH=cc[cd-1]*65536+cc[cd]*256+aF[1]local V=aG[aH]if not V then V={}aG[aH]=V end;V[#V+1]=-1 end;if c2>=c1+1 and cd>=1 then aH=cc[cd]*65536+aF[1]*256+aF[2]local V=aG[aH]if not V then V={}aG[aH]=V end;V[#V+1]=0 end end;local ce=cd+3;aH=(aF[c1-bZ]or 0)*256+(aF[c1+1-bZ]or 0)local cf={}local cg=0;local ch={}local ci={}local cj=0;local ck={}local cl={}local cm=0;local cn={}local co=0;local cp=false;local cq;local cr;local cs=0;local ct=0;local bH=c1;local cu=c2+(c4 and 1 or 0)while bH<=cu do local cv=bH-bZ;local cw=bZ-3;cq=cs;cr=ct;cs=0;aH=(aH*256+(aF[cv+2]or 0))%16777216;local cx;local cy;local cz=aG[aH]local cA;if not cz then cA=0;cz={}aG[aH]=cz;if cb then cy=cb[aH]cx=cy and#cy or 0 else cx=0 end else cA=#cz;cy=cz;cx=cA end;if bH<=c2 then cz[cA+1]=bH end;if cx>0 and bH+2<=c2 and(not c4 or cq<c6)then local cB=c4 and cq>=c5 and ca or c8;local cC=c2-bH;cC=cC>=257 and 257 or cC;cC=cC+cv;local cD=cv+3;while cx>=1 and cB>0 do local bT=cy[cx]if bH-bT>32768 then break end;if bT<bH then local cE=cD;if bT>=-257 then local cF=bT-cw;while cE<=cC and aF[cF]==aF[cE]do cE=cE+1;cF=cF+1 end else local cF=ce+bT;while cE<=cC and cc[cF]==aF[cE]do cE=cE+1;cF=cF+1 end end;local M=cE-cv;if M>cs then cs=M;ct=bH-bT end;if cs>=c7 then break end end;cx=cx-1;cB=cB-1;if cx==0 and bT>0 and cb then cy=cb[aH]cx=cy and#cy or 0 end end end;if not c4 then cq,cr=cs,ct end;if(not c4 or cp)and(cq>3 or cq==3 and cr<4096)and cs<=cq then local W=r[cq]local cG=t[cq]local cH,cI,cJ;if cr<=256 then cH=u[cr]cJ=v[cr]cI=w[cr]else cH=16;cI=7;local Q=384;local R=512;while true do if cr<=Q then cJ=(cr-R/2-1)%(R/4)break elseif cr<=R then cJ=(cr-R/2-1)%(R/4)cH=cH+1;break else cH=cH+2;cI=cI+1;Q=Q*2;R=R*2 end end end;cg=cg+1;cf[cg]=W;ch[W]=(ch[W]or 0)+1;cj=cj+1;ci[cj]=cH;ck[cH]=(ck[cH]or 0)+1;if cG>0 then local cK=s[cq]cm=cm+1;cl[cm]=cK end;if cI>0 then co=co+1;cn[co]=cJ end;for K=bH+1,bH+cq-(c4 and 2 or 1)do aH=(aH*256+(aF[K-bZ+2]or 0))%16777216;if cq<=c9 then cz=aG[aH]if not cz then cz={}aG[aH]=cz end;cz[#cz+1]=K end end;bH=bH+cq-(c4 and 1 or 0)cp=false elseif not c4 or cp then local W=aF[c4 and cv-1 or cv]cg=cg+1;cf[cg]=W;ch[W]=(ch[W]or 0)+1;bH=bH+1 else cp=true;bH=bH+1 end end;cg=cg+1;cf[cg]=256;ch[256]=(ch[256]or 0)+1;return cf,cl,ch,ci,cn,ck end;local function cL(ch,ck)local cM,cN,bL=bu(ch,15,285)local cO,cP,bN=bu(ck,15,29)local cQ,bS,cR=bJ(cM,bL,cO,bN)local cS,cT=bu(cR,7,18)local cU=0;for K=1,19 do local bs=B[K]local cV=cS[bs]or 0;if cV~=0 then cU=K end end;cU=cU-4;local cW=bL+1-257;local cX=bN+1-1;if cX<0 then cX=0 end;return cW,cX,cU,cS,cT,cQ,bS,cM,cN,cO,cP end;local function cY(cf,ci,cU,cS,cQ,cM,cO)local cZ=17;cZ=cZ+(cU+4)*3;for K=1,#cQ do local W=cQ[K]cZ=cZ+cS[W]if W>=16 then cZ=cZ+(W==16 and 2 or(W==17 and 3 or 7))end end;local c_=0;for K=1,#cf do local W=cf[K]local d0=cM[W]cZ=cZ+d0;if W>256 then c_=c_+1;if W>264 and W<285 then local d1=y[W-256]cZ=cZ+d1 end;local cH=ci[c_]local d2=cO[cH]cZ=cZ+d2;if cH>3 then local cI=(cH-cH%2)/2-1;cZ=cZ+cI end end end;return cZ end;local function d3(b1,d4,cf,cl,ci,cn,cW,cX,cU,cS,cT,cQ,bS,cM,cN,cO,cP)b1(d4 and 1 or 0,1)b1(2,2)b1(cW,5)b1(cX,5)b1(cU,4)for K=1,cU+4 do local bs=B[K]local cV=cS[bs]or 0;b1(cV,3)end;local d5=1;for K=1,#cQ do local W=cQ[K]b1(cT[W],cS[W])if W>=16 then local d6=bS[d5]b1(d6,W==16 and 2 or(W==17 and 3 or 7))d5=d5+1 end end;local c_=0;local d7=0;local d8=0;for K=1,#cf do local d9=cf[K]local bp=cN[d9]local d0=cM[d9]b1(bp,d0)if d9>256 then c_=c_+1;if d9>264 and d9<285 then d7=d7+1;local da=cl[d7]local d1=y[d9-256]b1(da,d1)end;local db=ci[c_]local dc=cP[db]local d2=cO[db]b1(dc,d2)if db>3 then d8=d8+1;local cJ=cn[d8]local cI=(db-db%2)/2-1;b1(cJ,cI)end end end end;local function dd(cf,ci)local cZ=3;local c_=0;for K=1,#cf do local W=cf[K]local d0=E[W]cZ=cZ+d0;if W>256 then c_=c_+1;if W>264 and W<285 then local d1=y[W-256]cZ=cZ+d1 end;local cH=ci[c_]cZ=cZ+5;if cH>3 then local cI=(cH-cH%2)/2-1;cZ=cZ+cI end end end;return cZ end;local function de(b1,d4,cf,cl,ci,cn)b1(d4 and 1 or 0,1)b1(1,2)local c_=0;local d7=0;local d8=0;for K=1,#cf do local df=cf[K]local bp=C[df]local d0=E[df]b1(bp,d0)if df>256 then c_=c_+1;if df>264 and df<285 then d7=d7+1;local da=cl[d7]local d1=y[df-256]b1(da,d1)end;local cH=ci[c_]local dc=G[cH]b1(dc,5)if cH>3 then d8=d8+1;local cJ=cn[d8]local cI=(cH-cH%2)/2-1;b1(cJ,cI)end end end end;local function dg(c1,c2,aZ)assert(c2-c1+1<=65535)local cZ=3;aZ=aZ+3;local b6=(8-aZ%8)%8;cZ=cZ+b6;cZ=cZ+32;cZ=cZ+(c2-c1+1)*8;return cZ end;local function dh(b1,b3,d4,ag,c1,c2,aZ)assert(c2-c1+1<=65535)b1(d4 and 1 or 0,1)b1(0,2)aZ=aZ+3;local b6=(8-aZ%8)%8;if b6>0 then b1(o[b6]-1,b6)end;local di=c2-c1+1;b1(di,16)local dj=255-di%256+(255-(di-di%256)/256)*256;b1(dj,16)b3(ag:sub(c1,c2))end;local function dk(aN,b1,b3,b4,ag,aE)local aF={}local aG={}local d4=nil;local c1;local c2;local dl;local aZ=b4(aU)local ah=#ag;local bZ;local c0;local dm;if aN then if aN.level then c0=aN.level end;if aN.strategy then dm=aN.strategy end end;if not c0 then if ah<2048 then c0=7 elseif ah>65536 then c0=3 else c0=5 end end;while not d4 do if not c1 then c1=1;c2=64*1024-1;bZ=0 else c1=c2+1;c2=c2+32*1024;bZ=c1-32*1024-1 end;if c2>=ah then c2=ah;d4=true else d4=false end;local cf,cl,ch,ci,cn,ck;local cW,cX,cU,cS,cT,cQ,bS,cM,cN,cO,cP;local dn;local dp;local dq;if c0~=0 then bW(ag,aF,c1,c2+3,bZ)if c1==1 and aE then local cc=aE.string_table;local dr=aE.strlen;for K=0,-dr+1<-257 and-257 or-dr+1,-1 do aF[K]=cc[dr+K]end end;if dm==\"huffman_only\"then cf={}bW(ag,cf,c1,c2,c1-1)cl={}ch={}cf[c2-c1+2]=256;for K=1,c2-c1+2 do local W=cf[K]ch[W]=(ch[W]or 0)+1 end;ci={}cn={}ck={}else cf,cl,ch,ci,cn,ck=b_(c0,aF,aG,c1,c2,bZ,aE)end;cW,cX,cU,cS,cT,cQ,bS,cM,cN,cO,cP=cL(ch,ck)dn=cY(cf,ci,cU,cS,cQ,cM,cO)dp=dd(cf,ci)end;dq=dg(c1,c2,aZ)local ds=dq;ds=dp and dp<ds and dp or ds;ds=dn and dn<ds and dn or ds;if c0==0 or dm~=\"fixed\"and dm~=\"dynamic\"and dq==ds then dh(b1,b3,d4,ag,c1,c2,aZ)aZ=aZ+dq elseif dm~=\"dynamic\"and(dm==\"fixed\"or dp==ds)then de(b1,d4,cf,cl,ci,cn)aZ=aZ+dp elseif dm==\"dynamic\"or dn==ds then d3(b1,d4,cf,cl,ci,cn,cW,cX,cU,cS,cT,cQ,bS,cM,cN,cO,cP)aZ=aZ+dn end;if d4 then dl=b4(aU)else dl=b4(aR)end;assert(dl==aZ)if not d4 then local M;if aE and c1==1 then M=0;while aF[M]do aF[M]=nil;M=M-1 end end;aE=nil;M=1;for K=c2-32767,c2 do aF[M]=aF[K-bZ]M=M+1 end;for a6,V in pairs(aG)do local dt=#V;if dt>0 and c2+1-V[1]>32768 then if dt==1 then aG[a6]=nil else local du={}local dv=0;for K=2,dt do M=V[K]if c2+1-M<=32768 then dv=dv+1;du[dv]=M end end;aG[a6]=du end end end end end end;local function dw(ag,aE,aN)local b1,b3,b4=aV()dk(aN,b1,b3,b4,ag,aE)local aZ,dx=b4(aS)local b6=(8-aZ%8)%8;return dx,b6 end;local function dy(ag,aE,aN)local b1,b3,b4=aV()local dz=8;local dA=7;local dB=dA*16+dz;b1(dB,8)local dC=aE and 1 or 0;local dD=2;local dE=dD*64+dC*32;local dF=31-(dB*256+dE)%31;dE=dE+dF;b1(dE,8)if dC==1 then local aC=aE.adler32;local dG=aC%256;aC=(aC-dG)/256;local dH=aC%256;aC=(aC-dH)/256;local dI=aC%256;aC=(aC-dI)/256;local dJ=aC%256;b1(dJ,8)b1(dI,8)b1(dH,8)b1(dG,8)end;dk(aN,b1,b3,b4,ag,aE)b4(aT)local aC=a:Adler32(ag)local dJ=aC%256;aC=(aC-dJ)/256;local dI=aC%256;aC=(aC-dI)/256;local dH=aC%256;aC=(aC-dH)/256;local dG=aC%256;b1(dG,8)b1(dH,8)b1(dI,8)b1(dJ,8)local aZ,dx=b4(aS)local b6=(8-aZ%8)%8;return dx,b6 end;function a:CompressDeflate(ag,aN)local dK,dL=aK(ag,false,nil,true,aN)if not dK then error(\"Usage: LibDeflate:CompressDeflate(str, configs): \"..dL,2)end;return dw(ag,nil,aN)end;function a:CompressDeflateWithDict(ag,aE,aN)local dK,dL=aK(ag,true,aE,true,aN)if not dK then error(\"Usage: LibDeflate:CompressDeflateWithDict\"..\"(str, dictionary, configs): \"..dL,2)end;return dw(ag,aE,aN)end;function a:CompressZlib(ag,aN)local dK,dL=aK(ag,false,nil,true,aN)if not dK then error(\"Usage: LibDeflate:CompressZlib(str, configs): \"..dL,2)end;return dy(ag,nil,aN)end;function a:CompressZlibWithDict(ag,aE,aN)local dK,dL=aK(ag,true,aE,true,aN)if not dK then error(\"Usage: LibDeflate:CompressZlibWithDict\"..\"(str, dictionary, configs): \"..dL,2)end;return dy(ag,aE,aN)end;local function ab(dM,R)return Y(a1(dM,R*8),0xFF)end;function a:CompressGzip(ag,aN)local dK,dL=aK(ag,false,nil,true,aN)if not dK then error(\"Usage: LibDeflate:CompressGzip(str, configs): \"..dL,2)end;local dN,dO=dw(ag,nil,aN)if dN==nil then return dN,dO end;local V=os.time()local dP=0;local a9=self:CRC32(ag)local U=string.len(ag)if aN~=nil and aN.level~=nil then if aN.level==0 then dP=0x04 elseif aN.level==9 then dP=0x02 end end;return i(0x1f,0x8b,8,0,ab(V,0),ab(V,1),ab(V,2),ab(V,3),dP,0xFF)..dN..i(ab(a9,0),ab(a9,1),ab(a9,2),ab(a9,3),ab(U,0),ab(U,1),ab(U,2),ab(U,3))end;local function dQ(dR)local dS=dR;local dT=#dR;local dU=1;local aY=0;local aX=0;local function dV(T)local b2=o[T]local W;if T<=aY then W=aX%b2;aX=(aX-W)/b2;aY=aY-T else local dW=o[aY]local dH,dI,dJ,dX=h(dS,dU,dU+3)aX=aX+((dH or 0)+(dI or 0)*256+(dJ or 0)*65536+(dX or 0)*16777216)*dW;dU=dU+4;aY=aY+32-T;W=aX%b2;aX=(aX-W)/b2 end;return W end;local function dY(dZ,a_,aW)assert(aY%8==0)local d_=aY/8<dZ and aY/8 or dZ;for P=1,d_ do local ab=aX%256;aW=aW+1;a_[aW]=i(ab)aX=(aX-ab)/256 end;aY=aY-d_*8;dZ=dZ-d_;if(dT-dU-dZ+1)*8+aY<0 then return-1 end;for K=dU,dU+dZ-1 do aW=aW+1;a_[aW]=l(dS,K,K)end;dU=dU+dZ;return aW end;local function e0(e1,e2,ds)local W=0;local e3=0;local bH=0;local bA;if ds>0 then if aY<15 and dS then local dW=o[aY]local dH,dI,dJ,dX=h(dS,dU,dU+3)aX=aX+((dH or 0)+(dI or 0)*256+(dJ or 0)*65536+(dX or 0)*16777216)*dW;dU=dU+4;aY=aY+32 end;local b2=o[ds]aY=aY-ds;W=aX%b2;aX=(aX-W)/b2;W=q[ds][W]bA=e1[ds]if W<bA then return e2[W]end;bH=bA;e3=bA*2;W=W*2 end;for T=ds+1,15 do local e4;e4=aX%2;aX=(aX-e4)/2;aY=aY-1;W=e4==1 and W+1-W%2 or W;bA=e1[T]or 0;local e5=W-e3;if e5<bA then return e2[bH+e5]end;bH=bH+bA;e3=e3+bA;e3=e3*2;W=W*2 end;return-10 end;local function e6()return(dT-dU+1)*8+aY end;local function e7()local e8=aY%8;local b2=o[e8]aY=aY-e8;aX=(aX-aX%b2)/b2 end;return dV,dY,e0,e6,e7 end;local function e9(ag,aE)local dV,dY,e0,e6,e7=dQ(ag)local ea={ReadBits=dV,ReadBytes=dY,Decode=e0,ReaderBitlenLeft=e6,SkipToByteBoundary=e7,buffer_size=0,buffer={},result_buffer={},dictionary=aE}return ea end;local function eb(ec,bn,bo)local e1={}local ds=bo;for bs=0,bn do local T=ec[bs]or 0;ds=T>0 and T<ds and T or ds;e1[T]=(e1[T]or 0)+1 end;if e1[0]==bn+1 then return 0,e1,{},0 end;local ed=1;for U=1,bo do ed=ed*2;ed=ed-(e1[U]or 0)if ed<0 then return ed end end;local ee={}ee[1]=0;for U=1,bo-1 do ee[U+1]=ee[U]+(e1[U]or 0)end;local e2={}for bs=0,bn do local T=ec[bs]or 0;if T~=0 then local bZ=ee[T]e2[bZ]=bs;ee[T]=ee[T]+1 end end;return ed,e1,e2,ds end;local function ef(ea,cM,eg,eh,cO,ei,ej)local a_,aW,dV,e0,e6,b0=ea.buffer,ea.buffer_size,ea.ReadBits,ea.Decode,ea.ReaderBitlenLeft,ea.result_buffer;local aE=ea.dictionary;local cc;local dr;local ek=1;if aE and not a_[0]then cc=aE.string_table;dr=aE.strlen;ek=-dr+1;for K=0,-dr+1<-257 and-257 or-dr+1,-1 do a_[K]=p[cc[dr+K]]end end;repeat local bs=e0(cM,eg,eh)if bs<0 or bs>285 then return-10 elseif bs<256 then aW=aW+1;a_[aW]=p[bs]elseif bs>256 then bs=bs-256;local T=x[bs]T=bs>=8 and T+dV(y[bs])or T;bs=e0(cO,ei,ej)if bs<0 or bs>29 then return-10 end;local X=z[bs]X=X>4 and X+dV(A[bs])or X;local el=aW-X+1;if el<ek then return-11 end;if el>=-257 then for P=1,T do aW=aW+1;a_[aW]=a_[el]el=el+1 end else el=dr+el;for P=1,T do aW=aW+1;a_[aW]=p[cc[el]]el=el+1 end end end;if e6()<0 then return 2 end;if aW>=65536 then b0[#b0+1]=m(a_,\"\",1,32768)for K=32769,aW do a_[K-32768]=a_[K]end;aW=aW-32768;a_[aW+1]=nil end until bs==256;ea.buffer_size=aW;return 0 end;local function em(ea)local a_,aW,dV,dY,e6,e7,b0=ea.buffer,ea.buffer_size,ea.ReadBits,ea.ReadBytes,ea.ReaderBitlenLeft,ea.SkipToByteBoundary,ea.result_buffer;e7()local dZ=dV(16)if e6()<0 then return 2 end;local en=dV(16)if e6()<0 then return 2 end;if dZ%256+en%256~=255 then return-2 end;if(dZ-dZ%256)/256+(en-en%256)/256~=255 then return-2 end;aW=dY(dZ,a_,aW)if aW<0 then return 2 end;if aW>=65536 then b0[#b0+1]=m(a_,\"\",1,32768)for K=32769,aW do a_[K-32768]=a_[K]end;aW=aW-32768;a_[aW+1]=nil end;ea.buffer_size=aW;return 0 end;local function eo(ea)return ef(ea,F,D,7,J,H,5)end;local function ep(ea)local dV,e0=ea.ReadBits,ea.Decode;local eq=dV(5)+257;local er=dV(5)+1;local es=dV(4)+4;if eq>286 or er>30 then return-3 end;local cS={}for K=1,es do cS[B[K]]=dV(3)end;local et,eu,ev,ew=eb(cS,18,7)if et~=0 then return-4 end;local cM={}local cO={}local bH=0;while bH<eq+er do local bs;local T;bs=e0(eu,ev,ew)if bs<0 then return bs elseif bs<16 then if bH<eq then cM[bH]=bs else cO[bH-eq]=bs end;bH=bH+1 else T=0;if bs==16 then if bH==0 then return-5 end;if bH-1<eq then T=cM[bH-1]else T=cO[bH-eq-1]end;bs=3+dV(2)elseif bs==17 then bs=3+dV(3)else bs=11+dV(7)end;if bH+bs>eq+er then return-6 end;while bs>0 do bs=bs-1;if bH<eq then cM[bH]=T else cO[bH-eq]=T end;bH=bH+1 end end end;if(cM[256]or 0)==0 then return-9 end;local ex,ey,eg,eh=eb(cM,eq-1,15)if ex~=0 and(ex<0 or eq~=(ey[0]or 0)+(ey[1]or 0))then return-7 end;local ez,eA,ei,ej=eb(cO,er-1,15)if ez~=0 and(ez<0 or er~=(eA[0]or 0)+(eA[1]or 0))then return-8 end;return ef(ea,ey,eg,eh,eA,ei,ej)end;local function eB(ea)local dV=ea.ReadBits;local d4;while not d4 do d4=dV(1)==1;local eC=dV(2)local eD;if eC==0 then eD=em(ea)elseif eC==1 then eD=eo(ea)elseif eC==2 then eD=ep(ea)else return nil,-1 end;if eD~=0 then return nil,eD end end;ea.result_buffer[#ea.result_buffer+1]=m(ea.buffer,\"\",1,ea.buffer_size)local dx=m(ea.result_buffer)return dx end;local function eE(ag,aE)local ea=e9(ag,aE)local dx,eD=eB(ea)if not dx then return nil,eD end;local eF=ea.ReaderBitlenLeft()local eG=(eF-eF%8)/8;return dx,eG end;local function eH(ag,aE)local ea=e9(ag,aE)local dV=ea.ReadBits;local dB=dV(8)if ea.ReaderBitlenLeft()<0 then return nil,2 end;local dz=dB%16;local dA=(dB-dz)/16;if dz~=8 then return nil,-12 end;if dA>7 then return nil,-13 end;local dE=dV(8)if ea.ReaderBitlenLeft()<0 then return nil,2 end;if(dB*256+dE)%31~=0 then return nil,-14 end;local dC=(dE-dE%32)/32%2;local dD=(dE-dE%64)/64%4;if dC==1 then if not aE then return nil,-16 end;local dJ=dV(8)local dI=dV(8)local dH=dV(8)local dG=dV(8)local aD=dJ*16777216+dI*65536+dH*256+dG;if ea.ReaderBitlenLeft()<0 then return nil,2 end;if not az(aD,aE.adler32)then return nil,-17 end end;local dx,eD=eB(ea)if not dx then return nil,eD end;ea.SkipToByteBoundary()local eI=dV(8)local eJ=dV(8)local eK=dV(8)local eL=dV(8)if ea.ReaderBitlenLeft()<0 then return nil,2 end;local eM=eI*16777216+eJ*65536+eK*256+eL;local eN=a:Adler32(dx)if not az(eM,eN)then return nil,-15 end;local eF=ea.ReaderBitlenLeft()local eG=(eF-eF%8)/8;return dx,eG end;function a:DecompressDeflate(ag)local dK,dL=aK(ag)if not dK then error(\"Usage: LibDeflate:DecompressDeflate(str): \"..dL,2)end;return eE(ag)end;function a:DecompressDeflateWithDict(ag,aE)local dK,dL=aK(ag,true,aE)if not dK then error(\"Usage: LibDeflate:DecompressDeflateWithDict(str, dictionary): \"..dL,2)end;return eE(ag,aE)end;function a:DecompressZlib(ag)local dK,dL=aK(ag)if not dK then error(\"Usage: LibDeflate:DecompressZlib(str): \"..dL,2)end;return eH(ag)end;function a:DecompressZlibWithDict(ag,aE)local dK,dL=aK(ag,true,aE)if not dK then error(\"Usage: LibDeflate:DecompressZlibWithDict(str, dictionary): \"..dL,2)end;return eH(ag,aE)end;function a:DecompressGzip(ag)local dK,dL=aK(ag)if not dK then error(\"Usage: LibDeflate:DecompressGzip(str): \"..dL,2)end;if h(string.sub(ag,1,1))~=31 or h(string.sub(ag,2,2))~=139 then return nil,-1 end;if Y(h(string.sub(ag,4,4)),0xE0)~=0 then return nil,-3 end;if h(string.sub(ag,3,3))~=8 then return nil,-4 end;local bZ=10;if Y(h(string.sub(ag,4,4)),4)==4 then bZ=bZ+h(string.sub(ag,11,11))*256+h(string.sub(ag,12,12))end;if Y(h(string.sub(ag,4,4)),8)==8 then while h(string.sub(ag,bZ,bZ))~=0 do bZ=bZ+1 end end;if Y(h(string.sub(ag,4,4)),16)==16 then while h(string.sub(ag,bZ,bZ))~=0 do bZ=bZ+1 end end;if Y(h(string.sub(ag,4,4)),2)==2 then local eO=h(string.sub(ag,bZ+1,bZ+1))*256+h(string.sub(ag,bZ,bZ))local eP=Y(self:CRC32(string.sub(ag,1,bZ-1)),0xFFFF)if _(eO,eP)~=0xFFFF then return nil,-5 end;bZ=bZ+2 end;local dN,dO=eE(string.sub(ag,bZ+1,-8))if dN==nil then return dN,dO end;local eO=h(string.sub(ag,-5,-5))*0x1000000+h(string.sub(ag,-6,-6))*0x10000+h(string.sub(ag,-7,-7))*256+h(string.sub(ag,-8,-8))eO=Z(eO)local eP=self:CRC32(dN)if _(eO,eP)~=0xFFFFFFFF then return nil,-2 end;return dN end;do E={}for eQ=0,143 do E[eQ]=8 end;for eQ=144,255 do E[eQ]=9 end;for eQ=256,279 do E[eQ]=7 end;for eQ=280,287 do E[eQ]=8 end;I={}for X=0,31 do I[X]=5 end;local eD;eD,F,D=eb(E,287,9)assert(eD==0)eD,J,H=eb(I,31,5)assert(eD==0)C=bk(F,E,287,9)G=bk(J,I,31,5)end;a.internals={LoadStringToTable=bW,IsValidDictionary=aI,IsEqualAdler32=az,_byte_to_6bit_char=_byte_to_6bit_char,_6bit_to_byte=_6bit_to_byte,InternalClearCache=InternalClearCache}return a\n",created=1704748611335,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=27630},dpkg={modified=1704748610875,created=1704748610875,contents={["divert.lua"]={modified=1704748610847,data="local a=require\"system.filesystem\"local b={}b.admindir=\"/var/lib/dpkg\"function b.parse()local c=io.open(a.combine(b.admindir,\"diversions\"),\"r\")local d=1;local e={}local f;for g in c:lines()do if d==1 then e[g]={}f=g elseif d==2 then e[f].name=g elseif d==3 then e[f].package=g end;d=d+1;if d>3 then d=1 end end;c:close()return e end;function b.get(c,h,i)i=i or b.parse()local e=i[c]if not e or e.package==h then return nil end;return e end;local function j(k)a.copy(a.combine(b.admindir,\"diversions\"),a.combine(b.admindir,\"diversions-old\"))local c=a.open(a.combine(b.admindir,\"diversions\"),\"w\")for l,m in pairs(k)do c.writeLine(l)c.writeLine(m.name)c.writeLine(m.package)end;c.close()end;function b.add(n,o,h)local p=b.parse()p[n]={name=o or n..\".distrib\",package=h or\":\"}j(p)end;function b.remove(n)local p=b.parse()p[n]=nil;j(p)end;return b\n",created=1704748610872,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=843},["query.lua"]={modified=1704748610849,data="local a=require\"system.filesystem\"local b=require\"control\"local function c(d)return string.match(d,'^()[%s%z]*$')and''or string.match(d,'^[%s%z]*(.*[^%s%z])')end;local e={status={not_installed=1,config_files=2,half_installed=3,unpacked=4,half_configured=5,triggers_awaited=6,triggers_pending=7,installed=8}}e.admindir=\"/var/lib/dpkg\"if not a.isDir(e.admindir)then a.mkdir(e.admindir)end;function e.readDatabase()local f=io.open(a.combine(e.admindir,\"status\"),\"r\")if f==nil then error(\"Couldn't find status file\")end;local g={{}}local h=nil;local d=1;for i in f:lines()do if i==\"\"then d=d+1;g[d]={}h=nil else if string.sub(i,1,1)==\" \"and h~=nil then if h==\"Description\"then if type(g[d][h])==\"string\"then g[d][h]={Short=g[d][h],Long=\"\"}end;g[d][h].Long=g[d][h].Long..(string.sub(i,2)==\".\"and\"\\n\\n\"or string.sub(i,2))else g[d][h]=g[d][h]..(string.sub(i,2)==\".\"and\"\\n\\n\"or string.sub(i,2))end else h=string.sub(i,1,(string.find(i,\":\")or 0)-1)g[d][h]=c(string.sub(i,(string.find(i,\":\")or-1)+1))end end end;f:close()local j={}for k,l in pairs(g)do if l.Package then j[l.Package]=l end end;return j end;function e.writeDatabase(m)a.copy(a.combine(e.admindir,\"status\"),a.combine(e.admindir,\"status-old\"))local f=a.open(a.combine(e.admindir,\"status\"),\"w\")if f==nil then error(\"Couldn't find status file\")end;local function n(l)if type(l)==\"table\"then return(l.Short or\"\")..\"\\n \"..string.gsub(l.Long or\"\",\"\\n\\n\",\"\\n .\\n\")else return l end end;for k,l in pairs(m)do if not(string.match(l.Status,\"(%S+) %S+ %S+\")==\"unknown\"and string.match(l.Status,\"%S+ %S+ (%S+)\")==\"not-installed\")then f.writeLine(\"Package: \"..k)for o,p in pairs(l)do if o~=\"Package\"and o~=\"Description\"then f.writeLine(o..\": \"..n(p))end end;if l.Description then f.writeLine(\"Description: \"..n(l.Description))end;f.writeLine(\"\")end end;f.close()end;function e.findPackage(q,r)r=r or e.readDatabase()for k,l in pairs(r)do if q==k then return l,r end end;return nil,r end;function e.readFileLists()local g={duplicates={}}local s=0;for t,l in ipairs(a.find(a.combine(e.admindir,\"info/*.list\")))do local u=string.match(l,\"info/(.+)%.list$\")local f=io.open(l,\"r\")for i in f:lines()do if g[i]~=nil and not a.isDir(i)then g.duplicates[i]=g.duplicates[i]or{}table.insert(g.duplicates[i],u)else g[i]=u;s=s+1 end end end;return g,s end;function e.status.configured(v)return v==\"triggers-pending\"or v==\"installed\"end;function e.status.present(v)return v~=\"not-installed\"and v~=\"config-files\"and v~=\"half-installed\"end;function e.status.needs_configure(v)return v==\"config-failed\"or v==\"half-configured\"or v==\"unpacked\"end;function e.status.get_number(v)for k,l in ipairs({\"not-installed\",\"config-files\",\"half-installed\",\"unpacked\",\"half-configured\",\"triggers-awaited\",\"triggers-pending\",\"installed\"})do if l==v then return k end end;return nil end;return e\n",created=1704748610874,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=2805},["init.lua"]={modified=1704748610848,data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=(function()local d={__add=true,__sub=true,__mul=true,__div=true,__mod=true,__pow=true,__unm=true,__concat=true,__len=true,__eq=true,__lt=true,__le=true,__newindex=true,__call=true,__metatable=true}local function e(f,g,...)local h=getfenv(g)h.self=f;h.super=setmetatable({},{__index=getmetatable(f).__index})setfenv(g,h)return g(...)end;local function i(j,k,l)local m,n={__class=j},{}if l.static then for o,p in pairs(l.static)do if d[o]then n[o]=p else m[o]=p end end end;l.static=nil;if k.extends then if k.extends[1]then n.__index=function(self,j)for q,p in ipairs(k.extends)do if p[j]then return p[j]end end end else n.__index=k.extends end end;local r=l.__init;l.__init=nil;n.__call=function(self,...)local s,t={},{}local f=setmetatable({__class=j},s)if k.extends and not r then if k.extends[1]then for q,p in ipairs(k.extends)do t[q]=p()end;s.__index=function(self,j)for q,p in ipairs(t)do if p[j]then return p[j]end end end else s.__index=k.extends(...)end end;for o,p in pairs(l)do if type(p)==\"function\"then f[o]=function(...)return e(f,p,...)end elseif o~=\"__class\"then f[o]=p end;if d[o]then s[o]=f[o]f[o]=nil end end;if r then local h=getfenv(r)h.self=f;h.super=setmetatable({},{__index=s.__index})if k.extends then if k.extends[1]then s.__index=function(self,j)if#t<#k.extends then for q,p in ipairs(k.extends)do t[q]=p()end end;for q,p in ipairs(t)do if p[j]then return p[j]end end end;for q,p in ipairs(k.extends)do h[p.__class]=function(...)t[q]=p(...)end end else s.__index=function(self,j)s.__index=k.extends()return s.__index[j]end;h[k.extends.__class]=function(...)s.__index=k.extends(...)end end end;setfenv(r,h)r(...)if k.extends and k.extends[1]then s.__index=function(self,j)for q,p in ipairs(t)do if p[j]then return p[j]end end end end end;return f end;setmetatable(m,n)return m end;return setmetatable({},{__call=function(self,j)return function(u)if u.extends or u.implements then return function(v)return i(j,u,v)end else return i(j,{},u)end end end})end)()local w=require\"diff\"local x=require\"control\"local y=require\"deb\"local z=require\"divert\"local A=require\"query\"local B=require\"trigger\"local C=require\"sha2\"local D=require\"tar\"local E={}E.admindir=\"/var/lib/dpkg\"E.rootdir=\"/\"E.write=io.write;E.print=print;E.read=io.read;E.warn=function(F)print(\"dpkg: warning: \"..F)end;E.error=function(F)print(\"dpkg: \\x1b[31merror:\\x1b[0m \"..F)end;E.debug=function(F)end;local function G(H)return a.combine(E.admindir,H)end;local function I(H)return a.combine(E.rootdir,H)end;local function J(K)return string.match(K,'^()[%s%z]*$')and''or string.match(K,'^[%s%z]*(.*[^%s%z])')end;local function L(M)local N=a.open(M,\"r\")local O=N.readAll()N.close()return O end;local function P(M)local O={}for Q in io.lines(M)do table.insert(O,Q)end;return O end;local function R(M,S)local N=a.open(M,\"w\")N.write(S)N.close()end;local function T(M,U)local N=a.open(M,\"w\")for V,p in ipairs(U)do N.writeLine(p)end;N.close()end;local function W(X,Y)return({string.match(X.Status,\"(%S+) (%S+) (%S+)\")})[Y]end;local function Z(X,Y,_)local a0={string.match(X.Status,\"(%S+) (%S+) (%S+)\")}a0[Y]=_;X.Status=table.concat(a0,\" \")return X.Status end;local function a1(a2,a3)local a4={}for K in string.gmatch(a2,\"([^\"..(a3 or\"%s\")..\"]+)\")do table.insert(a4,K)end;return a4 end;local function a5(F)local b=io.popen(\"/bin/less\",\"w\")b:write(F)b:close()end;local a6={preinst=\"postrm\",prerm=\"postinst\",postrm=\"preinst\"}self={}E.options={triggers=true,pager=true,auto_deconfigure=false,skip_same_version=false,dry_run=false,ignore_depends={}}E.force={downgrade=false,configure_any=false,hold=false,remove_reinstreq=false,remove_essential=false,depends=false,depends_version=false,breaks=false,conflicts=false,confmiss=false,confmode=nil,overwrite=false,overwrite_dir=false,overwrite_diverted=false,statoverride_add=false,statoverride_remove=false,architecture=false,bad_version=false,bad_verify=false}local a7=_G.package;E.package=c\"package\"{static={packagedb=nil,triggerdb=nil,filedb=nil,filecount=0,scriptCallStack={},setPackageDB=function(a8)E.package.packagedb=a8 or A.readDatabase()end,setTriggerDB=function(a8)E.package.triggerdb=a8 or B.readDatabase()end,setFileDB=function(a8,a9)if a8 then E.package.filedb,E.package.filecount=a8,a9 else E.package.filedb,E.package.filecount=A.readFileLists()end end,unwindScriptErrors=function(aa)local O=true;while#E.package.scriptCallStack>0 do local ab=table.remove(E.package.scriptCallStack)if a6[ab.script]then local ac=ab.pkg.callMaintainerScript(a6[ab.script],\"abort-\"..ab.args[1],table.unpack(ab.args,2,ab.args.n))if aa then aa(ab.pkg,ac,ab.script,table.unpack(ab.args,1,ab.args.n))end;if not ac then O=false end end end;return O end,clearScriptErrors=function()E.package.scriptCallStack={}end},__init=function(M)if a.exists(M)then local ad=y.load(M,true)self.isUnpacked=false;self.name=ad.name;self.path=a.basename(M)self.files=ad.data;self.filelist=nil;self.control=ad.control;self.controlArchive=ad.control_archive;self.conffiles=ad.conffiles;self.md5sums=ad.md5sums;self.preinst=ad.preinst;self.postinst=ad.postinst;self.prerm=ad.prerm;self.postrm=ad.postrm;self.triggers=ad.triggers elseif E.package.packagedb~=nil and E.package.packagedb[M]~=nil then self.isUnpacked=true;self.name=M;self.path=nil;self.files=nil;self.filelist=a.exists(G(\"info/\"..M..\".list\"))and P(G(\"info/\"..M..\".list\"))or nil;self.control=E.package.packagedb[M]self.controlArchive=nil;self.conffiles=a.exists(G(\"info/\"..M..\".conffiles\"))and P(G(\"info/\"..M..\".conffiles\"))or nil;if a.exists(G(\"info/\"..M..\".md5sums\"))then local ae=L(G(\"info/\"..M..\".md5sums\"))self.md5sums={}for af in string.gmatch(ae,\"[^\\n]+\")do local o,p=af:match(\"^(%x+)  (.+)$\")if o then self.md5sums[\"/\"..p]=o end end end;self.preinst=a.exists(G(\"info/\"..M..\".preinst\"))and L(G(\"info/\"..M..\".preinst\"))or nil;self.postinst=a.exists(G(\"info/\"..M..\".postinst\"))and L(G(\"info/\"..M..\".postinst\"))or nil;self.prerm=a.exists(G(\"info/\"..M..\".prerm\"))and L(G(\"info/\"..M..\".prerm\"))or nil;self.postrm=a.exists(G(\"info/\"..M..\".postrm\"))and L(G(\"info/\"..M..\".postrm\"))or nil;self.triggers=a.exists(G(\"info/\"..M..\".triggers\"))and L(G(\"info/\"..M..\".triggers\"))or nil else error(\"Could not find package \"..M)end end,callMaintainerScript=function(ag,...)local M,ah=nil,false;if string.sub(ag,#ag)=='!'then ah=true end;ag=ag:gsub(\"!$\",\"\")if self.isUnpacked or string.sub(ag,1,1)=='.'then M=G(\"info/\"..self.name..\".\"..string.gsub(ag,\"^%.\",\"\"))else M=G(\"tmp.ci/\"..ag)end;local ai=...if not ah and ai:find(\"abort\")==nil then table.insert(E.package.scriptCallStack,{pkg=self,script=ag,args=table.pack(...)})end;ag=ag:gsub(\"^%.\",\"\")if not a.exists(M)then return true end;return b.run(M,...)end,unpack=function()local self=self;if self.isUnpacked then E.error(\"internal error: attempted to unpack package without archive\")return false end;if E.package.packagedb[self.name]~=nil and W(E.package.packagedb[self.name],1)==\"hold\"then if E.force.hold then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package is currently held\")else E.error(\"package is currently held\")return false end end;if self.control.Architecture~=\"phoenix\"and self.control.Architecture~=\"all\"then if E.force.architecture then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package architecture (\"..self.control.Architecture..\") does not match the system (phoenix)\")else E.error(\"package architecture (\"..self.control.Architecture..\") does not match the system (phoenix)\")return false end end;if a.isDir(G(\"tmp.ci\"))then a.remove(G(\"tmp.ci\"))end;D.extract(self.controlArchive,G(\"tmp.ci\"))E.print(\"Preparing to unpack \"..self.path..\" ...\")local aj=false;if E.package.packagedb[self.name]~=nil and W(E.package.packagedb[self.name],3)==\"installed\"and E.compareVersions(self.control.Version,E.package.packagedb[self.name].Version)==-1 then if E.force.downgrade then E.warn(\"overriding problem because --force enabled:\")E.warn(\"downgrading \"..self.name..\" from \"..E.package.packagedb[self.name].Version..\" to \"..self.control.Version)aj=true else E.error(\"attempted to downgrade \"..self.name..\" from \"..E.package.packagedb[self.name].Version..\" to \"..self.control.Version)return false end end;local ak={}if self.control[\"Pre-Depends\"]~=nil and not aj then for V,p in ipairs(a1(self.control[\"Pre-Depends\"],\",\"))do local al,j=E.checkDependency(p,function(am,X)return A.status.configured(am)or X[\"Config-Version\"]~=nil and A.status.present(am)end)if not al and not E.options.ignore_depends[j]then table.insert(ak,{j,J(p)})end end end;if#ak>0 then if E.force.depends then E.warn(\"overriding problem because --force enabled:\")E.warn(\"dependency problems prevent unpacking of \"..self.name..\":\")for V,p in ipairs(ak)do E.print(\" \"..self.name..\" pre-depends on \"..p[2]..\"; however:\\n  Package \"..p[1]..\" is not installed.\\n\")end else E.error(\"dependency problems prevent unpacking of \"..self.name..\":\")for V,p in ipairs(ak)do E.print(\" \"..self.name..\" pre-depends on \"..p[2]..\"; however:\\n  Package \"..p[1]..\" is not installed.\\n\")end;return false end end;local an={}for o,p in pairs(E.package.packagedb)do if p.Conflicts and A.status.present(W(p,3))and E.findRelationship(self.name,self.control.Version,p.Conflicts)then table.insert(an,o)end end;if#an>0 then if E.force.conflicts then E.warn(\"overriding problem because --force enabled:\")E.warn(\"conflicting packages prevent unpacking of \"..self.name..\":\")for V,p in ipairs(an)do E.print(\" \"..p..\" conflicts with \"..self.name..\", however:\\n  Package \"..self.name..\" (\"..self.control.Version..\") is being installed.\\n\")end else E.error(\"conflicting packages prevent unpacking of \"..self.name..\":\")for V,p in ipairs(an)do E.print(\" \"..p..\" conflicts with \"..self.name..\", however:\\n  Package \"..self.name..\" (\"..self.control.Version..\") is being installed.\\n\")end;return false end end;if E.package.packagedb[self.name]~=nil and W(E.package.packagedb[self.name],3)==\"installed\"then E.debug(\"Upgrading pre-existing package (\"..E.package.packagedb[self.name].Version..\" => \"..self.control.Version..\")\")if not self.callMaintainerScript(\".prerm\",\"upgrade\",self.control.Version)then E.debug(\"Old package's prerm upgrade failed\")if not self.callMaintainerScript(\"prerm!\",\"failed-upgrade\",E.package.packagedb[self.name].Version)then E.debug(\"New package's prerm failed-upgrade failed\")if E.package.unwindScriptErrors()then E.error(\"package pre-upgrade script failed to run\")Z(E.package.packagedb[self.name],3,\"installed\")else E.debug(\"Old package's postinst abort-upgrade failed\")E.error(\"package pre-upgrade script failed to run, and old package failed to revert changes\")Z(E.package.packagedb[self.name],3,\"half-configured\")end;a.remove(G(\"tmp.ci\"))return false end end end;local ao={}do local ap,j;if self.control.Breaks~=nil then for V,p in ipairs(a1(self.control.Breaks,\",\"))do ap,j=E.checkDependency(p)if ap then ao[j]=0 end end end;if self.control.Conflicts~=nil then for V,p in ipairs(a1(self.control.Conflicts,\",\"))do ap,j=E.checkDependency(p,true)if ap then ao[j]=1 end end end end;if not E.options.auto_deconfigure and next(ao)~=nil then if E.force.conflicts then E.warn(\"dependency problems, but unpacking \"..self.name..\" anyway as you requested:\")else E.error(\"dependency problems prevent unpacking of \"..self.name..\":\")end;for p,V in ipairs(ao)do E.print(\" \"..p..\" conflicts with \"..self.name..\".\")end;if not E.force.conflicts then E.unwindScriptErrors()a.remove(G(\"tmp.ci\"))return false end end;local aq,ar=next(ao)and true or false,ao;while aq do local as,at={},{}aq=false;for o,p in pairs(E.package.packagedb)do for Q,au in pairs(ar)do if p.Depends and E.findRelationship(Q,E.package.packagedb[Q].Version,p.Depends)or p[\"Pre-Depends\"]and E.findRelationship(Q,E.package.packagedb[Q].Version,p[\"Pre-Depends\"])then aq=true;at[o]=p[\"Pre-Depends\"]and E.findRelationship(Q,E.package.packagedb[Q].Version,p[\"Pre-Depends\"])and 1 or 0;local av=E.package(o)E.debug(\"Deconfiguring \"..o..\" since it depends on conflicting package \"..Q)if av.prerm then if av.callMaintainerScript(\"prerm\",\"deconfigure\",\"in-favour\",self.name,self.control.Version,\"removing\",Q,E.package.packagedb[Q].Version)then p[\"Config-Version\"]=p.Version;Z(p,3,\"unpacked\")else E.debug(\"Deconfigure failed.\")table.insert(as,{o,Q})end else p[\"Config-Version\"]=p.Version;Z(p,3,\"unpacked\")end end end end;if#as>0 then if E.force.depends and E.force.conflicts then E.warn(\"overriding problem because --force enabled:\")E.warn(\"dependency problems prevent unpacking of \"..self.name..\":\")else E.error(\"dependency problems prevent unpacking of \"..self.name..\":\")end;for V,p in ipairs(as)do E.print(\" \"..p[1]..\" depends on \"..p[2]..\" which conflicts with \"..self.name..\", however:\")E.print(\"  deconfiguring \"..p[1]..\" failed\\n\")end;if not(E.force.depends and E.force.conflicts)then E.package.unwindScriptErrors(function(aw,ac,ag)if aw.name~=self.name and ag==\"prerm\"then if ac then Z(E.package.packagedb[aw.name],3,\"installed\")else Z(E.package.packagedb[aw.name],3,\"half-configured\")end end end)a.remove(G(\"tmp.ci\"))return false end end;ar=at end;local ax={}for o,p in pairs(ao)do if o~=self.name then local av=E.package(o)E.debug(\"Deconfiguring \"..o..\" since it conflicts with the current package\")if av.callMaintainerScript(\"prerm\",\"deconfigure\",\"in-favour\",self.name,self.control.Version)then E.package.packagedb[o][\"Config-Version\"]=E.package.packagedb[o].Version;Z(E.package.packagedb[o],3,\"unpacked\")if p==1 then Z(E.package.packagedb[o],3,\"half-installed\")if not av.callMaintainerScript(\"prerm\",\"remove\",\"in-favour\",self.name,self.control.Version)then E.debug(\"Pre-remove failed, aborting.\")table.insert(ax,o)end end else E.debug(\"Deconfigure failed, aborting.\")table.insert(ax,o)end end end;if#ax>0 then if E.force.conflicts then E.warn(\"overriding problem because --force enabled:\")E.warn(\"dependency problems prevent unpacking of \"..self.name..\":\")else E.error(\"dependency problems prevent unpacking of \"..self.name..\":\")end;for V,p in ipairs(ax)do E.print(\" \"..p..\" conflicts with \"..self.name..\", however:\")E.print(\"  deconfiguring \"..p..\" failed\\n\")end;if not E.force.conflicts then E.unwindScriptErrors(function(aw,ac,ag,...)if aw.name~=self.name and ag==\"prerm\"then if...==\"remove\"then if ac then Z(E.package.packagedb[aw.name],3,\"unpacked\")end elseif...==\"deconfigure\"then if ac then Z(E.package.packagedb[aw.name],3,\"installed\")else Z(E.package.packagedb[aw.name],3,\"half-configured\")end end end end)a.remove(G(\"tmp.ci\"))return false end end;local ay;if E.package.packagedb[self.name]~=nil and W(E.package.packagedb[self.name],3)~=\"not-installed\"then ay=E.package.packagedb[self.name].Version;if W(E.package.packagedb[self.name],3)~=\"config-files\"then E.debug(\"Upgrading from \"..E.package.packagedb[self.name].Version..\" to \"..self.control.Version)if not self.callMaintainerScript(\"preinst!\",\"upgrade\",E.package.packagedb[self.name].Version)then E.debug(\"New preinst upgrade failed\")if self.callMaintainerScript(\"postrm\",\"abort-upgrade\",E.package.packagedb[self.name].Version)then if self.callMaintainerScript(\".postinst\",\"abort-upgrade\",self.control.Version)then E.debug(\"Leaving package as-is\")E.error(\"package pre-install script failed to upgrade, leaving old version installed\")Z(E.package.packagedb[self.name],3,\"installed\")E.package.unwindScriptErrors()return false else E.debug(\"Old postinst abort-upgrade failed\")E.error(\"package pre-install script failed to upgrade, and previous version failed to revert changes\")Z(E.package.packagedb[self.name],3,\"unpacked\")E.package.unwindScriptErrors()return false end else E.debug(\"New postrm abort-upgrade failed\")E.error(\"package pre-install script failed to run\")Z(E.package.packagedb[self.name],3,\"half-installed\")E.package.unwindScriptErrors()return false end end else E.debug(\"Installing with config files\")if not self.callMaintainerScript(\"preinst\",\"install\",E.package.packagedb[self.name][\"Config-Version\"])then E.debug(\"Preinst install failed\")if E.package.unwindScriptErrors()then E.error(\"package pre-install script failed to install\")Z(E.package.packagedb[self.name],3,\"config-files\")return false else E.error(\"package pre-install script failed to run, reinstallation required\")Z(E.package.packagedb[self.name],2,\"reinstreq\")Z(E.package.packagedb[self.name],3,\"half-installed\")return false end end end else E.debug(\"Installing new\")if not self.callMaintainerScript(\"preinst\",\"install\")then E.debug(\"Preinst install failed\")if E.package.unwindScriptErrors()then E.error(\"package pre-install script failed to install\")Z(E.package.packagedb[self.name],3,\"not-installed\")return false else E.error(\"package pre-install script failed to run, reinstallation required\")Z(E.package.packagedb[self.name],2,\"reinstreq\")Z(E.package.packagedb[self.name],3,\"half-installed\")return false end end end;if ay then E.print(\"Unpacking \"..self.name..\" (\"..self.control.Version..\") over (\"..ay..\") ...\")else E.print(\"Unpacking \"..self.name..\" (\"..self.control.Version..\") ...\")end;self.filelist={}local az={}local function aA()for V,p in ipairs(self.filelist)do if not a.isDir(I(p))then a.remove(I(p..\".dpkg-new\"))if a.exists(I(p..\".dpkg-old\"))then a.rename(I(p..\".dpkg-old\"),I(p))end end end;self.filelist=nil;if E.package.packagedb[self.name]~=nil and W(E.package.packagedb[self.name],3)~=\"not-installed\"then if W(E.package.packagedb[self.name],3)~=\"config-files\"then if self.callMaintainerScript(\"postrm\",\"abort-upgrade\",E.package.packagedb[self.name].Version)then if self.callMaintainerScript(\".postinst\",\"abort-upgrade\",self.control.Version)then Z(E.package.packagedb[self.name],3,\"installed\")E.package.unwindScriptErrors()return false else E.error(\"previous version failed to revert changes\")Z(E.package.packagedb[self.name],3,\"unpacked\")E.package.unwindScriptErrors()return false end else E.error(\"package post-removal script failed to run\")Z(E.package.packagedb[self.name],3,\"half-installed\")E.package.unwindScriptErrors()return false end else if E.package.unwindScriptErrors()then Z(E.package.packagedb[self.name],3,\"config-files\")return false else E.error(\"package post-remove script failed to run, reinstallation required\")Z(E.package.packagedb[self.name],2,\"reinstreq\")Z(E.package.packagedb[self.name],3,\"half-installed\")return false end end else if E.package.unwindScriptErrors()then Z(E.package.packagedb[self.name],3,\"not-installed\")return false else E.error(\"package post-removal script failed to run, reinstallation required\")Z(E.package.packagedb[self.name],2,\"reinstreq\")Z(E.package.packagedb[self.name],3,\"half-installed\")return false end end end;local aB={}for V,p in ipairs(self.files)do local o=p.name:gsub(\"^./+\",\"/\"):gsub(\"^[^/]\",\"/%1\")E.debug(\"Writing \"..o)if E.package.filedb[o]~=nil and E.package.filedb[o]~=self.name and p.type==0 then if not(self.control.Replaces and E.findRelationship(E.package.filedb[o],E.package.packagedb[E.package.filedb[o]].Version,self.control.Replaces))then if E.force.overwrite_dir and a.isDir(I(o))or E.force.overwrite and not a.isDir(I(o))then E.warn(\"overriding problem because --force enabled:\")E.print((\"dpkg: error processing archive %s:\\n trying to overwrite '%s', which is also in package %s %s\"):format(self.path,o,E.package.filedb[o],E.package.packagedb[E.package.filedb[o]].Version))else E.print((\"dpkg: error processing archive %s:\\n trying to overwrite '%s', which is also in package %s %s\"):format(self.path,o,E.package.filedb[o],E.package.packagedb[E.package.filedb[o]].Version))return aA()end else az[E.package.filedb[o]]=az[E.package.filedb[o]]or{}table.insert(az[E.package.filedb[o]],o)end end;if p.type==5 then a.mkdir(I(o))elseif p.type==2 then a.link(I(o),p.link)elseif p.type==0 then if self.md5sums and self.md5sums[o:gsub(\"^/+\",\"\")]and C.md5(p.data)~=self.md5sums[o:gsub(\"^/+\",\"\")]then E.debug((\"Invalid checksum for file %s (expected %s, got %s)\"):format(o,self.md5sums[o:gsub(\"^/+\",\"\")],C.md5(p.data)))if E.force.bad_verify then E.warn(\"overriding problem because --force enabled:\")E.warn(\"invalid checksum for file \"..o)else E.error(\"invalid checksum for file \"..o)return aA()end end;local N=a.open(I(o..\".dpkg-new\"),\"wb\")if not N then E.print((\"dpkg: error processing archive %s:\\n could not open destination file %s.dpkg-new for writing\"):format(self.path,o))return aA()end;N.write(p.data or\"\")N.close()a.chmod(I(o..\".dpkg-new\"),nil,bit32.band(p.mode,7))a.chmod(I(o..\".dpkg-new\"),p.ownerName or\"root\",bit32.rshift(bit32.band(p.mode,0x1C0),6))a.chown(I(o..\".dpkg-new\"),p.ownerName or\"root\")if bit32.btest(p.mode,0x800)then a.chmod(I(o..\".dpkg-new\"),p.ownerName or\"root\",\"+s\")end;local aC=false;if self.conffiles and self.md5sums and E.package.packagedb[self.name]~=nil and W(E.package.packagedb[self.name],3)~=\"not-installed\"then for V,au in ipairs(self.conffiles)do if au==o then if self.md5sums[o]==E.package(self.name).md5sums[o]then if a.exists(I(o))then a.remove(I(o..\".dpkg-new\"))aC=true end elseif a.exists(I(o))and p.data~=L(o)or not a.exists(I(o))then local aD=a.exists(I(o))and E.force.confmode or(E.force.confmiss and 0 or nil)E.print(\"Configuration file `\"..o..[['\n==> Modified (by you or by a script) since installation.\n==> Package distributor has shipped an updated version.\nWhat would you like to do about it? Your options are:\n    Y or I  : install the package maintainer's version\n    N or O  : keep your currently-installed version\n    D     : show the differences between the versions\n    Z     : start a shell to examine the situation\nThe default action is to keep your current version.]])while aD==nil do E.write(\"*** \"..a.basename(o)..\" (Y/I/N/O/D/Z) [default=N] ? \")local aE=E.read()if aE==\"Y\"or aE==\"y\"or aE==\"I\"or aE==\"i\"then aD=0 elseif aE==\"N\"or aE==\"n\"or aE==\"O\"or aE==\"o\"then aD=1 elseif aE==\"D\"or aE==\"d\"then local U={}local aF=w.diff(L(o),p.data,\"\\n\")for V,aG in ipairs(aF)do if aG[2]==\"in\"then table.insert(U,\"+++ \"..aG[1])elseif aG[2]==\"out\"then table.insert(U,\"--- \"..aG[1])else table.insert(U,\"    \"..aG[1])end end;if E.options.pager then a5(table.concat(U,\"\\n\"))else E.print(table.concat(U,\"\\n\"))end elseif aE==\"Z\"or aE==\"z\"then b.run(\"/bin/sh\")elseif aE==\"\"then aD=2 end end;if aD==0 then aB[o]=true else aC=true;a.remove(I(o..\".dpkg-dist\"))a.rename(I(o..\".dpkg-new\"),I(o..\".dpkg-dist\"))end end end end end;if not aC and a.exists(I(o))then a.rename(I(o),I(o..\".dpkg-old\"))end else E.debug(\"Unknown type \"..p.type..\" for path \"..o)end;table.insert(self.filelist,o)B.activate(o,self.name,false,E.package.triggerdb,E.package.packagedb)end;if E.package.packagedb[self.name]~=nil and W(E.package.packagedb[self.name],3)~=\"not-installed\"then if not self.callMaintainerScript(\".postrm!\",\"upgrade\",self.control.Version)and not self.callMaintainerScript(\"postrm\",\"failed-upgrade\",E.package.packagedb[self.name].Version)then E.debug(\"postrm upgrade failed\")if self.callMaintainerScript(\".preinst\",\"abort-upgrade\",self.control.Version)then E.debug(\"Reverting changes\")for V,p in ipairs(self.filelist)do if not a.isDir(I(p))then a.remove(I(p..\".dpkg-new\"))if a.exists(I(p..\".dpkg-old\"))then a.rename(I(p..\".dpkg-old\"),I(p))end end end;self.filelist=nil;if not self.callMaintainerScript(\"postrm\",\"abort-upgrade\",E.package.packagedb[self.name].Version)or not self.callMaintainerScript(\".postinst\",\"abort-upgrade\",self.control.Version)then E.debug(\"postrm/.postinst abort-upgrade failed\")E.error(\"package postrm script failed to finish upgrade, and upgrade failed to abort\")Z(self.name,3,\"half-installed\")E.package.unwindScriptErrors()return false end;E.error(\"package upgrade failed to finish\")Z(self.name,3,\"unpacked\")E.package.unwindScriptErrors()return false else E.debug(\"preinst abort-upgrade failed\")E.error(\"package postrm script failed to finish upgrade, and preinst script failed to abort upgrade\")Z(self.name,3,\"half-installed\")E.package.unwindScriptErrors()return false end end;local aH=P(G(\"info/\"..self.name..\".list\"))for V,p in pairs(aH)do local aq=false;for V,au in ipairs(self.filelist)do if p==au then aq=true;break end end;if not aq then E.debug(\"Deleting removed file \"..p)a.remove(I(p))end end end;T(G(\"info/\"..self.name..\".list\"),self.filelist)if self.conffiles then T(G(\"info/\"..self.name..\".conffiles\"),self.conffiles)end;if self.md5sums then local N=a.open(G(\"info/\"..self.name..\".md5sums\"),\"w\")for o,p in pairs(self.md5sums)do N.writeLine(p..\"  \"..o:sub(2))end;N.close()end;if self.triggers then local U=a1(self.triggers,'\\n')for V,p in ipairs(U)do p=J(p:gsub(\"#.+$\",\"\"))if string.find(p,\"interest\")==1 then local aI=a1(p)if aI[1]==\"interest\"or aI[1]==\"interest-await\"then B.register(aI[2],self.name,true)elseif aI[1]==\"interest-noawait\"then B.register(aI[2],self.name,false)end end end;E.package.setTriggerDB()end;for V,p in ipairs{\"postinst\",\"postrm\",\"preinst\",\"prerm\",\"triggers\"}do if self[p]then R(G(\"info/\"..self.name..\".\"..p),self[p])end end;for o,p in pairs(az)do local aJ=P(G(\"info/\"..o..\".list\"))for V,au in ipairs(p)do for q,aG in ipairs(aJ)do if au==aG then table.remove(aJ,q)break end end end;if#aJ==0 then E.package(o).callMaintainerScript(\"postrm\",\"disappear\",self.name,self.control.Version)for V,au in ipairs{\"conffiles\",\"md5sums\",\"postinst\",\"postrm\",\"preinst\",\"prerm\",\"triggers\"}do a.remove(G(\"info/\"..o..\".\"..au))end;E.package.packagedb[o].Status=\"purge ok not-installed\"else T(G(\"info/\"..o..\".list\"),aJ)end end;for V,p in ipairs(self.filelist)do E.package.filedb[p]=self.name;if a.exists(I(p..\".dpkg-old\"))and not aB[p]then a.remove(I(p..\".dpkg-old\"))end;if a.exists(I(p..\".dpkg-new\"))then local aK=a.stat(I(p..\".dpkg-new\"))a.rename(I(p..\".dpkg-new\"),I(p))if aK.setuser then a.chmod(I(p),aK.owner,\"+s\")end end end;a.remove(G(\"tmp.ci\"))E.package.packagedb[self.name]=E.package.packagedb[self.name]or{}for o,p in pairs(self.control)do E.package.packagedb[self.name][o]=p end;E.package.packagedb[self.name].Status=\"install ok unpacked\"self.isUnpacked=true;for o,p in pairs(ao)do if p==1 then E.package(o).remove()end end;E.package.clearScriptErrors()return true end,configure=function()if not self.isUnpacked then E.error(\"internal error: package is not unpacked\")return false end;if W(E.package.packagedb[self.name],1)==\"hold\"then if E.force.hold then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package is currently held\")else E.error(\"package is currently held\")return false end end;if not A.status.needs_configure(W(E.package.packagedb[self.name],3))then E.error(\"package is already configured\")return false end;local aL={}if self.control.Depends~=nil then for V,p in ipairs(a1(self.control.Depends,\",\"))do local al,j=E.checkDependency(p,function(am,X)return A.status.configured(am)or X[\"Config-Version\"]~=nil and A.status.present(am)end)if not al and not E.options.ignore_depends[j]then table.insert(aL,{j,J(p)})end end end;if#aL>0 then if E.force.depends then E.warn(\"overriding problem because --force enabled:\")E.warn(\"dependency problems prevent unpacking of \"..self.name..\":\")for V,p in ipairs(aL)do E.print(\" \"..self.name..\" depends on \"..p[2]..\"; however:\\n  Package \"..p[1]..\" is not installed.\\n\")end else E.error(\"dependency problems prevent unpacking of \"..self.name..\":\")for V,p in ipairs(aL)do E.print(\" \"..self.name..\" depends on \"..p[2]..\"; however:\\n  Package \"..p[1]..\" is not installed.\\n\")end;return false end end;local an={}for o,p in pairs(E.package.packagedb)do if p.Breaks and A.status.get_number(W(p,3))>=A.status.unpacked and E.findRelationship(self.name,self.control.Version,p.Breaks)then table.insert(an,o)end end;if#an>0 then if E.force.breaks then E.warn(\"overriding problem because --force enabled:\")E.warn(\"conflicting packages prevent unpacking of \"..self.name..\":\")for V,p in ipairs(an)do E.print(\" \"..p..\" breaks \"..self.name..\", however:\\n  Package \"..self.name..\" (\"..self.control.Version..\") is being configured.\\n\")end else E.error(\"conflicting packages prevent unpacking of \"..self.name..\":\")for V,p in ipairs(an)do E.print(\" \"..p..\" breaks \"..self.name..\", however:\\n  Package \"..self.name..\" (\"..self.control.Version..\") is being configured.\\n\")end;return false end end;E.print(\"Setting up \"..self.name..\" (\"..self.control.Version..\") ...\")if not self.callMaintainerScript(\"postinst!\",\"configure\",self.control[\"Config-Version\"])then E.print(\"dpkg: an error occurred while configuring \"..self.name)Z(E.package.packagedb[self.name],3,\"half-configured\")return false end;if self.triggers then local U=a1(self.triggers,'\\n')for V,p in ipairs(U)do p=J(p:gsub(\"#.+$\",\"\"))if string.find(p,\"activate\")==1 then local aI=a1(p)if aI[1]==\"activate\"or aI[1]==\"activate-await\"then B.activate(aI[2],self.name,true,E.package.triggerdb,E.package.packagedb)elseif aI[1]==\"activate-noawait\"then B.activate(aI[2],self.name,false,E.package.triggerdb,E.package.packagedb)end end end end;if E.package.packagedb[self.name][\"Triggers-Pending\"]and E.options.triggers then E.print(\"Processing triggers for \"..self.name..\" (\"..self.control.Version..\") ...\")B.commit(self.name,E.package.triggerdb,E.package.packagedb)else Z(E.package.packagedb[self.name],3,\"installed\")end;E.package.clearScriptErrors()return true end,remove=function(aM)if not self.isUnpacked then E.error(\"internal error: package is not unpacked\")return false end;if W(E.package.packagedb[self.name],1)==\"hold\"then if E.force.hold then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package is currently held\")else E.error(\"package is currently held\")return false end end;if not A.status.present(W(E.package.packagedb[self.name],3))then if aM then return self.purge()end;E.error(\"cannot remove package: package is not installed\")return false end;if W(E.package.packagedb[self.name],2)==\"reinstreq\"then if E.force.remove_reinstreq then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package requires reinstallation\")else E.error(\"package requires reinstallation\")return false end end;if E.package.packagedb[self.name].Essential==\"yes\"then if E.force.remove_essential then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package is marked as essential\")else E.error(\"package is marked as essential\")return false end end;do local as={}for o,p in pairs(E.package.packagedb)do if p.Depends and E.findRelationship(self.name,self.control.Version,p.Depends)then table.insert(as,o)end end;if#as>0 then if E.force.depends then E.print(\"dpkg: \"..self.name..\": dependency problems, but removing anyway as you requested:\")else E.error(\"dependency problems prevent removal of \"..self.name..\":\")end;for V,p in ipairs(as)do E.print(\" \"..p[1]..\" depends on \"..self.name..\".\")end;if not E.force.depends then return false end end end;if not self.callMaintainerScript(\"prerm\",\"remove\")then E.debug(\"Prerm failed\")if E.package.unwindScriptErrors()then E.error(\"prerm failed, leaving installed\")Z(E.package.packagedb[self.name],3,\"installed\")return false else E.error(\"prerm failed to run\")Z(E.package.packagedb[self.name],3,\"half-configured\")return false end end;local aN={}for V,p in ipairs(self.conffiles)do aN[p]=true end;local aO={}local aP={}for q,p in ipairs(self.filelist)do if p~=\"/\"then E.debug(\"Removing \"..p)if not aN[p]then table.insert(aP,q)if a.isDir(I(p))then table.insert(aO,p)else a.remove(I(p))end end end end;table.sort(aO,function(ai,aQ)return#ai>#aQ end)for V,p in ipairs(aO)do if#a.list(I(p))==0 then a.remove(I(p))end end;for V,p in ipairs(aP)do self.filelist[p]=nil end;if not self.callMaintainerScript(\"postrm\",\"remove\")then E.error(\"postrm failed to run\")E.package.clearScriptErrors()Z(E.package.packagedb[self.name],3,\"half-installed\")return false end;if self.triggers then local U=a1(self.triggers,'\\n')for V,p in ipairs(U)do p=J(p:gsub(\"#.+$\",\"\"))if string.find(p,\"interest\")==1 then local aI=a1(p)B.deregister(aI[2])end end;E.package.setTriggerDB()end;for V,p in ipairs(a.find(G(\"info/\"..self.name..\".*\")))do local aR=p:match(\"[^.]+$\")if not(aR==\"postrm\"or aR==\"conffiles\"or aR==\"list\"or aR==\"md5sums\")then a.remove(I(p))end end;T(G(\"info/\"..self.name..\".list\"),self.filelist)Z(E.package.packagedb[self.name],3,\"config-files\")if not a.exists(G(\"info/\"..self.name..\".postrm\"))and not a.exists(G(\"info/\"..self.name..\".conffiles\"))then a.remove(G(\"info/\"..self.name..\".list\"))Z(E.package.packagedb[self.name],3,\"not-installed\")return true elseif aM then return self.purge()else return true end end,purge=function()if not self.isUnpacked then E.error(\"internal error: package is not unpacked\")return false end;if W(E.package.packagedb[self.name],1)==\"hold\"then if E.force.hold then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package is currently held\")else E.error(\"package is currently held\")return false end end;if W(E.package.packagedb[self.name],3)~=\"config-files\"then E.error(\"cannot purge package: package is\"..(W(E.package.packagedb[self.name],3)==\"not-installed\"and\" not \"or\" \")..\"installed\")return false end;E.print(\"Removing config files for \"..self.name..\" (\"..self.control.Version..\") ...\")for V,p in ipairs(self.conffiles)do a.remove(I(p))end;if not self.callMaintainerScript(\"postrm\",\"purge\")then E.error(\"postrm failed to run\")E.package.clearScriptErrors()Z(E.package.packagedb[self.name],3,\"config-files\")return false end;if a.exists(G(\"info/\"..self.name..\".postrm\"))then a.remove(G(\"info/\"..self.name..\".postrm\"))end;if a.exists(G(\"info/\"..self.name..\".conffiles\"))then a.remove(G(\"info/\"..self.name..\".conffiles\"))end;Z(E.package.packagedb[self.name],3,\"not-installed\")return true end,verify=function()if not self.isUnpacked then E.error(\"internal error: package is not unpacked\")return false end;if W(E.package.packagedb[self.name],1)==\"hold\"then if E.force.hold then E.warn(\"overriding problem because --force enabled:\")E.warn(\"package is currently held\")else E.error(\"package is currently held\")return false end end;if not self.md5sums then E.error(\"cannot verify package: no md5 sums are available\")return false end;local aS=true;for o,p in pairs(self.md5sums)do if C.md5(L(o))~=p then E.print(\"dpkg: \"..self.name..\": checksum failed for file \"..o)aS=false end end;return aS end}_G.package=a7;local function aT(aU,aV)if aU=='~'and aV~='~'then return 1 elseif aU~='~'and aV=='~'then return-1 elseif aU==''and aV~=''then return 1 elseif aU~=''and aV==''then return-1 elseif string.match(aU,\"%a\")and not string.match(aV,\"%a\")then return 1 elseif not string.match(aU,\"%a\")and string.match(aV,\"%a\")then return-1 elseif aU>aV then return 1 elseif aU<aV then return-1 else return 0 end end;local function aW(ai,aQ)if ai==aQ then return 0 end;while ai~=\"\"or aQ~=\"\"do local aX,aY;aX,ai=string.match(ai,\"^(%D*)(.*)$\")aY,aQ=string.match(aQ,\"^(%D*)(.*)$\")while aX~=\"\"or aY~=\"\"do local aZ,a_;aZ,aX=string.match(aX,\"^(.?)(.*)$\")a_,aY=string.match(aY,\"^(.?)(.*)$\")local ac=aT(aZ,a_)if ac~=0 then return ac end end;if ai==\"\"and aQ==\"\"then break end;aX,ai=string.match(ai,\"^(%d*)(.*)$\")aY,aQ=string.match(aQ,\"^(%d*)(.*)$\")if tonumber(aX)>tonumber(aY)then return 1 elseif tonumber(aX)<tonumber(aY)then return-1 end end;return 0 end;function E.compareVersions(ai,aQ)if string.match(ai,\"^%d+:\")or string.match(aQ,\"^%d+:\")then local b0=tonumber(string.match(ai,\"^(%d+):\")or 0)local b1=tonumber(string.match(aQ,\"^(%d+):\")or 0)ai,aQ=string.match(ai,\"^%d+:(.*)\")or ai,string.match(aQ,\"^%d+:(.*)\")or aQ;if b0<b1 then return-1 elseif b0>b1 then return 1 end end;local b2=string.match(ai,\"^([%w.+-~]+)%-?[%w.+~]*$\")local b3=string.match(aQ,\"^([%w.+-~]+)%-?[%w.+~]*$\")if b2==nil or b3==nil then return nil end;local ac=aW(b2,b3)if ac~=0 then return ac end;if string.match(ai,\"%-[^-]+$\")or string.match(aQ,\"%-[%w.+~]+$\")then return aW(string.match(ai,\"%-([%w.+~]+)$\")or\"0\",string.match(aQ,\"%-([%w.+~]+)$\")or\"0\")end;return 0 end;function E.findRelationship(X,b4,b5)local b6,b7;b5=string.match(J(b5),\"^(\"..X..\"%s+%([<=>][<=>]?%s*[^ )]+%))\")or string.match(J(b5),\"[, ](\"..X..\"%s+%([<=>][<=>]?%s*[^ )]+%))\")or string.match(J(b5),\"^(\"..X..\")%s*,\")or string.match(J(b5),\"[, ](\"..X..\")%s*,\")or string.match(J(b5),\"^(\"..X..\")$\")or string.match(J(b5),\"[, ](\"..X..\")$\")if b5==nil then return false end;if string.match(b5,\"%S+%s+%([<=>][<=>]?%s*[^ )]+%)\")then b5,b7,b6=string.match(b5,\"(%S+)%s+%(([<=>][<=>]?)%s*([^ )]+)%)\")if not({[\"<<\"]=true,[\"<=\"]=true,[\"=\"]=true,[\">=\"]=true,[\">>\"]=true})[b7]then return nil end end;if b6 and b7 then local ac=E.compareVersions(b4,b6)return b7==\"<<\"and ac==-1 or b7==\"<=\"and ac~=1 or b7==\"=\"and ac==0 or b7==\">=\"and ac~=-1 or b7==\">>\"and ac==1 else return true end end;function E.checkDependency(b8,b9)local b6,b7;b8=J(b8)if string.match(b8,\"%S+%s+%([<=>][<=>]?%s*[^ )]+%)\")then b8,b7,b6=string.match(b8,\"(%S+)%s+%(([<=>][<=>]?)%s*([^ )]+)%)\")if not({[\"<<\"]=true,[\"<=\"]=true,[\"=\"]=true,[\">=\"]=true,[\">>\"]=true})[b7]then return nil end end;local ba={}if E.package.packagedb[b8]~=nil then table.insert(ba,{E.package.packagedb[b8],E.package.packagedb[b8].Version})end;for V,p in pairs(E.package.packagedb)do if p.Provides and string.find(p.Provides,\"[, ]\"..b8 ..\"[(, ]\")then if b6 and string.match(p.Provides,\"[, ]\"..b8 ..\"%s+%(=%s*[^ )]+%)\")then table.insert(ba,{p,string.match(p.Provides,\"[, ]\"..b8 ..\"%s+%(=%s*([^ )]+)%)\")})elseif not b6 then table.insert(ba,{p,p.Version})end end end;for V,bb in ipairs(ba)do if A.status.configured(W(bb[1],3))or b9==true and A.status.present(W(bb[1],3))or type(b9)==\"function\"and b9(W(bb[1],3),bb[1])then if b6 and b7 and not E.breaks.depends_version then local ac=E.compareVersions(bb[2],b6)if b7==\"<<\"and ac==-1 or b7==\"<=\"and ac~=1 or b7==\"=\"and ac==0 or b7==\">=\"and ac~=-1 or b7==\">>\"and ac==1 then return true,bb[1].Package end else return true,bb[1].Package end end end;return false,b8 end;function E.readDatabase()E.write(\"(Reading database ...\")E.package.setPackageDB()E.package.setTriggerDB()E.package.setFileDB()E.print(\" \"..E.package.filecount..\" files and directories installed.)\")end;return E\n",created=1704748610873,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=37643},["control.lua"]={modified=1704748610845,data="local function a(b)return string.match(b,'^()[%s%z]*$')and''or string.match(b,'^[%s%z]*(.*[^%s%z])')end;local c={}function c.parseControl(d)local e={}local f=nil;for g in string.gmatch(d,\"[^\\n]+\")do if string.sub(g,1,1)==\" \"and f~=nil then if f==\"Description\"then if type(e[f])==\"string\"then e[f]={Short=e[f],Long=\"\"}end;e[f].Long=e[f].Long..(string.sub(g,2)==\".\"and\"\\n\\n\"or string.sub(g,2))else e[f]=e[f]..(string.sub(g,2)==\".\"and\"\\n\\n\"or string.sub(g,2))end else f=string.sub(g,1,(string.find(g,\":\")or 0)-1)e[f]=a(string.sub(g,(string.find(g,\":\")or-1)+1))end end;return e end;function c.parseControlList(d,h)local e={}local i={}local j={}local b=1;for k,g in string.gmatch(d,\"()([^\\n]*\\n)\")do if g==\"\\n\"or g==\"\"then b=b+1 else j[b]=j[b]or k;i[b]=(i[b]or\"\")..g end end;for l,m in pairs(i)do local n=c.parseControl(m)if h then n.__pos=j[l]end;table.insert(e,n)end;return e end;function c.parseDependencies(o)local e={}for p in string.gmatch(o,\"[^,]+\")do p=a(p)local q={}if string.find(p,\"|\")then q.multiple=true;q.names={}for r in string.gmatch(p,\"[^|]+\")do r=a(r)local s={}s.name=string.match(r,\"%S+\")if string.match(r,\"%([<>=]+ [%d.%-%+%~]+%)\")then s.rel=string.match(r,\"%(([<>=]+) [%d.%-%+%~]+%)\")s.version=string.match(r,\"%([<>=]+ ([%d.%-%+%~]+)%)\")end;table.insert(q.names,s)end else q.name=string.match(p,\"%S+\")if string.match(p,\"%([<>=]+ [%d%.%-%+%~]+%)\")then q.rel=string.match(p,\"%(([<>=]+) [%d.%-%+%~]+%)\")q.version=string.match(p,\"%([<>=]+ ([%d.%-%+%~]+)%)\")end end;table.insert(e,q)end;return e end;return c\n",created=1704748610871,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1520},["trigger.lua"]={modified=1704748610850,data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=require\"query\"local d={}d.admindir=\"/var/lib/dpkg\"d.log=function(e)end;local f={}local function g(h)return a.combine(d.admindir,h)end;local function i(j,k)local l={}for m in string.gmatch(j,\"([^\"..(k or\"%s\")..\"]+)\")do table.insert(l,m)end;return l end;function d.list()return a.list(g(\"triggers\"))end;function d.lock()while a.exists(g(\"triggers/Lock\"))do coroutine.yield()end;local n=a.open(g(\"triggers/Lock\"),\"w\")n.write(\"Lock\")n.flush()return function()n.close()a.remove(g(\"triggers/Lock\"))if a.exists(g(\"triggers/Lock\"))then error(\"Lock still exists!\")end end end;function d.readDatabase()local n=io.open(g(\"triggers/File\"),\"r\")if not n then error(\"Missing trigger file\")end;local o=d.lock()local p={}for q in n:lines()do local r,s=string.match(q,\"([^ ]+) ([^ ]+)\")if r then p[r]={package=s,await=true}if string.find(s,\"/noawait\")then p[r].await=false end end end;n:close()o()return p end;function d.register(t,s,u)if u==nil then u=true end;local o=d.lock()if string.find(t,\"/\")then local n=a.open(g(\"triggers/File\"),a.exists(g(\"triggers/File\"))and\"a\"or\"w\")n.writeLine(t..\" \"..s..(not u and\"/noawait\"or\"\"))n.close()else local n=a.open(g(\"triggers/\"..t),\"w\")n.writeLine(s..(not u and\"/noawait\"or\"\"))n.close()end;o()end;function d.deregister(t)if string.find(t,\"/\")then local o=d.lock()local n=io.open(g(\"triggers/File\"),\"r\")if not n then return o()end;local p=\"\"for q in n:lines()do if not string.match(q,\"^\"..t..\" \")then p=p..q..\"\\n\"end end;n:close()n=a.open(g(\"triggers/File\"),\"w\")n.write(p)n.close()o()else a.remove(g(\"triggers/\"..t))end end;function d.activate(t,s,u,v,w)if u==nil then u=true end;if string.find(t,\"/\")then v=v or d.readDatabase()local x=false;for y,z in pairs(v)do if string.match(t,\"^\"..y)then x=z end end;if not x then return false end;u=u and x.await;w=w or c.readDatabase()local A,B,C=string.match(w[x.package].Status,\"([^ ]+) ([^ ]+) ([^ ]+)\")if C~=\"triggers-awaited\"then w[x.package].Status=A..\" \"..B..\" triggers-pending\"end;A,B,C=string.match(w[s].Status,\"([^ ]+) ([^ ]+) ([^ ]+)\")if u then w[s].Status=A..\" \"..B..\" triggers-awaited\"w[s][\"Triggers-Awaited\"]=(w[s][\"Triggers-Awaited\"]or\"\")..(w[s][\"Triggers-Awaited\"]and\" \"or\"\")..x.package end;w[x.package][\"Triggers-Pending\"]=(w[x.package][\"Triggers-Pending\"]or\"\")..(w[x.package][\"Triggers-Pending\"]and\" \"or\"\")..t;local o=d.lock()local n=io.open(g(\"triggers/Unincorp\"),\"r\")local D=a.open(g(\"triggers/Unincorp.new\"),\"w\")local E=false;for z in n:lines()do if not E and string.match(z,\"^\"..t..\" \")then E=true;if u then if string.match(z,\"[^ ]+ (.+)\")==\"-\"then z=t end;z=z..\" \"..s end end;D.writeLine(z)end;if not E then D.writeLine(t..\" \"..(u and s or\"-\"))end;n:close()D.close()a.remove(g(\"triggers/Unincorp\"))a.move(g(\"triggers/Unincorp.new\"),g(\"triggers/Unincorp\"))o()return true,v,w else if not a.exists(g(\"triggers/\"..t))then error(\"Invalid trigger \"..t,2)end;local n=io.open(g(\"triggers/\"..t),\"r\")if n==nil then error(\"Could not open trigger file\")end;w=w or c.readDatabase()local F;for q in n:lines()do if w[q]==nil then d.log(\"Package \"..q..\" is interested in trigger \"..t..\" but is not installed\")else local A,B,C=string.match(w[q].Status,\"([^ ]+) ([^ ]+) ([^ ]+)\")w[q].Status=A..\" \"..B..\" triggers-pending\"w[q][\"Triggers-Pending\"]=(w[q][\"Triggers-Pending\"]or\"\")..(w[q][\"Triggers-Pending\"]and\" \"or\"\")..t;A,B,C=string.match(w[s].Status,\"([^ ]+) ([^ ]+) ([^ ]+)\")if u then w[s].Status=A..\" \"..B..\" triggers-awaited\"w[s][\"Triggers-Awaited\"]=(w[s][\"Triggers-Awaited\"]or\"\")..(w[s][\"Triggers-Awaited\"]and\" \"or\"\")..q end;F=(F or\"\")..(F and\" \"or\"\")..q end end;n:close()local o=d.lock()n=io.open(g(\"triggers/Unincorp\"),\"r\")local D=a.open(g(\"triggers/Unincorp.new\"),\"w\")local E=false;for z in n:lines()do if not E and string.match(z,\"^\"..t..\" \")then E=true;if u then if string.match(z,\"[^ ]+ (.+)\")==\"-\"then z=t end;z=z..\" \"..s end end;D.writeLine(z)end;if not E then D.writeLine(t..\" \"..(u and s or\"-\"))end;n:close()D.close()a.remove(g(\"triggers/Unincorp\"))a.move(g(\"triggers/Unincorp.new\"),g(\"triggers/Unincorp\"))o()return true,v,w end end;function d.commit(s,v,w)w=w or c.readDatabase()if w[s]==nil then error(\"Package \"..s..\" not found\")end;local A,B,C=string.match(w[s].Status,\"([^ ]+) ([^ ]+) ([^ ]+)\")if w[s][\"Triggers-Pending\"]==nil or not c.status.configured(C)then return false,v,w end;local G=w[s][\"Triggers-Pending\"]w[s][\"Triggers-Pending\"]=nil;local H=b.run(g(\"info/\"..s..\".postinst\"),\"triggered\",G)w[s].Status=A..\" \"..B..(H and(w[s][\"Triggers-Awaited\"]and\" triggers-awaited\"or\" installed\")or\" config-failed\")local o=d.lock()local I=a.open(g(\"triggers/Unincorp.new\"),\"w\")for J in io.lines(g(\"triggers/Unincorp\"))do local K=string.gsub(G,string.find(G,string.match(J,\"^([^ ]+)\"),1,true))if K then for L,z in ipairs(i(string.match(J,\"^[^ ]+ (.+)\")))do if w[z]~=nil and w[z][\"Triggers-Awaited\"]~=nil then w[z][\"Triggers-Awaited\"]=string.gsub(string.gsub(w[z][\"Triggers-Awaited\"],\"( ?)\"..s..\"( ?)\",\"%1\"),\" $\",\"\")if w[z][\"Triggers-Awaited\"]==\"\"then w[z][\"Triggers-Awaited\"]=nil;w[z].Status=string.gsub(w[z].Status,\"triggers%-awaited\",\"installed\")end end end else I.writeLine(J)end end;I.close()a.remove(g(\"triggers/Unincorp\"))a.move(g(\"triggers/Unincorp.new\"),g(\"triggers/Unincorp\"))o()return H and 1 or 0,v,w end;return d\n",created=1704748610875,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=5278},["deb.lua"]={modified=1704748610846,data="local a=require\"ar\"local b=require\"tar\"local c=require\"control\"local d=require\"LibDeflate\"local e=require\"muxzcat\"local f={verbose=false}function f.load(g,h,i)if f.verbose then print(\"Loading package...\")end;local j=a.load(g)if j==nil then error(\"Invalid deb file\",2)end;if#j<3 or j[1].name~=\"debian-binary\"or j[1].data~=\"2.0\\n\"then error(\"Invalid deb file\",2)end;local k,l,m;if f.verbose then print(\"Extracting control...\")end;if j[2].name==\"control.tar.gz\"then k,m=d:DecompressGzip(j[2].data)elseif j[2].name==\"control.tar.xz\"then k,m=e.DecompressXzOrLzmaString(j[2].data)else error(\"Unsupported compression format: \"..j[2].name)end;if k==nil then error(\"Could not decompress control file: \"..m)end;local n=b.load(k,false,true)if n[\".\"]~=nil then n=n[\".\"]end;if f.verbose then print(\"Extracting data...\")end;if j[3].name==\"data.tar.gz\"then l,m=d:DecompressGzip(j[3].data)elseif j[3].name==\"data.tar.xz\"or j[3].name==\"data.tar.lzma\"then l,m=e.DecompressXzOrLzmaString(j[3].data)else error(\"Unsupported compression format: \"..j[2].name)end;if l==nil then error(\"Could not decompress data file: \"..m)end;if i then return{k,l}end;local o=b.load(l,h,true)if o[\".\"]~=nil and not h then o=o[\".\"]end;local p={}p.control_size=string.len(j[2].data)p.data_size=string.len(j[3].data)p.control_archive=n;p.control=c.parseControl(n.control.data)p.name=p.control.Package;p.version=p.control.Version;p.section=p.control.Section;p.priority=p.control.Priority;if p.control[\"Pre-Depends\"]~=nil then p.predepends=c.parseDependencies(p.control[\"Pre-Depends\"])end;if p.control.Depends~=nil then p.depends=c.parseDependencies(p.control.Depends)end;if p.control.Recommends~=nil then p.recommends=c.parseDependencies(p.control.Recommends)end;if p.control.Suggests~=nil then p.suggests=c.parseDependencies(p.control.Suggests)end;if p.control.Enhances~=nil then p.enhances=c.parseDependencies(p.control.Enhances)end;if p.control.Breaks~=nil then p.breaks=c.parseDependencies(p.control.Breaks)end;if p.control.Conflicts~=nil then p.conflicts=c.parseDependencies(p.control.Conflicts)end;if p.control.Provides~=nil then p.provides=c.parseDependencies(p.control.Provides)end;if p.control.Replaces~=nil then p.replaces=c.parseDependencies(p.control.Replaces)end;p.conffiles={}if n.conffiles~=nil then for q in string.gmatch(n.conffiles.data,\"[^\\n]+\")do table.insert(p.conffiles,q)end end;p.md5sums={}if n.md5sums~=nil then for q in string.gmatch(n.md5sums.data,\"[^\\n]+\")do local r,s=q:match(\"^(%x+)  (.+)$\")if r then p.md5sums[\"/\"..s]=r end end end;if n.preinst~=nil then p.preinst=n.preinst.data end;if n.prerm~=nil then p.prerm=n.prerm.data end;if n.postinst~=nil then p.postinst=n.postinst.data end;if n.postrm~=nil then p.postrm=n.postrm.data end;if n.config~=nil then p.config=n.config.data end;if n.triggers~=nil then p.triggers=n.triggers.data end;if n.templates~=nil then p.templates=c.parseControlList(n.templates.data)for r,s in pairs(p.templates)do local t={}for u,v in pairs(s)do if string.match(u,\"%a+%-[%a@_]+%.UTF%-8\")then table.insert(t,u)end end;for u,v in pairs(t)do s[v]=nil end end end;p.data=o;return p end;return f\n",created=1704748610872,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=3107}},owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},["usermgr.lua"]={modified=1704748612975,data="local a=require\"system.expect\"local b=require\"system.ipc\"local c=require\"system.process\"local d={}local e;local function f(g,h)if not e then e=b.lookup(\"usermgr\")end;if not e then error(\"Could not connect to user authentication service\",2)end;b.sendEvent(e,\"usermgr.request.\"..g,h)local i,j=b.receiveEvent(e,\"usermgr.response.\"..g,5)if not j then error(\"Timed out waiting for user authentication service\",2)end;return j end;function d.authenticate(k,l)a(1,k,\"string\")a(2,l,\"string\")if c.getuser()~=\"root\"then error(\"Permission denied\",2)end;local m=f(\"authenticate\",{user=k,password=l})return m.result or false,m.error or m.message end;function d.getUserInfo(k)a(1,k,\"string\")local m=f(\"getUserInfo\",{user=k})if m.error then error(m.error,2)end;return m.result end;function d.addUser(k,l,n)a(1,k,\"string\")a(2,l,\"string\",\"nil\")n=a(3,n,\"table\",\"nil\")or{}a.field(n,\"fullName\",\"string\",\"nil\")a.field(n,\"home\",\"string\",\"nil\")a.field(n,\"shell\",\"string\",\"nil\")n.user=k;n.password=l;if c.getuser()~=\"root\"then error(\"Permission denied\",2)end;local m=f(\"addUser\",n)if m.error then error(m.error,2)end;return m.result or false end;function d.removeUser(k)a(1,k,\"string\")if c.getuser()~=\"root\"then error(\"Permission denied\",2)end;local m=f(\"removeUser\",{user=k})if m.error then error(m.error,2)end;return m.result or false end;function d.editUser(k,n)a(1,k,\"string\")a(2,n,\"table\")a.field(n,\"fullName\",\"string\",\"nil\")a.field(n,\"home\",\"string\",\"nil\")a.field(n,\"shell\",\"string\",\"nil\")n.user=k;local o=c.getuser()if o~=\"root\"and o~=k then error(\"Permission denied\",2)end;local m=f(\"editUser\",n)if m.error then error(m.error,2)end;return m.result or false end;function d.setPassword(k,l,n)a(1,k,\"string\")a(2,l,\"string\",\"nil\")n=a(3,n,\"table\",\"nil\")or{}a.field(n,\"nextChange\",\"number\",\"nil\")a.field(n,\"expirationTime\",\"number\",\"nil\")a.field(n,\"expirationWarning\",\"number\",\"nil\")a.field(n,\"lockTime\",\"number\",\"nil\")a.field(n,\"isLocked\",\"boolean\",\"nil\")if c.getuser()~=\"root\"then error(\"Permission denied\",2)end;n.user,n.password=k,l;local m=f(\"setPassword\",n)if m.error then error(m.error,2)end;return m.result or false end;return d\n",created=1704748613030,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=2114},["sha2.lua"]={modified=1704748612466,data="local a=false;local unpack,b,c,d,e,f,g,h,i,j,k,l,m,tonumber,type,n=table.unpack or unpack,table.concat,string.byte,string.char,string.rep,string.sub,string.gsub,string.gmatch,string.format,math.floor,math.ceil,math.min,math.max,tonumber,type,math.huge;local function o(p)local q,r,s,t=0,p,p;while true do q,t,r,s=q+1,r,r+r+1,s+s+q%2;if q>256 or r-(r-1)~=1 or s-(s-1)~=1 or r==s then return q,false elseif r==t then return q,true end end end;local u=2/3;local v=u*5>3 and u*4<3 and o(1.0)>=53;assert(v,\"at least 53-bit floating point numbers are required\")local w,x=o(1)local y=x and w==64;local z=x and w==32;assert(y or z or not x,\"Lua integers must be either 32-bit or 64-bit\")local A=({false,[1]=true})[1]and _VERSION~=\"Luau\"and(type(jit)~=\"table\"or jit.version_num>=20000)local B;local C;local D;local E;local F;if A then E=require\"bit\"F=\"bit\"local G,H=pcall(require,\"ffi\")if G then D=H end;B=not not loadstring\"b=0b0\"C=type(jit)==\"table\"and jit.arch or D and D.arch or nil else for I,J in ipairs(_VERSION==\"Lua 5.2\"and{\"bit32\",\"bit\"}or{\"bit\",\"bit32\"})do if type(_G[J])==\"table\"and _G[J].bxor then E=_G[J]F=J;break end end end;if a then print(\"Abilities:\")print(\"   Lua version:               \"..(A and\"LuaJIT \"..(B and\"2.1 \"or\"2.0 \")..(C or\"\")..(D and\" with FFI\"or\" without FFI\")or _VERSION))print(\"   Integer bitwise operators: \"..(y and\"int64\"or z and\"int32\"or\"no\"))print(\"   32-bit bitwise library:    \"..(F or\"not found\"))end;local K,L;if A and D then K=\"Using 'ffi' library of LuaJIT\"L=\"FFI\"elseif A then K=\"Using special code for sandboxed LuaJIT (no FFI)\"L=\"LJ\"elseif F then K=\"Using '\"..F..\"' library\"L=\"LIB32\"else K=\"Emulating bitwise operators using look-up table\"L=\"EMUL\"end;if a then print(\"Implementation selected:\")print(\"   \"..K)end;local M,N,O,P,Q,R,S,T,U,V,W;if L==\"FFI\"or L==\"LJ\"or L==\"LIB32\"then M=E.band;N=E.bor;O=E.bxor;P=E.lshift;Q=E.rshift;R=E.rol or E.lrotate;S=E.ror or E.rrotate;T=E.bnot;U=E.tobit;V=E.tohex;assert(M and N and O and P and Q and R and S and T,\"Library '\"..F..\"' is incomplete\")W=O end;V=V or pcall(i,\"%x\",2^31)and function(u)return i(\"%08x\",u%4294967296)end or function(u)return i(\"%08x\",(u+2^31)%2^32-2^31)end;local function X(u,Y)return O(u,Y or 0xA5A5A5A5)%4294967296 end;local function Z()return{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}end;local _,a0,a1,a2,a3,a4,a5,a6;local a7,a8,a9,aa,ab,ac={},{},{},{},{},{}local ad={[224]={},[256]=aa}local ae,af={[384]={},[512]=a9},{[384]={},[512]=aa}local ag,ah={},{0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476,0xC3D2E1F0}local ai={0,0,0,0,0,0,0,0,28,25,26,27,0,0,10,9,11,12,0,15,16,17,18,0,20,22,23,21}local aj,ak;local al={}local am,an,ao=al,al,{}local ap,aq,ar=4294967296,0,0;local as={{1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16},{15,11,5,9,10,16,14,7,2,13,1,3,12,8,6,4},{12,9,13,1,6,3,16,14,11,15,4,7,8,2,10,5},{8,10,4,2,14,13,12,15,3,7,6,11,5,1,16,9},{10,1,6,8,3,5,11,16,15,2,12,13,7,9,4,14},{3,13,7,11,1,12,9,4,5,14,8,6,16,15,2,10},{13,6,2,16,15,14,5,11,1,8,7,4,10,3,9,12},{14,12,8,15,13,2,4,10,6,1,16,5,9,7,3,11},{7,16,15,10,12,4,1,9,13,3,14,8,2,5,11,6},{11,3,9,5,8,7,2,6,16,12,10,15,4,13,14,1}}as[11],as[12]=as[1],as[2]local at={1,3,4,11,13,10,12,6,1,3,4,11,13,10,2,7,5,8,14,15,16,9,2,7,5,8,14,15}local function au(av)local aw={}for I,ax in ipairs{1,9,13,17,18,21}do aw[ax]=\"<\"..e(av,ax)end;return aw end;if L==\"FFI\"then local ay=D.new(\"int32_t[?]\",80)an=ay;ao=D.new(\"int32_t[?]\",16)at=D.new(\"uint8_t[?]\",#at+1,0,unpack(at))for az=1,10 do as[az]=D.new(\"uint8_t[?]\",#as[az]+1,0,unpack(as[az]))end;as[11],as[12]=as[1],as[2]function _(aA,aB,aC,ax)local aD,aE=ay,a8;for aF=aC,aC+ax-1,64 do for az=0,15 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aG,24),P(E,16),P(aH,8),aI)end;for az=16,63 do local aG,E=aD[az-15],aD[az-2]aD[az]=U(O(S(aG,7),R(aG,14),Q(aG,3))+O(R(E,15),R(E,13),Q(E,10))+aD[az-7]+aD[az-16])end;local aG,E,aH,aI,aJ,aK,aL,aM=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for az=0,63,8 do local aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az]+aE[az+1]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az+1]+aE[az+2]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az+2]+aE[az+3]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az+3]+aE[az+4]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az+4]+aE[az+5]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az+5]+aE[az+6]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az+6]+aE[az+7]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(aL,M(aJ,O(aK,aL)))+O(S(aJ,6),S(aJ,11),R(aJ,7))+aD[az+7]+aE[az+8]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)end;aA[1],aA[2],aA[3],aA[4]=U(aG+aA[1]),U(E+aA[2]),U(aH+aA[3]),U(aI+aA[4])aA[5],aA[6],aA[7],aA[8]=U(aJ+aA[5]),U(aK+aA[6]),U(aL+aA[7]),U(aM+aA[8])end end;local aO=D.new(\"int64_t[?]\",80)am=aO;local aP=D.typeof\"int64_t\"local aQ=D.typeof\"int32_t\"local aR=D.typeof\"uint32_t\"aq=aP(2^32)if B then local aS,aT,aU,aV,aW,aX,aY,aZ=M,N,O,T,P,Q,R,S;aj=V;do local a_=D.new(\"int64_t[?]\",16)local aD=am;local function b0(aG,E,aH,aI,b1,b2)local b3,b4,b5,b6=a_[aG],a_[E],a_[aH],a_[aI]b3=aD[b1]+b3+b4;b6=aZ(aU(b6,b3),32)b5=b5+b6;b4=aZ(aU(b4,b5),24)b3=aD[b2]+b3+b4;b6=aZ(aU(b6,b3),16)b5=b5+b6;b4=aY(aU(b4,b5),1)a_[aG],a_[E],a_[aH],a_[aI]=b3,b4,b5,b6 end;function a5(aA,I,aB,aC,ax,b7,b8,b9)local ba,bb,bc,bd,be,bf,bg,bh=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for aF=aC,aC+ax-1,128 do if aB then for az=1,16 do aF=aF+8;local aG,E,aH,aI,aJ,aK,aL,aM=c(aB,aF-7,aF)aD[az]=aU(N(P(aM,24),P(aL,16),P(aK,8),aJ)*aP(2^32),aR(aQ(N(P(aI,24),P(aH,16),P(E,8),aG))))end end;a_[0x0],a_[0x1],a_[0x2],a_[0x3],a_[0x4],a_[0x5],a_[0x6],a_[0x7]=ba,bb,bc,bd,be,bf,bg,bh;a_[0x8],a_[0x9],a_[0xA],a_[0xB],a_[0xD],a_[0xE],a_[0xF]=a9[1],a9[2],a9[3],a9[4],a9[6],a9[7],a9[8]b7=b7+(b8 or 128)a_[0xC]=aU(a9[5],b7)if b8 then a_[0xE]=aV(a_[0xE])end;if b9 then a_[0xF]=aV(a_[0xF])end;for az=1,12 do local bi=as[az]b0(0,4,8,12,bi[1],bi[2])b0(1,5,9,13,bi[3],bi[4])b0(2,6,10,14,bi[5],bi[6])b0(3,7,11,15,bi[7],bi[8])b0(0,5,10,15,bi[9],bi[10])b0(1,6,11,12,bi[11],bi[12])b0(2,7,8,13,bi[13],bi[14])b0(3,4,9,14,bi[15],bi[16])end;ba=aU(ba,a_[0x0],a_[0x8])bb=aU(bb,a_[0x1],a_[0x9])bc=aU(bc,a_[0x2],a_[0xA])bd=aU(bd,a_[0x3],a_[0xB])be=aU(be,a_[0x4],a_[0xC])bf=aU(bf,a_[0x5],a_[0xD])bg=aU(bg,a_[0x6],a_[0xE])bh=aU(bh,a_[0x7],a_[0xF])end;aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]=ba,bb,bc,bd,be,bf,bg,bh;return b7 end end;local bj=D.typeof\"int64_t[?]\"ak=0;ar=aP(2^32)function Z()return bj(30)end;function a3(bk,I,aB,aC,ax,bl)local bm=ab;local bn=Q(bl,3)for aF=aC,aC+ax-1,bl do for az=0,bn-1 do aF=aF+8;local aM,aL,aK,aJ,aI,aH,E,aG=c(aB,aF-7,aF)bk[az]=aU(bk[az],aT(N(P(aG,24),P(E,16),P(aH,8),aI)*aP(2^32),aR(aQ(N(P(aJ,24),P(aK,16),P(aL,8),aM)))))end;for bo=1,24 do for az=0,4 do bk[25+az]=aU(bk[az],bk[az+5],bk[az+10],bk[az+15],bk[az+20])end;local bp=aU(bk[25],aY(bk[27],1))bk[1],bk[6],bk[11],bk[16]=aY(aU(bp,bk[6]),44),aY(aU(bp,bk[16]),45),aY(aU(bp,bk[1]),1),aY(aU(bp,bk[11]),10)bk[21]=aY(aU(bp,bk[21]),2)bp=aU(bk[26],aY(bk[28],1))bk[2],bk[7],bk[12],bk[22]=aY(aU(bp,bk[12]),43),aY(aU(bp,bk[22]),61),aY(aU(bp,bk[7]),6),aY(aU(bp,bk[2]),62)bk[17]=aY(aU(bp,bk[17]),15)bp=aU(bk[27],aY(bk[29],1))bk[3],bk[8],bk[18],bk[23]=aY(aU(bp,bk[18]),21),aY(aU(bp,bk[3]),28),aY(aU(bp,bk[23]),56),aY(aU(bp,bk[8]),55)bk[13]=aY(aU(bp,bk[13]),25)bp=aU(bk[28],aY(bk[25],1))bk[4],bk[14],bk[19],bk[24]=aY(aU(bp,bk[24]),14),aY(aU(bp,bk[19]),8),aY(aU(bp,bk[4]),27),aY(aU(bp,bk[14]),39)bk[9]=aY(aU(bp,bk[9]),20)bp=aU(bk[29],aY(bk[26],1))bk[5],bk[10],bk[15],bk[20]=aY(aU(bp,bk[10]),3),aY(aU(bp,bk[20]),18),aY(aU(bp,bk[5]),36),aY(aU(bp,bk[15]),41)bk[0]=aU(bp,bk[0])bk[0],bk[1],bk[2],bk[3],bk[4]=aU(bk[0],aS(aV(bk[1]),bk[2]),bm[bo]),aU(bk[1],aS(aV(bk[2]),bk[3])),aU(bk[2],aS(aV(bk[3]),bk[4])),aU(bk[3],aS(aV(bk[4]),bk[0])),aU(bk[4],aS(aV(bk[0]),bk[1]))bk[5],bk[6],bk[7],bk[8],bk[9]=aU(bk[8],aS(aV(bk[9]),bk[5])),aU(bk[9],aS(aV(bk[5]),bk[6])),aU(bk[5],aS(aV(bk[6]),bk[7])),aU(bk[6],aS(aV(bk[7]),bk[8])),aU(bk[7],aS(aV(bk[8]),bk[9]))bk[10],bk[11],bk[12],bk[13],bk[14]=aU(bk[11],aS(aV(bk[12]),bk[13])),aU(bk[12],aS(aV(bk[13]),bk[14])),aU(bk[13],aS(aV(bk[14]),bk[10])),aU(bk[14],aS(aV(bk[10]),bk[11])),aU(bk[10],aS(aV(bk[11]),bk[12]))bk[15],bk[16],bk[17],bk[18],bk[19]=aU(bk[19],aS(aV(bk[15]),bk[16])),aU(bk[15],aS(aV(bk[16]),bk[17])),aU(bk[16],aS(aV(bk[17]),bk[18])),aU(bk[17],aS(aV(bk[18]),bk[19])),aU(bk[18],aS(aV(bk[19]),bk[15]))bk[20],bk[21],bk[22],bk[23],bk[24]=aU(bk[22],aS(aV(bk[23]),bk[24])),aU(bk[23],aS(aV(bk[24]),bk[20])),aU(bk[24],aS(aV(bk[20]),bk[21])),aU(bk[20],aS(aV(bk[21]),bk[22])),aU(bk[21],aS(aV(bk[22]),bk[23]))end end end;local bq=0xA5A5A5A5*aP(2^32+1)function X(br,bs)return aU(br,bs or bq)end;function a0(aA,I,aB,aC,ax)local aD,aE=aO,a7;for aF=aC,aC+ax-1,128 do for az=0,15 do aF=aF+8;local aG,E,aH,aI,aJ,aK,aL,aM=c(aB,aF-7,aF)aD[az]=aT(N(P(aG,24),P(E,16),P(aH,8),aI)*aP(2^32),aR(aQ(N(P(aJ,24),P(aK,16),P(aL,8),aM))))end;for az=16,79 do local aG,E=aD[az-15],aD[az-2]aD[az]=aU(aZ(aG,1),aZ(aG,8),aX(aG,7))+aU(aZ(E,19),aY(E,3),aX(E,6))+aD[az-7]+aD[az-16]end;local aG,E,aH,aI,aJ,aK,aL,aM=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for az=0,79,8 do local aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+1]+aD[az]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN;aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+2]+aD[az+1]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN;aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+3]+aD[az+2]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN;aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+4]+aD[az+3]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN;aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+5]+aD[az+4]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN;aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+6]+aD[az+5]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN;aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+7]+aD[az+6]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN;aN=aU(aZ(aJ,14),aZ(aJ,18),aY(aJ,23))+aU(aL,aS(aJ,aU(aK,aL)))+aM+aE[az+8]+aD[az+7]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,aU(aS(aU(aG,E),aH),aS(aG,E))+aU(aZ(aG,28),aY(aG,25),aY(aG,30))+aN end;aA[1]=aG+aA[1]aA[2]=E+aA[2]aA[3]=aH+aA[3]aA[4]=aI+aA[4]aA[5]=aJ+aA[5]aA[6]=aK+aA[6]aA[7]=aL+aA[7]aA[8]=aM+aA[8]end end else local bt=D.new(\"union{int64_t i64; struct{int32_t \"..(D.abi(\"le\")and\"lo, hi\"or\"hi, lo\")..\";} i32;}[3]\")local function bu(aG)bt[0].i64=aG;local bv,bw=bt[0].i32.lo,bt[0].i32.hi;local bx=O(Q(bv,1),P(bw,31),Q(bv,8),P(bw,24),Q(bv,7),P(bw,25))local by=O(Q(bw,1),P(bv,31),Q(bw,8),P(bv,24),Q(bw,7))return by*aP(2^32)+aR(aQ(bx))end;local function bz(E)bt[0].i64=E;local bA,bB=bt[0].i32.lo,bt[0].i32.hi;local bC=O(Q(bA,19),P(bB,13),P(bA,3),Q(bB,29),Q(bA,6),P(bB,26))local bD=O(Q(bB,19),P(bA,13),P(bB,3),Q(bA,29),Q(bB,6))return bD*aP(2^32)+aR(aQ(bC))end;local function bE(aJ)bt[0].i64=aJ;local bF,bG=bt[0].i32.lo,bt[0].i32.hi;local bC=O(Q(bF,14),P(bG,18),Q(bF,18),P(bG,14),P(bF,23),Q(bG,9))local bD=O(Q(bG,14),P(bF,18),Q(bG,18),P(bF,14),P(bG,23),Q(bF,9))return bD*aP(2^32)+aR(aQ(bC))end;local function bH(aG)bt[0].i64=aG;local bA,bB=bt[0].i32.lo,bt[0].i32.hi;local bC=O(Q(bA,28),P(bB,4),P(bA,30),Q(bB,2),P(bA,25),Q(bB,7))local bD=O(Q(bB,28),P(bA,4),P(bB,30),Q(bA,2),P(bB,25),Q(bA,7))return bD*aP(2^32)+aR(aQ(bC))end;local function bI(aJ,aK,aL)bt[0].i64=aK;bt[1].i64=aL;bt[2].i64=aJ;local bJ,bK=bt[0].i32.lo,bt[0].i32.hi;local bL,bM=bt[1].i32.lo,bt[1].i32.hi;local bF,bG=bt[2].i32.lo,bt[2].i32.hi;local bN=O(bL,M(bF,O(bJ,bL)))local bO=O(bM,M(bG,O(bK,bM)))return bO*aP(2^32)+aR(aQ(bN))end;local function bP(aG,E,aH)bt[0].i64=aG;bt[1].i64=E;bt[2].i64=aH;local bv,bw=bt[0].i32.lo,bt[0].i32.hi;local bA,bB=bt[1].i32.lo,bt[1].i32.hi;local bQ,bR=bt[2].i32.lo,bt[2].i32.hi;local bN=O(M(O(bv,bA),bQ),M(bv,bA))local bO=O(M(O(bw,bB),bR),M(bw,bB))return bO*aP(2^32)+aR(aQ(bN))end;local function bS(aG,E,s)bt[0].i64=aG;bt[1].i64=E;local bv,bw=bt[0].i32.lo,bt[0].i32.hi;local bA,bB=bt[1].i32.lo,bt[1].i32.hi;local bQ,bR=O(bv,bA),O(bw,bB)local bx=O(Q(bQ,s),P(bR,-s))local by=O(Q(bR,s),P(bQ,-s))return by*aP(2^32)+aR(aQ(bx))end;local function bT(aG,E)bt[0].i64=aG;bt[1].i64=E;local bv,bw=bt[0].i32.lo,bt[0].i32.hi;local bA,bB=bt[1].i32.lo,bt[1].i32.hi;local bQ,bR=O(bv,bA),O(bw,bB)local bx=O(P(bQ,1),Q(bR,31))local by=O(P(bR,1),Q(bQ,31))return by*aP(2^32)+aR(aQ(bx))end;local function bU(aG,E)bt[0].i64=aG;bt[1].i64=E;local bv,bw=bt[0].i32.lo,bt[0].i32.hi;local bA,bB=bt[1].i32.lo,bt[1].i32.hi;local by,bx=O(bv,bA),O(bw,bB)return by*aP(2^32)+aR(aQ(bx))end;local function aU(aG,E)bt[0].i64=aG;bt[1].i64=E;local bv,bw=bt[0].i32.lo,bt[0].i32.hi;local bA,bB=bt[1].i32.lo,bt[1].i32.hi;local bx,by=O(bv,bA),O(bw,bB)return by*aP(2^32)+aR(aQ(bx))end;local function bV(aG,E,aH)bt[0].i64=aG;bt[1].i64=E;bt[2].i64=aH;local bv,bw=bt[0].i32.lo,bt[0].i32.hi;local bA,bB=bt[1].i32.lo,bt[1].i32.hi;local bQ,bR=bt[2].i32.lo,bt[2].i32.hi;local bx,by=O(bv,bA,bQ),O(bw,bB,bR)return by*aP(2^32)+aR(aQ(bx))end;function X(br,bs)bt[0].i64=br;local bW,bX=bt[0].i32.lo,bt[0].i32.hi;local bY,bZ=0xA5A5A5A5,0xA5A5A5A5;if bs then bt[1].i64=bs;bY,bZ=bt[1].i32.lo,bt[1].i32.hi end;bW=O(bW,bY)bX=O(bX,bZ)return bX*aP(2^32)+aR(aQ(bW))end;function aj(br)bt[0].i64=br;return V(bt[0].i32.hi)..V(bt[0].i32.lo)end;function a0(aA,I,aB,aC,ax)local aD,aE=aO,a7;for aF=aC,aC+ax-1,128 do for az=0,15 do aF=aF+8;local aG,E,aH,aI,aJ,aK,aL,aM=c(aB,aF-7,aF)aD[az]=N(P(aG,24),P(E,16),P(aH,8),aI)*aP(2^32)+aR(aQ(N(P(aJ,24),P(aK,16),P(aL,8),aM)))end;for az=16,79 do aD[az]=bu(aD[az-15])+bz(aD[az-2])+aD[az-7]+aD[az-16]end;local aG,E,aH,aI,aJ,aK,aL,aM=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for az=0,79,8 do local aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+1]+aD[az]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN;aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+2]+aD[az+1]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN;aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+3]+aD[az+2]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN;aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+4]+aD[az+3]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN;aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+5]+aD[az+4]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN;aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+6]+aD[az+5]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN;aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+7]+aD[az+6]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN;aN=bE(aJ)+bI(aJ,aK,aL)+aM+aE[az+8]+aD[az+7]aM,aL,aK,aJ=aL,aK,aJ,aN+aI;aI,aH,E,aG=aH,E,aG,bP(aG,E,aH)+bH(aG)+aN end;aA[1]=aG+aA[1]aA[2]=E+aA[2]aA[3]=aH+aA[3]aA[4]=aI+aA[4]aA[5]=aJ+aA[5]aA[6]=aK+aA[6]aA[7]=aL+aA[7]aA[8]=aM+aA[8]end end;do local a_=D.new(\"int64_t[?]\",16)local aD=am;local function b0(aG,E,aH,aI,b1,b2)local b3,b4,b5,b6=a_[aG],a_[E],a_[aH],a_[aI]b3=aD[b1]+b3+b4;b6=bU(b6,b3)b5=b5+b6;b4=bS(b4,b5,24)b3=aD[b2]+b3+b4;b6=bS(b6,b3,16)b5=b5+b6;b4=bT(b4,b5)a_[aG],a_[E],a_[aH],a_[aI]=b3,b4,b5,b6 end;function a5(aA,I,aB,aC,ax,b7,b8,b9)local ba,bb,bc,bd,be,bf,bg,bh=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for aF=aC,aC+ax-1,128 do if aB then for az=1,16 do aF=aF+8;local aG,E,aH,aI,aJ,aK,aL,aM=c(aB,aF-7,aF)aD[az]=aU(N(P(aM,24),P(aL,16),P(aK,8),aJ)*aP(2^32),aR(aQ(N(P(aI,24),P(aH,16),P(E,8),aG))))end end;a_[0x0],a_[0x1],a_[0x2],a_[0x3],a_[0x4],a_[0x5],a_[0x6],a_[0x7]=ba,bb,bc,bd,be,bf,bg,bh;a_[0x8],a_[0x9],a_[0xA],a_[0xB],a_[0xD],a_[0xE],a_[0xF]=a9[1],a9[2],a9[3],a9[4],a9[6],a9[7],a9[8]b7=b7+(b8 or 128)a_[0xC]=aU(a9[5],b7)if b8 then a_[0xE]=-1-a_[0xE]end;if b9 then a_[0xF]=-1-a_[0xF]end;for az=1,12 do local bi=as[az]b0(0,4,8,12,bi[1],bi[2])b0(1,5,9,13,bi[3],bi[4])b0(2,6,10,14,bi[5],bi[6])b0(3,7,11,15,bi[7],bi[8])b0(0,5,10,15,bi[9],bi[10])b0(1,6,11,12,bi[11],bi[12])b0(2,7,8,13,bi[13],bi[14])b0(3,4,9,14,bi[15],bi[16])end;ba=bV(ba,a_[0x0],a_[0x8])bb=bV(bb,a_[0x1],a_[0x9])bc=bV(bc,a_[0x2],a_[0xA])bd=bV(bd,a_[0x3],a_[0xB])be=bV(be,a_[0x4],a_[0xC])bf=bV(bf,a_[0x5],a_[0xD])bg=bV(bg,a_[0x6],a_[0xE])bh=bV(bh,a_[0x7],a_[0xF])end;aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]=ba,bb,bc,bd,be,bf,bg,bh;return b7 end end end;function a1(aA,aB,aC,ax)local aD,aE=ay,ag;for aF=aC,aC+ax-1,64 do for az=0,15 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aI,24),P(aH,16),P(E,8),aG)end;local aG,E,aH,aI=aA[1],aA[2],aA[3],aA[4]for az=0,15,4 do aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az+1]+aD[az]+aG,7)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az+2]+aD[az+1]+aG,12)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az+3]+aD[az+2]+aG,17)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az+4]+aD[az+3]+aG,22)+E)end;for az=16,31,4 do local aL=5*az;aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az+1]+aD[M(aL+1,15)]+aG,5)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az+2]+aD[M(aL+6,15)]+aG,9)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az+3]+aD[M(aL-5,15)]+aG,14)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az+4]+aD[M(aL,15)]+aG,20)+E)end;for az=32,47,4 do local aL=3*az;aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az+1]+aD[M(aL+5,15)]+aG,4)+E)aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az+2]+aD[M(aL+8,15)]+aG,11)+E)aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az+3]+aD[M(aL-5,15)]+aG,16)+E)aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az+4]+aD[M(aL-2,15)]+aG,23)+E)end;for az=48,63,4 do local aL=7*az;aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az+1]+aD[M(aL,15)]+aG,6)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az+2]+aD[M(aL+7,15)]+aG,10)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az+3]+aD[M(aL-2,15)]+aG,15)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az+4]+aD[M(aL+5,15)]+aG,21)+E)end;aA[1],aA[2],aA[3],aA[4]=U(aG+aA[1]),U(E+aA[2]),U(aH+aA[3]),U(aI+aA[4])end end;function a2(aA,aB,aC,ax)local aD=ay;for aF=aC,aC+ax-1,64 do for az=0,15 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aG,24),P(E,16),P(aH,8),aI)end;for az=16,79 do aD[az]=R(O(aD[az-3],aD[az-8],aD[az-14],aD[az-16]),1)end;local aG,E,aH,aI,aJ=aA[1],aA[2],aA[3],aA[4],aA[5]for az=0,19,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+1]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+2]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+3]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+4]+0x5A827999+aJ)end;for az=20,39,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+1]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+2]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+3]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+4]+0x6ED9EBA1+aJ)end;for az=40,59,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+1]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+2]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+3]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+4]+0x8F1BBCDC+aJ)end;for az=60,79,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+1]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+2]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+3]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+4]+0xCA62C1D6+aJ)end;aA[1],aA[2],aA[3],aA[4],aA[5]=U(aG+aA[1]),U(E+aA[2]),U(aH+aA[3]),U(aI+aA[4]),U(aJ+aA[5])end end end;if L==\"FFI\"and not B or L==\"LJ\"then if L==\"FFI\"then local b_=D.typeof\"int32_t[?]\"function Z()return b_(31)end end;function a3(c0,c1,aB,aC,ax,bl)local c2,c3=ab,ac;local bn=Q(bl,3)for aF=aC,aC+ax-1,bl do for az=1,bn do local aG,E,aH,aI=c(aB,aF+1,aF+4)c0[az]=O(c0[az],N(P(aI,24),P(aH,16),P(E,8),aG))aF=aF+8;aG,E,aH,aI=c(aB,aF-3,aF)c1[az]=O(c1[az],N(P(aI,24),P(aH,16),P(E,8),aG))end;for bo=1,24 do for az=1,5 do c0[25+az]=O(c0[az],c0[az+5],c0[az+10],c0[az+15],c0[az+20])end;for az=1,5 do c1[25+az]=O(c1[az],c1[az+5],c1[az+10],c1[az+15],c1[az+20])end;local c4=O(c0[26],P(c0[28],1),Q(c1[28],31))local c5=O(c1[26],P(c1[28],1),Q(c0[28],31))c0[2],c1[2],c0[7],c1[7],c0[12],c1[12],c0[17],c1[17]=O(Q(O(c4,c0[7]),20),P(O(c5,c1[7]),12)),O(Q(O(c5,c1[7]),20),P(O(c4,c0[7]),12)),O(Q(O(c4,c0[17]),19),P(O(c5,c1[17]),13)),O(Q(O(c5,c1[17]),19),P(O(c4,c0[17]),13)),O(P(O(c4,c0[2]),1),Q(O(c5,c1[2]),31)),O(P(O(c5,c1[2]),1),Q(O(c4,c0[2]),31)),O(P(O(c4,c0[12]),10),Q(O(c5,c1[12]),22)),O(P(O(c5,c1[12]),10),Q(O(c4,c0[12]),22))local c6,aA=O(c4,c0[22]),O(c5,c1[22])c0[22],c1[22]=O(P(c6,2),Q(aA,30)),O(P(aA,2),Q(c6,30))c4=O(c0[27],P(c0[29],1),Q(c1[29],31))c5=O(c1[27],P(c1[29],1),Q(c0[29],31))c0[3],c1[3],c0[8],c1[8],c0[13],c1[13],c0[23],c1[23]=O(Q(O(c4,c0[13]),21),P(O(c5,c1[13]),11)),O(Q(O(c5,c1[13]),21),P(O(c4,c0[13]),11)),O(Q(O(c4,c0[23]),3),P(O(c5,c1[23]),29)),O(Q(O(c5,c1[23]),3),P(O(c4,c0[23]),29)),O(P(O(c4,c0[8]),6),Q(O(c5,c1[8]),26)),O(P(O(c5,c1[8]),6),Q(O(c4,c0[8]),26)),O(Q(O(c4,c0[3]),2),P(O(c5,c1[3]),30)),O(Q(O(c5,c1[3]),2),P(O(c4,c0[3]),30))c6,aA=O(c4,c0[18]),O(c5,c1[18])c0[18],c1[18]=O(P(c6,15),Q(aA,17)),O(P(aA,15),Q(c6,17))c4=O(c0[28],P(c0[30],1),Q(c1[30],31))c5=O(c1[28],P(c1[30],1),Q(c0[30],31))c0[4],c1[4],c0[9],c1[9],c0[19],c1[19],c0[24],c1[24]=O(P(O(c4,c0[19]),21),Q(O(c5,c1[19]),11)),O(P(O(c5,c1[19]),21),Q(O(c4,c0[19]),11)),O(P(O(c4,c0[4]),28),Q(O(c5,c1[4]),4)),O(P(O(c5,c1[4]),28),Q(O(c4,c0[4]),4)),O(Q(O(c4,c0[24]),8),P(O(c5,c1[24]),24)),O(Q(O(c5,c1[24]),8),P(O(c4,c0[24]),24)),O(Q(O(c4,c0[9]),9),P(O(c5,c1[9]),23)),O(Q(O(c5,c1[9]),9),P(O(c4,c0[9]),23))c6,aA=O(c4,c0[14]),O(c5,c1[14])c0[14],c1[14]=O(P(c6,25),Q(aA,7)),O(P(aA,25),Q(c6,7))c4=O(c0[29],P(c0[26],1),Q(c1[26],31))c5=O(c1[29],P(c1[26],1),Q(c0[26],31))c0[5],c1[5],c0[15],c1[15],c0[20],c1[20],c0[25],c1[25]=O(P(O(c4,c0[25]),14),Q(O(c5,c1[25]),18)),O(P(O(c5,c1[25]),14),Q(O(c4,c0[25]),18)),O(P(O(c4,c0[20]),8),Q(O(c5,c1[20]),24)),O(P(O(c5,c1[20]),8),Q(O(c4,c0[20]),24)),O(P(O(c4,c0[5]),27),Q(O(c5,c1[5]),5)),O(P(O(c5,c1[5]),27),Q(O(c4,c0[5]),5)),O(Q(O(c4,c0[15]),25),P(O(c5,c1[15]),7)),O(Q(O(c5,c1[15]),25),P(O(c4,c0[15]),7))c6,aA=O(c4,c0[10]),O(c5,c1[10])c0[10],c1[10]=O(P(c6,20),Q(aA,12)),O(P(aA,20),Q(c6,12))c4=O(c0[30],P(c0[27],1),Q(c1[27],31))c5=O(c1[30],P(c1[27],1),Q(c0[27],31))c0[6],c1[6],c0[11],c1[11],c0[16],c1[16],c0[21],c1[21]=O(P(O(c4,c0[11]),3),Q(O(c5,c1[11]),29)),O(P(O(c5,c1[11]),3),Q(O(c4,c0[11]),29)),O(P(O(c4,c0[21]),18),Q(O(c5,c1[21]),14)),O(P(O(c5,c1[21]),18),Q(O(c4,c0[21]),14)),O(Q(O(c4,c0[6]),28),P(O(c5,c1[6]),4)),O(Q(O(c5,c1[6]),28),P(O(c4,c0[6]),4)),O(Q(O(c4,c0[16]),23),P(O(c5,c1[16]),9)),O(Q(O(c5,c1[16]),23),P(O(c4,c0[16]),9))c0[1],c1[1]=O(c4,c0[1]),O(c5,c1[1])c0[1],c0[2],c0[3],c0[4],c0[5]=O(c0[1],M(T(c0[2]),c0[3]),c2[bo]),O(c0[2],M(T(c0[3]),c0[4])),O(c0[3],M(T(c0[4]),c0[5])),O(c0[4],M(T(c0[5]),c0[1])),O(c0[5],M(T(c0[1]),c0[2]))c0[6],c0[7],c0[8],c0[9],c0[10]=O(c0[9],M(T(c0[10]),c0[6])),O(c0[10],M(T(c0[6]),c0[7])),O(c0[6],M(T(c0[7]),c0[8])),O(c0[7],M(T(c0[8]),c0[9])),O(c0[8],M(T(c0[9]),c0[10]))c0[11],c0[12],c0[13],c0[14],c0[15]=O(c0[12],M(T(c0[13]),c0[14])),O(c0[13],M(T(c0[14]),c0[15])),O(c0[14],M(T(c0[15]),c0[11])),O(c0[15],M(T(c0[11]),c0[12])),O(c0[11],M(T(c0[12]),c0[13]))c0[16],c0[17],c0[18],c0[19],c0[20]=O(c0[20],M(T(c0[16]),c0[17])),O(c0[16],M(T(c0[17]),c0[18])),O(c0[17],M(T(c0[18]),c0[19])),O(c0[18],M(T(c0[19]),c0[20])),O(c0[19],M(T(c0[20]),c0[16]))c0[21],c0[22],c0[23],c0[24],c0[25]=O(c0[23],M(T(c0[24]),c0[25])),O(c0[24],M(T(c0[25]),c0[21])),O(c0[25],M(T(c0[21]),c0[22])),O(c0[21],M(T(c0[22]),c0[23])),O(c0[22],M(T(c0[23]),c0[24]))c1[1],c1[2],c1[3],c1[4],c1[5]=O(c1[1],M(T(c1[2]),c1[3]),c3[bo]),O(c1[2],M(T(c1[3]),c1[4])),O(c1[3],M(T(c1[4]),c1[5])),O(c1[4],M(T(c1[5]),c1[1])),O(c1[5],M(T(c1[1]),c1[2]))c1[6],c1[7],c1[8],c1[9],c1[10]=O(c1[9],M(T(c1[10]),c1[6])),O(c1[10],M(T(c1[6]),c1[7])),O(c1[6],M(T(c1[7]),c1[8])),O(c1[7],M(T(c1[8]),c1[9])),O(c1[8],M(T(c1[9]),c1[10]))c1[11],c1[12],c1[13],c1[14],c1[15]=O(c1[12],M(T(c1[13]),c1[14])),O(c1[13],M(T(c1[14]),c1[15])),O(c1[14],M(T(c1[15]),c1[11])),O(c1[15],M(T(c1[11]),c1[12])),O(c1[11],M(T(c1[12]),c1[13]))c1[16],c1[17],c1[18],c1[19],c1[20]=O(c1[20],M(T(c1[16]),c1[17])),O(c1[16],M(T(c1[17]),c1[18])),O(c1[17],M(T(c1[18]),c1[19])),O(c1[18],M(T(c1[19]),c1[20])),O(c1[19],M(T(c1[20]),c1[16]))c1[21],c1[22],c1[23],c1[24],c1[25]=O(c1[23],M(T(c1[24]),c1[25])),O(c1[24],M(T(c1[25]),c1[21])),O(c1[25],M(T(c1[21]),c1[22])),O(c1[21],M(T(c1[22]),c1[23])),O(c1[22],M(T(c1[23]),c1[24]))end end end end;if L==\"LJ\"then function _(aA,aB,aC,ax)local aD,aE=al,a8;for aF=aC,aC+ax-1,64 do for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aG,24),P(E,16),P(aH,8),aI)end;for az=17,64 do local aG,E=aD[az-15],aD[az-2]aD[az]=U(U(O(S(aG,7),R(aG,14),Q(aG,3))+O(R(E,15),R(E,13),Q(E,10)))+U(aD[az-7]+aD[az-16]))end;local aG,E,aH,aI,aJ,aK,aL,aM=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for az=1,64,8 do local aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az]+aD[az]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az+1]+aD[az+1]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az+2]+aD[az+2]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az+3]+aD[az+3]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az+4]+aD[az+4]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az+5]+aD[az+5]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az+6]+aD[az+6]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)aN=U(O(S(aJ,6),S(aJ,11),R(aJ,7))+O(aL,M(aJ,O(aK,aL)))+aE[az+7]+aD[az+7]+aM)aM,aL,aK,aJ=aL,aK,aJ,U(aI+aN)aI,aH,E,aG=aH,E,aG,U(O(M(aG,O(E,aH)),M(E,aH))+O(S(aG,2),S(aG,13),R(aG,10))+aN)end;aA[1],aA[2],aA[3],aA[4]=U(aG+aA[1]),U(E+aA[2]),U(aH+aA[3]),U(aI+aA[4])aA[5],aA[6],aA[7],aA[8]=U(aJ+aA[5]),U(aK+aA[6]),U(aL+aA[7]),U(aM+aA[8])end end;local function c7(bv,bw,bA,bB,bQ,bR,c8,c9)local ca=bv%2^32+bA%2^32+bQ%2^32+c8%2^32;local cb=bw+bB+bR+c9;local bN=U(ca)local bO=U(cb+j(ca/2^32))return bN,bO end;if C==\"x86\"then function a0(cc,cd,aB,aC,ax)local aD,ce,cf=al,a7,a8;for aF=aC,aC+ax-1,128 do for az=1,16*2 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aG,24),P(E,16),P(aH,8),aI)end;for cg=17*2,80*2,2 do local bv,bw=aD[cg-30],aD[cg-31]local bx=O(N(Q(bv,1),P(bw,31)),N(Q(bv,8),P(bw,24)),N(Q(bv,7),P(bw,25)))local by=O(N(Q(bw,1),P(bv,31)),N(Q(bw,8),P(bv,24)),Q(bw,7))local bA,bB=aD[cg-4],aD[cg-5]local bC=O(N(Q(bA,19),P(bB,13)),N(P(bA,3),Q(bB,29)),N(Q(bA,6),P(bB,26)))local bD=O(N(Q(bB,19),P(bA,13)),N(P(bB,3),Q(bA,29)),Q(bB,6))aD[cg],aD[cg-1]=c7(bx,by,bC,bD,aD[cg-14],aD[cg-15],aD[cg-32],aD[cg-33])end;local bv,bA,bQ,c8,bF,bJ,bL,ch=cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]local bw,bB,bR,c9,bG,bK,bM,ci=cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]local cj=0;for az=1,80 do local bx=O(bL,M(bF,O(bJ,bL)))local by=O(bM,M(bG,O(bK,bM)))local bC=O(N(Q(bF,14),P(bG,18)),N(Q(bF,18),P(bG,14)),N(P(bF,23),Q(bG,9)))local bD=O(N(Q(bG,14),P(bF,18)),N(Q(bG,18),P(bF,14)),N(P(bG,23),Q(bF,9)))local ca=bC%2^32+bx%2^32+ch%2^32+ce[az]+aD[2*az]%2^32;local ck,cl=U(ca),U(bD+by+ci+cf[az]+aD[2*az-1]+j(ca/2^32))cj=cj+cj;ch,ci,bL,bM,bJ,bK=N(cj,bL),N(cj,bM),N(cj,bJ),N(cj,bK),N(cj,bF),N(cj,bG)local ca=ck%2^32+c8%2^32;bF,bG=U(ca),U(cl+c9+j(ca/2^32))c8,c9,bQ,bR,bA,bB=N(cj,bQ),N(cj,bR),N(cj,bA),N(cj,bB),N(cj,bv),N(cj,bw)bC=O(N(Q(bA,28),P(bB,4)),N(P(bA,30),Q(bB,2)),N(P(bA,25),Q(bB,7)))bD=O(N(Q(bB,28),P(bA,4)),N(P(bB,30),Q(bA,2)),N(P(bB,25),Q(bA,7)))bx=N(M(c8,bQ),M(bA,O(c8,bQ)))by=N(M(c9,bR),M(bB,O(c9,bR)))local ca=ck%2^32+bx%2^32+bC%2^32;bv,bw=U(ca),U(cl+by+bD+j(ca/2^32))end;cc[1],cd[1]=c7(cc[1],cd[1],bv,bw,0,0,0,0)cc[2],cd[2]=c7(cc[2],cd[2],bA,bB,0,0,0,0)cc[3],cd[3]=c7(cc[3],cd[3],bQ,bR,0,0,0,0)cc[4],cd[4]=c7(cc[4],cd[4],c8,c9,0,0,0,0)cc[5],cd[5]=c7(cc[5],cd[5],bF,bG,0,0,0,0)cc[6],cd[6]=c7(cc[6],cd[6],bJ,bK,0,0,0,0)cc[7],cd[7]=c7(cc[7],cd[7],bL,bM,0,0,0,0)cc[8],cd[8]=c7(cc[8],cd[8],ch,ci,0,0,0,0)end end else function a0(cc,cd,aB,aC,ax)local aD,ce,cf=al,a7,a8;for aF=aC,aC+ax-1,128 do for az=1,16*2 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aG,24),P(E,16),P(aH,8),aI)end;for cg=17*2,80*2,2 do local bv,bw=aD[cg-30],aD[cg-31]local bx=O(N(Q(bv,1),P(bw,31)),N(Q(bv,8),P(bw,24)),N(Q(bv,7),P(bw,25)))local by=O(N(Q(bw,1),P(bv,31)),N(Q(bw,8),P(bv,24)),Q(bw,7))local bA,bB=aD[cg-4],aD[cg-5]local bC=O(N(Q(bA,19),P(bB,13)),N(P(bA,3),Q(bB,29)),N(Q(bA,6),P(bB,26)))local bD=O(N(Q(bB,19),P(bA,13)),N(P(bB,3),Q(bA,29)),Q(bB,6))aD[cg],aD[cg-1]=c7(bx,by,bC,bD,aD[cg-14],aD[cg-15],aD[cg-32],aD[cg-33])end;local bv,bA,bQ,c8,bF,bJ,bL,ch=cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]local bw,bB,bR,c9,bG,bK,bM,ci=cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]for az=1,80 do local bx=O(bL,M(bF,O(bJ,bL)))local by=O(bM,M(bG,O(bK,bM)))local bC=O(N(Q(bF,14),P(bG,18)),N(Q(bF,18),P(bG,14)),N(P(bF,23),Q(bG,9)))local bD=O(N(Q(bG,14),P(bF,18)),N(Q(bG,18),P(bF,14)),N(P(bG,23),Q(bF,9)))local ca=bC%2^32+bx%2^32+ch%2^32+ce[az]+aD[2*az]%2^32;local ck,cl=U(ca),U(bD+by+ci+cf[az]+aD[2*az-1]+j(ca/2^32))ch,ci,bL,bM,bJ,bK=bL,bM,bJ,bK,bF,bG;local ca=ck%2^32+c8%2^32;bF,bG=U(ca),U(cl+c9+j(ca/2^32))c8,c9,bQ,bR,bA,bB=bQ,bR,bA,bB,bv,bw;bC=O(N(Q(bA,28),P(bB,4)),N(P(bA,30),Q(bB,2)),N(P(bA,25),Q(bB,7)))bD=O(N(Q(bB,28),P(bA,4)),N(P(bB,30),Q(bA,2)),N(P(bB,25),Q(bA,7)))bx=N(M(c8,bQ),M(bA,O(c8,bQ)))by=N(M(c9,bR),M(bB,O(c9,bR)))local ca=ck%2^32+bC%2^32+bx%2^32;bv,bw=U(ca),U(cl+bD+by+j(ca/2^32))end;cc[1],cd[1]=c7(cc[1],cd[1],bv,bw,0,0,0,0)cc[2],cd[2]=c7(cc[2],cd[2],bA,bB,0,0,0,0)cc[3],cd[3]=c7(cc[3],cd[3],bQ,bR,0,0,0,0)cc[4],cd[4]=c7(cc[4],cd[4],c8,c9,0,0,0,0)cc[5],cd[5]=c7(cc[5],cd[5],bF,bG,0,0,0,0)cc[6],cd[6]=c7(cc[6],cd[6],bJ,bK,0,0,0,0)cc[7],cd[7]=c7(cc[7],cd[7],bL,bM,0,0,0,0)cc[8],cd[8]=c7(cc[8],cd[8],ch,ci,0,0,0,0)end end end;function a1(aA,aB,aC,ax)local aD,aE=al,ag;for aF=aC,aC+ax-1,64 do for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aI,24),P(aH,16),P(E,8),aG)end;local aG,E,aH,aI=aA[1],aA[2],aA[3],aA[4]for az=1,16,4 do aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az]+aD[az]+aG,7)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az+1]+aD[az+1]+aG,12)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az+2]+aD[az+2]+aG,17)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aI,M(E,O(aH,aI)))+aE[az+3]+aD[az+3]+aG,22)+E)end;for az=17,32,4 do local aL=5*az-4;aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az]+aD[M(aL,15)+1]+aG,5)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az+1]+aD[M(aL+5,15)+1]+aG,9)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az+2]+aD[M(aL+10,15)+1]+aG,14)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,M(aI,O(E,aH)))+aE[az+3]+aD[M(aL-1,15)+1]+aG,20)+E)end;for az=33,48,4 do local aL=3*az+2;aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az]+aD[M(aL,15)+1]+aG,4)+E)aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az+1]+aD[M(aL+3,15)+1]+aG,11)+E)aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az+2]+aD[M(aL+6,15)+1]+aG,16)+E)aG,aI,aH,E=aI,aH,E,U(R(O(E,aH,aI)+aE[az+3]+aD[M(aL-7,15)+1]+aG,23)+E)end;for az=49,64,4 do local aL=az*7;aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az]+aD[M(aL-7,15)+1]+aG,6)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az+1]+aD[M(aL,15)+1]+aG,10)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az+2]+aD[M(aL+7,15)+1]+aG,15)+E)aG,aI,aH,E=aI,aH,E,U(R(O(aH,N(E,T(aI)))+aE[az+3]+aD[M(aL-2,15)+1]+aG,21)+E)end;aA[1],aA[2],aA[3],aA[4]=U(aG+aA[1]),U(E+aA[2]),U(aH+aA[3]),U(aI+aA[4])end end;function a2(aA,aB,aC,ax)local aD=al;for aF=aC,aC+ax-1,64 do for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aG,24),P(E,16),P(aH,8),aI)end;for az=17,80 do aD[az]=R(O(aD[az-3],aD[az-8],aD[az-14],aD[az-16]),1)end;local aG,E,aH,aI,aJ=aA[1],aA[2],aA[3],aA[4],aA[5]for az=1,20,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+1]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+2]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+3]+0x5A827999+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(aI,M(E,O(aI,aH)))+aD[az+4]+0x5A827999+aJ)end;for az=21,40,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+1]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+2]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+3]+0x6ED9EBA1+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+4]+0x6ED9EBA1+aJ)end;for az=41,60,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+1]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+2]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+3]+0x8F1BBCDC+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(M(aI,O(E,aH)),M(E,aH))+aD[az+4]+0x8F1BBCDC+aJ)end;for az=61,80,5 do aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+1]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+2]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+3]+0xCA62C1D6+aJ)aJ,aI,aH,E,aG=aI,aH,S(E,2),aG,U(R(aG,5)+O(E,aH,aI)+aD[az+4]+0xCA62C1D6+aJ)end;aA[1],aA[2],aA[3],aA[4],aA[5]=U(aG+aA[1]),U(E+aA[2]),U(aH+aA[3]),U(aI+aA[4]),U(aJ+aA[5])end end;do local cm,cn={},{}local function b0(aG,E,aH,aI,b1,b2)local aD=al;local co,cp,cq,cr=cm[aG],cm[E],cm[aH],cm[aI]local cs,ct,cu,cv=cn[aG],cn[E],cn[aH],cn[aI]local aN=aD[2*b1-1]+co%2^32+cp%2^32;co=U(aN)cs=U(aD[2*b1]+cs+ct+j(aN/2^32))cr,cv=O(cv,cs),O(cr,co)aN=cq%2^32+cr%2^32;cq=U(aN)cu=U(cu+cv+j(aN/2^32))cp,ct=O(cp,cq),O(ct,cu)cp,ct=O(Q(cp,24),P(ct,8)),O(Q(ct,24),P(cp,8))aN=aD[2*b2-1]+co%2^32+cp%2^32;co=U(aN)cs=U(aD[2*b2]+cs+ct+j(aN/2^32))cr,cv=O(cr,co),O(cv,cs)cr,cv=O(Q(cr,16),P(cv,16)),O(Q(cv,16),P(cr,16))aN=cq%2^32+cr%2^32;cq=U(aN)cu=U(cu+cv+j(aN/2^32))cp,ct=O(cp,cq),O(ct,cu)cp,ct=O(P(cp,1),Q(ct,31)),O(P(ct,1),Q(cp,31))cm[aG],cm[E],cm[aH],cm[aI]=co,cp,cq,cr;cn[aG],cn[E],cn[aH],cn[aI]=cs,ct,cu,cv end;function a5(cc,cd,aB,aC,ax,b7,b8,b9)local aD=al;local cw,cx,cy,cz,cA,cB,cC,cD=cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]local cE,cF,cG,cH,cI,cJ,cK,cL=cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]for aF=aC,aC+ax-1,128 do if aB then for az=1,32 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=aI*2^24+N(P(aH,16),P(E,8),aG)end end;cm[0x0],cm[0x1],cm[0x2],cm[0x3],cm[0x4],cm[0x5],cm[0x6],cm[0x7]=cw,cx,cy,cz,cA,cB,cC,cD;cm[0x8],cm[0x9],cm[0xA],cm[0xB],cm[0xC],cm[0xD],cm[0xE],cm[0xF]=a9[1],a9[2],a9[3],a9[4],a9[5],a9[6],a9[7],a9[8]cn[0x0],cn[0x1],cn[0x2],cn[0x3],cn[0x4],cn[0x5],cn[0x6],cn[0x7]=cE,cF,cG,cH,cI,cJ,cK,cL;cn[0x8],cn[0x9],cn[0xA],cn[0xB],cn[0xC],cn[0xD],cn[0xE],cn[0xF]=aa[1],aa[2],aa[3],aa[4],aa[5],aa[6],aa[7],aa[8]b7=b7+(b8 or 128)local cM=b7%2^32;local cN=j(b7/2^32)cm[0xC]=O(cm[0xC],cM)cn[0xC]=O(cn[0xC],cN)if b8 then cm[0xE]=T(cm[0xE])cn[0xE]=T(cn[0xE])end;if b9 then cm[0xF]=T(cm[0xF])cn[0xF]=T(cn[0xF])end;for az=1,12 do local bi=as[az]b0(0,4,8,12,bi[1],bi[2])b0(1,5,9,13,bi[3],bi[4])b0(2,6,10,14,bi[5],bi[6])b0(3,7,11,15,bi[7],bi[8])b0(0,5,10,15,bi[9],bi[10])b0(1,6,11,12,bi[11],bi[12])b0(2,7,8,13,bi[13],bi[14])b0(3,4,9,14,bi[15],bi[16])end;cw=O(cw,cm[0x0],cm[0x8])cx=O(cx,cm[0x1],cm[0x9])cy=O(cy,cm[0x2],cm[0xA])cz=O(cz,cm[0x3],cm[0xB])cA=O(cA,cm[0x4],cm[0xC])cB=O(cB,cm[0x5],cm[0xD])cC=O(cC,cm[0x6],cm[0xE])cD=O(cD,cm[0x7],cm[0xF])cE=O(cE,cn[0x0],cn[0x8])cF=O(cF,cn[0x1],cn[0x9])cG=O(cG,cn[0x2],cn[0xA])cH=O(cH,cn[0x3],cn[0xB])cI=O(cI,cn[0x4],cn[0xC])cJ=O(cJ,cn[0x5],cn[0xD])cK=O(cK,cn[0x6],cn[0xE])cL=O(cL,cn[0x7],cn[0xF])end;cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]=cw%2^32,cx%2^32,cy%2^32,cz%2^32,cA%2^32,cB%2^32,cC%2^32,cD%2^32;cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]=cE%2^32,cF%2^32,cG%2^32,cH%2^32,cI%2^32,cJ%2^32,cK%2^32,cL%2^32;return b7 end end end;if L==\"FFI\"or L==\"LJ\"then do local aD=an;local a_=ao;local function b0(aG,E,aH,aI,b1,b2)local b3,b4,b5,b6=a_[aG],a_[E],a_[aH],a_[aI]b3=U(aD[b1]+b3+b4)b6=S(O(b6,b3),16)b5=U(b5+b6)b4=S(O(b4,b5),12)b3=U(aD[b2]+b3+b4)b6=S(O(b6,b3),8)b5=U(b5+b6)b4=S(O(b4,b5),7)a_[aG],a_[E],a_[aH],a_[aI]=b3,b4,b5,b6 end;function a4(aA,aB,aC,ax,b7,b8,b9)local ba,bb,bc,bd,be,bf,bg,bh=U(aA[1]),U(aA[2]),U(aA[3]),U(aA[4]),U(aA[5]),U(aA[6]),U(aA[7]),U(aA[8])for aF=aC,aC+ax-1,64 do if aB then for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aI,24),P(aH,16),P(E,8),aG)end end;a_[0x0],a_[0x1],a_[0x2],a_[0x3],a_[0x4],a_[0x5],a_[0x6],a_[0x7]=ba,bb,bc,bd,be,bf,bg,bh;a_[0x8],a_[0x9],a_[0xA],a_[0xB],a_[0xE],a_[0xF]=U(aa[1]),U(aa[2]),U(aa[3]),U(aa[4]),U(aa[7]),U(aa[8])b7=b7+(b8 or 64)local cO=b7%2^32;local cP=j(b7/2^32)a_[0xC]=O(aa[5],cO)a_[0xD]=O(aa[6],cP)if b8 then a_[0xE]=T(a_[0xE])end;if b9 then a_[0xF]=T(a_[0xF])end;for az=1,10 do local bi=as[az]b0(0,4,8,12,bi[1],bi[2])b0(1,5,9,13,bi[3],bi[4])b0(2,6,10,14,bi[5],bi[6])b0(3,7,11,15,bi[7],bi[8])b0(0,5,10,15,bi[9],bi[10])b0(1,6,11,12,bi[11],bi[12])b0(2,7,8,13,bi[13],bi[14])b0(3,4,9,14,bi[15],bi[16])end;ba=O(ba,a_[0x0],a_[0x8])bb=O(bb,a_[0x1],a_[0x9])bc=O(bc,a_[0x2],a_[0xA])bd=O(bd,a_[0x3],a_[0xB])be=O(be,a_[0x4],a_[0xC])bf=O(bf,a_[0x5],a_[0xD])bg=O(bg,a_[0x6],a_[0xE])bh=O(bh,a_[0x7],a_[0xF])end;aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]=ba,bb,bc,bd,be,bf,bg,bh;return b7 end;function a6(aB,aC,ax,cQ,cR,cS,cT,cU,cV)cV=cV or 64;local ba,bb,bc,bd,be,bf,bg,bh=U(cS[1]),U(cS[2]),U(cS[3]),U(cS[4]),U(cS[5]),U(cS[6]),U(cS[7]),U(cS[8])cT=cT or cS;for aF=aC,aC+ax-1,64 do if aB then for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=N(P(aI,24),P(aH,16),P(E,8),aG)end end;a_[0x0],a_[0x1],a_[0x2],a_[0x3],a_[0x4],a_[0x5],a_[0x6],a_[0x7]=ba,bb,bc,bd,be,bf,bg,bh;a_[0x8],a_[0x9],a_[0xA],a_[0xB]=U(aa[1]),U(aa[2]),U(aa[3]),U(aa[4])a_[0xC]=U(cR%2^32)a_[0xD]=j(cR/2^32)a_[0xE],a_[0xF]=cV,cQ;for az=1,7 do b0(0,4,8,12,at[az],at[az+14])b0(1,5,9,13,at[az+1],at[az+2])b0(2,6,10,14,at[az+16],at[az+7])b0(3,7,11,15,at[az+15],at[az+17])b0(0,5,10,15,at[az+21],at[az+5])b0(1,6,11,12,at[az+3],at[az+6])b0(2,7,8,13,at[az+4],at[az+18])b0(3,4,9,14,at[az+19],at[az+20])end;if cU then cT[9]=O(ba,a_[0x8])cT[10]=O(bb,a_[0x9])cT[11]=O(bc,a_[0xA])cT[12]=O(bd,a_[0xB])cT[13]=O(be,a_[0xC])cT[14]=O(bf,a_[0xD])cT[15]=O(bg,a_[0xE])cT[16]=O(bh,a_[0xF])end;ba=O(a_[0x0],a_[0x8])bb=O(a_[0x1],a_[0x9])bc=O(a_[0x2],a_[0xA])bd=O(a_[0x3],a_[0xB])be=O(a_[0x4],a_[0xC])bf=O(a_[0x5],a_[0xD])bg=O(a_[0x6],a_[0xE])bh=O(a_[0x7],a_[0xF])end;cT[1],cT[2],cT[3],cT[4],cT[5],cT[6],cT[7],cT[8]=ba,bb,bc,bd,be,bf,bg,bh end end end;O=O or X;if L==\"LIB32\"or L==\"EMUL\"then function _(aA,aB,aC,ax)local aD,aE=al,a8;local ba,bb,bc,bd,be,bf,bg,bh=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for aF=aC,aC+ax-1,64 do for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=((aG*256+E)*256+aH)*256+aI end;for az=17,64 do local aG,E=aD[az-15],aD[az-2]local cW,cX,cY,cZ=aG/2^7,aG/2^18,E/2^17,E/2^19;aD[az]=(O(cW%1*(2^32-1)+cW,cX%1*(2^32-1)+cX,(aG-aG%2^3)/2^3)+aD[az-16]+aD[az-7]+O(cY%1*(2^32-1)+cY,cZ%1*(2^32-1)+cZ,(E-E%2^10)/2^10))%2^32 end;local aG,E,aH,aI,aJ,aK,aL,aM=ba,bb,bc,bd,be,bf,bg,bh;for az=1,64 do aJ=aJ%2^32;local c_,d0,d1=aJ/2^6,aJ/2^11,aJ*2^7;local d2=d1%2^32;local aN=M(aJ,aK)+M(-1-aJ,aL)+aM+aE[az]+aD[az]+O(c_%1*(2^32-1)+c_,d0%1*(2^32-1)+d0,d2+(d1-d2)/2^32)aM=aL;aL=aK;aK=aJ;aJ=aN+aI;aI=aH;aH=E;E=aG%2^32;local d3,d4,d5=E/2^2,E/2^13,E*2^10;local d6=d5%2^32;aG=aN+M(aI,aH)+M(E,O(aI,aH))+O(d3%1*(2^32-1)+d3,d4%1*(2^32-1)+d4,d6+(d5-d6)/2^32)end;ba,bb,bc,bd=(aG+ba)%2^32,(E+bb)%2^32,(aH+bc)%2^32,(aI+bd)%2^32;be,bf,bg,bh=(aJ+be)%2^32,(aK+bf)%2^32,(aL+bg)%2^32,(aM+bh)%2^32 end;aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]=ba,bb,bc,bd,be,bf,bg,bh end;function a0(cc,cd,aB,aC,ax)local aD,ce,cf=al,a7,a8;local cw,cx,cy,cz,cA,cB,cC,cD=cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]local cE,cF,cG,cH,cI,cJ,cK,cL=cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]for aF=aC,aC+ax-1,128 do for az=1,16*2 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=((aG*256+E)*256+aH)*256+aI end;for cg=17*2,80*2,2 do local bw,bv,bB,bA=aD[cg-31],aD[cg-30],aD[cg-5],aD[cg-4]local d7,d8,d9,da,db,dc,dd,de,df,dg=bB%2^6,bB%2^19,bB%2^29,bA%2^19,bA%2^29,bw%2^1,bw%2^7,bw%2^8,bv%2^1,bv%2^8;local dh=O((bv-df)/2^1+dc*2^31,(bv-dg)/2^8+de*2^24,(bv-bv%2^7)/2^7+dd*2^25)%2^32+O((bA-da)/2^19+d8*2^13,db*2^3+(bB-d9)/2^29,(bA-bA%2^6)/2^6+d7*2^26)%2^32+aD[cg-14]+aD[cg-32]local di=dh%2^32;aD[cg-1]=(O((bw-dc)/2^1+df*2^31,(bw-de)/2^8+dg*2^24,(bw-dd)/2^7)+O((bB-d8)/2^19+da*2^13,d9*2^3+(bA-db)/2^29,(bB-d7)/2^6)+aD[cg-15]+aD[cg-33]+(dh-di)/2^32)%2^32;aD[cg]=di end;local bv,bA,bQ,c8,bF,bJ,bL,ch=cw,cx,cy,cz,cA,cB,cC,cD;local bw,bB,bR,c9,bG,bK,bM,ci=cE,cF,cG,cH,cI,cJ,cK,cL;for az=1,80 do local cg=2*az;local dj,dk,dl,dm,dn,dp=bF%2^9,bF%2^14,bF%2^18,bG%2^9,bG%2^14,bG%2^18;local dh=(M(bF,bJ)+M(-1-bF,bL))%2^32+ch+ce[az]+aD[cg]+O((bF-dk)/2^14+dn*2^18,(bF-dl)/2^18+dp*2^14,dj*2^23+(bG-dm)/2^9)%2^32;local ck=dh%2^32;local cl=M(bG,bK)+M(-1-bG,bM)+ci+cf[az]+aD[cg-1]+(dh-ck)/2^32+O((bG-dn)/2^14+dk*2^18,(bG-dp)/2^18+dl*2^14,dm*2^23+(bF-dj)/2^9)ch=bL;ci=bM;bL=bJ;bM=bK;bJ=bF;bK=bG;dh=ck+c8;bF=dh%2^32;bG=(cl+c9+(dh-bF)/2^32)%2^32;c8=bQ;c9=bR;bQ=bA;bR=bB;bA=bv;bB=bw;local dq,dr,ds,dt,du,dv=bA%2^2,bA%2^7,bA%2^28,bB%2^2,bB%2^7,bB%2^28;dh=ck+(M(c8,bQ)+M(bA,O(c8,bQ)))%2^32+O((bA-ds)/2^28+dv*2^4,dq*2^30+(bB-dt)/2^2,dr*2^25+(bB-du)/2^7)%2^32;bv=dh%2^32;bw=(cl+M(c9,bR)+M(bB,O(c9,bR))+(dh-bv)/2^32+O((bB-dv)/2^28+ds*2^4,dt*2^30+(bA-dq)/2^2,du*2^25+(bA-dr)/2^7))%2^32 end;bv=cw+bv;cw=bv%2^32;cE=(cE+bw+(bv-cw)/2^32)%2^32;bv=cx+bA;cx=bv%2^32;cF=(cF+bB+(bv-cx)/2^32)%2^32;bv=cy+bQ;cy=bv%2^32;cG=(cG+bR+(bv-cy)/2^32)%2^32;bv=cz+c8;cz=bv%2^32;cH=(cH+c9+(bv-cz)/2^32)%2^32;bv=cA+bF;cA=bv%2^32;cI=(cI+bG+(bv-cA)/2^32)%2^32;bv=cB+bJ;cB=bv%2^32;cJ=(cJ+bK+(bv-cB)/2^32)%2^32;bv=cC+bL;cC=bv%2^32;cK=(cK+bM+(bv-cC)/2^32)%2^32;bv=cD+ch;cD=bv%2^32;cL=(cL+ci+(bv-cD)/2^32)%2^32 end;cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]=cw,cx,cy,cz,cA,cB,cC,cD;cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]=cE,cF,cG,cH,cI,cJ,cK,cL end;if L==\"LIB32\"then function a1(aA,aB,aC,ax)local aD,aE,ai=al,ag,ai;local ba,bb,bc,bd=aA[1],aA[2],aA[3],aA[4]for aF=aC,aC+ax-1,64 do for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=((aI*256+aH)*256+E)*256+aG end;local aG,E,aH,aI=ba,bb,bc,bd;local dw=25;for az=1,16 do local dx=S(M(E,aH)+M(-1-E,aI)+aG+aE[az]+aD[az],dw)+E;dw=ai[dw]aG=aI;aI=aH;aH=E;E=dx end;dw=27;for az=17,32 do local dx=S(M(aI,E)+M(-1-aI,aH)+aG+aE[az]+aD[(5*az-4)%16+1],dw)+E;dw=ai[dw]aG=aI;aI=aH;aH=E;E=dx end;dw=28;for az=33,48 do local dx=S(O(O(E,aH),aI)+aG+aE[az]+aD[(3*az+2)%16+1],dw)+E;dw=ai[dw]aG=aI;aI=aH;aH=E;E=dx end;dw=26;for az=49,64 do local dx=S(O(aH,N(E,-1-aI))+aG+aE[az]+aD[(az*7-7)%16+1],dw)+E;dw=ai[dw]aG=aI;aI=aH;aH=E;E=dx end;ba=(aG+ba)%2^32;bb=(E+bb)%2^32;bc=(aH+bc)%2^32;bd=(aI+bd)%2^32 end;aA[1],aA[2],aA[3],aA[4]=ba,bb,bc,bd end end;function a2(aA,aB,aC,ax)local aD=al;local ba,bb,bc,bd,be=aA[1],aA[2],aA[3],aA[4],aA[5]for aF=aC,aC+ax-1,64 do for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=((aG*256+E)*256+aH)*256+aI end;for az=17,80 do local aG=O(aD[az-3],aD[az-8],aD[az-14],aD[az-16])%2^32*2;local E=aG%2^32;aD[az]=E+(aG-E)/2^32 end;local aG,E,aH,aI,aJ=ba,bb,bc,bd,be;for az=1,20 do local dy=aG*2^5;local aN=dy%2^32;aN=aN+(dy-aN)/2^32+M(E,aH)+M(-1-E,aI)+0x5A827999+aD[az]+aJ;aJ=aI;aI=aH;aH=E/2^2;aH=aH%1*(2^32-1)+aH;E=aG;aG=aN%2^32 end;for az=21,40 do local dy=aG*2^5;local aN=dy%2^32;aN=aN+(dy-aN)/2^32+O(E,aH,aI)+0x6ED9EBA1+aD[az]+aJ;aJ=aI;aI=aH;aH=E/2^2;aH=aH%1*(2^32-1)+aH;E=aG;aG=aN%2^32 end;for az=41,60 do local dy=aG*2^5;local aN=dy%2^32;aN=aN+(dy-aN)/2^32+M(aI,aH)+M(E,O(aI,aH))+0x8F1BBCDC+aD[az]+aJ;aJ=aI;aI=aH;aH=E/2^2;aH=aH%1*(2^32-1)+aH;E=aG;aG=aN%2^32 end;for az=61,80 do local dy=aG*2^5;local aN=dy%2^32;aN=aN+(dy-aN)/2^32+O(E,aH,aI)+0xCA62C1D6+aD[az]+aJ;aJ=aI;aI=aH;aH=E/2^2;aH=aH%1*(2^32-1)+aH;E=aG;aG=aN%2^32 end;ba=(aG+ba)%2^32;bb=(E+bb)%2^32;bc=(aH+bc)%2^32;bd=(aI+bd)%2^32;be=(aJ+be)%2^32 end;aA[1],aA[2],aA[3],aA[4],aA[5]=ba,bb,bc,bd,be end;function a3(c0,c1,aB,aC,ax,bl)local c2,c3=ab,ac;local bn=bl/8;for aF=aC,aC+ax-1,bl do for az=1,bn do local aG,E,aH,aI=c(aB,aF+1,aF+4)c0[az]=O(c0[az],((aI*256+aH)*256+E)*256+aG)aF=aF+8;aG,E,aH,aI=c(aB,aF-3,aF)c1[az]=O(c1[az],((aI*256+aH)*256+E)*256+aG)end;local dz,dA,dB,dC,dD,dE,dF,dG,dH,dI,dJ,dK,dL,dM,dN,dO,dP,dQ,dR,dS,dT,dU,dV,dW,dX,dY,dZ,d_,e0,e1,e2,e3,e4,e5,e6,e7,e8,e9,ea,eb,ec,ed,ee,ef,eg,eh,ei,ej,ek,el=c0[1],c1[1],c0[2],c1[2],c0[3],c1[3],c0[4],c1[4],c0[5],c1[5],c0[6],c1[6],c0[7],c1[7],c0[8],c1[8],c0[9],c1[9],c0[10],c1[10],c0[11],c1[11],c0[12],c1[12],c0[13],c1[13],c0[14],c1[14],c0[15],c1[15],c0[16],c1[16],c0[17],c1[17],c0[18],c1[18],c0[19],c1[19],c0[20],c1[20],c0[21],c1[21],c0[22],c1[22],c0[23],c1[23],c0[24],c1[24],c0[25],c1[25]for bo=1,24 do local em=O(dz,dJ,dT,e2,ec)local en=O(dA,dK,dU,e3,ed)local eo=O(dB,dL,dV,e4,ee)local ep=O(dC,dM,dW,e5,ef)local eq=O(dD,dN,dX,e6,eg)local er=O(dE,dO,dY,e7,eh)local es=O(dF,dP,dZ,e8,ei)local et=O(dG,dQ,d_,e9,ej)local eu=O(dH,dR,e0,ea,ek)local ev=O(dI,dS,e1,eb,el)local c4=O(em,eq*2+(er%2^32-er%2^31)/2^31)local c5=O(en,er*2+(eq%2^32-eq%2^31)/2^31)local ew=O(c4,dB)local ex=O(c5,dC)local ey=O(c4,dL)local ez=O(c5,dM)local eA=O(c4,dV)local eB=O(c5,dW)local eC=O(c4,e4)local eD=O(c5,e5)local eE=O(c4,ee)local eF=O(c5,ef)dB=(ey%2^32-ey%2^20)/2^20+ez*2^12;dC=(ez%2^32-ez%2^20)/2^20+ey*2^12;dL=(eC%2^32-eC%2^19)/2^19+eD*2^13;dM=(eD%2^32-eD%2^19)/2^19+eC*2^13;dV=ew*2+(ex%2^32-ex%2^31)/2^31;dW=ex*2+(ew%2^32-ew%2^31)/2^31;e4=eA*2^10+(eB%2^32-eB%2^22)/2^22;e5=eB*2^10+(eA%2^32-eA%2^22)/2^22;ee=eE*2^2+(eF%2^32-eF%2^30)/2^30;ef=eF*2^2+(eE%2^32-eE%2^30)/2^30;c4=O(eo,es*2+(et%2^32-et%2^31)/2^31)c5=O(ep,et*2+(es%2^32-es%2^31)/2^31)ew=O(c4,dD)ex=O(c5,dE)ey=O(c4,dN)ez=O(c5,dO)eA=O(c4,dX)eB=O(c5,dY)eC=O(c4,e6)eD=O(c5,e7)eE=O(c4,eg)eF=O(c5,eh)dD=(eA%2^32-eA%2^21)/2^21+eB*2^11;dE=(eB%2^32-eB%2^21)/2^21+eA*2^11;dN=(eE%2^32-eE%2^3)/2^3+eF*2^29%2^32;dO=(eF%2^32-eF%2^3)/2^3+eE*2^29%2^32;dX=ey*2^6+(ez%2^32-ez%2^26)/2^26;dY=ez*2^6+(ey%2^32-ey%2^26)/2^26;e6=eC*2^15+(eD%2^32-eD%2^17)/2^17;e7=eD*2^15+(eC%2^32-eC%2^17)/2^17;eg=(ew%2^32-ew%2^2)/2^2+ex*2^30%2^32;eh=(ex%2^32-ex%2^2)/2^2+ew*2^30%2^32;c4=O(eq,eu*2+(ev%2^32-ev%2^31)/2^31)c5=O(er,ev*2+(eu%2^32-eu%2^31)/2^31)ew=O(c4,dF)ex=O(c5,dG)ey=O(c4,dP)ez=O(c5,dQ)eA=O(c4,dZ)eB=O(c5,d_)eC=O(c4,e8)eD=O(c5,e9)eE=O(c4,ei)eF=O(c5,ej)dF=eC*2^21%2^32+(eD%2^32-eD%2^11)/2^11;dG=eD*2^21%2^32+(eC%2^32-eC%2^11)/2^11;dP=ew*2^28%2^32+(ex%2^32-ex%2^4)/2^4;dQ=ex*2^28%2^32+(ew%2^32-ew%2^4)/2^4;dZ=eA*2^25%2^32+(eB%2^32-eB%2^7)/2^7;d_=eB*2^25%2^32+(eA%2^32-eA%2^7)/2^7;e8=(eE%2^32-eE%2^8)/2^8+eF*2^24%2^32;e9=(eF%2^32-eF%2^8)/2^8+eE*2^24%2^32;ei=(ey%2^32-ey%2^9)/2^9+ez*2^23%2^32;ej=(ez%2^32-ez%2^9)/2^9+ey*2^23%2^32;c4=O(es,em*2+(en%2^32-en%2^31)/2^31)c5=O(et,en*2+(em%2^32-em%2^31)/2^31)ew=O(c4,dH)ex=O(c5,dI)ey=O(c4,dR)ez=O(c5,dS)eA=O(c4,e0)eB=O(c5,e1)eC=O(c4,ea)eD=O(c5,eb)eE=O(c4,ek)eF=O(c5,el)dH=eE*2^14+(eF%2^32-eF%2^18)/2^18;dI=eF*2^14+(eE%2^32-eE%2^18)/2^18;dR=ey*2^20%2^32+(ez%2^32-ez%2^12)/2^12;dS=ez*2^20%2^32+(ey%2^32-ey%2^12)/2^12;e0=eC*2^8+(eD%2^32-eD%2^24)/2^24;e1=eD*2^8+(eC%2^32-eC%2^24)/2^24;ea=ew*2^27%2^32+(ex%2^32-ex%2^5)/2^5;eb=ex*2^27%2^32+(ew%2^32-ew%2^5)/2^5;ek=(eA%2^32-eA%2^25)/2^25+eB*2^7;el=(eB%2^32-eB%2^25)/2^25+eA*2^7;c4=O(eu,eo*2+(ep%2^32-ep%2^31)/2^31)c5=O(ev,ep*2+(eo%2^32-eo%2^31)/2^31)ey=O(c4,dJ)ez=O(c5,dK)eA=O(c4,dT)eB=O(c5,dU)eC=O(c4,e2)eD=O(c5,e3)eE=O(c4,ec)eF=O(c5,ed)dJ=eA*2^3+(eB%2^32-eB%2^29)/2^29;dK=eB*2^3+(eA%2^32-eA%2^29)/2^29;dT=eE*2^18+(eF%2^32-eF%2^14)/2^14;dU=eF*2^18+(eE%2^32-eE%2^14)/2^14;e2=(ey%2^32-ey%2^28)/2^28+ez*2^4;e3=(ez%2^32-ez%2^28)/2^28+ey*2^4;ec=(eC%2^32-eC%2^23)/2^23+eD*2^9;ed=(eD%2^32-eD%2^23)/2^23+eC*2^9;dz=O(c4,dz)dA=O(c5,dA)dz,dB,dD,dF,dH=O(dz,M(-1-dB,dD)),O(dB,M(-1-dD,dF)),O(dD,M(-1-dF,dH)),O(dF,M(-1-dH,dz)),O(dH,M(-1-dz,dB))dA,dC,dE,dG,dI=O(dA,M(-1-dC,dE)),O(dC,M(-1-dE,dG)),O(dE,M(-1-dG,dI)),O(dG,M(-1-dI,dA)),O(dI,M(-1-dA,dC))dJ,dL,dN,dP,dR=O(dP,M(-1-dR,dJ)),O(dR,M(-1-dJ,dL)),O(dJ,M(-1-dL,dN)),O(dL,M(-1-dN,dP)),O(dN,M(-1-dP,dR))dK,dM,dO,dQ,dS=O(dQ,M(-1-dS,dK)),O(dS,M(-1-dK,dM)),O(dK,M(-1-dM,dO)),O(dM,M(-1-dO,dQ)),O(dO,M(-1-dQ,dS))dT,dV,dX,dZ,e0=O(dV,M(-1-dX,dZ)),O(dX,M(-1-dZ,e0)),O(dZ,M(-1-e0,dT)),O(e0,M(-1-dT,dV)),O(dT,M(-1-dV,dX))dU,dW,dY,d_,e1=O(dW,M(-1-dY,d_)),O(dY,M(-1-d_,e1)),O(d_,M(-1-e1,dU)),O(e1,M(-1-dU,dW)),O(dU,M(-1-dW,dY))e2,e4,e6,e8,ea=O(ea,M(-1-e2,e4)),O(e2,M(-1-e4,e6)),O(e4,M(-1-e6,e8)),O(e6,M(-1-e8,ea)),O(e8,M(-1-ea,e2))e3,e5,e7,e9,eb=O(eb,M(-1-e3,e5)),O(e3,M(-1-e5,e7)),O(e5,M(-1-e7,e9)),O(e7,M(-1-e9,eb)),O(e9,M(-1-eb,e3))ec,ee,eg,ei,ek=O(eg,M(-1-ei,ek)),O(ei,M(-1-ek,ec)),O(ek,M(-1-ec,ee)),O(ec,M(-1-ee,eg)),O(ee,M(-1-eg,ei))ed,ef,eh,ej,el=O(eh,M(-1-ej,el)),O(ej,M(-1-el,ed)),O(el,M(-1-ed,ef)),O(ed,M(-1-ef,eh)),O(ef,M(-1-eh,ej))dz=O(dz,c2[bo])dA=dA+c3[bo]end;c0[1]=dz;c1[1]=dA;c0[2]=dB;c1[2]=dC;c0[3]=dD;c1[3]=dE;c0[4]=dF;c1[4]=dG;c0[5]=dH;c1[5]=dI;c0[6]=dJ;c1[6]=dK;c0[7]=dL;c1[7]=dM;c0[8]=dN;c1[8]=dO;c0[9]=dP;c1[9]=dQ;c0[10]=dR;c1[10]=dS;c0[11]=dT;c1[11]=dU;c0[12]=dV;c1[12]=dW;c0[13]=dX;c1[13]=dY;c0[14]=dZ;c1[14]=d_;c0[15]=e0;c1[15]=e1;c0[16]=e2;c1[16]=e3;c0[17]=e4;c1[17]=e5;c0[18]=e6;c1[18]=e7;c0[19]=e8;c1[19]=e9;c0[20]=ea;c1[20]=eb;c0[21]=ec;c1[21]=ed;c0[22]=ee;c1[22]=ef;c0[23]=eg;c1[23]=eh;c0[24]=ei;c1[24]=ej;c0[25]=ek;c1[25]=el end end;function a4(aA,aB,aC,ax,b7,b8,b9)local aD=al;local ba,bb,bc,bd,be,bf,bg,bh=aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]for aF=aC,aC+ax-1,64 do if aB then for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=((aI*256+aH)*256+E)*256+aG end end;local eG,eH,eI,eJ,eK,eL,eM,eN=ba,bb,bc,bd,be,bf,bg,bh;local eO,eP,eQ,eR,eS,eT,eU,eV=aa[1],aa[2],aa[3],aa[4],aa[5],aa[6],aa[7],aa[8]b7=b7+(b8 or 64)local cO=b7%2^32;local cP=(b7-cO)/2^32;eS=O(eS,cO)eT=O(eT,cP)if b8 then eU=-1-eU end;if b9 then eV=-1-eV end;for az=1,10 do local bi=as[az]eG=eG+eK+aD[bi[1]]eS=O(eS,eG)%2^32/2^16;eS=eS%1*(2^32-1)+eS;eO=eO+eS;eK=O(eK,eO)%2^32/2^12;eK=eK%1*(2^32-1)+eK;eG=eG+eK+aD[bi[2]]eS=O(eS,eG)%2^32/2^8;eS=eS%1*(2^32-1)+eS;eO=eO+eS;eK=O(eK,eO)%2^32/2^7;eK=eK%1*(2^32-1)+eK;eH=eH+eL+aD[bi[3]]eT=O(eT,eH)%2^32/2^16;eT=eT%1*(2^32-1)+eT;eP=eP+eT;eL=O(eL,eP)%2^32/2^12;eL=eL%1*(2^32-1)+eL;eH=eH+eL+aD[bi[4]]eT=O(eT,eH)%2^32/2^8;eT=eT%1*(2^32-1)+eT;eP=eP+eT;eL=O(eL,eP)%2^32/2^7;eL=eL%1*(2^32-1)+eL;eI=eI+eM+aD[bi[5]]eU=O(eU,eI)%2^32/2^16;eU=eU%1*(2^32-1)+eU;eQ=eQ+eU;eM=O(eM,eQ)%2^32/2^12;eM=eM%1*(2^32-1)+eM;eI=eI+eM+aD[bi[6]]eU=O(eU,eI)%2^32/2^8;eU=eU%1*(2^32-1)+eU;eQ=eQ+eU;eM=O(eM,eQ)%2^32/2^7;eM=eM%1*(2^32-1)+eM;eJ=eJ+eN+aD[bi[7]]eV=O(eV,eJ)%2^32/2^16;eV=eV%1*(2^32-1)+eV;eR=eR+eV;eN=O(eN,eR)%2^32/2^12;eN=eN%1*(2^32-1)+eN;eJ=eJ+eN+aD[bi[8]]eV=O(eV,eJ)%2^32/2^8;eV=eV%1*(2^32-1)+eV;eR=eR+eV;eN=O(eN,eR)%2^32/2^7;eN=eN%1*(2^32-1)+eN;eG=eG+eL+aD[bi[9]]eV=O(eV,eG)%2^32/2^16;eV=eV%1*(2^32-1)+eV;eQ=eQ+eV;eL=O(eL,eQ)%2^32/2^12;eL=eL%1*(2^32-1)+eL;eG=eG+eL+aD[bi[10]]eV=O(eV,eG)%2^32/2^8;eV=eV%1*(2^32-1)+eV;eQ=eQ+eV;eL=O(eL,eQ)%2^32/2^7;eL=eL%1*(2^32-1)+eL;eH=eH+eM+aD[bi[11]]eS=O(eS,eH)%2^32/2^16;eS=eS%1*(2^32-1)+eS;eR=eR+eS;eM=O(eM,eR)%2^32/2^12;eM=eM%1*(2^32-1)+eM;eH=eH+eM+aD[bi[12]]eS=O(eS,eH)%2^32/2^8;eS=eS%1*(2^32-1)+eS;eR=eR+eS;eM=O(eM,eR)%2^32/2^7;eM=eM%1*(2^32-1)+eM;eI=eI+eN+aD[bi[13]]eT=O(eT,eI)%2^32/2^16;eT=eT%1*(2^32-1)+eT;eO=eO+eT;eN=O(eN,eO)%2^32/2^12;eN=eN%1*(2^32-1)+eN;eI=eI+eN+aD[bi[14]]eT=O(eT,eI)%2^32/2^8;eT=eT%1*(2^32-1)+eT;eO=eO+eT;eN=O(eN,eO)%2^32/2^7;eN=eN%1*(2^32-1)+eN;eJ=eJ+eK+aD[bi[15]]eU=O(eU,eJ)%2^32/2^16;eU=eU%1*(2^32-1)+eU;eP=eP+eU;eK=O(eK,eP)%2^32/2^12;eK=eK%1*(2^32-1)+eK;eJ=eJ+eK+aD[bi[16]]eU=O(eU,eJ)%2^32/2^8;eU=eU%1*(2^32-1)+eU;eP=eP+eU;eK=O(eK,eP)%2^32/2^7;eK=eK%1*(2^32-1)+eK end;ba=O(ba,eG,eO)bb=O(bb,eH,eP)bc=O(bc,eI,eQ)bd=O(bd,eJ,eR)be=O(be,eK,eS)bf=O(bf,eL,eT)bg=O(bg,eM,eU)bh=O(bh,eN,eV)end;aA[1],aA[2],aA[3],aA[4],aA[5],aA[6],aA[7],aA[8]=ba,bb,bc,bd,be,bf,bg,bh;return b7 end;function a5(cc,cd,aB,aC,ax,b7,b8,b9)local aD=al;local cw,cx,cy,cz,cA,cB,cC,cD=cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]local cE,cF,cG,cH,cI,cJ,cK,cL=cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]for aF=aC,aC+ax-1,128 do if aB then for az=1,32 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=((aI*256+aH)*256+E)*256+aG end end;local eW,eX,eY,eZ,e_,f0,f1,f2=cw,cx,cy,cz,cA,cB,cC,cD;local f3,f4,f5,f6,f7,f8,f9,fa=cE,cF,cG,cH,cI,cJ,cK,cL;local fb,fc,fd,fe,ff,fg,fh,fi=a9[1],a9[2],a9[3],a9[4],a9[5],a9[6],a9[7],a9[8]local fj,fk,fl,fm,fn,fo,fp,fq=aa[1],aa[2],aa[3],aa[4],aa[5],aa[6],aa[7],aa[8]b7=b7+(b8 or 128)local cM=b7%2^32;local cN=(b7-cM)/2^32;ff=O(ff,cM)fn=O(fn,cN)if b8 then fh=-1-fh;fp=-1-fp end;if b9 then fi=-1-fi;fq=-1-fq end;for az=1,12 do local bi=as[az]local q=bi[1]*2;local aN=eW%2^32+e_%2^32+aD[q-1]eW=aN%2^32;f3=f3+f7+(aN-eW)/2^32+aD[q]ff,fn=O(fn,f3),O(ff,eW)aN=fb%2^32+ff%2^32;fb=aN%2^32;fj=fj+fn+(aN-fb)/2^32;e_,f7=O(e_,fb),O(f7,fj)local ck,cl=e_%2^24,f7%2^24;e_,f7=(e_-ck)/2^24%2^8+cl*2^8,(f7-cl)/2^24%2^8+ck*2^8;q=bi[2]*2;aN=eW%2^32+e_%2^32+aD[q-1]eW=aN%2^32;f3=f3+f7+(aN-eW)/2^32+aD[q]ff,fn=O(ff,eW),O(fn,f3)ck,cl=ff%2^16,fn%2^16;ff,fn=(ff-ck)/2^16%2^16+cl*2^16,(fn-cl)/2^16%2^16+ck*2^16;aN=fb%2^32+ff%2^32;fb=aN%2^32;fj=fj+fn+(aN-fb)/2^32;e_,f7=O(e_,fb),O(f7,fj)ck,cl=e_%2^31,f7%2^31;e_,f7=ck*2^1+(f7-cl)/2^31%2^1,cl*2^1+(e_-ck)/2^31%2^1;q=bi[3]*2;aN=eX%2^32+f0%2^32+aD[q-1]eX=aN%2^32;f4=f4+f8+(aN-eX)/2^32+aD[q]fg,fo=O(fo,f4),O(fg,eX)aN=fc%2^32+fg%2^32;fc=aN%2^32;fk=fk+fo+(aN-fc)/2^32;f0,f8=O(f0,fc),O(f8,fk)ck,cl=f0%2^24,f8%2^24;f0,f8=(f0-ck)/2^24%2^8+cl*2^8,(f8-cl)/2^24%2^8+ck*2^8;q=bi[4]*2;aN=eX%2^32+f0%2^32+aD[q-1]eX=aN%2^32;f4=f4+f8+(aN-eX)/2^32+aD[q]fg,fo=O(fg,eX),O(fo,f4)ck,cl=fg%2^16,fo%2^16;fg,fo=(fg-ck)/2^16%2^16+cl*2^16,(fo-cl)/2^16%2^16+ck*2^16;aN=fc%2^32+fg%2^32;fc=aN%2^32;fk=fk+fo+(aN-fc)/2^32;f0,f8=O(f0,fc),O(f8,fk)ck,cl=f0%2^31,f8%2^31;f0,f8=ck*2^1+(f8-cl)/2^31%2^1,cl*2^1+(f0-ck)/2^31%2^1;q=bi[5]*2;aN=eY%2^32+f1%2^32+aD[q-1]eY=aN%2^32;f5=f5+f9+(aN-eY)/2^32+aD[q]fh,fp=O(fp,f5),O(fh,eY)aN=fd%2^32+fh%2^32;fd=aN%2^32;fl=fl+fp+(aN-fd)/2^32;f1,f9=O(f1,fd),O(f9,fl)ck,cl=f1%2^24,f9%2^24;f1,f9=(f1-ck)/2^24%2^8+cl*2^8,(f9-cl)/2^24%2^8+ck*2^8;q=bi[6]*2;aN=eY%2^32+f1%2^32+aD[q-1]eY=aN%2^32;f5=f5+f9+(aN-eY)/2^32+aD[q]fh,fp=O(fh,eY),O(fp,f5)ck,cl=fh%2^16,fp%2^16;fh,fp=(fh-ck)/2^16%2^16+cl*2^16,(fp-cl)/2^16%2^16+ck*2^16;aN=fd%2^32+fh%2^32;fd=aN%2^32;fl=fl+fp+(aN-fd)/2^32;f1,f9=O(f1,fd),O(f9,fl)ck,cl=f1%2^31,f9%2^31;f1,f9=ck*2^1+(f9-cl)/2^31%2^1,cl*2^1+(f1-ck)/2^31%2^1;q=bi[7]*2;aN=eZ%2^32+f2%2^32+aD[q-1]eZ=aN%2^32;f6=f6+fa+(aN-eZ)/2^32+aD[q]fi,fq=O(fq,f6),O(fi,eZ)aN=fe%2^32+fi%2^32;fe=aN%2^32;fm=fm+fq+(aN-fe)/2^32;f2,fa=O(f2,fe),O(fa,fm)ck,cl=f2%2^24,fa%2^24;f2,fa=(f2-ck)/2^24%2^8+cl*2^8,(fa-cl)/2^24%2^8+ck*2^8;q=bi[8]*2;aN=eZ%2^32+f2%2^32+aD[q-1]eZ=aN%2^32;f6=f6+fa+(aN-eZ)/2^32+aD[q]fi,fq=O(fi,eZ),O(fq,f6)ck,cl=fi%2^16,fq%2^16;fi,fq=(fi-ck)/2^16%2^16+cl*2^16,(fq-cl)/2^16%2^16+ck*2^16;aN=fe%2^32+fi%2^32;fe=aN%2^32;fm=fm+fq+(aN-fe)/2^32;f2,fa=O(f2,fe),O(fa,fm)ck,cl=f2%2^31,fa%2^31;f2,fa=ck*2^1+(fa-cl)/2^31%2^1,cl*2^1+(f2-ck)/2^31%2^1;q=bi[9]*2;aN=eW%2^32+f0%2^32+aD[q-1]eW=aN%2^32;f3=f3+f8+(aN-eW)/2^32+aD[q]fi,fq=O(fq,f3),O(fi,eW)aN=fd%2^32+fi%2^32;fd=aN%2^32;fl=fl+fq+(aN-fd)/2^32;f0,f8=O(f0,fd),O(f8,fl)ck,cl=f0%2^24,f8%2^24;f0,f8=(f0-ck)/2^24%2^8+cl*2^8,(f8-cl)/2^24%2^8+ck*2^8;q=bi[10]*2;aN=eW%2^32+f0%2^32+aD[q-1]eW=aN%2^32;f3=f3+f8+(aN-eW)/2^32+aD[q]fi,fq=O(fi,eW),O(fq,f3)ck,cl=fi%2^16,fq%2^16;fi,fq=(fi-ck)/2^16%2^16+cl*2^16,(fq-cl)/2^16%2^16+ck*2^16;aN=fd%2^32+fi%2^32;fd=aN%2^32;fl=fl+fq+(aN-fd)/2^32;f0,f8=O(f0,fd),O(f8,fl)ck,cl=f0%2^31,f8%2^31;f0,f8=ck*2^1+(f8-cl)/2^31%2^1,cl*2^1+(f0-ck)/2^31%2^1;q=bi[11]*2;aN=eX%2^32+f1%2^32+aD[q-1]eX=aN%2^32;f4=f4+f9+(aN-eX)/2^32+aD[q]ff,fn=O(fn,f4),O(ff,eX)aN=fe%2^32+ff%2^32;fe=aN%2^32;fm=fm+fn+(aN-fe)/2^32;f1,f9=O(f1,fe),O(f9,fm)ck,cl=f1%2^24,f9%2^24;f1,f9=(f1-ck)/2^24%2^8+cl*2^8,(f9-cl)/2^24%2^8+ck*2^8;q=bi[12]*2;aN=eX%2^32+f1%2^32+aD[q-1]eX=aN%2^32;f4=f4+f9+(aN-eX)/2^32+aD[q]ff,fn=O(ff,eX),O(fn,f4)ck,cl=ff%2^16,fn%2^16;ff,fn=(ff-ck)/2^16%2^16+cl*2^16,(fn-cl)/2^16%2^16+ck*2^16;aN=fe%2^32+ff%2^32;fe=aN%2^32;fm=fm+fn+(aN-fe)/2^32;f1,f9=O(f1,fe),O(f9,fm)ck,cl=f1%2^31,f9%2^31;f1,f9=ck*2^1+(f9-cl)/2^31%2^1,cl*2^1+(f1-ck)/2^31%2^1;q=bi[13]*2;aN=eY%2^32+f2%2^32+aD[q-1]eY=aN%2^32;f5=f5+fa+(aN-eY)/2^32+aD[q]fg,fo=O(fo,f5),O(fg,eY)aN=fb%2^32+fg%2^32;fb=aN%2^32;fj=fj+fo+(aN-fb)/2^32;f2,fa=O(f2,fb),O(fa,fj)ck,cl=f2%2^24,fa%2^24;f2,fa=(f2-ck)/2^24%2^8+cl*2^8,(fa-cl)/2^24%2^8+ck*2^8;q=bi[14]*2;aN=eY%2^32+f2%2^32+aD[q-1]eY=aN%2^32;f5=f5+fa+(aN-eY)/2^32+aD[q]fg,fo=O(fg,eY),O(fo,f5)ck,cl=fg%2^16,fo%2^16;fg,fo=(fg-ck)/2^16%2^16+cl*2^16,(fo-cl)/2^16%2^16+ck*2^16;aN=fb%2^32+fg%2^32;fb=aN%2^32;fj=fj+fo+(aN-fb)/2^32;f2,fa=O(f2,fb),O(fa,fj)ck,cl=f2%2^31,fa%2^31;f2,fa=ck*2^1+(fa-cl)/2^31%2^1,cl*2^1+(f2-ck)/2^31%2^1;q=bi[15]*2;aN=eZ%2^32+e_%2^32+aD[q-1]eZ=aN%2^32;f6=f6+f7+(aN-eZ)/2^32+aD[q]fh,fp=O(fp,f6),O(fh,eZ)aN=fc%2^32+fh%2^32;fc=aN%2^32;fk=fk+fp+(aN-fc)/2^32;e_,f7=O(e_,fc),O(f7,fk)ck,cl=e_%2^24,f7%2^24;e_,f7=(e_-ck)/2^24%2^8+cl*2^8,(f7-cl)/2^24%2^8+ck*2^8;q=bi[16]*2;aN=eZ%2^32+e_%2^32+aD[q-1]eZ=aN%2^32;f6=f6+f7+(aN-eZ)/2^32+aD[q]fh,fp=O(fh,eZ),O(fp,f6)ck,cl=fh%2^16,fp%2^16;fh,fp=(fh-ck)/2^16%2^16+cl*2^16,(fp-cl)/2^16%2^16+ck*2^16;aN=fc%2^32+fh%2^32;fc=aN%2^32;fk=fk+fp+(aN-fc)/2^32;e_,f7=O(e_,fc),O(f7,fk)ck,cl=e_%2^31,f7%2^31;e_,f7=ck*2^1+(f7-cl)/2^31%2^1,cl*2^1+(e_-ck)/2^31%2^1 end;cw=O(cw,eW,fb)%2^32;cx=O(cx,eX,fc)%2^32;cy=O(cy,eY,fd)%2^32;cz=O(cz,eZ,fe)%2^32;cA=O(cA,e_,ff)%2^32;cB=O(cB,f0,fg)%2^32;cC=O(cC,f1,fh)%2^32;cD=O(cD,f2,fi)%2^32;cE=O(cE,f3,fj)%2^32;cF=O(cF,f4,fk)%2^32;cG=O(cG,f5,fl)%2^32;cH=O(cH,f6,fm)%2^32;cI=O(cI,f7,fn)%2^32;cJ=O(cJ,f8,fo)%2^32;cK=O(cK,f9,fp)%2^32;cL=O(cL,fa,fq)%2^32 end;cc[1],cc[2],cc[3],cc[4],cc[5],cc[6],cc[7],cc[8]=cw,cx,cy,cz,cA,cB,cC,cD;cd[1],cd[2],cd[3],cd[4],cd[5],cd[6],cd[7],cd[8]=cE,cF,cG,cH,cI,cJ,cK,cL;return b7 end;function a6(aB,aC,ax,cQ,cR,cS,cT,cU,cV)cV=cV or 64;local aD=al;local ba,bb,bc,bd,be,bf,bg,bh=cS[1],cS[2],cS[3],cS[4],cS[5],cS[6],cS[7],cS[8]cT=cT or cS;for aF=aC,aC+ax-1,64 do if aB then for az=1,16 do aF=aF+4;local aG,E,aH,aI=c(aB,aF-3,aF)aD[az]=((aI*256+aH)*256+E)*256+aG end end;local eG,eH,eI,eJ,eK,eL,eM,eN=ba,bb,bc,bd,be,bf,bg,bh;local eO,eP,eQ,eR=aa[1],aa[2],aa[3],aa[4]local eS=cR%2^32;local eT=(cR-eS)/2^32;local eU,eV=cV,cQ;for az=1,7 do eG=eG+eK+aD[at[az]]eS=O(eS,eG)%2^32/2^16;eS=eS%1*(2^32-1)+eS;eO=eO+eS;eK=O(eK,eO)%2^32/2^12;eK=eK%1*(2^32-1)+eK;eG=eG+eK+aD[at[az+14]]eS=O(eS,eG)%2^32/2^8;eS=eS%1*(2^32-1)+eS;eO=eO+eS;eK=O(eK,eO)%2^32/2^7;eK=eK%1*(2^32-1)+eK;eH=eH+eL+aD[at[az+1]]eT=O(eT,eH)%2^32/2^16;eT=eT%1*(2^32-1)+eT;eP=eP+eT;eL=O(eL,eP)%2^32/2^12;eL=eL%1*(2^32-1)+eL;eH=eH+eL+aD[at[az+2]]eT=O(eT,eH)%2^32/2^8;eT=eT%1*(2^32-1)+eT;eP=eP+eT;eL=O(eL,eP)%2^32/2^7;eL=eL%1*(2^32-1)+eL;eI=eI+eM+aD[at[az+16]]eU=O(eU,eI)%2^32/2^16;eU=eU%1*(2^32-1)+eU;eQ=eQ+eU;eM=O(eM,eQ)%2^32/2^12;eM=eM%1*(2^32-1)+eM;eI=eI+eM+aD[at[az+7]]eU=O(eU,eI)%2^32/2^8;eU=eU%1*(2^32-1)+eU;eQ=eQ+eU;eM=O(eM,eQ)%2^32/2^7;eM=eM%1*(2^32-1)+eM;eJ=eJ+eN+aD[at[az+15]]eV=O(eV,eJ)%2^32/2^16;eV=eV%1*(2^32-1)+eV;eR=eR+eV;eN=O(eN,eR)%2^32/2^12;eN=eN%1*(2^32-1)+eN;eJ=eJ+eN+aD[at[az+17]]eV=O(eV,eJ)%2^32/2^8;eV=eV%1*(2^32-1)+eV;eR=eR+eV;eN=O(eN,eR)%2^32/2^7;eN=eN%1*(2^32-1)+eN;eG=eG+eL+aD[at[az+21]]eV=O(eV,eG)%2^32/2^16;eV=eV%1*(2^32-1)+eV;eQ=eQ+eV;eL=O(eL,eQ)%2^32/2^12;eL=eL%1*(2^32-1)+eL;eG=eG+eL+aD[at[az+5]]eV=O(eV,eG)%2^32/2^8;eV=eV%1*(2^32-1)+eV;eQ=eQ+eV;eL=O(eL,eQ)%2^32/2^7;eL=eL%1*(2^32-1)+eL;eH=eH+eM+aD[at[az+3]]eS=O(eS,eH)%2^32/2^16;eS=eS%1*(2^32-1)+eS;eR=eR+eS;eM=O(eM,eR)%2^32/2^12;eM=eM%1*(2^32-1)+eM;eH=eH+eM+aD[at[az+6]]eS=O(eS,eH)%2^32/2^8;eS=eS%1*(2^32-1)+eS;eR=eR+eS;eM=O(eM,eR)%2^32/2^7;eM=eM%1*(2^32-1)+eM;eI=eI+eN+aD[at[az+4]]eT=O(eT,eI)%2^32/2^16;eT=eT%1*(2^32-1)+eT;eO=eO+eT;eN=O(eN,eO)%2^32/2^12;eN=eN%1*(2^32-1)+eN;eI=eI+eN+aD[at[az+18]]eT=O(eT,eI)%2^32/2^8;eT=eT%1*(2^32-1)+eT;eO=eO+eT;eN=O(eN,eO)%2^32/2^7;eN=eN%1*(2^32-1)+eN;eJ=eJ+eK+aD[at[az+19]]eU=O(eU,eJ)%2^32/2^16;eU=eU%1*(2^32-1)+eU;eP=eP+eU;eK=O(eK,eP)%2^32/2^12;eK=eK%1*(2^32-1)+eK;eJ=eJ+eK+aD[at[az+20]]eU=O(eU,eJ)%2^32/2^8;eU=eU%1*(2^32-1)+eU;eP=eP+eU;eK=O(eK,eP)%2^32/2^7;eK=eK%1*(2^32-1)+eK end;if cU then cT[9]=O(ba,eO)cT[10]=O(bb,eP)cT[11]=O(bc,eQ)cT[12]=O(bd,eR)cT[13]=O(be,eS)cT[14]=O(bf,eT)cT[15]=O(bg,eU)cT[16]=O(bh,eV)end;ba=O(eG,eO)bb=O(eH,eP)bc=O(eI,eQ)bd=O(eJ,eR)be=O(eK,eS)bf=O(eL,eT)bg=O(eM,eU)bh=O(eN,eV)end;cT[1],cT[2],cT[3],cT[4],cT[5],cT[6],cT[7],cT[8]=ba,bb,bc,bd,be,bf,bg,bh end end;do local function fr(fs,ft,fu,fv)local H,fw,fx,fy={},0.0,0.0,1.0;for az=1,fv do for q=m(1,az+1-#ft),l(az,#fs)do fw=fw+fu*fs[q]*ft[az+1-q]end;local fz=fw%2^24;H[az]=j(fz)fw=(fw-fz)/2^24;fx=fx+fz*fy;fy=fy*2^24 end;return H,fx end;local fA,fB,fC,p,fD,fE=0,{4,1,2,-2,2},4,{1},aa,a9;repeat fC=fC+fB[fC%6]local aI=1;repeat aI=aI+fB[aI%6]if aI*aI>fC then local fF=fC^(1/3)local fG=fF*2^40;fG=fr({fG-fG%1},p,1.0,2)local I,fH=fr(fG,fr(fG,fG,1.0,4),-1.0,4)local fI=fG[2]%65536*65536+j(fG[1]/256)local fJ=fG[1]%256*16777216+j(fH*2^-56/3*fF/fC)if fA<16 then fF=fC^(1/2)fG=fF*2^40;fG=fr({fG-fG%1},p,1.0,2)I,fH=fr(fG,fG,-1.0,2)local fI=fG[2]%65536*65536+j(fG[1]/256)local fJ=fG[1]%256*16777216+j(fH*2^-17/fF)local fA=fA%8+1;ad[224][fA]=fJ;fD[fA],fE[fA]=fI,fJ+fI*aq;if fA>7 then fD,fE=af[384],ae[384]end end;fA=fA+1;a8[fA],a7[fA]=fI,fJ%ap+fI*aq;break end until fC%aI==0 until fA>79 end;for fK=224,256,32 do local cc,cd={}if aj then for az=1,8 do cc[az]=X(a9[az])end else cd={}for az=1,8 do cc[az]=X(a9[az])cd[az]=X(aa[az])end end;a0(cc,cd,\"SHA-512/\"..tostring(fK)..\"\\128\"..e(\"\\0\",115)..\"\\88\",0,128)ae[fK]=cc;af[fK]=cd end;do local fL,fM,fN=math.sin,math.abs,math.modf;for fA=1,64 do local fI,fJ=fN(fM(fL(fA))*2^16)ag[fA]=fI*65536+j(fJ*2^16)end end;do local fO=29;local function fP()local fQ=fO%2;fO=W((fO-fQ)/2,142*fQ)return fQ end;for fA=1,24 do local fJ,s=0;for I=1,6 do s=s and s*s*2 or 1;fJ=fJ+fP()*s end;local fI=fP()*s;ac[fA],ab[fA]=fI,fJ+fI*ar end end;if L==\"FFI\"then a8=D.new(\"uint32_t[?]\",#a8+1,0,unpack(a8))a7=D.new(\"int64_t[?]\",#a7+1,0,unpack(a7))if ar==0 then ab=D.new(\"uint32_t[?]\",#ab+1,0,unpack(ab))ac=D.new(\"uint32_t[?]\",#ac+1,0,unpack(ac))else ab=D.new(\"int64_t[?]\",#ab+1,0,unpack(ab))end end;local function fR(fK,fS)local aA,fT,fU={unpack(ad[fK])},0.0,\"\"local function fV(fW)if fW then if fU then fT=fT+#fW;local aC=0;if fU~=\"\"and#fU+#fW>=64 then aC=64-#fU;_(aA,fU..f(fW,1,aC),0,64)fU=\"\"end;local ax=#fW-aC;local fX=ax%64;_(aA,fW,aC,ax-fX)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then local fY={fU,\"\\128\",e(\"\\0\",(-9-fT)%64+1)}fU=nil;fT=fT*8/256^7;for az=4,10 do fT=fT%1*256;fY[az]=d(j(fT))end;fY=b(fY)_(aA,fY,0,#fY)local fZ=fK/32;for az=1,fZ do aA[az]=V(aA[az])end;aA=b(aA,\"\",1,fZ)end;return aA end end;if fS then return fV(fS)()else return fV end end;local function f_(fK,fS)local fT,fU,cc,cd=0.0,\"\",{unpack(ae[fK])},not aj and{unpack(af[fK])}local function fV(fW)if fW then if fU then fT=fT+#fW;local aC=0;if fU~=\"\"and#fU+#fW>=128 then aC=128-#fU;a0(cc,cd,fU..f(fW,1,aC),0,128)fU=\"\"end;local ax=#fW-aC;local fX=ax%128;a0(cc,cd,fW,aC,ax-fX)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then local fY={fU,\"\\128\",e(\"\\0\",(-17-fT)%128+9)}fU=nil;fT=fT*8/256^7;for az=4,10 do fT=fT%1*256;fY[az]=d(j(fT))end;fY=b(fY)a0(cc,cd,fY,0,#fY)local fZ=k(fK/64)if aj then for az=1,fZ do cc[az]=aj(cc[az])end else for az=1,fZ do cc[az]=V(cd[az])..V(cc[az])end;cd=nil end;cc=f(b(cc,\"\",1,fZ),1,fK/4)end;return cc end end;if fS then return fV(fS)()else return fV end end;local function g0(fS)local aA,fT,fU={unpack(ah,1,4)},0.0,\"\"local function fV(fW)if fW then if fU then fT=fT+#fW;local aC=0;if fU~=\"\"and#fU+#fW>=64 then aC=64-#fU;a1(aA,fU..f(fW,1,aC),0,64)fU=\"\"end;local ax=#fW-aC;local fX=ax%64;a1(aA,fW,aC,ax-fX)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then local fY={fU,\"\\128\",e(\"\\0\",(-9-fT)%64)}fU=nil;fT=fT*8;for az=4,11 do local g1=fT%256;fY[az]=d(g1)fT=(fT-g1)/256 end;fY=b(fY)a1(aA,fY,0,#fY)for az=1,4 do aA[az]=V(aA[az])end;aA=g(b(aA),\"(..)(..)(..)(..)\",\"%4%3%2%1\")end;return aA end end;if fS then return fV(fS)()else return fV end end;local function g2(fS)local aA,fT,fU={unpack(ah)},0.0,\"\"local function fV(fW)if fW then if fU then fT=fT+#fW;local aC=0;if fU~=\"\"and#fU+#fW>=64 then aC=64-#fU;a2(aA,fU..f(fW,1,aC),0,64)fU=\"\"end;local ax=#fW-aC;local fX=ax%64;a2(aA,fW,aC,ax-fX)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then local fY={fU,\"\\128\",e(\"\\0\",(-9-fT)%64+1)}fU=nil;fT=fT*8/256^7;for az=4,10 do fT=fT%1*256;fY[az]=d(j(fT))end;fY=b(fY)a2(aA,fY,0,#fY)for az=1,5 do aA[az]=V(aA[az])end;aA=b(aA)end;return aA end end;if fS then return fV(fS)()else return fV end end;local function g3(bl,g4,g5,fS)if type(g4)~=\"number\"then error(\"Argument 'digest_size_in_bytes' must be a number\",2)end;local fU,c0,c1=\"\",Z(),ar==0 and Z()local H;local function fV(fW)if fW then if fU then local aC=0;if fU~=\"\"and#fU+#fW>=bl then aC=bl-#fU;a3(c0,c1,fU..f(fW,1,aC),0,bl,bl)fU=\"\"end;local ax=#fW-aC;local fX=ax%bl;a3(c0,c1,fW,aC,ax-fX,bl)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then local g6=g5 and 31 or 6;fU=fU..(#fU+1==bl and d(g6+128)or d(g6)..e(\"\\0\",(-2-#fU)%bl)..\"\\128\")a3(c0,c1,fU,0,#fU,bl)fU=nil;local g7=0;local g8=j(bl/8)local g9={}local function ga(bn)if g7>=g8 then a3(c0,c1,\"\\0\\0\\0\\0\\0\\0\\0\\0\",0,8,8)g7=0 end;bn=j(l(bn,g8-g7))if ar~=0 then for az=1,bn do g9[az]=aj(c0[g7+az-1+ak])end else for az=1,bn do g9[az]=V(c1[g7+az])..V(c0[g7+az])end end;g7=g7+bn;return g(b(g9,\"\",1,bn),\"(..)(..)(..)(..)(..)(..)(..)(..)\",\"%8%7%6%5%4%3%2%1\"),bn*8 end;local gb={}local gc,gd=\"\",0;local function ge(gf)gf=gf or 1;if gf<=gd then gd=gd-gf;local gg=gf*2;local H=f(gc,1,gg)gc=f(gc,gg+1)return H end;local gh=0;if gd>0 then gh=1;gb[gh]=gc;gf=gf-gd end;while gf>=8 do local gi,gj=ga(gf/8)gh=gh+1;gb[gh]=gi;gf=gf-gj end;if gf>0 then gc,gd=ga(1)gh=gh+1;gb[gh]=ge(gf)else gc,gd=\"\",0 end;return b(gb,\"\",1,gh)end;if g4<0 then H=ge else H=ge(g4)end end;return H end end;if fS then return fV(fS)()else return fV end end;local gk,gl,gm,gn;do function gk(go)return g(go,\"%x%x\",function(gp)return d(tonumber(gp,16))end)end;function gl(gq)return g(gq,\".\",function(aH)return i(\"%02x\",c(aH))end)end;local gr={['+']=62,['-']=62,[62]='+',['/']=63,['_']=63,[63]='/',['=']=-1,['.']=-1,[-1]='='}local gs=0;for az,gt in ipairs{'AZ','az','09'}do for gu=c(gt),c(gt,2)do local gv=d(gu)gr[gv]=gs;gr[gs]=gv;gs=gs+1 end end;function gm(gq)local H={}for aF=1,#gq,3 do local gw,gx,gy,gz=c(f(gq,aF,aF+2)..'\\0',1,-1)H[#H+1]=gr[j(gw/4)]..gr[gw%4*16+j(gx/16)]..gr[gy and gx%16*4+j(gy/64)or-1]..gr[gz and gy%64 or-1]end;return b(H)end;function gn(gA)local H,gB={},3;for aF,gv in h(g(gA,'%s+',''),'()(.)')do local gC=gr[gv]if gC<0 then gB=gB-1;gC=0 end;local fA=aF%4;if fA>0 then H[-fA]=gC else local gw=H[-1]*4+j(H[-2]/16)local gx=H[-2]%16*16+j(H[-3]/4)local gy=H[-3]%4*64+gC;H[#H+1]=f(d(gw,gx,gy),1,gB)end end;return b(H)end end;local gD;local function gE(aB,fv,gF)return g(aB,\".\",function(aH)return d(W(c(aH),gF))end)..e(d(gF),fv-#aB)end;local function gG(gH,gI,fS)local gJ=gD[gH]if not gJ then error(\"Unknown hash function\",2)end;if#gI>gJ then gI=gk(gH(gI))end;local gK=gH()(gE(gI,gJ,0x36))local H;local function fV(fW)if not fW then H=H or gH(gE(gI,gJ,0x5C)..gk(gK()))return H elseif H then error(\"Adding more chunks is not allowed after receiving the result\",2)else gK(fW)return fV end end;if fS then return fV(fS)()else return fV end end;local function gL(gM,gN,cc,cd)local gO=gN==\"s\"and 16 or 32;local gP=#gM;if gP>gO then error(i(\"For BLAKE2%s/BLAKE2%sp/BLAKE2X%s the 'salt' parameter length must not exceed %d bytes\",gN,gN,gN,gO),2)end;if cc then local gQ,gR,gS=0,gN==\"s\"and 4 or 8,gN==\"s\"and O or X;for az=5,4+k(gP/gR)do local gT,gU;for I=1,gR,4 do gQ=gQ+4;local aG,E,aH,aI=c(gM,gQ-3,gQ)local gV=(((aI or 0)*256+(aH or 0))*256+(E or 0))*256+(aG or 0)gT,gU=gU,gV end;cc[az]=gS(cc[az],gT and gU*aq+gT or gU)if cd then cd[az]=gS(cd[az],gU)end end end end;local function gW(fS,gI,gM,g4,gX,gY)g4=g4 or 32;if g4<1 or g4>32 then error(\"BLAKE2s digest length must be from 1 to 32 bytes\",2)end;gI=gI or\"\"local gZ=#gI;if gZ>32 then error(\"BLAKE2s key length must not exceed 32 bytes\",2)end;gM=gM or\"\"local b7,fU,aA=0.0,\"\",{unpack(aa)}if gY then aA[1]=O(aA[1],g4)aA[2]=O(aA[2],0x20)aA[3]=O(aA[3],gY)aA[4]=O(aA[4],0x20000000+gX)else aA[1]=O(aA[1],0x01010000+gZ*256+g4)if gX then aA[4]=O(aA[4],gX)end end;if gM~=\"\"then gL(gM,\"s\",aA)end;local function fV(fW)if fW then if fU then local aC=0;if fU~=\"\"and#fU+#fW>64 then aC=64-#fU;b7=a4(aA,fU..f(fW,1,aC),0,64,b7)fU=\"\"end;local ax=#fW-aC;local fX=ax>0 and(ax-1)%64+1 or 0;b7=a4(aA,fW,aC,ax-fX,b7)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then if gY then a4(aA,nil,0,64,0,32)else a4(aA,fU..e(\"\\0\",64-#fU),0,64,b7,#fU)end;fU=nil;if not gX or gY then local fZ=k(g4/4)for az=1,fZ do aA[az]=V(aA[az])end;aA=f(g(b(aA,\"\",1,fZ),\"(..)(..)(..)(..)\",\"%4%3%2%1\"),1,g4*2)end end;return aA end end;if gZ>0 then fV(gI..e(\"\\0\",64-gZ))end;if gY then return fV()elseif fS then return fV(fS)()else return fV end end;local function g_(fS,gI,gM,g4,gX,gY)g4=j(g4 or 64)if g4<1 or g4>64 then error(\"BLAKE2b digest length must be from 1 to 64 bytes\",2)end;gI=gI or\"\"local gZ=#gI;if gZ>64 then error(\"BLAKE2b key length must not exceed 64 bytes\",2)end;gM=gM or\"\"local b7,fU,cc,cd=0.0,\"\",{unpack(a9)},not aj and{unpack(aa)}if gY then if cd then cc[1]=X(cc[1],g4)cd[1]=X(cd[1],0x40)cc[2]=X(cc[2],gY)cd[2]=X(cd[2],gX)else cc[1]=X(cc[1],0x40*aq+g4)cc[2]=X(cc[2],gX*aq+gY)end;cc[3]=X(cc[3],0x4000)else cc[1]=X(cc[1],0x01010000+gZ*256+g4)if gX then if cd then cd[2]=X(cd[2],gX)else cc[2]=X(cc[2],gX*aq)end end end;if gM~=\"\"then gL(gM,\"b\",cc,cd)end;local function fV(fW)if fW then if fU then local aC=0;if fU~=\"\"and#fU+#fW>128 then aC=128-#fU;b7=a5(cc,cd,fU..f(fW,1,aC),0,128,b7)fU=\"\"end;local ax=#fW-aC;local fX=ax>0 and(ax-1)%128+1 or 0;b7=a5(cc,cd,fW,aC,ax-fX,b7)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then if gY then a5(cc,cd,nil,0,128,0,64)else a5(cc,cd,fU..e(\"\\0\",128-#fU),0,128,b7,#fU)end;fU=nil;if gX and not gY then if cd then for az=8,1,-1 do cc[az*2]=cd[az]cc[az*2-1]=cc[az]end;return cc,16 end else local fZ=k(g4/8)if cd then for az=1,fZ do cc[az]=V(cd[az])..V(cc[az])end else for az=1,fZ do cc[az]=aj(cc[az])end end;cc=f(g(b(cc,\"\",1,fZ),\"(..)(..)(..)(..)(..)(..)(..)(..)\",\"%8%7%6%5%4%3%2%1\"),1,g4*2)end;cd=nil end;return cc end end;if gZ>0 then fV(gI..e(\"\\0\",128-gZ))end;if gY then return fV()elseif fS then return fV(fS)()else return fV end end;local function h0(fS,gI,gM,g4)g4=g4 or 32;if g4<1 or g4>32 then error(\"BLAKE2sp digest length must be from 1 to 32 bytes\",2)end;gI=gI or\"\"local gZ=#gI;if gZ>32 then error(\"BLAKE2sp key length must not exceed 32 bytes\",2)end;gM=gM or\"\"local h1,fT,h2,H={},0.0,0x02080000+gZ*256+g4;for az=1,8 do local b7,fU,aA=0.0,\"\",{unpack(aa)}h1[az]={b7,fU,aA}aA[1]=O(aA[1],h2)aA[3]=O(aA[3],az-1)aA[4]=O(aA[4],0x20000000)if gM~=\"\"then gL(gM,\"s\",aA)end end;local function fV(fW)if fW then if h1 then local h3=0;while true do local h4=l(h3+64-fT%64,#fW)if h4>h3 then local h5=h1[j(fT/64)%8+1]local h6=f(fW,h3+1,h4)fT,h3=fT+h4-h3,h4;local b7,fU=h5[1],h5[2]if#fU<64 then fU=fU..h6 else local aA=h5[3]b7=a4(aA,fU,0,64,b7)fU=h6 end;h5[1],h5[2]=b7,fU else break end end;return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if h1 then local h7={unpack(aa)}h7[1]=O(h7[1],h2)h7[4]=O(h7[4],0x20010000)if gM~=\"\"then gL(gM,\"s\",h7)end;for az=1,8 do local h5=h1[az]local b7,fU,aA=h5[1],h5[2],h5[3]a4(aA,fU..e(\"\\0\",64-#fU),0,64,b7,#fU,az==8)if az%2==0 then local h8=0;for q=az-1,az do local h5=h1[q]local aA=h5[3]for h9=1,8 do h8=h8+1;an[h8]=aA[h9]end end;a4(h7,nil,0,64,64*(az/2-1),az==8 and 64,az==8)end end;h1=nil;local fZ=k(g4/4)for az=1,fZ do h7[az]=V(h7[az])end;H=f(g(b(h7,\"\",1,fZ),\"(..)(..)(..)(..)\",\"%4%3%2%1\"),1,g4*2)end;return H end end;if gZ>0 then gI=gI..e(\"\\0\",64-gZ)for az=1,8 do fV(gI)end end;if fS then return fV(fS)()else return fV end end;local function ha(fS,gI,gM,g4)g4=g4 or 64;if g4<1 or g4>64 then error(\"BLAKE2bp digest length must be from 1 to 64 bytes\",2)end;gI=gI or\"\"local gZ=#gI;if gZ>64 then error(\"BLAKE2bp key length must not exceed 64 bytes\",2)end;gM=gM or\"\"local h1,fT,h2,H={},0.0,0x02040000+gZ*256+g4;for az=1,4 do local b7,fU,cc,cd=0.0,\"\",{unpack(a9)},not aj and{unpack(aa)}h1[az]={b7,fU,cc,cd}cc[1]=X(cc[1],h2)cc[2]=X(cc[2],az-1)cc[3]=X(cc[3],0x4000)if gM~=\"\"then gL(gM,\"b\",cc,cd)end end;local function fV(fW)if fW then if h1 then local h3=0;while true do local h4=l(h3+128-fT%128,#fW)if h4>h3 then local h5=h1[j(fT/128)%4+1]local h6=f(fW,h3+1,h4)fT,h3=fT+h4-h3,h4;local b7,fU=h5[1],h5[2]if#fU<128 then fU=fU..h6 else local cc,cd=h5[3],h5[4]b7=a5(cc,cd,fU,0,128,b7)fU=h6 end;h5[1],h5[2]=b7,fU else break end end;return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if h1 then local hb,hc={unpack(a9)},not aj and{unpack(aa)}hb[1]=X(hb[1],h2)hb[3]=X(hb[3],0x4001)if gM~=\"\"then gL(gM,\"b\",hb,hc)end;for az=1,4 do local h5=h1[az]local b7,fU,cc,cd=h5[1],h5[2],h5[3],h5[4]a5(cc,cd,fU..e(\"\\0\",128-#fU),0,128,b7,#fU,az==4)if az%2==0 then local h8=0;for q=az-1,az do local h5=h1[q]local cc,cd=h5[3],h5[4]for h9=1,8 do h8=h8+1;am[h8]=cc[h9]if cd then h8=h8+1;am[h8]=cd[h9]end end end;a5(hb,hc,nil,0,128,128*(az/2-1),az==4 and 128,az==4)end end;h1=nil;local fZ=k(g4/8)if aj then for az=1,fZ do hb[az]=aj(hb[az])end else for az=1,fZ do hb[az]=V(hc[az])..V(hb[az])end end;H=f(g(b(hb,\"\",1,fZ),\"(..)(..)(..)(..)(..)(..)(..)(..)\",\"%8%7%6%5%4%3%2%1\"),1,g4*2)end;return H end end;if gZ>0 then gI=gI..e(\"\\0\",128-gZ)for az=1,4 do fV(gI)end end;if fS then return fV(fS)()else return fV end end;local function hd(he,hf,hg,gJ,g4,fS,gI,gM)local hh,hi,hj=2^(gJ/2)-1;if g4==-1 then g4=n;hi=j(hh)hj=true else if g4<0 then g4=-1.0*g4;hj=true end;hi=j(g4)if hi>=hh then error(\"Requested digest is too long.  BLAKE2X\"..hf..\" finite digest is limited by (2^\"..j(gJ/2)..\")-2 bytes.  Hint: you can generate infinite digest.\",2)end end;gM=gM or\"\"if gM~=\"\"then gL(gM,hf)end;local hk=he(nil,gI,gM,nil,hi)local H;local function fV(fW)if fW then if hk then hk(fW)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if hk then local hl,hm=hk()hm,hk=hm or 8;local function hn(ho)local ax=l(gJ,g4-ho*gJ)if ax<=0 then return\"\"end;for az=1,hm do hg[az]=hl[az]end;for az=hm+1,2*hm do hg[az]=0 end;return he(nil,nil,gM,ax,hi,j(ho))end;local hp={}if hj then local aF,hq,hr,hs=0,gJ*2^32;local function ge(ht,hu)if ht==\"seek\"then aF=hu%hq else local ax,h8=ht or 1,0;while ax>0 do local hv=aF%gJ;local ho=(aF-hv)/gJ;local hw=l(ax,gJ-hv)if hr~=ho then hr=ho;hs=hn(ho)end;h8=h8+1;hp[h8]=f(hs,hv*2+1,(hv+hw)*2)ax=ax-hw;aF=(aF+hw)%hq end;return b(hp,\"\",1,h8)end end;H=ge else for az=1.0,k(g4/gJ)do hp[az]=hn(az-1.0)end;H=b(hp)end end;return H end end;if fS then return fV(fS)()else return fV end end;local function hx(g4,fS,gI,gM)return hd(gW,\"s\",an,32,g4,fS,gI,gM)end;local function hy(g4,fS,gI,gM)return hd(g_,\"b\",am,64,g4,fS,gI,gM)end;local function hz(fS,gI,g4,hA,aE,hB)gI=gI or\"\"g4=g4 or 32;hA=hA or 0;if gI==\"\"then aE=aE or aa else local gZ=#gI;if gZ>32 then error(\"BLAKE3 key length must not exceed 32 bytes\",2)end;gI=gI..e(\"\\0\",32-gZ)aE={}for az=1,8 do local aG,E,aH,aI=c(gI,4*az-3,4*az)aE[az]=((aI*256+aH)*256+E)*256+aG end;hA=hA+16 end;local fU,aA,cR,hC,hD,hE=\"\",{},0,0,0,{}local hF,hG,hj,H,cU=aE;local hH=3;local function hI(aB,aC,ax)while ax>0 do local hJ,hK,cS=1,0,aA;if hC==0 then hK=1;cS,hF=aE,aA;hH=2 elseif hC==15 then hK=2;hH=3;hF=aE else hJ=l(ax/64,15-hC)end;local hw=hJ*64;a6(aB,aC,hw,hA+hK,cR,cS,aA)aC,ax=aC+hw,ax-hw;hC=(hC+hJ)%16;if hC==0 then cR=cR+1.0;local hL=2.0;while cR%hL==0 do hL=hL*2.0;hD=hD-8;for az=1,8 do an[az]=hE[hD+az]end;for az=1,8 do an[az+8]=aA[az]end;a6(nil,0,64,hA+4,0,aE,aA)end;for az=1,8 do hE[hD+az]=aA[az]end;hD=hD+8 end end end;local function hn(ho)local ax=l(64,g4-ho*64)if ho<0 or ax<=0 then return\"\"end;if hj then for az=1,16 do an[az]=hE[az+16]end end;a6(nil,0,64,hH,ho,hF,hE,cU,hG)if hB then return hE end;local fZ=k(ax/4)for az=1,fZ do hE[az]=V(hE[az])end;return f(g(b(hE,\"\",1,fZ),\"(..)(..)(..)(..)\",\"%4%3%2%1\"),1,ax*2)end;local function fV(fW)if fW then if fU then local aC=0;if fU~=\"\"and#fU+#fW>64 then aC=64-#fU;hI(fU..f(fW,1,aC),0,64)fU=\"\"end;local ax=#fW-aC;local fX=ax>0 and(ax-1)%64+1 or 0;hI(fW,aC,ax-fX)fU=fU..f(fW,#fW+1-fX)return fV else error(\"Adding more chunks is not allowed after receiving the result\",2)end else if fU then hG=#fU;fU=fU..e(\"\\0\",64-#fU)if an[0]then for az=1,16 do local aG,E,aH,aI=c(fU,4*az-3,4*az)an[az]=N(P(aI,24),P(aH,16),P(E,8),aG)end else for az=1,16 do local aG,E,aH,aI=c(fU,4*az-3,4*az)an[az]=((aI*256+aH)*256+E)*256+aG end end;fU=nil;for hD=hD-8,0,-8 do a6(nil,0,64,hA+hH,cR,hF,aA,nil,hG)cR,hG,hF,hH=0,64,aE,4;for az=1,8 do an[az]=hE[hD+az]end;for az=1,8 do an[az+8]=aA[az]end end;hH=hA+hH+8;if g4<0 then if g4==-1 then g4=n else g4=-1.0*g4 end;hj=true;for az=1,16 do hE[az+16]=an[az]end end;g4=l(2^53,g4)cU=g4>32;if hj then local aF,hr,hs=0.0;local function ge(ht,hu)if ht==\"seek\"then aF=hu*1.0 else local ax,h8=ht or 1,32;while ax>0 do local hv=aF%64;local ho=(aF-hv)/64;local hw=l(ax,64-hv)if hr~=ho then hr=ho;hs=hn(ho)end;h8=h8+1;hE[h8]=f(hs,hv*2+1,(hv+hw)*2)ax=ax-hw;aF=aF+hw end;return b(hE,\"\",33,h8)end end;H=ge elseif g4<=64 then H=hn(0)else local hM=k(g4/64)-1;for ho=0.0,hM do hE[33+ho]=hn(ho)end;H=b(hE,\"\",33,33+hM)end end;return H end end;if fS then return fV(fS)()else return fV end end;local function hN(hO,hP,hQ)if type(hP)~=\"string\"then error(\"'context_string' parameter must be a Lua string\",2)end;local aE=hz(hP,nil,nil,32,nil,true)return hz(hO,nil,hQ,64,aE)end;local hR={md5=g0,sha1=g2,sha224=function(fS)return fR(224,fS)end,sha256=function(fS)return fR(256,fS)end,sha512_224=function(fS)return f_(224,fS)end,sha512_256=function(fS)return f_(256,fS)end,sha384=function(fS)return f_(384,fS)end,sha512=function(fS)return f_(512,fS)end,sha3_224=function(fS)return g3((1600-2*224)/8,224/8,false,fS)end,sha3_256=function(fS)return g3((1600-2*256)/8,256/8,false,fS)end,sha3_384=function(fS)return g3((1600-2*384)/8,384/8,false,fS)end,sha3_512=function(fS)return g3((1600-2*512)/8,512/8,false,fS)end,shake128=function(g4,fS)return g3((1600-2*128)/8,g4,true,fS)end,shake256=function(g4,fS)return g3((1600-2*256)/8,g4,true,fS)end,hmac=gG,hex_to_bin=gk,bin_to_hex=gl,base64_to_bin=gn,bin_to_base64=gm,hex2bin=gk,bin2hex=gl,base642bin=gn,bin2base64=gm,blake2b=g_,blake2s=gW,blake2bp=ha,blake2sp=h0,blake2xb=hy,blake2xs=hx,blake2=g_,blake2b_160=function(fS,gI,gM)return g_(fS,gI,gM,20)end,blake2b_256=function(fS,gI,gM)return g_(fS,gI,gM,32)end,blake2b_384=function(fS,gI,gM)return g_(fS,gI,gM,48)end,blake2b_512=g_,blake2s_128=function(fS,gI,gM)return gW(fS,gI,gM,16)end,blake2s_160=function(fS,gI,gM)return gW(fS,gI,gM,20)end,blake2s_224=function(fS,gI,gM)return gW(fS,gI,gM,28)end,blake2s_256=gW,blake3=hz,blake3_derive_key=hN}gD={[hR.md5]=64,[hR.sha1]=64,[hR.sha224]=64,[hR.sha256]=64,[hR.sha512_224]=128,[hR.sha512_256]=128,[hR.sha384]=128,[hR.sha512]=128,[hR.sha3_224]=144,[hR.sha3_256]=136,[hR.sha3_384]=104,[hR.sha3_512]=72}return hR\n",created=1704748612474,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=81085},["muxzcat.lua"]={modified=1704748611641,data="local a;if bit32~=nil then a=bit32 elseif pcall(require,\"bit32\")then a=require\"bit32\"elseif pcall(require,\"bit\")then a=require\"bit\"elseif bit~=nil then a=bit else local function b(c)if c-math.floor(c)>0 then error(\"trying to use bitwise operation on non-integer!\")end end;local function d(c)b(c)if c<0 then return d(a.bnot(math.abs(c))+1)end;local e={}local f=1;while c>0 do local g=math.mod(c,2)if g==1 then e[f]=1 else e[f]=0 end;c=(c-g)/2;f=f+1 end;return e end;local function h(e)local c=table.getn(e)local i=0;local j=1;for k=1,c do i=i+e[k]*j;j=j*2 end;return i end;local function l(m,n)local o={}local p={}if table.getn(m)>table.getn(n)then o=m;p=n else o=n;p=m end;for k=table.getn(p)+1,table.getn(o)do p[k]=0 end end;local function q(r,c)local m=d(r)local n=d(c)l(m,n)local e={}local i=math.max(table.getn(m),table.getn(n))for k=1,i do if m[k]==0 and n[k]==0 then e[k]=0 else e[k]=1 end end;return h(e)end;local function s(r,c)local m=d(r)local n=d(c)l(m,n)local e={}local i=math.max(table.getn(m),table.getn(n))for k=1,i do if m[k]==0 or n[k]==0 then e[k]=0 else e[k]=1 end end;return h(e)end;local function t(c)local e=d(c)local u=math.max(table.getn(e),32)for k=1,u do if e[k]==1 then e[k]=0 else e[k]=1 end end;return h(e)end;local function v(r,c)local m=d(r)local n=d(c)l(m,n)local e={}local i=math.max(table.getn(m),table.getn(n))for k=1,i do if m[k]~=n[k]then e[k]=1 else e[k]=0 end end;return h(e)end;local function w(c,x)b(c)local y=0;if c<0 then c=t(math.abs(c))+1;y=2147483648 end;for k=1,x do c=c/2;c=q(math.floor(c),y)end;return math.floor(c)end;local function z(c,x)b(c)if c<0 then c=t(math.abs(c))+1 end;for k=1,x do c=c/2 end;return math.floor(c)end;local function A(c,x)b(c)if c<0 then c=t(math.abs(c))+1 end;for k=1,x do c=c*2 end;return s(c,4294967295)end;a={bnot=t,band=s,bor=q,bxor=v,brshift=w,blshift=A,blogic_rshift=z}end;if a.blogic_rshift then a={arshift=a.brshift,band=a.band,bnot=a.bnot,bor=a.bor,btest=function(B,C)return a.band(B,C)~=0 end,bxor=a.bxor,lshift=a.blshift,rshift=a.blogic_rshift}end;local D={}local E={}local F={}local G={}local H={}local I={}setmetatable(D,{__sub=function(J)local K={J,__sub=function(self,C)return a.band(self[1],C)end}return setmetatable(K,K)end})setmetatable(E,{__sub=function(J)local K={J,__sub=function(self,C)return a.bor(self[1],C)end}return setmetatable(K,K)end})setmetatable(F,{__sub=function(J)local K={J,__sub=function(self,C)return a.bxor(self[1],C)end}return setmetatable(K,K)end})setmetatable(H,{__sub=function(J)local K={J,__sub=function(self,C)return a.lshift(self[1],C)end}return setmetatable(K,K)end})setmetatable(I,{__sub=function(J)local K={J,__sub=function(self,C)return a.rshift(self[1],C)end}return setmetatable(K,K)end})setmetatable(G,{__sub=function(L,M)return a.bnot(M)end})local N,O;local function P(Q,k,c,...)if c~=nil then Q[k]=c;return P(Q,k+1,...)end end;local function R(B,S,u)local T;if N then T,N=N:sub(1,u),N:sub(u+1)for k=1,#T,256 do P(B,S+k-1,T:byte(k,k+256))end;return#T else T=io.input():read(u)for k=1,#T,256 do P(B,S+k-1,T:byte(k,k+256))end;return#T end end;local function U(Q,k,V)if k==V then return Q[k]elseif k>V then return nil else return Q[k],U(Q,k+1,V)end end;local function W(B,S,u)if O then for k=S,S+u-1,256 do O=O..string.char(U(B,k,math.min(S+u-1,k+255)))end;return u else for k=1,u,256 do io.output():write(string.char(U(B,k+S-1,math.min(S+u-1,k+S+254))))end;return u end end;local X=0;local Y=0;local Z=0;local _=0;local a0=0;local a1=0;local a2=0;local a3=0;local a4=0;local a5=1;local a6=1;local a7=1;local a8=1;local a9=0;local aa=0;local ab=0;local ac=0;local ad=0;local ae=0;local af=0;local ag=0;local ah=0;local ai=0;local aj=0;local ak=0;local al=0;local am={}local an=setmetatable({},{__index=function(L,ao)return am[ao]end,__newindex=function(L,ao,ap)am[ao]=ap-D-0xFFFF end})local aq={}local ar=setmetatable({},{__index=function(L,ao)return aq[ao]end,__newindex=function(L,ao,ap)aq[ao]=ap-D-0xFF end})local as={}local at=setmetatable({},{__index=function(L,ao)return as[ao]end,__newindex=function(L,ao,ap)as[ao]=ap-D-0xFF end})local function au()X=0;Y=0;Z=0;_=0;a0=0;a1=0;a2=0;a3=0;a4=0;a5=1;a6=1;a7=1;a8=1;a9=0;aa=0;ab=0;ac=0;ad=0;ae=0;af=0;ag=0;ah=0;ai=0;aj=0;ak=0;al=0;am={}aq={}as={}end;local function av(aw)if a9~=0 and a9<274 then local ax=a9;if aw-a0<ax then ax=aw-a0 end;if a3==0 and Y-a2<=ax then a3=Y end;a2=a2+ax;a9=a9-ax;while ax~=0 do ax=ax-1;at[a0]=at[a0-a5+(a0<a5 and a1 or 0)]-D-0xFF;a0=a0+1 end end end;local function ay(az,aA)local aB=1-H-ak-1;local aC=1-H-aj-1;local aD=0;repeat local aE=a3==0 and Y-a2<az-a0 and a0+Y-a2 or az;a9=0;repeat local aF=0;local aG=0;local aH=0;local aI=0;local aJ=a2-D-aB;aF=0+a4-H-4+aJ;aH=an[aF]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then local aK=0;assert(aH<=0x7fffffff and aH<=2048)Z=aG;an[aF]=aH+a.rshift(2048-aH,5)aF=1846;if a3~=0 or a2~=0 then aF=aF+768*(a2-D-aC-H-ai+a.rshift(at[(a0==0 and a1 or a0)-1],al))end;if a4<7 then a4=a4-(a4<4 and a4 or 3)aK=1;repeat aH=an[aF+aK]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aF+aK]=aH+a.rshift(2048-aH,5)aK=aK+aK else Z=Z-aG;_=_-aG;an[aF+aK]=aH-a.rshift(aH,5)aK=aK+aK+1 end until not(aK<0x100)else local aL=at[a0-a5+(a0<a5 and a1 or 0)]local aM=0x100;a4=a4-(a4<10 and 3 or 6)aK=1;repeat local aN;local aO;assert(aM==0 or aM==0x100)aL=aL-H-1;aN=aL-D-aM;aO=aF+aM+aN+aK;aH=an[aO]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aO]=aH+a.rshift(2048-aH,5)aK=aK+aK;aM=aM-D-(G-aN)else Z=Z-aG;_=_-aG;an[aO]=aH-a.rshift(aH,5)aK=aK+aK+1;aM=aM-D-aN end until not(aK<0x100)end;at[a0]=aK-D-0xFF;a0=a0+1;a2=a2+1 else Z=Z-aG;_=_-aG;an[aF]=aH-a.rshift(aH,5)aF=192+a4;aH=an[aF]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;local aP=true;if _<aG then assert(aH<=0x7fffffff and aH<=2048)Z=aG;an[aF]=aH+a.rshift(2048-aH,5)a4=a4+12;aF=818 else Z=Z-aG;_=_-aG;an[aF]=aH-a.rshift(aH,5)if a3==0 and a2==0 then return 1 end;aF=204+a4;aH=an[aF]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then assert(aH<=0x7fffffff and aH<=2048)Z=aG;an[aF]=aH+a.rshift(2048-aH,5)aF=240+a4-H-4+aJ;aH=an[aF]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aF]=aH+a.rshift(2048-aH,5)at[a0]=at[a0-a5+(a0<a5 and a1 or 0)]-D-0xFF;a0=a0+1;a2=a2+1;a4=a4<7 and 9 or 11;aP=false end;if aP then Z=Z-aG;_=_-aG;an[aF]=aH-a.rshift(aH,5)end else Z=Z-aG;_=_-aG;an[aF]=aH-a.rshift(aH,5)aF=216+a4;aH=an[aF]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aF]=aH+a.rshift(2048-aH,5)aI=a6 else Z=Z-aG;_=_-aG;an[aF]=aH-a.rshift(aH,5)aF=228+a4;aH=an[aF]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aF]=aH+a.rshift(2048-aH,5)aI=a7 else Z=Z-aG;_=_-aG;an[aF]=aH-a.rshift(aH,5)aI=a8;a8=a7 end;a7=a6 end;a6=a5;a5=aI end;if aP then a4=a4<7 and 8 or 11;aF=1332 end end;if aP then do local aQ;local aR;local aS=aF+0;aH=an[aS]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then assert(aH<=0x7fffffff and aH<=2048)Z=aG;an[aS]=aH+a.rshift(2048-aH,5)aS=aF+2+aJ-H-3;aR=0;aQ=8 else Z=Z-aG;_=_-aG;an[aS]=aH-a.rshift(aH,5)aS=aF+1;aH=an[aS]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then assert(aH<=0x7fffffff and aH<=2048)Z=aG;an[aS]=aH+a.rshift(2048-aH,5)aS=aF+130+aJ-H-3;aR=8;aQ=8 else Z=Z-aG;_=_-aG;an[aS]=aH-a.rshift(aH,5)aS=aF+258;aR=8+8;aQ=256 end end;do a9=1;repeat aH=an[aS+a9]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aS+a9]=aH+a.rshift(2048-aH,5)a9=a9+a9 else Z=Z-aG;_=_-aG;an[aS+a9]=aH-a.rshift(aH,5)a9=a9+a9+1 end until not(a9<aQ)a9=a9-aQ end;a9=a9+aR end;if a4>=12 then aF=432+(a9<4 and a9 or 4-1)-H-6;do aI=1;repeat aH=an[aF+aI]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aF+aI]=aH+a.rshift(2048-aH,5)aI=aI+aI else Z=Z-aG;_=_-aG;an[aF+aI]=aH-a.rshift(aH,5)aI=aI+aI+1 end until not(aI<64)aI=aI-64 end;assert(aI<=0x7fffffff and aI<64)if aI>=4 then local aT=aI;local aU=a.rshift(aI,1)-1;aI=2-E-(aI-D-1)if aT<14 then aI=aI-H-aU;aF=688+aI-aT-1;do local aV=1;aD=1;repeat aH=an[aF+aD]if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aF+aD]=aH+a.rshift(2048-aH,5)aD=aD+aD else Z=Z-aG;_=_-aG;an[aF+aD]=aH-a.rshift(aH,5)aD=aD+aD+1;aI=aI-E-aV end;aV=aV-H-1;aU=aU-1 until not(aU~=0)end else aU=aU-4;repeat if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;Z=a.rshift(Z,1)if _-Z-D-0x80000000~=0 then aI=aI-H-1 else _=_-Z;aI=aI-H-1+1 end;aU=aU-1 until not(aU~=0)aF=802;aI=aI-H-4;do aD=1;aH=an[aF+aD]assert(aH<=0x7fffffff and aH<=2048)if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aF+aD]=aH+a.rshift(2048-aH,5)aD=aD+aD else Z=Z-aG;_=_-aG;an[aF+aD]=aH-a.rshift(aH,5)aD=aD+aD+1;aI=aI-E-1 end;aH=an[aF+aD]assert(aH<=0x7fffffff and aH<=2048)if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aF+aD]=aH+a.rshift(2048-aH,5)aD=aD+aD else Z=Z-aG;_=_-aG;an[aF+aD]=aH-a.rshift(aH,5)aD=aD+aD+1;aI=aI-E-2 end;aH=an[aF+aD]assert(aH<=0x7fffffff and aH<=2048)if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aF+aD]=aH+a.rshift(2048-aH,5)aD=aD+aD else Z=Z-aG;_=_-aG;an[aF+aD]=aH-a.rshift(aH,5)aD=aD+aD+1;aI=aI-E-4 end;aH=an[aF+aD]assert(aH<=0x7fffffff and aH<=2048)if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;aG=a.rshift(Z,11)*aH;if _<aG then Z=aG;an[aF+aD]=aH+a.rshift(2048-aH,5)aD=aD+aD else Z=Z-aG;_=_-aG;an[aF+aD]=aH-a.rshift(aH,5)aD=aD+aD+1;aI=aI-E-8 end end;if G-aI==0 then a9=a9+274;a4=a4-12;break end end end;assert(aI<=0x7fffffff and aI<=1610612736)a8=a7;a7=a6;a6=a5;a5=aI+1;if a3==0 then if aI>=a2 then return 1 end else if aI>=a3 then return 1 end end;a4=a4<12+7 and 7 or 7+3 end;a9=a9+2;if aE==a0 then return 1 end;do local aW=aE-a0;local aX=aW<a9 and aW or a9;local aY=a0-a5+(a0<a5 and a1 or 0)a2=a2+aX;a9=a9-aX;if aY+aX<=a1 then assert(a0>aY)assert(aX>0)repeat at[a0]=at[aY]-D-0xFF;a0=a0+1;aY=aY+1;aX=aX-1 until not(aX~=0)else repeat at[a0]=at[aY]-D-0xFF;a0=a0+1;aY=aY+1;if aY==a1 then aY=0 end until not(aX~=0)end end end end until not(a0<aE and X<aA)if Z<16777216 then Z=Z-H-8;_=_-H-8-E-ar[X]X=X+1 end;if a2>=Y then a3=Y end;av(az)until not(a0<az and X<aA and a9<274)if a9>274 then a9=274 end;return 0 end;local function aZ(a_,b0)local b1=Z;local b2=_;local b3=a4;local b4;local b5;local b6;local b7;local b8=a2-D-(1-H-ak-1)b5=0+b3-H-4+b8;b7=an[b5]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then local b9=1;b1=b6;b5=1846;if a3~=0 or a2~=0 then b5=b5+768*(a2-D-(1-H-aj-1)-H-ai+a.rshift(at[(a0==0 and a1 or a0)-1],al))end;if b3<7 then repeat b7=an[b5+b9]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6;b9=b9+b9 else b1=b1-b6;b2=b2-b6;b9=b9+b9+1 end until not(b9<0x100)else local ba=at[a0-a5+(a0<a5 and a1 or 0)]local bb=0x100;repeat local bc;local bd;assert(bb==0 or bb==0x100)ba=ba-H-1;bc=ba-D-bb;bd=b5+bb+bc+b9;b7=an[bd]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6;b9=b9+b9;bb=bb-D-(G-bc)else b1=b1-b6;b2=b2-b6;b9=b9+b9+1;bb=bb-D-bc end until not(b9<0x100)end;b4=1 else local be;b1=b1-b6;b2=b2-b6;b5=192+b3;b7=an[b5]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6;b3=0;b5=818;b4=2 else b1=b1-b6;b2=b2-b6;b4=3;b5=204+b3;b7=an[b5]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6;b5=240+b3-H-4+b8;b7=an[b5]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6;if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;return 3 else b1=b1-b6;b2=b2-b6 end else b1=b1-b6;b2=b2-b6;b5=216+b3;b7=an[b5]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6 else b1=b1-b6;b2=b2-b6;b5=228+b3;b7=an[b5]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6 else b1=b1-b6;b2=b2-b6 end end end;b3=12;b5=1332 end;do local bf;local bg;local bh=b5+0;b7=an[bh]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6;bh=b5+2+b8-H-3;bg=0;bf=8 else b1=b1-b6;b2=b2-b6;bh=b5+1;b7=an[bh]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6;bh=b5+130+b8-H-3;bg=8;bf=8 else b1=b1-b6;b2=b2-b6;bh=b5+258;bg=8+8;bf=256 end end;do be=1;repeat b7=an[bh+be]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6;be=be+be else b1=b1-b6;b2=b2-b6;be=be+be+1 end until not(be<bf)be=be-bf end;be=be+bg end;if b3<4 then local bi;b5=432+(be<4 and be or 4-1)-H-6;do bi=1;repeat b7=an[b5+bi]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6;bi=bi+bi else b1=b1-b6;b2=b2-b6;bi=bi+bi+1 end until not(bi<64)bi=bi-64 end;assert(bi<=0x7fffffff and bi<64)if bi>=4 then local bj=a.rshift(bi,1)-1;if bi<14 then b5=688+2-E-(bi-D-1)-H-bj-bi-1 else bj=bj-4;repeat if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b1=a.rshift(b1,1)if b2-b1-D-0x80000000==0 then b2=b2-b1 end;bj=bj-1 until not(bj~=0)b5=802;bj=4 end;do local bk=1;repeat b7=an[b5+bk]if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;b6=a.rshift(b1,11)*b7;if b2<b6 then b1=b6;bk=bk+bk else b1=b1-b6;b2=b2-b6;bk=bk+bk+1 end;bj=bj-1 until not(bj~=0)end end end end;if b1<16777216 then if a_>=b0 then return 0 end;b1=b1-H-8;b2=b2-H-8-E-ar[a_]a_=a_+1 end;return b4 end;local function bl(bm,bn)ad=1;a9=0;aa=0;if bm~=0 then a2=0;a3=0;ae=1 end;if bn~=0 then ae=1 end end;local function bo(bp)local bq=ab+bp;local br;local bs;av(a1)while a9~=274 do if ad~=0 then while bq>ab and aa<5 do ar[6+65536+6+aa]=ar[ab]aa=aa+1;ab=ab+1 end;if aa<5 then end;if ar[6+65536+6]~=0 then return 1 end;_=ar[6+65536+6+1]-H-24-E-(ar[6+65536+6+2]-H-16)-E-(ar[6+65536+6+3]-H-8)-E-ar[6+65536+6+4]Z=0xffffffff;ad=0;aa=0 end;br=0;if a0>=a1 then if a9==0 and _==0 then if ab~=bq then return 18 end;return 0 end;if a9~=0 then return 16 end;br=1 end;if ae~=0 then local bt=1846+768-H-(ai+aj)for bu=0,bt-1,1 do an[bu]=a.rshift(2048,1)end;a8=1;a7=a8;a6=a7;a5=a6;a4=0;ae=0 end;if aa==0 then local bv;if bq-ab<20 or br~=0 then bs=aZ(ab,bq)if bs==0 then aa=0;while ab~=bq do ar[6+65536+6+aa]=ar[ab]aa=aa+1;ab=ab+1 end;if ab~=bq then return 17 end;return 17 end;if br~=0 and bs~=2 then return 16 end;bv=ab else bv=bq-20 end;X=ab;if ay(a1,bv)~=0 then return 1 end;ab=X else local bw=aa;local bx=0;while bw<20 and bx<bq-ab do ar[6+65536+6+bw]=ar[ab+bx]bw=bw+1;bx=bx+1 end;aa=bw;if bw<20 or br~=0 then bs=aZ(6+65536+6,6+65536+6+bw)if bs==0 then ab=ab+bx;if ab~=bq then return 17 end;return 17 end;if br~=0 and bs~=2 then return 16 end end;X=6+65536+6;if ay(0,6+65536+6)~=0 then return 1 end;bx=bx-bw-(X-(6+65536+6))ab=ab+bx;aa=0 end end;if _~=0 then return 1 end;return 15 end;local function by(bz)local bA=ac-ab;local bB;assert(bz<=6+65536+6)if bA<bz then if 6+65536+6-ab<bz then ac=0;while ac<bA do ar[ac]=ar[ab+ac]ac=ac+1 end;ab=0 end;while bA<bz do bB=R(ar,ac,bz-bA)if bB+1<=1 then break end;ac=ac+bB;bA=bA+bB end end;return bA end;local function bC()while ar[ab]>=0x80 do ab=ab+1 end;ab=ab+1 end;local function bD(bE)while bE~=0 do ab=ab+1;if ar[ab-1]~=0 then return 57 end;bE=bE-1 end;return 0 end;local function bF(bG)return a.band(ar[bG],0xff)+a.blshift(a.band(ar[bG+1],0xff),8)+a.blshift(a.band(ar[bG+2],0xff),16)+bit.blshift(a.band(ar[bG+3],0xff),24)end;local function bH()a1=0;af=1;ag=1;ah=1;a0=0;bl(1,1)end;local function bI(bJ)if bJ>=9*5*5 then return 68 end;ai=bJ%9;al=8-ai;bJ=math.floor(bJ/9)ak=math.floor(bJ/5)aj=bJ%5;if ai+aj>4 then return 68 end;ah=0;return 0 end;local function bK(bL)while bL~=a0 do local bM=W(at,bL,a0-bL)if bM-D-0x80000000~=0 then return 9 end;bL=bL+bM end;return 0 end;local function bN()local bO;local bP;local bQ;if by(12+12+6)<12+12+6 then return 6 end;if ar[0]==0xfd and ar[1]==0x37 and ar[2]==0x7a and ar[3]==0x58 and ar[4]==0x5a and ar[5]==0 and ar[6]==0 then elseif ar[ab]<=225 and ar[ab+13]==0 and((function()bP=bF(ab+9)return bP end)()==0 or G-bP==0)and(function()Y=bF(ab+1)return Y end)()>=4096 and Y<a.band(1610612736+1,0x7fffffff)then local bR;local bS;local bT;bH()if(function()bQ=bI(ar[ab])return bQ end)()~=0 then return bQ end;if bP==0 then bR=bF(ab+5)a1=bR;if not(bR<a.band(1610612736+1,0x7fffffff))then return 2 end else bR=bP;a1=1610612736 end;ab=ab+13;while(function()bS=by(6+65536+6)return bS end)()~=0 do bT=a0;bQ=bo(bS)if bR<a0 then a0=bR end;if(function()bQ=bK(bT)return bQ end)()~=0 then return bQ end;if bQ==15 then break end;if bQ~=17 and bQ~=0 then return bQ end;if a0-bR==0 then break end end;return 0 else return 51 end;bO=ar[ab+7]if bO==0 then bO=1 elseif bO==1 then bO=4 elseif bO==4 then bO=8 elseif bO==10 then bO=32 else return 60 end;ab=ab+12;while true do local bU=3;local bV;local bW;local bX;local bY;assert(ac-ab>=12)bY=ab;ab=ab+1;if(function()bV=ar[ab-1]return bV end)()==0 then break end;bV=bV+1-H-2;if by(bV)<bV then return 6 end;bY=ab;bP=ar[ab]ab=ab+1;if bP-D-2~=0 then return 53 end;if bP-D-20~=0 then return 54 end;if bP-D-64~=0 then bC()end;if bP-D-128~=0 then bC()end;if ar[ab]~=0x21 then return 55 end;ab=ab+1;if ar[ab]~=1 then return 56 end;ab=ab+1;bX=ar[ab]ab=ab+1;if bX>40 then return 61 end;if bX>37 then return 62 end;Y=2-E-(bX-D-1)-H-(math.floor(bX/2)+11)assert(Y>=4096)bW=ab-bY+5;if bW>bV then return 58 end;if(function()bQ=bD(bV-bW)return bQ end)()~=0 then return bQ end;ab=ab+4;do local bZ;local b_;local c0;bH()while true do local c1;assert(a0==a1)if by(6)<6 then return 6 end;c1=ar[ab]if c1==0 then ab=ab+1;break elseif a.band(c1-3,0xff)<0x80-3 then return 59 end;bZ=ar[ab+1]-H-8+ar[ab+2]+1;if c1<3 then c0=c1==1 and 1 or 0;b_=bZ;ab=ab+3;bU=bU-3;if c0~=0 then ag=1;ah=ag;af=0 elseif af~=0 then return 1 end;bl(c0,0)else local c2=a.rshift(c1,5)-D-3;local c3=c2~=0 and 1 or 0;local c4=c1-D-64~=0 and 1 or 0;c0=c2==3 and 1 or 0;bZ=bZ+c1-D-31-H-16;b_=ar[ab+3]-H-8+ar[ab+4]+1;if c4~=0 then if(function()bQ=bI(ar[ab+5])return bQ end)()~=0 then return bQ end;ab=ab+1;bU=bU-1 else if ah~=0 then return 67 end end;ab=ab+5;bU=bU-5;if c0==0 and af~=0 or c3==0 and ag~=0 then return 1 end;bl(c0,c3)af=0;ag=0 end;assert(a0==a1)a1=a1+bZ;if a1>1610612736 then return 2 end;if by(b_+6)<b_ then return 6 end;if c1<0x80 then while a0~=a1 do at[a0]=ar[ab]-D-0xFF;a0=a0+1;ab=ab+1 end;if a3==0 and Y-a2<=bZ then a3=Y end;a2=a2+bZ else if(function()bQ=bo(b_)return bQ end)()~=0 then return bQ end end;if a0~=a1 then return 65 end;if(function()bQ=bK(a0-bZ)return bQ end)()~=0 then return bQ end;bU=bU-b_ end end;if by(7+12+6)<7+12+6 then return 6 end;if(function()bQ=bD(bU-D-3)return bQ end)()~=0 then return bQ end;ab=ab+bO end;return 0 end;local c5={UNKNOWN_ERROR=-1,OK=0,ERROR_DATA=1,ERROR_MEM=2,ERROR_CRC=3,ERROR_UNSUPPORTED=4,ERROR_PARAM=5,ERROR_INPUT_EOF=6,ERROR_OUTPUT_EOF=7,ERROR_READ=8,ERROR_WRITE=9,ERROR_FINISHED_WITH_MARK=15,ERROR_NOT_FINISHED=16,ERROR_NEEDS_MORE_INPUT=17,ERROR_CHUNK_NOT_CONSUMED=18,ERROR_NEEDS_MORE_INPUT_PARTIAL=17,ERROR_BAD_MAGIC=51,ERROR_BAD_STREAM_FLAGS=52,ERROR_UNSUPPORTED_FILTER_COUNT=53,ERROR_BAD_BLOCK_FLAGS=54,ERROR_UNSUPPORTED_FILTER_ID=55,ERROR_UNSUPPORTED_FILTER_PROPERTIES_SIZE=56,ERROR_BAD_PADDING=57,ERROR_BLOCK_HEADER_TOO_LONG=58,ERROR_BAD_CHUNK_CONTROL_BYTE=59,ERROR_BAD_CHECKSUM_TYPE=60,ERROR_BAD_DICTIONARY_SIZE=61,ERROR_UNSUPPORTED_DICTIONARY_SIZE=62,ERROR_FEED_CHUNK=63,ERROR_NOT_FINISHED_WITH_MARK=64,ERROR_BAD_DICPOS=65,ERROR_MISSING_INITPROP=67,ERROR_BAD_LCLPPB_PROP=68}return{DecompressXzOrLzmaFile=function(c6,c7)if type(c6)~=\"userdata\"and(_HOST==nil or type(c6)~=\"table\")and type(c6)~=\"string\"then error(\"bad argument #1 (expected string or file, got \"..type(c6)..\")\",2)end;if type(c7)~=\"userdata\"and(_HOST==nil or type(c7)~=\"table\")and type(c7)~=\"string\"then error(\"bad argument #2 (expected string or file, got \"..type(c7)..\")\",2)end;N=nil;O=nil;local c8=io.input()local c9=io.output()if type(c6)==\"string\"then c6=io.open(c6,\"rb\")if c6==nil then return false,-1 end end;if type(c7)==\"string\"then c7=io.open(c7,\"wb\")if c7==nil then return false,-1 end end;io.input(c6)io.output(c7)au()local ca,cb=pcall(bN)io.input(c8)io.output(c9)c6:close()c7:close()if not ca then if cb then io.stderr:write(cb..\"\\n\")end;return false,-1 else return cb==0,cb end end,DecompressXzOrLzmaString=function(c6)if type(c6)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(c6)..\")\",2)end;N=c6;O=\"\"au()local ca,cb=pcall(bN)if not ca then if cb then io.stderr:write(cb..\"\\n\")end;return-1 elseif cb==0 then return O elseif cb==53 and#O>0 then return O,cb else return nil,cb end end,GetError=function(_)for cc,cd in pairs(c5)do if cd==_ then return cc end end;return nil end,Errors=c5}\n",created=1704748611647,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=21375},["ftp.lua"]={modified=1704748610960,data="local a=require(\"system.filesystem\")local b;b=require(\"system.hardware\").call;local c,d,e;do local f=require(\"system.network\")c,d,e=f.connect,f.listen,f.unlisten end;local g;g=require(\"system.process\").newthread;local h;h=require(\"system.sync\").barrier;local i,j,k;do local f=require(\"system.util\")i,j,k=f.timer,f.cancel,f.sleep end;local l;l=function(m,n)local o=c(\"psp://\"..m..\":\"..n)while o:status()==\"connecting\"do coroutine.yield()end;if o:status()==\"error\"then return nil,select(2,o:status())end;return o end;local p;p=function(m,n,q)local r=\"psp://\"..m..\":\"..n;d(r)local s;if q then s=i(q)end;while true do local t,u=coroutine.yield()if t==\"network_request\"and u.uri==r then e(r)if q then j(s)end;return u.handle elseif t==\"timer\"and u.id==s then e(r)return nil end end end;local v;v=function(o,w)local x=o:read(w or\"*a\")while x==nil and o:status()==\"open\"do coroutine.yield()x=o:read(w or\"*a\")end;return x end;local y;y=function(z,A)if#z<A then return z..(\" \"):rep(A-z)else return z:sub(1,A)end end;local B;B=function()local C={}return function(D)if D==nil then if C[20]==nil then C[20]=true;return 20 else local E=5000;while E<65536 and C[E]do E=E+1 end;if E>65535 then return nil else return E end end else C[D]=nil end end end;local F;do local G;local H={_send_command=function(self,I)if not self.connection:status()==\"open\"then return false,421,\"Connection closed\"end;if I~=nil then self.connection:write(I..\"\\r\\n\")end;local x=v(self.connection,\"*l\")if x==nil then error(\"Could not receive reply\",2)end;local J=x:sub(1,3)if tonumber(J)==nil then error(\"Malformed reply (invalid code): \"..x)end;local K=\"\"if x:sub(4,4)=='-'then for L in x:sub(5):gmatch(\"[^\\n]+\")do if L:sub(1,4)==J..\" \"then K=K..L:sub(5)break else K=K..L..\"\\n\"end end elseif x:sub(4,4)==' 'then K=x:sub(5)else error(\"Malformed reply (invalid code separator):\"..x)end;local M=math.floor(tonumber(J)/100)if 1==M then return self:_send_command()elseif 2==M or 3==M then return true,tonumber(J),K elseif 4==M or 5==M then return false,tonumber(J),K else return error(\"Malformed reply (invalid code): \"..J)end end,_receive_data=function(self,I)if self.pasv then local n=self:pasv()if n==nil then error(\"Ran out of ports for data connection\")end;local N,J,x=self:_send_command(\"PORT \"..self.connection:localIP():gsub(\"%.\",\",\")..\",\"..math.floor(n/256)..\",\"..n%256)if J~=200 then return nil,J,x end;local O,P,Q;local R=h.new(3)g(function()N,J,Q=self:_send_command(I)if not N then P:close()end;R:wait()end)g(function()P=p(self.connection:localIP(),n,self.timeout)if not P then return end;while true do local S=v(P)if not S then break end;local M=self.transfer_params.mode;if\"S\"==M then O=(O or\"\")..S elseif\"B\"==M then local T=S:byte(1)local A=S:byte(2)*256+S:byte(3)O=(O or\"\")..y(S,A)if math.floor(T/128)==1 then P:close()break end elseif\"C\"==M then R=S:byte(1)if R==0 and math.floor(S:byte(2)/128)==1 then P:close()break elseif math.floor(R/128)==0 then O=(O or\"\")..S:sub(2,R%128+1)elseif math.floor(R/64)%2==0 then O=(O or\"\")..S:sub(2,2):rep(R%64)else if self.transfer_params.type==\"A\"or self.transfer_params.type==\"E\"then O=(O or\"\")..(\" \"):rep(R%64)elseif self.transfer_params.type==\"I\"or self.transfer_params.type==\"L\"then O=(O or\"\")..(\"\\0\"):rep(R%64)end end end end;R:wait()end)R:wait()if P:status()==\"open\"then P:close()end;self:pasv(n)if self.transfer_params.type==\"A\"and O~=nil then O=O:gsub(\"[\\128-\\255]\",\"?\")end;return O,J,Q else local N,J,x=self:_send_command(\"PASV\")if J~=227 then return false,J,x end;local U,V,W,X,Y,Z=x:match((\"(%d+),\"):rep(5)..\"(%d+)\")local _=U..\".\"..V..\".\"..W..\".\"..X;local n=tonumber(Y)*256+tonumber(Z)local P,Q=l(_,n)if P==nil then return false,0,\"Could not connect to server: \"..Q end;local O,Q;local R=h.new(3)g(function()N,J,Q=self:_send_command(I)if not N then P:close()end;R:wait()end)g(function()while true do local S=v(P)if not S then break end;local M=self.transfer_params.mode;if\"S\"==M then O=(O or\"\")..S elseif\"B\"==M then local T=S:byte(1)local A=S:byte(2)*256+S:byte(3)O=(O or\"\")..y(S,A)if math.floor(T/128)==1 then P:close()break end elseif\"C\"==M then R=S:byte(1)if R==0 and math.floor(S:byte(2)/128)==1 then P:close()break elseif math.floor(R/128)==0 then O=(O or\"\")..S:sub(2,R%128+1)elseif math.floor(R/64)%2==0 then O=(O or\"\")..S:sub(2,2):rep(R%64)else if self.transfer_params.type==\"A\"or self.transfer_params.type==\"E\"then O=(O or\"\")..(\" \"):rep(R%64)elseif self.transfer_params.type==\"I\"or self.transfer_params.type==\"L\"then O=(O or\"\")..(\"\\0\"):rep(R%64)end end end end;R:wait()end)R:wait()if P:status()==\"open\"then P:close()end;if self.transfer_params.type==\"A\"and O~=nil then O=O:gsub(\"[\\128-\\255]\",\"?\")end;return O,J,Q end end,_send_data=function(self,I,O)if self.transfer_params.type==\"A\"then O=O:gsub(\"[\\128-\\255]\",\"?\")end;if self.pasv then local n=self:pasv()if n==nil then error(\"Ran out of ports for data connection\")end;local N,J,x=self:_send_command(\"PORT \"..self.connection:localIP():gsub(\"%.\",\",\")..\",\"..math.floor(n/256)..\",\"..n%256)if J~=200 then return false,J,x end;local P,Q;local R=h.new(2)g(function()N,J,Q=self:_send_command(I)if N then while true do coroutine.yield()end end;if R then R:wait()end end)g(function()P=p(self.connection:localIP(),n,self.timeout)if not P then return end;local M=self.transfer_params.mode;if\"S\"==M then for E=1,#O,65536 do P:write(O:sub(E,E+65535))end elseif\"B\"==M then for E=1,#O,65535 do local S=O:sub(E,E+65534)P:write((function()if#S<65535 then return\"\\0\"else return\"\\128\"end end)()..string.char(#S/256)..string.char(#S%256)..S)end elseif\"C\"==M then for E=1,#O,127 do local S=O:sub(E,E+126)P:write(string.char(#S)..S)end;P:write(\"\\0\\128\")end;P:close()if R then R:wait()end end)R:wait()R=nil;self:pasv(n)return N,J,Q else local N,J,x=self:_send_command(\"PASV\")if J~=227 then return false,J,x end;local U,V,W,X,Y,Z=x:match((\"(%d+),\"):rep(5)..\"(%d+)\")local _=U..\".\"..V..\".\"..W..\".\"..X;local n=tonumber(Y)*256+tonumber(Z)local P,Q=l(_,n)if P==nil then return false,0,\"Could not connect to server: \"..Q end;N,J,Q=self:_send_command(I)if not N then P:close()return N,J,Q end;local M=self.transfer_params.mode;if\"S\"==M then for E=1,#O,65536 do P:write(O:sub(E,E+65535))end elseif\"B\"==M then for E=1,#O,65535 do local S=O:sub(E,E+65534)P:write((function()if#S<65535 then return\"\\0\"else return\"\\128\"end end)()..string.char(#S/256)..string.char(#S%256)..S)end elseif\"C\"==M then for E=1,#O,127 do local S=O:sub(E,E+126)P:write(string.char(#S)..S)end;P:write(\"\\0\\128\")end;P:close()return true end end,login=function(self,a0,a1)if type(a0)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a0)..\")\",2)end;if a1~=nil and type(a1)~=\"string\"then error(\"bad argument #2 (expected string, got \"..type(a1)..\")\",2)end;local N,J,Q=self:_send_command(\"USER \"..a0)local M=J;if 230==M then return true elseif 500==M or 501==M or 421==M or 530==M then return false,Q elseif 331==M or 332==M then if a1==nil then return false,\"Password required\"end else error(\"Malformed reply (invalid code): \"..J)end;N,J,Q=self:_send_command(\"PASS \"..a1)local a2=J;if 230==a2 then return true elseif 202==a2 then return true elseif 500==a2 or 502==a2 or 421==a2 or 530==a2 then return false,Q elseif 332==a2 then return false,Q else return error(\"Malformed reply (invalid code): \"..J)end end,close=function(self)self:_send_command(\"QUIT\")return self.connection:close()end,setTransferParams=function(self,a3,w)if a3==nil then a3=self.transfer_params.type end;if w==nil then w=self.transfer_params.mode end;if type(a3)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a3)..\")\",2)end;if type(w)~=\"string\"then error(\"bad argument #2 (expected string, got \"..type(w)..\")\",2)end;if a3~=\"A\"and a3~=\"I\"then error(\"bad argument #1 (invalid data type)\",2)end;if w~=\"S\"and w~=\"B\"and w~=\"C\"then error(\"bad argument #2 (invalid transmission mode)\",2)end;if a3~=self.transfer_params.type then local N,J,Q=self:_send_command(\"TYPE \"..a3)if J==200 then self.transfer_params.type=a3 end end;if w~=self.transfer_params.mode then local N,J,Q=self:_send_command(\"MODE \"..w)if J==200 then self.transfer_params.mode=w end end;return self.transfer_params.type,self.transfer_params.mode end,list=function(self,a4)if type(a4)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a4)..\")\",2)end;if a4==\"\"then a4=\"/\"end;local a5;if self.transfer_params.type~=\"A\"then a5=self.transfer_params.type;if self:setTransferParams(\"A\")~=\"A\"then error(\"Could not switch to ASCII data type\")end end;local O,J,Q=self:_receive_data(\"NLST \"..a4)if a5 then self:setTransferParams(a5)end;if not O then error(Q..\" (\"..J..\")\",2)end;local a6={}local a7=1;for L in O:gmatch(\"[^\\r\\n]+\")do a6[a7]=L;a7=a7+1 end;return a6 end,stat=function(self,a4)return{size=0,type=self:isDir(a4)and\"directory\"or\"file\",created=0,modified=0,owner=\"root\",permissions={},worldPermissions={read=true,write=true,execute=true},setuser=false,capacity=0,freeSpace=0,special={}}end,isDir=function(self,a4)if type(a4)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a4)..\")\",2)end;if a4==\"\"then a4=\"/\"end;local N,J,Q=self:_send_command(\"CWD \"..a4)local M=J;if 533==M or 550==M then return false elseif 200==M or 250==M then self:_send_command(\"CWD /\")return true else return error(Q..\" (\"..J..\")\",2)end end,mkdir=function(self,a4)if type(a4)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a4)..\")\",2)end;local N,J,Q=self:_send_command(\"MKD \"..a4)if not N then return error(Q..\" (\"..J..\")\",2)end end,rename=function(self,a8,a9)if type(a8)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a8)..\")\",2)end;if type(a9)~=\"string\"then error(\"bad argument #2 (expected string, got \"..type(a9)..\")\",2)end;local N,J,Q=self:_send_command(\"RNFR \"..a8)if not N then error(Q..\" (\"..J..\")\",2)end;N,J,Q=self:_send_command(\"RNTO \"..a9)if not N then return error(Q..\" (\"..J..\")\",2)end end,remove=function(self,a4)if type(a4)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a4)..\")\",2)end;local N,J,Q=self:_send_command(\"DELE \"..a4)if not N then N=self:_send_command(\"RMD \"..a4)if N then for aa in ipairs(self:list(a4))do self:remove(a.combine(a4,aa))end else return error(Q..\" (\"..J..\")\",2)end end end,open=function(self,a4,w)if type(a4)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(a4)..\")\",2)end;if type(w)~=\"string\"then error(\"bad argument #2 (expected string, got \"..type(w)..\")\",2)end;local M=w;if\"r\"==M then if self:setTransferParams(\"A\")~=\"A\"then error(\"Could not switch to ASCII data type\")end;local O,J,Q=self:_receive_data(\"RETR \"..a4)if O==nil then return nil,Q..\" (\"..J..\")\"end;local ab=1;return{close=function()return nil end,readLine=function()if ab>=#O then return nil end;local E=O:find(\"\\n\",ab)or#O+1;local ac=O:sub(ab,E-1)ab=E+1;return ac end,readAll=function()if ab>=#O then return nil end;local ac=O:sub(ab)ab=#O;return ac end,read=function(A)if ab>=#O then return nil end;local ac=O:sub(ab,ab+A)ab=ab+A;return ac end,seek=function(ad,ae)ae=ae or 0;if type(ad)==\"number\"and type(ae)==nil then ae=ad;ad=\"cur\"end;local a2=ad;if\"cur\"==a2 then ab=ab+math.max(math.min(ae,#O),0)elseif\"set\"==a2 then ab=math.max(math.min(ae,#O),0)elseif\"end\"==a2 then ab=math.max(math.min(#O-ae,#O),0)end;return ab end}elseif\"w\"==M then local O=\"\"local ab=1;local af={flush=function()if self:setTransferParams(\"A\")~=\"A\"then error(\"Could not switch to ASCII data type\")end;local N,J,Q=self:_send_data(\"STOR \"..a4,O)if not N then return error(Q..\" (\"..J..\")\")end end,write=function(z)O=O:sub(1,ab-1)..z..O:sub(ab)ab=ab+#z end,writeLine=function(z)O=O:sub(1,ab-1)..z..\"\\n\"..O:sub(ab)ab=ab+#z+1 end,seek=function(ad,ae)ae=ae or 0;if type(ad)==\"number\"and type(ae)==nil then ae=ad;ad=\"cur\"end;local a2=ad;if\"cur\"==a2 then ab=ab+math.max(math.min(ae,#O),0)elseif\"set\"==a2 then ab=math.max(math.min(ae,#O),0)elseif\"end\"==a2 then ab=math.max(math.min(#O-ae,#O),0)end;return ab end}af.close=af.flush;return af elseif\"a\"==M then local O=\"\"local ab=1;return{close=function()if self:setTransferParams(\"A\")~=\"A\"then error(\"Could not switch to ASCII data type\")end;local N,J,Q=self:_send_data(\"STOA \"..a4,O)if not N then return error(Q..\" (\"..J..\")\")end end,write=function(z)O=O:sub(1,ab-1)..z..O:sub(ab)ab=ab+#z end,writeLine=function(z)O=O:sub(1,ab-1)..z..\"\\n\"..O:sub(ab)ab=ab+#z+1 end,flush=function()return nil end}elseif\"rb\"==M then if self:setTransferParams(\"I\")~=\"I\"then error(\"Could not switch to Image data type\")end;local O,J,Q=self:_receive_data(\"RETR \"..a4)if O==nil then return nil,Q..\" (\"..J..\")\"end;local ab=1;return{close=function()return nil end,readAll=function()if ab>=#O then return nil end;local ac=O:sub(ab)ab=#O;return ac end,read=function(A)if ab>=#O then return nil end;if A==nil then ab=ab+1;return O:byte(ab-1)end;local ac=O:sub(ab,ab+A)ab=ab+A;return ac end,seek=function(ad,ae)ae=ae or 0;if type(ad)==\"number\"and type(ae)==nil then ae=ad;ad=\"cur\"end;local a2=ad;if\"cur\"==a2 then ab=ab+math.max(math.min(ae,#O),0)elseif\"set\"==a2 then ab=math.max(math.min(ae,#O),0)elseif\"end\"==a2 then ab=math.max(math.min(#O-ae,#O),0)end;return ab end}elseif\"wb\"==M then local O=\"\"local ab=1;local af={flush=function()if self:setTransferParams(\"I\")~=\"I\"then error(\"Could not switch to Image data type\")end;local N,J,Q=self:_send_data(\"STOR \"..a4,O)if not N then return error(Q..\" (\"..J..\")\")end end,write=function(z)O=O:sub(1,ab-1)..(function()if type(z)==\"number\"then return string.char(z)else return z end end)()..O:sub(ab)ab=ab+#z end,seek=function(ad,ae)ae=ae or 0;if type(ad)==\"number\"and type(ae)==nil then ae=ad;ad=\"cur\"end;local a2=ad;if\"cur\"==a2 then ab=ab+math.max(math.min(ae,#O),0)elseif\"set\"==a2 then ab=math.max(math.min(ae,#O),0)elseif\"end\"==a2 then ab=math.max(math.min(#O-ae,#O),0)end;return ab end}af.close=af.flush;return af elseif\"ab\"==M then local O=\"\"local ab=1;return{close=function()if self:setTransferParams(\"I\")~=\"I\"then error(\"Could not switch to Image data type\")end;local N,J,Q=self:_send_data(\"STOA \"..a4,O)if not N then return error(Q..\" (\"..J..\")\")end end,write=function(z)O=O:sub(1,ab-1)..(function()if type(z)==\"number\"then return string.char(z)else return z end end)()..O:sub(ab)ab=ab+#z end,flush=function()return nil end}else return nil,\"Unknown mode \\\"\"..w..'\"'end end}H.__index=H;G=setmetatable({__init=function(self,m,n,ag,q)if n==nil then n=21 end;if ag==nil then ag=false end;if q==nil then q=5 end;self.timeout=q;local Q;self.connection,Q=l(m,n)if self.connection==nil then error(\"Could not connect to server: \"..Q,2)end;self.pasv=ag;self.transfer_params={type=\"A\",mode=\"S\"}return self:_send_command()end,__base=H,__name=\"client\"},{__index=H,__call=function(ah,...)local ai=setmetatable({},H)ah.__init(ai,...)return ai end})H.__class=G;F=G end;local aj;do local G;local H={send=function(self,S)self.connection.socket:write(S)self.status.total_bytes=self.status.total_bytes+#S;self.status.current_bytes=self.status.current_bytes+#S end,send_data=function(self,O,ak)self.status.current_bytes=0;self.status.target_bytes=#O;local M=self.transfer_params.mode;if\"S\"==M then for E=1,#O,65536 do self:send(O:sub(E,E+65535))end elseif\"B\"==M then for E=1,#O,65535 do local S=O:sub(E,E+65534)self:send((function()if#S<65535 then return\"\\0\"else return\"\\128\"end end)()..string.char(#S/256)..string.char(#S%256)..S)end elseif\"C\"==M then for E=1,#O,127 do local S=O:sub(E,E+126)self:send(string.char(#S)..S)end;self:send(\"\\0\\128\")end;self.socket:write(\"226 Transfer complete\\n\")self.connection.socket:close()if self.connection.ip==nil then return ak(self.connection.port)end end,receive_data=function(self,ak)local O=\"\"while self.connection.socket:status()==\"open\"do local S=v(self.connection.socket)local M=self.transfer_params.mode;if\"S\"==M then O=(O or\"\")..S elseif\"B\"==M then local T=S:byte(1)local A=S:byte(2)*256+S:byte(3)O=(O or\"\")..y(S,A)if math.floor(T/128)==1 then self.connection.socket:close()break end elseif\"C\"==M then local R=S:byte(1)if R==0 and math.floor(S:byte(2)/128)==1 then self.connection.socket:close()break elseif math.floor(R/128)==0 then O=(O or\"\")..S:sub(2,R%128+1)elseif math.floor(R/64)%2==0 then O=(O or\"\")..S:sub(2,2):rep(R%64)else if self.transfer_params.type==\"A\"or self.transfer_params.type==\"E\"then O=(O or\"\")..(\" \"):rep(R%64)elseif self.transfer_params.type==\"I\"or self.transfer_params.type==\"L\"then O=(O or\"\")..(\"\\0\"):rep(R%64)end end end end;if self.connection.ip==nil then ak(self.connection.port)end;return O end}H.__index=H;G=setmetatable({__init=function(self,o)self.socket=o;self.dir=\"\"self.transfer_params={type=\"A\",mode=\"S\"}self.status={total_bytes=0,current_bytes=nil,target_bytes=nil,current_command=nil}end,__base=H,__name=\"server_connection\"},{__index=H,__call=function(ah,...)local ai=setmetatable({},H)ah.__init(ai,...)return ai end})H.__class=G;aj=G end;local al;do local G;local H={commands={USER=function(self,am,a0)if a0==nil then return\"501 Missing username\"end;am.username=a0;if self.auth==nil or self.auth(am.username)then return\"230 User logged in, proceed.\"else return\"331 User name okay, need password.\"end end,PASS=function(self,am,a1)if a1==nil then return\"501 Missing password\"end;am.password=a1;if self.auth==nil then return\"202 Password not required for this server.\"elseif self.auth(am.username,am.password)then return\"230 User logged in, proceed.\"else return\"530 Login incorrect.\"end end,ACCT=function(self,am)return\"502 ACCT command not implemented\"end,CWD=function(self,am,an)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if an==nil then return\"501 Missing file name\"end;local a4;if an:sub(1,1)==\"/\"then a4=an else a4=a.combine(am.dir,an)end;if not a.isDir(a4)then return\"550 Not a directory\"end;am.dir=a4;return\"200 OK\"end,CDUP=function(self,am)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;am.dir=a.combine(am.dir,\"..\")return\"200 OK\"end,SMNT=function(self,am)return\"502 SMNT command not implemented\"end,REIN=function(self,am)am.username=nil;am.password=nil;am.dir=\"\"am.connection=nil;am.transfer_params={type=\"A\",mode=\"S\"}return\"220 Service ready for new user.\"end,QUIT=function(self,am)am.socket:write(\"221 Goodbye.\\n\")return am.socket:close()end,PORT=function(self,am,n)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if n==nil then return\"501 Missing ID/port\"end;local ao={n:match(\"(%d+),(%d+),(%d+),(%d+),(%d+),(%d+)\")}if tonumber(ao[1])==nil or tonumber(ao[2])==nil or tonumber(ao[3])==nil or tonumber(ao[4])==nil or tonumber(ao[5])==nil or tonumber(ao[6])==nil then return\"501 Port specified is not correctly formatted\"end;am.connection={ip=(\"%d.%d.%d.%d\"):format(ao[1],ao[2],ao[3],ao[4]),port=bit32.lshift(tonumber(ao[5]),8)+tonumber(ao[6])}return\"200 OK\"end,PASV=function(self,am)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;am.connection={ip=nil,port=self.port_provider()}if not am.connection.port then return\"425 Can't open data connection.\"end;local _=am.socket.localIP()am.connection.task=self:_add_task(function()am.connection.socket=p(_,am.connection.port)end,\"passive listener \"..am.connection.port)return(\"227 Entering passive mode. %s,%d,%d\"):format(_:gsub(\"%.\",\",\"),bit32.rshift(bit32.band(am.connection.port,0xFF00),8),bit32.band(am.connection.port,0xFF))end,TYPE=function(self,am,type)local ap=type:sub(1,1):upper()if ap==\"E\"or ap==\"L\"then return\"504 Transfer type \"..ap..\" not supported\"end;if ap~=\"A\"and ap~=\"I\"then return\"501 Unknown transfer type \"..ap end;am.transfer_params.type=ap;return\"200 OK\"end,STRU=function(self,am)return\"502 STRU command not implemented\"end,MODE=function(self,am,w)local ap=w:sub(1,1):upper()if ap~=\"S\"and ap~=\"B\"and ap~=\"C\"then return\"501 Unknown transfer mode \"..ap end;am.transfer_params.mode=ap;return\"200 OK\"end,RETR=function(self,am,aq)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if aq==nil then return\"501 Missing file name\"end;if am.connection.port==nil then return\"503 Bad sequence of commands\"end;if am.current_task~=nil then return\"425 Data connection already open\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;if not a.exists(a4)or a.isDir(a4)then am.connection=nil;return\"550 \"..(a.isDir(a4)and\"Path is directory\"or\"File '\"..a4 ..\"' does not exist\")end;am.current_task=self:_add_task(function()if am.connection.ip~=nil then am.connection.socket=l(am.connection.ip,self.connection.port)end;if am.connection.socket==nil then if am.connection.task~=nil then self.tasks[am.connection.task]=nil end;am.connection=nil;am.socket:write(\"425 Unable to open data connection.\")end;local O;if am.transfer_params.type==\"A\"then local ar=a.open(a4,\"r\")O=ar.readAll()ar.close()else local ar=a.open(a4,\"rb\")O=ar.read(a.getSize(a4))ar.close()end;am:send_data(O,self.port_provider)am.connection=nil;am.current_task=nil;am.status.current_bytes=nil;am.status.target_bytes=nil;am.status.current_command=nil end,\"send data \"..aq)am.status.current_command=\"RETR \"..a4;if am.connection.socket==nil then return\"150 Opening data connection\"else return\"125 Data connection already open; transfer starting.\"end end,STOR=function(self,am,aq)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if aq==nil then return\"501 Missing file name\"end;if am.connection.port==nil then return\"503 Bad sequence of commands\"end;if am.current_task~=nil then return\"425 Data connection already open\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;if a.isDir(a4)then am.connection=nil;return\"550 Path is directory\"end;am.current_task=self:_add_task(function()if am.connection.ip~=nil then am.connection.socket=l(am.connection.ip,self.connection.port)end;if am.connection.socket==nil then if am.connection.task~=nil then self.tasks[am.connection.task]=nil end;am.connection=nil;am.socket:write(\"425 Unable to open data connection.\")end;local O=am:receive_data(self.port_provider)local ar;if am.transfer_params.type==\"A\"then ar=a.open(a4,\"w\")else ar=a.open(a4,\"wb\")end;ar.write(O)ar.close()am.socket:write(\"250 Transfer complete\")am.connection=nil;am.current_task=nil;am.status.current_bytes=nil;am.status.target_bytes=nil;am.status.current_command=nil end,\"receive data \"..aq)am.status.current_command=\"STOR \"..a4;if am.connection.socket==nil then return\"150 Opening data connection\"else return\"125 Data connection already open; transfer starting.\"end end,STOU=function(self,am)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if am.connection.port==nil then return\"503 Bad sequence of commands\"end;if am.current_task~=nil then return\"425 Data connection already open\"end;local as,a4;as=table.concat((function()local a6={}local a7=1;for E=1,8 do a6[a7]=string.char(math.random(65,90))a7=a7+1 end;return a6 end)())..\".\"..table.concat((function()local a6={}local a7=1;for E=1,3 do a6[a7]=string.char(math.random(65,90))a7=a7+1 end;return a6 end)())a4=a.combine(am.dir,as)while a.exists(a4 or a.isDir(a4))do as=table.concat((function()local a6={}local a7=1;for E=1,8 do a6[a7]=string.char(math.random(65,90))a7=a7+1 end;return a6 end)())..\".\"..table.concat((function()local a6={}local a7=1;for E=1,3 do a6[a7]=string.char(math.random(65,90))a7=a7+1 end;return a6 end)())a4=a.combine(am.dir,as)end;am.current_task=self:_add_task(function()if am.connection.ip~=nil then am.connection.socket=l(am.connection.ip,self.connection.port)end;if am.connection.socket==nil then if am.connection.task~=nil then self.tasks[am.connection.task]=nil end;am.connection=nil;am.socket:write(\"425 Unable to open data connection.\")end;local O=am:receive_data(self.port_provider)local ar;if am.transfer_params.type==\"A\"then ar=a.open(a4,\"w\")else ar=a.open(a4,\"wb\")end;ar.write(O)ar.close()am.socket:write(\"250 Transfer complete: \"..as)am.connection=nil;am.current_task=nil;am.status.current_bytes=nil;am.status.target_bytes=nil;am.status.current_command=nil end,\"store unique \"..a4)am.status.current_command=\"STOU \"..a4;if am.connection.socket==nil then return\"150 Opening data connection\"else return\"125 Data connection already open; transfer starting.\"end end,APPE=function(self,am,aq)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if aq==nil then return\"501 Missing file name\"end;if am.connection.port==nil then return\"503 Bad sequence of commands\"end;if am.current_task~=nil then return\"425 Data connection already open\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;if a.isDir(a4)then am.connection=nil;return\"550 Path is directory\"end;am.current_task=self:_add_task(function()if am.connection.ip~=nil then am.connection.socket=l(am.connection.ip,self.connection.port)end;if am.connection.socket==nil then if am.connection.task~=nil then self.tasks[am.connection.task]=nil end;am.connection=nil;am.socket:write(\"425 Unable to open data connection.\")end;local O=am:receive_data(self.port_provider)local ar;if am.transfer_params.type==\"A\"then ar=a.open(a4,\"a\")else ar=a.open(a4,\"ab\")end;ar.write(O)ar.close()am.socket:write(\"250 Transfer complete\")am.connection=nil;am.current_task=nil;am.status.current_bytes=nil;am.status.target_bytes=nil;am.status.current_command=nil end,\"append \"..aq)am.status.current_command=\"APPE \"..a4;if am.connection.socket==nil then return\"150 Opening data connection\"else return\"125 Data connection already open; transfer starting.\"end end,ALLO=function(self,am)return\"502 ALLO command not implemented\"end,REST=function(self,am)return\"502 REST command not implemented\"end,RNFR=function(self,am,as)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if as==nil then return\"501 Missing file name\"end;am.rename_from=as;return\"350 Awaiting name to rename to.\"end,RNTO=function(self,am,as)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if as==nil then return\"501 Missing file name\"end;if am.rename_from==nil then return\"503 Bad sequence of commands\"end;local at;if am.rename_from:sub(1,1)==\"/\"then at=am.rename_from else at=a.combine(am.dir,am.rename_from)end;local au;if as:sub(1,1)==\"/\"then au=as else au=a.combine(am.dir,as)end;a.move(at,au)am.rename_from=nil;return\"250 File operation succeeded\"end,ABOR=function(self,am)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if self.current_task==nil then return\"226 No data transfer in progress\"end;self.tasks[am.current_task]=nil;am.socket:write(\"426 Data transfer aborted.\")return\"226 Data transfer successfully aborted.\"end,DELE=function(self,am,aq)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if aq==nil then return\"501 Missing file name\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;if not fs.exists(a4)then return\"550 File not found\"end;if fs.isDir(a4)then return\"550 Path is directory\"end;a.delete(a4)return\"250 File deleted\"end,RMD=function(self,am,aq)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if aq==nil then return\"501 Missing file name\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;if not fs.exists(a4)then return\"550 Directory not found\"end;if not fs.isDir(a4)then return\"550 Path is not directory\"end;a.delete(a4)return\"250 Directory deleted\"end,MKD=function(self,am,aq)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if aq==nil then return\"501 Missing file name\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;a.makeDir(a4)return'257 Created directory \"'..a4 ..'\"'end,PWD=function(self,am)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;return'257 \"/'..am.dir..'\"'end,LIST=function(self,am,aq)if aq==nil then aq=am.dir end;if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if am.connection.port==nil then return\"503 Bad sequence of commands\"end;if am.current_task~=nil then return\"425 Data connection already open\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;if not a.isDir(a4)then am.connection=nil;return\"550 Path is not a directory\"end;am.current_task=self:_add_task(function()if am.connection.ip~=nil then am.connection.socket=l(am.connection.ip,self.connection.port)end;if am.connection.socket==nil then if am.connection.task~=nil then self.tasks[am.connection.task]=nil end;am.connection=nil;am.socket:write(\"425 Unable to open data connection.\")end;local av={}for E,aw in ipairs(a.list(a4))do local ao=a.combine(a4,aw)local ax=a.attributes(ao)av[E]=(\"%s%s % 4d craftos craftos % 8d %s %s\"):format(ax.isDir and\"d\"or\"-\",(ax.isReadOnly and\"r-x\"or\"rwx\"):rep(3),ax.isDir and#a.list(ao)or 1,ax.size,os.date(\"%h %e  %Y\",ax.modified/1000),aw)end;am:send_data(table.concat(av,\"\\n\")..\"\\n\",self.port_provider)am.connection=nil;am.current_task=nil;am.status.current_bytes=nil;am.status.target_bytes=nil;am.status.current_command=nil end,\"name list \"..aq)am.status.current_command=\"NLST \"..a4;if am.connection.socket==nil then return\"150 Opening data connection\"else return\"125 Data connection already open; transfer starting.\"end end,NLST=function(self,am,aq)if aq==nil then aq=am.dir end;if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;if am.connection.port==nil then return\"503 Bad sequence of commands\"end;if am.current_task~=nil then return\"425 Data connection already open\"end;local a4;if aq:sub(1,1)==\"/\"then a4=aq else a4=a.combine(am.dir,aq)end;if not a.isDir(a4)then am.connection=nil;return\"550 Path is not a directory\"end;am.current_task=self:_add_task(function()if am.connection.ip~=nil then am.connection.socket=l(am.connection.ip,self.connection.port)end;if am.connection.socket==nil then if am.connection.task~=nil then self.tasks[am.connection.task]=nil end;am.connection=nil;am.socket:write(\"425 Unable to open data connection.\")end;am:send_data(table.concat((function()local a6={}local a7=1;for ay,aw in ipairs(a.list(a4))do a6[a7]=aw;a7=a7+1 end;return a6 end)(),\"\\n\")..\"\\n\",self.port_provider)am.connection=nil;am.current_task=nil;am.status.current_bytes=nil;am.status.target_bytes=nil;am.status.current_command=nil end,\"name list \"..aq)am.status.current_command=\"NLST \"..a4;if am.connection.socket==nil then return\"150 Opening data connection\"else return\"125 Data connection already open; transfer starting.\"end end,SITE=function(self,am)return\"202 Not implemented\"end,SYST=function(self,am)return\"215 UNKNOWN Phoenix\"end,STAT=function(self,am)if self.auth~=nil and not self.auth(am.username,am.password)then return\"530 Not logged in.\"end;return\"211-Status of '\"..tostring(b(\"/\",\"getLabel\"))..\"'\\n Connected from ID \"..tostring(am.socket.id)..\"\\n Logged in as \"..tostring(am.username)..\"\\n TYPE: \"..tostring(am.transfer.params==\"A\"and\"ASCII\"or\"Image\")..\", STRUcture: File, Mode: \"..tostring(am.transfer.params==\"S\"and\"Stream\"or(am.transfer.params==\"B\"and\"Block\"or\"Compressed\"))..\"\\n Total bytes transferred for session: \"..tostring(am.status.total_bytes)..\"\\n\"..(self.current_task==nil and\"No data connection\"or tostring(am.connection.id==nil and\"Passive\"or\"Active\")..\" data transfer from \"..tostring(am.connection.socket.id)..\" port \"..tostring(am.connection.port)..\"\\n\"..tostring(am.status.current_command)..\" (\"..tostring(am.status.target_bytes)..\"/\"..tostring(am.status.current_bytes)..\")\")..\"\\n211 End of status\"end,HELP=function(self,am,az)return\"202 Not implemented (yet)\"end,NOOP=function(self,am)return\"200 NOOP command successful\"end},_add_task=function(self,aA,as)return g(aA)end,listen=function(self)local r=\"psp://\"..self.ip..\":\"..self.port;d(r)while true do local t,u=coroutine.yield()if t==\"network_request\"and u.uri==r then self:_add_task(function()return self:run(u.handle)end,\"connection \"..u.handle.id)end end end,run=function(self,o)return self:_run_connection(aj(o))end,_run_connection=function(self,am)am.socket:write(\"220 Hello!\\n\")while am.socket:status()==\"open\"do local aB=v(am.socket)if not aB then break end;local I,aC=aB:gsub(\"%s+$\",\"\")if aB:find(\" \")then I,aC=aB:sub(1,aB:find(\" \")-1):upper():gsub(\"%s+$\",\"\"),aB:sub(aB:find(\" \")+1):gsub(\"%s+$\",\"\")end;if self.commands[I]==nil then am.socket:write(\"500 Unknown command '\"..I..\"'\\n\")else if aC==\"\"then aC=nil end;local K=self.commands[I](self,am,aC)if not(am.socket:status()==\"open\")then break end;if K and self.commands[I]~=nil then am.socket:write(K..\"\\n\")end end end;return am.socket:close()end}H.__index=H;G=setmetatable({__init=function(self,m,n,aD,ak)if m==nil then m=\"0.0.0.0\"end;if n==nil then n=21 end;if aD==nil then aD=nil end;if ak==nil then ak=B()end;self.port=n;self.auth=aD;self.filesystem=a;self.port_provider=ak;self.ip=m end,__base=H,__name=\"server\"},{__index=H,__call=function(ah,...)local ai=setmetatable({},H)ah.__init(ai,...)return ai end})H.__class=G;al=G end;return{client=F,server=al}\n",created=1704748610983,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=32975}},owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},libexec={modified=1704748613031,created=1704748613031,contents={["dhcpmgr.lua"]={modified=1704748610628,data="local a=require\"system.expect\"local b=require\"system.hardware\"local c=require\"system.log\"local d=require\"system.network\"local e=require\"system.util\"local function f(g)if g:match\"^%d+$\"then return tonumber(g)elseif g:match\"^%d+%.%d+$\"then return tonumber(g:match\"^%d+\")*0x1000000+tonumber(g:match\"^%d+%.(%d+)\")elseif g:match\"^%d+%.%d+%.%d+$\"then return tonumber(g:match\"^(%d+)\")*0x1000000+tonumber(g:match\"^%d+%.(%d+)\")*0x10000+tonumber(g:match\"^%d+%.%d+%.(%d+)\")elseif g:match\"^%d+%.%d+%.%d+%.%d+$\"then return tonumber(g:match\"^(%d+)\")*0x1000000+tonumber(g:match\"^%d+%.(%d+)\")*0x10000+tonumber(g:match\"^%d+%.%d+%.(%d+)\")*0x100+tonumber(g:match\"^%d+%.%d+%.%d+%.(%d+)\")else error(\"Invalid IP address\",2)end end;local function h(i)if not i then return nil end;return(\"%d.%d.%d.%d\"):format(bit32.band(bit32.rshift(i,24),0xFF),bit32.band(bit32.rshift(i,16),0xFF),bit32.band(bit32.rshift(i,8),0xFF),bit32.band(i,0xFF))end;local function j(i)return bit32.bnot(2^(32-i)-1)end;local function k(l)local m=0;while bit32.btest(l,0x80000000)do l,m=bit32.lshift(l,1),m+1 end;return m end;local n={static={},options={}}do local o,p=io.open(\"/etc/dhcpmgr.conf\",\"r\")assert(o,\"Could not open config file: \"..tostring(p))local q,p=load(o:read(\"*a\"):gsub(\"#\",\"--\"),\"@/etc/dhcpmgr.conf\",\"t\",n)o:close()assert(q,\"Could not load config file: \"..tostring(p))local r,p=pcall(q)assert(r,\"Could not load config file: \"..tostring(p))r,p=pcall(function()a.field(n,\"interface\",\"string\",\"nil\")a.field(n,\"firstaddr\",\"string\")a.field(n,\"lastaddr\",\"string\")n.firstaddr=f(n.firstaddr)n.lastaddr=f(n.lastaddr)a.field(n,\"netmask\",\"string\",\"number\",\"nil\")if type(n.netmask)==\"string\"then n.netmask=f(n.netmask)elseif type(n.netmask)==\"number\"then n.netmask=j(n.netmask)else n.netmask=j(k(bit32.bnot(bit32.bxor(n.firstaddr,n.lastaddr))))end;a.field(n,\"gateway\",\"string\",\"nil\")a.field(n,\"dns\",\"table\",\"nil\")if n.dns then for s,t in ipairs(n.dns)do if type(t)~=\"string\"then error(\"bad field 'dns' (entry \"..s..\" is not a string)\")end end end;a.field(n,\"leasetime\",\"number\",\"nil\")a.field(n,\"allowrequests\",\"boolean\")a.field(n,\"storeassignments\",\"boolean\")a.field(n,\"forcereassign\",\"boolean\")for u,t in pairs(n.static)do if type(u)==\"number\"then if type(t)~=\"string\"then error(\"bad static entry: \"..u..\" is not a string)\")end end end;n.options.dns=n.dns;n.options.gateway=n.gateway;n.options.netmask=h(n.netmask)end)assert(r,\"Could not load config file: \"..tostring(p))end;local v=c.create(\"dhcpmgr\",true,\"/var/log/dhcpmgr.log\")local w;if n.interface then w=b.wrap(n.interface)else w=b.find(\"modem\")end;if not w or not b.hasType(w,\"modem\")then v.error(\"Requested interface does not exist or is not a modem:\")error(\"Requested interface does not exist or is not a modem:\")end;w:open(67)b.listen(w,true)local x=d.ipconfig(b.path(w))local y=b.info(\"/\").metadata.id;local z={}local A={}if n.storeassignments then local o=io.open(\"/var/lib/misc/dhcpmgr\",\"r\")if o then for B in o:lines()do local C,g,D=B:match\"^(%d+)%s+([%d%.]+)%s+(%d+)\"if C then z[tonumber(C)]={address=f(g),expires=tonumber(D)}A[f(g)]=tonumber(C)end end;o:close()end end;for u,t in pairs(n.static)do z[u]={address=f(t),expires=0}A[f(t)]=u end;local function E(C)if z[C]then if n.forcereassign then A[z[C].address]=nil;z[C]=nil else return z[C]end end;for g=n.firstaddr,n.lastaddr do if not A[g]then v.info(\"Assigning address \"..h(g)..\" to ID \"..C)A[g]=C;z[C]={address=g,expires=n.leasetime and math.floor(os.time()+n.leasetime)or 0,pending=true}return z[C]end end;v.warn(\"Could not allocate address for ID \"..C)return nil end;local function F()if n.storeassignments then local o,p=io.open(\"/var/lib/misc/dhcpmgr\",\"w\")if o then for u,t in pairs(z)do if not t.pending then o:write((\"%d %s %d\\n\"):format(u,h(t.address),t.expires))end end;o:close()else v.warn(\"Could not open address database for writing:\",p)end end end;local G=e.timer(60)while true do local H,I=coroutine.yield()if H==\"modem_message\"and I.channel==67 and I.replyChannel==68 and type(I.message)==\"table\"and I.message.dhcp==true and type(I.message.from)==\"number\"then local J=I.message.type;if J==\"discover\"then local g;if type(I.message.requestedIP)==\"string\"and n.allowrequests then local r,K=pcall(f,I.message.requestedIP)if r and K>=n.firstaddr and K<=n.lastaddr and not A[K]then g={address=K,expires=n.leasetime and math.floor(os.time()+n.leasetime)or 0,pending=true}A[K]=I.message.from;z[I.message.from]=g end end;if not g then g=E(I.message.from)end;if g then local L={dhcp=true,type=\"offer\",from=y,to=I.message.from,serverIP=x.ip,offeredIP=h(g.address),messageID=I.message.messageID,options={}}if type(I.message.options)==\"table\"then for u in pairs(I.message.options)do if n.options[u]then L.options[u]=n.options[u]end end end;w:transmit(68,67,L)end elseif J==\"request\"and z[I.message.from]then local g=z[I.message.from]if I.message.to==y then g.pending=nil;F()local L={dhcp=true,type=\"acknowledgement\",from=y,to=I.message.from,serverIP=x.ip,offeredIP=h(g.address),messageID=I.message.messageID,options={}}if type(I.message.options)==\"table\"then for u in pairs(I.message.options)do if n.options[u]then L.options[u]=n.options[u]end end end;w:transmit(68,67,L)else A[g.address]=nil;z[I.message.from]=nil end end elseif H==\"timer\"and I.id==G then local M=os.time()local N=false;for u,t in pairs(z)do if t.expires>0 and M>t.expires then z[u]=nil;A[t.address]=nil;N=true end end;if N then F()end;G=e.timer(60)end end\n",created=1704748610631,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=5402},["usermgr.lua"]={modified=1704748612975,data="local a=require\"system.ipc\"local b=require\"system.log\"local c=require\"system.serialization\".base64;local d=require\"system.util\"local e=require\"sha2\"local f={[\"1\"]=e.md5,[\"5\"]=e.sha256,[\"6\"]=e.sha512,[\"\"]=\"\",[\"!\"]=\"Password authentication disabled\",[\"*\"]=\"Password authentication disabled\",[\"*LK*\"]=\"User locked\",[\"*NP*\"]=\"No password set\",[\"!!\"]=\"No password set\"}local g={[e.md5]=\"1\",[e.sha256]=\"5\",[e.sha512]=\"6\",[\"Password authentication disabled\"]=\"!\",[\"User locked\"]=\"*LK*\",[\"No password set\"]=\"!!\"}local h=5000;assert(a.register(\"usermgr\"),\"Could not register usermgr service. Is another instance running?\")local i={}local function j()local k,l=io.open(\"/etc/passwd\",\"r\")if not k then b.warn(\"Could not open /etc/passwd:\",l)return end;for m in k:lines()do local n=d.split(m,\":\",true)if#n>=7 then local o=d.split(n[5],\",\",true)i[n[1]]={fullName=o[1],home=n[6],shell=n[7]}end end;k:close()k,l=io.open(\"/etc/shadow\",\"r\")if not k then b.warn(\"Could not open /etc/shadow:\",l)return end;for m in k:lines()do local n=d.split(m,\":\",true)if#n>=9 then local p=d.split(n[2],\"%$\")i[n[1]].password={hashType=f[p[1]],salt=p[2]and c.decode(p[2]),password=p[3]and c.decode(p[3]),lastChange=tonumber(n[3]),nextChange=tonumber(n[4]),expirationTime=tonumber(n[5]),expirationWarning=tonumber(n[6]),lockTime=tonumber(n[7]),expirationDate=tonumber(n[8])}end end;k:close()end;local function q()local r,l=io.open(\"/etc/passwd\",\"w\")if not r then b.warn(\"Could not open /etc/passwd:\",l)return end;local s,t=io.open(\"/etc/shadow\",\"w\")if not s then r:close()b.warn(\"Could not open /etc/shadow:\",t)return end;for u,v in pairs(i)do local p;if type(v.password.hashType)==\"string\"then p=g[v.password.hashType]else p=\"$\"..g[v.password.hashType]..\"$\"..c.encode(v.password.salt)..\"$\"..c.encode(v.password.password)end;r:write((\"%s:x:::%s:%s:%s\\n\"):format(u,v.fullName or\"\",v.home or\"\",v.shell or\"\"))s:write((\"%s:%s:%d:%s:%s:%s:%s:%s:\\n\"):format(u,p,v.password.lastChange,v.password.nextChange or\"\",v.password.expirationTime or\"\",v.password.expirationWarning or\"\",v.password.lockTime or\"\",v.password.expirationDate or\"\"))end;r:close()s:close()end;j()d.addEventListener(\"remote_event\",function(w,x)local y=d.syscall.getpinfo(x.sender)if x.type==\"usermgr.request.authenticate\"then if type(x.data)~=\"table\"or type(x.data.user)~=\"string\"or type(x.data.password)~=\"string\"then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{error=\"Invalid request\"})return end;if y.user~=\"root\"then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{error=\"Permission denied\"})return end;local z=i[x.data.user]local A;if not z then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{error=\"Unknown user\"})return end;if z.password.hashType==\"\"then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{result=true})return elseif type(z.password.hashType)==\"string\"then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{error=z.password.hashType})return end;if z.password.expirationTime then if z.password.lockTime and os.time()>=(z.password.lastChange+z.password.expirationTime+z.password.lockTime)*86400 then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{error=\"User locked\"})if not z.password.expirationDate then z.password.expirationDate=math.floor(os.time()/86400)end;z.password.hashType=\"User locked\"z.password.password=nil;z.password.salt=nil;q()return elseif os.time()>=(z.password.lastChange+z.password.expirationTime)*86400 then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{error=\"Password expired\"})if not z.password.expirationDate then z.password.expirationDate=math.floor(os.time()/86400)q()end;return elseif z.password.expirationWarning and os.time()>=(z.password.lastChange+z.password.expirationTime-z.password.expirationWarning)*86400 then A=\"Password expires in \"..math.floor(os.time()/86400)-(z.password.lastChange+z.password.expirationTime)..\" days\"end end;local B=x.data.password..z.password.salt;for C=1,h do B=z.password.hashType(B)end;if B==z.password.password then a.sendEvent(x.sender,\"usermgr.response.authenticate\",{result=true,message=A})else a.sendEvent(x.sender,\"usermgr.response.authenticate\",{error=\"Incorrect password\"})end elseif x.type==\"usermgr.request.getUserInfo\"then if type(x.data)~=\"table\"or type(x.data.user)~=\"string\"then a.sendEvent(x.sender,\"usermgr.response.getUserInfo\",{error=\"Invalid request\"})return end;local z=i[x.data.user]a.sendEvent(x.sender,\"usermgr.response.getUserInfo\",{result=z and{name=x.data.user,fullName=z.fullName,home=z.home,shell=z.shell,lastChange=z.password.lastChange*86400,nextChange=z.password.nextChange and(z.password.lastChange+z.password.nextChange)*86400,expirationTime=z.password.expirationTime and(z.password.lastChange+z.password.expirationTime)*86400,expirationWarning=z.password.expirationTime and z.password.expirationWarning and(z.password.lastChange+z.password.expirationTime-z.password.expirationWarning)*86400,lockTime=z.password.expirationTime and z.password.lockTime and(z.password.lastChange+z.password.expirationTime+z.password.lockTime)*86400,isExpired=z.password.expirationDate~=nil,isLocked=z.password.hash and z.password.hash:match\"^!\",hasPassword=z.password.type~=\"No password set\"}})elseif x.type==\"usermgr.request.addUser\"then if type(x.data)~=\"table\"or type(x.data.user)~=\"string\"or x.data.password~=nil and type(x.data.password)~=\"string\"then a.sendEvent(x.sender,\"usermgr.response.addUser\",{error=\"Invalid request\"})return end;if y.user~=\"root\"then a.sendEvent(x.sender,\"usermgr.response.addUser\",{error=\"Permission denied\"})return end;if i[x.data.user]then a.sendEvent(x.sender,\"usermgr.response.addUser\",{error=\"User already exists\"})return end;local z={fullName=tostring(x.data.fullName or\"\"),home=tostring(x.data.home or\"\"),shell=tostring(x.data.shell or\"\"),password={lastChange=math.floor(os.time()/86400)}}if type(x.data.lockTime)==\"number\"then z.password.lockTime=x.data.lockTime end;if x.data.password==nil then z.password.hashType=\"No password set\"elseif x.data.password==\"\"then z.password.hashType=\"\"else local D=\"\"for C=1,16 do D=D..string.char(math.random(0,255))end;local B=x.data.password..D;z.password.hashType=e.sha256;for C=1,h do B=z.password.hashType(B)end;z.password.salt=D;z.password.password=B end;i[x.data.user]=z;q()a.sendEvent(x.sender,\"usermgr.response.addUser\",{result=true})elseif x.type==\"usermgr.request.editUser\"then if type(x.data)~=\"table\"or type(x.data.user)~=\"string\"then a.sendEvent(x.sender,\"usermgr.response.editUser\",{error=\"Invalid request\"})return end;if y.user~=\"root\"and y.user~=x.data.user then a.sendEvent(x.sender,\"usermgr.response.editUser\",{error=\"Permission denied\"})return end;local z=i[x.data.user]if not z then a.sendEvent(x.sender,\"usermgr.response.editUser\",{error=\"User does not exist\"})return end;if type(x.data.fullName)==\"string\"then z.fullName=x.data.fullName end;if type(x.data.home)==\"string\"then z.home=x.data.home end;if type(x.data.shell)==\"string\"then z.shell=x.data.shell end;q()a.sendEvent(x.sender,\"usermgr.response.editUser\",{result=true})elseif x.type==\"usermgr.request.removeUser\"then if type(x.data)~=\"table\"or type(x.data.user)~=\"string\"then a.sendEvent(x.sender,\"usermgr.response.removeUser\",{error=\"Invalid request\"})return end;if y.user~=\"root\"then a.sendEvent(x.sender,\"usermgr.response.removeUser\",{error=\"Permission denied\"})return end;if not i[x.data.user]then a.sendEvent(x.sender,\"usermgr.response.removeUser\",{error=\"User does not exist\"})return end;i[x.data.user]=nil;q()a.sendEvent(x.sender,\"usermgr.response.removeUser\",{result=true})elseif x.type==\"usermgr.request.setPassword\"then if type(x.data)~=\"table\"or type(x.data.user)~=\"string\"or x.data.password~=nil and type(x.data.password)~=\"string\"then a.sendEvent(x.sender,\"usermgr.response.setPassword\",{error=\"Invalid request\"})return end;if y.user~=\"root\"then a.sendEvent(x.sender,\"usermgr.response.setPassword\",{error=\"Permission denied\"})return end;local z=i[x.data.user]if not z then a.sendEvent(x.sender,\"usermgr.response.setPassword\",{error=\"Unknown user\"})return end;if x.data.password==nil then if x.data.isLocked==true then if z.password.password then z.password.password=\"!\"..z.password.password end elseif x.data.isLocked==false then if z.password.password then z.password.password=z.password.password:gsub(\"^!*\",\"\")end elseif x.data.expirationTime then z.password.expirationTime=z.password.lastChange+x.data.expirationTime else z.password.hashType=\"No password set\"z.password.salt,z.password.password=nil end else local D=\"\"for C=1,16 do D=D..string.char(math.random(0,255))end;local B=x.data.password..D;z.password.hashType=e.sha256;for C=1,h do B=z.password.hashType(B)end;z.password.salt=D;z.password.password=B;z.password.lastChange=math.floor(os.time()/86400)if type(x.data.nextChange)==\"number\"then z.password.nextChange=x.data.nextChange end;if type(x.data.expirationTime)==\"number\"then z.password.expirationTime=x.data.expirationTime end;if type(x.data.expirationWarning)==\"number\"then z.password.expirationWarning=x.data.expirationWarning end;if type(x.data.lockTime)==\"number\"then z.password.lockTime=x.data.lockTime end end;q()a.sendEvent(x.sender,\"usermgr.response.setPassword\",{result=true})elseif x.type:match(\"^usermgr%.request%.\")then a.sendEvent(x.sender,x.type:gsub(\"^usermgr%.request%.\",\"usermgr.response.\"),{error=\"Unknown request\"})end end)d.runEvents()\n",created=1704748613031,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=9305},["diskmgr.lua"]={modified=1704748610716,data="local a=require\"system.filesystem\"local b=require\"system.hardware\"local c=require\"system.log\"local d=c.create(\"diskmgr\",true)local e={}local function f(g)local h=b.call(g,\"getState\")if h and h.id then local i=\"/media/\"if h.label then i=i..h.label else i=i..h.id end;local j,k=pcall(function()a.mkdir(i)a.mount(\"drivefs\",g,i,{})e[g]=i end)if j then d.info(\"Mounted drive \"..g..\" to \"..i)else d.error(\"Could not mount drive: \"..k)end end end;local function l(i,m)if b.hasType(i,\"drive\")or b.hasType(i,\"modem\")then b.listen(i)end;if m and b.hasType(i,\"drive\")then f(i)end;for n,o in ipairs(b.children(i))do l(i..\"/\"..o,m)end end;b.listen(\"/\")l(\"/\",true)while true do local p,q=coroutine.yield()if p==\"disk\"then f(q.device)elseif p==\"disk_eject\"and e[q.device]then a.unmount(e[q.device])a.remove(e[q.device])e[q.device]=nil elseif p==\"device_added\"then l(q.device,false)end end\n",created=1704748610719,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=874},["ftpmgr.lua"]={modified=1704748610961,data="local a=require\"system.expect\"local b=require\"system.filesystem\"local c=require\"system.log\"local d=require\"system.network\"local e=require\"system.process\"local f=require\"system.terminal\"local g=require\"ftp\"local h=require\"sha2\"local i;if e.getuser()~=\"root\"then error(\"This program must be run as root.\")end;local j,k={},{}function j.user(l)a(1,l,\"string\")return function(m)a(2,m,\"table\")m.systemUser=a.field(m,\"systemUser\",\"string\",\"nil\")or l;a.field(m,\"password\",\"string\",\"nil\")if a.field(m,\"passwordHash\",\"string\",\"nil\")then a.field(m,\"passwordSalt\",\"string\")end;a.field(m,\"useSystemLogin\",\"boolean\",\"nil\")if m.useSystemLogin==nil then m.useSystemLogin=true end;if m.useSystemLogin and not i then i=require\"usermgr\"end;m.root=a.field(m,\"root\",\"string\",\"nil\")or\"/\"k[l]=m end end;do local n,o=io.open(\"/etc/ftpmgr.conf\",\"r\")assert(n,\"Could not open config file: \"..tostring(o))local p,o=load(n:read(\"*a\"):gsub(\"#\",\"--\"),\"@/etc/ftpmgr.conf\",\"t\",j)n:close()assert(p,\"Could not load config file: \"..tostring(o))local q,o=pcall(p)assert(q,\"Could not load config file: \"..tostring(o))q,o=pcall(function()j.ip=a.field(j,\"ip\",\"string\",\"nil\")or\"0.0.0.0\"j.port=a.field(j,\"port\",\"number\",\"nil\")or 21;j.passivePortRange=a.field(j,\"passivePortRange\",\"table\",\"nil\")or{65000,65535}if type(j.passivePortRange[1])~=\"number\"then error(\"bad field 'passivePortRange' (first entry is not a number)\")end;if type(j.passivePortRange[2])~=\"number\"then error(\"bad field 'passivePortRange' (second entry is not a number)\")end;if a.field(j,\"allUsers\",\"boolean\",\"nil\")and not i then i=require\"usermgr\"end end)assert(q,\"Could not load config file: \"..tostring(o))end;local r=c.create(\"ftpmgr\",true,\"/var/log/ftpmgr.log\")local function s(t)if not k[t]then k[t]={systemUser=t,root=\"/\",useSystemLogin=true,allowWrite=true}end;r.info(\"Logging in as \"..t)b.chroot(k[t].root)e.setuser(k[t].systemUser)e.getenv().didAuthenticate=true;e.getenv().allowWrite=k[t].allowWrite end;local function u(t,v)if e.getenv().didAuthenticate then return true end;if t then local w=k[t]local q=false;if not w then q=j.allUsers and v and i.authenticate(t,v)elseif not w.password and not w.passwordHash and not w.useSystemLogin then q=true elseif v then if w.passwordHash then q=h.sha256(v..w.passwordSalt)==w.passwordHash elseif w.password then q=v==w.password elseif w.useSystemLogin then q=i.authenticate(w.systemUser,v)end end;if q then s(t)return true else r.info(\"Login attempt for user\",t,\"failed: Invalid password\")return false end elseif k.anonymous then s(\"anonymous\")return true else r.info(\"Login attempt for user\",t,\"failed: No anonymous user available\")return false end end;local x={}local function y(z)if z then r.info(\"Closed data port \"..z)x[z]=nil;return end;if not x[20]then r.info(\"Opened data port 20\")x[20]=true;return 20 end;for A=j.passivePortRange[1],j.passivePortRange[2]do if not x[A]then r.info(\"Opened data port \"..A)x[A]=true;return A end end;return nil end;local B=g.server(j.ip,j.port,u,y)local C,D,E,F,G,H,I,J=B.commands.STOR,B.commands.STOU,B.commands.APPE,B.commands.RNFR,B.commands.RNTO,B.commands.DELE,B.commands.RMD,B.commands.MKD;function B.commands.REIN(self,K)return\"502 Not supported\"end;function B.commands.STOR(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return C(...)end;function B.commands.STOU(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return D(...)end;function B.commands.APPE(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return E(...)end;function B.commands.RNFR(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return F(...)end;function B.commands.RNTO(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return G(...)end;function B.commands.DELE(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return H(...)end;function B.commands.RMD(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return I(...)end;function B.commands.MKD(...)if not e.getenv().allowWrite then return\"531 Permission denied\"end;return J(...)end;local L=\"psp://\"..j.ip..\":\"..j.port;d.listen(L)while true do local M,N=coroutine.yield()if M==\"network_request\"and N.uri==L then r.info(\"Received connection from \"..N.ip)e.fork(function()f.stdin(nil)f.stdout(nil)f.stderr(nil)N.handle:transfer()B:run(N.handle)end,\"[ftpmgr] connection to \"..N.ip)d.listen(L)end end\n",created=1704748610983,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=4392},["netmgr.lua"]={modified=1704748611703,data="local a=require\"system.expect\"local b=require\"system.hardware\"local c=require\"system.log\"local d=require\"system.network\"local e=require\"system.util\"local f={dhcp=\"dhcp\",dhcp_staticaddr=\"dhcp_staticaddr\",static=\"static\",auto={},interfaces={}}function f.interface(g)if g==f.auto then g=b.find(\"modem\")if g then g=b.path(g)end end;a(1,g,\"string\")return function(h)a.field(h,\"acquire\",\"string\")if h.acquire==\"dhcp\"then a.field(h,\"dns\",\"table\",\"nil\")elseif h.acquire==\"dhcp_staticaddr\"then a.field(h,\"address\",\"string\")a.field(h,\"dns\",\"table\",\"nil\")elseif h.acquire==\"static\"then a.field(h,\"address\",\"string\")a.field(h,\"netmask\",\"string\",h.address:match\"/%d+$\"and\"nil\"or nil)a.field(h,\"gateway\",\"string\")a.field(h,\"dns\",\"table\")else error(\"bad field 'acquire' (invalid option)\",2)end;f.interfaces[g]=h end end;do local i,j=io.open(\"/etc/network.conf\",\"r\")assert(i,\"Could not open config file: \"..tostring(j))local k,j=load(i:read(\"*a\"):gsub(\"#\",\"--\"),\"@/etc/dhcpmgr.conf\",\"t\",f)i:close()assert(k,\"Could not load config file: \"..tostring(j))local l,j=pcall(k)assert(l,\"Could not load config file: \"..tostring(j))end;local m=c.create(\"netmgr\",true,\"/var/log/netmgr.log\")local function n(g,o)local p=b.wrap(g)if not p or not b.hasType(p,\"modem\")then error(\"Device does not exist or is not a modem\")end;p:open(68)b.listen(p,true)local q=math.random(0,2^31-1)local r=b.info(\"/\").metadata.id;p:transmit(67,68,{dhcp=true,type=\"discover\",from=r,messageID=q,requestedIP=o,options={netmask=true,gateway=true,dns=true}})local s=e.timer(2)local t={}while true do local u,v=coroutine.yield()if u==\"modem_message\"and v.channel==68 and v.replyChannel==67 and type(v.message)==\"table\"and v.message.dhcp==true and v.message.to==r and v.message.messageID==q and v.message.type==\"offer\"then t[v.message.from]={ip=v.message.offeredIP,netmask=v.message.options.netmask,gateway=v.message.options.gateway,dns=v.message.options.dns,up=true}elseif u==\"timer\"and v.id==s then break end end;if#t==0 then b.listen(p,false)p:close(68)error(\"Could not get IP address: Timed out\")end;for w,x in pairs(t)do d.control(x.ip,\"ping\")e.sleep(2)if not d.arp.list(g)[x.ip]then p:transmit(67,68,{dhcp=true,type=\"request\",from=r,to=w,messageID=q,options={netmask=true}})s=e.timer(2)while true do local u,v=coroutine.yield()if u==\"modem_message\"and v.channel==68 and v.replyChannel==67 and type(v.message)==\"table\"and v.message.dhcp==true and v.message.to==r and v.message.messageID==q and v.message.type==\"acknowledgement\"then d.ipconfig(g,x)if x.gateway then d.route.add({source=\"0.0.0.0\",sourceNetmask=0,action=\"unicast\",destination=x.gateway,device=g})end;b.listen(p,false)p:close(68)e.cancel(s)return elseif u==\"timer\"and v.id==s then b.listen(p,false)p:close(68)error(\"Could not get IP address: No response from server\")end end end end;b.listen(p,false)p:close(68)error(\"Could not get IP address: No usable offers\")end;for w,x in pairs(f.interfaces)do if x.acquire==\"dhcp\"then local l,j=pcall(n,w,nil)if not l then m.error(j)end elseif x.acquire==\"dhcp_staticaddr\"then local l,j=pcall(n,w,x.address)if not l then m.error(j)end elseif x.acquire==\"static\"then d.ipconfig(w,{ip=x.address,netmask=x.netmask,up=true})d.route.add({source=\"0.0.0.0\",sourceNetmask=0,action=\"unicast\",destination=x.gateway,device=w})end end\n",created=1704748611706,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=3274}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},share={modified=1704748610851,created=1704748610851,contents={man={modified=1704748613136,created=1704748613136,contents={man6={modified=1704748613143,created=1704748613143,contents={["yahtcc.md"]={modified=1704748613138,data="<summary>Yahtzee clone for Phoenix</summary>\n# NAME\n    yahtcc - Yahtzee clone for Phoenix\n\n# SYNOPSIS\n    **yahtcc**\n\n# DESCRIPTION\n**yahtcc** is a clone of the popular dice game \"Yahtzee\". Players roll a set of\nfive dice up to three times per round, trying to get the dice to roll in\ncertain patterns. Each pattern grants a number of points, and the goal of the\ngame is to achieve the highest number of points.\n\nThe main screen shows a scorecard with the available categories and the number\nof points already scored or available to score. Locked scores are colored white,\npossible scores are colored blue, and possible scores worth 0 points are colored\ngray. Below that, the current set of dice is displayed. Locked dice are colored\nyellow, while unlocked dice are colored white. The roll cup shows whether\nanother roll is available. The current total score and number of available rolls\nis displayed above the scorecard.\n\nTo roll the dice, press the **R** key or click on the roll cup. The unlocked\ndice will be rolled fresh, leaving the locked dice in-place. Dice may then be\nlocked or unlocked by pressing the **1**-**5** keys, or by clicking on any of\nthe dice. To lock a score, use the arrow keys to select the category to score,\nand press **Enter** to score it. Alternatively, double-click on any of the\nunscored categories.\n\n# GAMEPLAY\nA game of **yahtcc** consists of 13 rounds, with each round having three dice\nrolls, and ends when the player selects a pattern to score the current set of\ndice on. Between rolls, the player may lock any of the five dice, which will\nprevent them from being changed in the next roll. The player may score during\nany roll, but they must score after the third roll. Once a pattern is scored, it\ncannot be changed later.\n\nSix of the patterns are scored based on the number of dice in the set that match\nthe number for the score. The score is calculated by summing the values of those\ndice. For example, the *Threes* pattern will sum the value of all of the dice\nwith a value of 3.\n\nSix of the patterns are all-or-nothing based on whether the set of dice contains\ndice matching a pattern. If the pattern matches, the category gets the full score; otherwise, it is worth 0 points. The patterns in this category are scored as follows:\n\n- *Three of a Kind*: Matches when any three dice have the same value. Worth\nthe sum of all dice in the set.\n- *Four of a Kind*: Matches when any four dive have the same value. Worth\nthe sum of all dice in the set.\n- *Full House*: Matches when three dice have the same value, and two differently-valued dice are equal. Worth 25 points.\n- *Small Straight*: Matches when four dice have sequential values (i.e. 1-2-3-4,\n2-3-4-5, 3-4-5-6). Worth 30 points.\n- *Large Straight*: Matches when five dice have sequential values (i.e.\n1-2-3-4-5, 2-3-4-5-6). Worth 40 points.\n- *Yahtzee*: Matches when all five dice have the same value. Worth 50 points.\n\nThe last pattern, *Chance*, is a wildcard pattern that is always worth points.\nIts value is equal to the sum of the values of all dice.\n\nTwo bonuses can be triggered during the game. The *Bonus* score on the left is\nactivated when the sum of all of the numbered scores is greater than or equal to\n63, which corresponds to at least 3 dice in each category. When activated, it is\nworth 35 points. The *Yahtzee Bonus* score on the right is automatically\nactivated when all five dice rolled have the same value and the *Yahtzee*\ncategory has been scored with 50 points. It is worth 100 points.\n\nOnce all 13 categories have been scored, the game ends, and the final score is\nsimply the sum of all points awarded in each category. The final score is\nprinted to the console after the game ends.\n\n# AUTHORS\nYahtCC was written by JackMacWindows in 2020, and ported to Phoenix in 2022. It is licensed under the GPL license.\n\n*Yahtzee* is a registered trademark of Hasbro, Inc.\n",created=1704748613143,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=3884}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},man9={modified=1704748612256,created=1704748612256,contents={["kernel.md"]={modified=1704748612195,data="---\nlayout: default\ntitle: Kernel API\n---\n\n# Kernel API\nThis page contains documentation for the public kernel module API.\n\nThis is a work-in-progress! Some parts may be broken or don't make sense.\n\n## `version: string`\nVersion number of Phoenix.\n\n## `do_syscall(call: string, ...: any): any...`\nSmall function to execute a syscall and error if it fails.\n\n### Arguments\n1. `call`: The syscall to execute\n2. `...`: The arguments to pass to the syscall\n\n### Return Values\nThe values returned from the syscall\n\n## `deepcopy(tab: any): any`\nCopies a value.  If the value is a table, copies all of its contents too.\n\n### Arguments\n1. `tab`: The value to copy\n\n### Return Values\nThe new copied value\n\n## `split(str: string[, sep: string = \"%s\"]): {string}`\nSplits a string by a separator.\n\n### Arguments\n1. `str`: The string to split\n2. `sep`: The separator pattern to split by (defaults to \"%s\")\n\n### Return Values\nA list of items in the string\n\n## `executeThread(process: Process, thread: Thread, ev: table, dead: boolean, allWaiting: boolean): boolean, boolean`\nResumes a thread's coroutine, handling different yield types.\n\n### Arguments\n1. `process`: The process that owns the thread\n2. `thread`: The thread to resume\n3. `ev`: An event to pass to the thread, if present\n4. `dead`: Whether a thread in the current run cycle has died\n5. `allWaiting`: Whether all previous threads were waiting for an event\n\n### Return Values\nThis function may return the following values:\n1. Whether this thread or a previous thread has died\n2. Whether all threads (including this one) are waiting for an event\n\n## `userModeCallback(process: Process, func: function, ...: any): boolean, any`\nExecutes a function in user mode from kernel code.\n\n### Arguments\n1. `process`: The process to execute as\n2. `func`: The function to execute\n3. `...`: Any parameters to pass to the function\n\n### Return Values\nThis function may return the following values:\n1. Whether the function returned successfully\n2. The value that the function returned.\n\n## `make_ENV(env: table): table`\nCreates a new _ENV shadow environment for a table.  The resulting table can\n have its environment set through `t._ENV = val`.\n\n### Arguments\n1. `env`: The environment table to use\n\n### Return Values\nA new _ENV-ized table\n\n## `args`\nStores all kernel arguments passed on the command line.\n\n### Fields\n- `init`:\n- `root`:\n- `rootfstype`:\n- `preemptive`:\n- `quantum`:\n- `splitkernpath`:\n- `loglevel`:\n- `console`:\n- `traceback`:\n\n## `syscalls`\nContains every syscall defined in the kernel.\n\n## `processes`\nStores all currently running processes.\n\n### Fields\n- `[0]`:\n- `id`:\n- `user`:\n- `dir`:\n- `dependents`:\n\n## `modules`\nStores all currently loaded kernel modules.\n\n## `eventHooks`\nStores a list of hooks to call on certain CraftOS events.  Each entry has the\n event name as a key, and a list of functions to call as the value. The\n functions are called with a single table parameter with the event parameters.\n\n## `process`\nProcess API\n\n## `filesystem`\nFilesystem API\n\n## `terminal`\nTerminal API\n\n## `user`\nUser API\n\n## `syslog`\nSystem logger API\n\n## `hardware`\nHardware API\n\n## `PHOENIX_BUILD`\nBuild string of Phoenix.\n\n### Fields\nThis function does not take any arguments.\n\n## `systemStartTime`\nStores the start time of the kernel.\n\n### Fields\nThis function does not take any arguments.\n\n## `KERNEL`\nStores a quick reference to the kernel process object.\n\n### Fields\nThis function does not take any arguments.\n\n# filesystem\n\n\n## `mounts`\nStores the current mounts as a key-value table of paths to filesystem objects.\n\n## `filesystems`\nThis table contains all filesystem types.  Use this to insert more filesystem\n types into the system.\n\n A filesystem type has to implement one method for each function in the\n filesystem API, with the exception of mounting-related functions and `combine`,\n as well as a `new` method that is called with the process, the source device,\n and the options table (if present). Paths passed to these methods (outside\n `new`) take a relative path to the mountpoint, NOT the absolute path.\n\n### Fields\n- `craftos`:\n- `owner`:\n- `permissions`:\n- `write`:\n- `execute`:\n\n## `filesystem.open(process: Process, path: string, mode: string): Handle / nil, string`\nOpens a file for reading or writing.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The file path to open, which may be absolute or relative\n to the process's working directory\n3. `mode`: The mode to open the file as\n\n### Return Values\nThis function may return the following values:\n1. The new file handle\n\nOr:\n1. If an error occurred\n2. An error message describing why the file couldn't be opened\n\n## `filesystem.list(process: Process, path: string): {string}`\nReturns a list of file names in the directory.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The file path to list, which may be absolute or relative\n to the process's working directory\n\n### Return Values\nA list of file names present in the directory\n\n## `filesystem.stat(process: Process, path: string): table / nil, string`\nReturns a table with information about the selected path.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The file path to stat, which may be absolute or relative\n to the process's working directory\n\n### Return Values\nThis function may return the following values:\n1. A table with information about the path (see the docs for\n the `stat` syscall for more info)\n\nOr:\n1. If an error occurred\n2. An error message describing why the file couldn't be opened\n\n## `filesystem.remove(process: Process, path: string)`\nRemoves a file or directory.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The file path to remove, which may be absolute or relative\n to the process's working directory\n\n### Return Values\nThis function does not return anything.\n\n## `filesystem.rename(process: Process, path: string, new: The)`\nRenames (moves) a file or directory.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The file path to rename, which may be absolute or relative\n to the process's working directory\n3. `new`: path the file will be at, which may be in another directory\n but must be on the same mountpoint\n\n### Return Values\nThis function does not return anything.\n\n## `filesystem.mkdir(process: Process, path: string)`\nCreates a new directory and any parent directories.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The directory to create, which may be absolute or relative\n to the process's working directory\n\n### Return Values\nThis function does not return anything.\n\n## `filesystem.chmod(process: Process, path: string, user: string|nil, boolean: number|string|{read)`\nChanges the permissions (mode) of a file or directory for the specified user.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The file path to modify, which may be absolute or relative\n to the process's working directory\n3. `user`: The user to change the permissions for, or `nil` for all users\n4. `boolean`: ?, write = boolean?, execute = boolean?} mode The\n new permissions for the user (see the docs for the `chmod` syscall for more info)\n\n### Return Values\nThis function does not return anything.\n\n## `filesystem.chown(process: Process, path: string, user: string)`\nChanges the owner of a file or directory.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The file path to modify, which may be absolute or relative\n to the process's working directory\n3. `user`: The user that will own the file\n\n### Return Values\nThis function does not return anything.\n\n## `filesystem.mount(process: Process, type: string, src: string, dest: string, options: table?)`\nMounts a disk device to a path using the specified filesystem and options.\n\n### Arguments\n1. `process`: The process to operate as\n2. `type`: The type of filesystem to mount\n3. `src`: The source device to mount\n4. `dest`: The destination mountpoint\n5. `options`: Any options to pass to the mounter (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `filesystem.unmount(process: Process, path: string)`\nUnmounts a filesystem at a mountpoint.\n\n### Arguments\n1. `process`: The process to operate as\n2. `path`: The mountpoint to remove, which may be absolute or relative\n to the process's working directory\n\n### Return Values\nThis function does not return anything.\n\n## `filesystem.combine(first: string, ...: string): string`\nCombines the specified path components into a single path.\n\n### Arguments\n1. `first`: The first path component\n2. `...`: Any additional path components to add\n\n### Return Values\nThe final combined path\n\n## `createLuaLib(process: Process): _G`\nCreates a new global table with a Lua 5.2 standard library installed.\n\n### Arguments\n1. `process`: The process to generate for\n\n### Return Values\nA new global table for the process\n\n# terminal\n\n\n## `terminal.makeTTY(term: table, width: number, height: number): TTY`\nReturns a new TTY object.\n\n### Arguments\n1. `term`: The CraftOS terminal object to render on\n2. `width`: The width of the TTY\n3. `height`: The height of the TTY\n\n### Return Values\nThe new TTY object\n\n## `TTY`\nStores all virtual TTYs for the main screen.\n\n### Fields\n- `terminal`:\n- `terminal`:\n- `terminal`:\n- `terminal`:\n- `terminal`:\n- `terminal`:\n- `terminal`:\n- `terminal`:\n\n## `currentTTY`\nStores the TTY that is currently shown on screen.\n\n### Fields\nThis function does not take any arguments.\n\n## `terminal.userTTYs`\nStores all TTYs that have been created in user mode.\n\n## `keysHeld`\nStores what modifier keys are currently being held.\n\n### Fields\n- `ctrl`:\n- `alt`:\n- `shift`:\n\n## `terminal.redraw(tty: TTY, full: boolean)`\nRedraws the specified TTY if on-screen.\n\n### Arguments\n1. `tty`: The TTY to redraw\n2. `full`: Whether to draw the full screen, or just the changed regions\n\n### Return Values\nThis function does not return anything.\n\n## `terminal.resize(tty: TTY, width: number, height: number)`\nResizes the TTY.\n\n### Arguments\n1. `tty`: The TTY to resize\n2. `width`: The new width\n3. `height`: The new height\n\n### Return Values\nThis function does not return anything.\n\n## `terminal.write(tty: TTY, text: string)`\nWrites some text to a TTY's text buffer, allowing ANSI escapes.\n\n### Arguments\n1. `tty`: The TTY to write to\n2. `text`: The text to write\n\n### Return Values\nThis function does not return anything.\n\n# syslog\n\n\n## `syslogs`\nStores all open system logs.\n\n### Fields\n- `default`: file = filesystem.open(KERNEL, \"/var/log/default.log\", \"a\"),\n\n## `panic(message: any?)`\nImmediately halts the system and shows an error message on screen.\n This function can be called either standalone or from within xpcall.\n This function never returns.\n\n### Arguments\n1. `message`: A message to display on screen (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `createRequire(process: Process, G: _G)`\nCreates a new `package` and `require` set in a global table for the specified process.\n\n### Arguments\n1. `process`: The process to make the functions for\n2. `G`: The global environment to install in\n\n### Return Values\nThis function does not return anything.\n\n## `timerMap`\nStores a list of used timers.\n\n## `alarmMap`\nStores a list of used alarms.\n\n## `reap_process(process: Process)`\nFinishes a process's resources so it can be removed cleanly.\n\n### Arguments\n1. `process`: The process to reap\n\n### Return Values\nThis function does not return anything.\n\n# hardware\n\n\n## `deviceTreeRoot`\nStores the root device for hardware.\n\n### Fields\n- `id`:\n- `uuid`:\n- `parent`:\n- `displayName`:\n- `drivers`:\n\n## `hardware.get(path: string): Device...`\nReturns all devices that match a path specifier.\n\n### Arguments\n1. `path`: The path to query\n\n### Return Values\nThe device objects that match\n\n## `hardware.find(type: string): Device...`\nReturns all devices that match a type.\n\n### Arguments\n1. `type`: The type to find\n\n### Return Values\nThe device objects that match\n\n## `hardware.path(node: Device): string`\nReturns the absolute path to a device node.\n\n### Arguments\n1. `node`: The node to lookup\n\n### Return Values\nThe path to the node\n\n## `hardware.add(parent: Device, name: string): Device`\nAdds a new child to the specified node.\n\n### Arguments\n1. `parent`: The parent of the new node\n2. `name`: The name of the new node\n\n### Return Values\nThe newly added node\n\n## `hardware.remove(node: Device): boolean, string?`\nRemoves a node from its parent and the device tree.  The device node should\n no longer be used.\n\n### Arguments\n1. `node`: The node to remove\n\n### Return Values\nThis function may return the following values:\n1. Whether the operation succeeded\n2. An error message if it failed\n\n## `hardware.register(node: Device, driver: Driver): boolean, string?`\nRegisters a device driver on a node.\n\n### Arguments\n1. `node`: The node to modify\n2. `driver`: The driver to add\n\n### Return Values\nThis function may return the following values:\n1. Whether the operation succeeded\n2. An error message if it failed\n\n## `hardware.register_callback(driver: Driver): function`\nReturns a function that automatically attaches a driver to a node.\n\n### Arguments\n1. `driver`: The driver to use\n\n### Return Values\nA function that takes a node and registers the driver on it\n\n## `hardware.deregister(node: Device, driver: Driver): boolean, string?`\nDeregisters a driver from a node.\n\n### Arguments\n1. `node`: The node to modify\n2. `driver`: The driver to remove\n\n### Return Values\nThis function may return the following values:\n1. Whether the operation succeeded\n2. An error message if it failed\n\n## `hardware.listen(callback: function, parent: Device?, pattern: string?)`\nAdds a function that is called when either a parent node or pattern matches on a new node.\n\n### Arguments\n1. `callback`: A function that is called with a node when the pattern matches\n2. `parent`: A parent node to watch on (optional)\n3. `pattern`: A Lua pattern to match on the device name (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `hardware.unlisten(callback: function)`\nRemoves a listener callback from the listener list.\n\n### Arguments\n1. `callback`: The function to remove\n\n### Return Values\nThis function does not return anything.\n\n## `hardware.broadcast(node: Device, event: string, param: table)`\nBroadcasts an event to all processes listening to events on a node.\n\n### Arguments\n1. `node`: The node to broadcast for\n2. `event`: The event to broadcast\n3. `param`: The parameters to pass for the event\n\n### Return Values\nThis function does not return anything.\n\n## `hardware.call(process: Process, node: Device, method: string, ...: any): any...`\nCalls a method on a device.\n\n### Arguments\n1. `process`: The process to run as\n2. `node`: The node to call on\n3. `method`: The method to call\n4. `...`: Any arguments to pass\n\n### Return Values\nAny return values from the method\n\n## `uriSchemes`\nStores all URI scheme handlers using Lua patterns as keys.\n\n### Fields\n- `[https?]`:\n- `[wss?]`:\n- `[rednet]`:\n- `[rednet%+%a+]`:\n- `[psp]`:\n\n",created=1704748612256,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=15004}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},man7={modified=1704748612577,created=1704748612577,contents={["spanfs.md"]={modified=1704748612559,data="<summary>RAID-like spanning filesystem across disk peripherals</summary>\n# NAME\nspanfs - RAID-like spanning filesystem across disk peripherals\n\n# DESCRIPTION\nspanfs is a kernel module that implements a spanning filesystem layer across a\nnumber of disk peripherals. It concatenates the contents of the disks together\ninto a single drive, which can store large files across multiple disks.\n\nspanfs stores file information using a single index disk, which holds the\nentire filesystem structure, plus up to 65535 of disks to store file\ncontents. Each disk has a file called \".spanfs\", which contains three lines:\nthe user-friendly name of the filesystem, a UUID identifying it, and the ID\nof the disk in the array. The ID is used to identify the disk's position in\nthe array regardless of mountpoint.\n\nDisk ID 0 is the index disk. This disk contains only one file called \"index\"\nwhich is a binary file that stores the entire filesystem tree, including\nfile names, metadata, and directory contents. A directory entry consists of\nthe following data (all integers are little-endian):\n\n| Format | Size | Description       |\n|--------|------|-------------------|\n| `I`    | 4    | Directory entry length (excluding contents) |\n| `I`    | 4    | File size         |\n| `I8`   | 8    | Creation date     |\n| `I8`   | 8    | Modification date |\n| `B`    | 1    | Type (using TAR file types) |\n| `B`    | 1    | Bits 0-2: world permissions, bit 7: set user |\n| `s2`   | 2+x  | File name         |\n| `s2`   | 2+x  | Owner name        |\n| `B`    | 1    | Number of permission entries |\n| `s2B`* | (3+x)*y | List of permissions - each entry is a name followed by a 3-bit mode |\n\nThe index file consists of one directory entry for the root of the\nfilesystem, which is always of type \"directory\".\n\nIf the entry points to a file, it is followed by a 16-byte string containing\nthe UUID of the file data, then a 2-byte integer indicating the number of\ndisks the file is split across, and then a list of 2-byte integers holding\nthe IDs of the disks which hold the data, in sequence, and finally a CRC-32\nchecksum of the file (4 bytes).\n\nIf the entry is a directory, it is followed by a 4-byte integer with the\nnumber of files in the directory, followed by each entry in sequence. If the\nentry is a link, it is followed by a 2-byte length string with the path that\nthe link points to. If the entry is a FIFO there is no data after the entry.\n\nNote that the entry length does not include the length of the contents -\nthis is to allow the format to be extended for more metadata in the future.\nSkip over the entire entry length to get to the contents - do not rely on\nthe contents being at the end of the above table! The order of the above\nfields will not change in the future - fields will only be added at the end.\n\nFile data is stored by a random UUID assigned to the file. Each part of a\nfile is distributed across independent chunks on each disk, with each chunk\nnamed with the file's UUID. The file can be reconstructed by concatenating\nthe contents of each chunk in the order specified in the ID list in the file\nentry.\n\nThe default allocation algorithm will first attempt to store the entire file\non a single disk, finding the disk with the least amount of free space that\ncan still fit the whole file. If there are no disks that can store the\nentire file, then the file will be split across as few disks as possible,\nusing the disks with the largest free space in order. If two disks have the\nsame amount of free space, the disk with the lowest ID is preferred.\n\n# CONFIGURATION\n**spanfs** can be installed by dropping the `spanfs.lua` kernel module into\n`/lib/modules`. Ensure the file is not world-writable, and is executable by root.\n\nUse the **mkspanfs**(8) program to create new spanfs volumes across disks.\n\n# SEE ALSO\n**mkspanfs**(8), **spaninfo**(8)",created=1704748612577,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=3841},["fuse.md"]={modified=1704748611048,data="<summary>filesystem in userspace kernel module</summary>\n# NAME\nfuse - filesystem in userspace kernel module\n\n# DESCRIPTION\n**fuse** is a kernel module that implements an interface for filesystems written\nin userspace. This allows user programs to create and mount filesystem types\nwithout needing to load a kernel module. Filesystem operations are executed in a\nuser-mode process, with the results being sent back to the process that requested\nthe operation.\n\n# USAGE\nTo mount a **fuse**-based filesystem, simply use the **mount**(1) command with\nthe filesystem type **fuse**, and pass the filesystem to mount in the **fs**\noption. For example, an FTP filesystem could be mounted with the following command:\n\n```sh\nmount -t fuse -o fs=ftp,pasv ftp://user:password@10.0.1.1 /mnt/ftpshare\n```\n\nThis will mount the `ftp` filesystem (from `/lib/fuse/ftp.lua`) to `/mnt/ftpshare`,\nusing the mount source `ftp://user:password@10.0.1.1` and passing the `pasv`\noption to the filesystem.\n\nFilesystem modules are located in `/lib/fuse` by default. Filesystems located in\nother locations may be loaded by passing the path as the `fs` option.\n\n# WRITING FILESYSTEMS\nA **fuse** filesystem is simply a Lua library which returns a table with the\nrequired filesystem methods. The library is run with two parameters: the path to\nthe filesystem to mount, and a key-value table with the mount options. It is run\nin a thread under the process that called **mount**(2) (usually **mount**(1)).\n\nEach method in the filesystem is called with at least two arguments: the table\nreturned (as in `:` methods), and a process table filled from **getpinfo**(2).\nMost methods also have at least one path argument as a string. There is no need\nto do argument type checking: this is done in the kernel before calling the\nfilesystem methods.\n\nThe following methods are expected to be exported by the filesystem:\n\n```ts\ninterface Filesystem {\n    open(self: table, process: ProcessInfo, path: string, mode: string): table | string | ((data: string, reset: boolean): void);\n    list(self: table, process: ProcessInfo, path: string): string[];\n    stat(self: table, process: ProcessInfo, path: string, nolink?: boolean): Stat?;\n    remove(self: table, process: ProcessInfo, path: string): void;\n    rename(self: table, process: ProcessInfo, path: string, to: string): void;\n    mkdir(self: table, process: ProcessInfo, path: string): void;\n    link(self: table, process: ProcessInfo, path: string, location: string): void;\n    mkfifo(self: table, process: ProcessInfo, path: string): void;\n    chmod(self: table, process: ProcessInfo, path: string, user: string | nil, mode: string | number | table): void;\n    chown(self: table, process: ProcessInfo, path: string, owner: string): void;\n    unmount?(self: table, process: ProcessInfo): void;\n    init?(self: table, process: ProcessInfo): void;\n}\n```\n\nAll functions are optional, but calls on unimplemented functions will throw an\nerror to the caller. A minimal filesystem should implement at least `open`,\n`list`, and `stat`. The `unmount` method is called when the filesystem is about\nto be unmounted, and can be used to clean up resources before unmounting. If it\nis not present, no error is emitted, and the filesystem is removed as usual. The\n`init` method is called right after the filesystem is mounted, and can be used\nto initialize certain things that have to run on the client process.\n\nMost methods function the same as their respective syscalls. However, the `open`\nmethod has extra functionality: if it returns a string, then a read file handle\nwill be synthesized automatically (with a second boolean return value indicating\nwhether it should be binary). Likewise, if it returns a function, it'll return\na write file handle which will call the function to flush data to the file. This\ncan be used to simplify basic file open operations, reducing code duplication in\nthe process.\n\nEach mounted filesystem is given its own process to run as, which is forked from\nthe initial mount process, and is disconnected from TTYs. Methods are called in\nnew threads under that process. When the filesystem is unmounted, the main\nthread exits, which will cause the process to exit once the last remaining\nfilesystem method returns.\n\n# EXAMPLES\nHere is an example of a minimal filesystem:\n\n```lua\nlocal fs = {}\n\nfunction fs:open(process, path, mode)\n    if path == \"\" then return nil, \"Is a directory\"\n    elseif path == \"zero\" then\n        if mode:find \"[wa]\" then\n            return {\n                close = function() end,\n                seek = function() end,\n                write = function() end,\n                writeLine = function() end,\n                flush = function() end\n            }\n        end\n        return {\n            close = function() end,\n            seek = function() end,\n            read = function(n)\n                if not n then return 0\n                else return (\"\\0\"):rep(n) end\n            end,\n            readLine = function() return \"\" end,\n            readAll = function() return \"\" end\n        }\n    elseif path == \"random\" then\n        if mode:find \"[wa]\" then\n            return {\n                close = function() end,\n                seek = function() end,\n                write = function() end,\n                writeLine = function() end,\n                flush = function() end\n            }\n        end\n        return {\n            close = function() end,\n            seek = function() end,\n            read = function(n)\n                if not n then return math.random(0, 255)\n                else\n                    local s = \"\"\n                    for i = 1, n do s = s .. string.char(math.random(0, 255)) end\n                    return s\n                end\n            end,\n            readLine = function() return \"\" end,\n            readAll = function() return \"\" end\n        }\n    else return nil, \"No such file\" end\nend\n\nfunction fs:list(process, path)\n    if path == \"\" then\n        return {\"zero\", \"random\"}\n    else\n        error(\"No such directory\")\n    end\nend\n\nfunction fs:stat(process, path)\n    if path == \"zero\" then\n        return {\n            size = 0,\n            type = \"file\",\n            created = 0,\n            modified = 0,\n            owner = \"root\",\n            permissions = {},\n            worldPermissions = {read = true, write = false, execute = false},\n            setuser = false,\n            capacity = 0,\n            freeSpace = 0,\n            special = {}\n        }\n    elseif path == \"random\" then\n        return {\n            size = 0,\n            type = \"file\",\n            created = 0,\n            modified = 0,\n            owner = \"root\",\n            permissions = {},\n            worldPermissions = {read = true, write = false, execute = false},\n            setuser = false,\n            capacity = 0,\n            freeSpace = 0,\n            special = {}\n        }\n    elseif path == \"\" then\n        return {\n            size = 0,\n            type = \"directory\",\n            created = 0,\n            modified = 0,\n            owner = \"root\",\n            permissions = {},\n            worldPermissions = {read = true, write = false, execute = true},\n            setuser = false,\n            capacity = 0,\n            freeSpace = 0,\n            special = {}\n        }\n    else return nil end\nend\n\nreturn fs\n```\n\n# SEE ALSO\n**mount**(1)\n\n# AUTHORS\n**fuse** was written by JackMacWindows, based on the concepts of FUSE/libfuse\nfor *nix.\n",created=1704748611054,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=7444}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},[".mandb"]={modified=1704748613170,data="craftos(1): run CraftOS programs under Phoenix\nlogger(1): view, post to, create, and delete logs\nlogin(1): \npasswd(1): \nshell(1): CraftOS shell wrapper for Phoenix\nshutdown(1): \nstartctl(1): \nstartmgr(1): \nsu(1): \nsudo(1): \ntar(1): \n_template(2): \nacquiresemaphore(2): acquires a resource from a semaphore object\nalarm(2): sets an alarm\narplist(2): returns the list of known IP to computer ID mappings\narpset(2): sets the computer ID mapping for the specified IP\nattach(2): attaches a peripheral of the specified type to the computer\ncallmodule(2): calls a function on a kernel module\ncancel(2): cancels a previously set timer or alarm\ncchost(2): returns the value of the _HOST variable\ncheckuri(2): returns whether the specified URI is valid\nchmod(2): changes the permissions of a file or directory\nchown(2): changes the owner of a file or directory\nchroot(2): changes the root directory\ncombine(2): combines a set of path components into a valid path\nconnect(2): creates a connection to a remote resource\ndetach(2): detaches a peripheral from a side\ndevalias(2): sets or removes an alias for a device\ndevcall(2): calls the specified method on the device\ndevchildren(2): returns a list of names of all children of the current device\ndevfind(2): finds devices with a specific type\ndevinfo(2): returns a table with information describing a device node\ndevlisten(2): enables listening for events from this device\ndevlock(2): locks the specified device to this process\ndevlookup(2): returns all paths to devices that have the specified node name\ndevmethods(2): returns a list of methods that can be called on this device\ndevproperties(2): returns a list of properties on the device\ndevunlock(2): unlocks the specified device\nipconfig(2): queries or modifies the current PIP config\nkernargs(2): returns the arguments passed to the kernel\nkill(2): sends a signal to another process\nlink(2): creates a new symbolic link\nlist(2): returns a list of file names present in a directory\nlisten(2): starts listening for connections on the specified URI\nlistmodules(2): returns a list of currently loaded kernel module names\nloadCraftOSAPI(2): loads a CraftOS API or module from the ROM\nloadmodule(2): attempts to load a kernel module into memory\nlockmutex(2): locks the specified mutex\nmkdir(2): creates a new directory\nmkfifo(2): creates a new FIFO pipe file\nmount(2): mounts a disk device to a path\nmountlist(2): returns a list of mounts on the system\nnetcontrol(2): sends a control message to the specified IP address\nnetevent(2): returns or toggles the current state of network event reporting\nopen(2): opens a file for reading or writing\nqueueEvent(2): queues an arbitrary event to be sent back to the current process\nreleasesemaphore(2): releases a resource from a semaphore\nremove(2): deletes a file at a path\nrename(2): renames a file or directory from one path to another\nrouteadd(2): adds a new route to the specified route table\nroutedel(2): removes the specified route from the specified table\nroutelist(2): returns a list of route entries in the specified route table\nsendEvent(2): queues a remote event to be sent to another process\nsignal(2): registers a handler function to be called for a signal\nstat(2): returns a table with information about a file or directory\ntimeacquiresemaphore(2): acquires a resource from a semaphore object, waiting until available or timeout\ntimelockmutex(2): locks the specified mutex, waiting until the mutex is unlocked or timeout\ntimer(2): sets a timer\ntrylockmutex(2): attempts to lock the mutex\nunlisten(2): stops listening on a URI previously passed to listen\nunloadmodule(2): unloads a kernel module from memory\nunlockmutex(2): unlocks the specified mutex\nunmount(2): unmounts the mount at the specified path\nuptime(2): returns the amount of time the computer has been running\nversion(2): returns the Phoenix version or build number\nftp(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nsystem(3): \nusermgr(3): \nftpmgr(5): configuration file for ftpmgr\nmotd(5): \npasswd(5): \nshadow(5): \nyahtcc(6): Yahtzee clone for Phoenix\nfuse(7): filesystem in userspace kernel module\nspanfs(7): RAID-like spanning filesystem across disk peripherals\ncomponents(8): \ndpkg(8): \nftpmgr(8): \nmkspanfs(8): Create and format new spanfs disks\nspanadd(8): add drives to an existing span\nspaninfo(8): shows information about a span\nupdate-initrd(8): \nupdate(8): \nuseradd(8): \nuserdel(8): \nusermgr(8): \nusermod(8): \nkernel(9): \n",created=1704748613170,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=4566},man1={modified=1704748613033,created=1704748613033,contents={["craftos.md"]={modified=1704748611242,data="<summary>run CraftOS programs under Phoenix</summary>\n# NAME\n    craftos - run CraftOS programs under Phoenix\n\n# SYNOPSIS\n    **craftos** *program path* [*arguments ...*]\n\n# DESCRIPTION\n**craftos** allows running programs written for CraftOS on top of Phoenix. It\nuses *libcraftos* to implement a compatibility layer between CraftOS APIs and\nPhoenix system calls. It loads all of the CraftOS APIs into the program's global\ntable, and then executes the program with the specified arguments.\n\n**craftos** functions as if the program was called from the CraftOS shell, or\nusing `shell.run`. It should be compatible with many programs, but some that\nrequire specific details of CraftOS's inner workings may not be compatible.\n\n# HISTORY\nIntroduced in libcraftos 0.1.\n\n# SEE ALSO\n**shell**(1)\n",created=1704748611252,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=788},["startmgr.md"]={modified=1704748612679,data="",created=1704748612690,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=0},["passwd.md"]={modified=1704748612983,data="",created=1704748613032,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=0},["shutdown.md"]={modified=1704748612674,data="",created=1704748612689,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=0},["shell.md"]={modified=1704748611245,data="<summary>CraftOS shell wrapper for Phoenix</summary>\n# NAME\n    shell - CraftOS shell wrapper for Phoenix\n\n# SYNOPSIS\n    **shell**\n\n# DESCRIPTION\n**shell** executes the CraftOS shell program using libcraftos. It requires the\nROM to be mounted at `/rom` - if run as root, it will automatically mount the\nROM as needed.\n\nThe filesystem is the same as the Phoenix filesystem, so all Phoenix files will\nstill be present in the shell. Compatibility caveats with libcraftos still apply,\nbut the `shell`, `package`, and `require` APIs will be replaced with the\noriginal CraftOS versions, so issues relating to those will no longer apply.\n\nPhoenix programs will still be executable in the CraftOS shell. However, the\nprograms will execute in the same process context as the shell. This means that\ncalls that affect global process state, such as **exit**(2) or **stdin**(2),\nwill also affect the shell, as well as other programs run in the shell (e.g.\ncalling **exit**(2) will quit the entire shell).\n\n# HISTORY\nIntroduced in libcraftos 0.2.\n\n# SEE ALSO\n**craftos**(1)\n",created=1704748611252,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1061},["login.md"]={modified=1704748612980,data="",created=1704748613031,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=0},["tar.md"]={modified=1704748612785,data="",created=1704748612790,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=0},["sudo.md"]={modified=1704748612989,data="",created=1704748613033,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=0},["su.md"]={modified=1704748612986,data="",created=1704748613033,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=0},["logger.md"]={modified=1704748611945,data="<summary>view, post to, create, and delete logs</summary>\n# NAME\nlogger - view, post to, create, and delete logs\n\n# SYNOPSIS\n**logger log** [**-n** *log name*] [**-c** *category*] [**-l** **debug**|**info**|**notice**|**warning**|**error**|**critical**] [**-m** *module*] *message* ...\n**logger create** [**-F** *path*] [**-s**] *log name*\n**logger delete** [**-p**] *log name*\n**logger view** *log name*\n**logger follow** [**-f** *filter*] *log name*\n\n# DESCRIPTION\n**logger** provides a simple command-line interface to the system logger module. It allows viewing logs (including streaming), posting messages to a log, and creating and deleting logs.\n\n# PARAMETERS\nFor the **log** subcommand:\n\n**-c** *category*  \n    Sets the category for the message.\n\n**-l** **debug**|**info**|**notice**|**warning**|**error**|**critical**  \n    Sets the level of the log messgae.\n\n**-m** *module*  \n    Sets the name of the module for the message.\n\n**-n** *log name*  \n    Sets the name of the log to write to.\n\nFor the **create** subcommand:\n\n**-F** *path*  \n    Sets the file to write logs to.\n\n**-s**  \n    Specifies that the log should be streamable.\n\nFor the **delete** subcommand:\n\n**-p**  \n    Purges all logs on disk.\n\nFor the **follow** subcommand:\n\n**-f** *filter*  \n    Specifies a filter expression to apply to the listener.\n    \n    A filter consists of a series of clauses separated by semicolons. Each clause consists of a name, operator, and one or more values separated by bars (`|`). String values may be surrounded with double quotes to allow semicolons, bars, and leading spaces. If multiple values are specified, any value matching will cause the clause to resolve to true. All clauses must be true for the filter to match.\n    \n    Available operators: `==`, `!=`/`~=`, `=%` (match), `!%`/`~%` (not match), `<`, `<=`, `>=`, `>` (numbers only).\n    \n    Example: `level == 3 | 4 | 5; category != filesystem; process > 0; message =% \"Unexpected error\"`\n\n# HISTORY\nIntroduced in baseutils 0.2.\n\n# SEE ALSO\n**syslog**(2), **system.log**(3)\n",created=1704748612200,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=2047},["startctl.md"]={modified=1704748612676,data="",created=1704748612690,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=0}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},man5={modified=1704748613036,created=1704748613036,contents={["motd.md"]={modified=1704748612999,data="",created=1704748613035,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=0},["passwd.md"]={modified=1704748613002,data="",created=1704748613035,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=0},["shadow.md"]={modified=1704748613004,data="",created=1704748613036,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=0},["ftpmgr.conf.md"]={modified=1704748610971,data="<summary>configuration file for ftpmgr</summary>\n\n# NAME\n    **ftpmgr.conf** - configuration file for ftpmgr\n\n# SYNOPSIS\n    /etc/ftpmgr.conf\n\n# DESCRIPTION\nThe /etc/ftpmgr.conf file configures settings for the **ftpmgr(8)** FTP server.\n\nThe file uses a code-like syntax, with comments using `#`. Options are set using *key* **=** *value* **;** syntax, and users are defined using **user \"** *name* **\" {** *options* **}**. Strings may be delimited with **\"** or **'**. `#` characters in strings are not recommended, as they may be mistaken for comments while parsing.\n\n# GLOBAL OPTIONS\n* **ip =** *string*: The IP address to serve on. \"0.0.0.0\" indicates any IP/interface.\n* **port =** *number*: The port to serve the command stream on. FTP standard is 21.\n* **passivePortRange = {** *number* **,** *number* **}**: The range of ports to reserve for passive connections.\n* **allUsers =** *boolean*: Whether to allow all users on the system to log in. These users will use their system username and password for login, and have access to the full system root with their permissions. This requires **usermgr(8)** to be installed.\n\n# USER OPTIONS\nThere are three methods of authentication available:\n* No authentication: No password is required for the user. This is used when `useSystemLogin` is false, and no password or hash is set.\n* Password authentication: A password for the user is supplied in the config file. This is used when `password` or `passwordHash` is set for a user.\n* System authentication: The user's password is stored in the system database (i.e. **passwd(5)**), and authentication is done through **usermgr(8)**, which must be installed. This is used when `useSystemLogin` is true (default) and no `password` is set.\n\nA user named `anonymous` is used when no username or password is entered. It is disabled by default for security, but can be configured to provide, for example, public read-only access to a certain folder on the system.\n\nThe following options may be configured in each user directive:\n* **systemUser =** *string*: The Phoenix username to run the server as. Defaults to the name of the FTP user.\n* **password =** *string*: The password for the user in plaintext.\n* **passwordHash =** *string*: The hex SHA-256 hash of the password + hash.\n* **useSystemLogin =** *boolean*: Whether to use system credentials for the user (requires **usermgr(8)**). Defaults to true. Overridden by `password` and `passwordHash`.\n* **allowWrite =** *boolean*: Whether to allow writing files, irrespective of the system user's permissions. Defaults to true.\n* **root =** *string*: The root of the filesystem to expose to the share. Defaults to `/`.\n\n# SEE ALSO\n**ftpmgr(8)**\n",created=1704748610985,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=2691}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},man3={modified=1704748613034,created=1704748613034,contents={["system.expect.md"]={modified=1704748612145,data="# system.expect\nThe expect module provides error checking functions for other libraries.\n\n## `expect(index: number, value: any, ...: string): any`\nCheck that a numbered argument matches the expected type(s).  If the type\n doesn't match, throw an error.\n This function supports custom types by checking the __name metaproperty.\n\n### Arguments\n1. `index`: The index of the argument to check\n2. `value`: The value to check\n3. `...`: The types to check for\n\n### Return Values\n`value`\n\n## `field(tbl: any, key: any, ...: string): any`\nCheck that a key in a table matches the expected type(s).  If the type\n doesn't match, throw an error.\n This function supports custom types by checking the __name metaproperty.\n\n### Arguments\n1. `tbl`: The table (or other indexable value) to search through\n2. `key`: The key of the table to check\n3. `...`: The types to check for\n\n### Return Values\nThe indexed value in the table\n\n## `range(num: number[, min: number = -math.huge][, max: number = math.huge]): number`\nCheck that a number is between the specified minimum and maximum values.  If\n the number is out of bounds, throw an error.\n\n### Arguments\n1. `num`: The number to check\n2. `min`: The minimum value of the number (inclusive) (defaults to -math.huge)\n3. `max`: The maximum value of the number (inclusive) (defaults to math.huge)\n\n### Return Values\n`num`\n\n",created=1704748612246,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1349},["system.ipc.md"]={modified=1704748612162,data="# system.ipc\nThe IPC module provides functions for sending messages to other processes.\n\n## `kill(pid: number, signal: number)`\nSends a basic signal to a process.\n\n### Arguments\n1. `pid`: The PID of the process to send to\n2. `signal`: The signal to send to the process\n\n### Return Values\nThis function does not return anything.\n\n## `sigaction(signal: number, fn: function|nil)`\nSets the handler for a signal.\n\n### Arguments\n1. `signal`: The signal to modify\n2. `fn`: The function to call, or `nil` to remove\n\n### Return Values\nThis function does not return anything.\n\n## `sendEvent(pid: number, event: string, param: table): boolean`\nSends a remote event to a process.\n\n### Arguments\n1. `pid`: The PID of the process to send to\n2. `event`: The event name to send\n3. `param`: The parameter table to send with the event\n\n### Return Values\nWhether the event was sent\n\n## `register(name: string): boolean`\nRegisters the current process as the receiver of a service name.\n\n### Arguments\n1. `name`: The service name to register for\n\n### Return Values\nWhether the service was registered\n\n## `lookup(name: string): number|nil`\nReturns the ID of the process that receives a service name.\n\n### Arguments\n1. `name`: The service to lookup\n\n### Return Values\nThe PID of the process that owns it (if available)\n\n## `sendServiceEvent(name: string, event: string, param: table): boolean`\nSends an event to the owner of a service.\n\n### Arguments\n1. `name`: The service to send to\n2. `event`: The event name to send\n3. `param`: The parameter table to send with the event\n\n### Return Values\nWhether the event was sent\n\n## `receiveEvent(pid: number?, event: string?, timeout: number?): string, table / nil`\nWaits for a remote event, filtering for processes or event names, with an optional timeout.\n\n### Arguments\n1. `pid`: The PID to wait for an event from (optional)\n2. `event`: The event to filter for (optional)\n3. `timeout`: The maximum number of seconds to wait for (optional)\n\n### Return Values\nThis function may return the following values:\n1. The event name received\n2. The parameters for the event\n\nOr:\n1. If the function timed out\n\n## `signal`\nConstants for signal numbers\n\n### Fields\n- `SIGHUP`:\n- `SIGINT`:\n- `SIGQUIT`:\n- `SIGTRAP`:\n- `SIGABRT`:\n- `SIGKILL`:\n- `SIGPIPE`:\n- `SIGTERM`:\n- `SIGCONT`:\n- `SIGSTOP`:\n- `SIGTTIN`:\n- `SIGTTOU`:\n\n",created=1704748612249,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=2331},["system.pretty.md"]={modified=1704748612175,data="# system.pretty\nProvides a \"pretty printer\", for rendering data structures in an\naesthetically pleasing manner.\n\nIn order to display something using @{pretty}, you build up a series of\n@{Doc|documents}. These behave a little bit like strings; you can concatenate\nthem together and then print them to the screen.\n\nHowever, documents also allow you to control how they should be printed. There\nare several functions (such as @{nest} and @{group}) which allow you to control\nthe \"layout\" of the document. When you come to display the document, the 'best'\n(most compact) layout is used.\n\nThe structure of this module is based on [A Prettier Printer][prettier].\n\n[prettier]: https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf \"A Prettier Printer\"\n\n\n",created=1704748612251,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=760},["system.keys.md"]={modified=1704748612165,data="# system.keys\nThe keys module assigns names to the keycode constants that Phoenix sends in\n key events, and adds a few functions to make using them easier.  This module\n uses the same names as the CraftOS `keys` API, so porting programs should be\n trivial.\n\n\n## `getName(id: number): string|nil`\nReturns the name for the specified keycode.\n\n### Arguments\n1. `id`: The keycode to check\n\n### Return Values\nThe name (which is a key in `keys`), or `nil` if the code is invalid\n\n## `getCharacter(id: number): string|nil`\nReturns a printable representation of the keycode if available.\n\n### Arguments\n1. `id`: The keycode to check\n\n### Return Values\nThe keycode's character (in lowercase), or `nil` if the code doesn't have a printable representation\n\n",created=1704748612249,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=746},["system.serialization.md"]={modified=1704748612180,data="# system.serialization\nThe serialization module provides functions for serializing and deserializing\n objects in multiple formats, as well as some miscellaneous encoding types.\n\n# serialization.base64\n\n\n## `serialization.base64.encode(str: string): string`\nEncodes a binary string into Base64.\n\n### Arguments\n1. `str`: The string to encode\n\n### Return Values\nThe string's representation in Base64\n\n## `serialization.base64.decode(str: string): string`\nDecodes a Base64 string to binary.\n\n### Arguments\n1. `str`: The Base64 to decode\n\n### Return Values\nThe decoded data\n\n# serialization.json\n\n\n## `serialization.json.encode(val: any): string`\nSerializes an arbitrary Lua object into a JSON string.\n\n### Arguments\n1. `val`: The value to encode\n\n### Return Values\nThe JSON representation of the object\n\n## `serialization.json.decode(str: string): any`\nParses a JSON string and returns a Lua value represented by the string.\n\n### Arguments\n1. `str`: The JSON string to decode\n\n### Return Values\nThe Lua value from the JSON\n\n## `serialization.json.save(val: any, path: string)`\nSaves a Lua value to a JSON file.\n\n### Arguments\n1. `val`: The value to save\n2. `path`: The path to the file to save\n\n### Return Values\nThis function does not return anything.\n\n## `serialization.json.load(path: string): any`\nLoads a JSON file into a Lua value.\n\n### Arguments\n1. `path`: The path to the file to load\n\n### Return Values\nThe loaded value\n\n# serialization.lua\n\n\n## `serialization.lua.encode(val: any, opts: {minified=boolean,allow_functions=boolean}?): string`\nSerializes an arbitrary Lua object into a serialized Lua string.\n\n### Arguments\n1. `val`: The value to encode\n2. `opts`: Any options to specify while encoding (optional)\n\n### Return Values\nThe serialized Lua representation of the object\n\n## `serialization.lua.decode(str: string, opts: {allow_functions=boolean}?): any`\nParses a serialized Lua string and returns a Lua value represented by the string.\n\n### Arguments\n1. `str`: The serialized Lua string to decode\n2. `opts`: Any options to specify while decoding (optional)\n\n### Return Values\nThe Lua value from the serialized Lua\n\n## `serialization.lua.save(val: any, path: string, opts: {minified=boolean,allow_functions=boolean}?)`\nSaves a Lua value to a serialized Lua file.\n\n### Arguments\n1. `val`: The value to save\n2. `path`: The path to the file to save\n3. `opts`: Any options to specify while encoding (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `serialization.lua.load(path: string, opts: {allow_functions=boolean}?): any`\nLoads a serialized Lua file into a Lua value.\n\n### Arguments\n1. `path`: The path to the file to load\n2. `opts`: Any options to specify while decoding (optional)\n\n### Return Values\nThe loaded value\n\n",created=1704748612252,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=2757},["system.hardware.md"]={modified=1704748612159,data="# system.hardware\nThe hardware module implements functions for operating on peripherals and\n other hardware devices.\n\n## `wrap(device: string): device`\nWraps a device into an indexable object, allowing accessing properties and\n methods of the device by indexing the table.\n If an object is passed, this simply re-wraps the device in a new object.\n\n### Arguments\n1. `device`: The device specifier or object to wrap\n\n### Return Values\nThe wrapped device\n\n## `find(type: string): device...`\nReturns a list of wrapped devices that implement the specified type.\n\n### Arguments\n1. `type`: The type to search for\n\n### Return Values\nThe devices found, or `nil` if none were found\n\n## `path(device: string|device): string...`\nReturns a list of device paths that match the device specifier or object.\n If an absolute path is specified, this returns the same path back.\n If a device object is specified, this returns the path to the device.\n\n### Arguments\n1. `device`: The device specifier or object to read\n\n### Return Values\nThe paths that match the specifier or device object.\n\n## `hasType(device: string|device, type: string): boolean`\nReturns whether the device implements the specified type.\n\n### Arguments\n1. `device`: The device specifier or object to query\n2. `type`: The type to check for\n\n### Return Values\nWhether the device implements the type\n\n## `info(device: string|device): HWInfo|nil`\nReturns a table of information about the specified device.\n\n### Arguments\n1. `device`: The device specifier or object to query\n\n### Return Values\nThe hardware info table, or `nil` if no device was found\n\n## `methods(device: string|device): {string...}`\nReturns a list of methods implemented by this device.\n\n### Arguments\n1. `device`: The device specifier or object to query\n\n### Return Values\nThe methods available to call on this device\n\n## `properties(device: string|device): {string...}`\nReturns a list of properties implemented by this device.\n\n### Arguments\n1. `device`: The device specifier or object to query\n\n### Return Values\nThe properties available on this device\n\n## `children(device: string|device): {string...}`\nReturns a list of children of this device.\n\n### Arguments\n1. `device`: The device specifier or object to query\n\n### Return Values\nThe names of children of the device\n\n## `call(device: string|device, method: string, ...: any): any...`\nCalls a method on a device.\n\n### Arguments\n1. `device`: The device specifier or object to call on\n2. `method`: The method to call\n3. `...`: Any arguments to pass to the method\n\n### Return Values\nThe return values from the method\n\n## `listen(device: string|device[, state: boolean = true])`\nToggles whether this process should receive events from the device.\n\n### Arguments\n1. `device`: The device specifier or object to modify\n2. `state`: Whether to allow events (defaults to true)\n\n### Return Values\nThis function does not return anything.\n\n## `lock(device: string|device[, wait: boolean = true]): boolean`\nLocks the device from being called on or listened to by other processes.\n\n### Arguments\n1. `device`: The device specifier or object to modify\n2. `wait`: Whether to wait for the device to unlock if\n it's currently locked by another process (defaults to true)\n\n### Return Values\nWhether the current process now owns the lock\n\n## `unlock(device: string|device)`\nUnlocks the device after previously locking it.\n\n### Arguments\n1. `device`: The device specifier or object to modify\n\n### Return Values\nThis function does not return anything.\n\n## `tree`\nA table that allows accessing device object pointers in a tree.  This is\n simply syntax sugar for real paths.\n\n### Fields\nThis function does not take any arguments.\n\n",created=1704748612248,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=3673},["system.process.md"]={modified=1704748612177,data="# system.process\nThe process module allows querying various properties about the current\n process, as well as creating, modifying, and searching other processes.\n\n## `getpid(): number`\nReturns the process ID of the current process.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe process ID of the current process\n\n## `getppid(): number`\nReturns the process ID of the parent process, if available.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe process ID of the parent process, if available\n\n## `getuser(): string`\nReturns the username the process is running under.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe username the process is running under\n\n## `setuser(user: string)`\nSets the user of the current process.  This can only be run by root.\n\n### Arguments\n1. `user`: The user to switch to\n\n### Return Values\nThis function does not return anything.\n\n## `clock(): number`\nReturns the amount of time this process has executed.  This may not be\n entirely accurate due to a lack of precision in the system clock.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe amount of time this process has executed\n\n## `getenv(): table`\nReturns the environment table for the current process.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe environment table for the current process\n\n## `getname(): string`\nReturns the name of the current process.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe name of the current process\n\n## `getcwd(): string`\nReturns the working directory of the current process.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe working directory of the current process\n\n## `chdir(dir: string)`\nSets the working directory of the current process.\n\n### Arguments\n1. `dir`: The new working directory, which must be absolute and existent.\n\n### Return Values\nThis function does not return anything.\n\n## `fork(func: function, name: string, ...: any): number`\nCreates a new process running the specified function with arguments.\n\n### Arguments\n1. `func`: The function to run in the new process. This will be the\n main function of the first thread, and will have its environment set to the\n new process's environment.\n2. `name`: ? The name of the new process.\n3. `...`: Any arguments to pass to the function.\n\n### Return Values\nThe PID of the new process.\n\n## `exec(path: string, ...: any)`\nReplaces the current process with the contents of the specified file.\n This function does not return - it can only throw an error.\n\n### Arguments\n1. `path`: The path to the file to execute.\n2. `...`: Any arguments to pass to the file.\n\n### Return Values\nThis function does not return anything.\n\n## `execp(command: string, ...: any)`\nReplaces the current process with the contents of the specified file or\n command, searching the PATH environment variable if necessary.\n This function does not return - it can only throw an error.\n\n### Arguments\n1. `command`: The command or file to execute.\n2. `...`: Any arguments to pass to the file.\n\n### Return Values\nThis function does not return anything.\n\n## `start(path: string, ...: any): number`\nStarts a new process from the specified path.\n\n### Arguments\n1. `path`: The path to the file to execute.\n2. `...`: Any arguments to pass to the file.\n\n### Return Values\nThe PID of the new process.\n\n## `run(path: string, ...: any): true, any / false, string`\nRuns a program from the specified path in a new process, waiting until it completes.\n\n### Arguments\n1. `path`: The command or file to execute\n2. `...`: Any arguments to pass to the file\n\n### Return Values\nThis function may return the following values:\n1. When the process succeeded\n2. The return value from the process\n\nOr:\n1. When the process errored\n2. The error message from the process\n\n## `newthread(func: function, ...: any): number`\nCreates a new thread running the specified function with arguments.\n Threads in the same process share the same environment, event queue, and\n other properties.\n\n### Arguments\n1. `func`: The function to start\n2. `...`: Any arguments to pass to the function\n\n### Return Values\nThe ID of the new thread\n\n## `exit(code: number)`\nEnds the current process immediately, stopping all threads and sending the\n specified return value to the parent.  This function does not return.\n\n### Arguments\n1. `code`: ? The value to return.\n\n### Return Values\nThis function does not return anything.\n\n## `getplist(): table`\nReturns a list of all valid PIDs.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nA list of all valid PIDs\n\n## `getpinfo(pid: number): {id=number,name=string,user=string,parent?=number,dir=string,stdin?=number,stdout?=number,stderr?=number,cputime=number,systime=number,threads={[number]={id=number,name=string,status=string}}}|nil`\nReturns a table with various information about the specified process.\n\n### Arguments\n1. `pid`: The process ID to query.\n\n### Return Values\nThe process information, or nil if the process doesn't exist.\n\n",created=1704748612252,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=5130},["system.graphics.md"]={modified=1704748612156,data="# system.graphics\nThe graphics module provides functions to draw primitive geometry on a locked\n terminal object.  It supports both text and graphics mode terminals.\n The state of text terminals is preserved, so using these functions doesn't\n change the cursor position or colors.\n\n\n## `drawPixel(term: Terminal|GFXTerminal, x: number, y: number, color: number)`\nDraws a single pixel on screen.\n\n### Arguments\n1. `term`: The terminal to draw on\n2. `x`: The X coordinate to draw at\n3. `y`: The Y coordinate to draw at\n4. `color`: The color to draw with\n\n### Return Values\nThis function does not return anything.\n\n## `drawLine(term: Terminal|GFXTerminal, x1: number, y1: number, x2: number, y2: number, color: number)`\nDraws a line between two points.\n\n### Arguments\n1. `term`: The terminal to draw on\n2. `x1`: The start X coordinate to draw at\n3. `y1`: The start Y coordinate to draw at\n4. `x2`: The end X coordinate to draw at\n5. `y2`: The end Y coordinate to draw at\n6. `color`: The color to draw with\n\n### Return Values\nThis function does not return anything.\n\n## `drawBox(term: Terminal|GFXTerminal, x: number, y: number, width: number, height: number, color: number)`\nDraws an outlined rectangle on screen.\n\n### Arguments\n1. `term`: The terminal to draw on\n2. `x`: The upper-left X coordinate to draw at\n3. `y`: The upper-left Y coordinate to draw at\n4. `width`: The width of the rectangle\n5. `height`: The height of the rectangle\n6. `color`: The color to draw with\n\n### Return Values\nThis function does not return anything.\n\n## `drawFilledBox(term: Terminal|GFXTerminal, x: number, y: number, width: number, height: number, color: number)`\nDraws a filled rectangle on screen.\n\n### Arguments\n1. `term`: The terminal to draw on\n2. `x`: The upper-left X coordinate to draw at\n3. `y`: The upper-left Y coordinate to draw at\n4. `width`: The width of the rectangle\n5. `height`: The height of the rectangle\n6. `color`: The color to draw with\n\n### Return Values\nThis function does not return anything.\n\n## `drawCircle(term: Terminal|GFXTerminal, x: number, y: number, width: number, height: number, color: number[, startAngle: number = 0][, arcCircumference: number = 2*math.pi])`\nDraws an outlined circle (or arc) on screen.\n\n### Arguments\n1. `term`: The terminal to draw on\n2. `x`: The upper-left X coordinate to draw at\n3. `y`: The upper-left Y coordinate to draw at\n4. `width`: The width of the circle\n5. `height`: The height of the circle\n6. `color`: The color to draw with\n7. `startAngle`: The angle to start from in radians (starting at the right side) (defaults to 0)\n8. `arcCircumference`: The amount of the arc to draw in radians (defaults to 2*math.pi)\n\n### Return Values\nThis function does not return anything.\n\n## `drawFilledTriangle(term: Terminal|GFXTerminal, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, color: number)`\nDraws a filled triangle on screen.\n\n### Arguments\n1. `term`: The terminal to draw on\n2. `x1`: The first X coordinate to draw at\n3. `y1`: The first Y coordinate to draw at\n4. `x2`: The second X coordinate to draw at\n5. `y2`: The second Y coordinate to draw at\n6. `x3`: The third X coordinate to draw at\n7. `y3`: The third Y coordinate to draw at\n8. `color`: The color to draw with\n\n### Return Values\nThis function does not return anything.\n\n## `drawImage(term: Terminal|GFXTerminal, x: number, y: number, image: table)`\nDraws an image on screen.  The image may be either a valid graphics mode\n pixel region (using either string or table rows), or a blit table with\n {text, text color, background color} table rows (text mode only).\n\n### Arguments\n1. `term`: The terminal to draw on\n2. `x`: The X coordinate to draw at\n3. `y`: The Y coordinate to draw at\n4. `image`: The image to draw\n\n### Return Values\nThis function does not return anything.\n\n",created=1704748612247,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=3803},["usermgr.md"]={modified=1704748612994,data="",created=1704748613034,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=0},["system.util.md"]={modified=1704748612190,data="# system.util\nThe util module contains various functions that don't have any specific\n system function, or help improve the usability of the general system.\n\n## `argparse(arguments: {[string]=string|boolean|nil}, ...: string): {[string]=string|number|boolean|nil,string...} / nil, string`\nTakes a list of valid arguments + the arguments to a program, and returns a\n table with the extracted arguments (and values if requested).\n If an argument with all `-`s is passed, processing of arguments stops, and\n all subsequent arguments are added to the list.\n\n### Arguments\n1. `arguments`: A list of arguments that\n the program accepts. Single-character arguments are handled through `-a`, and\n longer arguments are handled through `--argument`. The value of the entry\n specifies how the argument is handled:\n * If the value is a truthy value, this argument requires a parameter.\n * If the value is `\"number\"`, the argument requires a number parameter.\n * If the value is `\"multiple\"`, the argument can be specified multiple times,\n   and will require a parameter. The values returned will be in a table.\n * If the value is `\"multiple number\"`, the argument can be specified multiple\n   times, and will require a number parameter. These are also in a table.\n * If the value is `false`, the argument does not take a parameter.\n * If the value is `nil`, the argument does not exist and will throw an error\n   if passed.\n * If the value starts with `@`, the parameter is an alias and will be stored\n   in that argument instead, following the same rules as that argument as well.\n Special parameters to the parser can be added in a `[\"\"]` table. The following\n parameters are specified:\n * `stopProcessingOnPositionalArgument` [boolean]: Whether to stop processing\n   arguments when a positional argument is passed, e.g. `myprog -s arg -i` will\n   return `args.s = true`, but `args.i = nil`.\n2. `...`: The arguments as passed to the program.\n\n### Return Values\nThis function may return the following values:\n1.  The arguments\n as parsed from the arguments table as key-value entries, plus positional\n arguments as list entries.\n\nOr:\n1. If the arguments passed are invalid.\n2. An error string describing what was invalid, which can be\n printed for the user.\n\n## `timer(time: number): number`\nStarts a timer that will run for the specified number of seconds.\n A timer event will be queued on completion.\n\n### Arguments\n1. `time`: The number of seconds to wait until sending the event\n\n### Return Values\nThe ID of the newly created timer\n\n## `alarm(time: number): number`\nStarts an alarm that will run until the specified time.\n A timer event will be queued on completion.\n\n### Arguments\n1. `time`: The time to send the event at\n\n### Return Values\nThe ID of the newly created alarm\n\n## `cancel(id: number)`\nCancels a timer or alarm.  This prevents the event from triggering.\n\n### Arguments\n1. `id`: The ID of the timer or alarm to cancel\n\n### Return Values\nThis function does not return anything.\n\n## `sleep(time: number)`\nPauses the process for a certain amount of time.\n\n### Arguments\n1. `time`: The amount of time to wait for, in seconds\n\n### Return Values\nThis function does not return anything.\n\n## `pullEvent(): string, table`\nReturns the next event from the event queue.  This is intended to make it more\n clear when events are being pulled, and also has the benefit of supporting\n libsystem-craftos better.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function may return the following values:\n1. The event pulled\n2. The parameters for the event\n\n## `filterEvent(...: string): string, table`\nWaits until an event of the specified type(s) occurs.\n\n### Arguments\n1. `...`: The event names to filter for\n\n### Return Values\nThis function may return the following values:\n1. The event type that was matched\n2. The parameters for the event\n\n## `queueEvent(event: string, param: table)`\nQueues an event to loop back to the process.\n\n### Arguments\n1. `event`: The event name to send\n2. `param`: The parameter table to send with the event\n\n### Return Values\nThis function does not return anything.\n\n## `split(str: string[, sep: string = \"%s\"][, includeEmpty: boolean = false]): {string...}`\nSplits a string into components.\n\n### Arguments\n1. `str`: The string to split\n2. `sep`: The delimiter match class to split by (defaults to \"%s\")\n3. `includeEmpty`: Whether to include empty matches (defaults to false)\n\n### Return Values\nThe components of the string\n\n## `copy(value: any): any`\nCopies a value recursively, including all its keys and values.\n\n### Arguments\n1. `value`: The value to copy\n\n### Return Values\nA copy of the value, with all keys, values, and metatables duplicated.\n\n## `addEventListener(event: string, callback: function(string,table):boolean)`\nAdds an event listener to the listening module.\n\n### Arguments\n1. `event`: The event to listen for\n2. `callback`: The function to call when\n the event is queued. If the function returns a truthy value, processing for\n the current event will stop. If the function throws an error, the loop will\n stop.\n\n### Return Values\nThis function does not return anything.\n\n## `removeEventListener(event: string, callback: function(string,table))`\nRemoves an event listener from the listening module.\n\n### Arguments\n1. `event`: The event to listen for\n2. `callback`: The function to remove\n\n### Return Values\nThis function does not return anything.\n\n## `runEvents(): string`\nRuns the event listening loop on the current thread, blocking forever.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe error that caused the function to stop\n\n## `startEvents(): number`\nRuns the event listening loop on a new thread, allowing code to run after.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe ID of the new thread\n\n## `type(value: any): string`\nReturns the type of the parameter, with the ability to check the __name\n metamethod for custom types.\n\n### Arguments\n1. `value`: The value to check\n\n### Return Values\nThe type of the value\n\n## `crc32(str: string[, polynomial: table|number = 0xEDB88320][, crc: number = 0xFFFFFFFF]): number`\nCalculates the CRC-32 checksum of the specified data.\n\n### Arguments\n1. `str`: The data to checksum\n2. `polynomial`: The polynomial for the CRC, or the lookup table to use (defaults to 0xEDB88320)\n3. `crc`: The initial CRC value (defaults to 0xFFFFFFFF)\n\n### Return Values\nThe calculated CRC checksum\n\n## `syscall`\nutil.syscall wraps all available syscalls into a table of functions, making\n it possible to call syscalls using direct function calls instead of manually\n yielding and managing the return values.\n\n### Fields\nThis function does not take any arguments.\n\n",created=1704748612255,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=6732},["system.sync.md"]={modified=1704748612183,data="# system.sync\nThe sync library exposes interfaces for various synchronization structures.\n\n# Class mutex\nA mutex is an object that controls access to a variable across multiple threads.\n It ensures only one thread accesses a resource at a time by blocking other\n threads from locking the mutex until the current thread unlocks it.\n\n## `sync.mutex.new(recursive: boolean?): mutex`\nCreates a new mutex.\n\n### Arguments\n1. `recursive`: Whether to make the mutex recursive (optional)\n\n### Return Values\nThe new mutex object\n\n## `sync.mutex:lock()`\nLocks the mutex, waiting if it's currently owned by another thread.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.mutex:unlock()`\nUnlocks the mutex.  This is only valid from the thread that owns the lock.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.mutex:tryLock(): boolean`\nTries to lock the thread, returning false if it could not be locked.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nWhether the mutex is now locked\n\n## `sync.mutex:tryLockFor(timeout: number): boolean`\nLocks the mutex, waiting until it's unlocked or until the specified timeout.\n\n### Arguments\n1. `timeout`: The number of seconds to wait\n\n### Return Values\nWhether the mutex is now locked\n\n# Class semaphore\nA semaphore controls access to a limited number of resources.  A function may\n acquire a resource from the semaphore, decrementing its available count. If\n the count is zero, it waits until another function releases a resource, at\n which point it will acquire it and return.\n\n## `sync.semaphore.new([init: number = 1]): semaphore`\nCreates a new semaphore.\n\n### Arguments\n1. `init`: The initial count of the semaphore (defaults to 1)\n\n### Return Values\nThe new semaphore object\n\n## `sync.semaphore:acquire()`\nAcquires a resource from the semaphore, waiting until there is one available.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.semaphore:tryAcquireFor(timeout: number): boolean`\nAcquires a resource from the semaphore, waiting until there is one available or until a timeout.\n\n### Arguments\n1. `timeout`: The number of seconds to wait\n\n### Return Values\nWhether the resource was acquired\n\n## `sync.semaphore:release()`\nReleases a resource to the semaphore.  This can be called from any thread.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n# Class conditionVariable\nA condition variable allows threads to wait until another thread notifies\n them to resume.\n\n## `sync.conditionVariable.new(): conditionVariable`\nCreates a new condition variable.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe new condition variable.\n\n## `sync.conditionVariable:wait()`\nWaits for a notification from another thread.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.conditionVariable:waitFor(timeout: number): boolean`\nWaits for a notification from another thread, or until a timeout occurs.\n\n### Arguments\n1. `timeout`: The number of seconds to wait\n\n### Return Values\nWhether a notification occurred\n\n## `sync.conditionVariable:notifyOne()`\nNotifies a single (unspecified) thread to continue.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.conditionVariable:notifyAll()`\nNotifies all waiting threads to continue.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n# Class barrier\nA barrier is a lock that waits for a specific number of threads to wait on\n the object, at which point all threads will be released together.\n\n## `sync.barrier.new(count: number): barrier`\nCreates a new barrier object.\n\n### Arguments\n1. `count`: The number of threads to wait for\n\n### Return Values\nA new barrier object\n\n## `sync.barrier:wait(): boolean`\nAdds one to the thread wait count, and waits until it meets the limit.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nWhether this call directly resulted in the barrier being met\n\n# Class rwlock\nA readers-writer lock implements two related locks: a read lock, which can\n be held by multiple threads, and a write lock, which can only be held by one\n thread.  Multiple threads can hold a read lock, but a write lock blocks both\n read and write locks.\n\n## `sync.rwLock.new(): rwlock`\nCreates a new RW lock.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe new RW lock\n\n## `sync.rwLock:lockRead()`\nAcquires the lock for reading, waiting for the write lock to be released first.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.rwLock:unlockRead()`\nReleases the lock for reading.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.rwLock:lockWrite()`\nAcquires the lock for writing, waiting for the read and write locks to be released.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `sync.rwLock:unlockWrite()`\nReleases the lock for writing.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function does not return anything.\n\n## `rwlock:lockGuard(mutex: mutex, fn: function, ...: any): any...`\nCalls a function, ensuring that the mutex is locked before calling and unlocked\n after calling, even if the function returns early or throws an error.\n\n### Arguments\n1. `mutex`: The mutex to lock\n2. `fn`: The function to call\n3. `...`: Any parameters to pass\n\n### Return Values\nThe return values from the function\n\n",created=1704748612253,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=5981},["system.framebuffer.md"]={modified=1704748612152,data="# system.framebuffer\nThe framebuffer library provides functions to make \"window\" and \"framebuffer\"\n objects.  These objects imitate a Terminal object (as returned by\n @{system.terminal.openterm}) or GFXTerminal object (as returned by\n @{system.terminal.opengfx}) that may or may not draw to a parent object.\n Windows and framebuffers may be used as parents to other windows and\n framebuffers, in addition to the root terminal object.\n\n A framebuffer object holds its own state, can be redrawn onto the parent\n terminal even if the parent is changed, can be removed from the parent and\n used independently, and its contents can be accessed from code. A window\n object simply changes the coordinates of writing methods, and is entirely\n dependent on the parent.\n\n The type of object returned by each function is dependent on the parent\n passed in. If a Terminal object is passed, a Terminal object is created; if a\n GFXTerminal object is passed, a GFXTerminal object is created. When creating\n a framebuffer with no parent, the @{empty} fields are used to specify the type.\n\n\n## `window(parent: Terminal|GFXTerminal, x: number, y: number, width: number, height: number): Terminal|GFXTerminal`\nCreates a new window object.\n\n### Arguments\n1. `parent`: The parent object to render to\n2. `x`: The X coordinate in the parent to start at\n3. `y`: The Y coordinate in the parent to start at\n4. `width`: The width of the window\n5. `height`: The height of the window\n\n### Return Values\nThe new window object\n\n## `framebuffer(parent: Terminal|GFXTerminal, wx: number|nil, wy: number|nil, w: number, h: number, visible: boolean?): Terminal|GFXTerminal`\nCreates a new framebuffer object.\n\n### Arguments\n1. `parent`: The parent object to render to, or a member of <a href=\"framebuffer.html#empty\">empty</a> to not use a parent\n2. `wx`: The X coordinate in the parent to start at (`nil` if there's no parent)\n3. `wy`: The Y coordinate in the parent to start at (`nil` if there's no parent)\n4. `w`: The width of the framebuffer\n5. `h`: The height of the framebuffer\n6. `visible`: Whether the window should be visible upon creation (optional)\n\n### Return Values\nThe new framebuffer object\n\n## `empty`\nEmpty objects for use when creating framebuffers with no parents.\n\n### Fields\n- `text`: Used to create a text mode Terminal framebuffer\n- `graphics`: Used to create a graphics mode GFXTerminal framebuffer\n\n",created=1704748612247,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=2388},["ftp.md"]={modified=1704748610966,data="",created=1704748610984,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=0},["system.filesystem.md"]={modified=1704748612148,data="# system.filesystem\nThe filesystem module implements common operations for working with the\n filesystem, including wrappers for syscalls.\n\n## `open(path: string, mode: string): FileHandle / nil, string`\nOpens a file for reading or writing.\n\n### Arguments\n1. `path`: The path to the file to open\n2. `mode`: The mode to open the file in: [rwa]b?\n\n### Return Values\nThis function may return the following values:\n1. The file handle, which has the same functions as CraftOS file handles\n\nOr:\n1. If the file could not be opened\n2. An error message describing why the file couldn't be opened\n\n## `list(path: string): table`\nReturns a list of files in a directory.\n\n### Arguments\n1. `path`: The path to query\n\n### Return Values\nA list of files and folders in the directory\n\n## `stat(path: string[, nolink: boolean = false]): FileStat`\nReturns a table with various information about a file or directory.\n\n### Arguments\n1. `path`: The path to query\n2. `nolink`: Whether to not resolve links to the file (defaults to false)\n\n### Return Values\nA table with information about the path\n\n## `remove(path: string)`\nDeletes a file or directory at a path, removing any subentries if present.\n\n### Arguments\n1. `path`: The path to remove\n\n### Return Values\nThis function does not return anything.\n\n## `rename(from: string, to: string)`\nMoves a file or directory on the same filesystem.\n\n### Arguments\n1. `from`: The original file to move\n2. `to`: The new path for the file\n\n### Return Values\nThis function does not return anything.\n\n## `mkdir(path: string)`\nCreates a directory, making any parent paths that don't exist.\n\n### Arguments\n1. `path`: The directory to create\n\n### Return Values\nThis function does not return anything.\n\n## `link(path: string, location: string)`\nCreates a (symbolic) link to a file.\n\n### Arguments\n1. `path`: The path of the new link\n2. `location`: The location to point the link to\n\n### Return Values\nThis function does not return anything.\n\n## `mkfifo(path: string)`\nCreates a FIFO.\n\n### Arguments\n1. `path`: The FIFO to create\n\n### Return Values\nThis function does not return anything.\n\n## `chmod(path: string, user: string|nil, mode: number|string|{read?=boolean,write?=boolean,execute?=boolean})`\nChanges the permissions (mode) of the file at a path.\n\n### Arguments\n1. `path`: The path to modify\n2. `user`: The user to modify, or nil to modify world permissions\n3. `mode`: The new permissions, as either an octal bitmask, a string in the format \"[+-=][rwx]+\" or \"[r-][w-][x-]\", or a table with the permissions to set (any `nil` arguments are left unset).\n\n### Return Values\nThis function does not return anything.\n\n## `chown(path: string, user: string)`\nChanges the owner of a file or directory.\n\n### Arguments\n1. `path`: The path to modify\n2. `user`: The new owner of the file\n\n### Return Values\nThis function does not return anything.\n\n## `chroot(path: string)`\nChanges the root directory of the current and future child processes.\n This function requires root.\n\n### Arguments\n1. `path`: The new root path to change to\n\n### Return Values\nThis function does not return anything.\n\n## `mount(type: string, src: string, dest: string, options: table?)`\nMounts a filesystem of the specified type to a directory.\n\n### Arguments\n1. `type`: The type of filesystem to mount\n2. `src`: The source of the mount (depends on the FS type)\n3. `dest`: The destination directory to mount to\n4. `options`: A table of options to pass to the filesystem (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `unmount(path: string)`\nUnmounts a mounted filesystem.\n\n### Arguments\n1. `path`: The filesystem to unmount\n\n### Return Values\nThis function does not return anything.\n\n## `mountlist(): [{path:string,type:string,source:string,options:table}]`\nReturns a list of mounts currently available.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nA list of mounts and their properties.\n\n## `combine(...: string): string`\nCombines the specified path components into a single path, canonicalizing any links and ./..  paths.\n\n### Arguments\n1. `...`: The path components to combine\n\n### Return Values\nThe combined and canonicalized path\n\n## `copy(from: string, to: string, preserve: boolean?)`\nCopies a file or directory.\n\n### Arguments\n1. `from`: The path to copy from\n2. `to`: The path to copy to\n3. `preserve`: Whether to preserve permissions when copying (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `move(from: string, to: string)`\nMoves a file or directory, allowing cross-filesystem operations.\n\n### Arguments\n1. `from`: The path to move from\n2. `to`: The path to move to\n\n### Return Values\nThis function does not return anything.\n\n## `basename(path: string): string`\nReturns the file name for a path.\n\n### Arguments\n1. `path`: The path to use\n\n### Return Values\nThe file name of the path\n\n## `dirname(path: string): string`\nReturns the parent directory for a path.\n\n### Arguments\n1. `path`: The path to use\n\n### Return Values\nThe parent directory of the path\n\n## `find(wildcard: string): table`\nSearches the filesystem for paths matching a glob-style wildcard.\n\n### Arguments\n1. `wildcard`: The pathspec to match\n\n### Return Values\nA list of matching file paths\n\n## `exists(path: string): boolean`\nConvenience function for determining whether a file exists.\n This simply checks that @{stat} does not return `nil`.\n\n### Arguments\n1. `path`: The path to check\n\n### Return Values\nWhether the path exists\n\n## `isFile(path: string): boolean`\nReturns whether the path exists and is a file.\n\n### Arguments\n1. `path`: The path to check\n\n### Return Values\nWhether the path is a file\n\n## `isDir(path: string): boolean`\nReturns whether the path exists and is a directory.\n\n### Arguments\n1. `path`: The path to check\n\n### Return Values\nWhether the path is a directory\n\n## `isLink(path: string): boolean`\nReturns whether the path exists and is a link.\n\n### Arguments\n1. `path`: The path to check\n\n### Return Values\nWhether the path is a link\n\n## `effectivePermissions(file: string|FileStat, user: string?): {read:boolean,write:boolean,execute:boolean}|nil`\nReturns the effective permissions on a file or stat entry for the selected user.\n\n### Arguments\n1. `file`: The file path or stat to check\n2. `user`: The user to check for (defaults to the current user) (optional)\n\n### Return Values\nThe permissions for the user, or `nil` if the file doesn't exist\n\n# Class FileStat\nA table which stores file statistics.\n\n## `FileStat.type`\nStores the type of file: one of \"file\", \"directory\", \"link\", \"special\"\n\n### Fields\nThis function does not take any arguments.\n\n## `FileStat.size`\nThe size of the file\n\n### Fields\nThis function does not take any arguments.\n\n## `FileStat.created`\nThe creation date of the file, in milliseconds since January 1, 1970\n\n### Fields\nThis function does not take any arguments.\n\n## `FileStat.modified`\nThe modification date of the file, in milliseconds since January 1, 1970\n\n### Fields\nThis function does not take any arguments.\n\n## `FileStat.owner`\nThe owner of the file\n\n### Fields\nThis function does not take any arguments.\n\n## `FileStat.permissions`\nThe permissions of the file for each user, indexed by user name\n\n### Fields\n- `read`: Whether the file can be read\n- `write`: Whether the file can be written to\n- `execute`: Whether the file can be executed\n\n## `FileStat.worldPermissions`\nThe permissions of the file for all users not in @{FileStat.permissions}\n\n### Fields\n- `read`: Whether the file can be read\n- `write`: Whether the file can be written to\n- `execute`: Whether the file can be executed\n\n## `FileStat.special`\nAny additional data from the filesystem\n\n",created=1704748612246,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=7653},["system.log.md"]={modified=1704748612168,data="# system.log\nThe log module exposes functions for interacting with the logging subsystem.\n The default system log is available under the root `log` table. Other logs\n created through @{log.create} can be accessed by indexing the `log` table with\n the name of the log, e.g. `log.mylog.info(\"hello\")`. Both the main and\n subtables may also be called directly, e.g. `log(\"test\")` or `log.mylog(\"hello\")`.\n\n\n## `log(options: table?, ...: any)`\nWrites a message to the log.\n\n### Arguments\n1. `options`: A table of options to supply. See the documentation\n for the syslog syscall for more information. (optional)\n2. `...`: The values to print to the log, which will be concatenated as\n strings with \\t.\n\n### Return Values\nThis function does not return anything.\n\n## `debug(options: table?, ...: any)`\nWrites a debug message to the log.\n\n### Arguments\n1. `options`: A table of options to supply. See the documentation\n for the syslog syscall for more information. (optional)\n2. `...`: The values to print to the log, which will be concatenated as\n strings with \\t.\n\n### Return Values\nThis function does not return anything.\n\n## `info(options: table?, ...: any)`\nWrites an info message to the log.\n\n### Arguments\n1. `options`: A table of options to supply. See the documentation\n for the syslog syscall for more information. (optional)\n2. `...`: The values to print to the log, which will be concatenated as\n strings with \\t.\n\n### Return Values\nThis function does not return anything.\n\n## `notice(options: table?, ...: any)`\nWrites a notice message to the log.\n\n### Arguments\n1. `options`: A table of options to supply. See the documentation\n for the syslog syscall for more information. (optional)\n2. `...`: The values to print to the log, which will be concatenated as\n strings with \\t.\n\n### Return Values\nThis function does not return anything.\n\n## `warning(options: table?, ...: any)`\nWrites a warning message to the log.\n\n### Arguments\n1. `options`: A table of options to supply. See the documentation\n for the syslog syscall for more information. (optional)\n2. `...`: The values to print to the log, which will be concatenated as\n strings with \\t.\n\n### Return Values\nThis function does not return anything.\n\n## `error(options: table?, ...: any)`\nWrites an error message to the log.\n\n### Arguments\n1. `options`: A table of options to supply. See the documentation\n for the syslog syscall for more information. (optional)\n2. `...`: The values to print to the log, which will be concatenated as\n strings with \\t.\n\n### Return Values\nThis function does not return anything.\n\n## `critical(options: table?, ...: any)`\nWrites a critical error message to the log.\n\n### Arguments\n1. `options`: A table of options to supply. See the documentation\n for the syslog syscall for more information. (optional)\n2. `...`: The values to print to the log, which will be concatenated as\n strings with \\t.\n\n### Return Values\nThis function does not return anything.\n\n## `traceback(message: string?)`\nWrites a traceback error message to the log.\n\n### Arguments\n1. `message`: A message to attach to the traceback (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `create(name: string, streamed: boolean?, file: string?): table`\nCreates a new log.\n\n### Arguments\n1. `name`: The name of the log to create\n2. `streamed`: Whether to make the log available for streaming (optional)\n3. `file`: The path to the file to write the log to (optional)\n\n### Return Values\nA logger object from `log.*`\n\n## `remove(name: string)`\nRemoves a previously created log.\n\n### Arguments\n1. `name`: The log to remove\n\n### Return Values\nThis function does not return anything.\n\n## `open(name: string, filter: string?): number`\nOpens a log for listening to messages.\n\n### Arguments\n1. `name`: The name of the log to listen to\n2. `filter`: A filter command to filter messages with (see the\n openlog syscall docs for more info) (optional)\n\n### Return Values\nAn ID to identify the logged messages with\n\n## `close(name: string|number)`\nCloses a log or stream for listening.\n\n### Arguments\n1. `name`: The log name to close (closes all streams), or an\n ID returned by <a href=\"log.html#open\">log.open</a>.\n\n### Return Values\nThis function does not return anything.\n\n## `setTTY(name: string, tty: TTY|nil, level: number?)`\nSets the TTY to output a log to.  (Requires root)\n\n### Arguments\n1. `name`: The log to set the TTY of\n2. `tty`: The TTY to use, or `nil` to disable\n3. `level`: The minimum log level to show messages (optional)\n\n### Return Values\nThis function does not return anything.\n\n## `levels`\nConstants for log levels.\n\n### Fields\n- `debug`:\n- `info`:\n- `notice`:\n- `warning`:\n- `error`:\n- `critical`:\n\n",created=1704748612250,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=4678},["system.network.md"]={modified=1704748612171,data="# system.network\nThe network module implements functions for making and hosting connections\n with local and Internet-connected computers, as well as managing the network\n stack configuration.\n\n## `connect(options: string|table): Handle`\nCreates a new connection to a remote server.\n\n### Arguments\n1. `options`: The URI to connect with, or a table of options\n (see the connect syscall docs for more information)\n\n### Return Values\nA handle to the connection\n\n## `get(options: string|table): Handle / nil, string`\nConnects to an HTTP(S) server, sends a GET request and waits for a response.\n\n### Arguments\n1. `options`: The URL to connect to, or a table of options\n (see the connect syscall docs for more information)\n\n### Return Values\nThis function may return the following values:\n1. The handle to the response data\n\nOr:\n1. If the connection failed\n2. An error describing why the connection failed\n\n## `getData(url: string, headers: table?): string / nil, string`\nConnects to an HTTP(S) server, sends a GET request, waits for a response,\n and returns the data received after closing the connection.\n\n### Arguments\n1. `url`: The URL to connect to\n2. `headers`: Any headers to send in the request (optional)\n\n### Return Values\nThis function may return the following values:\n1. The response data sent from the server\n\nOr:\n1. If the connection failed\n2. An error describing why the connection failed\n\n## `head(options: string|table): Handle / nil, string`\nConnects to an HTTP(S) server, sends a HEAD request and waits for a response.\n\n### Arguments\n1. `options`: The URL to connect to, or a table of options\n (see the connect syscall docs for more information)\n\n### Return Values\nThis function may return the following values:\n1. The handle to the response data\n\nOr:\n1. If the connection failed\n2. An error describing why the connection failed\n\n## `options(options: string|table): Handle / nil, string`\nConnects to an HTTP(S) server, sends an OPTIONS request and waits for a response.\n\n### Arguments\n1. `options`: The URL to connect to, or a table of options\n (see the connect syscall docs for more information)\n\n### Return Values\nThis function may return the following values:\n1. The handle to the response data\n\nOr:\n1. If the connection failed\n2. An error describing why the connection failed\n\n## `post(options: string|table, data: string): Handle / nil, string`\nConnects to an HTTP(S) server, sends a POST request and waits for a response.\n\n### Arguments\n1. `options`: The URL to connect to, or a table of options\n (see the connect syscall docs for more information)\n2. `data`: The data to send to the server\n\n### Return Values\nThis function may return the following values:\n1. The handle to the response data\n\nOr:\n1. If the connection failed\n2. An error describing why the connection failed\n\n## `put(options: string|table, data: string): Handle / nil, string`\nConnects to an HTTP(S) server, sends a PUT request and waits for a response.\n\n### Arguments\n1. `options`: The URL to connect to, or a table of options\n (see the connect syscall docs for more information)\n2. `data`: The data to send to the server\n\n### Return Values\nThis function may return the following values:\n1. The handle to the response data\n\nOr:\n1. If the connection failed\n2. An error describing why the connection failed\n\n## `delete(options: string|table, data: string?): Handle / nil, string`\nConnects to an HTTP(S) server, sends a DELETE request and waits for a response.\n\n### Arguments\n1. `options`: The URL to connect to, or a table of options\n (see the connect syscall docs for more information)\n2. `data`: The data to send to the server, if required (optional)\n\n### Return Values\nThis function may return the following values:\n1. The handle to the response data\n\nOr:\n1. If the connection failed\n2. An error describing why the connection failed\n\n",created=1704748612251,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=3820},["system.terminal.md"]={modified=1704748612187,data="# system.terminal\nThe terminal module defines functions to allow interacting with the terminal\n and screen, as well as handling user input.\n\n## `toEscape(color: number[, background: boolean = false]): string`\nConverts a @{terminal.colors} constant to an ANSI escape code.\n\n### Arguments\n1. `color`: The color to convert\n2. `background`: Whether the escape should set the background (defaults to false)\n\n### Return Values\nThe escape code generated for the color\n\n## `write(...)`\nWrites text to the standard output stream.\n\n### Arguments\n1. `...`: The entries to write. Each one will be separated by tabs (`\\t`).\n\n### Return Values\nThis function does not return anything.\n\n## `writeerr(...)`\nWrites text to the standard error stream.\n\n### Arguments\n1. `...`: The entries to write. Each one will be separated by tabs (`\\t`).\n\n### Return Values\nThis function does not return anything.\n\n## `read(n: number): string|nil`\nReads a number of characters from the standard input stream.\n\n### Arguments\n1. `n`: The number of characters to read\n\n### Return Values\nThe text read, or nil if EOF was reached.\n\n## `readline(): string|nil`\nReads a single line of text from the standard input stream.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThe text read, or nil if EOF was reached.\n\n## `termctl(flags: {cbreak?=boolean,delay?=boolean,echo?=boolean,keypad?=boolean,nlcr?=boolean,raw?=boolean}): {cbreak=boolean,delay=boolean,echo=boolean,keypad=boolean,nlcr=boolean,raw=boolean}|nil`\nSets certain terminal control flags on the current TTY if available.\n\n### Arguments\n1. `flags`: ? The flags to set, or nil to just query.\n\n### Return Values\nThe flags that are currently set on the TTY, or nil if no TTY is available.\n\n## `openterm(): Terminal / nil, string`\nOpens the current output TTY in exclusive text mode, allowing direct\n manipulation of the screen buffer.  Only one process may open the terminal at\n a time. Once opened, the screen will be cleared, and stdout will be sent to\n an off-screen buffer to be shown once the terminal is closed. The terminal\n will automatically be closed on process exit.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function may return the following values:\n1. A terminal object for the current TTY.\n\nOr:\n1. If the terminal could not be opened.\n2. An error message describing why the terminal couldn't be opened.\n\n## `opengfx(): GFXTerminal / nil, string`\nOpens the current output TTY in exclusive graphics mode, allowing direct\n manipulation of the pixels if available.  Only one process may open the terminal\n at a time. Once opened, the screen will be cleared, and stdout will be sent to\n an off-screen buffer to be shown once the terminal is closed. The terminal\n will automatically be closed on process exit. This only works on CraftOS-PC.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function may return the following values:\n1. A graphical terminal object for the current TTY.\n\nOr:\n1. If the terminal could not be opened.\n2. An error message describing why the terminal couldn't be opened.\n\n## `mktty(width: number, height: number): TTY`\nCreates a new virtual TTY with the specified size.  This can later be used in\n a call to stdin/stdout/stderr.\n\n### Arguments\n1. `width`: The width of the new TTY.\n2. `height`: The height of the new TTY.\n\n### Return Values\nA new TTY object which is registered with the kernel.\n\n## `stdin(handle: number|TTY|FileHandle|nil)`\nSets the standard input of the current process.\n\n### Arguments\n1. `handle`: The input handle to switch to, as\n either a physical TTY, a virtual TTY, a file, or nil.\n\n### Return Values\nThis function does not return anything.\n\n## `stdout(handle: number|TTY|FileHandle|nil)`\nSets the standard output of the current process.\n\n### Arguments\n1. `handle`: The output handle to switch to, as\n either a physical TTY, a virtual TTY, a file, or nil.\n\n### Return Values\nThis function does not return anything.\n\n## `stderr(handle: number|TTY|FileHandle|nil)`\nSets the standard error of the current process.\n\n### Arguments\n1. `handle`: The output handle to switch to, as\n either a physical TTY, a virtual TTY, a file, or nil.\n\n### Return Values\nThis function does not return anything.\n\n## `istty(): boolean, boolean`\nReturns whether the current stdio are linked to a TTY.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function may return the following values:\n1. Whether the current stdin is linked to a TTY.\n2. Whether the current stdout is linked to a TTY.\n\n## `termsize(): number, number / nil`\nReturns the current size of the TTY if available.\n\n### Arguments\nThis function does not take any arguments.\n\n### Return Values\nThis function may return the following values:\n1. The width of the screen.\n2. The height of the screen.\n\nOr:\n1. If the current stdout is not a screen.\n\n## `colors`\nConstants for colors.  This includes both normal and British spelling.\n\n### Fields\n- `white`:\n- `orange`:\n- `magenta`:\n- `lightBlue`:\n- `yellow`:\n- `lime`:\n- `pink`:\n- `gray`:\n- `grey`:\n- `lightGray`:\n- `lightGrey`:\n- `cyan`:\n- `purple`:\n- `blue`:\n- `brown`:\n- `green`:\n- `red`:\n- `black`:\n\n",created=1704748612254,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=5197}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},man8={modified=1704748613038,created=1704748613038,contents={["userdel.md"]={modified=1704748613012,data="",created=1704748613037,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=0},["update.md"]={modified=1704748610863,data="",created=1704748610877,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=0},["ftpmgr.md"]={modified=1704748610976,data="",created=1704748610986,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=0},["spaninfo.md"]={modified=1704748612569,data="<summary>shows information about a span</summary>\n# NAME\n    spaninfo - shows information about a span\n\n# SYNOPSIS\n    **spaninfo** *mount path*\n\n# DESCRIPTION\n**spaninfo** shows various information about a mounted span, including UUID, name,\ncapacity, free space, and space info on individual disks.\n\n# HISTORY\nIntroduced in spanfs 0.1.\n",created=1704748612578,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=338},["usermod.md"]={modified=1704748613018,data="",created=1704748613038,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=0},["update-initrd.md"]={modified=1704748611121,data="",created=1704748611131,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=0},["usermgr.md"]={modified=1704748613015,data="",created=1704748613038,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=0},["dpkg.md"]={modified=1704748610858,data="",created=1704748610876,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=0},["mkspanfs.md"]={modified=1704748612563,data="<summary>Create and format new spanfs disks</summary>\n# NAME\nmkspanfs - Create and format new spanfs disks\n\n# SYNOPSIS\n**mkspanfs** *volume name* *index drive* *data drive* ...\n\n# DESCRIPTION\n**mkspanfs** creates a new *spanfs* filesystem across the drives specified,\nusing the volume name given as the first argument to name the volume. The command\nwill first verify that all drives provided are valid, and prompts the user to\nconfirm that these drives are correct. Once confirmed, all disks are erased and\nformatted with a new *spanfs* filesystem with the specified name and a random\nUUID. After creation, the disk usage stats are reported.\n\n# EXAMPLE\nCreate a new volume named *Span Volume* on four disks, using `drive_0` to store\nthe index.\n\n`mkspanfs \"Span Volume\" drive_0 drive_1 drive_2 drive_3`\n\n# SEE ALSO\n**spanfs**(7)",created=1704748612577,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=828},["useradd.md"]={modified=1704748613009,data="",created=1704748613036,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=0},["spanadd.md"]={modified=1704748612566,data="<summary>add drives to an existing span</summary>\n# NAME\n    spanadd - add drives to an existing span\n\n# SYNOPSIS\n    **spanadd** *mount point* *drives ...*\n\n# DESCRIPTION\n**spanadd** adds one or more disk drives to an existing span filesystem. This\nallows effectively resizing the span.\n\nThe first argument points to the span to resize. The span must be mounted to be\nable to add drives.\n\nEach remaining argument is the device name of the drive to add. This can be a\ndevice ID, UUID, or path, as would be used with hardware APIs. **The disk in the drives will be erased.**\n\nThe filesystem must be remounted for the changes to take effect.\n\n# HISTORY\nIntroduced in spanfs 0.1.\n\n# SEE ALSO\n**mkspanfs**(8)\n",created=1704748612578,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=705},["components.md"]={modified=1704748610856,data="",created=1704748610876,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=0}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},man2={modified=1704748612245,created=1704748612245,contents={["devchildren.md"]={modified=1704748612002,data="<summary>returns a list of names of all children of the current device</summary>\n# NAME\ndevchildren - returns a list of names of all children of the current device\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\ndevchildren(device: string): string[]\n\n# DESCRIPTION\nReturns a list of names of all children of the current device.\n\n# PARAMETERS\n1. `device`: The device path or UUID to look up\n\n# RETURN VALUE\nA list of child names, in an unspecified order. This table may be empty.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612212,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=653},["_template.md"]={modified=1704748611950,data="<summary></summary>\n# NAME\n - \n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n\n\n# DESCRIPTION\n\n\n# PARAMETERS\n\n\n# RETURN VALUE\n\n\n# ERRORS\n\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n\n",created=1704748612201,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=239},["list.md"]={modified=1704748612040,data="<summary>returns a list of file names present in a directory</summary>\n# NAME\nlist - returns a list of file names present in a directory\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**list**(*path*: string): string[]\n\n# DESCRIPTION\nReturns a list of file names present in a directory.\n\n# PARAMETERS\n1. `path`: The path to the directory to list.\n\n# RETURN VALUE\nA list of file names. This may or may not be sorted.\n\n# ERRORS\nThis syscall may throw an error if:\n* The path does not exist.\n* The path is not directory.\n* The current user does not have permission to access the directory.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612219,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=681},["version.md"]={modified=1704748612140,data="<summary>returns the Phoenix version or build number</summary>\n# NAME\nversion - returns the Phoenix version or build number\n\n# SYNOPSIS\n**version**(*buildnum*: boolean?): string\n\n# DESCRIPTION\nReturns the Phoenix version or build number.\n\n# PARAMETERS\n1. `buildnum`: `true` to return the minor build string/information, `false` to return the version number\n\n# RETURN VALUE\nThe version number of the current Phoenix kernel.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**cchost**(2)\n",created=1704748612245,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=539},["uptime.md"]={modified=1704748612135,data="<summary>returns the amount of time the computer has been running</summary>\n# NAME\nuptime - returns the amount of time the computer has been running\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**uptime**(): number\n\n# DESCRIPTION\nReturns the amount of time the computer has been running.\n\n# PARAMETERS\nThis syscall does not take any arguments.\n\n# RETURN VALUE\nThe amount of time the computer has been running in seconds.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612244,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=563},["devproperties.md"]={modified=1704748612023,data="<summary>returns a list of properties on the device</summary>\n# NAME\ndevproperties - returns a list of properties on the device\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devproperties**(*device*: string): string[]\n\n# DESCRIPTION\nReturns a list of properties on the device.\n\nProperties are intended for use by wrapper APIs (such as `libsystem.hardware`), and specify an alternate name for a corresponding `get<Property>` method. To retrieve the property, capitalize the first character of the property name, prepend `get` to the name, and call that method on the device with no arguments. To set the property, first check for a `set<Property>` method in the same format as `get`, then call that method with one argument (the new value). If no `set` method is available, then that property is read-only.\n\n# PARAMETERS\n1. `device`: The device path or UUID to look up\n\n# RETURN VALUE\nA list of properties that are available. This table may be empty.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612216,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1128},["cchost.md"]={modified=1704748611973,data="<summary>returns the value of the _HOST variable</summary>\n# NAME\ncchost - returns the value of the _HOST variable\n\n# SYNOPSIS\n**cchost**(): string\n\n# DESCRIPTION\nReturns the value of the `_HOST` variable.\n\n# PARAMETERS\nThis syscall does not take any arguments.\n\n# RETURN VALUE\nThe value of `_HOST`, which is in the format `ComputerCraft [0-9%.]+ %b()`.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**version**(2)\n",created=1704748612206,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=471},["connect.md"]={modified=1704748611990,data="<summary>creates a connection to a remote resource</summary>\n# NAME\nconnect - creates a connection to a remote resource\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**connect**(*options*: table|string): Handle?\n\n# DESCRIPTION\nCreates a connection to a remote resource using the specified options table or URI.\n\n# PARAMETERS\n1. `options`: Either a string with a URI (no options), or a table with any of the following elements:\n  * `url: string`: The URI to connect to (required)\n  * `encoding: \"utf8\" | \"utf-8\" | \"binary\"`: HTTP/WS: Encoding to use when transferring data (defaults to `\"binary\"`)\n  * `headers: {[string] = string}`: HTTP/WS: Any headers to send in the request\n  * `method: string`: HTTP: The method to use when connecting (defaults to `\"GET\"`)\n  * `redirect: boolean`: HTTP: Whether to automatically redirect responses that indicate a redirect (defaults to `true`)\n  * `device: string`: Rednet/PSP: The path to the device to use to establish the connection (usually a modem), or `nil` to use all modems (note: if this path points to multiple devices, all are used)\n\n# RETURN VALUE\nA handle object that can be used to send/receive data, or `nil` + an error if the handle could not be created. The handle is not guaranteed to be ready to send/receive data immediately, however, so the `status` method should be checked before using.\n\n# ERRORS\nThis syscall may throw an error if:\n* The URI specified is malformed.\n* The scheme in the URI is not supported.\n* The device is not present.\n* The device is not a valid modem.\n\n# NOTES\nThe **connect** syscall returns a handle object for the specific protocol that was requested. These handles all contain a common set of methods, as well as some special methods that are specific to each protocol.\n\nAll handles have an `id` field, which is a number that uniquely identifies the connection. This ID is used in `handle_status_change` events to indicate which handle has changed status.\n\n`status(): \"ready\"|\"connecting\"|\"error\"|\"open\"|\"closed\", string?`  \nReturns the current status of the handle/connection.\n\n*Arguments*  \nThis method does not take any arguments.\n\n*Return Values*  \nThe current status of the handle/connection. These are the currently assigned statuses:\n* `ready`: Indicates the handle is ready to send data, but a connection has not yet been established.\n* `connecting`: Indicates the handle sent a connection request, and is currently awaiting a response. The handle is not ready to send or receive data.\n* `error`: Indicates an error has occurred while connecting to the server, and no data has been sent or received. This handle may no longer be used. More information may be supplied in a second return value.\n* `open`: Indicates the connection has been established, and data can be received (and possibly sent).\n* `closed`: Indicates the connection has been closed, and no data may be sent or received. This handle may no longer be used.\n\n*Errors*  \nThis method does not throw any errors.\n\n`read(mode...: string|number): string|number|nil...`  \nRead one or more values from the connection in a manner similar to `io.file:read`.\n\n*Arguments*  \n1. `mode...`: The read mode to use. This may be one of the following options:\n  * `*a`: Read all data available in the connection.\n  * `*l`: Read a line, excluding the final newline.\n  * `*L`: Read a line, including the final newline.\n  * `*n`: Read a number value if available.\n  * (any number): Read the specified number of characters/bytes.\n  If no arguments are specified, this defaults to `read(\"*l\")`.\n\n*Return Values*  \nThe values extracted from the connection. If one of the modes could not be read, the value returned for that parameter and all ones after are `nil`.\n\n*Errors*  \nThis method may throw an error if:\n* The handle is not currently open.\n\n`write(data...: any)`  \nWrites the supplied values to the connection.\n\n*Arguments*  \n1. `data...`: The values to write. Values that are not strings will be converted with `tostring`, unless otherwise specified by the handle type.\n\n*Return Values*  \nThis method does not return anything.\n\n*Errors*  \nThis method may throw an error if:\n* The handle is not currently open or ready.\n\n`close()`  \nCloses the connection.\n\n*Arguments*  \nThis method does not take any arguments.\n\n*Return Values*  \nThis method does not return anything.\n\n*Errors*  \nThis method may throw an error if:\n* The connection is not currently open.\n\n## HTTP handles\nHTTP\\[S\\] handles have a special flow to work properly. Upon creating the handle, it will be set in the `ready` state, and no request is sent yet. The request is only sent once the `write` method is called once. After that, the `write` method will no longer function, so make sure to add all data in the request in that `write` call. Even if no data needs to be sent (e.g. `GET` method), `write` must be called exactly once, even if it's with no data.\n\nAfter calling `write`, the handle will shift into `connecting` status, awaiting a response from the server. The client must wait for `status` to change to `open` before attempting to read data. After that, the handle functions like a normal read-only handle.\n\nHTTP handles have the following additional methods:\n\n`responseHeaders(): {[string]: string}`  \nReturns the headers contained in the response.\n\n*Arguments*  \nThis method does not take any arguments.\n\n*Return Values*  \nA key-value table of headers sent back from the server.\n\n*Errors*  \nThis method may throw an error if:\n* The connection is not currently open.\n\n`responseCode(): number`  \nReturns the HTTP response code returned from the server.\n\n*Arguments*  \nThis method does not take any arguments.\n\n*Return Values*  \nThe response code sent from the server.\n\n*Errors*  \nThis method may throw an error if:\n* The connection is not currently open.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612210,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=5863},["timeacquiresemaphore.md"]={modified=1704748612108,data="<summary>acquires a resource from a semaphore object, waiting until available or timeout</summary>\n# NAME\ntimeacquiresemaphore - acquires a resource from a semaphore object, waiting until available or timeout\n\n# LIBRARY\nStandard system library, synchronization module (*libsystem*, `system.sync`)\n\n# SYNOPSIS\n**timeacquiresemaphore**(*sem*: semaphore, *timeout*: number): boolean\n\n# DESCRIPTION\nAcquires a resource from a semaphore object, waiting if none are available, until the specified timeout passes.\n\n# PARAMETERS\n1. `sem`: The semaphore to acquire.\n2. `timeout`: The amount of time to wait in seconds.\n\n# RETURN VALUE\nWhether a resource was successfully acquired.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**acquiresemaphore**(2), **releasesemaphore**(2)\n",created=1704748612240,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=823},["unmount.md"]={modified=1704748612131,data="<summary>unmounts the mount at the specified path</summary>\n# NAME\nunmount - unmounts the mount at the specified path\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**unmount**(*path*: string)\n\n# DESCRIPTION\nUnmounts the mount at the specified path.\n\n# PARAMETERS\n1. `path`: The path to the mount.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The path does not exist.\n* The path specified is not a mount.\n* The user does not have permission to write to the path.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**mount**(2), **mountlist**(2)\n",created=1704748612244,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=658},["routelist.md"]={modified=1704748612096,data="<summary>returns a list of route entries in the specified route table</summary>\n# NAME\nroutelist - returns a list of route entries in the specified route table\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**routelist**(*num*: number?): table?\n\n# DESCRIPTION\nReturns a list of route entries in the specified route table.\n\n# PARAMETERS\n1. `num`: The table number to check as an integer starting at 0 (default 1)\n\n# RETURN VALUE\nA list of route entries with the following fields:\n* `source: string`: The bottom end of the source IP range.\n* `sourceNetmask: number`: The source subnet mask. For a single IP, this is 32. For all IPs (`default`), this is 0.\n* `action: string`: The action to take on the message. Valid values:\n  * `\"unicast\"`: Send all messages to the specified destination.\n  * `\"broadcast\"`: Broadcast the message to all destinations on the device.\n  * `\"local\"`: Send the message to a known destination on a local network.\n  * `\"unreachable\"`: Send a Destination Unreachable message back to the sender.\n  * `\"prohibit\"`: Send a Prohibit message back to the sender.\n  * `\"blackhole\"`: Ignore the message altogether.\n* `device: string?`: The device path to send the message to.\n* `destination: string?`: The destination IP to forward to.\n\nIf the specified table does not exist, this will return `nil`.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**routeadd**(2), **routedel**(2)\n",created=1704748612237,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1499},["netcontrol.md"]={modified=1704748612069,data="<summary>sends a control message to the specified IP address</summary>\n# NAME\nnetcontrol - sends a control message to the specified IP address\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**netcontrol**(*ip*: string, *type*: string, *err*: string?)\n\n# DESCRIPTION\nSends a control message to the specified IP address.\n\n# PARAMETERS\n1. `ip`: The IP address to send to\n2. `type`: The message type to send. See **network**(5) for more information.\n3. `err`: An optional error message to send if necessary.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user is not root.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612225,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=725},["unloadmodule.md"]={modified=1704748612125,data="<summary>unloads a kernel module from memory</summary>\n# NAME\nunloadmodule - unloads a kernel module from memory\n\n# SYNOPSIS\n**unloadmodule**(*path*: string)\n\n# DESCRIPTION\nUnloads a kernel module from memory. This syscall requires root.\n\n# PARAMETERS\n1. `name`: The name of the module to unload\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The user is not root.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**loadmodule**(2)\n",created=1704748612242,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=491},["unlisten.md"]={modified=1704748612122,data="<summary>stops listening on a URI previously passed to listen</summary>\n# NAME\nunlisten - stops listening on a URI previously passed to listen\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**unlisten**(*uri*: string)\n\n# DESCRIPTION\nStops listening on a URI previously passed to `listen`. This does not close any handles that are in use.\n\n# PARAMETERS\n1. `uri`: The URI to listen on. The path portion is ignored.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The computer is not listening on the specified URI.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**listen**(2)\n",created=1704748612242,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=682},["devlookup.md"]={modified=1704748612016,data="<summary>returns all paths to devices that have the specified node name</summary>\n# NAME\ndevlookup - returns all paths to devices that have the specified node name\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devlookup**(*name*: string): string...\n\n# DESCRIPTION\nReturns all paths to devices that have the specified node name. If a path or UUID is specified, returns the path of the singular device node.\n\n# PARAMETERS\n1. `name`: The device name to search for\n\n# RETURN VALUE\nThe path to each node in the device tree that has the specified name.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**devfind**(2)\n",created=1704748612215,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=717},["listen.md"]={modified=1704748612043,data="<summary>starts listening for connections on the specified URI</summary>\n# NAME\nlisten - starts listening for connections on the specified URI\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**listen**(*uri*: string)\n\n# DESCRIPTION\nStarts listening for connections on the specified URI, using the protocol, IP, and port indicated in the URI. For PSP connections, the IP is used to determine the device to listen on - if this is `0.0.0.0`, then all connections are accepted.\n\nWhen a request is received, a `network_request` event is sent with the URI of the listener, the IP of the other computer (if available), and a handle to the connection. Listening will continue until `unlisten` is called with the same URI. (Note: PSP can only handle one connection at once per port.)\n\nThe following URI schemes are built-in:\n* `http`: Internet HTTP requests (CraftOS-PC only)\n* `ws`: Internet WebSocket connections (CraftOS-PC only)\n* `psp`: Phoenix Socket Protocol connections\n\nOther schemes may be implemented in kernel modules.\n\n# PARAMETERS\n1. `uri`: The URI to listen on. The path portion is ignored.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The URI specified is malformed.\n* The scheme in the URI is not supported.\n* The computer does not own the IP in the URI.\n* The computer is already using the IP/port specified.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**unlisten**(2)\n",created=1704748612220,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1491},["trylockmutex.md"]={modified=1704748612119,data="<summary>attempts to lock the mutex</summary>\n# NAME\ntrylockmutex - attempts to lock the mutex\n\n# LIBRARY\nStandard system library, synchronization module (*libsystem*, `system.sync`)\n\n# SYNOPSIS\n**trylockmutex**(*mtx*: mutex): boolean\n\n# DESCRIPTION\nAttempts to lock the mutex, returning immediately if the mutex could not be locked.\n\n# PARAMETERS\n1. `mtx`: The mutex to lock.\n\n# RETURN VALUE\nWhether the mutex could be locked.\n\n# ERRORS\nThis syscall may throw an error if:\n* The mutex is already claimed by the current thread and is not recursive.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**lockmutex**(2), **unlockmutex**(2)\n",created=1704748612241,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=638},["kernargs.md"]={modified=1704748612031,data="<summary>returns the arguments passed to the kernel</summary>\n# NAME\nkernargs - Returns the arguments passed to the kernel\n\n# SYNOPSIS\n**kernargs**(): table\n\n# DESCRIPTION\nReturns the arguments passed to the kernel in a key-value table.\n\n# PARAMETERS\nThis syscall does not take any arguments.\n\n# RETURN VALUE\nA key-value table of all arguments passed to the kernel.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.4.\n",created=1704748612218,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=456},["releasesemaphore.md"]={modified=1704748612082,data="<summary>releases a resource from a semaphore</summary>\n# NAME\nreleasesemaphore - releases a resource from a semaphore\n\n# LIBRARY\nStandard system library, synchronization module (*libsystem*, `system.sync`)\n\n# SYNOPSIS\n**releasesemaphore**(*sem*: semaphore)\n\n# DESCRIPTION\nReleases a resource from a semaphore. This is a guaranteed atomic alternative to `sem.count = sem.count + 1`, and should be preferred.\n\n# PARAMETERS\n1. `sem`: The semaphore to release.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**acquiresemaphore**(2)\n",created=1704748612234,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=639},["alarm.md"]={modified=1704748611956,data="<summary>sets an alarm</summary>\n# NAME\nalarm - sets an alarm\n\n# LIBRARY\nStandard system library, utility module (*libsystem*, `system.util`)\n\n# SYNOPSIS\n**alarm**(*timeout*: number): number\n\n# DESCRIPTION\nSets an alarm that will send an `alarm` event at the specified time.\n\n# PARAMETERS\n1. `timeout`: The time to set the alarm to.\n\n# RETURN VALUE\nThe ID of the new alarm created.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**cancel**(2), **timer**(2)\n",created=1704748612202,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=508},["devunlock.md"]={modified=1704748612025,data="<summary>unlocks the specified device</summary>\n# NAME\ndevunlock - unlocks the specified device\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devunlock**(*device*: string)\n\n# DESCRIPTION\nUnlocks the specified device, allowing access to the device in other processes. This syscall does nothing if the device is not locked.\n\n# PARAMETERS\n1. `device`: The device path or UUID to operate on\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n* Another process has locked this device.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**devlock**(2)\n",created=1704748612216,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=689},["ipconfig.md"]={modified=1704748612028,data="<summary>queries or modifies the current PIP config</summary>\n# NAME\nipconfig - queries or modifies the current PIP config\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**ipconfig**(*device*: string, *info*: table?): table?\n\n# DESCRIPTION\nReturns a table with information about the current PIP configuration for the specified modem, and optionally sets new options (requires root).\n\nIf no configuration is present, then both the IP and netmask must be specified if `info` is set.\n\n# PARAMETERS\n1. `device`: The path to the modem to operate on\n2. `info`: If provided, a table of configuration options to set on the device, in the same format as the returned table\n\n# RETURN VALUE\nA table of PIP configuration entries. These are the currently used members:\n* `ip: string`: The IP address of the modem. No IP is indicated with an empty string. (When setting, this may also be a 32-bit number representing the IP in big-endian format.)\n* `netmask: number`: The subnet mask expressed as a number of bits, as in CIDR notation. No subnet mask is indicated with a value of `0`. (When setting, this may also be an IP-formatted address string.)\n* `up: boolean`: Whether the link is currently up. If a link is down, no Phoenix networking protocols will be serviced on this device. (This allows user applications to manually manage the protocols instead, if required.)\n\nIf the device does not have any IP configuration, returns `nil`.\n\n# ERRORS\nThis syscall may throw an error if:\n* The device is not present.\n* The device is not a valid modem.\n* A non-root user attempted to set configurations.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612217,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1673},["acquiresemaphore.md"]={modified=1704748611953,data="<summary>acquires a resource from a semaphore object</summary>\n# NAME\nacquiresemaphore - acquires a resource from a semaphore object\n\n# LIBRARY\nStandard system library, synchronization module (*libsystem*, `system.sync`)\n\n# SYNOPSIS\n**acquiresemaphore**(*sem*: semaphore)\n\n# DESCRIPTION\nAcquires a resource from a semaphore object, waiting if none are available.\n\n# PARAMETERS\n1. `sem`: The semaphore to acquire.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**timeacquiresemaphore**(2), **releasesemaphore**(2)\n",created=1704748612201,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=623},["stat.md"]={modified=1704748612105,data="<summary>returns a table with information about a file or directory</summary>\n# NAME\nstat - returns a table with information about a file or directory\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**stat**(*path*: string): StatInfo | **nil**, string\n\n# DESCRIPTION\nReturns a table with information about a file or directory. If the file does not exist, this returns `nil` and an error message.\n\n# PARAMETERS\n1. `path`: The path to the file or directory to inspect.\n\n# RETURN VALUE\nA table with the following contents:\n* `size: number`: The total size of the file in bytes\n* `type: string`: The type of file, which can be `\"file\"`, `\"directory\"`, `\"link\"`, `\"fifo\"`, or `\"special\"`\n* `created: number`: The time the file was created, in milliseconds since the UNIX epoch\n* `modified: number`: The time the file was last modified, in milliseconds since the UNIX epoch\n* `owner: string`: The owner of the file\n* `mountpoint: string`: The path to the mountpoint the file is on\n* `link: string?`: If the file is a link, the path it links to\n* `capacity: number`: The total number of bytes the mount can store\n* `freeSpace: number`: The total number of bytes available on the mount\n* `permissions: table`: The permissions for each user/group\n  * `<string>: table`: The permissions for each user/group who has manual permissions\n    * `read: boolean`: Whether the user can read the file\n    * `write: boolean`: Whether the user can write to the file\n    * `execute: boolean`: Whether the user can execute the file\n* `worldPermissions: table`: The permissions for all other users\n  * `read: boolean`: Whether everyone else can read the file\n  * `write: boolean`: Whether everyone else can write to the file\n  * `execute: boolean`: Whether everyone else can execute the file\n* `setuser: boolean`: Whether executing the file will set the user to the owner\n* `special: table?`: A table that can contain mount-specific data.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612239,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=2054},["signal.md"]={modified=1704748612102,data="<summary>registers a handler function to be called for a signal</summary>\n# NAME\nsignal - registers a handler function to be called for a signal\n\n# LIBRARY\nStandard system library, IPC module (*libsystem*, `system.ipc`)\n\n# SYNOPSIS\n**signal**(*signal*: number, *handler*: function(signal: number))\n\n# DESCRIPTION\nRegisters a handler function to be called for a signal.\n\n# PARAMETERS\n1. `signal`: The signal ID to register for.\n2. `handler`: The handler function to call, which takes the signal ID as its only argument.\n\n# RETURN VALUES\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**kill**(2)\n",created=1704748612238,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=685},["sendEvent.md"]={modified=1704748612099,data="<summary>queues a remote event to be sent to another process</summary>\n# NAME\nsendEvent - queues a remote event to be sent to another process\n\n# LIBRARY\nStandard system library, IPC module (*libsystem*, `system.ipc`)\n\n# SYNOPSIS\n**sendEvent**(*pid*: number, *name*: string, *params*: any)\n\n# DESCRIPTION\nQueues a remote event to be sent to another process. This creates an event called `remote_event` with the name and parameters passed as parameters. It does *not* allow sending arbitrary events to a process.\n\n# PARAMETERS\n1. `pid`: The ID of the process to send to.\n2. `name`: The name of the remote event to send.\n3. `params`: The data to send with the event.\n\n# RETURN VALUES\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612238,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=806},["netevent.md"]={modified=1704748612072,data="<summary>returns or toggles the current state of network event reporting</summary>\n# NAME\nnetevent - returns or toggles the current state of network event reporting\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**netevent**(*state*: boolean?): boolean\n\n# DESCRIPTION\nReturns the current state of network event reporting in the current process, and toggles it if desired. This allows listening to events such as control messages, PSP messages, send failures, etc.\n\n# PARAMETERS\n1. `state`: If specified, whether to send general network events to the current process\n\n# RETURN VALUE\nThe current state of network event reporting.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user is not root.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612226,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=794},["mountlist.md"]={modified=1704748612066,data="<summary>returns a list of mounts on the system</summary>\n# NAME\nmountlist - returns a list of mounts on the system\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**mountlist**(): [{*path*: string, *type*: string, *source*: string, *options*: table}]\n\n# DESCRIPTION\nReturns a list of mounts on the system.\n\n# PARAMETERS\nThis syscall does not take any arguments.\n\n# RETURN VALUE\nA list of tables containing the mount path, the filesystem type, the source path, and any options stored in the mount.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**mount**(2)\n",created=1704748612225,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=666},["detach.md"]={modified=1704748611993,data="<summary>detaches a peripheral from a side</summary>\n# NAME\ndetach - detaches a peripheral from a side\n\n# SYNOPSIS\n**detach**(*side*: string|number): boolean, string?\n\n# DESCRIPTION\nIf using an emulator, detaches a peripheral from a side. This syscall requires root.\n\n# PARAMETERS\n1. `side`: The side or ID to detach\n\n# RETURN VALUE\n1. Whether the detachment succeeded\n2. If it failed, an optional error message (this may be `nil`!)\n\n# ERRORS\nThis syscall may throw an error if:\n* The user is not root.\n\n# HISTORY\nIntroduced in Phoenix 0.0.2.\n\n# SEE ALSO\n**attach**(2)\n",created=1704748612210,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=569},["rename.md"]={modified=1704748612087,data="<summary>renames a file or directory from one path to another</summary>\n# NAME\nrename - renames a file or directory from one path to another\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**rename**(*from*: string, *to*: string)\n\n# DESCRIPTION\nRenames (moves) a file or directory from one path to another. The source and destination must be on the same filesystem.\n\n# PARAMETERS\n1. `from`: The file to move.\n2. `to`: The new destination path for the file.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The original file does not exist.\n* The new file already exists.\n* The current user does not have permission to read the original file.\n* The current user does not have permission to write the new file.\n* The current user does not have permission to write the parent directory of the new file.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612236,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=947},["remove.md"]={modified=1704748612084,data="<summary>deletes a file at a path</summary>\n# NAME\nremove - deletes a file at a path\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**remove**(*path*: string)\n\n# DESCRIPTION\nDeletes a file at a path. If the file is a directory, this also removes all files and directories contained within it. If the file does not exist, this does nothing and returns successfully.\n\n# PARAMETERS\n1. `path`: The path to the file to delete.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user does not have permission to write the file.\n* The current user does not have permission to write child subfiles and subdirectories.\n* The current user does not have permission to write the parent directory.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612235,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=843},["chroot.md"]={modified=1704748611985,data="<summary>changes the root directory</summary>\n# NAME\nchroot - changes the root directory\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**chroot**(*path*: string)\n\n# DESCRIPTION\nChanges the root directory of the current and future child processes. This syscall requires root.\n\n# PARAMETERS\n1. `path`: The path to the new root directory.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user is not root.\n* The new root directory does not exist.\n\n# HISTORY\nIntroduced in Phoenix 0.0.3.\n",created=1704748612208,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=605},["combine.md"]={modified=1704748611987,data="<summary>combines a set of path components into a valid path</summary>\n# NAME\ncombine - combines a set of path components into a valid path\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**combine**(*components...*: string): string\n\n# DESCRIPTION\nCombines a set of path components into a valid path.\n\n# PARAMETERS\n1. `components...`: The components in the path\n\n# RETURN VALUE\nThe final path composed of the passed components.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612209,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=567},["link.md"]={modified=1704748612037,data="<summary>creates a new symbolic link</summary>\n# NAME\nlink - creates a new symbolic link\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**link**(*path*: string, *location*: string)\n\n# DESCRIPTION\nCreates a new symbolic link at a path, creating any parent directories if they don't exist.\n\n# PARAMETERS\n1. `path`: The path to the link to create.\n2. `location`: The location the link should point to. This may be on another filesystem, as the link is symbolic.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user does not have permission to write the parent directory of the first directory created.\n* The path already exists.\n\n# HISTORY\nIntroduced in Phoenix 0.0.3.\n",created=1704748612219,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=787},["queueEvent.md"]={modified=1704748612078,data="<summary>queues an arbitrary event to be sent back to the current process</summary>\n# NAME\nqueueEvent - queues an arbitrary event to be sent back to the current process\n\n# LIBRARY\nStandard system library, IPC module (*libsystem*, `system.ipc`)\n\n# SYNOPSIS\n**queueEvent**(*name*: string, *params*: table)\n\n# DESCRIPTION\nQueues an arbitrary event to be sent back to the current process.\n\n# PARAMETERS\n1. `name`: The name of the event to send.\n2. `params`: The parameter list to send in the event.\n\n# RETURN VALUES\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612233,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=637},["devlock.md"]={modified=1704748612013,data="<summary>locks the specified device to this process</summary>\n# NAME\ndevlock - locks the specified device to this process\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devlock**(*device*: string, *wait*: boolean = true): boolean\n\n# DESCRIPTION\nLocks the specified device to this process. This prevents any calls to the device from other processes, and will suppress events from being sent to other processes. If the current process already owns the lock, this syscall returns `true` immediately. (It does not act like a recursive mutex in this case - only one unlock is required no matter how many times it's locked.)\n\n# PARAMETERS\n1. `device`: The device path or UUID to operate on\n2. `wait`: `true` to wait for the lock to be released before returning; `false` to return immediately if the lock is already owned by another process\n\n# RETURN VALUE\n`true` if the current process now owns the lock; `false` otherwise.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**devunlock**(2)\n",created=1704748612214,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1124},["open.md"]={modified=1704748612075,data="<summary>opens a file for reading or writing</summary>\n# NAME\nopen - opens a file for reading or writing\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**open**(*path*: string, *mode*: string): file\n\n# DESCRIPTION\nOpens a file for reading or writing.\n\n# PARAMETERS\n1. `path`: The path to the file to open. This may be a relative path to the current working directory, or an absolute path relative to the root.\n2. `mode`: The mode to open the file in. This may be `r`, `w`, or `a`, with an additional `b` at the end to open in binary mode.\n\n# RETURN VALUE\nA file handle object.\n\n# ERRORS\nThis syscall may throw an error if:\n* The mode argument is invalid.\n* The file was opened in read mode and it does not exist.\n* The parent directory of the file does not exist.\n* The file is a directory.\n* The current user does not have permission to access the file.\n* If creating a new file and the current user does not have permission to write the parent directory.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612227,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1051},["routedel.md"]={modified=1704748612093,data="<summary>removes the specified route from the specified table</summary>\n# NAME\nroutedel - removes the specified route from the specified table\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**routedel**(*source*: string, *mask*: number, *num*: number?)\n\n# DESCRIPTION\nRemoves the specified route from the specified table.\n\n# PARAMETERS\n1. `source`: The source IP address to remove in CIDR notation (e.g. `192.168.0.0/16`)\n2. `mask`: The netmask prefix length of the IP to remove\n3. `num`: The table number to modify as an integer starting at 1 (default 1)\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* A non-root user attempted to remove routes.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**routeadd**(2)\n",created=1704748612237,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=819},["cancel.md"]={modified=1704748611970,data="<summary>cancels a previously set timer or alarm</summary>\n# NAME\ncancel - cancels a previously set timer or alarm\n\n# LIBRARY\nStandard system library, utility module (*libsystem*, `system.util`)\n\n# SYNOPSIS\n**cancel**(*tm*: number)\n\n# DESCRIPTION\nCancels a previously set timer or alarm.\n\n# PARAMETERS\n1. `tm`: The ID of the timer or alarm to cancel.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**alarm**(2), **timer**(2)\n",created=1704748612205,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=531},["unlockmutex.md"]={modified=1704748612128,data="<summary>unlocks the specified mutex</summary>\n# NAME\nunlockmutex - unlocks the specified mutex\n\n# LIBRARY\nStandard system library, synchronization module (*libsystem*, `system.sync`)\n\n# SYNOPSIS\n**unlockmutex**(*mtx*: mutex)\n\n# DESCRIPTION\nUnlocks the specified mutex.\n\n# PARAMETERS\n1. `mtx`: The mutex to unlock.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The mutex is already unlocked.\n* The mutex is currently locked by a different thread.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**lockmutex**(2)\n",created=1704748612243,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=573},["routeadd.md"]={modified=1704748612090,data="<summary>adds a new route to the specified route table</summary>\n# NAME\nrouteadd - adds a new route to the specified route table\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**routeadd**(*options*: table)\n\n# DESCRIPTION\nAdds a new route to the specified route table. If the table does not exist, it will be created.\n\n# PARAMETERS\n1. `options`: A table with options for the route entry, with the following fields:\n  * `source: string`: The bottom end of the source IP range.\n  * `sourceNetmask: number`: The source subnet mask. For a single IP, this is 32. For all IPs (`default`), this is 0.\n  * `action: string`: The action to take on the message. Valid values:\n    * `\"unicast\"`: Send all messages to the specified destination.\n    * `\"broadcast\"`: Broadcast the message to all destinations on the device.\n    * `\"local\"`: Send the message to a known destination on a local network.\n    * `\"unreachable\"`: Send a Destination Unreachable message back to the sender.\n    * `\"prohibit\"`: Send a Prohibit message back to the sender.\n    * `\"blackhole\"`: Ignore the message altogether.\n  * `device: string?`: The device path to send the message to.\n  * `destination: string?`: The destination IP to forward to.\n  * `table: number?`: A number specifying the table index to insert into (integer starting at 1; defaults to 1).\n\nThe actions `\"local\"`, `\"unicast\"` and `\"broadcast\"` require `device`; `\"unicast\"` also requires `destination`.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* A non-root user attempted to add routes.\n* A route already exists with the same IP and netmask.\n* The device (if specified) is not present.\n* The device (if specified) is not a valid modem.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**routedel**(2)\n",created=1704748612236,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1845},["devcall.md"]={modified=1704748612000,data="<summary>calls the specified method on the device</summary>\n# NAME\ndevcall - calls the specified method on the device\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devcall**(*device*: string, *method*: string, *args...*: any): any...\n\n# DESCRIPTION\nCalls the specified method on the device with arguments.\n\n# PARAMETERS\n1. `device`: The device path or UUID to operate on\n2. `method`: The name of the method to call\n3. `args...`: Any arguments to pass to the method\n\n# RETURN VALUE\nAll values returned from the method.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n* Another process has locked this device.\n* The specified method does not exist on the device.\n* The method threw an error while executing.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612211,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=836},["mount.md"]={modified=1704748612064,data="<summary>mounts a disk device to a path</summary>\n# NAME\nmount - mounts a disk device to a path\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**mount**(*type*: string, *src*: string, *dest*: string, *options*: table?)\n\n# DESCRIPTION\nMounts a disk device to a path using the specified filesystem and options.\n\n# PARAMETERS\n1. `type`: The filesystem type to use when mounting.\n2. `src`: The source device to mount. This argument's meaning depends on the filesystem type.\n3. `dest`: The directory to mount the new filesystem to.\n4. `options`: A table of options to pass to the filesystem mounter. The available options are specified by each individual filesystem.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The filesystem type does not exist.\n* The source device is invalid for the specified filesystem type.\n* The destination path does not exist.\n* The options passed to the mounter are invalid for the specified filesystem type.\n* The current user does not have permission to access to the source device.\n* The current user does not have permission to write to to the destination path.\n* The mounter ran into an issue while mounting the device.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**mountlist**(2), **unmount**(2)\n",created=1704748612224,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1344},["mkfifo.md"]={modified=1704748612060,data="<summary>creates a new FIFO pipe file</summary>\n# NAME\nmkfifo - creates a new FIFO pipe file\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**mkfifo**(*path*: string)\n\n# DESCRIPTION\nCreates a new FIFO (first in first out) pipe file at a path, creating any parent directories if they don't exist.\n\n# PARAMETERS\n1. `path`: The path to the FIFO to create.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user does not have permission to write the parent directory of the first directory created.\n* The path already exists.\n\n# HISTORY\nIntroduced in Phoenix 0.0.3.\n",created=1704748612224,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=681},["mkdir.md"]={modified=1704748612057,data="<summary>creates a new directory</summary>\n# NAME\nmkdir - creates a new directory\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**mkdir**(*path*: string)\n\n# DESCRIPTION\nCreates a new directory at a path, creating any parent directories if they don't exist. If the directory already exists, this function does nothing and exits successfully.\n\n# PARAMETERS\n1. `path`: The path of the directory to create.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user does not have permission to write the parent directory of the first directory created.\n* A path component already exists and is a file.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612223,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=754},["arplist.md"]={modified=1704748611959,data="<summary>returns the list of known IP to computer ID mappings</summary>\n# NAME\narplist - returns the list of known IP to computer ID mappings\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**arplist**(*device*: string): {[string] = number}\n\n# DESCRIPTION\nReturns the list of known IP to computer ID mappings for the specified device.\n\n# PARAMETERS\n1. `device`: The path to the modem to query for.\n\n# RETURN VALUE\nA key-value table of mappings from IP addresses to computer IDs.\n\n# ERRORS\nThis syscall may throw an error if:\n* The device is not present.\n* The device is not a valid modem.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**arpset**(2)\n",created=1704748612202,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=702},["checkuri.md"]={modified=1704748611976,data="<summary>returns whether the specified URI is valid</summary>\n# NAME\ncheckuri - returns whether the specified URI is valid\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**checkuri**(*uri*: string): boolean\n\n# DESCRIPTION\nReturns whether the specified URI is valid and the scheme is supported.\n\n# PARAMETERS\n1. `uri`: The URI to check\n\n# RETURN VALUE\nWhether the URI is valid. This will always return `false` for an unsupported URI scheme. For HTTP and WebSocket URLs, this will check that the URL can be connected to as well.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612207,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=665},["devinfo.md"]={modified=1704748612008,data="<summary>returns a table with information describing a device node</summary>\n# NAME\ndevinfo - returns a table with information describing a device node\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devinfo**(*device*: string): HWInfo?\n\n# DESCRIPTION\nReturns a table with information describing a device node.\n\n# PARAMETERS\n1. `device`: The device path or UUID to look up\n\n# RETURN VALUE\nA table with the following information:\n```ts\ntype HWInfo = {\n    id: string,                // Device hardware ID\n    uuid: string,              // Assigned UUID\n    alias: string?,            // User-specified alias\n    parent: string,            // Path to parent device\n    displayName: string,       // Display name for users\n    types: {[string]: string}, // Types of devices implemented: type = driver name\n    metadata: Object           // Extra static metadata provided by drivers\n}\n```\nIf the device does not exist, this returns `nil`.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**devmethods**(2), **devproperties**(2)\n",created=1704748612213,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1128},["devfind.md"]={modified=1704748612005,data="<summary>finds devices with a specific type</summary>\n# NAME\ndevfind - finds devices with a specific type\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devfind**(*type*: string): string...\n\n# DESCRIPTION\nReturns all paths to devices that have the specified type implemented.\n\n# PARAMETERS\n1. `name`: The device type to search for\n\n# RETURN VALUE\nThe path to each node in the device tree that has the specified type.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**devlookup**(2)\n",created=1704748612212,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=588},["callmodule.md"]={modified=1704748611967,data="<summary>calls a function on a kernel module</summary>\n# NAME\ncallmodule - calls a function on a kernel module\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**callmodule**(*name*: string, *func*: string, *args...*: any): any...\n\n# DESCRIPTION\nCalls a function on a kernel module, if the module exposes an API.\n\n# PARAMETERS\n1. `name`: The name of the module to call on\n2. `func`: The name of the function to call\n3. `args...`: Any arguments to pass to the function\n\n# RETURN VALUE\nAny values returned from the function call.\n\n# ERRORS\nThis syscall may throw an error if:\n* The module requested is not loaded.\n* The module does not have an exported API.\n* The module does not have the requested function.\n* The function throws an error.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612204,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=827},["loadCraftOSAPI.md"]={modified=1704748612049,data="<summary>loads a CraftOS API or module from the ROM</summary>\n# NAME\nloadCraftOSAPI - loads a CraftOS API or module from the ROM\n\n# SYNOPSIS\n**loadCraftOSAPI**(*apiName*: string): table\n\n# DESCRIPTION\nLoads a CraftOS API or module from the ROM. This can be used to get access to certain functions without having to mount the entire ROM.\n\nThis uses the current process's environment as the parent environment. This means the API will use the process's globals. If the API you need requires certain globals (like `colors`), load these in as globals first.\n\n# PARAMETERS\n1. `apiName`: The name of the API or module to load. If this starts with `cc.`, it loads a module from `rom/modules/main`. Otherwise, it loads an API from `rom/apis`.\n\n# RETURN VALUE\nA table with the loaded API or module.\n\n# ERRORS\nThis syscall may throw an error if:\n* The API name is malformed.\n* The API does not exist.\n* An error occurred while loading the API.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612221,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=974},["kill.md"]={modified=1704748612034,data="<summary>sends a signal to another process</summary>\n# NAME\nkill - sends a signal to another process\n\n# LIBRARY\nStandard system library, IPC module (*libsystem*, `system.ipc`)\n\n# SYNOPSIS\n**kill**(*pid*: number, *signal*: number)\n\n# DESCRIPTION\nSends a signal to another process. The signal may be any numerical value, though the system will only respond to certain values.\n\n# PARAMETERS\n1. `pid`: The ID of the process to send to\n2. `signal`: The signal ID to send\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The target process ID does not exist.\n* The current user does not have permission to send a signal to the target.\n  * The target process must be under the same user as the current one.\n  * If the current process is running as root, it may send a signal to any process.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**signal**(2)\n",created=1704748612218,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=904},["listmodules.md"]={modified=1704748612046,data="<summary>returns a list of currently loaded kernel module names</summary>\n# NAME\nlistmodules - returns a list of currently loaded kernel module names\n\n# SYNOPSIS\n**listmodules**(): string[]\n\n# DESCRIPTION\nReturns a list of currently loaded kernel module names.\n\n# PARAMETERS\nThis syscall does not take any arguments.\n\n# RETURN VALUE\nA list of currently loaded kernel module names.\n\n# ERRORS\nThis syscall does not throw any errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612221,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=471},["lockmutex.md"]={modified=1704748612054,data="<summary>locks the specified mutex</summary>\n# NAME\nlockmutex - locks the specified mutex\n\n# LIBRARY\nStandard system library, synchronization module (*libsystem*, `system.sync`)\n\n# SYNOPSIS\n**lockmutex**(*mtx*: mutex)\n\n# DESCRIPTION\nLocks the specified mutex, waiting for the resource to be freed before claiming it.\n\n# PARAMETERS\n1. `mtx`: The mutex to lock.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The mutex is already claimed by the current thread and is not recursive.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**timelockmutex**(2) **trylockmutex**(2), **unlockmutex**(2)\n",created=1704748612222,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=649},["timer.md"]={modified=1704748612114,data="<summary>sets a timer</summary>\n# NAME\ntimer - sets a timer\n\n# LIBRARY\nStandard system library, utility module (*libsystem*, `system.util`)\n\n# SYNOPSIS\n**timer**(*timeout*: number): number\n\n# DESCRIPTION\nSets a timer that will send a `timer` event after the specified number of seconds.\n\n# PARAMETERS\n1. `timeout`: The amount of time to set the timer for.\n\n# RETURN VALUE\nThe ID of the new timer created.\n\n# ERRORS\nThis syscall does not throw errors.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**alarm**(2), **cancel**(2)\n",created=1704748612241,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=531},["loadmodule.md"]={modified=1704748612051,data="<summary>attempts to load a kernel module into memory</summary>\n# NAME\nloadmodule - attempts to load a kernel module into memory\n\n# SYNOPSIS\n**loadmodule**(*path*: string)\n\n# DESCRIPTION\nAttempts to load a kernel module into memory. This syscall requires root.\n\n# PARAMETERS\n1. `path`: The path to the module to load.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The user is not root.\n* The path refers to a directory.\n* The module is either not owned by root or world-writable.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**unloadmodule**(2)\n",created=1704748612222,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=609},["chown.md"]={modified=1704748611982,data="<summary>changes the owner of a file or directory</summary>\n# NAME\nchown - changes the owner of a file or directory\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**chown**(*path*: string, *user*: string)\n\n# DESCRIPTION\nChanges the owner of a file or directory, clearing the `setuser` bit if it's set.\n\n# PARAMETERS\n1. `path`: The path to the file to modify.\n2. `user`: The user who will own the file.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The file does not exist.\n* The current user is not the owner of the file or root.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**chmod**(2)\n",created=1704748612208,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=706},["devlisten.md"]={modified=1704748612010,data="<summary>enables listening for events from this device</summary>\n# NAME\ndevlisten - enables listening for events from this device\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devlisten**(*device*: string, *state*: boolean = true)\n\n# DESCRIPTION\nEnables (or disables) listening for events from this device.\n\n# PARAMETERS\n1. `device`: The device path or UUID to operate on\n2. `state`: `true` to allow events to be passed to this process; `false` to stop events from being sent\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612214,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=709},["timelockmutex.md"]={modified=1704748612111,data="<summary>locks the specified mutex, waiting until the mutex is unlocked or timeout</summary>\n# NAME\ntimelockmutex - locks the specified mutex, waiting until the mutex is unlocked or timeout\n\n# LIBRARY\nStandard system library, synchronization module (*libsystem*, `system.sync`)\n\n# SYNOPSIS\n**timelockmutex**(*mtx*: mutex, *timeout*: number): boolean\n\n# DESCRIPTION\nLocks the specified mutex, waiting for the resource to be freed before claiming it. If the mutex isn't unlocked after the specified timeout, the syscall returns without locking.\n\n# PARAMETERS\n1. `mtx`: The mutex to lock.\n2. `timeout`: The amount of time to wait in seconds.\n\n# RETURN VALUE\nWhether the mutex could be locked.\n\n# ERRORS\nThis syscall may throw an error if:\n* The mutex is already claimed by the current thread and is not recursive.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**lockmutex**(2), **unlockmutex**(2)\n",created=1704748612240,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=900},["devmethods.md"]={modified=1704748612019,data="<summary>returns a list of methods that can be called on this device</summary>\n# NAME\ndevmethods - returns a list of methods that can be called on this device\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devmethods**(*device*: string): string[]\n\n# DESCRIPTION\nReturns a list of methods that can be called on this device.\n\n# PARAMETERS\n1. `device`: The device path or UUID to look up\n\n# RETURN VALUE\nA list of valid methods that can be called.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612215,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=622},["attach.md"]={modified=1704748611964,data="<summary>attaches a peripheral of the specified type to the computer</summary>\n# NAME\nattach - attaches a peripheral of the specified type to the computer\n\n# SYNOPSIS\n**attach**(*side*: string|number, *type*: string, *args...*: any): boolean, string?\n\n# DESCRIPTION\nIf using an emulator, attaches a peripheral of the specified type to the computer. This syscall requires root.\n\n# PARAMETERS\n1. `side`: The side to attach to, or an ID to attach as\n2. `type`: The type of peripheral to attach. The peripherals use standard CC/CraftOS-PC naming.\n3. `args...`: Any arguments to pass to the peripheral constructor\n\n# RETURN VALUE\n1. Whether the attachment succeeded\n2. If it failed, an optional error message (this may be `nil`!)\n\n# ERRORS\nThis syscall may throw an error if:\n* The user is not root.\n\n# HISTORY\nIntroduced in Phoenix 0.0.2.\n\n# SEE ALSO\n**detach**(2)\n",created=1704748612204,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=861},["devalias.md"]={modified=1704748611996,data="<summary>sets or removes an alias for a device</summary>\n# NAME\ndevalias - sets or removes an alias for a device\n\n# LIBRARY\nStandard system library, hardware module (*libsystem*, `system.hardware`)\n\n# SYNOPSIS\n**devalias**(*device*: string, *alias*: string?)\n\n# DESCRIPTION\nSets or removes an alias for a device.\n\n# PARAMETERS\n1. `device`: The device path or UUID to modify\n2. `alias`: The new alias to set (`nil` to remove)\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The specified device does not exist.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n",created=1704748612211,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=605},["chmod.md"]={modified=1704748611979,data="<summary>changes the permissions of a file or directory</summary>\n# NAME\nchmod - changes the permissions of a file or directory\n\n# LIBRARY\nStandard system library, filesystem module (*libsystem*, `system.filesystem`)\n\n# SYNOPSIS\n**chmod**(*path*: string, *user*: string?, *mode*: number|string|table)\n\n# DESCRIPTION\nChanges the permissions (mode) of a file or directory for the specified user. If any setuser bit is specified, this will be applied for all users.\n\n# PARAMETERS\n1. `path`: The path to the file to modify.\n2. `user`: The user to set the permissions for. If this is `nil`, sets the permissions for all users.\n3. `mode`: A value representing the permissions. This may be:\n  * A UNIX-style octal mode (e.g. `5`) - setuid bit is bit 4 (010)\n  * A UNIX-style mode modification string, without the user specifier (e.g. `\"+rx\"`) (this does not work with `\"-wx\"` - use `\"-xw\"` instead)\n  * A 3-character string with \"r\", \"w\", and \"x\" or \"s\" (or \"-\") (e.g. `\"r-s\"`)\n  * A table with `read: boolean?`, `write: boolean?`, `execute: boolean?`, and `setuser: boolean?` fields (if a field is `nil`, it uses the previous value)\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The file does not exist.\n* The current user is not the owner of the file or root.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**chown**(2)\n",created=1704748612207,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1377},["arpset.md"]={modified=1704748611961,data="<summary>sets the computer ID mapping for the specified IP</summary>\n# NAME\narpset - sets the computer ID mapping for the specified IP\n\n# LIBRARY\nStandard system library, network module (*libsystem*, `system.network`)\n\n# SYNOPSIS\n**arpset**(*device*: string, *ip*: string, *id*: number?)\n\n# DESCRIPTION\nSets the computer ID mapping for the specified IP on the requested device.\n\n# PARAMETERS\n1. `device`: The path to the modem to add for.\n2. `ip`: The IP address of the target computer.\n3. `id`: The computer ID of the target computer, or `nil` to remove the entry.\n\n# RETURN VALUE\nThis syscall does not return anything.\n\n# ERRORS\nThis syscall may throw an error if:\n* The current user is not root.\n* The device is not present.\n* The device is not a valid modem.\n\n# HISTORY\nIntroduced in Phoenix 0.0.1.\n\n# SEE ALSO\n**arplist**(2)\n",created=1704748612203,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=830}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},typescript={modified=1704748612467,created=1704748612467,contents={libsystem={modified=1704748611496,created=1704748611496,contents={["expect.d.ts"]={modified=1704748611470,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"system.expect\" {\n    namespace expect {\n        function expect(index: number, value: any, ...types: string[]): any;\n        function field(tbl: Object, index: any, ...types: string[]): any;\n        function range(num: number, min?: number, max?: number): number;\n    }\n    function expect(index: number, value: any, ...types: string[]): any;\n    export = expect;\n}",created=1704748611485,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=425},["sync.d.ts"]={modified=1704748611479,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"system.sync\" {\n    export interface mutex {\n        lock(): void;\n        unlock(): void;\n        tryLock(): boolean;\n        tryLockFor(timeout: number): boolean;\n    }\n    export const mutex: {new: (this: void, recursive?: boolean) => mutex};\n    export interface semaphore {\n        acquire(): void;\n        tryAcquireFor(timeout: number): boolean;\n        release(): void;\n    }\n    export const semaphore: {new: (this: void, init?: number) => mutex};\n    export interface conditionVariable {\n        wait(): void;\n        waitFor(timeout: number): boolean;\n        notifyOne(): void;\n        notifyAll(): void;\n    }\n    export const conditionVariable: {new: (this: void) => conditionVariable};\n    export interface barrier {\n        wait(): boolean;\n    }\n    export const barrier: {new: (this: void, count: number) => barrier};\n    export interface rwLock {\n        lockRead(): void;\n        unlockRead(): void;\n        lockWrite(): void;\n        unlockWrite(): void;\n    }\n    export const rwLock: {new: (this: void) => rwLock};\n}",created=1704748611494,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1098},["hardware.d.ts"]={modified=1704748611472,data="/** @noSelfInFile **/\ntype device = {[method: string]: Function} & {[property: string]: any};\n\n/** @noSelf **/\ndeclare interface CommandDevice extends device {\n    command: string;\n    run(): LuaMultiReturn<[boolean, string|null]>;\n}\n\n/** @noSelf **/\ndeclare interface ComputerDevice extends device {\n    readonly isOn: boolean;\n    readonly label: string|null;\n    turnOn(): void;\n    shutdown(): void;\n    reboot(): void;\n}\n\n/** @noSelf **/\ndeclare interface RootComputerDevice extends ComputerDevice {\n    label: string|null;\n    shutdown(): never;\n    reboot(): never;\n}\n\n/** @noSelf **/\ndeclare interface DriveDevice extends device {\n    readonly state: {\n        audio: string|null,\n        label: string|null,\n        id: number|null\n    } | null;\n    setLabel(label: string|null): void;\n    play(): void;\n    stop(): void;\n    eject(): void;\n    insert(path: string): void;\n}\n\n/** @noSelf **/\ndeclare interface EnergyStorageDevice extends device {\n    readonly energy: number;\n}\n\n/** @noSelf **/\ndeclare interface FluidStorageDevice extends device {\n    readonly tanks: {name: string, amount: number}[];\n    push(to: string, limit?: number, name?: string): number;\n    pull(from: string, limit?: number, name?: string): number;\n}\n\ntype ItemDetail = {\n    name: string,\n    count: number,\n    nbt?: string,\n    displayName: string,\n    maxCount: number,\n    damage?: number,\n    maxDamage?: number,\n    durability?: number,\n    lore?: string[],\n    enchantments?: {name: string, level: number, displayName: string}[],\n    unbreakable?: boolean\n}\n\n/** @noSelf **/\ndeclare interface InventoryDevice extends device {\n    readonly items: {name: string, count: number, nbt: string|null}[];\n    detail(slot: number): ItemDetail|null;\n    limit(slot: number): number;\n    push(to: string, slot: number, limit?: number, toSlot?: number): number;\n    pull(from: string, slot: number, limit?: number, toSlot?: number): number;\n}\n\n/** @noSelf **/\ndeclare interface ModemDevice extends device {\n    readonly remainingChannels: number;\n    open(channel: number): void;\n    isOpen(channel: number): boolean;\n    close(channel: number): void;\n    closeAll(): void;\n    transmit(channel: number, replyChannel: number|null, payload: any): void;\n}\n\n/** @noSelf **/\ndeclare interface MonitorDevice extends device {\n    scale: number;\n    readonly size: {width: number, height: number};\n    write(...value: any[]): void;\n    termctl(flags?: TermFlags): TermFlags;\n    openterm(): LuaMultiReturn<[Terminal] | [null, string]>;\n    opengfx(): LuaMultiReturn<[GFXTerminal] | [null, string]>;\n}\n\n/** @noSelf **/\ndeclare interface PrinterPage {\n    readonly size: {width: number, height: number};\n    cursor: {x: number, y: number};\n    title: string|null;\n    write(...text: any[]): void;\n    close(): boolean;\n}\n\n/** @noSelf **/\ndeclare interface PrinterDevice extends device {\n    readonly inkLevel: number;\n    readonly paperLevel: number;\n    page(): PrinterPage|null;\n}\n\n/** @noSelf **/\ndeclare interface RedstoneDevice extends device {\n    readonly input: number|null;\n    output: number|null;\n    readonly bundledInput: number|null;\n    bundledOutput: number|null;\n}\n\n/** @noSelf **/\ninterface SpeakerDevice extends device {\n    playNote(instrument: string, volume?: number, pitch?: number): boolean;\n    playSound(name: string, volume?: number, speed?: number): boolean;\n    playAudio(audio: number[], volume?: number): boolean;\n    stop(): void;\n}\n\n/** @noResolution **/\ndeclare module \"system.hardware\" {\n    export type HWInfo = {\n        id: string,                      // Device hardware ID\n        uuid: string,                    // Assigned UUID\n        alias: string|null,              // User-specified alias\n        parent: string,                  // Path to parent device\n        displayName: string,             // Display name for users\n        types: {[type: string]: string}, // Types of devices implemented: type = driver name\n        metadata: Object                 // Extra static metadata provided by drivers\n    }\n    export type devicetree = {[name: string]: devicetree|null};\n    type _devspec = string | device | devicetree;\n\n    export const tree: devicetree;\n    export function wrap(device: _devspec): device | null;\n    export function find(type: string): LuaMultiReturn<device[]>;\n    export function path(device: _devspec): LuaMultiReturn<string[]>;\n    export function hasType(device: _devspec, type: string): boolean;\n    export function info(device: _devspec): HWInfo|null;\n    export function methods(device: _devspec): string[];\n    export function properties(device: _devspec): string[];\n    export function children(device: _devspec): string[];\n    export function call(device: _devspec, method: string, ...args: any[]): LuaMultiReturn<any[]>;\n    export function listen(device: _devspec, state?: boolean): void;\n    export function lock(device: _devspec, wait?: boolean): boolean;\n    export function unlock(device: _devspec): void;\n}",created=1704748611487,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=4965},["pretty.d.ts"]={modified=1704748611477,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"system.pretty\" {\n    type Doc = {};\n    export const empty: Doc;\n    export const space: Doc;\n    export const line: Doc;\n    export const space_line: Doc;\n    export function text(text: string, color?: number): Doc;\n    export function concat(...args: (Doc|string)[]): Doc;\n    export function nest(depth: number, doc: Doc): Doc;\n    export function group(doc: Doc): Doc;\n    export function write(doc: Doc, ribbon_frac?: number): void;\n    export function print(doc: Doc, ribbon_frac?: number): void;\n    export function render(doc: Doc, width?: number, ribbon_frac?: number): string;\n    export function pretty(obj: any, options?: {function_args?: boolean, function_source: boolean}): Doc;\n    export function pretty_print(obj: any, options?: {function_args?: boolean, function_source: boolean}, ribbon_frac?: number): void;\n}",created=1704748611493,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=889},["graphics.d.ts"]={modified=1704748611472,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"system.graphics\" {\n    export function drawPixel(term: Terminal|GFXTerminal, x: number, y: number, color: Color): void;\n    export function drawLine(term: Terminal|GFXTerminal, x1: number, y1: number, x2: number, y2: number, color: Color): void;\n    export function drawBox(term: Terminal|GFXTerminal, x: number, y: number, width: number, height: number, color: Color): void;\n    export function drawFilledBox(term: Terminal|GFXTerminal, x: number, y: number, width: number, height: number, color: Color): void;\n    export function drawCircle(term: Terminal|GFXTerminal, x: number, y: number, width: number, height: number, color: Color, startAngle?: number, arcCircumference?: number): void;\n    export function drawFilledTriangle(term: Terminal|GFXTerminal, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, color: Color): void;\n    export function drawImage(term: Terminal, x: number, y: number, image: [string, string, string][] | string[] | (Color|null)[][]): void;\n    export function drawImage(term: GFXTerminal, x: number, y: number, image: string[] | (Color|null)[][]): void;\n}",created=1704748611486,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1168},["filesystem.d.ts"]={modified=1704748611470,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"system.filesystem\" {\n    /** @noSelf **/\n    export interface FileHandle {\n        close(): void;\n    }\n    /** @noSelf **/\n    export interface ReadFileHandle extends FileHandle {\n        read(n: number): string|number|null;\n        readLine(newline?: boolean): string|null;\n        readAll(): string|null;\n    }\n    /** @noSelf **/\n    export interface WriteFileHandle extends FileHandle {\n        write(val: any): void;\n        writeLine(val: any): void;\n        flush(): void;\n    }\n    /** @noSelf **/\n    export interface BinaryFileHandle {\n        seek(mode?: \"set\"|\"cur\"|\"end\", offset?: number): number;\n    }\n    export type Permission = {read: boolean|null, write: boolean|null, execute: boolean|null};\n    export type FileStat = {\n        size: number,\n        type: \"file\" | \"directory\" | \"link\" | \"fifo\" | \"special\",\n        created: number,\n        modified: number,\n        owner: string | null,\n        mountpoint: string,\n        capacity: number,\n        freeSpace: number,\n        permissions: {[key: string]: Permission},\n        worldPermissions: Permission,\n        setuser: boolean,\n        special: LuaTable | null\n    };\n    export type MountInfo = {\n        path: string,\n        type: string,\n        source: string,\n        options: {[key: string]: any}\n    };\n\n    export function open(path: string, mode: \"r\"): LuaMultiReturn<[ReadFileHandle|null, null|string]>;\n    export function open(path: string, mode: \"w\"|\"a\"): LuaMultiReturn<[WriteFileHandle|null, null|string]>;\n    export function open(path: string, mode: \"rb\"): LuaMultiReturn<[(ReadFileHandle & BinaryFileHandle)|null, null|string]>;\n    export function open(path: string, mode: \"wb\"|\"ab\"): LuaMultiReturn<[(WriteFileHandle & BinaryFileHandle)|null, null|string]>;\n    export function list(path: string): string[];\n    export function stat(path: string, nolink?: boolean): LuaMultiReturn<[FileStat|null, null|string]>;\n    export function remove(path: string): void;\n    export function rename(from: string, to: string): void;\n    export function mkdir(path: string): void;\n    export function link(path: string, location: string): void;\n    export function mkfifo(path: string): void;\n    export function chmod(path: string, user: string|null, mode: number|string|Permission): void;\n    export function chown(path: string, user: string): void;\n    export function chroot(path: string): void;\n    export function mount(type: string, src: string, dest: string, options?: Object): void;\n    export function unmount(path: string): void;\n    export function mountlist(): MountInfo[];\n    export function combine(...args: string[]): string;\n    export function copy(from: string, to: string, preserve?: boolean): void;\n    export function move(from: string, to: string): void;\n    export function basename(path: string): string;\n    export function dirname(path: string): string;\n    export function find(wildcard: string): string[];\n    export function exists(path: string): boolean;\n    export function isFile(path: string): boolean;\n    export function isDir(path: string): boolean;\n    export function isLink(path: string): boolean;\n    export function effectivePermissions(file: string|FileStat, user?: string): Permission|null;\n}",created=1704748611485,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=3282},["framebuffer.d.ts"]={modified=1704748611471,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"system.framebuffer\" {\n    /** @noSelf **/\n    interface _Window<T extends Terminal | GFXTerminal> {\n        getPosition(): LuaMultiReturn<[number, number]>;\n        reposition(x?: number, y?: number, width?: number, height?: number, parent?: T): void;\n        resize(width?: number, height?: number): void;\n        reparent(parent?: T): void;\n        restoreCursor(this: _Window<Terminal>): void;\n    }\n    /** @noSelf **/\n    interface _Framebuffer<T extends Terminal | GFXTerminal> extends _Window<T> {\n        redraw(full?: boolean): void;\n        isVisible(): boolean;\n        setVisible(visible: boolean): void;\n    }\n    export type Window<T extends Terminal | GFXTerminal> = T & _Window<T>;\n    export type Framebuffer<T extends Terminal | GFXTerminal> = T & _Framebuffer<T>;\n\n    export const empty: {text: Terminal, graphics: GFXTerminal};\n    export function window(parent: Terminal, x: number, y: number, width: number, height: number): Window<Terminal>;\n    export function window(parent: GFXTerminal, x: number, y: number, width: number, height: number): Window<GFXTerminal>;\n    export function framebuffer(parent: Terminal, x: number, y: number, width: number, height: number, visible?: boolean): Framebuffer<Terminal>;\n    export function framebuffer(parent: GFXTerminal, x: number, y: number, width: number, height: number, visible?: boolean): Framebuffer<GFXTerminal>;\n}",created=1704748611486,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1448},["util.d.ts"]={modified=1704748611481,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"system.util\" {\n    export const syscall: {[method: string]: (...args: any[]) => LuaMultiReturn<any[]>};\n    export function argparse(arguments: {\"\": {stopProcessingOnPositionalArgument?: boolean}} & {[arg: string]: boolean | \"number\" | \"multiple\" | \"multiple number\" | `@${string}`}, ...args: string[]): LuaMultiReturn<[{[arg: string]: true|string} & string[]] | [null, string]>;\n    export function timer(time: number): number;\n    export function alarm(time: number): number;\n    export function cancel(id: number): number;\n    export function sleep(time: number): void;\n    export function pullEvent(): LuaMultiReturn<[string, Object]>;\n    export function filterEvent(...types: string[]): LuaMultiReturn<[string, Object]>;\n    export function queueEvent(event: string, param: Object): void;\n    export function split(str: string, sep?: string, includeEmpty?: boolean): string[];\n    export function copy<T>(value: T): T;\n    export function addEventListener(event: string, callback: (event: string, param: Object) => boolean): void;\n    export function removeEventListener(event: string, callback: (event: string, param: Object) => boolean): void;\n    export function runEvents(): string;\n    export function startEvents(): number;\n    export function type(value: any): string;\n    export function crc32(str: string, polynomial?: number|number[], crc?: number): number;\n}",created=1704748611496,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1435},["serialization.d.ts"]={modified=1704748611478,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"system.serialization\" {\n    /** @noSelf **/\n    export namespace base64 {\n        function encode(str: string): string;\n        function decode(str: string): string;\n    }\n    /** @noSelf **/\n    export namespace json {\n        function encode(val: any): string;\n        function decode(str: string): any;\n        function save(val: any, path: string): void;\n        function load(path: string): any;\n    }\n    /** @noSelf **/\n    export namespace lua {\n        type EncodeOptions = {minified?: boolean, allow_functions?: boolean};\n        type DecodeOptions = {allow_functions?: boolean};\n        function encode(val: any, opts?: EncodeOptions): string;\n        function decode(str: string, opts?: DecodeOptions): any;\n        function save(val: any, path: string, opts?: EncodeOptions): void;\n        function load(path: string, opts?: DecodeOptions): any;\n    }\n}",created=1704748611494,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=926},["events.d.ts"]={modified=1704748611469,data="type AlarmEvent = {id: number};\ntype CharEvent = {character: string};\ntype ComputerCommandEvent = {args: string[]};\ntype DiskEvent = {device: string};\ntype DiskEjectEvent = {device: string};\ntype HandleStatusChangeEvent = {id: number, status: string};\ntype KeyEvent = {keycode: number, isRepeat: boolean};\ntype KeyUpEvent = {keycode: number};\ntype ModemMessageEvent = {device: string, channel: number, replyChannel: number, message: any, distance: number};\ntype MonitorResizeEvent = {device: string};\ntype MouseClickEvent = {button: number, x: number, y: number, buttonMask: number, device: string|null};\ntype MouseUpEvent = {button: number, x: number, y: number, buttonMask: number, device: string|null};\ntype MouseDragEvent = {button: number, x: number, y: number, buttonMask: number, device: string|null};\ntype MouseScrollEvent = {direction: boolean, x: number, y: number, buttonMask: number, device: string|null};\ntype PasteEvent = {text: string};\ntype DeviceAddedEvent = {device: string};\ntype DeviceRemovedEvent = {device: string};\ntype RedstoneEvent = {};\ntype HandleDataReadyEvent = {id: number};\ntype SpeakerAudioEmptyEvent = {device: string};\ntype TaskCompleteEvent = {id: number, success: boolean, results: any[]};\ntype TermResizeEvent = {};\ntype TimerEvent = {id: number};\ntype TurtleInventoryEvent = {};\ntype ProcessCompleteEvent = {pid: number, thread: number, value: any|null, n: number|null, error: string|null, traceback: string|null} & any[];",created=1704748611484,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1460},["tsconfig.json"]={modified=1704748611480,data="{\n    \"compilerOptions\": {\n        \"target\": \"ESNext\",\n        \"lib\": [\"ESNext\"],\n        \"moduleResolution\": \"node\",\n        \"strict\": false,\n        \"types\": [\"@jackmacwindows/lua-types/cc\"]\n    },\n}",created=1704748611496,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=201},["log.d.ts"]={modified=1704748611475,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"system.log\" {\n    type LogOptions = {\n        name: string|null,\n        category: string|null,\n        level: 0|1|2|3|4|5|\"debug\"|\"info\"|\"notice\"|\"warning\"|\"error\"|\"critical\"|null,\n        time: number|null,\n        process: number|null,\n        thread: number|null,\n        module: string|null,\n        traceback: boolean|null\n    }\n    /** @noSelf **/\n    interface Log {\n        log(options: LogOptions, ...args: any[]): void;\n        log(...args: any[]): void;\n        debug(options: LogOptions, ...args: any[]): void;\n        debug(...args: any[]): void;\n        info(options: LogOptions, ...args: any[]): void;\n        info(...args: any[]): void;\n        notice(options: LogOptions, ...args: any[]): void;\n        notice(...args: any[]): void;\n        warning(options: LogOptions, ...args: any[]): void;\n        warning(...args: any[]): void;\n        warn(options: LogOptions, ...args: any[]): void;\n        warn(...args: any[]): void;\n        error(options: LogOptions, ...args: any[]): void;\n        error(...args: any[]): void;\n        crtitical(options: LogOptions, ...args: any[]): void;\n        crtitical(...args: any[]): void;\n        traceback(message: string): void;\n    }\n\n    const log: Log & {\n        levels: {debug: number, info: number, notice: number, warning: number, error: number, critical: number},\n        create(this: void, name: string, streamed?: boolean, file?: string): Log,\n        remove(this: void, name: string): void,\n        open(this: void, name: string, filter?: string): number,\n        close(this: void, name: string|number): void,\n        setTTY(this: void, name: string, tty: TTY|null, level?: number): void\n    } & {[name: string]: Log};\n    export = log;\n}",created=1704748611490,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1763},["terminal.d.ts"]={modified=1704748611480,data="/** @noSelfInFile **/\ntype Color = 0|1|2|3|4|5|6|7|8|9|10|11|12|13|14|15;\ntype Colour = Color;\n\n/** @noSelf **/\ndeclare interface ITerminalBase {\n    close(): void;\n    clear(): void;\n    getSize(): LuaMultiReturn<[number, number]>;\n    getPaletteColor(color: Color): LuaMultiReturn<[number, number, number]>;\n    setPaletteColor(color: Color, rgb: number): void;\n    setPaletteColor(color: Color, r: number, g: number, b: number): void;\n    getPaletteColour(colour: Color): LuaMultiReturn<[number, number, number]>;\n    setPaletteColour(colour: Color, rgb: number): void;\n    setPaletteColour(colour: Color, r: number, g: number, b: number): void;\n}\n\n/** @noSelf **/\ndeclare interface Terminal extends ITerminalBase {\n    write(text: string): void;\n    blit(text: string, fg: string, bg: string): void;\n    clearLine(): void;\n    getCursorPos(): LuaMultiReturn<[number, number]>;\n    setCursorPos(x: number, y: number): void;\n    getCursorBlink(): boolean;\n    setCursorBlink(blink: boolean): void;\n    isColor(): boolean;\n    isColour(): boolean;\n    scroll(lines: number): void;\n    getTextColor(): Color;\n    setTextColor(color: Color): void;\n    getBackgroundColor(): Color;\n    setBackgroundColor(color: Color): void;\n    getTextColour(): Color;\n    setTextColour(colour: Color): void;\n    getBackgroundColour(): Color;\n    setBackgroundColour(colour: Color): void;\n    getLine(y: number): LuaMultiReturn<[string, string, string]>;\n}\n\n/** @noSelf **/\ndeclare interface GFXTerminal extends ITerminalBase {\n    getPixel(x: number, y: number): number;\n    setPixel(x: number, y: number, color: number): void;\n    getPixels(x: number, y: number, width: number, height: number, asStr?: false): Color[][];\n    getPixels(x: number, y: number, width: number, height: number, asStr: true): string[];\n    drawPixels(x: number, y: number, data: ((Color|null)[]|string)[], width?: number, height?: number): void;\n    drawPixels(x: number, y: number, data: number, width: number, height: number): void;\n    getFrozen(): boolean;\n    setFrozen(frozen: boolean): void;\n}\n\ntype TTY = [string, string, string][] & {\n    isTTY: true,\n    flags: {\n        cbreak: boolean,\n        delay: boolean,\n        echo: boolean,\n        keypad: boolean,\n        nlcr: boolean,\n        raw: boolean\n    },\n    cursor: {x: number, y: number},\n    cursorBlink: boolean,\n    colors: {fg: string, bg: string, bold: boolean},\n    size: {width: number, height: number},\n    dirtyLines: number[],\n    palette: [number, number, number][],\n    dirtyPalette: number[],\n    buffer: string,\n    preBuffer: string,\n    isLocked: boolean,\n    isGraphics: boolean,\n    textBuffer: [string, string, string][] & {\n        cursor: {x: number, y: number},\n        cursorBlink: boolean,\n        colors: {fg: string, bg: string, bold: boolean},\n        dirtyLines: number[],\n        palette: [number, number, number][],\n        dirtyPalette: number[]\n    },\n    graphicsBuffer: string[] & {\n        palette: [number, number, number][],\n        dirtyPalette: number[],\n        dirtyRects: ({x: number, y: number, color: Color} | {x: number, y: number, width: number, height: number})[],\n        frozen: boolean\n    },\n    eof: boolean\n};\n\ntype TermFlags = {\n    cbreak?: boolean,\n    delay?: boolean,\n    echo?: boolean,\n    keypad?: boolean,\n    nlcr?: boolean,\n    raw?: boolean\n};\n\n/** @noResolution **/\ndeclare module \"system.terminal\" {\n    type _Colors = {\n        white: Color,\n        orange: Color,\n        magenta: Color,\n        lightBlue: Color,\n        yellow: Color,\n        lime: Color,\n        pink: Color,\n        gray: Color,\n        grey: Color,\n        lightGray: Color,\n        lightGrey: Color,\n        cyan: Color,\n        purple: Color,\n        blue: Color,\n        brown: Color,\n        green: Color,\n        red: Color,\n        black: Color\n    };\n    export interface Readable {\n        read(count?: number): string|null;\n    }\n    export interface Writable {\n        write(str: string): void;\n    }\n\n    export const colors: _Colors;\n    export const colours: _Colors;\n    export function toEscape(color: Color, background?: boolean): string;\n    export function write(...args: any[]): void;\n    export function writeerr(...args: any[]): void;\n    export function read(n: number): string|null;\n    export function readline(): string|null;\n    export function readline2(history?: string[], completion?: (partial: string) => string[]): string|null;\n    export function termctl(flags?: TermFlags): TermFlags|null;\n    export function openterm(): LuaMultiReturn<[Terminal] | [null, string]>;\n    export function opengfx(): LuaMultiReturn<[GFXTerminal] | [null, string]>;\n    export function mktty(width: number, height: number): TTY;\n    export function stdin(handle: number|TTY|Readable|null): void;\n    export function stdout(handle: number|TTY|Writable|null): void;\n    export function stderr(handle: number|TTY|Writable|null): void;\n    export function istty(): LuaMultiReturn<[boolean, boolean]>;\n    export function termsize(): LuaMultiReturn<[number, number] | []>;\n}",created=1704748611495,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=5053},["process.d.ts"]={modified=1704748611478,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"system.process\" {\n    export type ProcessInfo = {\n        id: number,\n        name: string,\n        user: string,\n        parent: number | null,\n        dir: string,\n        stdin: number | null,\n        stdout: number | null,\n        stderr: number | null,\n        cputime: number,\n        systime: number,\n        threads: {id: number, name: string, status: string}[];\n    };\n    export function getpid(): number;\n    export function getppid(): number;\n    export function getuser(): string;\n    export function setuser(user: string): void;\n    export function clock(): number;\n    export function getenv(): LuaTable;\n    export function getname(): string;\n    export function getcwd(): string;\n    export function chdir(dir: string): void;\n    export function fork(func: Function, name: string, ...args: any[]): number;\n    export function exec(path: string, ...args: any[]): never;\n    export function execp(command: string, ...args: any[]): never;\n    export function start(path: string, ...args: any[]): number;\n    export function run(path: string, ...args: any[]): LuaMultiReturn<[true, any] | [false, string]>;\n    export function newthread(func: Function, ...args: any[]): number;\n    export function exit(code?: number): never;\n    export function getplist(): number[];\n    export function getpinfo(pid: number): ProcessInfo|null;\n    export function nice(level: number, pid?: number): void;\n}",created=1704748611493,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1464},["network.d.ts"]={modified=1704748611476,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"system.network\" {\n    export interface NetworkHandle {\n        status(): LuaMultiReturn<[\"ready\"|\"connecting\"|\"error\"|\"open\"|\"closed\", string|null]>;\n        read(...mode: (\"*a\"|\"*l\"|\"*L\"|\"*n\"|\"a\"|\"l\"|\"L\"|\"n\"|number)[]): LuaMultiReturn<(string|number|null)[]>;\n        read(mode: \"*a\"|\"*l\"|\"*L\"|\"a\"|\"l\"|\"L\"|number): string|null;\n        read(mode: \"*n\"|\"n\"): number|null;\n        write(...data: any[]): void;\n        close(): void;\n    }\n    export interface HTTPHandle extends NetworkHandle {\n        responseHeaders(): Object;\n        responseCode(): number;\n    }\n    export type ConnectOptions = {\n        url: string,\n        encoding: \"utf8\" | \"utf-8\" | \"binary\" | null,\n        headers: Object | null,\n        method: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"OPTIONS\" | \"HEAD\" | null,\n        redirect: boolean | null,\n        device: string | null\n    };\n    export type IPConfig = {\n        ip: string|number,\n        netmask: number|string,\n        up: boolean\n    };\n    export type Route = {\n        source: string,\n        sourceNetmask: number,\n        action: \"unicast\" | \"broadcast\" | \"local\" | \"unreachable\" | \"prohibit\" | \"blackhole\",\n        device: string | null,\n        destination: string | null\n    };\n\n    export function connect(options: string|ConnectOptions): LuaMultiReturn<[NetworkHandle|null, null|string]>;\n    export function get(options: string|ConnectOptions): LuaMultiReturn<[NetworkHandle|null, null|string]>;\n    export function head(options: string|ConnectOptions): LuaMultiReturn<[NetworkHandle|null, null|string]>;\n    export function options(options: string|ConnectOptions): LuaMultiReturn<[NetworkHandle|null, null|string]>;\n    export function post(options: string|ConnectOptions): LuaMultiReturn<[NetworkHandle|null, null|string]>;\n    export function put(options: string|ConnectOptions): LuaMultiReturn<[NetworkHandle|null, null|string]>;\n    export function getData(url: string, headers?: Object): LuaMultiReturn<[string|null, null|string]>;\n    export function listen(uri: string): void;\n    export function unlisten(uri: string): void;\n    export function ipconfig(device: string, info?: IPConfig): IPConfig|null;\n    export function control(ip: string, type: string, err?: string): void;\n    export function events(state?: boolean): boolean;\n    export function checkURI(uri: string): boolean;\n    /** @noSelf **/\n    export namespace route {\n        function list(num?: number): Route[];\n        function add(options: Route & {table: number | null}): void;\n        function remove(source: string, mask: number, num?: number): void;\n    }\n    /** @noSelf **/\n    export namespace arp {\n        function list(device: string): {[ip: string]: number};\n        function set(device: string, ip: string, id: number|null): void;\n    }\n}",created=1704748611491,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=2835},["keys.d.ts"]={modified=1704748611474,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"system.keys\" {\n    type Key = number;\n    const keys: {\n        a: Key;\n        apostrophe: Key;\n        at: Key;\n        ax: Key;\n        b: Key;\n        backslash: Key;\n        backspace: Key;\n        c: Key;\n        capsLock: Key;\n        circumflex: Key;\n        colon: Key;\n        comma: Key;\n        convert: Key;\n        d: Key;\n        down: Key;\n        e: Key;\n        eight: Key;\n        end: Key;\n        enter: Key;\n        equals: Key;\n        f: Key;\n        f1: Key;\n        f10: Key;\n        f11: Key;\n        f12: Key;\n        f13: Key;\n        f14: Key;\n        f15: Key;\n        f2: Key;\n        f3: Key;\n        f4: Key;\n        f5: Key;\n        f6: Key;\n        f7: Key;\n        f8: Key;\n        f9: Key;\n        five: Key;\n        four: Key;\n        g: Key;\n        grave: Key;\n        h: Key;\n        home: Key;\n        i: Key;\n        insert: Key;\n        j: Key;\n        k: Key;\n        kana: Key;\n        kanji: Key;\n        l: Key;\n        left: Key;\n        leftAlt: Key;\n        leftBracket: Key;\n        leftCtrl: Key;\n        leftShift: Key;\n        m: Key;\n        minus: Key;\n        multiply: Key;\n        n: Key;\n        nine: Key;\n        noconvert: Key;\n        numLock: Key;\n        numPad0: Key;\n        numPad1: Key;\n        numPad2: Key;\n        numPad3: Key;\n        numPad4: Key;\n        numPad5: Key;\n        numPad6: Key;\n        numPad7: Key;\n        numPad8: Key;\n        numPad9: Key;\n        numPadAdd: Key;\n        numPadComma: Key;\n        numPadDecimal: Key;\n        numPadDivide: Key;\n        numPadEnter: Key;\n        numPadEquals: Key;\n        numPadSubtract: Key;\n        o: Key;\n        one: Key;\n        p: Key;\n        pageDown: Key;\n        pageUp: Key;\n        pause: Key;\n        period: Key;\n        q: Key;\n        r: Key;\n        returnKey: Key;\n        right: Key;\n        rightAlt: Key;\n        rightBracket: Key;\n        rightCtrl: Key;\n        rightShift: Key;\n        s: Key;\n        scrollLock: Key;\n        semiColon: Key;\n        seven: Key;\n        six: Key;\n        slash: Key;\n        space: Key;\n        stop: Key;\n        t: Key;\n        tab: Key;\n        three: Key;\n        two: Key;\n        u: Key;\n        underscore: Key;\n        up: Key;\n        v: Key;\n        w: Key;\n        x: Key;\n        y: Key;\n        yen: Key;\n        z: Key;\n        zero: Key;\n        getName(this: void, k: Key): string|null;\n        getCharacter(this: void, k: Key): string|null;\n    }\n    export = keys;\n}",created=1704748611489,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=2532},["package.json"]={modified=1704748611476,data="{\r\n    \"name\": \"@phoenix-cc/libsystem\",\r\n    \"version\": \"1.1.3\",\r\n    \"description\": \"Typing package for Phoenix libsystem.\",\r\n    \"types\": \"./index.d.ts\",\r\n    \"files\": [\"./*.d.ts\"],\r\n    \"dependencies\": {\r\n        \"@jackmacwindows/lua-types\": \"^2.13.1\"\r\n    },\r\n    \"author\": \"JackMacWindows\",\r\n    \"license\": \"GPLv2+\"\r\n}",created=1704748611492,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=323},["ipc.d.ts"]={modified=1704748611474,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"system.ipc\" {\n    export const signal: {\n        SIGHUP: number,\n        SIGINT: number,\n        SIGQUIT: number,\n        SIGTRAP: number,\n        SIGABRT: number,\n        SIGKILL: number,\n        SIGPIPE: number,\n        SIGTERM: number,\n        SIGCONT: number,\n        SIGSTOP: number,\n        SIGTTIN: number,\n        SIGTTOU: number\n    };\n    export function kill(pid: number, signal: number): void;\n    export function sigaction(signal: number, fn: ((signal: number) => void) | (() => void) | null): void;\n    export function sendEvent(pid: number, event: string, param: Object): boolean;\n    export function register(name: string): boolean;\n    export function lookup(name: string): number|null;\n    export function sendServiceEvent(name: string, event: string, param: Object): boolean;\n    export function receiveEvent(pid?: number, event?: string, timeout?: number): LuaMultiReturn<[string, Object] | [null, null]>;\n}",created=1704748611488,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=987},["index.d.ts"]={modified=1704748611473,data="/// <reference path=\"events.d.ts\"/>\n/// <reference path=\"expect.d.ts\"/>\n/// <reference path=\"filesystem.d.ts\"/>\n/// <reference path=\"framebuffer.d.ts\"/>\n/// <reference path=\"graphics.d.ts\"/>\n/// <reference path=\"hardware.d.ts\"/>\n/// <reference path=\"ipc.d.ts\"/>\n/// <reference path=\"keys.d.ts\"/>\n/// <reference path=\"log.d.ts\"/>\n/// <reference path=\"network.d.ts\"/>\n/// <reference path=\"pretty.d.ts\"/>\n/// <reference path=\"process.d.ts\"/>\n/// <reference path=\"serialization.d.ts\"/>\n/// <reference path=\"sync.d.ts\"/>\n/// <reference path=\"terminal.d.ts\"/>\n/// <reference path=\"util.d.ts\"/>\n",created=1704748611488,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=588}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},libdeflate={modified=1704748611337,created=1704748611337,contents={["package.json"]={modified=1704748611331,data="{\n    \"name\": \"@phoenix-cc/libdeflate\",\n    \"version\": \"1.0.0\",\n    \"description\": \"Typing package for libdeflate.\",\n    \"types\": \"./index.d.ts\",\n    \"files\": [\"./*.d.ts\"],\n    \"dependencies\": {\n        \"@jackmacwindows/lua-types\": \"^2.13.1\"\n    },\n    \"author\": \"JackMacWindows\",\n    \"license\": \"GPLv2+\"\n}",created=1704748611336,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=306},["tsconfig.json"]={modified=1704748611332,data="{\n    \"compilerOptions\": {\n        \"target\": \"ESNext\",\n        \"lib\": [\"ESNext\"],\n        \"moduleResolution\": \"node\",\n        \"strict\": false,\n        \"types\": [\"@jackmacwindows/lua-types/cc\"]\n    },\n}",created=1704748611337,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=201},["index.d.ts"]={modified=1704748611330,data="/** @noResolution **/\ndeclare module \"LibDeflate\" {\n    export interface Dictionary {\n        adler32: number;\n        hash_tables: number[][];\n        string_table: string[];\n        strlen: number;\n    }\n    export type CompressionConfigs = {\n        level?: 0|1|2|3|4|5|6|7|8|9|null,\n        strategy?: \"fixed\" | \"huffman_only\" | \"dynamic\"\n    }\n\n    export function CRC32(str: string, crc?: number): number;\n    export function Adler32(str: string): number;\n    export function IsEqualAdler32(actual: number, expected: number): boolean;\n    export function CreateDictionary(str: string, strlen: number, adler32: number): Dictionary;\n    export function CompressDeflate(str: string, configs?: CompressionConfigs): LuaMultiReturn<[string, number]>;\n    export function CompressDeflateWithDict(str: string, dictionary: Dictionary, configs?: CompressionConfigs): LuaMultiReturn<[string, number]>;\n    export function CompressZlib(str: string, configs?: CompressionConfigs): LuaMultiReturn<[string, number]>;\n    export function CompressZlibWithDict(str: string, dictionary: Dictionary, configs?: CompressionConfigs): LuaMultiReturn<[string, number]>;\n}",created=1704748611336,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1152}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},ccryptolib={modified=1704748610580,created=1704748610580,contents={["chacha20.d.ts"]={modified=1704748610563,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"ccryptolib.chacha20\" {\n    export function crypt(key: string, nonce: string, message: string, rounds?: number, offset?: number): string;\n}",created=1704748610575,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=198},["util.d.ts"]={modified=1704748610569,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"ccryptolib.util\" {\n    export function toHex(str: string): string;\n    export function fromHex(hex: string): string | null;\n    export function compare(a: string, b: string): boolean;\n}",created=1704748610580,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=245},["poly1305.d.ts"]={modified=1704748610566,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"ccryptolib.poly1305\" {\n    export function mac(key: string, message: string): string;\n}",created=1704748610577,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=147},["ed25519.d.ts"]={modified=1704748610564,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"ccryptolib.ed25519\" {\n    export function publicKey(sk: string): string;\n    export function sign(sk: string, pk: string, msg: string): string;\n    export function verify(pk: string, msg: string, sig: string): boolean;\n}",created=1704748610576,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=280},["blake3.d.ts"]={modified=1704748610563,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"ccryptolib.blake3\" {\n    export function digest(message: string, len?: number): string;\n    export function digestKeyed(key: string, message: string, len?: number): string;\n    export function deriveKey(context: string): (material: string, len?: number) => string;\n}",created=1704748610574,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=326},["random.d.ts"]={modified=1704748610567,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"ccryptolib.random\" {\n    export function init(seed: string): void;\n    export function mix(data: string): void;\n    export function random(len: number): string;\n}",created=1704748610578,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=222},["x25519.d.ts"]={modified=1704748610570,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"ccryptolib.x25519\" {\n    export function publicKey(sk: string): string;\n    export function exchange(sk: string, pk: string): string;\n    export function exchangeEd(sk: string, pk: string): string;\n}",created=1704748610580,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=259},["aead.d.ts"]={modified=1704748610562,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"ccryptolib.aead\" {\n    export function encrypt(key: string, nonce: string, message: string, aad: string, rounds?: number): LuaMultiReturn<[string, string]>;\n    export function decrypt(key: string, nonce: string, tag: string, ciphertext: string, aad: string, rounds?: string): string | null;\n}",created=1704748610574,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=353},["tsconfig.json"]={modified=1704748610568,data="{\n    \"compilerOptions\": {\n        \"target\": \"ESNext\",\n        \"lib\": [\"ESNext\"],\n        \"moduleResolution\": \"node\",\n        \"strict\": false,\n        \"types\": [\"@jackmacwindows/lua-types/cc\"]\n    },\n}",created=1704748610579,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=201},["package.json"]={modified=1704748610566,data="{\n    \"name\": \"@phoenix-cc/ccryptolib\",\n    \"version\": \"1.0.1\",\n    \"description\": \"Typing package for Phoenix/CraftOS ccryptolib.\",\n    \"types\": \"./index.d.ts\",\n    \"files\": [\"./*.d.ts\"],\n    \"dependencies\": {\n        \"@jackmacwindows/lua-types\": \"^2.13.1\"\n    },\n    \"author\": \"JackMacWindows\",\n    \"contributors\": [\"migeyel\"],\n    \"license\": \"MIT\"\n}",created=1704748610577,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=352},["sha256.d.ts"]={modified=1704748610568,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"ccryptolib.sha256\" {\n    export function digest(data: string): string;\n    export function pbkdf2(password: string, salt: string, iter: number, progress?: (iter: number) => void): string;\n}",created=1704748610579,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=249},["index.d.ts"]={modified=1704748610565,data="/// <reference path=\"aead.d.ts\"/>\n/// <reference path=\"blake3.d.ts\"/>\n/// <reference path=\"chacha20.d.ts\"/>\n/// <reference path=\"ed25519.d.ts\"/>\n/// <reference path=\"poly1305.d.ts\"/>\n/// <reference path=\"random.d.ts\"/>\n/// <reference path=\"sha256.d.ts\"/>\n/// <reference path=\"util.d.ts\"/>\n/// <reference path=\"x25519.d.ts\"/>",created=1704748610576,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=324}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},muxzcat={modified=1704748611649,created=1704748611649,contents={["package.json"]={modified=1704748611643,data="{\n    \"name\": \"@phoenix-cc/muxzcat\",\n    \"version\": \"1.0.0\",\n    \"description\": \"Typing package for muxzcat.\",\n    \"types\": \"./index.d.ts\",\n    \"files\": [\"./*.d.ts\"],\n    \"dependencies\": {\n        \"@jackmacwindows/lua-types\": \"^2.13.1\"\n    },\n    \"author\": \"JackMacWindows\",\n    \"license\": \"GPLv2+\"\n}",created=1704748611648,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=300},["tsconfig.json"]={modified=1704748611644,data="{\n    \"compilerOptions\": {\n        \"target\": \"ESNext\",\n        \"lib\": [\"ESNext\"],\n        \"moduleResolution\": \"node\",\n        \"strict\": false,\n        \"types\": [\"@jackmacwindows/lua-types/cc\"]\n    },\n}",created=1704748611649,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=201},["index.d.ts"]={modified=1704748611642,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"muxzcat\" {\n    export function DecompressXzOrLzmaFile(input: string|LuaFile, output: string|LuaFile): LuaMultiReturn<[boolean, number]>;\n    export function DecompressXzOrLzmaString(input: string): LuaMultiReturn<[string, number|null] | [null, number]>;\n    export function GetError(err: number): string|null;\n    export const Errors: {\n        UNKNOWN_ERROR: number,\n        OK: number,\n        ERROR_DATA: number,\n        ERROR_MEM: number,\n        ERROR_CRC: number,\n        ERROR_UNSUPPORTED: number,\n        ERROR_PARAM: number,\n        ERROR_INPUT_EOF: number,\n        ERROR_OUTPUT_EOF: number,\n        ERROR_READ: number,\n        ERROR_WRITE: number,\n        ERROR_FINISHED_WITH_MARK: number,\n        ERROR_NOT_FINISHED: number,\n        ERROR_NEEDS_MORE_INPUT: number,\n        ERROR_CHUNK_NOT_CONSUMED: number,\n        ERROR_NEEDS_MORE_INPUT_PARTIAL: number,\n        ERROR_BAD_MAGIC: number,\n        ERROR_BAD_STREAM_FLAGS: number,\n        ERROR_UNSUPPORTED_FILTER_COUNT: number,\n        ERROR_BAD_BLOCK_FLAGS: number,\n        ERROR_UNSUPPORTED_FILTER_ID: number,\n        ERROR_UNSUPPORTED_FILTER_PROPERTIES_SIZE: number,\n        ERROR_BAD_PADDING: number,\n        ERROR_BLOCK_HEADER_TOO_LONG: number,\n        ERROR_BAD_CHUNK_CONTROL_BYTE: number,\n        ERROR_BAD_CHECKSUM_TYPE: number,\n        ERROR_BAD_DICTIONARY_SIZE: number,\n        ERROR_UNSUPPORTED_DICTIONARY_SIZE: number,\n        ERROR_FEED_CHUNK: number,\n        ERROR_NOT_FINISHED_WITH_MARK: number,\n        ERROR_BAD_DICPOS: number,\n        ERROR_MISSING_INITPROP: number,\n        ERROR_BAD_LCLPPB_PROP: number\n    }\n}",created=1704748611648,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1649}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},sha2={modified=1704748612477,created=1704748612477,contents={["package.json"]={modified=1704748612468,data="{\n    \"name\": \"@phoenix-cc/sha2\",\n    \"version\": \"12.0.0\",\n    \"description\": \"Typing package for sha2.\",\n    \"types\": \"./index.d.ts\",\n    \"files\": [\"./*.d.ts\"],\n    \"dependencies\": {\n        \"@jackmacwindows/lua-types\": \"^2.13.1\"\n    },\n    \"author\": \"JackMacWindows\",\n    \"license\": \"GPLv2+\"\n}",created=1704748612476,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=295},["tsconfig.json"]={modified=1704748612468,data="{\n    \"compilerOptions\": {\n        \"target\": \"ESNext\",\n        \"lib\": [\"ESNext\"],\n        \"moduleResolution\": \"node\",\n        \"strict\": false,\n        \"types\": [\"@jackmacwindows/lua-types/cc\"]\n    },\n}",created=1704748612477,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=201},["index.d.ts"]={modified=1704748612467,data="/** @noSelfInFile **/\n/** @noResolution **/\ndeclare module \"sha2\" {\n    export type MessageBuilder = ((message: string) => MessageBuilder) & (() => string);\n    export type ChunkedMessageBuilder = ((message: string) => ChunkedMessageBuilder) & (() => (() => string));\n    export function md5(message: string): string;\n    export function md5(): MessageBuilder;\n    export function sha1(message: string): string;\n    export function sha1(): MessageBuilder;\n    export function sha224(message: string): string;\n    export function sha224(): MessageBuilder;\n    export function sha256(message: string): string;\n    export function sha256(): MessageBuilder;\n    export function sha512_224(message: string): string;\n    export function sha512_224(): MessageBuilder;\n    export function sha512_256(message: string): string;\n    export function sha512_256(): MessageBuilder;\n    export function sha384(message: string): string;\n    export function sha384(): MessageBuilder;\n    export function sha512(message: string): string;\n    export function sha512(): MessageBuilder;\n    export function sha3_224(message: string): string;\n    export function sha3_224(): MessageBuilder;\n    export function sha3_256(message: string): string;\n    export function sha3_256(): MessageBuilder;\n    export function sha3_384(message: string): string;\n    export function sha3_384(): MessageBuilder;\n    export function sha3_512(message: string): string;\n    export function sha3_512(): MessageBuilder;\n    export function shake128(digest_size_in_bytes: number, message: string): string;\n    export function shake128(digest_size_in_bytes: number): MessageBuilder;\n    export function shake256(digest_size_in_bytes: number, message: string): string;\n    export function shake256(digest_size_in_bytes: number): MessageBuilder;\n    export function hmac(hash_func: () => MessageBuilder, key: string, message: string): string;\n    export function hmac(hash_func: () => MessageBuilder, key: string): MessageBuilder;\n    export function hex_to_bin(hex: string): string;\n    export function bin_to_hex(bin: string): string;\n    export function base64_to_bin(base64: string): string;\n    export function bin_to_base64(bin: string): string;\n    export function hex2bin(hex: string): string;\n    export function bin2hex(bin: string): string;\n    export function base642bin(base64: string): string;\n    export function bin2base64(bin: string): string;\n    export function blake2b(message: string, key?: string, salt?: string, digest_size_in_bytes?: number): string;\n    export function blake2b(message: null, key?: string, salt?: string, digest_size_in_bytes?: number): MessageBuilder;\n    export function blake2s(message: string, key?: string, salt?: string, digest_size_in_bytes?: number): string;\n    export function blake2s(message: null, key?: string, salt?: string, digest_size_in_bytes?: number): MessageBuilder;\n    export function blake2bp(message: string, key?: string, salt?: string, digest_size_in_bytes?: number): string;\n    export function blake2bp(message: null, key?: string, salt?: string, digest_size_in_bytes?: number): MessageBuilder;\n    export function blake2sp(message: string, key?: string, salt?: string, digest_size_in_bytes?: number): string;\n    export function blake2sp(message: null, key?: string, salt?: string, digest_size_in_bytes?: number): MessageBuilder;\n    export function blake2xs(digest_size_in_bytes: number, message: string, key?: string, salt?: string): string | (() => string);\n    export function blake2xs(digest_size_in_bytes: message: null, key?: string, salt?: string): MessageBuilder | ChunkedMessageBuilder;\n    export function blake2xb(digest_size_in_bytes: number, message: string, key?: string, salt?: string): string | (() => string);\n    export function blake2xb(digest_size_in_bytes: message: null, key?: string, salt?: string): MessageBuilder | ChunkedMessageBuilder;\n    export function blake2(message: string, key?: string, salt?: string, digest_size_in_bytes?: number): string;\n    export function blake2(message: null, key?: string, salt?: string, digest_size_in_bytes?: number): MessageBuilder;\n    export function blake2b_160(message: string, key?: string, salt?: string): string;\n    export function blake2b_160(message: null, key?: string, salt?: string): MessageBuilder;\n    export function blake2b_256(message: string, key?: string, salt?: string): string;\n    export function blake2b_256(message: null, key?: string, salt?: string): MessageBuilder;\n    export function blake2b_384(message: string, key?: string, salt?: string): string;\n    export function blake2b_384(message: null, key?: string, salt?: string): MessageBuilder;\n    export function blake2b_512(message: string, key?: string, salt?: string): string;\n    export function blake2b_512(message: null, key?: string, salt?: string): MessageBuilder;\n    export function blake2s_128(message: string, key?: string, salt?: string): string;\n    export function blake2s_128(message: null, key?: string, salt?: string): MessageBuilder;\n    export function blake2s_160(message: string, key?: string, salt?: string): string;\n    export function blake2s_160(message: null, key?: string, salt?: string): MessageBuilder;\n    export function blake2s_224(message: string, key?: string, salt?: string): string;\n    export function blake2s_224(message: null, key?: string, salt?: string): MessageBuilder;\n    export function blake2s_256(message: string, key?: string, salt?: string): string;\n    export function blake2s_256(message: null, key?: string, salt?: string): MessageBuilder;\n    export function blake3(message: string, key?: string, digest_size_in_bytes?: number): string | (() => string);\n    export function blake3(message: null, key?: string, digest_size_in_bytes?: number): MessageBuilder | ChunkedMessageBuilder;\n    export function blake3_derive_key(key_material: string, context_string: string, digest_size_in_bytes?: number): string | (() => string);\n    export function blake3_derive_key(key_material: null, context_string: string, digest_size_in_bytes?: number): MessageBuilder | ChunkedMessageBuilder;\n}",created=1704748612475,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=6100}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},bin={modified=1704748613142,created=1704748613142,contents={["userdel.lua"]={modified=1704748612973,data="local a=require\"usermgr\"local b=require\"system.filesystem\"local c=require\"system.process\"local d=require\"system.util\"local e=[[\nUsage: userdel [options] LOGIN\nOptions:\n  -f, --force   force some actions that would fail otherwise\n                e.g. removal of user still logged in\n                or files, even if not owned by the user\n  -h, --help    display this help message and exit\n  -r, --remove  remove home directory\n]]local f=assert(d.argparse({f=false,force=\"@f\",h=false,help=\"@h\",r=false,remove=\"@r\"},...))if f.h then print(e)return end;if not f[1]then io.stdout:write(e..\"\\n\")return false end;if c.getuser()~=\"root\"then error(\"userdel: Permission denied.\")end;local g=a.getUserInfo(f[1])if not g then error(\"userdel: User does not exist.\")end;if not f.f then local h=c.getplist()for i,j in ipairs(h)do if c.getpinfo(j).user==f[1]then error(\"userdel: User is currently logged in.\")end end end;assert(a.removeUser(f[1]),\"userdel: Could not delete user.\")if f.r and g.home then b.remove(g.home)end\n",created=1704748613029,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1009},["arp.lua"]={modified=1704748611760,data="local a=require\"system.hardware\"local b=require\"system.network\"local c=require\"system.util\"local d=assert(c.argparse({s=false,set=\"@s\",d=false,delete=\"@d\",f=true,file=\"@f\",i=true,device=\"@i\"},...))local e;if d.i then e={a.get(d.i)}else e={a.find(\"modem\")}end;if d.s then local f,g=d[1],tonumber(d[2])if not g or not f or not f:match\"^%d+%.%d+%.%d+%.%d+$\"then error(\"Usage: arp [options] -s <ip> <id>\")end;for h,i in ipairs(e)do local j=a.path(i)b.arp.set(j,f,g)end elseif d.d then local f=d[1]if not f or not f:match\"^%d+%.%d+%.%d+%.%d+$\"then error(\"Usage: arp [options] -d <ip>\")end;for h,i in ipairs(e)do local j=a.path(i)b.arp.set(j,f,nil)end elseif d.f then for k in io.lines(d.f)do local f,g=k:match(\"^(%S+)%s+(%d+)\")if f and g then for h,i in ipairs(e)do local j=a.path(i)b.arp.set(j,f,tonumber(g))end end end else print(\"Address\\t\\tID\\tDevice\")for h,i in ipairs(e)do local j=a.path(i)local l=b.arp.list(j)for m,n in pairs(l)do print(m,n,j)end end end\n",created=1704748611765,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=958},["ping.lua"]={modified=1704748611762,data="local a=require\"system.util\"local b=require\"system.process\"local c=assert(...)print(\"Pinging \"..c..\"...\")a.syscall.netevent(true)local d={}b.newthread(function()while true do local e,f=coroutine.yield()if e==\"network_event\"and f.type==\"control\"and f.sender==c then if f.messageType==\"pong\"then local g=tonumber(f.payload.payload.error)local h=(os.time()-d[g][1])*1000;print(\"Response from \"..c..\": seq=\"..g..\" time=\"..(h>=1000 and\"%d\"or\"%.3g\"):format(h)..\" ms\")d[g]=nil elseif f.messageType==\"unreachable\"then print(f.error or\"Destination unreachable\")end elseif e==\"timer\"then for i,j in pairs(d)do if j[2]==f.id then print(\"Host is down\")d[i]=nil end end end end end)local i=1;while true do d[i]={os.time(),a.syscall.timer(2)}a.syscall.netcontrol(c,\"ping\",tostring(i))i=i+1;a.sleep(1)end\n",created=1704748611767,owner="root",setuser=true,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=790},["nc.lua"]={modified=1704748611761,data="\n",created=1704748611766,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1},["dpkg-deb.lua"]={modified=1704748610841,data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=require\"ar\"local d=require\"dpkg.deb\"local e=require\"tar\"local function f(g)return string.match(g,'^()[%s%z]*$')and''or string.match(g,'^[%s%z]*(.*[^%s%z])')end;local function h(i,j,k)return string.len(i)<j and string.sub(i,1,j)..string.rep(k or\" \",j-string.len(i))or i end;local function l(i,j,k)return string.len(i)<j and string.rep(k or\" \",j-string.len(i))..string.sub(i,1,j)or i end;local function m(n,o,p)a.mkdir(o)local q={}for r,s in pairs(n)do if r~=\"//\"and type(r)==\"string\"then local t=a.combine(o,r)if s[\"//\"]~=nil then local u=m(s,t,true)for v,w in pairs(u)do table.insert(q,w)end elseif s.type==1 or s.type==2 then table.insert(q,s)elseif s.type==0 or s.type==7 then local x=a.open(t,\"wb\")for g in string.gmatch(s.data,\".\")do x.write(string.byte(g))end;x.close()if s.owner~=nil then a.chmod(t,nil,bit32.band(s.mode,7))if s.ownerName~=nil and s.ownerName~=\"\"then a.chmod(t,s.ownerName,bit32.band(bit32.rshift(s.mode,3),7))a.chown(t,s.ownerName)elseif s.owner==0 then a.chmod(t,\"root\",bit32.band(bit32.rshift(s.mode,3),7))a.chown(t,\"root\")end end elseif s.type~=nil then print(\"Unimplemented type \"..s.type)end;if d.verbose then print((s[\"//\"]and s[\"//\"].name or s.name or\"?\")..\" => \"..(t or\"?\"))end end end;if p then return q else for r,s in pairs(q)do end end end;local function y(z,i,k)local A=\"\"for B=1,string.len(i)do A=A..(bit32.band(z,bit32.lshift(1,string.len(i)-B))==0 and k or string.sub(i,B,B))end;return A end;local C=nil;local D=false;local E=5;local F=\"${Package}\\t${Version}\\n\"local G=true;local H=true;local I={}for r,s in pairs({...})do if s==\"-b\"or s==\"--build\"then C=0 elseif s==\"-I\"or s==\"--info\"then C=1 elseif s==\"-W\"or s==\"--show\"then C=2 elseif s==\"-f\"or s==\"--field\"then C=3 elseif s==\"-c\"or s==\"--contents\"then C=4 elseif s==\"-x\"or s==\"--extract\"then C=5 elseif s==\"-X\"or s==\"--vextract\"then C=5;d.verbose=true elseif s=='-R'or s==\"--raw-extract\"then C=7 elseif s==\"--ctrl-tarfile\"then C=5;D=true elseif s==\"--fsys-tarfile\"then C=6;D=true elseif s==\"-e\"or s==\"--control\"then C=6 elseif s==\"-?\"or s==\"--help\"then print([[Usage: dpkg-deb [<option> ...] <command>\nCommands:\n  -b|--build <directory> [<deb>]     Build an archive.\n  -c|--contents <deb>                List contents.\n  -I|--info <deb> [<cfile> ...]      Show info to stdout.\n  -W|--show <deb>                    Show information on package(s)\n  -f|--field <deb> [<cfield> ...]    Show field(s) to stdout.\n  -e|--control <deb> [<directory>]   Extract control info.\n  -x|--extract <deb> <directory>     Extract files.\n  -X|--vextract <deb> <directory>    Extract & list files.\n  -R|--raw-extract <deb> <directory> Extract control info and files.\n  --ctrl-tarfile <deb>               Output control tarfile.\n  --fsys-tarfile <deb>               Output filesystem tarfile.\n  -?, --help                         Show this help message.\n      --version                      Show the version.]])return 2 elseif s==\"--version\"then print(\"dpkg-deb v1.0\\nPart of apt-lua for Phoenix\\nCopyright (c) 2019-2022 JackMacWindows.\")return 2 elseif string.find(s,\"--showformat=\")==1 then F=string.sub(s,14)elseif string.sub(s,1,2)==\"-z\"then E=tonumber(string.sub(s,3))elseif s==\"--no-uniform-compression\"then G=false elseif s==\"--uniform-compression\"then G=true elseif s==\"--nocheck\"then H=false elseif s==\"-v\"or s==\"--verbose\"then d.verbose=true else table.insert(I,s)end end;F=string.gsub(string.gsub(F,\"\\\\n\",\"\\n\"),\"\\\\t\",\"\\t\")if C==0 then if#I<1 then error(\"Usage: dpkg-deb [options...] --build <binary-directory> [archive|directory]\")end;local J=I[1]local K=I[2]or J..\".deb\"if not a.isDir(J)then error(J..\" is not a directory\")elseif not a.isDir(a.combine(J,\"DEBIAN\"))then error(\"A subdirectory named DEBIAN is required.\")end;if d.verbose and a.isDir(K)then print(\"Output is a directory, forcing check\")end;if H or a.isDir(K)then local x=a.open(a.combine(J,\"DEBIAN/control\"),\"r\")if not x then error(\"Control file not found.\")end;local A={}local L=nil;local M=x.readLine()local B=1;while M~=nil do if string.sub(M,1,1)==\" \"and L~=nil then if L==\"Description\"then if type(A[L])==\"string\"then A[L]={Short=A[L],Long=\"\"}end;A[L].Long=A[L].Long..(string.sub(M,2)==\".\"and\"\\n\\n\"or string.sub(M,2))else A[L]=A[L]..(string.sub(M,2)==\".\"and\"\\n\"or string.sub(M,2))end else if string.find(M,\":\")==nil then x.close()error(\"Error while checking control (line \"..B..\"): Missing separator\\n    \"..M)end;L=string.sub(M,1,string.find(M,\":\")-1)A[L]=f(string.sub(M,string.find(M,\":\")+1))end;M=x.readLine()B=B+1 end;x.close()if A.Package==nil then error(\"Error while checking control: Missing \\\"Package\\\" field\")end;if A.Version==nil then error(\"Error while checking control: Missing \\\"Version\\\" field\")end;if A.Architecture==nil then error(\"Error while checking control: Missing \\\"Architecture\\\" field\")end;if A.Maintainer==nil then error(\"Error while checking control: Missing \\\"Maintainer\\\" field\")end;if A.Description==nil then error(\"Error while checking control: Missing \\\"Description\\\" field\")end;if a.isDir(K)then K=a.combine(K,A.Package..\"_\"..A.Version..\"_\"..A.Architecture..\".deb\")end;print(\"Successfully checked package \\\"\"..A.Package..\"\\\".\")end;if d.verbose then print(\"Creating control archive...\")end;local N=e.save(e.pack(a.combine(J,\"DEBIAN\")))if d.verbose then print(\"Creating data archive...\")end;local n=e.pack(J)n.DEBIAN=nil;local O=e.save(n)if d.verbose then print(\"Compressing archives...\")end;local P=LibDeflate:CompressGzip(N,{level=G and E or 5})local Q=LibDeflate:CompressGzip(O,{level=E})if d.verbose then print(\"Writing package...\")end;c.save({{name=\"debian-binary\",timestamp=os.time(),owner=0,group=0,mode=0x1FF,data=\"2.0\\n\"},{name=\"control.tar.gz\",timestamp=os.time(),owner=0,group=0,mode=0x1FF,data=P},{name=\"data.tar.gz\",timestamp=os.time(),owner=0,group=0,mode=0x1FF,data=Q}},K)elseif C==1 then if#I<1 then error(\"Usage: dpkg-deb [options...] --info <archive> [control-file-name...]\")end;local R=d.load(I[1])print(\"new Debian package, version 2.0.\")print(\"size \"..R.data_size..\" bytes: control archive=\"..R.control_size..\" bytes.\")local S={}local T={0,0,0}for r,s in pairs(R.control_archive)do if r~=\"//\"then local U=0;for u in string.gmatch(s.data or\"\",\"[^\\n]+\")do U=U+1 end;local t={tostring(string.len(s.data or\"\")),tostring(U),r}for u,w in pairs(t)do if string.len(w)+2>T[u]then T[u]=string.len(w)+2 end end;table.insert(S,t)end end;for r,s in pairs(S)do print(l(s[1],T[1])..\" bytes,\"..l(s[2],T[2])..\" lines   \"..h(s[3],T[3]))end;print(R.control_archive.control.data)elseif C==2 then if#I<1 then error(\"Usage: dpkg-deb [options...] --show <archive>\")end;local R=d.load(I[1])io.write(({string.gsub(F,\"%${(.-)}\",R.control)})[1])elseif C==3 then if#I<1 then error(\"Usage: dpkg-deb [options...] --field <archive> [control-field-name...]\")end;local R=d.load(I[1])local function H(s)if type(s)==\"table\"then return s.Short..\"\\n\"..s.Long else return s end end;for r,s in pairs(R.control)do if#I>1 then for u,w in pairs(I)do if r==w then print(r..\": \"..H(s))break end end else print(r..\": \"..H(s))end end elseif C==4 then if#I<1 then error(\"Usage: dpkg-deb [options...] --contents <archive>\")end;local R=d.load(I[1],true)local V={}local T={0,0,0,0,0}for r,s in pairs(R.data)do local W=os.date(\"%F %R\",s.timestamp or 0)local t={y(s.mode+(s.type==5 and 0x200 or 0),\"drwxrwxrwx\",\"-\"),(s.ownerName or s.owner or 0)..\"/\"..(s.groupName or s.group or 0),string.len(s.data or\"\"),W,s.name..(s.link and s.link~=\"\"and\" -> \"..s.link or\"\")}for u,w in pairs(t)do if string.len(w)+1>T[u]then T[u]=string.len(w)+1 end end;table.insert(V,t)end;for r,s in pairs(V)do for u,w in pairs(s)do io.write((u==3 and l or h)(w,T[u])..(u==3 and\" \"or\"\"))end;print(\"\")end elseif C~=nil and C>=5 and C<=7 then if#I<1 or not D and C~=6 and#I<2 then error(\"Usage: dpkg-deb [options...] --extract <archive> <directory>\")end;local R=d.load(I[1],false,D)local X=I[2]or(C==6 and\"DEBIAN\"or b.getcwd())if not D then a.mkdir(X)end;if C~=6 then if D then print(R[2])else m(R.data,X)end end;if C~=5 then if D then print(R[1])else m(R.control_archive,C==7 and a.combine(X,\"DEBIAN\")or X)end end else error(\"Usage: dpkg-deb [options...] <command>\")end\n",created=1704748610867,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=8167},["b2sum.lua"]={modified=1704748612460,data="local a=require\"sha2\"local b=require\"system.util\"local c=assert(b.argparse({b=false,binary=\"@b\",c=false,check=\"@c\",l=\"number\",length=\"@l\",tag=false,t=false,text=\"@t\",z=false,zero=\"@z\",[\"ignore-missing\"]=false,quiet=false,status=false,strict=false,w=false,warn=\"@w\",h=false,help=\"@h\",v=false,version=\"@v\"},...))if c.h then print[[\nUsage: b2sum [OPTION]... [FILE]...\nPrint or check BLAKE2b (512-bit) checksums.\n\nWith no FILE, or when FILE is -, read standard input.\n  -b, --binary          read in binary mode\n  -c, --check           read checksums from the FILEs and check them\n  -l, --length=BITS     digest length in bits; must not exceed the max for\n                          the blake2 algorithm and must be a multiple of 8\n      --tag             create a BSD-style checksum\n  -t, --text            read in text mode (default)\n  -z, --zero            end each output line with NUL, not newline,\n                          and disable file name escaping\n\nThe following five options are useful only when verifying checksums:\n      --ignore-missing  don't fail or report status for missing files\n      --quiet           don't print OK for each successfully verified file\n      --status          don't output anything, status code shows success\n      --strict          exit non-zero for improperly formatted checksum lines\n  -w, --warn            warn about improperly formatted checksum lines\n\n      --help        display this help and exit\n      --version     output version information and exit\n\nThe sums are computed as described in RFC 7693.\nWhen checking, the input should be a former output of this program.\nThe default mode is to print a line with: checksum, a space,\na character indicating input mode ('*' for binary, ' ' for text\nor where binary is insignificant), and name for each FILE.\n]]return elseif c.v then print(\"1.0\")return end;c[1]=c[1]or\"-\"for d,e in ipairs(c)do local f=e==\"-\"and io.stdin or assert(io.open(e,c.b and not c.t and\"rb\"or\"r\"))local g=a.blake2b(nil,nil,nil,c.l and c.l/8)local h;repeat local i=f:read(\"*L\")h=g(i)until not i;if f~=io.stdin then f:close()end;local j;if c.tag then j=\"BLAKE2b\"..(c.l and\"-\"..c.l or\"\")..\" (\"..e..\") = \"..h else j=h..\"  \"..e end;if c.z then io.stdout:write(j..\"\\0\")else print(j)end end\n",created=1704748612470,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=2247},["gzip.lua"]={modified=1704748611328,data="local a=require\"LibDeflate\"local b={...}local c=0;local d;local e;local f=false;local g=false;local h;local i=false;for j,k in pairs(b)do if k==\"-c\"or k==\"--stdout\"then e=\"stdout\"elseif k==\"-d\"or k==\"--decompress\"then c=1 elseif k==\"-f\"or k==\"--force\"then g=true elseif k==\"-h\"or k==\"--help\"then print([[Usage: gzip [OPTION]... [FILE]\nCompress or uncompress FILEs (by default, compress FILES in-place).\n\n    -c, --stdout      write on standard output, keep original files unchanged\n    -d, --decompress  decompress\n    -f, --force       force overwrite of output file\n    -h, --help        give this help\n    -k, --keep        keep (don't delete) input files\n    -l, --list        list compressed file contents\n    -t, --test        test compressed file integrity\n    -v, --verbose     verbose mode\n    -V, --version     display version number\n    -1, --fast        compress faster\n    -9, --best        compress better\n\nWith no FILE, or when FILE is -, read standard input.]])return elseif k==\"-k\"or k==\"--keep\"then f=true elseif k==\"-l\"or k==\"--list\"then c=2 elseif k==\"-t\"or k==\"--test\"then c=3 elseif k==\"-v\"or k==\"--verbose\"then i=true elseif k==\"-V\"or k==\"--version\"then print(\"gzip v1.0\")return elseif k==\"-1\"or k==\"--fast\"then h=1 elseif k==\"-9\"or k==\"--best\"then h=9 elseif d==nil then if k==\"-\"then d=\"stdin\"e=\"stdout\"else d=k end end end;if d==nil then d=\"stdin\"end;if e==nil then if c==0 and d~=\"stdin\"then e=d..\".gz\"elseif c==1 and d~=\"stdin\"then e=string.gsub(d,\".gz\",\"\")else e=\"stdout\"end end;local function l()if d==\"stdin\"then return io.stdin:read(\"*a\")else local m=assert(io.open(d,\"rb\"))local n=m:read(\"*a\")m:close()return n end end;local function o(p)if p==nil then error(d..\": not in gzip format\",2)end;if e==\"stdout\"then io.stdout:write(p)else local m=assert(io.open(e,\"wb\"))m:write(p)m:close()end;if i and e~=\"stdout\"then print(\"Wrote \"..string.len(p)..\" bytes\")end end;if e~=\"stdout\"and not g then local m=io.open(e,\"r\")if m then m:close()error(e..\": File exists\")end end;if c==0 then o(a:CompressGzip(l(),{level=h}))elseif c==1 then o(a:DecompressGzip(l()))elseif c==2 then local q=a.internal.GetGzipInfo(l())if q==nil then error(d..\": not in gzip format\")end;for j,k in pairs(q)do print(j,k)end elseif c==3 then local r,s=a:DecompressGzip(l())if r==nil then if s==-2 then error(d..\": invalid compressed data--crc error\")elseif s==-1 then error(d..\": not in gzip format\")elseif s==-3 then error(d..\" has unsupported flags\")elseif s==-4 then error(d..\": unknown method -- not supported\")else error(d..\": unknown error\")end end;if i then print(d..\":    OK\")end else error(\"This should never happen.\")end;if not f and d~=\"stdin\"and e~=\"stdout\"then os.remove(d)end\n",created=1704748611334,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=2686},["login.lua"]={modified=1704748612970,data="local a=require\"usermgr\"local b=require\"system.ipc\"local c=require\"system.process\"local d=require\"system.terminal\"local e=require\"system.util\"print()while b.lookup(\"usermgr\")==nil do e.sleep(0.1)end;if c.getuser()~=\"root\"then error(\"This program must be run as root. Make sure the setuser bit is set.\")end;for f,g in pairs(b.signal)do b.sigaction(g,nil)end;b.sigaction(b.signal.SIGHUP,function()return c.exit(-1)end)while true do print(\"Phoenix \"..e.syscall.version()..\"\\n\")io.stdout:write(\"login: \")local h=io.stdin:read()for i=1,3 do io.stdout:write(\"Password: \")d.termctl({echo=false})local j=io.stdin:read()d.termctl({echo=true})print()local k,l=a.authenticate(h,j)if l then print(l)end;if not k and(l==\"No password set\"or l==\"Password expired\")then repeat until c.run(\"/usr/bin/passwd.lua\",h)end;if k then local m=io.open(\"/etc/motd\",\"r\")if m then print(m:read(\"*a\"))m:close()end;local n=a.getUserInfo(h)local o=c.fork(function()c.setuser(h)if n and n.home then c.getenv().HOME=n.home;c.chdir(n.home)end;if n and n.shell then c.exec(n.shell)else c.exec(\"/bin/sh\")end end)for f,g in pairs(b.signal)do b.sigaction(g,function()b.kill(o,g)end)end;b.sigaction(b.signal.SIGHUP,function()b.kill(o,b.signal.SIGHUP)return c.exit(-1)end)repeat local p,q=coroutine.yield()until p==\"process_complete\"and q.id==o;for f,g in pairs(b.signal)do b.sigaction(g,nil)end;b.sigaction(b.signal.SIGHUP,function()return c.exit(-1)end)break else if i==3 then print(\"login: 3 incorrect password attempts\\n\")e.sleep(2)end end end end\n",created=1704748613026,owner="root",setuser=true,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1512},["sha1sum.lua"]={modified=1704748612461,data="return coroutine.yield(\"syscall\",\"exec\",\"/usr/bin/shasum\",\"-a\",\"1\",...)\n",created=1704748612471,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=72},["shasum.lua"]={modified=1704748612465,data="local a=require\"sha2\"local b=require\"system.util\"local c=assert(b.argparse({a=true,algorithm=\"@a\",b=false,binary=\"@b\",c=false,check=\"@c\",tag=false,t=false,text=\"@t\",U=false,UNIVERSAL=\"@U\",[\"0\"]=false,[\"01\"]=\"@0\",[\"ignore-missing\"]=false,q=false,quiet=\"@q\",s=false,status=\"@s\",strict=false,w=false,warn=\"@w\",h=false,help=\"@h\",v=false,version=\"@v\"},...))if c.h then print[[\nUsage: shasum [OPTION]... [FILE]...\nPrint or check SHA checksums.\nWith no FILE, or when FILE is -, read standard input.\n\n    -a, --algorithm   1 (default), 224, 256, 384, 512, 512224, 512256\n    -b, --binary      read in binary mode\n    -c, --check       read SHA sums from the FILEs and check them\n        --tag         create a BSD-style checksum\n    -t, --text        read in text mode (default)\n    -U, --UNIVERSAL   read in Universal Newlines mode\n                        produces same digest on Windows/Unix/Mac\n    -0, --01          read in BITS mode\n                        ASCII '0' interpreted as 0-bit,\n                        ASCII '1' interpreted as 1-bit,\n                        all other characters ignored\n\nThe following five options are useful only when verifying checksums:\n        --ignore-missing  don't fail or report status for missing files\n    -q, --quiet           don't print OK for each successfully verified file\n    -s, --status          don't output anything, status code shows success\n        --strict          exit non-zero for improperly formatted checksum lines\n    -w, --warn            warn about improperly formatted checksum lines\n\n    -h, --help        display this help and exit\n    -v, --version     output version information and exit\n\nWhen verifying SHA-512/224 or SHA-512/256 checksums, indicate the\nalgorithm explicitly using the -a option, e.g.\n\n    shasum -a 512224 -c checksumfile\n\nThe sums are computed as described in FIPS PUB 180-4.  When checking,\nthe input should be a former output of this program.  The default\nmode is to print a line with checksum, a character indicating type\n(`*' for binary, ` ' for text, `U' for UNIVERSAL, `^' for BITS),\nand name for each FILE.  The line starts with a `\\' character if the\nFILE name contains either newlines or backslashes, which are then\nreplaced by the two-character sequences `\\n' and `\\\\' respectively.\n]]return elseif c.v then print(\"1.0\")return end;c[1]=c[1]or\"-\"for d,e in ipairs(c)do local f=e==\"-\"and io.stdin or assert(io.open(e,c.b and not c.t and\"rb\"or\"r\"))local g;if c.a==\"1\"or not c.a then g=a.sha1()elseif c.a==\"224\"then g=a.sha224()elseif c.a==\"256\"then g=a.sha256()elseif c.a==\"384\"then g=a.sha384()elseif c.a==\"512\"then g=a.sha512()elseif c.a==\"512224\"then g=a.sha512_224()elseif c.a==\"512256\"then g=a.sha512_256()else error(\"shasum: invalid algorithm \"..c.a)end;local h;repeat local i=f:read(\"*L\")if i and c[\"0\"]then i=i:gsub(\"[^01]\",\"\"):gsub(\"........\",function(j)return string.char(tonumber(j,2))end)end;h=g(i)until not i;if f~=io.stdin then f:close()end;if c.tag then print(\"SHA\"..(c.a or\"1\"):gsub(\"(...)(...)\",\"%1/%2\")..\" (\"..e..\") = \"..h)else print(h..\"  \"..e)end end\n",created=1704748612474,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=3059},["dpkg-trigger.lua"]={modified=1704748610842,data="local a=require\"dpkg.query\"local b=require\"dpkg.trigger\"local c={}local d=_ENV.DPKG_MAINTSCRIPT_PACKAGE;local e=true;local f=true;local g;for h,i in ipairs({...})do if g then if g==0 then b.admindir=i;a.admindir=i elseif g==1 then d=i end;g=nil elseif i==\"--check-supported\"then return 0 elseif i==\"-?\"or i==\"--help\"then print([[Usage: dpkg-trigger [<options> ...] <trigger-name>\n       dpkg-trigger [<options> ...] <command>\n\nCommands:\n  --check-supported                Check if the running dpkg supports triggers.\n\n  -?, --help                       Show this help message.\n      --version                    Show the version.\n\nOptions:\n  --admindir=<directory>           Use <directory> instead of /var/lib/dpkg.\n  --by-package=<package>           Override trigger awaiter (normally set\n                                   by dpkg).\n  --await                          Package needs to await the processing.\n  --no-await                       No package needs to await the processing.\n  --no-act                         Just test - don't actually change anything.\n ]])return 0 elseif i==\"--version\"then print([[Debian dpkg-trigger package trigger utility version 1.19.0.5 (Phoenix).]])return 0 elseif i==\"--admindir\"then g=0 elseif string.match(i,\"^--admindir=\")then b.admindir=string.sub(i,12)a.admindir=string.sub(i,12)elseif i==\"--by-package\"then g=1 elseif string.match(i,\"^--by-package=\")then d=string.sub(i,14)elseif i==\"--await\"then e=true elseif i==\"--no-await\"then e=false elseif i==\"--no-act\"then f=false else table.insert(c,i)end end;if c[1]==nil then error([[error: takes one argument, the trigger name\n\nType dpkg-trigger --help for help about this utility.]])end;if d==nil then error([[error: must be called from a maintainer script (or with a --by-package option)\n\nType dpkg-trigger --help for help about this utility.]])end;b.log=function(j)print(\"\\x1b[31m\"..j..\"\\x1b[0m\")end;if f then b.activate(c[1],d,e)end;return 0\n",created=1704748610868,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1936},["passwd.lua"]={modified=1704748612971,data="local a=require\"usermgr\"local b=require\"system.process\"local c=require\"system.terminal\"local d=require\"system.util\"local e,f=b.getuser()f=f or e;if e~=\"root\"then error(\"This program must be run as root. Make sure the setuser bit is set.\")end;local g=assert(d.argparse({a=false,all=\"@a\",d=false,delete=\"@d\",e=false,expire=\"@e\",h=false,help=\"@h\",i=\"number\",inactive=\"@i\",k=false,[\"keep-tokens\"]=\"@k\",l=false,lock=\"@l\",n=\"number\",mindays=\"@n\",q=false,quiet=\"@q\",S=false,status=\"@S\",u=false,unlock=\"@u\",w=\"number\",warndays=\"@w\",x=\"number\",maxdays=\"@x\"},...))if g.h then print[[\nUsage: passwd [options] [LOGIN]\nOptions:\n  -a, --all                 report password status on all accounts\n  -d, --delete              delete the password for the named account\n  -e, --expire              force expire the password for the named account\n  -h, --help                display this help message and exit\n  -k, --keep-tokens         change password only if expired\n  -i, --inactive INACTIVE   set password inactive after expiration to INACTIVE\n  -l, --lock                lock the password of the named account\n  -n, --mindays MIN_DAYS    set minimum number of days before password change to MIN_DAYS\n  -q, --quiet               quiet mode\n  -S, --status              report password status on the named account\n  -u, --unlock              unlock the password of the named account\n  -w, --warndays WARN_DAYS  set expiration warning days to WARN_DAYS\n  -x, --maxdays MAX_DAYS    set maximum number of days before password change to MAX_DAYS \n]]return elseif g.S then local function h(i)local j=a.getUserInfo(i)if not j then print(\"passwd: could not find user\")return end;print(i,j.hasPassword and(j.isLocked and\"L\"or\"P\")or\"NP\",os.date(\"%F\",j.lastChange),j.nextChange and(j.nextChange-j.lastChange)/86400 or 0,j.expirationTime and(j.expirationTime-j.lastChange)/86400 or 0,j.expirationWarning and(j.expirationTime-j.expirationWarning)/86400 or 0,-1)end;if g.a then if f~=\"root\"then error(\"passwd: Permission denied.\")end;for k in io.lines(\"/etc/passwd\")do h(k:match(\"^[^:]+\"))end else h(f)end;return end;local i=g[1]or f;if g.d then assert(f==\"root\",\"passwd: Permission denied.\")return a.setPassword(i,nil)elseif g.e then assert(f==\"root\",\"passwd: Permission denied.\")return a.setPassword(i,nil,{expirationTime=0})elseif g.l then assert(f==\"root\",\"passwd: Permission denied.\")return a.setPassword(i,nil,{isLocked=true})elseif g.u then assert(f==\"root\",\"passwd: Permission denied.\")return a.setPassword(i,nil,{isLocked=false})else local j=a.getUserInfo(i)if not j then io.stderr:write(\"passwd: User not found.\\n\")return false end;if j.isLocked then io.stderr:write(\"passwd: User is locked.\\n\")return false end;if not g.q then print(\"Changing password for \"..i..\".\")end;local l;if f~=\"root\"then if not g.q then io.stdout:write(\"Old password: \")end;c.termctl({echo=false})l=io.stdin:read()c.termctl({echo=true})print()end;if not g.q then io.stdout:write(\"New password: \")end;c.termctl({echo=false})local m=io.stdin:read()c.termctl({echo=true})print()if not g.q then io.stdout:write(\"Confirm password: \")end;c.termctl({echo=false})local n=io.stdin:read()c.termctl({echo=true})print()if l and not a.authenticate(i,l)then if not g.q then io.stderr:write(\"passwd: Incorrect old password.\\n\")end;return false elseif m==n then return a.setPassword(i,m,{nextChange=g.n,expirationTime=g.x,expirationWarning=g.w,lockTime=g.i})else if not g.q then io.stderr:write(\"passwd: Passwords do not match.\\n\")end;return false end end\n",created=1704748613027,owner="root",setuser=true,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=3496},["useradd.lua"]={modified=1704748612973,data="local a=require\"usermgr\"local b=require\"system.filesystem\"local c=require\"system.process\"local d=require\"system.util\"local e=[[\nUsage: useradd [options] LOGIN\n       useradd -D\n       useradd -D [options]\nOptions:\n  -b, --base-dir BASE_DIR  base directory for the home directory of the new account\n  -c, --comment COMMENT    full name of the new account\n  -d, --home-dir HOME_DIR  home directory of the new account\n  -D, --defaults           print or change default useradd configuration\n  -f, --inactive INACTIVE  password inactivity period of the new account\n  -h, --help               display this help message and exit\n  -k, --skel SKEL_DIR      use this alternative skeleton directory\n  -K, --key KEY=VALUE      override /etc/login.defs defaults\n  -m, --create-home        create the user's home directory\n  -M, --no-create-home     do not create the user's home directory\n  -p, --password PASSWORD  password of the new account\n  -s, --shell SHELL        login shell of the new account\n]]local f=assert(d.argparse({b=true,[\"base-dir\"]=\"@b\",c=true,comment=\"@c\",d=true,[\"home-dir\"]=\"@d\",D=false,defaults=\"@D\",f=\"number\",inactive=\"@f\",h=false,help=\"@h\",k=true,skel=\"@k\",K=\"multiple\",key=\"@K\",m=false,[\"create-home\"]=\"@m\",M=false,[\"no-create-home\"]=\"@M\",p=true,password=\"@p\",s=true,shell=\"@s\"},...))if f.h then print(e)return end;local g={HOME=\"/home\",INACTIVE=-1,SHELL=\"/bin/cash\",SKEL=\"/etc/skel\"}do local h=io.open(\"/etc/default/useradd\",\"r\")if h then for i in h:lines()do local j,k=i:gsub(\"#.*$\",\"\"):match\"^([^=]+)=(.*)$\"if j and k then g[j]=type(g[j])==\"number\"and tonumber(k)or k end end;h:close()end end;for l,i in ipairs(f.K or{})do local j,k=i:match\"^([^=]+)=(.*)$\"if j and k then g[j]=type(g[j])==\"number\"and tonumber(k)or k end end;if f.D then if f.b or f.f or f.s then if c.getuser()~=\"root\"then error(\"useradd: Permission denied.\")end;if f.b then g.HOME=f.b end;if f.f then g.INACTIVE=f.f end;if f.s then g.SHELL=f.s end;local h=assert(io.open(\"/etc/default/useradd\",\"w\"))for m,n in pairs(g)do h:write(m..\"=\"..n..\"\\n\")end;h:close()else for m,n in pairs(g)do print(m..\"=\"..n)end end;return end;if not f[1]then io.stderr:write(e..\"\\n\")return false end;if c.getuser()~=\"root\"then error(\"useradd: Permission denied.\")end;local o=f.d or b.combine(f.b or g.HOME,f[1])local p=f.f or g.INACTIVE;if p<0 then p=nil end;assert(a.addUser(f[1],f.p,{fullName=f.c,home=o,shell=f.s or g.SHELL,lockTime=p}))if f.m and not f.M then b.mkdir(o)b.chmod(o,f[1],\"rwx\")b.chmod(o,nil,\"r-x\")b.chown(o,f[1])local q=f.k or g.SKEL;if q and b.isDir(q)then local function r(s)local t=b.stat(s,true)if t.permissions[t.owner]then b.chmod(s,f[1],t.permissions[t.owner])end;b.chown(s,f[1])if t.type==\"directory\"then for l,n in ipairs(b.list(s))do r(b.combine(s,n))end end end;for l,n in ipairs(b.list(q))do b.copy(b.combine(q,n),b.combine(o,n),true)r(b.combine(o,n))end end end\n",created=1704748613028,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=2857},["su.lua"]={modified=1704748612972,data="local a=require\"usermgr\"local b=require\"system.ipc\"local c=require\"system.process\"local d=require\"system.terminal\"local e=require\"system.util\"local f=assert(e.argparse({[\"\"]={stopProcessingOnPositionalArgument=true},s=true,shell=\"@s\"},...))local g=f.s or f.shell;local h=f[1]or\"root\"io.stdout:write(\"Password: \")d.termctl({echo=false})local i=io.stdin:read()d.termctl({echo=true})print()local j,k=a.authenticate(h,i)if k then print(k)end;if j then local l=a.getUserInfo(h)local m=c.fork(function()c.setuser(h)if l and l.home then c.getenv().HOME=l.home;c.chdir(l.home)end;if g then c.exec(g,table.unpack(f,2))elseif l and l.shell then c.exec(l.shell,table.unpack(f,2))else c.exec(\"/bin/sh\",table.unpack(f,2))end end)for n,o in pairs(b.signal)do b.sigaction(o,function()b.kill(m,o)end)end;repeat local p,q=coroutine.yield()until p==\"process_complete\"and q.id==m else print(\"su: Sorry\")end\n",created=1704748613027,owner="root",setuser=true,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=888},["sha224sum.lua"]={modified=1704748612462,data="return coroutine.yield(\"syscall\",\"exec\",\"/usr/bin/shasum\",\"-a\",\"224\",...)\n",created=1704748612472,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=74},["sha384sum.lua"]={modified=1704748612463,data="return coroutine.yield(\"syscall\",\"exec\",\"/usr/bin/shasum\",\"-a\",\"384\",...)\n",created=1704748612473,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=74},["update.lua"]={modified=1704748610844,data="local a=\"https://phoenix.madefor.cc/packages/\"local b=require\"system.filesystem\"local c=require\"system.network\"local d=require\"system.process\"local e=require\"dpkg.control\"local f=require\"dpkg.query\"if d.getuser()~=\"root\"then error(\"This program must be run as root.\")end;print(\"Checking for updates...\")local g,h=c.get(a..\"Packages\")if not g then error(\"Could not download package list: \"..h)elseif g:responseCode()~=200 then local i=g:responseCode()g:close()error(\"Could not download package list: HTTP \"..i)end;local j=e.parseControlList(g:read(\"*a\"))g:close()local k={}for l,m in ipairs(j)do k[m.Package]=m end;local n=f.readDatabase()local o={}for p,m in pairs(n)do if not m.Status:match\"^deinstall \"and k[p]and k[p].Version~=m.Version then o[#o+1]=p end end;if#o==0 then print(\"No updates available.\")return true end;table.sort(o,function(q,r)if q==\"dpkg\"then return true elseif r==\"dpkg\"then return false else return q<r end end)print(\"The following package updates are available:\")for l,m in ipairs(o)do print(\"  \"..m..\": \"..n[m].Version..\" -> \"..k[m].Version)end;io.write(\"Install these updates? (y/N) \")local s=io.read()if not s or s:lower()~=\"y\"then return false end;b.mkdir(\"/tmp/pkgcache\")b.mount(\"tmpfs\",\"tmpfs\",\"/tmp/pkgcache\",{})for l,m in ipairs(o)do print(\"Downloading \"..m..\" (\"..math.floor(k[m].Size/1024)..\" kiB)\")g,h=c.get{url=a..m..\".deb\",encoding=\"binary\"}if not g then b.unmount(\"/tmp/pkgcache\")error(\"Failed to download package: \"..h)elseif g:responseCode()~=200 then b.unmount(\"/tmp/pkgcache\")local i=g:responseCode()g:close()error(\"Failed to download package: HTTP \"..i)end;local t,h=b.open(\"/tmp/pkgcache/\"..m..\".deb\",\"wb\")if not t then g:close()b.unmount(\"/tmp/pkgcache\")error(\"Failed to write package: \"..h)end;t.write(g:read(\"*a\"))t.close()g:close()end;local u=true;for l,m in ipairs(o)do u=d.run(\"/usr/bin/dpkg\",\"-i\",\"/tmp/pkgcache/\"..m..\".deb\")and u end;b.unmount(\"/tmp/pkgcache\")print(\"Update complete. It may be necessary to reboot your computer to use the new software.\")return u\n",created=1704748610870,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=2016},["update-initrd.lua"]={modified=1704748611116,data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=assert(io.open(\"/etc/initrd/initrd.conf\",\"r\"))local d=c:read(\"*a\"):gsub(\"#\",\"--\")c:close()config={}assert(load(d,\"@/etc/initrd/initrd.conf\",\"t\",config))()rootDirectory=os.tmpname()a.mkdir(rootDirectory)for e,f in ipairs(a.list(\"/etc/initrd/hooks.d\"))do print(\"--> Running hook \"..f)dofile(\"/etc/initrd/hooks.d/\"..f)end;print(\"--> Creating initrd\")b.run(\"/usr/bin/mktablefs.lua\",rootDirectory,config.output_path or\"/boot/initrd.img\")print(\"=>  Finished creating initrd at \"..(config.output_path or\"/boot/initrd.img\"))\n",created=1704748611130,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=590},["unxz.lua"]={modified=1704748611640,data="local a=require\"muxzcat\"local b=setmetatable({},{__index=function(self,c)return function(...)local d=table.pack(coroutine.yield(\"syscall\",c,...))if d[1]then return table.unpack(d,2,d.n)else error(d[2],2)end end end,__newindex=function()end})local function e()print([[Usage: unxz [OPTION]... [FILE]...\nDecompress FILEs in the .xz format.\n\n  -k, --keep         keep (don't delete) input files\n  -f, --force        force overwrite of output file\n  -c, --stdout       write to standard output and don't delete input files\n  -h, --help         display this help and exit\n  -V, --version      display the version number and exit\n\nReport bugs to https://github.com/MCJack123/CC-Archive/issues.\nUses JackMacWindows's Lua port of muxzcat. Licensed under GPL v2.0.]])end;local f={}local g=false;local h=false;local i=false;local j=false;for k,l in ipairs({...})do if#l==2 then if l==\"-z\"or l==\"-t\"or l==\"-l\"then error(\"unxz: This program only supports decompression.\")elseif l==\"-k\"then g=true elseif l==\"-f\"then h=true elseif l==\"-c\"then i=true;g=true elseif l==\"-h\"then return e()elseif l==\"-V\"then print(\"unxz 0.9 for Phoenix\")return end elseif l:sub(1,2)==\"--\"then if l==\"--compress\"or l==\"--test\"or l==\"--list\"then error(\"unxz: This program only supports decompression.\")elseif l==\"--keep\"then g=true elseif l==\"--force\"then h=true elseif l==\"--stdout\"or l==\"--to-stdout\"then i=true elseif l==\"--ignore-check\"then j=true elseif l==\"--help\"then return e()elseif l==\"--version\"then print(\"unxz 0.9 for Phoenix\")return end else table.insert(f,l)end end;local m=true;if#f==0 then error(\"unxz: Missing input. Type --help for help.\")end;for k,l in ipairs(f)do if not b.stat(l)then io.stderr:write(\"unxz: Could not open \"..l..\": File not found\\n\")elseif b.stat(l).type==\"directory\"then io.stderr:write(\"unxz: Could not open \"..l..\": Is a directory\\n\")elseif l:sub(-3)~=\".xz\"then io.stderr:write(\"unxz: \"..l..\": Filename has an unknown suffix, skipping\\n\")elseif not h and b.stat(l:sub(1,-4))then io.stderr:write(\"unxz: \"..l:sub(1,-4)..\": File exists\\n\")elseif i then local n=assert(io.open(l,\"rb\"))local o=n:read(\"*a\")n:close()local p,q=a.DecompressXzOrLzmaString(o)if p==nil then io.stderr:write(\"unxz: \"..l..\": Could not decompress: \"..a.GetError(q)..\"\\n\")m=false else io.stdout:write(p)end else local r,q=a.DecompressXzOrLzmaFile(l,l:sub(1,-4))if not r then io.stderr:write(\"unxz: \"..l..\": Could not decompress: \"..a.GetError(q)..\"\\n\")m=false elseif not g then os.remove(l)end end end;return m\n",created=1704748611646,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=2485},["usermod.lua"]={modified=1704748612974,data="local a=require\"usermgr\"local b=require\"system.filesystem\"local c=require\"system.process\"local d=require\"system.util\"local e=[[\nUsage: useradd [options] LOGIN\n       useradd -D\n       useradd -D [options]\nOptions:\n  -c, --comment COMMENT    new full name of the account\n  -d, --home HOME_DIR      new home directory of the account\n  -h, --help               display this help message and exit\n  -m, --move-home          move the user's home directory\n  -s, --shell SHELL        new login shell of the account\n]]local f=assert(d.argparse({c=true,comment=\"@c\",d=true,home=\"@d\",h=false,help=\"@h\",m=false,[\"move-home\"]=\"@m\",s=true,shell=\"@s\"},...))if f.h then print(e)return end;if not f[1]then io.stderr:write(e..\"\\n\")return false end;local g=c.getuser()if g~=\"root\"and g~=f[1]then error(\"usermod: Permission denied.\")end;local h=a.getUserInfo(f[1])if not h then error(\"usermod: User does not exist.\")end;if f.s==\"\"then f.s=\"/bin/cash\"end;assert(a.editUser(f[1],{fullName=f.c,home=f.d,shell=f.s}),\"usermod: Could not modify user.\")if f.m and f.d and h.home~=f.d then b.move(h.home,f.d)end\n",created=1704748613029,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1086},["components.lua"]={modified=1704748610840,data="local a=require\"system.filesystem\"local b=require\"system.framebuffer\"local c=require\"system.ipc\"local d=require\"system.keys\"local e=require\"system.log\"local f=require\"system.network\"local g=require\"system.process\"local h=require\"system.terminal\"local i=require\"system.util\"local j=require\"dpkg.query\"if g.getuser()~=\"root\"then error(\"This program must be run as root.\")end;local k=\"https://phoenix.madefor.cc/packages/\"local l=h.openterm()local m=h.colors;l.setPaletteColor(m.orange,0xD06018)l.setPaletteColor(m.white,0xD8D8D8)local n,o=l.getSize()local p;local q={}local r;local s=true;local t={}local function u(v,w)local x={}local y=\"\"for z in v:gmatch\"%w*%W*\"do while z:find\"\\n\"do local A;A,z=z:match\"([^\\n]*)\\n(.*)\"if#y+#A<w then x[#x+1],y=y..A,\"\"else x[#x+1],y=y,A end end;if#y+#z<w then y=y..z else x[#x+1],y=y,z end end;x[#x+1]=y;return x end;local function B(C)l.setCursorPos(3,o)l.setBackgroundColor(m.white)l.setTextColor(m.black)l.clearLine()l.write(C)end;local function D(C)l.setBackgroundColor(m.orange)l.setTextColor(m.white)l.clear()l.setCursorBlink(false)l.setCursorPos(2,2)l.write(\"Phoenix Setup\")l.setCursorPos(1,3)l.write((\"\\x8C\"):rep(15))B(C)p=5;q={}r=nil end;local function E(v)local F=b.window(l,3,p,n-4,o-p)F.setBackgroundColor(m.orange)F.setTextColor(m.white)F.clear()local G=0;for H,I in ipairs(u(v:gsub(\"* \",\"\\7 \"),n-4))do F.setCursorPos(1,H)F.write(I)G=H end;F.reposition(3,p,n-4,G)p=p+G+1 end;local function J(K,L,M,N)K=K or o-p-3;local O=0;for P in pairs(L)do O=O+1 end;l.setBackgroundColor(m.orange)l.setTextColor(m.white)l.setCursorPos(3,p)l.write(\"\\x9C\"..(\"\\x8C\"):rep(n-6))l.setBackgroundColor(m.white)l.setTextColor(m.orange)l.write(\"\\x93\")for Q=1,K do l.setCursorPos(l.getCursorPos()-1,p+Q)l.write(\"\\x95\")end;l.setBackgroundColor(m.orange)l.setTextColor(m.white)for Q=1,K do l.setCursorPos(3,p+Q)l.write(\"\\x95\")end;l.setCursorPos(3,p+K+1)l.write(\"\\x8D\"..(\"\\x8C\"):rep(n-6)..\"\\x8E\")local H,w=p+1,n-7;local R=b.window(l,4,H,w,K)R.setBackgroundColor(m.orange)R.clear()local S=b.framebuffer(R,1,1,w,O)S.setBackgroundColor(m.orange)S.setTextColor(m.white)S.clear()local x={}local T,U=1,1;for V,W in pairs(L)do S.setCursorPos(1,T)S.write((W and(W==\"R\"and\"[-] \"or\"[\\xD7] \")or\"[ ] \")..V)x[T]={V,not not W}T=T+1 end;l.setCursorPos(w+4,H+K-1)l.blit(1<O-K+1 and\"\\31\"or\" \",\"0\",\"1\")S.setCursorPos(2,U)S.setCursorBlink(true)r=S.restoreCursor;q[#q+1]=coroutine.create(function()local X=1;while true do local Y,Z=coroutine.yield()local _;if Y==\"key\"then if Z.keycode==d.up then _=-1 elseif Z.keycode==d.down then _=1 elseif Z.keycode==d.space and L[x[U][1]]~=\"R\"then x[U][2]=not x[U][2]S.setCursorPos(2,U)S.write(x[U][2]and\"\\xD7\"or\" \")if N and N(x[U][1],x[U][2])then for Q,W in ipairs(x)do local a0=L[W[1]]==\"R\"and\"R\"or W[2]S.setCursorPos(2,Q)S.write(a0 and(a0==\"R\"and\"-\"or\"\\xD7\")or\" \")end end;S.setCursorPos(2,U)elseif Z.keycode==d.enter then local a1={}for P,W in ipairs(x)do a1[W[1]]=L[W[1]]==\"R\"or W[2]end;M(a1)end elseif Y==\"mouse_scroll\"and Z.x>=4 and Z.x<4+w and Z.y>=H and Z.y<H+K then _=Z.direction end;if _ and(U+_>=1 and U+_<=O)then U=U+_;if U-X<0 or U-X>=K then X=X+_;S.reposition(1,2-X)end;S.setCursorPos(2,U)end;l.setCursorPos(w+4,H)l.blit(X>1 and\"\\30\"or\" \",\"0\",\"1\")l.setCursorPos(w+4,H+K-1)l.blit(X<O-K+1 and\"\\31\"or\" \",\"0\",\"1\")S.restoreCursor()end end)p=p+K+2 end;local function a2()l.setBackgroundColor(m.orange)l.setTextColor(m.white)l.setCursorPos(3,p)l.write(\"\\x9C\"..(\"\\x8C\"):rep(n-6))l.setBackgroundColor(m.white)l.setTextColor(m.orange)l.write(\"\\x93\")l.setCursorPos(l.getCursorPos()-1,p+1)l.write(\"\\x95\")l.setBackgroundColor(m.orange)l.setTextColor(m.white)l.setCursorPos(3,p+1)l.write(\"\\x95\")l.setCursorPos(3,p+2)l.write(\"\\x8D\"..(\"\\x8C\"):rep(n-6)..\"\\x8E\")local F=b.window(l,4,p+1,n-6,1)F.setBackgroundColor(m.orange)F.setTextColor(m.white)F.clear()p=p+4;return function(a3)F.setCursorPos(1,1)F.setBackgroundColor(m.orange)F.clearLine()F.setBackgroundColor(m.white)F.write((\" \"):rep(a3*(n-6)))end end;local function a4(a5)q[#q+1]=coroutine.create(function()while true do local Y,Z=coroutine.yield()if Y==\"key\"and a5[Z.keycode]then a5[Z.keycode](Z.keycode)end end end)end;local function a6()s=true;for P,W in ipairs(q)do coroutine.resume(W)end;while s do if r then r()end;local Y,Z=coroutine.yield()for P,W in ipairs(q)do local a7=table.pack(coroutine.resume(W,Y,Z))while a7[1]and a7[2]~=nil do a7=table.pack(coroutine.resume(W,coroutine.yield(table.unpack(a7,1,a7.n))))end end end end;local a8={}function a8.message(a9,aa,ab)D(\"ENTER=Back\")E(aa)a4{[d.enter]=function()s=false end}a6()return ab(a9)end;function a8.loading(a9)D(\"Downloading package list...\")E(\"Please wait while Setup initializes.\")local ac,ad=f.get(k..\"Packages\")if not ac or ac:status()==\"error\"or ac:responseCode()~=200 then return a8.message(a9,\"An error occurred while initializing Setup: Could not download package list: \"..(ad or select(2,ac:status())or ac:responseCode())..\"\\n\\nSetup cannot continue. Press ENTER to exit.\",function()end)end;local ae;for I in function()return ac:read(\"*l\")end do local V,W=I:match(\"^([%w%-]+):%s*(.+)$\")if V then if V==\"Package\"then ae=W;t[ae]={}elseif V==\"Size\"then t[ae].pkgsize=tonumber(W)elseif V==\"Installed-Size\"then t[ae].filesize=tonumber(W)*1024 elseif V==\"Priority\"then t[ae].priority=W elseif V==\"Essential\"then t[ae].essential=true elseif V==\"Depends\"then local af={}for A in W:gmatch\"[^,]+\"do af[A:match\"[%w%-]+\"]=true end;t[ae].depends=af end end end;ac:close()B(\"Checking installed packages...\")a9.installed=j.readDatabase()return a8.components(a9)end;function a8.components(a9)local ab;D(\"ENTER=Continue  SPACE=Toggle  TAB=Quit\")E(\"Select the components to install from the list below.\\n[-] = required, [\\xD7] = selected\")local L={}for V,W in pairs(t)do if V~=\"stage2-tarball\"then if V==\"phoenix\"or V==\"phoenix-luz\"then if a9.installed[\"phoenix-luz\"]and V==\"phoenix-luz\"or a9.installed[\"phoenix\"]and V==\"phoenix\"then L[V]=\"R\"end elseif W.essential or W.priority==\"required\"or a9.spanfs_disks and(V==\"initrd-utils\"or V==\"spanfs\")then L[V]=\"R\"elseif W.priority==\"optional\"then L[V]=false else L[V]=true end end end;local function ag()local function ah(ae)if L[ae]and t[ae].depends then for V in pairs(t[ae].depends)do L[V]=\"R\"ah(V)end end end;for V,W in pairs(L)do L[V]=(t[V].essential or t[V].priority==\"required\")and\"R\"or not not W end;for V in pairs(L)do ah(V)end end;ag()J(nil,L,function(ai)a9.components={}local a1,aj={},{}for V,W in pairs(ai)do if W then local af={}for ak,w in pairs(t[V].depends or{})do af[ak]=w end;aj[V]=af;if not _G.next(af)then a1[#a1+1]=V end end end;while#a1>0 do local al=table.remove(a1)a9.components[#a9.components+1]=al;for V,W in pairs(aj)do if W[al]then W[al]=nil;if not _G.next(W)then a1[#a1+1]=V end end end end;ab,s=true,false end,function(V,W)L[V]=W;ag()return true end)a4{[d.tab]=function()s=false end}a6()if ab then return a8.confirm(a9)else return false end end;function a8.confirm(a9)D(\"Calculating packages to install...\")a9.install,a9.remove={},{}local ai={}local am={}for P,W in ipairs(a9.components)do am[W]=true;if not a9.installed[W]or a9.installed[W].Status:match\"^deinstall \"then a9.install[#a9.install+1]=W end end;for V,W in pairs(t)do if not am[V]and(a9.installed[V]and not a9.installed[V].Status:match\"^deinstall \")then ai[V]=true end end;local a1,aj={},{}for V in pairs(ai)do local af={}for ak,w in pairs(t[V].depends or{})do af[ak]=w end;aj[V]=af;if not _G.next(af)then a1[#a1+1]=V end end;while#a1>0 do local al=table.remove(a1)a9.remove[#a9.remove+1]=al;for V,W in pairs(aj)do if W[al]then W[al]=nil;if not _G.next(W)then a1[#a1+1]=V end end end end;local ab;B(\"ENTER=Install  TAB=Back  Q=Quit\")E(\"The following changes will be made:\\nTo install: \"..table.concat(a9.install,\", \")..\"\\nTo remove: \"..table.concat(a9.remove,\", \")..\"\\n\\nPress ENTER to install.\")a4{[d.enter]=function()ab,s=true,false end,[d.tab]=function()ab,s=false,false end,[d.q]=function()s=false end}a6()if ab then return a8.download(a9)elseif ab==false then return a8.components(a9)else return false end end;function a8.download(a9)pcall(e.create,\"install\",false,\"/var/log/install.log\")if#a9.install==0 then return a8.remove(a9)end;D(\"\")E\"Downloading components...\"local a3=a2()local an=0;for P in pairs(a9.install)do an=an+1 end;local al=0;a.mkdir(\"/tmp/pkg\")a.mount(\"tmpfs\",\"tmpfs\",\"/tmp/pkg\",{})for P,V in ipairs(a9.install)do B(\"Downloading: \"..V)local ac,ad=f.get{url=k..V..\".deb\",encoding=\"binary\"}if not ac then return a8.message(a9,\"An error occurred while downloading the \"..V..\" component. Installation cannot continue.\\n\\nPress ENTER to exit.\\n\\nError message: \"..ad,function()return false end)end;local ao,ad=io.open(\"/tmp/pkg/\"..V..\".deb\",\"wb\")if not ao then ac:close()return a8.message(a9,\"An error occurred while saving the \"..V..\" component. Installation cannot continue.\\n\\nPress ENTER to exit.\\n\\nError message: \"..ad,function()return false end)end;ao:write(ac:read(\"*a\"))ac:close()ao:close()al=al+1;a3(al/an)end;return a8.install(a9)end;function a8.install(a9)D(\"\")E\"Please wait while Phoenix installs the requested components.\"l.setCursorPos(3,p)l.write(\"\\x9C\"..(\"\\x8C\"):rep(n-6))l.setBackgroundColor(m.white)l.setTextColor(m.orange)l.write(\"\\x93\")for Q=p+1,o-2 do l.setCursorPos(l.getCursorPos()-1,Q)l.write(\"\\x95\")end;l.setBackgroundColor(m.orange)l.setTextColor(m.white)for Q=p+1,o-2 do l.setCursorPos(3,Q)l.write(\"\\x95\")end;l.setCursorPos(3,o-1)l.write(\"\\x8D\"..(\"\\x8C\"):rep(n-6)..\"\\x8E\")local ap=h.mktty(n-6,o-9)local aq=g.fork(function()h.stdout(ap)while true do local Y,Z=coroutine.yield()if Y==\"remote_event\"then if Z.type==\"write\"then e.install.log(Z.data.data)io.stdout:write(Z.data.data)elseif Z.type==\"exit\"then break end end end end,\"tty helper\")g.newthread(function()while s do for H=1,ap.size.height do l.setCursorPos(4,H+7)l.blit(table.unpack(ap[H]))end;i.sleep(0.2)end end)local function ar(...)local as=g.fork(function(...)h.stdout({write=function(at)c.sendEvent(aq,\"write\",{data=at})end})g.exec(...)end,\"\",...)while true do local Y,Z=coroutine.yield()if Y==\"process_complete\"and Z.id==as then if Z.error or Z.traceback then s=false;c.sendEvent(aq,\"exit\",{})D(\"ENTER=Exit\")E[[\nAn error occurred while installing the specified components.\n\nPress ENTER to exit.]]B(\"ENTER=Reboot\")repeat local Y,Z=coroutine.yield()until Y==\"key\"and Z.keycode==10;return false end;break end end end;for P,V in ipairs(a9.install)do B(\"Installing: \"..V)e.install.log(\"Installing:\",V)ar(\"/usr/bin/dpkg.lua\",\"-i\",\"/tmp/pkg/\"..V..\".deb\")end;pcall(c.kill,aq,c.signal.SIGTERM)a.unmount(\"/tmp/pkg\")a.remove(\"/tmp/pkg\")return a8.remove(a9)end;function a8.remove(a9)if#a9.remove==0 then return a8.complete(a9)end;D(\"\")E\"Please wait while Phoenix removes the requested components.\"l.setCursorPos(3,p)l.write(\"\\x9C\"..(\"\\x8C\"):rep(n-6))l.setBackgroundColor(m.white)l.setTextColor(m.orange)l.write(\"\\x93\")for Q=p+1,o-2 do l.setCursorPos(l.getCursorPos()-1,Q)l.write(\"\\x95\")end;l.setBackgroundColor(m.orange)l.setTextColor(m.white)for Q=p+1,o-2 do l.setCursorPos(3,Q)l.write(\"\\x95\")end;l.setCursorPos(3,o-1)l.write(\"\\x8D\"..(\"\\x8C\"):rep(n-6)..\"\\x8E\")local ap=h.mktty(n-6,o-9)local aq=g.fork(function()h.stdout(ap)while true do local Y,Z=coroutine.yield()if Y==\"remote_event\"then if Z.type==\"write\"then e.install.log(Z.data.data)io.stdout:write(Z.data.data)elseif Z.type==\"exit\"then break end end end end,\"tty helper\")g.newthread(function()while s do for H=1,ap.size.height do l.setCursorPos(4,H+7)l.blit(table.unpack(ap[H]))end;i.sleep(0.2)end end)local function ar(...)local as=g.fork(function(...)h.stdout({write=function(at)c.sendEvent(aq,\"write\",{data=at})end})g.exec(...)end,\"\",...)while true do local Y,Z=coroutine.yield()if Y==\"process_complete\"and Z.id==as then if Z.error or Z.traceback then s=false;c.sendEvent(aq,\"exit\",{})D(\"ENTER=Exit\")E[[\nAn error occurred while removing the specified components.\n\nPress ENTER to exit.]]B(\"ENTER=Reboot\")repeat local Y,Z=coroutine.yield()until Y==\"key\"and Z.keycode==10;return false end;break end end end;for Q=#a9.remove,1,-1 do local V=a9.remove[Q]B(\"Removing: \"..V)e.install.log(\"Removing:\",V)ar(\"/usr/bin/dpkg.lua\",\"-r\",V)end;pcall(c.kill,aq,c.signal.SIGTERM)return a8.complete(a9)end;function a8.complete(a9)local ab;D(\"ENTER=Exit  R=Reboot\")E[[\nThe selected components have successfully been installed or removed. It is recommended to reboot your system to ensure all components were installed properly.\n\n* Press R to reboot your system now.\n* Press ENTER to exit without rebooting.]]a4{[d.enter]=function()ab,s=false,false end,[d.r]=function()ab,s=true,false end}a6()e.remove(\"install\")if ab then local as=c.lookup(\"ServiceManager\")if as then c.sendEvent(as,\"startmgr.request\",{func=\"reboot\"})else i.syscall.devcall(\"/\",\"reboot\")end else return true end end;return a8.loading{}\n",created=1704748610866,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=12722},["yahtcc.lua"]={modified=1704748613133,data="local a=require\"system.util\"local b=require\"system.keys\"local c=require\"system.terminal\"local d=require\"system.hardware\"local e,f=c.openterm()if not e then error(\"Could not open terminal: \"..f)end;local g={[0]={0xA0,0xA0,0xA0,0xA0,0xA0,0xA0},{0x20,0x10,0x95,0x8f,0x8f,0x85},{0x08,0x20,0x95,0x8f,0x8d,0x85},{0x08,0x10,0x95,0x8f,0x8d,0x85},{0x08,0x08,0x95,0x8d,0x8d,0x85},{0x08,0x18,0x95,0x8d,0x8d,0x85},{0x97,0x97,0x95,0x8d,0x8d,0x85}}local h={{0x2F,0x34,0x00,0x38,0x1F,0x00,0x00,0x28,0x14,0x00,0x00,0x3C,0x00,0x00,0x38,0x3C,0x14,0x20,0x3C,0x3C},{0x00,0x0B,0x3F,0x07,0x00,0x00,0x00,0x2A,0x15,0x00,0x0F,0x3F,0x0F,0x2A,0x17,0x00,0x00,0x3F,0x01,0x00},{0x00,0x00,0x3F,0x00,0x38,0x0F,0x3E,0x2A,0x1F,0x2F,0x14,0x3F,0x00,0x2A,0x15,0x00,0x00,0x3F,0x00,0x00},{0x00,0x00,0x3F,0x00,0x0B,0x3C,0x2F,0x2A,0x15,0x2A,0x15,0x3F,0x00,0x02,0x2F,0x3C,0x14,0x0B,0x3D,0x3C}}local i={{0x00,0x3C,0x30,0x30,0x38,0x14,0x00},{0x00,0x15,0x17,0x17,0x15,0x15,0x00},{0x00,0x15,0x15,0x15,0x15,0x15,0x00},{0x00,0x35,0x15,0x15,0x35,0x15,0x00},{0x00,0x03,0x0F,0x0F,0x07,0x01,0x00}}local j={{{name=\"\"},{name=\"Ones\",score=function(k)local l=0;for m,n in ipairs(k)do if n.value==1 then l=l+n.value end end;return l end},{name=\"Twos\",score=function(k)local l=0;for m,n in ipairs(k)do if n.value==2 then l=l+n.value end end;return l end},{name=\"Threes\",score=function(k)local l=0;for m,n in ipairs(k)do if n.value==3 then l=l+n.value end end;return l end},{name=\"Fours\",score=function(k)local l=0;for m,n in ipairs(k)do if n.value==4 then l=l+n.value end end;return l end},{name=\"Fives\",score=function(k)local l=0;for m,n in ipairs(k)do if n.value==5 then l=l+n.value end end;return l end},{name=\"Sixes\",score=function(k)local l=0;for m,n in ipairs(k)do if n.value==6 then l=l+n.value end end;return l end},{name=\"Bonus\"}},{{name=\"Three of a Kind\",score=function(k)local o={0,0,0,0,0,0}local p=false;local q=0;for m,n in ipairs(k)do o[n.value]=o[n.value]+1;q=q+n.value;if o[n.value]>=3 then p=true end end;return p and q or 0 end},{name=\"Four of a Kind\",score=function(k)local o={0,0,0,0,0,0}local p=false;local q=0;for m,n in ipairs(k)do o[n.value]=o[n.value]+1;q=q+n.value;if o[n.value]>=4 then p=true end end;return p and q or 0 end},{name=\"Full House\",score=function(k,r)local o={0,0,0,0,0,0}for m,n in ipairs(k)do o[n.value]=o[n.value]+1 end;local s,t,u=false,false,nil;for n=1,6 do if o[n]==3 then s=true elseif o[n]==2 then t=true elseif o[n]==5 then u=n end end;if u and r[2][6].locked and not r[1][u+1].locked then return 25 end;return s and t and 25 or 0 end},{name=\"Small Straight\",score=function(k,r)local o={0,0,0,0,0,0}local u=nil;for m,n in ipairs(k)do o[n.value]=o[n.value]+1;if o[n.value]==5 then u=n.value end end;if u and r[2][6].locked and not r[1][u+1].locked then return 30 end;if o[3]==0 or o[4]==0 then return 0 elseif o[1]~=0 and o[2]~=0 or o[2]~=0 and o[5]~=0 or o[5]~=0 and o[6]~=0 then return 30 end;return 0 end},{name=\"Large Straight\",score=function(k,r)local o={0,0,0,0,0,0}local u=nil;for m,n in ipairs(k)do o[n.value]=o[n.value]+1;if o[n.value]==5 then u=n.value end end;if u and r[2][6].locked and not r[1][u+1].locked then return 40 end;if o[2]==0 or o[3]==0 or o[4]==0 or o[5]==0 then return 0 end;return(o[1]~=0 or o[6]~=0)and 40 or 0 end},{name=\"Yahtzee\",score=function(k)local v=k[1].value;for m,n in ipairs(k)do if v~=n.value then return 0 end end;return 50 end},{name=\"Chance\",score=function(k)local q=0;for m,n in ipairs(k)do q=q+n.value end;return q end},{name=\"Yahtzee Bonus\"}}}local function w(x,y,z,A)A=A or'0'local B='f'local C=g[z]e.setCursorPos(x,y)for n=1,3 do local v=C[n]if v==0x20 then e.blit(' ',B,A)elseif v<0x80 then e.blit(string.char(v+0x80),B,A)else e.blit(string.char(v),A,B)end end;e.setCursorPos(x,y+1)for n=4,6 do local v=C[n]if v==0x20 then e.blit(' ',B,A)elseif v<0x80 then e.blit(string.char(v+0x80),B,A)else e.blit(string.char(v),A,B)end end;e.setBackgroundColor(c.colors.black)e.setTextColor(c.colors.white)end;local function D(x,y,k)for z,n in ipairs(k)do w(x+(z-1)*3,y,n.value,n.locked and'4'or'0')end end;local function E(F,G,H)H=H or'0'for y=1,4 do e.setCursorPos(F,G+y-1)for m,v in ipairs(h[y])do local B,A=H,'f'if bit32.btest(v,0x20)then B,A=A,B;v=bit32.band(bit32.bnot(v),0x1F)end;v=bit32.bor(v,0x80)if v==0x80 then v=0x20 end;e.blit(string.char(v),B,A)end end;e.setBackgroundColor(c.colors.black)e.setTextColor(c.colors.white)end;local function I(F,G,J,K)J=J or'b'for y=1,5 do e.setCursorPos(F-1,G+y-1)for x,v in ipairs(i[y])do local B,A;if y>1 and y<5 and x>1 and x<6 then B,A=J,'8'else B,A=J,'f'end;if bit32.btest(v,0x20)then B,A=A,B;v=bit32.band(bit32.bnot(v),0x1F)end;v=bit32.bor(v,0x80)if v==0x80 then v=0x20 end;e.blit(string.char(v),B,A)end end;e.setCursorPos(F-6,G+2)e.setBackgroundColor(c.colors.black)e.setTextColor(c.colors.white)e.write(K and\"      \"or\" Roll \")end;local function L(x,y,r,M,N)e.setBackgroundColor(c.colors.black)e.setCursorBlink(false)for O=1,2 do for n,P in ipairs(j[O])do local Q=O==M and n==N;e.setBackgroundColor(Q and c.colors.white or(n%2==1 and c.colors.black or c.colors.gray))e.setTextColor(Q and c.colors.black or c.colors.white)e.setCursorPos(x+(O-1)*20,y+n-1)e.write(P.name..(' '):rep(16-#P.name))if not r[O][n].locked and not P.bonus then if r[O][n].value==0 then e.setTextColor(c.colors.lightGray)else e.setTextColor(c.colors.lightBlue)end else e.setTextColor(Q and c.colors.black or c.colors.white)end;if r[O][n].value==nil then e.write(\"   \")elseif r[O][n].value<10 then e.write(\"  \"..r[O][n].value)else e.write(\" \"..r[O][n].value)end end end;e.setBackgroundColor(c.colors.black)e.setTextColor(c.colors.white)end;local function R(x,y,r,S)e.setCursorPos(x,y)e.write(\"Score: \")local q=0;for O=1,2 do for n,P in ipairs(r[O])do if P.value and P.locked then q=q+P.value end end end;e.write(q)e.setCursorPos(x,y+1)e.write(\"Rolls remaining: \"..S)e.setBackgroundColor(c.colors.black)e.setTextColor(c.colors.white)end;local function T(r,k)for O=1,2 do for n,P in ipairs(j[O])do if not r[O][n].locked and P.score then r[O][n].value=P.score(k,r)end end end;if r[2][6].locked and r[2][6].value==50 then local v=k[1].value;for m,n in ipairs(k)do if v~=n.value then return r end end;r[2][8].value=100;r[2][8].locked=true end;return r end;local function U(r,V,W)if V then r[V][W].locked=true end;for O=1,2 do for n,P in ipairs(r[O])do if not P.locked then P.value=nil end end end;if(r[1][2].locked and r[1][2].value or 0)+(r[1][3].locked and r[1][3].value or 0)+(r[1][4].locked and r[1][4].value or 0)+(r[1][5].locked and r[1][5].value or 0)+(r[1][6].locked and r[1][6].value or 0)+(r[1][7].locked and r[1][7].value or 0)>=63 then r[1][8].value=35;r[1][8].locked=true end;return r end;local X=d.find(\"speaker\")local function Y(k,Z,_,a0,a1,J,a2)for m,P in ipairs(k)do if not P.locked then P.value=0 end end;D(Z,_,k)for n=1,4 do I(a0,a1,J,true)if X then X:playNote(\"hat\",2,12)X:playNote(\"hat\",2,7)end;a.sleep(0.1)I(a0+1,a1,J,true)if X then X:playNote(\"hat\",2,11)X:playNote(\"hat\",2,6)end;a.sleep(0.1)I(a0,a1,J,true)if X then X:playNote(\"hat\",2,12)X:playNote(\"hat\",2,7)end;a.sleep(0.1)I(a0-1,a1,J,true)if X then X:playNote(\"hat\",2,11)X:playNote(\"hat\",2,6)end;a.sleep(0.1)end;if X then X:playNote(\"hat\",2,3)X:playNote(\"hat\",2,6)end;for m,P in ipairs(k)do if not P.locked then P.value=math.random(1,6)end end;I(a0,a1,J,a2)D(Z,_,k)return k end;local a3={dice={x=2,y=17},rollCup={x=36,y=15},logo={x=2,y=2},status={x=23,y=3},scores={x=2,y=7}}local k={{value=0},{value=0},{value=0},{value=0},{value=0}}local r={{{},{},{},{},{},{},{},{}},{{},{},{},{},{},{},{},{}}}local a4=3;local a5,a6=false,0;local a7=0;local a8=0xb;math.randomseed(os.time())e.clear()E(a3.logo.x,a3.logo.y)R(a3.status.x,a3.status.y,r,a4)L(a3.scores.x,a3.scores.y,r)D(a3.dice.x,a3.dice.y,k)I(a3.rollCup.x,a3.rollCup.y,('%x'):format(a8))while a7<13 do local a9,aa=coroutine.yield()if a9==\"key\"then if aa.keycode==b.r and a4>0 and not(k[1].locked and k[2].locked and k[3].locked and k[4].locked and k[5].locked)then a4=a4-1;U(r)L(a3.scores.x,a3.scores.y,r)R(a3.status.x,a3.status.y,r,a4)Y(k,a3.dice.x,a3.dice.y,a3.rollCup.x,a3.rollCup.y,('%x'):format(a8),a4<1)T(r,k)if a4==0 then a5=false;a6=2;while a6<=7 and r[1][a6].locked do a6=a6+1 end;if a6>7 then a5=true;a6=1;while a6<=7 and r[2][a6].locked do a6=a6+1 end;if a6>7 then a6=0 end end;L(a3.scores.x,a3.scores.y,r,a5 and 2 or 1,a6)else a5,a6=false,0;L(a3.scores.x,a3.scores.y,r)end elseif aa.keycode==b.one and a4<3 and a4>0 then k[1].locked=not k[1].locked;D(a3.dice.x,a3.dice.y,k)elseif aa.keycode==b.two and a4<3 and a4>0 then k[2].locked=not k[2].locked;D(a3.dice.x,a3.dice.y,k)elseif aa.keycode==b.three and a4<3 and a4>0 then k[3].locked=not k[3].locked;D(a3.dice.x,a3.dice.y,k)elseif aa.keycode==b.four and a4<3 and a4>0 then k[4].locked=not k[4].locked;D(a3.dice.x,a3.dice.y,k)elseif aa.keycode==b.five and a4<3 and a4>0 then k[5].locked=not k[5].locked;D(a3.dice.x,a3.dice.y,k)elseif aa.keycode==b.q then break elseif aa.keycode==b.up and a4<3 then if a6==0 then a5=false;a6=2;while a6<=7 and r[1][a6].locked do a6=a6+1 end;if a6>7 then a5=true;a6=1;while a6<=7 and r[2][a6].locked do a6=a6+1 end;if a6>7 then a6=0 end end end;if a6>(a5 and 1 or 2)then local ab=a6;repeat a6=a6-1 until a6<(a5 and 1 or 2)or not r[a5 and 2 or 1][a6].locked;if a6<(a5 and 1 or 2)then a6=ab end end;L(a3.scores.x,a3.scores.y,r,a5 and 2 or 1,a6)elseif aa.keycode==b.down and a4<3 then if a6==0 then a5=false;a6=7;while a6>=2 and r[1][a6].locked do a6=a6-1 end;if a6<2 then a5=true;a6=7;while a6>=1 and r[2][a6].locked do a6=a6-1 end;if a6<1 then a6=0 end end end;if a6>0 and a6<7 then local ab=a6;repeat a6=a6+1 until a6>7 or not r[a5 and 2 or 1][a6].locked;if a6>7 then a6=ab end end;L(a3.scores.x,a3.scores.y,r,a5 and 2 or 1,a6)elseif(aa.keycode==b.left or aa.keycode==b.right)and a4<3 and a6~=1 and(a6==0 or not r[a5 and 1 or 2][a6].locked)then if a6==0 then a5=aa.keycode==b.right;a6=a5 and 1 or 2;while a6<=7 and r[a5 and 2 or 1][a6].locked do a6=a6+1 end;if a6>7 then a5=not a5;a6=a5 and 1 or 2;while a6<=7 and r[a5 and 2 or 1][a6].locked do a6=a6+1 end;if a6>7 then a6=0 end end else a5=not a5 end;L(a3.scores.x,a3.scores.y,r,a5 and 2 or 1,a6)elseif aa.keycode==b.enter and a6~=0 and a4<3 and not r[a5 and 2 or 1][a6].locked then U(r,a5 and 2 or 1,a6)k={{value=0},{value=0},{value=0},{value=0},{value=0}}a4=3;R(a3.status.x,a3.status.y,r,a4)L(a3.scores.x,a3.scores.y,r)D(a3.dice.x,a3.dice.y,k)I(a3.rollCup.x,a3.rollCup.y,('%x'):format(a8))a7=a7+1 elseif aa.keycode==b.c then a8=a8+1;if a8>0xf then a8=0x0 end;I(a3.rollCup.x,a3.rollCup.y,('%x'):format(a8))end elseif a9==\"mouse_click\"and aa.button==1 then if(aa.x>=a3.rollCup.x and aa.x<a3.rollCup.x+5 and aa.y>=a3.rollCup.y and aa.y<a3.rollCup.y+5 or aa.x>=a3.rollCup.x-5 and aa.x<a3.rollCup.x-1 and aa.y==a3.rollCup.y+2)and a4>0 and not(k[1].locked and k[2].locked and k[3].locked and k[4].locked and k[5].locked)then a4=a4-1;U(r)L(a3.scores.x,a3.scores.y,r)R(a3.status.x,a3.status.y,r,a4)Y(k,a3.dice.x,a3.dice.y,a3.rollCup.x,a3.rollCup.y,('%x'):format(a8),a4<1)T(r,k)if a4==0 then a5=false;a6=2;while a6<=7 and r[1][a6].locked do a6=a6+1 end;if a6>7 then a5=true;a6=1;while a6<=7 and r[2][a6].locked do a6=a6+1 end;if a6>7 then a6=0 end end;L(a3.scores.x,a3.scores.y,r,a5 and 2 or 1,a6)else a5,a6=false,0;L(a3.scores.x,a3.scores.y,r)end elseif aa.x>=a3.dice.x and aa.x<a3.dice.x+15 and aa.y>=a3.dice.y and aa.y<a3.dice.y+2 and a4<3 and a4>0 then k[math.floor((aa.x-a3.dice.x)/3)+1].locked=not k[math.floor((aa.x-a3.dice.x)/3)+1].locked;D(a3.dice.x,a3.dice.y,k)elseif aa.x>=a3.scores.x and aa.x<a3.scores.x+40 and aa.y>=a3.scores.y and aa.y<a3.scores.y+7 and a4<3 then local V,W=aa.x-a3.scores.x>=20,aa.y-a3.scores.y+1;if a5==V and a6==W and not r[V and 2 or 1][W].locked then U(r,a5 and 2 or 1,a6)k={{value=0},{value=0},{value=0},{value=0},{value=0}}a4=3;R(a3.status.x,a3.status.y,r,a4)L(a3.scores.x,a3.scores.y,r)D(a3.dice.x,a3.dice.y,k)I(a3.rollCup.x,a3.rollCup.y,('%x'):format(a8))a7=a7+1 elseif(V or W>1)and not r[V and 2 or 1][W].locked then a5=V;a6=W;L(a3.scores.x,a3.scores.y,r,a5 and 2 or 1,a6)end end end end;if a7==13 then for n=1,3 do E(a3.logo.x,a3.logo.y,'5')a.sleep(0.5)E(a3.logo.x,a3.logo.y,'0')a.sleep(0.5)end;E(a3.logo.x,a3.logo.y,'5')a.sleep(1)end;e.close()local q=0;for O=1,2 do for n,P in ipairs(r[O])do if P.value and P.locked then q=q+P.value end end end;print(\"Final score: \"..q)print(\"Thanks for playing YahtCC!\")\n",created=1704748613142,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=12358},["mktablefs.lua"]={modified=1704748611115,data="local a=require\"system.filesystem\"local b=require\"system.serialization\"local function c(d)local e=a.stat(d)if not e then return nil end;e.freeSpace,e.capacity,e.special,e.mountpoint=nil;if e.type==\"file\"then local f=assert(io.open(d,\"rb\"))e.data=f:read(\"*a\")f:close()elseif e.type==\"directory\"then e.contents={}for g,h in ipairs(a.list(d))do e.contents[h]=c(a.combine(d,h))end end;return e end;local i,j=...if not j then error(\"Usage: mktablefs <input directory> <output file>\")end;local e=c(i)b.lua.save(e,j,{minified=true})\n",created=1704748611130,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=526},["dpkg-divert.lua"]={modified=1704748610841,data="local a=require\"system.filesystem\"local b=require\"dpkg.divert\"local c={}local d=0;local e=\"/\"local f=nil;local g=\":\"local h=false;local i=nil;local j=false;local k=nil;for l,m in pairs({...})do if k then if k==0 then b.admindir=m elseif k==1 then e=m elseif k==2 then e=m;b.admindir=a.combine(m,\"var/lib/dpkg\")elseif k==3 then f=m elseif k==4 then g=m end;k=nil elseif m==\"--add\"then d=0 elseif m==\"--remove\"then d=1 elseif m==\"--list\"then d=2 elseif m==\"--listpackage\"then d=3 elseif m==\"--truename\"then d=4 elseif m==\"--admindir\"then k=0 elseif m==\"--instdir\"then k=1 elseif m==\"--root\"then k=2 elseif m==\"--divert\"then k=3 elseif m==\"--local\"then g=\":\"elseif m==\"--package\"then k=4 elseif m==\"--quiet\"then h=true elseif m==\"--rename\"then i=true elseif m==\"--no-rename\"then i=false elseif m==\"--test\"then j=true elseif m==\"-?\"or m==\"--help\"then print([[Usage: dpkg-divert [<option> ...] <command>\nCommands:\n  [--add] <file>           add a diversion.\n  --remove <file>          remove the diversion.\n  --list [<glob-pattern>]  show file diversions.\n  --listpackage <file>     show what package diverts the file.\n  --truename <file>        return the diverted file.]])return 2 elseif m==\"--version\"then print(\"dpkg-divert v1.0\\nPart of apt-lua for Phoenix\\nCopyright (c) 2019-2022 JackMacWindows.\")return 2 else table.insert(c,m)end end;if d==0 then if#c<1 then error(\"Usage: dpkg-divert [options...] [--add] <file>\")end;f=f or c[1]..\".distrib\"if g==\":\"and not h then print(\"Adding 'local diversion of \"..c[1]..\" to \"..f..\"'\")elseif not h then print(\"Adding 'diversion of \"..c[1]..\" to \"..f..\" by \"..g..\"'\")end;if not j then b.add(c[1],f,g)end;if i then a.move(c[1],f)end elseif d==1 then if#c<1 then error(\"Usage: dpkg-divert [options...] --remove <file>\")end;local n=b.parse()if n[c[1]]==nil then return end;if g==\":\"and not h then print(\"Removing 'local diversion of \"..c[1]..\" to \"..n[c[1]].name..\"'\")elseif not h then print(\"Removing 'diversion of \"..c[1]..\" to \"..n[c[1]].name..\" by \"..n[c[1]].package..\"'\")end;if not j then b.remove(c[1])end;if i then a.move(n[c[1]].name,c[1])end elseif d==2 then if h then return end;if#c<1 then error(\"Usage: dpkg-divert [options...] --list <glob>\")end;c[1]=string.gsub(c[1],\"%*\",\"%.%*\")for l,m in pairs(b.parse())do if string.match(l,c[1])then if m.package==\":\"then print(\"local diversion of \"..l..\" to \"..m.name)else print(\"diversion of \"..l..\" to \"..m.name..\" by \"..m.package)end end end elseif d==3 then if h then return end;if#c<1 then error(\"Usage: dpkg-divert [options...] --listpackage <file>\")end;local o=b.parse()[c[1]]if o~=nil then if o.package==\":\"then print(\"LOCAL\")else print(o.package)end end elseif d==4 then if h then return end;if#c<1 then error(\"Usage: dpkg-divert [options...] --truename <file>\")end;local o=b.parse()[c[1]]if o==nil then print(c[1])else print(o.name)end end\n",created=1704748610867,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=2840},["dpkg-query.lua"]={modified=1704748610842,data="local a=require\"system.filesystem\"local b=require\"dpkg.query\"local function c(d)return string.match(d,'^()[%s%z]*$')and''or string.match(d,'^[%s%z]*(.*[^%s%z])')end;local function e(f,g,h)return string.len(f)<g and string.sub(f,1,g)..string.rep(h or\" \",g-string.len(f))or string.sub(f,1,g)end;local function i()local j=io.open(a.combine(b.admindir,\"available\"),\"r\")if j==nil then error(\"Couldn't find status file\")end;local k={{}}local l=nil;local d=1;for m in j:lines()do if m==\"\"then d=d+1;k[d]={}l=nil else if string.sub(m,1,1)==\" \"and l~=nil then if l==\"Description\"then if type(k[d][l])==\"string\"then k[d][l]={Short=k[d][l],Long=\"\"}end;k[d][l].Long=k[d][l].Long..(string.sub(m,2)==\".\"and\"\\n\\n\"or string.sub(m,2))else k[d][l]=k[d][l]..(string.sub(m,2)==\".\"and\"\\n\\n\"or string.sub(m,2))end else l=string.sub(m,1,(string.find(m,\":\")or 0)-1)k[d][l]=c(string.sub(m,(string.find(m,\":\")or-1)+1))end end end;j:close()local n={}for o,p in pairs(k)do if p.Package then n[p.Package]=p end end;return n end;local q={}local r=nil;local s=\"${Package}\\t${Version}\\n\"local t=false;local u;for o,p in pairs({...})do if u then if u==0 then s=p elseif u==1 then b.admindir=p elseif u==2 then s=p end;u=nil elseif p==\"-l\"or p==\"--list\"then r=0 elseif p==\"-W\"or p==\"--show\"then r=1 elseif p==\"-s\"or p==\"--status\"then r=2 elseif p==\"-L\"or p==\"--listfiles\"then r=3 elseif p==\"--control-list\"then r=4 elseif p==\"--control-show\"then r=5 elseif p==\"-c\"or p==\"--control-path\"then r=6 elseif p==\"-S\"or p==\"--search\"then r=7 elseif p==\"-p\"or p==\"--print-avail\"then r=8 elseif p==\"-?\"or p==\"--help\"then print([[Usage: dpkg-query [<option> ...] <command>\nCommands:\n  -s|--status <package> ...        Display package status details.\n  -p|--print-avail <package> ...   Display available version details.\n  -L|--listfiles <package> ...     List files 'owned' by package(s).\n  -l|--list [<pattern> ...]        List packages concisely.\n  -W|--show [<pattern> ...]        Show information on package(s).\n  -S|--search <pattern> ...        Find package(s) owning file(s).\n      --control-list <package>     Print the package control file list.\n      --control-show <package> <file>\n                                   Show the package control file.\n  -c|--control-path <package> [<file>]\n                                   Print path for package control file.\n  -?, --help                       Show this help message.\n      --version                    Show the version.]])return 2 elseif p==\"--version\"then print(\"dpkg-query v1.0\\nPart of apt-lua for Phoenix\\nCopyright (c) 2019-2022 JackMacWindows.\")return 2 elseif string.find(p,\"--admindir=\")==1 then b.admindir=string.sub(p,12)elseif p==\"--admindir\"then u=1 elseif p==\"--load-avail\"then t=true elseif string.find(p,\"--showformat=\")==1 then s=string.sub(p,14)elseif p==\"--showformat\"then u=2 elseif p==\"-f\"then u=0 else table.insert(q,p)end end;s=string.gsub(string.gsub(s,\"\\\\n\",\"\\n\"),\"\\\\t\",\"\\t\")if r==0 then local v=nil;if q[1]~=nil then v=string.gsub(q[1],\"%*\",\".+\")end;local w=b.readDatabase()local function x(p)local y=\"\"if string.find(p.Status,\"^install \")then y=\"i\"elseif string.find(p.Status,\" hold\")then y=\"h\"elseif string.find(p.Status,\" deinstall\")then y=\"r\"elseif string.find(p.Status,\" purge\")then y=\"p\"else y=\"u\"end;if string.find(p.Status,\" not-installed\")then y=y..\"n\"elseif string.find(p.Status,\" config-files\")then y=y..\"c\"elseif string.find(p.Status,\" half-installed\")then y=y..\"H\"elseif string.find(p.Status,\" unpacked\")then y=y..\"U\"elseif string.find(p.Status,\" half-configured\")then y=y..\"F\"elseif string.find(p.Status,\" triggers-awaited\")then y=y..\"W\"elseif string.find(p.Status,\" triggers-pending\")then y=y..\"t\"elseif string.find(p.Status,\" installed\")then y=y..\"i\"else y=y..\"u\"end;if string.find(p.Status,\" reinst-required\")then y=y..\"R\"else y=y..\" \"end;local z=select(2,coroutine.yield(\"syscall\",\"termsize\"))-4;io.write(string.format(\"%3s %s %s %s\",y,e(p.Package,z/4),e(p.Version,z/4),e(p.Description.Short,z/2)))end;if v then for o,p in pairs(w)do if string.match(p.Package,v)then x(p)end end else for o,p in pairs(w)do if string.find(p.Status,\" config-files\")==nil and string.find(p.Status,\" not-installed\")==nil then x(p)end end end elseif r==1 then local v=nil;if q[1]~=nil then v=string.gsub(q[1],\"%*\",\".+\")end;local w=b.readDatabase()local function x(p)local y=\"\"if string.find(p.Status,\"^install \")then y=\"i\"elseif string.find(p.Status,\"hold\")then y=\"h\"elseif string.find(p.Status,\"deinstall\")then y=\"r\"elseif string.find(p.Status,\"purge\")then y=\"p\"else y=\"u\"end;if string.find(p.Status,\"not-installed\")then y=y..\"n\"elseif string.find(p.Status,\"config-files\")then y=y..\"c\"elseif string.find(p.Status,\"half-installed\")then y=y..\"H\"elseif string.find(p.Status,\"unpacked\")then y=y..\"U\"elseif string.find(p.Status,\"half-configured\")then y=y..\"F\"elseif string.find(p.Status,\"triggers-awaited\")then y=y..\"W\"elseif string.find(p.Status,\"triggers-pending\")then y=y..\"t\"elseif string.find(p.Status,\" installed\")then y=y..\"i\"else y=y..\"u\"end;if string.find(p.Status,\" reinst-required\")then y=y..\"R\"else y=y..\" \"end;local function A(B,C)return C~=\"\"and e(p[B],tonumber(string.sub(C,2)))or p[B]end;io.write(string.gsub(s,\"%${(.-)(;?%d*)}\",A))end;if v then for o,p in pairs(w)do if string.match(p.Package,v)then x(p)end end else for o,p in pairs(w)do if string.find(p.Status,\" config-files\")==nil and string.find(p.Status,\" not-installed\")==nil then x(p)end end end elseif r==2 then if#q<1 then error(\"Usage: dpkg-query [options...] --status <package-name...>\")end;local w=b.readDatabase()local function D(p)if type(p)==\"table\"then return p.Short..\"\\n\"..string.gsub(p.Long,\"\\n\\n\",\"\\n .\\n\")else return p end end;for E,F in pairs(q)do for o,p in pairs(w)do if o==F then for G,z in pairs(p)do print(G..\": \"..D(z))end;break end end;print(\"\")end elseif r==3 then if#q<1 then error(\"Usage: dpkg-query [options...] --listfiles <package-name...>\")end;local w=b.readDatabase()for E,F in pairs(q)do local H;if a.exists(a.combine(b.admindir,\"info/\"..F..\".list\"))then H=a.combine(b.admindir,\"info/\"..F..\".list\")else for o,p in pairs(w)do if o==F then if not a.exists(a.combine(b.admindir,\"info/\"..F..\"!\"..p.Architecture..\".list\"))then error(\"Could not find list of files for \"..F)end;H=a.combine(b.admindir,\"info/\"..F..\"!\"..p.Architecture..\".list\")break end end end;local j=a.open(H,\"r\")print(j.readAll())j.close()end elseif r==4 then if#q<1 then error(\"Usage: dpkg-query [options...] --control-list <package-name>\")end;local I={}for o,p in pairs(a.list(a.combine(b.admindir,\"info\")))do if string.match(p,\"^\"..string.gsub(q[1],\"%-\",\"%%-\")..\"%..+\")then table.insert(I,a.combine(b.admindir,\"info/\"..p))end;if o%1000==0 then os.queueEvent(\"nosleep\")os.pullEvent()end end;if#I==0 then local w=b.readDatabase()for o,p in pairs(w)do if o==q[1]then local J=\"^\"..string.gsub(q[1],\"%-\",\"%%-\")..\"!\"..p.Architecture..\"%.(.+)\"for G,z in pairs(a.list(a.combine(b.admindir,\"info\")))do if string.match(z,J)then table.insert(I,string.match(z,J))end;if G%1000==0 then os.queueEvent(\"nosleep\")os.pullEvent()end end;break end end end;for o,p in pairs(I)do if p~=\"list\"then print(p)end end elseif r==5 then if#q<2 then error(\"Usage: dpkg-query [options...] --control-show <package-name> <control-file>\")end;if a.exists(a.combine(b.admindir,\"info/\"..q[1]..\".\"..q[2]))then local j=a.open(a.combine(b.admindir,\"info/\"..q[1]..\".\"..q[2]),\"r\")print(j.readAll())j.close()else local w=b.readDatabase()for o,p in pairs(w)do if o==q[1]then if a.exists(a.combine(b.admindir,\"info/\"..q[1]..\"!\"..p.Architecture..\".\"..q[2]))then local j=a.open(a.combine(b.admindir,\"info/\"..q[1]..\"!\"..p.Architecture..\".\"..q[2]),\"r\")print(j.readAll())j.close()end;break end end end elseif r==6 then error(\"This command is deprecated upstream, therefore it will remain unimplemented here.\")elseif r==7 then if#q<1 then error(\"Usage: dpkg-query [options...] --search <pattern>\")end;local K=false;local L=false;local v=string.gsub(string.gsub(q[1],\"([^\\\\])%*\",\"%1%.%*\"),\"([^\\\\])%?\",\"%1%.%-\")if string.find(q[1],\"[%*%[%?/]\")~=1 then v=\".*\"..v..\".*\"elseif string.find(q[1],\"[%*%[%?/]\")==nil then K=true else v=\"^\"..v..\"$\"end;local I=a.find(a.combine(b.admindir,\"info/*.list\"))print(\"Searching...\")for o,p in pairs(I)do local j=assert(io.open(p,\"r\"))for m in j:lines()do if string.find(m,v,1,K)then print(string.sub(a.basename(p),1,string.find(a.basename(p),\"[!.]\")-1)..\": \"..m)L=true end end;j:close()os.queueEvent(\"nosleep\")os.pullEvent()end;if not L then error(\"no pattern matching \"..q[1])end elseif r==8 then if#q<1 then error(\"Usage: dpkg-query [options...] --print-avail <package-name...>\")end;local w=i()local function D(p)if type(p)==\"table\"then return p.Short..\"\\n\"..string.gsub(p.Long,\"\\n\\n\",\"\\n .\\n\")else return p end end;for E,F in pairs(q)do for o,p in pairs(w)do if o==F then for G,z in pairs(p)do print(G..\": \"..D(z))end;break end end;print(\"\")end else error(\"Usage: dpkg-query [options...] <command>\")end\n",created=1704748610868,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=8892},["md5sum.lua"]={modified=1704748612460,data="local a=require\"sha2\"local b=require\"system.util\"local c=assert(b.argparse({b=false,binary=\"@b\",c=false,check=\"@c\",tag=false,t=false,text=\"@t\",z=false,zero=\"@z\",[\"ignore-missing\"]=false,quiet=false,status=false,strict=false,w=false,warn=\"@w\",h=false,help=\"@h\",v=false,version=\"@v\"},...))if c.h then print[[\nUsage: md5sum [OPTION]... [FILE]...\nPrint or check MD5 (128-bit) checksums.\n\nWith no FILE, or when FILE is -, read standard input.\n  -b, --binary          read in binary mode\n  -c, --check           read checksums from the FILEs and check them\n      --tag             create a BSD-style checksum\n  -t, --text            read in text mode (default)\n  -z, --zero            end each output line with NUL, not newline,\n                          and disable file name escaping\n\nThe following five options are useful only when verifying checksums:\n      --ignore-missing  don't fail or report status for missing files\n      --quiet           don't print OK for each successfully verified file\n      --status          don't output anything, status code shows success\n      --strict          exit non-zero for improperly formatted checksum lines\n  -w, --warn            warn about improperly formatted checksum lines\n\n      --help        display this help and exit\n      --version     output version information and exit\n\nThe sums are computed as described in RFC 1321.\nWhen checking, the input should be a former output of this program.\nThe default mode is to print a line with: checksum, a space,\na character indicating input mode ('*' for binary, ' ' for text\nor where binary is insignificant), and name for each FILE.\n]]return elseif c.v then print(\"1.0\")return end;c[1]=c[1]or\"-\"for d,e in ipairs(c)do local f=e==\"-\"and io.stdin or assert(io.open(e,c.b and not c.t and\"rb\"or\"r\"))local g=a.md5()local h;repeat local i=f:read(\"*L\")h=g(i)until not i;if f~=io.stdin then f:close()end;local j;if c.tag then j=\"MD5 (\"..e..\") = \"..h else j=h..\"  \"..e end;if c.z then io.stdout:write(j..\"\\0\")else print(j)end end\n",created=1704748612471,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=2010},["sudo.lua"]={modified=1704748612972,data="local a=require\"usermgr\"local b=require\"system.ipc\"local c=require\"system.process\"local d=require\"system.terminal\"local e=require\"system.util\"local f=assert(e.argparse({[\"\"]={stopProcessingOnPositionalArgument=true},D=true,chdir=\"@D\",E=false,[\"preserve-env\"]=\"@E\",H=false,[\"set-home\"]=\"@H\",i=false,login=\"@i\",K=false,[\"remove-timestamp\"]=\"@K\",k=false,[\"reset-timestamp\"]=\"@k\",l=false,list=\"@l\",n=false,[\"non-interactive\"]=\"@n\",p=true,prompt=\"@p\",R=true,chroot=\"@R\",s=false,shell=\"@s\",U=true,[\"other-user\"]=\"@U\",T=\"number\",[\"command-timeout\"]=\"@T\",u=true,user=\"@u\",v=false,validate=\"@v\",V=false,version=\"@V\",h=false,help=\"@h\"},...))local g,h=c.getuser()if g~=\"root\"then error(\"This program must be run as root. Make sure the setuser bit is set.\")end;if not f[1]or f.h then print(\":help\")return end;local i=f.u or f.user or\"root\"io.stdout:write(\"Password: \")d.termctl({echo=false})local j=io.stdin:read()d.termctl({echo=true})print()local k,l=a.authenticate(h,j)if l then print(l)end;if k then local m=a.getUserInfo(i)local n=c.fork(function()c.setuser(i)if m and m.home then c.getenv().HOME=m.home;c.chdir(m.home)end;c.execp(table.unpack(f))end)for o,p in pairs(b.signal)do b.sigaction(p,function()b.kill(n,p)end)end;repeat local q,r=coroutine.yield()until q==\"process_complete\"and r.id==n else print(\"sudo: Sorry\")end\n",created=1704748613028,owner="root",setuser=true,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1318},["sha512sum.lua"]={modified=1704748612464,data="return coroutine.yield(\"syscall\",\"exec\",\"/usr/bin/shasum\",\"-a\",\"512\",...)\n",created=1704748612473,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=74},["sha256sum.lua"]={modified=1704748612462,data="return coroutine.yield(\"syscall\",\"exec\",\"/usr/bin/shasum\",\"-a\",\"256\",...)\n",created=1704748612472,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=74},["dpkg.lua"]={modified=1704748610843,data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=require\"dpkg\"local d=require\"dpkg.divert\"local e=require\"dpkg.query\"local f=require\"dpkg.trigger\"local function g(h)return a.combine(c.admindir,h)end;local function i(j,k)local l=a.open(j,\"w\")l.write(k)l.close()end;local function m(n,o)return({string.match(n.Status,\"(%S+) (%S+) (%S+)\")})[o]end;local function p(n,o,q)local r={string.match(n.Status,\"(%S+) (%S+) (%S+)\")}r[o]=q;n.Status=table.concat(r,\" \")return n.Status end;local function s(t)local b=io.popen(\"/bin/less\",\"w\")b:write(t)b:close()end;local u=[[Usage: dpkg [<option> ...] <command>\n\nCommands:\n    -i|--install       <.deb file name> ... | -R|--recursive <directory> ...\n    --unpack           <.deb file name> ... | -R|--recursive <directory> ...\n    -A|--record-avail  <.deb file name> ... | -R|--recursive <directory> ...\n    --configure        <package> ... | -a|--pending\n    --triggers-only    <package> ... | -a|--pending\n    -r|--remove        <package> ... | -a|--pending\n    -P|--purge         <package> ... | -a|--pending\n    -V|--verify <package> ...        Verify the integrity of package(s).\n    --get-selections [<pattern> ...] Get list of selections to stdout.\n    --set-selections                 Set package selections from stdin.\n    --clear-selections               Deselect every non-essential package.\n    --update-avail [<Packages-file>] Replace available packages info.\n    --merge-avail [<Packages-file>]  Merge with info from file.\n    --clear-avail                    Erase existing available info.\n    --forget-old-unavail             Forget uninstalled unavailable pkgs.\n    -s|--status <package> ...        Display package status details.\n    -p|--print-avail <package> ...   Display available version details.\n    -L|--listfiles <package> ...     List files 'owned' by package(s).\n    -l|--list [<pattern> ...]        List packages concisely.\n    -S|--search <pattern> ...        Find package(s) owning file(s).\n    -C|--audit [<package> ...]       Check for broken package(s).\n    --yet-to-unpack                  Print packages selected for installation.\n    --predep-package                 Print pre-dependencies to unpack.\n    --add-architecture <arch>        Add <arch> to the list of architectures.\n    --remove-architecture <arch>     Remove <arch> from the list of architectures.\n    --print-architecture             Print dpkg architecture.\n    --print-foreign-architectures    Print allowed foreign architectures.\n    --assert-<feature>               Assert support for the specified feature.\n    --validate-<thing> <string>      Validate a <thing>'s <string>.\n    --compare-versions <a> <op> <b>  Compare version numbers - see below.\n    --force-help                     Show help on forcing.\n    -Dh|--debug=help                 Show help on debugging.\n\n    -?, --help                       Show this help message.\n        --version                    Show the version.\n\nAssertable features: support-predepends, working-epoch, long-filenames,\n    multi-conrep, multi-arch, versioned-provides.\n\nValidatable things: pkgname, archname, trigname, version.\n\nUse dpkg with -b, --build, -c, --contents, -e, --control, -I, --info,\n    -f, --field, -x, --extract, -X, --vextract, --ctrl-tarfile, --fsys-tarfile\non archives (type dpkg-deb --help).\n\nOptions:\n    --admindir=<directory>     Use <directory> instead of /var/lib/dpkg.\n    --root=<directory>         Install on a different root directory.\n    --instdir=<directory>      Change installation dir without changing admin dir.\n    --path-exclude=<pattern>   Do not install paths which match a shell pattern.\n    --path-include=<pattern>   Re-include a pattern after a previous exclusion.\n    -O|--selected-only         Skip packages not selected for install/upgrade.\n    -E|--skip-same-version     Skip packages whose same version is installed.\n    -G|--refuse-downgrade      Skip packages with earlier version than installed.\n    -B|--auto-deconfigure      Install even if it would break some other package.\n    --[no-]triggers            Skip or force consequential trigger processing.\n    --verify-format=<format>   Verify output format (supported: 'rpm').\n    --no-debsig                Do not try to verify package signatures.\n    --no-act|--dry-run|--simulate\n                               Just say what we would do - don't do it.\n    -D|--debug=<octal>         Enable debugging (see -Dhelp or --debug=help).\n    --status-fd <n>            Send status change updates to file descriptor <n>.\n    --status-logger=<command>  Send status change updates to <command>'s stdin.\n    --log=<filename>           Log status changes and actions to <filename>.\n    --ignore-depends=<package>,...\n                               Ignore dependencies involving <package>.\n    --force-...                Override problems (see --force-help).\n    --no-force-...|--refuse-...\n                               Stop when problems encountered.\n    --abort-after <n>          Abort after encountering <n> errors.\n\nComparison operators for --compare-versions are:\n    lt le eq ne ge gt       (treat empty version as earlier than any version);\n    lt-nl le-nl ge-nl gt-nl (treat empty version as later than any version);\n    < << <= = >= >> >       (only for compatibility with control file syntax).\n\nUse 'apt' or 'aptitude' for user-friendly package management.]]local v={}local w=nil;local x=false;local y=false;local z=nil;local A,B;local C,D;for E,F in ipairs({...})do if w~=nil then table.insert(v,F)elseif string.match(F,\"^%-[^-]\")then local G=string.sub(F,2,2)if G=='i'then w=0 elseif G=='r'then w=4 elseif G=='P'then w=5 elseif G=='V'then w=6 elseif G=='C'then w=7 elseif G=='?'then if c.options.pager then s(u)else print(u)end;return elseif G=='D'then elseif G=='b'or G=='c'or G=='e'or G=='x'or G=='X'or G=='f'or G=='I'then w=13 elseif G=='l'or G=='s'or G=='L'or G=='S'or G=='p'then w=14 elseif G=='B'then c.options.auto_deconfigure=true elseif G=='R'then x=true elseif G=='G'then c.force.downgrade=false elseif G=='O'then y=true elseif G=='E'then c.options.skip_same_version=true end else local H;if string.find(F,\"=\")then F,H=string.match(F,\"^(.+)=(.+)$\")end;if F==\"--install\"then w=0 elseif F==\"--unpack\"then w=1 elseif F==\"--configure\"then w=2 elseif F==\"--triggers-only\"then w=3 elseif F==\"--remove\"then w=4 elseif F==\"--purge\"then w=5 elseif F==\"--verify\"then w=6 elseif F==\"--audit\"then w=7 elseif F==\"--get-selections\"then w=8 elseif F==\"--set-selections\"then w=9 elseif F==\"--clear-selections\"then w=10 elseif F==\"--print-architecture\"then print(\"phoenix\")return elseif string.match(F,\"^%-%-assert%-\")then if F==\"--assert-support-predepends\"then return 0 elseif F==\"--assert-working-epoch\"then return 0 elseif F==\"--assert-long-filenames\"then return 0 elseif F==\"--assert-multi-conrep\"then return 1 elseif F==\"--assert-multi-arch\"then return 1 elseif F==\"--assert-versioned-provides\"then return 0 else return 2 end elseif string.match(F,\"^%-%-validate%-\")then w=11;z=string.match(F,\"^%-%-validate%-(.+)\")elseif F==\"--compare-verisons\"then w=12 elseif F==\"--help\"then if c.options.pager then s(u)else print(u)end;return elseif F==\"--force-help\"then(c.options.pager and s or print)([[dpkg forcing options - control behaviour when problems found:\nwarn but continue:  --force-<thing>,<thing>,...\nstop with error:    --refuse-<thing>,<thing>,... | --no-force-<thing>,...\nForcing things:\n[!] all                Set all force options\n[*] downgrade          Replace a package with a lower version\n    configure-any      Configure any package which may help this one\n    hold               Process incidental packages even when on hold\n    bad-verify         Install a package even if it fails authenticity check\n    bad-version        Process even packages with wrong versions\n    overwrite          Overwrite a file from one package with another\n    overwrite-diverted Overwrite a diverted file with an undiverted version\n[!] overwrite-dir      Overwrite one package's directory with another's file\n[!] confnew            Always use the new config files, don't prompt\n[!] confold            Always use the old config files, don't prompt\n[!] confdef            Use the default option for new config files if one\n                        is available, don't prompt. If no default can be found,\n                        you will be prompted unless one of the confold or\n                        confnew options is also given\n[!] confmiss           Always install missing config files\n[!] confask            Offer to replace config files with no new versions\n[!] architecture       Process even packages with wrong or no architecture\n[!] breaks             Install even if it would break another package\n[!] conflicts          Allow installation of conflicting packages\n[!] depends            Turn all dependency problems into warnings\n[!] depends-version    Turn dependency version problems into warnings\n[!] remove-reinstreq   Remove packages which require installation\n[!] remove-essential   Remove an essential package\n\nWARNING - use of options marked [!] can seriously damage your installation.\nForcing options marked [*] are enabled by default.]])return elseif F==\"--build\"or F==\"--contents\"or F==\"--control\"or F==\"--extract\"or F==\"--vextract\"or F==\"--field\"or F==\"--ctrl-tarfile\"or F==\"--fsys-tarfile\"or F==\"--info\"then w=13 elseif F==\"--list\"or F==\"--status\"or F==\"--listfiles\"or F==\"--search\"or F==\"--print-avail\"then w=14 elseif F==\"--auto-deconfigure\"then c.options.auto_deconfigure=true elseif F==\"--debug\"then elseif string.match(F,\"^%-%-force%-\")or string.match(F,\"^%-%-no%-force%-\")or string.match(F,\"^%-%-refuse%-\")then local I=string.match(F,\"^%-%-force%-\")~=nil;local J=F:gsub(\"^%-%-force%-\",\"\"):gsub(\"^%-%-no%-force%-\",\"\"):gsub(\"^%-%-refuse%-\",\"\")if J==\"downgrade\"then c.force.downgrade=I elseif J==\"configure-any\"then c.force.configure_any=I elseif J==\"hold\"then c.force.hold=I elseif J==\"remove-reinstreq\"then c.force.remove_reinstreq=I elseif J==\"remove-essential\"then c.force.remove_essential=I elseif J==\"depends\"then c.force.depends=I elseif J==\"depends-version\"then c.force.depends_version=I elseif J==\"breaks\"then c.force.breaks=I elseif J==\"conflicts\"then c.force.conflicts=I elseif J==\"confmiss\"then c.force.confmiss=I elseif J==\"confnew\"and c.force.confmode~=2 then c.force.confmode=0 elseif J==\"confold\"and c.force.confmode~=2 then c.force.confmode=1 elseif J==\"confdef\"then c.force.confmode=2 elseif J==\"confask\"and c.force.confmode==nil then c.force.confmode=nil elseif J==\"overwrite\"then c.force.overwrite=I elseif J==\"overwrite-dir\"then c.force.overwrite_dir=I elseif J==\"overwrite-diverted\"then c.force.overwrite_diverted=I elseif J==\"architecture\"then c.force.architecture=I elseif J==\"bad-version\"then c.force.bad_version=I elseif J==\"bad-verify\"then c.force.bad_verify=I end elseif F==\"--ignore-depends\"then for E,F in ipairs(split(H,\",\"))do c.options.ignore_depends[F]=true end elseif F==\"--no-act\"or F==\"--dry-run\"or F==\"--simulate\"then c.options.dry_run=true elseif F==\"--recursive\"then x=true elseif F==\"--admindir\"then c.admindir,d.admindir,e.admindir,f.admindir=H,H,H,H elseif F==\"--root\"then c.rootdir=H elseif F==\"--selected-only\"then y=true elseif F==\"--skip-same-verison\"then c.options.skip_same_version=true elseif F==\"--pre-invoke\"then A=H elseif F==\"--post-invoke\"then B=H elseif F==\"--path-exclude\"then C=H elseif F==\"--path-include\"then D=H elseif F==\"--no-pager\"then c.options.pager=false elseif F==\"--no-triggers\"then c.options.triggers=false elseif F==\"--triggers\"then c.options.triggers=true end end end;local function K(t)c.error(t)print([[\n\nType dpkg --help for help about installing and deinstalling packages [*];\nUse 'apt' or 'aptitude' for user-friendly package management;\nType dpkg -Dhelp for a list of dpkg debug flag values;\nType dpkg --force-help for a list of forcing options;\nType dpkg-deb --help for help about manipulating *.deb files;\n\nOptions marked [*] produce a lot of output !]])return 2 end;if w==nil then K(\"need an action option\")end;if not a.exists(g(\"\"))then a.mkdir(g(\"info\"))a.mkdir(g(\"triggers\"))i(g(\"status\"),\"\")i(g(\"triggers/Unincorp\"),\"\")i(g(\"triggers/File\"),\"\")end;if w==0 or w==1 then if#v==0 then K((w==0 and\"--install\"or\"--unpack\")..\" needs at least one package archive file argument\")end;local L={}for E,F in ipairs(v)do if not a.exists(F)then c.error(\"cannot access archive '\"..F..\"': No such file or directory\")return 2 end;if x then if not a.isDir(F)then c.error(\"cannot access directory '\"..F..\"': Not a directory\")return 2 end;local function M(g)for E,N in ipairs(a.list(g))do if a.isDir(a.combine(g,N))then M(a.combine(g,N))elseif N:match(\"^.*%.deb$\")then c.print(\"Loading \"..F..\" (this may take a while) ...\")local O,P=pcall(c.package,N)if not O then c.error(\"cannot access archive '\"..a.combine(g,N)..\"': \"..P)return 2 end;table.insert(L,P)end end end;M(F)else c.print(\"Loading \"..F..\" (this may take a while) ...\")local O,P=pcall(c.package,F)if not O then c.error(\"cannot access archive '\"..F..\"': \"..P)return 2 end;table.insert(L,P)end end;if#L==0 then c.error(\"searched, but found no packages (files matching *.deb)\")return 2 end;local Q={}for E,F in ipairs(L)do c.print(\"Selecting previously unselected package \"..F.name..\".\")if c.package.packagedb==nil then c.readDatabase()end;c.package.packagedb[F.name]=c.package.packagedb[F.name]or{Status=\"unknown ok not-installed\"}p(c.package.packagedb[F.name],1,\"install\")if not F.unpack()or w==0 and not F.configure()then table.insert(Q,F.name)end end;if c.options.triggers then for R,F in pairs(c.package.packagedb)do if F[\"Triggers-Pending\"]then c.print(\"Processing triggers for \"..R..\" (\"..F.Version..\") ...\")f.commit(R,c.package.triggerdb,c.package.packagedb)end end end;e.writeDatabase(c.package.packagedb)if#Q>0 then c.print(\"dpkg: error processing \"..table.concat(Q,\", \"))return 2 else return 0 end elseif w==2 then if x then c.warn(\"--recursive specified, but this flag is ineffective with --configure\")end;if#v==0 then K(\"--configure needs at least one package name argument\")end;c.readDatabase()local Q={}if v[1]==\"--pending\"or v[1]==\"-a\"then for R,F in pairs(c.package.packagedb)do if e.status.needs_configure(m(F,3))then local O,P=pcall(c.package,R)if not O or not P.configure()then table.insert(Q,R)end end end else for E,R in ipairs(v)do if e.status.needs_configure(m(c.package.packagedb[R],3))then local O,P=pcall(c.package,R)if not O or not P.configure()then table.insert(Q,R)end end end end;e.writeDatabase(c.package.packagedb)if#Q>0 then c.print(\"dpkg: error processing \"..table.concat(Q,\", \"))return 2 else return 0 end elseif w==3 then if x then c.warn(\"--recursive specified, but this flag is ineffective with --triggers-only\")end;if#v==0 then K(\"--triggers-only needs at least one package name argument\")end;c.readDatabase()local Q={}if v[1]==\"--pending\"or v[1]==\"-a\"then if c.options.triggers then for R,F in pairs(c.package.packagedb)do if F[\"Triggers-Pending\"]then c.print(\"Processing triggers for \"..R..\" (\"..F.Version..\") ...\")f.commit(R,c.package.triggerdb,c.package.packagedb)end end end else if c.options.triggers then for E,R in ipairs(v)do if c.package.packagedb[R][\"Triggers-Pending\"]then c.print(\"Processing triggers for \"..R..\" (\"..c.package.packagedb[R].Version..\") ...\")f.commit(R,c.package.triggerdb,c.package.packagedb)end end end end;e.writeDatabase(c.package.packagedb)if#Q>0 then c.print(\"dpkg: error processing \"..table.concat(Q,\", \"))return 2 else return 0 end elseif w==4 then if x then c.warn(\"--recursive specified, but this flag is ineffective with --remove\")end;if#v==0 then K(\"--remove needs at least one package name argument\")end;c.readDatabase()local Q={}for E,R in ipairs(v)do local O,P=pcall(c.package,R)if O then p(c.package.packagedb[R],1,\"deinstall\")end;if not O or not P.remove(false)then table.insert(Q,R)end end;e.writeDatabase(c.package.packagedb)if#Q>0 then c.print(\"dpkg: error processing \"..table.concat(Q,\", \"))return 2 else return 0 end elseif w==5 then if x then c.warn(\"--recursive specified, but this flag is ineffective with --purge\")end;if#v==0 then K(\"--purge needs at least one package name argument\")end;c.readDatabase()local Q={}for E,R in ipairs(v)do local O,P=pcall(c.package,R)if O then p(c.package.packagedb[R],1,\"purge\")end;if not O or not P.remove(true)then table.insert(Q,R)end end;e.writeDatabase(c.package.packagedb)if#Q>0 then c.print(\"dpkg: error processing \"..table.concat(Q,\", \"))return 2 else return 0 end elseif w==6 then if x then c.warn(\"--recursive specified, but this flag is ineffective with --verify\")end;c.readDatabase()local Q={}if#v==0 then for R in pairs(c.package.packagedb)do local O,P=pcall(c.package,R)if not O or not P.verify()then table.insert(Q,R)end end else for E,R in ipairs(v)do local O,P=pcall(c.package,R)if not O or not P.verify()then table.insert(Q,R)end end end;e.writeDatabase(c.package.packagedb)if#Q>0 then c.print(\"dpkg: error verifying \"..table.concat(Q,\", \"))return 2 else return 0 end elseif w==7 then c.readDatabase()if#v==0 then for R,F in pairs(c.package.packagedb)do if not a.exists(g(\"info/\"..R..\".list\"))then c.warn(\"package \"..R..\" is missing a file list\\nTo fix this issue: reinstall the package\")end;if not a.exists(g(\"info/\"..R..\".md5sums\"))then c.warn(\"package \"..R..\" is missing an md5sum list\\nTo fix this issue: reinstall the package\")end;if m(F,1)==\"install\"then if m(F,3)==\"half-installed\"or m(F,2)==\"reinstreq\"then c.warn(\"package \"..R..\" is not installed properly\\nTo fix this issue: reinstall the package\")elseif m(F,3)==\"not-installed\"or m(F,3)==\"config-files\"then c.warn(\"package \"..R..\" is marked for installation, but it is not installed\\nTo fix this issue: install the package\")elseif m(F,3)~=\"installed\"then c.warn(\"package \"..R..\" is not configured\\nTo fix this issue: configure the package\")end elseif m(F,1)==\"deinstall\"then if m(F,3)==\"not-installed\"then c.warn(\"package \"..R..\" is marked for removal of non-config files, but config files are not installed\\nTo fix this issue: reinstall package then remove properly\")elseif m(F,3)==\"installed\"or m(F,3)==\"triggers-pending\"or m(F,3)==\"triggers-awaited\"then c.warn(\"package \"..R..\" is marked for removal, but the package hasn't been removed\\nTo fix this issue: remove the package\")elseif m(F,3)~=\"config-files\"then c.warn(\"package \"..R..\" was not removed properly\\nTo fix this issue: remove the package\")end elseif m(F,1)==\"purge\"then if m(F,3)==\"config-files\"then c.warn(\"package \"..R..\" is marked for purge, but config files are still installed\\nTo fix this issue: purge the package\")elseif m(F,3)==\"installed\"or m(F,3)==\"triggers-pending\"or m(F,3)==\"triggers-awaited\"then c.warn(\"package \"..R..\" is marked for purge, but the package hasn't been removed\\nTo fix this issue: remove the package\")elseif m(F,3)~=\"config-files\"then c.warn(\"package \"..R..\" was not purged properly\\nTo fix this issue: remove the package\")end elseif m(F,1)==\"unknown\"then c.warn(\"package \"..R..\" is in an unknown status\\nTo fix this issue: (re)install the package\")end end else for E,R in ipairs(v)do local F=c.package.packagedb[R]if not F then c.warn(\"package \"..R..\" not found\")else if not a.exists(g(\"info/\"..R..\".list\"))then c.warn(\"package \"..R..\" is missing a file list\\nTo fix this issue: reinstall the package\")end;if not a.exists(g(\"info/\"..R..\".md5sums\"))then c.warn(\"package \"..R..\" is missing an md5sum list\\nTo fix this issue: reinstall the package\")end;if m(F,1)==\"install\"then if m(F,3)==\"half-installed\"or m(F,2)==\"reinstreq\"then c.warn(\"package \"..R..\" is not installed properly\\nTo fix this issue: reinstall the package\")elseif m(F,3)==\"not-installed\"or m(F,3)==\"config-files\"then c.warn(\"package \"..R..\" is marked for installation, but it is not installed\\nTo fix this issue: install the package\")elseif m(F,3)~=\"installed\"then c.warn(\"package \"..R..\" is not configured\\nTo fix this issue: configure the package\")end elseif m(F,1)==\"deinstall\"then if m(F,3)==\"not-installed\"then c.warn(\"package \"..R..\" is marked for removal of non-config files, but config files are not installed\\nTo fix this issue: reinstall package then remove properly\")elseif m(F,3)==\"installed\"or m(F,3)==\"triggers-pending\"or m(F,3)==\"triggers-awaited\"then c.warn(\"package \"..R..\" is marked for removal, but the package hasn't been removed\\nTo fix this issue: remove the package\")elseif m(F,3)~=\"config-files\"then c.warn(\"package \"..R..\" was not removed properly\\nTo fix this issue: remove the package\")end elseif m(F,1)==\"purge\"then if m(F,3)==\"config-files\"then c.warn(\"package \"..R..\" is marked for purge, but config files are still installed\\nTo fix this issue: purge the package\")elseif m(F,3)==\"installed\"or m(F,3)==\"triggers-pending\"or m(F,3)==\"triggers-awaited\"then c.warn(\"package \"..R..\" is marked for purge, but the package hasn't been removed\\nTo fix this issue: remove the package\")elseif m(F,3)~=\"config-files\"then c.warn(\"package \"..R..\" was not purged properly\\nTo fix this issue: remove the package\")end elseif m(F,1)==\"unknown\"then c.warn(\"package \"..R..\" is in an unknown status\\nTo fix this issue: (re)install the package\")end end end end elseif w==8 then c.readDatabase()local S={}if#v==0 then for R,F in pairs(c.package.packagedb)do if m(F,3)~=\"not-installed\"then table.insert(S,{R,m(F,1)})end end else for E,R in ipairs(v)do table.insert(S,{R,m(c.package.packagedb[R],1)})end end;textutils.tabulate(table.unpack(S))elseif w==9 then elseif w==10 then c.readDatabase()for R,F in pairs(c.package.packagedb)do if F.Priority~=\"essential\"and F.Priority~=\"required\"then p(F,1,\"deinstall\")end end;e.writeDatabase(c.package.packagedb)return 0 elseif w==11 then if z==\"pkgname\"then return string.match(v[1],\"^%w[%w+-.]+$\")and 0 or 2 elseif z==\"trigname\"then return string.match(v[1],\"^%w[%w+-.]+$\")and 0 or 2 elseif z==\"archname\"then return(v[1]==\"all\"or v[1]==\"any\"or v[1]==\"phoenix\"or v[1]==\"source\")and 0 or((v[1]==\"i386\"or v[1]==\"amd64\"or v[1]==\"powerpc\"or v[1]==\"armv7h\"or v[1]==\"aarch64\"or v[1]==\"ppc64el\"or v[1]==\"ia64\"or v[1]==\"s390x\"or v[1]==\"mips\"or v[1]==\"mipsel\"or v[1]==\"mips64el\"or v[1]==\"armv7el\")and 1 or 2)elseif z==\"version\"then return c.compareVersions(v[1],\"1\")and 0 or 2 else K(\"unknown option --validate-\"..z)end elseif w==12 then if#v<3 then K(\"--compare-versions takes three arguments: <version> <relation> <version>\")end;local T=c.findRelationship(\"a\",v[1],\"a (\"..v[2]..\" \"..v[3]..\")\")if T==nil then return 2 elseif T==true then return 0 else return 1 end elseif w==13 then return b.run(\"/usr/bin/dpkg-deb\",...)elseif w==14 then return b.run(\"/usr/bin/dpkg-query\",...)end\n",created=1704748610869,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=22540},["dhclient.lua"]={modified=1704748611760,data="local a=require\"system.hardware\"local b=require\"system.network\"local c=require\"system.util\"local d=...if not d then error(\"Usage: dhclient <interface>\")end;local e=a.wrap(d)if not e or not a.hasType(e,\"modem\")then error(\"Device does not exist or is not a modem\")end;e:open(68)a.listen(e,true)local f=math.random(0,2^31-1)local g=a.info(\"/\").metadata.id;e:transmit(67,68,{dhcp=true,type=\"discover\",from=g,messageID=f,options={netmask=true}})local h=c.timer(2)local i={}while true do local j,k=coroutine.yield()if j==\"modem_message\"and k.channel==68 and k.replyChannel==67 and type(k.message)==\"table\"and k.message.dhcp==true and k.message.to==g and k.message.messageID==f and k.message.type==\"offer\"then i[k.message.from]={ip=k.message.offeredIP,netmask=k.message.options.netmask,up=true}elseif j==\"timer\"and k.id==h then break end end;if#i==0 then a.listen(e,false)e:close(68)error(\"Could not get IP address: Timed out\")end;for l,m in pairs(i)do b.control(m.ip,\"ping\")c.sleep(2)if not b.arp.list(d)[m.ip]then e:transmit(67,68,{dhcp=true,type=\"request\",from=g,to=l,messageID=f,options={netmask=true}})h=c.timer(2)while true do local j,k=coroutine.yield()if j==\"modem_message\"and k.channel==68 and k.replyChannel==67 and type(k.message)==\"table\"and k.message.dhcp==true and k.message.to==g and k.message.messageID==f and k.message.type==\"acknowledgement\"then b.ipconfig(d,m)a.listen(e,false)e:close(68)c.cancel(h)return elseif j==\"timer\"and k.id==h then a.listen(e,false)e:close(68)error(\"Could not get IP address: No response from server\")end end end end;a.listen(e,false)e:close(68)error(\"Could not get IP address: No usable offers\")\n",created=1704748611765,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1634},["route.lua"]={modified=1704748611763,data="local a=require\"system.hardware\"local b=require\"system.network\"local function c(d)if d:match\"^%d+$\"then return tonumber(d)elseif d:match\"^%d+%.%d+$\"then return tonumber(d:match\"^%d+\")*0x1000000+tonumber(d:match\"^%d+%.(%d+)\")elseif d:match\"^%d+%.%d+%.%d+$\"then return tonumber(d:match\"^(%d+)\")*0x1000000+tonumber(d:match\"^%d+%.(%d+)\")*0x10000+tonumber(d:match\"^%d+%.%d+%.(%d+)\")elseif d:match\"^%d+%.%d+%.%d+%.%d+$\"then return tonumber(d:match\"^(%d+)\")*0x1000000+tonumber(d:match\"^%d+%.(%d+)\")*0x10000+tonumber(d:match\"^%d+%.%d+%.(%d+)\")*0x100+tonumber(d:match\"^%d+%.%d+%.%d+%.(%d+)\")else error(\"Invalid IP address\",2)end end;local function e(f)if not f then return nil end;return(\"%d.%d.%d.%d\"):format(bit32.band(bit32.rshift(f,24),0xFF),bit32.band(bit32.rshift(f,16),0xFF),bit32.band(bit32.rshift(f,8),0xFF),bit32.band(f,0xFF))end;local function g(f)return bit32.bnot(2^(32-f)-1)end;local function h(i)local j=0;while bit32.btest(i,0x80000000)do i,j=bit32.lshift(i,1),j+1 end;return j end;local function k(f)return e(g(f))end;local l={...}if l[1]==\"add\"then local m={}local n=2;while n<=#l do if l[n]==\"netmask\"then m.sourceNetmask=l[n+1]n=n+2 elseif l[n]==\"gw\"then m.action=\"unicast\"m.destination=l[n+1]n=n+2 elseif l[n]==\"dev\"then m.device=l[n+1]n=n+2 elseif l[n]==\"table\"then m.table=tonumber(l[n+1])n=n+2 elseif l[n]==\"reject\"then m.action=\"prohibit\"n=n+1 elseif l[n]==\"default\"then m.source=\"0.0.0.0\"m.sourceNetmask=0;n=n+1 elseif l[n]==\"-host\"then m.action=\"local\"m.sourceNetmask=32;n=n+1 elseif l[n]==\"-net\"then m.action=\"local\"n=n+1 else m.source=l[n]if m.source:match\"^[%d%.]+/%d+$\"then m.source,m.sourceNetmask=m.source:match\"^([%d%.]+)/(%d+)$\"m.sourceNetmask=tonumber(m.sourceNetmask)end;n=n+1 end end;if not m.device then if m.action==\"local\"then for o,p in ipairs{a.find(\"modem\")}do local q=a.path(p)local d=b.ipconfig(q)if d then local r=c(d.ip)local s=g(d.netmask)local t=c(m.source)if bit32.band(t,s)==bit32.band(r,s)then m.device=q;break end end end;if not m.device then error(\"Could not find suitable device; please specify 'dev <device>'\")end elseif m.action==\"unicast\"then for o,p in ipairs{a.find(\"modem\")}do local q=a.path(p)local d=b.ipconfig(q)if d then local r=c(d.ip)local s=g(d.netmask)local t=c(m.destination)if bit32.band(t,s)==bit32.band(r,s)then m.device=q;break end end end;if not m.device then error(\"Could not find suitable device; please specify 'dev <device>'\")end end end;b.route.add(m)elseif l[1]==\"del\"then local u,i,f;local n=2;while n<=#l do if l[n]==\"netmask\"then i=l[n+1]n=n+2 elseif l[n]==\"table\"then f=tonumber(l[n+1])n=n+2 elseif l[n]==\"default\"then u=\"0.0.0.0\"i=0;n=n+1 elseif l[n]==\"-host\"then i=32;n=n+1 elseif l[n]==\"-net\"or l[n]==\"reject\"then n=n+1 elseif l[n]==\"gw\"or l[n]==\"table\"then n=n+2 else u=l[n]if u:match\"^[%d%.]+/%d+$\"then u,i=u:match\"^([%d%.]+)/(%d+)$\"i=tonumber(i)end;n=n+1 end end;b.route.remove(u,i,f)elseif l[1]==nil then print(\"Destination\\tGateway \\tNetmask \\tFlags\\tTable\\tDevice\")for n=0,1024 do local v=b.route.list(n)if not v then break end;for o,w in ipairs(v)do local x=\"U\"if w.sourceNetmask==32 then x=x..\"H\"end;if w.action==\"unicast\"then x=x..\"G\"end;if w.action==\"unreachable\"or w.action==\"prohibit\"then x=x..\"!\"end;print(w.source,w.destination or\"0.0.0.0 \",k(w.sourceNetmask),x,n,w.device or\"*\")end end else error(\"Usage: route [add|del] [options...]\")end\n",created=1704748611767,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=3334},["ifconfig.lua"]={modified=1704748611761,data="local a=require\"system.hardware\"local b=require\"system.network\"local c={...}local d=table.remove(c,1)if not d then for e,f in ipairs{a.find(\"modem\")}do local g=a.path(f)local h=b.ipconfig(g)if h then print(g..\": \"..(h.up and\"up\"or\"down\")..\", ip \"..h.ip..\", netmask \"..h.netmask)else print(g..\": down, no ip\")end end;return end;local f=a.wrap(d)if not f then error(\"No such device\")end;if not a.hasType(f,\"modem\")then error(\"Interface is not a modem\")end;local i=1;local j={}while i<=#c do if c[i]==\"up\"then j.up=true;i=i+1 elseif c[i]==\"down\"then j.up=false;i=i+1 elseif c[i]==\"netmask\"then j.netmask=tonumber(c[i+1])or c[i+1]i=i+2 else if c[i]:match(\"([^/]+)/%d+$\")then j.ip,j.netmask=c[i]:match(\"([^/]+)/(%d+)$\")j.netmask=tonumber(j.netmask)else j.ip=c[i]end;i=i+1 end end;b.ipconfig(d,j)\n",created=1704748611766,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=791}},owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0}},owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},etc={modified=1704748613023,created=1704748613023,contents={shadow={modified=1704748613177,data="phoenix:$5$atf2kZPrcjWCESpuOohJXA==$OTIxYmM2NTYwMWM5Y2M5MWZmMzhmNzc2OTRkNjQ4YTA1M2EzNzc0NmIxYjU4YzJkZGYyYjhkMWMwYjllNGJjYQ==:19540::::::\n",created=1704748613177,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=137},motd={modified=1704748612966,data="\nWelcome to Phoenix, the next generation operating system for ComputerCraft.\n",created=1704748613023,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=77},fstab={modified=1704748613177,data="tmpfs /tmp tmpfs defaults,auto 0 0\ntmpfs /var/log tmpfs defaults,auto 0 0\n/ /root craftos defaults,auto 0 0\n",created=1704748613177,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=108},initrd={modified=1704748611129,created=1704748611129,contents={["initrd.conf"]={modified=1704748611114,data="# initrd configuration file\n\n# Uncomment this line to add a rescue shell and utilites to the initrd.\n# rescue_shell = true\n\n# A list of kernel modules to include in the initrd.\n# Example:\n# modules = {\"spanfs\", \"gfxterm\"}\nmodules = {}\n\n# A list of files to copy to the initrd.\n# These should be absolute paths to files on the main filesystem, with an\n# optional \"=<path>\" to move the file to a different location.\n# Example:\n# files = {\"/bin/nano.lua\", \"/lib/libsystem.a\", \"/etc/initrd/myhook.lua=/myhook.lua\"}\nfiles = {}\n\n# A list of files to execute in the init program before mounting the root filesystem.\n# These are executed using dofile, and thus must be full Lua file names, with\n# extensions if needed.\n# Example:\n# hook_preflight = {\"/myhook.lua\"}\nhook_preflight = {}\n\n# A list of files to execute in the init program after root is mounted but before\n# the real init is executed. The initrd is no longer mounted at this point.\n# These are executed using dofile, and thus must be full Lua file names, with\n# extensions if needed.\n# Example:\n# hook_postflight = {\"/bin/myhook.lua\"}\nhook_postflight = {}\n\n# Where to save the initrd file to.\noutput_path = \"/boot/initrd.img\"",created=1704748611129,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1179},["hooks.d"]={modified=1704748611128,created=1704748611128,contents={["01-files.lua"]={modified=1704748611112,data="if not config.modules then return end;local a=require\"system.filesystem\"for b,c in ipairs(config.files)do local d,e=c:match(\"^([^=]+)=(.+)$\")if not e then d,e=c,c end;e=a.combine(rootDirectory,e)a.copy(d,e,true)end\n",created=1704748611127,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=215},["10-init.lua"]={modified=1704748611114,data="local a=[==[\nprint(\"initrd: init running\")\n]==]if config.hook_preflight then for b,c in ipairs(config.hook_preflight)do a=a..'print(\"initrd: running hook '..c..'\")\\ndofile(\"'..c..'\")\\n'end end;a=a..[==[\nprint(\"initrd: mounting root filesystem\")\nlocal _, args = coroutine.yield(\"syscall\", \"kernargs\")\nlocal options = {}\nif args.rootflags then\n    for m in args.rootflags:gmatch \"[^,]+\" do\n        local k, v = m:match(\"^([^=]+)=(.*)$\")\n        if k and v then\n            if v == \"true\" then options[k] = true\n            elseif v == \"false\" then options[k] = false\n            else options[k] = tonumber(v) or v end\n        else options[m] = true end\n    end\nend\ncoroutine.yield(\"syscall\", \"unmount\", \"/\")\nlocal ok, err = coroutine.yield(\"syscall\", \"mount\", args.rootfstype or \"craftos\", args.root, \"/\", options)\nif not ok then\n    coroutine.yield(\"syscall\", \"syslog\", {module = \"initrd\", level = 6}, \"initrd: could not mount root device: \" .. err .. \"\\n\")\n    while true do coroutine.yield() end\n    return false\nend\n-- TODO: reopen log file\n]==]if config.hook_postflight then for b,c in ipairs(config.hook_postflight)do a=a..'print(\"initrd: running hook '..c..'\")\\ndofile(\"'..c..'\")\\n'end end;a=a..[==[\nprint(\"initrd: starting real init\")\nif args.init then coroutine.yield(\"syscall\", \"exec\", args.init) end\nprint(\"Could not find provided init, trying default locations\")\ncoroutine.yield(\"syscall\", \"exec\", \"/sbin/init\")\ncoroutine.yield(\"syscall\", \"exec\", \"/etc/init\")\ncoroutine.yield(\"syscall\", \"exec\", \"/bin/init\")\ncoroutine.yield(\"syscall\", \"exec\", \"/bin/sh\")\nio.stderr:write(\"initrd: no working init found\")\nreturn false\n]==]local d=assert(io.open(rootDirectory..\"/init.lua\",\"w\"))d:write(a)d:close()\n",created=1704748611128,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1705},["05-shell.lua"]={modified=1704748611113,data="if not config.rescue_shell then return end;local a=require\"system.filesystem\"a.copy(\"/bin/cash.lua\",a.combine(rootDirectory,\"bin/cash.lua\"),true)a.copy(\"/bin/chmod.lua\",a.combine(rootDirectory,\"bin/chmod.lua\"),true)a.copy(\"/bin/chown.lua\",a.combine(rootDirectory,\"bin/chown.lua\"),true)a.copy(\"/bin/chroot\",a.combine(rootDirectory,\"bin/chroot.lua\"),true)a.copy(\"/bin/cp.lua\",a.combine(rootDirectory,\"bin/cp.lua\"),true)a.copy(\"/bin/kill.lua\",a.combine(rootDirectory,\"bin/kill.lua\"),true)a.copy(\"/bin/less.lua\",a.combine(rootDirectory,\"bin/less.lua\"),true)a.copy(\"/bin/link.lua\",a.combine(rootDirectory,\"bin/link.lua\"),true)a.copy(\"/bin/ls.lua\",a.combine(rootDirectory,\"bin/ls.lua\"),true)a.copy(\"/bin/lua.lua\",a.combine(rootDirectory,\"bin/lua.lua\"),true)a.copy(\"/bin/mkdir.lua\",a.combine(rootDirectory,\"bin/mkdir.lua\"),true)a.copy(\"/bin/mount.lua\",a.combine(rootDirectory,\"bin/mount.lua\"),true)a.copy(\"/bin/nano.lua\",a.combine(rootDirectory,\"bin/nano.lua\"),true)a.copy(\"/bin/ps.lua\",a.combine(rootDirectory,\"bin/ps.lua\"),true)a.copy(\"/bin/rm.lua\",a.combine(rootDirectory,\"bin/rm.lua\"),true)a.copy(\"/bin/sh.lua\",a.combine(rootDirectory,\"bin/sh.lua\"),true)a.copy(\"/bin/unmount.lua\",a.combine(rootDirectory,\"bin/unmount.lua\"),true)a.copy(\"/lib/libsystem.a\",a.combine(rootDirectory,\"lib/libsystem.a\"),true)\n",created=1704748611128,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1300},["00-modules.lua"]={modified=1704748611112,data="if not config.modules then return end;local a=require\"system.filesystem\"a.mkdir(a.combine(rootDirectory,\"lib/modules\"))for b,c in ipairs(config.modules)do local d=a.combine(rootDirectory,\"lib/modules\",c..\".lua\")a.copy(\"/lib/modules/\"..c..\".lua\",d)a.chmod(d,\"root\",\"rwx\")a.chmod(d,nil,\"r-x\")a.chown(d,\"root\")end\n",created=1704748611126,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=311}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},passwd={modified=1704748613177,data="phoenix:x::::/home/phoenix:/bin/cash\n",created=1704748613177,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=37},skel={modified=1704748613024,created=1704748613024,contents={[".cashrc"]={modified=1704748612968,data="PS1=\"\\033[1;32m\\u@\\h\\033[39m:\\033[34m\\W\\033[0m\\$ \"",created=1704748613024,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=50}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},["ftpmgr.conf"]={modified=1704748610957,data="## ftpmgr configuration file\n\n## The IP address to serve on. \"0.0.0.0\" indicates any IP/interface.\nip = \"0.0.0.0\";\n\n## The port to serve the command stream on. FTP standard is 21.\nport = 21;\n\n## The range of ports to reserve for passive connections.\npassivePortRange = {65000, 65535};\n\n## The users allowed to connect. A special \"anonymous\" user is used for\n## connections without a login - if not present, clients will be required to log\n## in before accessing files.\n\n## The default root login, which authenticates via usermgr, and allows access to\n## the entire filesystem with root permissions.\n\nuser \"root\" {}\n\n## Uncomment this to allow any user registered on the system to log in.\n#allUsers = true;\n\n## An example of an anonymous login, which runs as a virtual user and does not\n## require a password.\n\n#user \"anonymous\" {\n#    systemUser = \"ftp-user\";   # The Phoenix username to run the server as\n#    allowWrite = false;        # Whether to allow the user to write files\n#    useSystemLogin = false;    # Whether to use usermgr to authenticate logins\n#    root = \"/var/ftp\";         # The filesystem root visible to the user\n#}\n\n## An example of a virtual user with a password. This user runs as root, but\n## does not have write permissions.\n\n#user \"virtual\" {\n#   password = \"virtual-user-password!\";    # The password for the user (plaintext!)\n#   allowWrite = false;                     # Whether to allow the user to write files\n#   root = \"/\";                             # The filesystem root visible to the user\n#}\n\n## An example of a virtual user with a more securely stored password. This user\n## runs as a user named \"virtual\", but does not check usermgr, and thus does not\n## need to be a registered user on the system.\n\n#user \"virtual-secure\" {\n#   systemUser = \"virtual\";     # The Phoenix username to run the server as\n#   # The hash of the password in SHA-256\n#   passwordHash = \"05bb25e9186d1014c5eb723edb0bf17987e6fe1b9eaeae5c88f217d1b3024b23\";\n#   passwordSalt = \"12345678\";  # The salt applied to the end of the password\n#   allowWrite = true;          # Whether to allow the user to write files\n#   root = \"/\";                 # The filesystem root visible to the user\n#}",created=1704748610980,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=2201},startmgr={modified=1704748610394,created=1704748610394,contents={system={modified=1704748613025,created=1704748613025,contents={["netmgr.service"]={modified=1704748611702,data="local process = require \"system.process\"\n\nunit.description = \"Networking Manager\"\nservice.restart = \"always\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.startbg(\"/usr/libexec/netmgr\")\n    return true\nend\n",created=1704748611706,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=260},["ftpmgr.service"]={modified=1704748610958,data="local process = require \"system.process\"\n\nunit.description = \"FTP server\"\nservice.restart = \"always\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.startbg(\"/usr/libexec/ftpmgr\")\n    return true\nend\n",created=1704748610981,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=252},["usermgr.service"]={modified=1704748612970,data="local process = require \"system.process\"\n\nunit.description = \"User Manager\"\nservice.restart = \"always\"\nservice.restartTime = 0\n\nfunction start()\n    service.pid[1] = process.startbg(\"/usr/libexec/usermgr\")\n    return true\nend\n",created=1704748613025,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=226},["startup.service.wants"]={modified=1704748613021,created=1704748613021,contents={["login.service"]={modified=1704748612969,data="local process = require \"system.process\"\n\nunit.description = \"Login Prompt\"\nunit.requires = {\"usermgr\"}\nunit.after = {\"usermgr\"}\nservice.restart = \"always\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.start(\"/usr/bin/login\")\n    return true\nend\n",created=1704748613025,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=300},["automount.service"]={modified=1704748610394,data="local process = require \"system.process\"\n\nunit.description = \"Automatically mount filesystems\"\nservice.restart = \"no\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.startbg(\"/bin/mount\", \"-a\")\n    return true\nend",created=1704748610434,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=265},["diskmgr.service"]={modified=1704748610715,data="local process = require \"system.process\"\n\nunit.description = \"Disk Manager\"\nservice.restart = \"always\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.startbg(\"/usr/libexec/diskmgr\")\n    return true\nend\n",created=1704748610718,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=255}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},["diskmgr.service"]={modified=1704748610715,data="local process = require \"system.process\"\n\nunit.description = \"Disk Manager\"\nservice.restart = \"always\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.startbg(\"/usr/libexec/diskmgr\")\n    return true\nend\n",created=1704748610718,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=255},["login.service"]={modified=1704748612969,data="local process = require \"system.process\"\n\nunit.description = \"Login Prompt\"\nunit.requires = {\"usermgr\"}\nunit.after = {\"usermgr\"}\nservice.restart = \"always\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.start(\"/usr/bin/login\")\n    return true\nend\n",created=1704748613025,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=300},["automount.service"]={modified=1704748610394,data="local process = require \"system.process\"\n\nunit.description = \"Automatically mount filesystems\"\nservice.restart = \"no\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.startbg(\"/bin/mount\", \"-a\")\n    return true\nend",created=1704748610434,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=265},["startup.service"]={modified=1704748612666,data="unit.description = \"Startup Tasks\"\nunit.requires = {}\n\nfunction start() return true end\nfunction stop() return true end",created=1704748612686,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=119},["dhcpmgr.service"]={modified=1704748610627,data="local process = require \"system.process\"\n\nunit.description = \"DHCP Manager\"\nservice.restart = \"always\"\nservice.restartTime = 0\ninstall.wantedBy = \"startup\"\n\nfunction start()\n    service.pid[1] = process.startbg(\"/usr/libexec/dhcpmgr\")\n    return true\nend\n",created=1704748610631,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=255}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},["dhcpmgr.conf"]={modified=1704748610627,data="## dhcpmgr configuration file\n\n## The network interface to host on. Leaving it as nil will host on a random\n## interface - this is not recommended for most uses, so make sure to set it.\ninterface = nil\n\n## The first address to assign to clients.\nfirstaddr = \"10.0.1.2\"\n\n## The last address to assign to clients.\nlastaddr = \"10.0.1.254\"\n\n## The network mask for assigned addresses. If set to nil, the mask will be\n## inferred from the first and last addresses.\nnetmask = nil\n\n## The gateway address to report to clients. Set to nil to not report a gateway.\ngateway = \"10.0.1.1\"\n\n## The DNS server addresses to report to clients. Set to nil to not report DNS.\ndns = {\"10.0.1.1\"}\n\n## The length of a DHCP lease, in seconds. nil means the lease never expires.\nleasetime = 86400\n\n## Whether to allow clients to request static addresses.\nallowrequests = true\n\n## Whether to store address assignments for clients permanently.\n## If this is enabled, the server will store the first address assigned to a\n## client, and will prefer to use that address if available.\nstoreassignments = false\n\n## Whether to force re-assigning addresses if a client requests an IP before its\n## lease expires.\nforcereassign = false\n\n## Static address assignments. These are in the form `static [id] = \"address\"`.\n# static [25] = \"10.0.1.15\"\n# static [28] = \"10.0.1.132\"\n\n## Other options to provide to clients. These are in the form\n## `options.name = value`.\n# options.domain = \"subnet.cc\"\n# options.bootServers = {\"10.0.1.1\"}\n# options.bootFile = \"/boot.lua\"\n",created=1704748610630,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1533},["network.conf"]={modified=1704748611701,data="## netmgr network configuration file\n## WORK-IN-PROGRESS - not all features implemented\n\n## Defines a set of rules for a specific network interface.\n## `(auto)` will pick the first network interface it finds. Use this if you only\n## have one interface.\n## Otherwise, use `\"<device>\"` to select a device.\n\ninterface (auto) {\n\n    ## Sets the way to acquire a network address. Valid options:\n    ## dhcp - Use DHCP to automatically acquire an address from a server/router\n    ## dhcp_staticaddr - Use DHCP with a manual requested address\n    ## static - Use a static address\n    acquire = dhcp;\n\n    ## If using a static IP address, define its parameters here.\n    ## dhcp_staticaddr only needs `address`.\n    ## static needs `address`, `netmask` (if not in the address), and `gateway`.\n    # address = \"10.0.1.2/24\";   # sets the netmask in the address\n    # address = \"10.0.1.2\";      # sets the netmask separately\n    # netmask = \"255.255.255.0\";\n    # gateway = \"10.0.1.1\";\n\n    ## DNS servers to use when resolving domain names. Optional if using DHCP.\n    # dns = {\n    #     \"10.0.1.1\",\n    #     \"10.0.1.4\"\n    # };\n\n}",created=1704748611705,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1124}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},sbin={modified=1704748612688,created=1704748612688,contents={["startctl.lua"]={modified=1704748612669,data="local a=require\"startmgr\"local b=require\"system.util\"local c=assert(b.argparse({user=false},...))local d;if not c.user then d=\"root\"end;if not a[c[1]]then error(\"Invalid operation\")end;if c[1]==\"list\"then local e,f=a.list(d)for g,h in pairs(f)do print(g..\": \"..(h.running and\"running\"or\"stopped\"))end else print(a[c[1]](c[2],d))end\n",created=1704748612688,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=332},["init.lua"]={modified=1704748612668,data="local a=require\"system.expect\"local b=require\"system.filesystem\"local c=require\"system.ipc\"local d=require\"system.log\"local e=require\"system.process\"local f=require\"system.sync\"local g=require\"system.util\"startmgr={}local h,i;local j={}local k=e.getuser()if k==\"root\"then assert(e.getpid()==1,\"startmgr must be run as init.\")h={\"/etc/startmgr/system\",j}c.register(\"ServiceManager\")i=d.create(\"startmgr\",true,\"/var/log/startmgr.log\")else assert(not c.lookup(\"ServiceManager.\"..k),\"startmgr is already running for this user.\")h={\"/home/\"..k..\"/.local/etc/startmgr\",\"/etc/startmgr/user\",j}c.register(\"ServiceManager.\"..k)i=d.create(\"startmgr.\"..k,true,\"/home/\"..k..\"/.local/var/log/startmgr.log\")end;local l={}local m,n;local o={[0]='\\27[90m','\\27[97m','\\27[36m','\\27[93m','\\27[31m','\\27[95m','\\27[96m'}local function p(q,r,...)if k==\"root\"then local s=o[r or 1]if q==\"OK\"then s=\"\\27[92m\"end;local t=...print((q and\"[\"..s..(\" \"):rep(math.floor((6-#q)/2))..q..(\" \"):rep(math.ceil((6-#q)/2))..\"\\27[0m]\"or\"        \")..\"  \"..t)end;i.log({level=r},...)end;local function u(v)if type(v)==\"table\"then local w={}for x,t in pairs(v)do w[u(x)]=u(t)end;return w else return v end end;local function y(z,A)if next(z)==nil then return true end;local B=f.barrier.new(#z+1)local C,D=true,\"\"for x,t in pairs(z)do e.newthread(function()local E,F=A(x)if t and not E then C=false;if F then D=D..F..\"\\n\"end end;B:wait()end)end;B:wait()return C,D:gsub(\"\\n+$\",\"\")end;function startmgr.start(G)local H=l[G]if not H then return false,\"No such service\"end;if H.runtime.running then return false,\"Service is already running\"end;if H.runtime.pending then return true end;local I={}for J,t in ipairs(H.unit.wants or{})do I[t]=false end;for J,t in ipairs(H.unit.upholds or{})do I[t]=false end;for J,t in ipairs(H.unit.requires or{})do if not l[t]then return false,\"Required service \"..t..\" does not exist\"end;I[t]=true end;for J,t in ipairs(H.unit.bindsTo or{})do if not l[t]then return false,\"Required service \"..t..\" does not exist\"end;I[t]=true end;for J,t in ipairs(H.unit.requisites or{})do if not l[t]or not l[t].runtime.running then return false,\"Requisite service \"..t..\" is not running\"end end;for J,t in ipairs(H.unit.conflicts or{})do if l[t]and l[t].runtime.running then return false,\"Conflicting service \"..t..\" is running\"end end;local K,L,M={},{[G]=true},{}local N,O={},{}for J,t in ipairs(H.unit.before or{})do N[t]=true end;for J,t in ipairs(H.unit.after or{})do O[t]=true end;for x,t in pairs(I)do if O[x]then K[x]=t end;if N[x]then M[x]=t end;if l[x]then for J,P in ipairs(l[x].unit.before or{})do if P==x then K[x]=t;break end end;for J,P in ipairs(l[x].unit.after or{})do if P==x then M[x]=t;break end end end;if K[x]and M[x]then return false,\"Service is misconfigured: Dependency \"..x..\" is ordered both before and after service\"end;if not K[x]and not M[x]then L[x]=t end end;if H.runtime.pending then return true end;H.runtime.pending=true;local E,F=y(K,startmgr.start)if not E then H.runtime.pending=false;return false,F end;E,F=y(L,function(Q)if Q==G then local E,R=false,\"Missing service start function\"if H.start then p(nil,nil,\"Starting \"..(H.unit and H.unit.description or Q)..\"...\")E,R=pcall(H.start)H.runtime.running=E and R;H.runtime.pending=false;p(E and R and\"OK\"or\"ERROR\",E and R and d.levels.notice or d.levels.error,\"Started \"..(H.unit and H.unit.description or Q)..\".\")end;if not E and type(R)==\"string\"then p(\"ERROR\",d.levels.error,\"Service \"..Q..\" threw an error:\",R)end;if not E or not R then return false,E and\"Failed to start service\"or R end;return true else return startmgr.start(Q)end end)if not E then return false,F end;return y(M,startmgr.start)end;function startmgr.stop(G)local H=l[G]if not H then return false,\"No such service\"end;if not H.runtime.running then return false,\"Service is already stopped\"end;local S={[G]=true}for J,t in ipairs(H.unit.bindsTo or{})do S[t]=false end;for J,t in ipairs(H.unit.parts or{})do S[t]=false end;return y(S,function(Q)if Q==G then p(nil,nil,\"Stopping \"..(H.unit and H.unit.description or Q)..\"...\")H.runtime.pending=true;if H.stop then local E,R=pcall(H.stop,false)H.runtime.running=not(E and R)if H.runtime.running then if not E and type(R)==\"string\"then p(\"ERROR\",d.levels.error,\"Service \"..Q..\" threw an error:\",R)end;return false,E and\"Failed to start service\"or R end end;for J,t in pairs(H.service.pid)do c.kill(t,c.signal.SIGHUP)end;return true else return startmgr.stop(Q)end end)end;function startmgr.kill(G)local H=l[G]if not H then return false,\"No such service\"end;if not H.runtime.running then return false,\"Service is already stopped\"end;local S={[G]=true}for J,t in ipairs(H.unit.bindsTo or{})do S[t]=false end;for J,t in ipairs(H.unit.parts or{})do S[t]=false end;return y(S,function(Q)if Q==G then p(nil,nil,\"Killing \"..(H.unit and H.unit.description or Q)..\"...\")H.runtime.pending=true;if H.stop then pcall(H.stop,true)H.runtime.running=false end;for J,t in pairs(H.service.pid)do c.kill(t,c.signal.SIGKILL)end;return true else return startmgr.stop(Q)end end)end;function startmgr.restart(G)local E,F=startmgr.stop(G)if not E then return E,F end;return startmgr.start(G)end;local function T(U,V,W,X,Y,Z)local _=setmetatable(u(U[V])or{name=V,path=W~=j and b.combine(W,X)or nil,runtime={},unit={},install={},service={pid={}},timer={}},{__index=_ENV})local A,F;if W==j then A,F=load(X,\"=service:\"..V,\"t\",_)else A,F=loadfile(b.combine(W,X),\"t\",_)end;if A then local E;E,F=pcall(A)if E then if _.service and type(_.unit.partOf)==\"table\"then for J,t in ipairs(_.unit.partOf)do Y[t]=Y[t]or{}Y[t][#Y[t]+1]=V end end;U[V]=_;_.runtime.didDelete=nil else Z[#Z+1]=\"\\x1b[31mError\\x1b[0m: Could not load \"..V..\": \"..F end else Z[#Z+1]=\"\\x1b[31mError\\x1b[0m: Could not load \"..V..\": \"..F end end;function startmgr.reload(G)if G then local H=l[G]if not H then return false,\"No such service\"end;if not H.runtime.running then return false,\"Service is not running\"end;if H.reload then return pcall(H.reload)else return true,\"Service has no reload function\"end else local U={}local Z={}for x,t in pairs(l)do if t.runtime.running then U[x]=t;t.runtime.didDelete=true end end;local Y={}for J,W in ipairs(h)do local E,z;if W==j then E,z=true,j else E,z=pcall(b.list,W)end;if E then for J,X in ipairs(z)do local V=W==j and select(2,X:match\"name%s*=%s*([\\\"'])([^\\\"']+)%1\")or X:match(\"^%w+\")if X:match\"%.wants$\"and b.isDir(b.combine(W,X))then if not U[V]then U[V]={unit={requires={}}}end;if not U[V].unit.requires then U[V].unit.requires={}end;local a0=U[V].unit.requires;for J,a1 in ipairs(b.list(b.combine(W,X)))do local Q=a1:match(\"^%w+\")T(U,Q,b.combine(W,X),a1,Y,Z)a0[#a0+1]=Q end else T(U,V,W,X,Y,Z)end end end end;for x,t in pairs(Y)do if U[x]and U[x].service then U[x].unit.parts=t end end;for x,t in pairs(U)do if t.runtime.didDelete then Z[#Z+1]=\"\\x1b[93mWarning\\x1b[0m: The service \"..x..\"was deleted on disk, but it is still running. The service will be deleted upon being stopped.\"end end;l=U;return true,Z end end;function startmgr.add(a2)local J,X=a2:match\"name%s*=%s*([\\\"'])([^\\\"']+)%1\"if not X then return false,\"Could not get name from service\"end;if l[X]then return false,\"Service with this name already exists\"end;j[#j+1]=a2;startmgr.reload()return true,X end;function startmgr.remove(G)for a3,t in ipairs(j)do local J,X=t:match\"name%s*=%s*([\\\"'])([^\\\"']+)%1\"if X==G then table.remove(j,a3)return true end end;return false end;function startmgr.list()local w={}for x,t in pairs(l)do w[x]={running=t.runtime.running}end;return true,w end;function startmgr.status(G)end;function startmgr.install(G)local H=l[G]if not H or not H.path or not H.install.wantedBy then return false end;local a4=l[H.install.wantedBy]if not a4 or not a4.path then return false end;b.mkdir(a4.path..\".wants\")if not b.exists(a4.path..\".wants/\"..b.basename(H.path))then b.link(a4.path..\".wants/\"..b.basename(H.path),H.path)end;return true end;function startmgr.uninstall(G)local H=l[G]if not H or not H.path or not H.install.wantedBy then return false end;local a4=l[H.install.wantedBy]if not a4 or not a4.path then return false end;b.remove(a4.path..\".wants/\"..b.basename(H.path))return true end;local function a5()p(nil,nil,\"Stopping all services...\")local a6=0;repeat local E=true;for x,t in pairs(l)do if t.runtime.running then E=(a6>=5 and startmgr.kill or startmgr.stop)(x)and E end end;a6=a6+1;if a6>10 then p(\"ERROR\",d.levels.error,\"Could not stop all services successfully, killing all processes.\")elseif a6==5 then p(nil,nil,\"Killing all remaining services...\")end;g.sleep(0.25)until E or a6>10 end;function startmgr.shutdown()if k~=\"root\"then return false,\"Operation invalid for this instance\"end;a5()g.syscall.devcall(\"/\",\"shutdown\")end;function startmgr.reboot()if k~=\"root\"then return false,\"Operation invalid for this instance\"end;a5()g.syscall.devcall(\"/\",\"reboot\")end;print(\"Welcome to \\27[96mPhoenix\\27[0m!\\n\")startmgr.reload()if not l.startup then p(\"WARN\",d.levels.warning,\"No startup service available. Installing default shell service.\")local a7={}l.startup={name=\"startup\",runtime={},unit={description=\"Shell prompt\"},install={},service={pid=a7,restart=k==\"root\"and\"always\"or\"no\"},timer={},start=function()a7[1]=e.start(\"/bin/sh\")return true end}end;assert(startmgr.start(\"startup\"))while true do local a8,a9=coroutine.yield()if a8==\"timer\"and a9.id==n then n=g.timer(m)elseif a8==\"process_complete\"then for x,t in pairs(l)do for a3,a7 in pairs(t.service and t.service.pid or{})do if a7==a9.id then t.service.pid[a3]=nil;local aa=a9.error or a9.value==false;p(nil,nil,\"Process \"..a7 ..\" (of service \"..x..\") exited \"..(aa and\"with an error: \"or\"successfully with return value: \")..(a9.error or tostring(a9.value)))if a9.error then p(\"ERROR\",d.levels.error,a9.error)end;if next(t.service.pid)==nil then if t.runtime.running and not t.runtime.pending and t.service.restart and t.service.restart~=\"no\"then if t.service.restart==\"always\"or t.service.restart==\"on-success\"and not aa or t.service.restart==\"on-failure\"and a9.value==false or t.service.restart==\"on-abnormal\"and aa or t.service.restart==\"on-abort\"and a9.error then startmgr.start(x)end else t.runtime.running=false;t.runtime.pending=false;if aa then if t.failure then pcall(t.failure)end elseif t.success then pcall(t.success)end;p(\"OK\",d.levels.notice,\"Stopped \"..(t.unit and t.unit.description or x)..\".\")end end end end end elseif a8==\"remote_event\"and a9.type==\"startmgr.request\"then if type(a9.data)==\"table\"and type(a9.data.func)==\"string\"then local ab=e.getpinfo(a9.sender)if ab.user==k then e.newthread(function()local A=startmgr[a9.data.func]if A then c.sendEvent(a9.sender,\"startmgr.response\",{func=a9.data.func,ok=true,result={A(a9.data.param)}})else c.sendEvent(a9.sender,\"startmgr.response\",{func=a9.data.func,ok=false,error=\"Unknown function\"})end end)else c.sendEvent(a9.sender,\"startmgr.response\",{func=a9.data.func,ok=false,error=\"Permission denied\"})end else c.sendEvent(a9.sender,\"startmgr.response\",{func=a9.data.func,ok=false,error=\"Invalid request\"})end end end\n",created=1704748612687,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=11007},["mkspanfs.lua"]={modified=1704748612553,data="local a=require\"system.filesystem\"local b=require\"system.hardware\"local c=require\"system.process\"local d={...}if#d<3 then error(\"Usage: mkspanfs <name> <index drive> <data drives...>\")end;if c.getuser()~=\"root\"then error(\"This program must be run as root.\")end;local e=table.remove(d,1)local f=\"The following disks will be erased and replaced with a new span filesystem:\\n\"for g,h in ipairs(d)do local i=b.info(h)if not i then error(\"Device '\"..h..\"' does not exist.\")end;if not i.types.drive then error(\"Device '\"..h..\"' is not a compatible disk drive.\")end;f=f..\"  Drive '\"..(i.alias or i.displayName or b.path(h))..\"' (\"..i.uuid..\")\\n\"end;print(f)io.write(\"Continue? (y/N) \")local j=io.read()if j:upper()~=\"Y\"then return false end;local k=('xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'):gsub('[xy]',function(l)local h=l=='x'and math.random(0,0xf)or math.random(8,0xb)return('%x'):format(h)end)local m=\"/tmp/.mkspanfs-\"..math.random(0,99999)a.mkdir(m)local n,o=0,0;for p,h in ipairs(d)do a.mount(\"drivefs\",h,m,{})for g,q in ipairs(a.list(m))do a.remove(m..\"/\"..q)end;local r=assert(io.open(m..\"/.spanfs\",\"w\"))r:write(e..\"\\n\"..k..\"\\n\"..p-1 ..\"\\n\")r:close()if p==1 then r=assert(io.open(m..\"/index\",\"wb\"))r:write((\"<III8I8BBs2s2Bs2BI\"):pack(38+#e,0,os.time()*1000,os.time()*1000,5,5,e,\"root\",1,\"root\",7,0))r:close()local s=a.stat(m)print(\"Index disk \"..h..\" has \"..s.freeSpace..\" bytes free\")else local s=a.stat(m)print(\"Data disk \"..h..\" has \"..s.freeSpace..\" bytes free\")n=n+s.freeSpace;o=o+s.capacity end;a.unmount(m)end;a.remove(m)print(\"Finished creating span filesystem '\"..e..\"' (\"..k..\") across \"..#d..\" disks.\")print(\"Total disk capacity: \"..o)print(\"Usable space: \"..n)\n",created=1704748612574,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1673},["spaninfo.lua"]={modified=1704748612554,data="local a=require\"system.util\"local b=...if not b then error(\"Usage: spaninfo <mountpoint>\\n\")end;local function c(d)if d>=1000000000 then return(\"%.3g GB\"):format(d/1000000000)elseif d>=1000000 then return(\"%.3g MB\"):format(d/1000000)elseif d>=1000 then return(\"%.3g kB\"):format(d/1000)else return d..\" bytes\"end end;local e=a.syscall.callmodule(\"spanfs\",\"info\",b)local f=a.syscall.stat(b)print(\"Span '\"..e.name..\"' (\"..e.uuid..\")\")print(\"Capacity: \"..c(f.capacity))print(\"Free space: \"..c(f.freeSpace))print(\"Disks:\")for g,h in pairs(e.disks)do print(\"  Disk \"..g..\" (\"..h.device:match(\"^%x+\")..\"): \"..h.space..\" bytes free\")end;print(\"Free index space: \"..e.freeindex)\n",created=1704748612576,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=670},["shutdown.lua"]={modified=1704748612668,data="local a=require\"startmgr\"local b=require\"system.log\"local c=require\"system.process\"local d=require\"system.util\"local e=assert(d.argparse({P=false,poweroff=\"@P\",H=\"@P\",halt=\"@P\",h=\"@P\",r=false,reboot=\"@r\",c=false,show=false,help=false},...))if e.help then print[[\nUsage: shutdown [OPTIONS] [TIME]\nOptions:\n  --help          Show this help\n  -H, --halt      Equivalent to -P\n  -P, --poweroff  Power off the machine\n  -r, --reboot    Reboot the machine\n  -h              Equivalent to -P\n  -c              Cancel a pending shutdown\n  --show          Show pending shutdown\n]]end;local f={31,28,31,30,31,30,31,31,30,31,30,31}local function g(h)return h%4==0 and(h%100~=0 or h%400==0)end;if e.c then return a.remove(\"shutdown-timer\",\"root\")elseif e.show then local i=a.status(\"shutdown-timer\",\"root\")if i then else print(\"No scheduled shutdown.\")end else local j=e[1]or\"+1\"if j==\"+0\"or j==\"now\"then if e.r and not e.P then assert(a.reboot())else assert(a.shutdown())end else local k;if j:match\"^%+%d+$\"then k=tonumber(j:match\"^%+(%d+)$\")*60 elseif j:match\"^%d+:%d+$\"then local l,m=j:match\"^(%d+):(%d+)$\"l,m=tonumber(l),tonumber(m)if l<0 or l>23 or m<0 or m>59 then error(\"shutdown: Invalid argument\")end;local n=os.date(\"!*t\")if l<n.hour or l==n.hour and m<n.min then n.day=n.day+1;n.wday=(n.wday+1)%7;n.yday=(n.yday+1)%(g(n.year)and 366 or 365)if n.day>f[n.month]or n.month==2 and g(n.year)and n.day>29 then n.day=1;n.month=n.month+1;if n.month>12 then n.month=1;n.year=n.year+1 end end end;n.hour,n.min,n.sec=l,m,0;k=os.time(n)-os.time()else error(\"shutdown: Invalid argument\")end;assert(a.add([[\nname = \"shutdown-timer\"\nunit.description = \"Shutdown Timer\"\nfunction trigger()\n    startmgr.]]..(e.r and not e.P and\"reboot\"or\"shutdown\")..[[()\nend\ntimer.loadTime = ]]..k,\"root\"))b.notice(\"System is going down in \"..k/60 ..\" minutes.\")end end\n",created=1704748612688,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1836},["spanadd.lua"]={modified=1704748612553,data="local a=require\"system.filesystem\"local b=require\"system.hardware\"local c=require\"system.process\"local d=require\"system.util\"local e={...}if#e<2 then error(\"Usage: spanadd <span mount> <drives...>\")end;if c.getuser()~=\"root\"then error(\"This program must be run as root.\")end;local f=table.remove(e,1)local g=d.syscall.callmodule(\"spanfs\",\"info\",f)local h=\"The following disks will be erased and added to the span filesystem '\"..(g.name or g.uuid)..\"':\\n\"for i,j in ipairs(e)do local k=b.info(j)if not k then error(\"Device '\"..j..\"' does not exist.\")end;if not k.types.drive then error(\"Device '\"..j..\"' is not a compatible disk drive.\")end;h=h..\"  Drive '\"..(k.alias or k.displayName or b.path(j))..\"' (\"..k.uuid..\")\\n\"end;print(h)io.write(\"Continue? (y/N) \")local l=io.read()if l:upper()~=\"Y\"then return false end;local m=\"/tmp/.mkspanfs-\"..math.random(0,99999)a.mkdir(m)local n,o=g.freeSpace,g.capacity;for i,j in ipairs(e)do a.mount(\"drivefs\",j,m,{})for i,p in ipairs(a.list(m))do a.remove(m..\"/\"..p)end;local q=assert(io.open(m..\"/.spanfs\",\"w\"))q:write(g.name..\"\\n\"..g.uuid..\"\\n\"..#g.disks+1 ..\"\\n\")q:close()local r=a.stat(m)print(\"Data disk \"..j..\" has \"..r.freeSpace..\" bytes free\")n=n+r.freeSpace;o=o+r.capacity;g.disks[#g.disks+1]={device=j,space=r.freeSpace}a.unmount(m)end;a.remove(m)print(\"Finished adding \"..#e..\" disks to the span filesystem '\"..g.name..\"' (\"..g.uuid..\").\")print(\"New total disk capacity: \"..o)print(\"Usable space: \"..n)print(\"You must remount the filesystem or restart the computer for changes to take effect.\")\n",created=1704748612575,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1543}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},boot={modified=1704748613177,created=1704748613177,contents={["pxboot.lua"]={modified=1704748612341,data="if not(fs or term or os.pullEvent)then error(\"This program must be run from CraftOS.\")end;local a=require\"cc.expect\"if not getmetatable(a)then setmetatable(a,{__call=function(self,...)return self.expect(...)end})elseif not getmetatable(a).__call then getmetatable(a).__call=function(self,...)return self.expect(...)end end;local b={}local c={}local d={}local e={}local f={}local g;local function h(i,...)local j=_G.dofile;local k=table.pack(...)local l={bit32=true,bit=true,ccemux=true,config=true,coroutine=true,debug=true,ffi=true,fs=true,http=true,io=true,jit=true,mounter=true,os=true,periphemu=true,peripheral=true,redstone=true,rs=true,term=true,utf8=true,_HOST=true,_CC_DEFAULT_SETTINGS=true,_CC_DISABLE_LUA51_FEATURES=true,_VERSION=true,assert=true,collectgarbage=true,error=true,gcinfo=true,getfenv=true,getmetatable=true,ipairs=true,load=true,loadstring=true,math=true,newproxy=true,next=true,pairs=true,pcall=true,rawequal=true,rawget=true,rawlen=true,rawset=true,select=true,setfenv=true,setmetatable=true,string=true,table=true,tonumber=true,tostring=true,type=true,unpack=true,xpcall=true,turtle=true,pocket=true,commands=true,_G=true,sound=true}local m={}for n in pairs(_G)do if not l[n]and not f[n]then table.insert(m,n)end end;for o,n in ipairs(m)do _G[n]=nil end;local p=g or _G.term.native()for o,q in ipairs{\"nativePaletteColor\",\"nativePaletteColour\",\"screenshot\"}do p[q]=_G.term[q]end;_G.term=p;_G.http.checkURL=_G.http.checkURLAsync;_G.http.websocket=_G.http.websocketAsync;if _G.commands then _G.commands=_G.commands.native end;if _G.turtle then _G.turtle.native,_G.turtle.craft=nil end;local r={os={\"version\",\"pullEventRaw\",\"pullEvent\",\"run\",\"loadAPI\",\"unloadAPI\",\"sleep\"},http={\"get\",\"post\",\"put\",\"delete\",\"patch\",\"options\",\"head\",\"trace\",\"listen\",\"checkURLAsync\",\"websocketAsync\"},fs={\"complete\",\"isDriveRoot\"}}for n,s in pairs(r)do for o,t in ipairs(s)do _G[n][t]=nil end end;local u=error;_G.error=function()end;_G.term.redirect=function()end;function _G.term.native()_G.term.native=nil;_G.term.redirect=nil;_G.error=u;term.setBackgroundColor(32768)term.setTextColor(1)term.setCursorPos(1,1)term.setCursorBlink(true)term.clear()local v;if type(i)==\"function\"then v=i else local w=fs.open(i,\"r\")if w==nil then term.setCursorBlink(false)term.setTextColor(16384)term.write(\"Could not find kernel. pxboot cannot continue.\")term.setCursorPos(1,2)term.write(\"Press any key to continue\")coroutine.yield(\"key\")os.shutdown()end;local x;v,x=loadstring(w.readAll(),\"=kernel\")w.close()if v==nil then term.setCursorBlink(false)term.setTextColor(16384)term.write(\"Could not load kernel. pxboot cannot continue.\")term.setCursorPos(1,2)term.write(x)term.setCursorPos(1,3)term.write(\"Press any key to continue\")coroutine.yield(\"key\")os.shutdown()end end;setfenv(v,_G)local y=os.shutdown;os.shutdown=function()os.shutdown=y;return v(table.unpack(k,1,k.n))end end;if debug then local function z(A,B,C,D)local E,F,G=1,debug.getupvalue(A[B],D)while F~=C and not(F==nil and E>1)do F,G=debug.getupvalue(A[B],E)E=E+1 end;A[B]=G or A[B]end;z(_G,\"loadstring\",\"nativeloadstring\",1)z(_G,\"load\",\"nativeload\",5)z(http,\"request\",\"nativeHTTPRequest\",3)z(os,\"shutdown\",\"nativeShutdown\",1)z(os,\"reboot\",\"nativeReboot\",1)if turtle then z(turtle,\"equipLeft\",\"v\",1)z(turtle,\"equipRight\",\"v\",1)end;do local E,F,G=1,debug.getupvalue(peripheral.isPresent,2)while F~=\"native\"and F~=nil do F,G=debug.getupvalue(peripheral.isPresent,E)E=E+1 end;_G.peripheral=G or peripheral end;if debug.getupvalue(j,2)==\"status\"then local o,H=debug.getupvalue(j,2)o,_G.discord=debug.getupvalue(H,4)end end;coroutine.yield()end;function e.kernel(m)d.fn=h;d.args={m.path}end;function e.chainloader(m)d.fn=shell and shell.run or function(i,...)os.run({},i,...)end;d.args={m.path}end;function e.craftos(m)d.fn=function()term.setTextColor(colors.yellow)print(os.version())term.setTextColor(colors.white)if settings.get(\"motd.enable\")then if shell then shell.run(\"motd\")else os.run({},\"/rom/programs/motd.lua\")end end end;d.args={}end;function e.args(m)if not d.args then error(\"config.lua:\"..m.line..\": args command must come after boot type\",0)end;for E=1,#m.args do d.args[#d.args+1]=m.args[E]end end;function e.global(m)_G[m.key]=m.value;f[m.key]=true end;function e.monitor(m)if peripheral.hasType then assert(peripheral.hasType(m.name,\"monitor\"),\"peripheral '\"..m.name..\"' does not exist or is not a monitor\")else assert(peripheral.getType(m.name)==\"monitor\",\"peripheral '\"..m.name..\"' does not exist or is not a monitor\")end;g=peripheral.wrap(m.name)term.redirect(g)end;function e.insmod(m)local i;if m.name:match\"^/\"then i=m.name elseif m.name:find\"[/%.]\"then i=fs.combine(shell and fs.getDir(shell.getRunningProgram())or\"pxboot\",m.name)else i=fs.combine(shell and fs.getDir(shell.getRunningProgram())or\"pxboot\",\"modules/\"..m.name..\".lua\")end;assert(loadfile(i,nil,setmetatable({entries=b,bootcfg=d,cmds=e,userGlobals=f,unbios=h},{__index=_ENV})))(m.args,i)end;local function I(J)term.setBackgroundColor(colors.black)term.setTextColor(colors.white)term.clear()term.setCursorPos(1,1)for E=0,15 do term.setPaletteColor(2^E,term.nativePaletteColor(2^E))end;for o,s in ipairs(J.commands)do local K,x;if type(s)==\"function\"then K,x=pcall(s)else K,x=pcall(e[s.cmd],s)end;if not K then d={}printError(\"Could not run boot script: \"..x)print(\"Press any key to continue.\")os.pullEventRaw(\"key\")return false end end;if not d.fn then d={}printError(\"Could not run boot script: missing boot type command\")print(\"Press any key to continue.\")os.pullEventRaw(\"key\")return false end;d.fn(table.unpack(d.args))return true end;local L;local M=setmetatable({title=\"Phoenix pxboot\",titlecolor=colors.white,backgroundcolor=colors.black,textcolor=colors.white,boxcolor=colors.white,boxbackground=colors.black,selectcolor=colors.white,selecttext=colors.black,background=nil,defaultentry=nil,timeout=30,menuentry=function(C)a(1,C,\"string\")return function(J)a(2,J,\"table\")local N=1;for E,s in pairs(J)do if type(E)==\"number\"then N=math.max(E,N)end end;local O={name=C,commands={}}for E=1,N do local P=J[E]if type(P)~=\"table\"and type(P)~=\"function\"or not P.cmd then error(\"bad command entry #\"..E..(P==nil and\" (unknown command)\"or\" (missing arguments)\"),2)end;if type(P)==\"function\"then O.commands[#O.commands+1]=P elseif P.cmd==\"description\"then O.description=P.text elseif e[P.cmd]then O.commands[#O.commands+1]=P else error(\"bad command entry #\"..E..\" (unknown command \"..P.cmd..\")\",2)end end;b[#b+1]=O;c[C]=O end end,include=function(i)a(1,i,\"string\")for o,s in ipairs(fs.find(fs.combine(L,i)))do repeat local v,x=loadfile(s,\"t\",getfenv(2))if not v then printError(\"Could not load config file: \"..x)print(\"Press any key to continue...\")os.pullEvent(\"key\")break end;local Q=L;L=fs.getDir(s)local K,x=pcall(v)L=Q;if not K then printError(\"Failed to execute config file: \"..x)print(\"Press any key to continue...\")os.pullEvent(\"key\")break end until true end end,description=function(R)a(1,R,\"string\")return{cmd=\"description\",text=R,line=debug.getinfo(2,\"l\").currentline}end,kernel=function(i)a(1,i,\"string\")return{cmd=\"kernel\",path=i,line=debug.getinfo(2,\"l\").currentline}end,chainloader=function(i)a(1,i,\"string\")return{cmd=\"chainloader\",path=i,line=debug.getinfo(2,\"l\").currentline}end,args=function(S)a(1,S,\"string\",\"table\")if type(S)==\"table\"then return{cmd=\"args\",args=S,line=debug.getinfo(2,\"l\").currentline}else local m={\"\"}local T;for P in S:gmatch\".\"do if T then if P==T then T=nil else m[#m]=m[#m]..P end elseif P=='\"'or P==\"'\"then T=P elseif P==' 'then m[#m+1]=\"\"else m[#m]=m[#m]..P end end;local N=2;return setmetatable({cmd=\"args\",args=m,line=debug.getinfo(2,\"l\").currentline},{__call=function(self,U)a(N,U,\"string\")N=N+1;local m=self.args;local T;m[#m+1]=\"\"for P in U:gmatch\".\"do if T then if P==T then T=nil else m[#m]=m[#m]..P end elseif P=='\"'or P==\"'\"then T=P elseif P==' 'then m[#m+1]=\"\"else m[#m]=m[#m]..P end end;return self end})end end,craftos={cmd=\"craftos\"},global=function(F)return function(G)return{cmd=\"global\",key=F,value=G}end end,monitor=function(C)return{cmd=\"monitor\",name=C}end,insmod=function(C)a(1,C,\"string\")return setmetatable({cmd=\"insmod\",name=C,line=debug.getinfo(2,\"l\").currentline},{__call=function(self,S)a(2,S,\"table\")self.args=S;setmetatable(self,nil)return self end})end},{__index=_ENV})term.clear()term.setCursorPos(1,1)repeat local v,x=loadfile(shell and fs.combine(fs.getDir(shell.getRunningProgram()),\"config.lua\")or\"pxboot/config.lua\",\"t\",M)if not v then printError(\"Could not load config file: \"..x)print(\"Press any key to continue...\")os.pullEvent(\"key\")break end;L=shell and fs.getDir(shell.getRunningProgram())or\"pxboot\"local K,x=pcall(v)L=nil;if not K then printError(\"Failed to execute config file: \"..x)print(\"Press any key to continue...\")os.pullEvent(\"key\")break end until true;local function V()end;if#b==0 then return V()end;local function W(N)return(\"0123456789abcdef\"):sub(N,N)end;local X,Y=term.getSize()local Z=Y-11;local _=window.create(term.current(),2,4,X-2,Y-9)local a0=window.create(_,2,2,X-4,Z)term.setBackgroundColor(M.backgroundcolor)term.clear()_.setBackgroundColor(M.boxbackground or M.backgroundcolor)_.clear()a0.setBackgroundColor(M.boxbackground or M.backgroundcolor)a0.clear()local a1,a2=1,1;if M.defaultentry then for E=1,#b do if b[E].name==M.defaultentry then a1=E;break end end;if M.timeout==0 and I(b[a1])then return end end;local function a3()a0.setVisible(false)a0.setBackgroundColor(M.boxbackground or M.backgroundcolor)a0.clear()for E=a2,a2+Z-1 do local a4=b[E]if not a4 then break end;a0.setCursorPos(2,E-a2+1)if E==a1 then a0.setBackgroundColor(M.selectcolor)a0.setTextColor(M.selecttext)else a0.setBackgroundColor(M.boxbackground or M.backgroundcolor)a0.setTextColor(M.textcolor)end;a0.clearLine()a0.write(#a4.name>X-6 and a4.name:sub(1,X-9)..\"...\"or a4.name)if E==a1 and M.timeout then local a5=tostring(M.timeout)a0.setCursorPos(X-4-#a5,E-a2+1)a0.write(a5)a0.setCursorPos(2,E-a2+1)end end;a0.setVisible(true)term.setCursorPos(5,Y-5)term.clearLine()term.setTextColor(M.titlecolor)term.write(b[a1].description or\"\")end;local function a6()local a7,a8=W(select(2,math.frexp(M.boxbackground or M.backgroundcolor))),W(select(2,math.frexp(M.boxcolor or M.textcolor)))_.setTextColor(M.boxcolor or M.textcolor)_.setCursorPos(1,1)_.write(\"\\x9C\"..(\"\\x8C\"):rep(X-4))_.blit(\"\\x93\",a7,a8)for a9=2,Y-10 do _.setCursorPos(1,a9)_.blit(\"\\x95\",a8,a7)_.setCursorPos(X-2,a9)_.blit(\"\\x95\",a7,a8)end;_.setCursorPos(1,Y-9)_.setBackgroundColor(M.boxbackground or M.backgroundcolor)_.setTextColor(M.boxcolor or M.textcolor)_.write(\"\\x8D\"..(\"\\x8C\"):rep(X-4)..\"\\x8E\")term.setCursorPos((X-#M.title)/2,2)term.setTextColor(M.titlecolor or M.textcolor)term.write(M.title)term.setCursorPos(5,Y-3)term.write(\"Use the \\x18 and \\x19 keys to select.\")term.setCursorPos(5,Y-2)term.write(\"Press enter to boot the selected OS.\")term.setCursorPos(5,Y-1)term.write(\"'c' for shell, 'e' to edit.\")a3()end;a6()local aa=M.defaultentry and M.timeout and os.startTimer(1)while true do local ab={coroutine.yield()}if ab[1]==\"timer\"and ab[2]==aa then M.timeout=M.timeout-1;if M.timeout==0 then if I(c[M.defaultentry])then return end end;a3()aa=os.startTimer(1)elseif ab[1]==\"key\"then if aa then os.cancelTimer(aa)M.timeout,aa=nil;a3()end;if(ab[2]==keys.down or ab[2]==keys.numPad2)and a1<#b then a1=a1+1;if a1>a2+Z-1 then a2=a2+1 end;a3()elseif(ab[2]==keys.up or ab[2]==keys.numPad8)and a1>1 then a1=a1-1;if a1<a2 then a2=a2-1 end;a3()elseif ab[2]==keys.enter then if I(b[a1])then return end elseif ab[2]==keys.c then V()a6()end elseif ab[1]==\"terminate\"then break end end\n",created=1704748612344,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=11564},["config.lua"]={modified=1704748612339,data="\n",created=1704748612343,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=1},["kernel.lua"]={modified=1704748610119,data="PHOENIX_VERSION=\"0.0.5\"PHOENIX_BUILD=\"PRERELEASE NONFREE Mon Jan  8 16:13:54 2024\"systemStartTime=os.epoch\"utc\"args={init=\"/sbin/init.lua\",root=\"/root\",rootfstype=\"craftos\",preemptive=true,quantum=2000000,splitkernpath=\"/boot/kernel.lua.d\",loglevel=1,console=\"tty1\",traceback=true}syscalls={}processes={[0]={name=\"kernel\",id=0,user=\"root\",dir=\"/\",root=\"/\",env=_G,vars={},dependents={}}}KERNEL=processes[0]modules={}eventHooks={}shutdownHooks={}kSyscallYield={}kSyscallComplete={}process={}filesystem={}terminal={}user={}syslog={}hardware={}if discord then discord(\"Phoenix\",\"Booting Phoenix \"..PHOENIX_VERSION)end;do local a=fs.open(\"/rom/modules/main/cc/expect.lua\",\"r\")expect=(loadstring or load)(a.readAll(),\"@/rom/modules/main/cc/expect.lua\")()a.close()setmetatable(expect,{__call=function(self,...)return self.expect(...)end})if not expect.range then function expect.range(b,c,d)expect(1,b,\"number\")expect(2,c,\"number\",\"nil\")expect(3,d,\"number\",\"nil\")if d and c and d<c then error(\"bad argument #3 (min must be less than or equal to max)\",2)end;if b~=b or b<(c or-math.huge)or b>(d or math.huge)then error((\"number outside of range (expected %s to be within %s and %s)\"):format(b,c or-math.huge,d or math.huge),3)end;return b end end end;do local a=fs.open(\"/rom/apis/textutils.lua\",\"r\")local e=setmetatable({dofile=function()return expect end},{__index=_G})local g;if loadstring and setfenv then g=loadstring(a.readAll(),\"@/rom/apis/textutils.lua\")setfenv(g,e)else g=load(a.readAll(),\"@/rom/apis/textutils.lua\",\"t\",e)end;a.close()g()serialize,unserialize=e.serialize,e.unserialize end;do local a=fs.open(\"/rom/apis/keys.lua\",\"r\")local e=setmetatable({dofile=function()return expect end},{__index=_G})if _VERSION<\"Lua 5.2\"then e._ENV=e end;local g;if loadstring and setfenv then g=loadstring(a.readAll(),\"@/rom/apis/keys.lua\")setfenv(g,e)else g=load(a.readAll(),\"@/rom/apis/keys.lua\",\"t\",e)end;a.close()g()keys={}for h,i in pairs(e)do keys[h]=i end end;if not pcall(load,\"return\",\"=test\",\"t\",{})then local j,k,expect,setfenv=load,loadstring,expect,setfenv;function load(l,m,n,e)expect(1,l,\"string\",\"function\")expect(2,m,\"string\",\"nil\")expect(3,n,\"string\",\"nil\")expect(4,e,\"table\",\"nil\")if type(l)==\"string\"then if l:sub(1,4)==\"\\27Lua\"then if n==nil or n:find\"b\"then local g,o=k(l,m)if g and e then setfenv(g,e)end;return g,o else return nil,\"attempt to load a binary chunk (mode is '\"..(n or\"bt\")..\"')\"end else if n==nil or n:find\"t\"then local g,o=k(l,m)if g and e then setfenv(g,e)end;return g,o else return nil,\"attempt to load a text chunk (mode is '\"..(n or\"bt\")..\"')\"end end else local g,o=j(l,m)if g then setfenv(g,e)end;return g,o end end end;loadstring=nil;if bit then if not bit32 then local bit=bit;bit32={bnot=bit.bnot,lshift=bit.blshift,rshift=bit.blogic_rshift,arshift=bit.brshift}function bit32.band(p,q,...)expect(1,p,\"number\")expect(2,q,\"number\",\"nil\")if not q then return p end;return bit32.band(bit.band(p,q),...)end;function bit32.bor(p,q,...)expect(1,p,\"number\")expect(2,q,\"number\",\"nil\")if not q then return p end;return bit32.bor(bit.bor(p,q),...)end;function bit32.bxor(p,q,...)expect(1,p,\"number\")expect(2,q,\"number\",\"nil\")if not q then return p end;return bit32.bxor(bit.bxor(p,q),...)end;function bit32.btest(...)return bit32.band(...)~=0 end;function bit32.extract(r,s,t)expect(1,r,\"number\")expect(2,s,\"number\")expect(3,t,\"number\",\"nil\")(expect.range or function()end)(s,0,31)(expect.range or function()end)(s+t-1,0,31)t=t or 1;local u=0;for v=s+t-1,s,-1 do u=u*2+bit.band(r,2^v)/2^v end;return u end;function bit32.replace(r,i,s,t)expect(1,r,\"number\")expect(2,i,\"number\")expect(3,s,\"number\")expect(4,t,\"number\",\"nil\")(expect.range or function()end)(s,0,31)(expect.range or function()end)(s+t-1,0,31)t=t or 1;local w=2^t-1;return bit.bor(bit.band(r,bit.bnot(bit.blshift(w,s))),bit.blshift(bit.band(i,w),s))end;function bit32.lrotate(p,x)return bit.bor(bit.blshift(p,x),bit.blogic_rshift(p,32-x))end;function bit32.rrotate(p,x)return bit.bor(bit.blogic_rshift(p,x),bit.blshift(p,32-x))end end;bit=nil end;if _VERSION==\"Lua 5.1\"and load(\"::a:: goto a\")then _VERSION=\"Lua 5.2\"if load(\"return 1 >> 2 & 3\")then _VERSION=\"Lua 5.3\"if load(\"local <const> a = 2\")then _VERSION=\"Lua 5.4\"end end end;if _VERSION==\"Lua 5.1\"then if not table.pack then table.pack=function(...)local y={...}y.n=select(\"#\",...)return y end end;if not table.unpack then table.unpack,unpack=unpack,nil end;local z,i=xpcall(function(A)return A end,function()end,true)if not i then local B=xpcall;xpcall=function(f,C,...)if select(\"#\",...)>0 then local args=table.pack(...)return B(function()return f(table.unpack(args,1,args.n))end,C)else return B(f,C)end end end end;if tonumber(_HOST:match\"ComputerCraft 1.(%d+)\")<95 then local D=fs.combine;function fs.combine(E,...)if...~=nil then return D(E,fs.combine(...))else return E end end end;if not string.pack then local F={BIG_ENDIAN=1,LITTLE_ENDIAN=2}local G={b=1,B=1,h=1,H=1,l=1,L=1,j=1,J=1,T=1}local H={b=1,B=1,x=1,h=2,H=2,f=4,j=4,J=4,l=8,L=8,T=8,d=8,n=8}local function I(r)if r%1>=0.5 then return math.ceil(r)else return math.floor(r)end end;local function J(f)if f==0 then return 0 elseif f==-0 then return 0x80000000 elseif f==math.huge then return 0x7F800000 elseif f==-math.huge then return 0xFF800000 end;local A,K=math.frexp(f)if K>127 or K<-126 then error(\"number out of range\",3)end;K,A=K+126,I((math.abs(A)-0.5)*0x1000000)if A>0x7FFFFF then K=K+1 end;return bit32.bor(f<0 and 0x80000000 or 0,bit32.lshift(bit32.band(K,0xFF),23),bit32.band(A,0x7FFFFF))end;local function L(f)if f==0 then return 0,0 elseif f==-0 then return 0x80000000,0 elseif f==math.huge then return 0x7FF00000,0 elseif f==-math.huge then return 0xFFF00000,0 end;local A,K=math.frexp(f)if K>1023 or K<-1022 then error(\"number out of range\",3)end;K,A=K+1022,I((math.abs(A)-0.5)*0x20000000000000)if A>0xFFFFFFFFFFFFF then K=K+1 end;return bit32.bor(f<0 and 0x80000000 or 0,bit32.lshift(bit32.band(K,0x7FF),20),bit32.band(A/0x100000000,0xFFFFF)),bit32.band(A,0xFFFFFFFF)end;local function M(N)if N==0 then return 0 elseif N==0x80000000 then return-0 elseif N==0x7F800000 then return math.huge elseif N==0xFF800000 then return-math.huge end;local A,K=bit32.band(N,0x7FFFFF),bit32.band(bit32.rshift(N,23),0xFF)K,A=K-126,A/0x1000000+0.5;local r=math.ldexp(A,K)return bit32.btest(N,0x80000000)and-r or r end;local function O(P,Q)if P==0 and Q==0 then return 0 elseif P==0x80000000 and Q==0 then return-0 elseif P==0x7FF00000 and Q==0 then return math.huge elseif P==0xFFF00000 and Q==0 then return-math.huge end;local A,K=bit32.band(P,0xFFFFF)*0x100000000+bit32.band(Q,0xFFFFFFFF),bit32.band(bit32.rshift(P,20),0x7FF)K,A=K-1022,A/0x20000000000000+0.5;local r=math.ldexp(A,K)return bit32.btest(P,0x80000000)and-r or r end;local function R(b,S,T,U,V,W,X)local Y=0;if U%math.min(S,V)~=0 and V>1 then local v=0;while U%math.min(S,V)~=0 and v<V do T[U]=0;U=U+1;Y=Y+1;v=v+1 end end;if W==F.BIG_ENDIAN then local Z=0;if S>8 then for v=0,S-9 do T[U+v]=X and b>=2^(S*8-1)~=0 and 0xFF or 0;Z=Z+1;Y=Y+1 end end;for v=Z,S-1 do T[U+v]=bit32.band(bit32.rshift(b,(S-v-1)*8),0xFF)Y=Y+1 end else for v=0,math.min(S,8)-1 do T[U+v]=b/2^(v*8)%256;Y=Y+1 end;for v=8,S-1 do T[U+v]=X and b>=2^(S*8-1)~=0 and 0xFF or 0;Y=Y+1 end end;return Y end;local function _(a0,U,S,W,V,X)local a1,a2=0,0;if U%math.min(S,V)~=0 and V>1 then for v=0,V-1 do if U%math.min(S,V)==0 then break end;U=U+1;a2=a2+1 end end;for v=0,S-1 do a1=a1+a0:byte(U+v)*2^((W==F.BIG_ENDIAN and S-v-1 or v)*8)a2=a2+1 end;if X and a1>=2^(S*8-1)then a1=a1-2^(S*8)end;return a1,a2 end;local function a3(a4,V)local a5=H[a4]or 0;if V>1 and a5%V~=0 then a5=a5+V-a5%V end;return a5 end;function string.pack(...)local a6=expect(1,...,\"string\")local W=F.LITTLE_ENDIAN;local V=1;local a7=1;local a8=2;local T={}local v=1;while v<=#a6 do local a9=a6:sub(v,v)v=v+1;if a9=='='or a9=='<'then W=F.LITTLE_ENDIAN elseif a9=='>'then W=F.BIG_ENDIAN elseif a9=='!'then local S=-1;while v<=#a6 and a6:sub(v,v):match(\"%d\")do if S>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;S=math.max(S,0)*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 or S==0 then error(string.format(\"integral size (%d) out of limits [1,16]\",S),2)elseif S==-1 then V=4 else V=S end elseif G[a9]then local b=expect(a8,select(a8,...),\"number\")a8=a8+1;if b>=math.pow(2,a3(a9,0)*8-(a9:match(\"%l\")and 1 or 0))or b<(a9:match(\"%l\")and-math.pow(2,a3(a9,0)*8-1)or 0)then error(string.format(\"bad argument #%d to 'pack' (integer overflow)\",a8-1),2)end;a7=a7+R(b,a3(a9,0),T,a7,V,W,false)elseif a9:lower()=='i'then local X=a9=='i'local S=-1;while v<=#a6 and a6:sub(v,v):match(\"%d\")do if S>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;S=math.max(S,0)*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 or S==0 then error(string.format(\"integral size (%d) out of limits [1,16]\",S),2)elseif V>1 and(S~=1 and S~=2 and S~=4 and S~=8 and S~=16)then error(\"bad argument #1 to 'pack' (format asks for alignment not power of 2)\",2)elseif S==-1 then S=4 end;local b=expect(a8,select(a8,...),\"number\")a8=a8+1;if b>=math.pow(2,S*8-(a9:match(\"%l\")and 1 or 0))or b<(a9:match(\"%l\")and-math.pow(2,S*8-1)or 0)then error(string.format(\"bad argument #%d to 'pack' (integer overflow)\",a8-1),2)end;a7=a7+R(b,S,T,a7,V,W,X)elseif a9=='f'then local f=expect(a8,select(a8,...),\"number\")a8=a8+1;local N=J(f)if a7%math.min(4,V)~=0 and V>1 then for aa=0,V-1 do if a7%math.min(4,V)==0 then break end;T[a7]=0;a7=a7+1 end end;for aa=0,3 do T[a7+(W==F.BIG_ENDIAN and 3-aa or aa)]=bit32.band(bit32.rshift(N,aa*8),0xFF)end;a7=a7+4 elseif a9=='d'or a9=='n'then local f=expect(a8,select(a8,...),\"number\")a8=a8+1;local P,Q=L(f)if a7%math.min(8,V)~=0 and V>1 then for aa=0,V-1 do if a7%math.min(8,V)==0 then break end;T[a7]=0;a7=a7+1 end end;for aa=0,3 do T[a7+(W==F.BIG_ENDIAN and 7-aa or aa)]=bit32.band(bit32.rshift(Q,aa*8),0xFF)end;for aa=4,7 do T[a7+(W==F.BIG_ENDIAN and 7-aa or aa)]=bit32.band(bit32.rshift(P,(aa-4)*8),0xFF)end;a7=a7+8 elseif a9=='c'then local S=0;if v>#a6 or not a6:sub(v,v):match(\"%d\")then error(\"missing size for format option 'c'\",2)end;while v<=#a6 and a6:sub(v,v):match(\"%d\")do if S>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if a7+S<a7 or a7+S>0xFFFFFFFF then error(\"bad argument #1 to 'pack' (format result too large)\",2)end;local a0=expect(a8,select(a8,...),\"string\")a8=a8+1;if#a0>S then error(string.format(\"bad argument #%d to 'pack' (string longer than given size)\",a8-1),2)end;if S>0 then for aa=0,S-1 do T[a7+aa]=a0:byte(aa+1)or 0 end;a7=a7+S end elseif a9=='z'then local a0=expect(a8,select(a8,...),\"string\")a8=a8+1;for ab in a0:gmatch\".\"do if ab=='\\0'then error(string.format(\"bad argument #%d to 'pack' (string contains zeros)\",a8-1),2)end end;for aa=0,#a0-1 do T[a7+aa]=a0:byte(aa+1)end;T[a7+#a0]=0;a7=a7+#a0+1 elseif a9=='s'then local S=0;while v<=#a6 and a6:sub(v,v):match(\"%d\")do if S>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 then error(string.format(\"integral size (%d) out of limits [1,16]\",S),2)elseif S==0 then S=4 end;local a0=expect(a8,select(a8,...),\"string\")a8=a8+1;if#a0>=math.pow(2,S*8)then error(string.format(\"bad argument #%d to 'pack' (string length does not fit in given size)\",a8-1),2)end;R(#a0,S,T,a7,1,W,false)for aa=S,#a0+S-1 do T[a7+aa]=a0:byte(aa-S+1)or 0 end;a7=a7+#a0+S elseif a9=='x'then T[a7]=0;a7=a7+1 elseif a9=='X'then if v>=#a6 then error(\"invalid next option for option 'X'\",2)end;local S=0;local a9=a6:sub(v,v)v=v+1;if a9:lower()=='i'then while v<=#a6 and a6:sub(v,v):match(\"%d\")do if S>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 or S==0 then error(string.format(\"integral size (%d) out of limits [1,16]\",S),2)end else S=a3(a9,0)end;if S<1 then error(\"invalid next option for option 'X'\",2)end;if a7%math.min(S,V)~=0 and V>1 then for aa=1,V do if a7%math.min(S,V)==0 then break end;T[a7]=0;a7=a7+1 end end elseif a9~=' 'then error(string.format(\"invalid format option '%s'\",a9),2)end end;return string.char(table.unpack(T))end;function string.packsize(a6)local a7=0;local V=1;local v=1;while v<=#a6 do local a9=a6:sub(v,v)v=v+1;if a9=='!'then local S=0;while v<=#a6 and a6:sub(v,v):match(\"%d\")do if S>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 then error(string.format(\"integral size (%d) out of limits [1,16]\",S),2)elseif S==0 then V=4 else V=S end elseif G[a9]then local S=a3(a9,0)if a7%math.min(S,V)~=0 and V>1 then for aa=1,V do if a7%math.min(S,V)==0 then break end;a7=a7+1 end end;a7=a7+S elseif a9:lower()=='i'then local S=0;while v<=#a6 and a6:sub(v,v):match(\"%d\")do if S>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 then error(string.format(\"integral size (%d) out of limits [1,16]\",S))elseif V>1 and(S~=1 and S~=2 and S~=4 and S~=8 and S~=16)then error(\"bad argument #1 to 'pack' (format asks for alignment not power of 2)\",2)elseif S==0 then S=4 end;if a7%math.min(S,V)~=0 and V>1 then for aa=1,V do if a7%math.min(S,V)==0 then break end;a7=a7+1 end end;a7=a7+S elseif a9=='f'then if a7%math.min(4,V)~=0 and V>1 then for aa=1,V do if a7%math.min(4,V)==0 then break end;a7=a7+1 end end;a7=a7+4 elseif a9=='d'or a9=='n'then if a7%math.min(8,V)~=0 and V>1 then for aa=1,V do if a7%math.min(8,V)==0 then break end;a7=a7+1 end end;a7=a7+8 elseif a9=='c'then local S=0;if v>#a6 or not a6:sub(v,v):match(\"%d\")then error(\"missing size for format option 'c'\",2)end;while v<=#a6 and a6:sub(v,v):match(\"%d\")do if S>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if a7+S<a7 or a7+S>0x7FFFFFFF then error(\"bad argument #1 to 'packsize' (format result too large)\",2)end;a7=a7+S elseif a9=='x'then a7=a7+1 elseif a9=='X'then if v>=#a6 then error(\"invalid next option for option 'X'\",2)end;local S=0;local a9=a6:sub(v,v)v=v+1;if a9:lower()=='i'then while v<=#a6 and a6:sub(v,v):match(\"%d\")do if S>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 or S==0 then error(string.format(\"integral size (%d) out of limits [1,16]\",S),2)end else S=a3(a9,0)end;if S<1 then error(\"invalid next option for option 'X'\",2)end;if a7%math.min(S,V)~=0 and V>1 then for aa=1,V do if a7%math.min(S,V)==0 then break end;a7=a7+1 end end elseif a9=='s'or a9=='z'then error(\"bad argument #1 to 'packsize' (variable-length format)\",2)elseif a9~=' 'and a9~='<'and a9~='>'and a9~='='then error(string.format(\"invalid format option '%s'\",a9),2)end end;return a7 end;function string.unpack(a6,a0,a7)expect(1,a6,\"string\")expect(2,a0,\"string\")expect(3,a7,\"number\",\"nil\")if a7 then if a7<0 then a7=#a0+a7 elseif a7==0 then error(\"bad argument #3 to 'unpack' (initial position out of string)\",2)end;if a7>#a0 or a7<0 then error(\"bad argument #3 to 'unpack' (initial position out of string)\",2)end else a7=1 end;local W=F.LITTLE_ENDIAN;local V=1;local a5={}local v=1;while v<=#a6 do local a9=a6:sub(v,v)v=v+1;if a9=='<'or a9=='='then W=F.LITTLE_ENDIAN elseif a9=='>'then W=F.BIG_ENDIAN elseif a9=='!'then local S=0;while v<=#a6 and a6:sub(v,v):match(\"%d\")do if S>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 then error(string.format(\"integral size (%d) out of limits [1,16]\",S))elseif S==0 then V=4 else V=S end elseif G[a9]then if a7+a3(a9,0)>#a0+1 then error(\"data string too short\",2)end;local u,ac=_(a0,a7,a3(a9,0),W,V,a9:match(\"%l\")~=nil)a5[#a5+1]=u;a7=a7+ac elseif a9:lower()=='i'then local X=a9=='i'local S=0;while v<=#a6 and a6:sub(v,v):match(\"%d\")do if S>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 then error(string.format(\"integral size (%d) out of limits [1,16]\",S),2)elseif S>8 then error(string.format(\"%d-byte integer does not fit into Lua Integer\",S),2)elseif S==0 then S=4 end;if a7+S>#a0+1 then error(\"data string too short\",2)end;local u,ac=_(a0,a7,S,W,V,X)a5[#a5+1]=u;a7=a7+ac elseif a9=='f'then if a7%math.min(4,V)~=0 and V>1 then for aa=1,V do if a7%math.min(4,V)==0 then break end;a7=a7+1 end end;if a7+4>#a0+1 then error(\"data string too short\",2)end;local u=_(a0,a7,4,W,V,false)a5[#a5+1]=M(u)a7=a7+4 elseif a9=='d'or a9=='n'then if a7%math.min(8,V)~=0 and V>1 then for aa=1,V do if a7%math.min(8,V)==0 then break end;a7=a7+1 end end;if a7+8>#a0+1 then error(\"data string too short\",2)end;local P,Q=0,0;for aa=0,3 do P=bit32.bor(P,bit32.lshift(a0:byte(a7+aa),(W==F.BIG_ENDIAN and 3-aa or aa)*8))end;for aa=0,3 do Q=bit32.bor(Q,bit32.lshift(a0:byte(a7+aa+4),(W==F.BIG_ENDIAN and 3-aa or aa)*8))end;if W==F.LITTLE_ENDIAN then P,Q=Q,P end;a5[#a5+1]=O(P,Q)a7=a7+8 elseif a9=='c'then local S=0;if v>#a6 or not a6:sub(v,v):match(\"%d\")then error(\"missing size for format option 'c'\",2)end;while v<=#a6 and a6:sub(v,v):match(\"%d\")do if S>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\")end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if a7+S>#a0+1 then error(\"data string too short\",2)end;a5[#a5+1]=a0:sub(a7,a7+S-1)a7=a7+S elseif a9=='z'then local S=0;while a0:byte(a7+S)~=0 do S=S+1;if a7+S>#a0 then error(\"unfinished string for format 'z'\",2)end end;a5[#a5+1]=a0:sub(a7,a7+S-1)a7=a7+S+1 elseif a9=='s'then local S=0;while v<=#a6 and a6:sub(v,v):match(\"%d\")do if S>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 then error(string.format(\"integral size (%d) out of limits [1,16]\",S),2)elseif S==0 then S=4 end;if a7+S>#a0+1 then error(\"data string too short\",2)end;local b,ad=_(a0,a7,S,W,V,false)a7=a7+ad;if a7+b>#a0+1 then error(\"data string too short\",2)end;a5[#a5+1]=a0:sub(a7,a7+b-1)a7=a7+b elseif a9=='x'then a7=a7+1 elseif a9=='X'then if v>=#a6 then error(\"invalid next option for option 'X'\",2)end;local S=0;local a9=a6:sub(v,v)v=v+1;if a9:lower()=='i'then while v<=#a6 and a6:sub(v,v):match(\"%d\")do if S>=0xFFFFFFFF/10 then error(\"bad argument #1 to 'pack' (invalid format)\",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 or S==0 then error(string.format(\"integral size (%d) out of limits [1,16]\",S),2)elseif S==-1 then S=4 end else S=a3(a9,0)end;if S<1 then error(\"invalid next option for option 'X'\",2)end;if a7%math.min(S,V)~=0 and V>1 then for aa=1,V do if a7%math.min(S,V)==0 then break end;a7=a7+1 end end elseif a9~=' 'then error(string.format(\"invalid format option '%s'\",a9),2)end end;a5[#a5+1]=a7;return table.unpack(a5)end end;function panic(ae)term.setBackgroundColor(32768)term.setTextColor(16384)term.setCursorBlink(false)local p,q=term.getCursorPos()p=1;local af,ag=term.getSize()ae=\"panic: \"..(ae or\"unknown\")for ah in ae:gmatch\"%S+\"do if p+#ah>=af then p,q=1,q+1;if q>ag then term.scroll(1)q=q-1 end end;term.setCursorPos(p,q)if p==1 then term.clearLine()end;term.write(ah..\" \")p=p+#ah+1 end;p,q=1,q+1;if q>ag then term.scroll(1)q=q-1 end;if debug then local ai=debug.traceback(nil,2)for aj in ai:gmatch\"[^\\n]+\"do term.setCursorPos(1,q)term.write(aj)q=q+1;if q>ag then term.scroll(1)q=q-1 end end end;term.setCursorPos(1,q)term.setTextColor(2)term.write(\"panic: We are hanging here...\")mainThread=nil;while true do coroutine.yield()end end;function do_syscall(ak,...)local u=table.pack(coroutine.yield(\"syscall\",ak,...))if u[1]then return table.unpack(u,2,u.n)else error(u[2],3)end end;function deepcopy(al)if type(al)==\"table\"then local a5=setmetatable({},deepcopy(getmetatable(al)))for h,i in pairs(al)do a5[deepcopy(h)]=deepcopy(i)end;return a5 else return al end end;function split(a0,am)local y={}for an in a0:gmatch(\"[^\"..(am or\"%s\")..\"]+\")do y[#y+1]=an end;return y end;local ao=pcall(os.epoch,\"nano\")and function()return os.epoch\"nano\"/1000000 end or(ccemux and function()return ccemux.nanoTime()/1000000 end or function()return os.epoch\"utc\"end)local ap={n=0}function executeThread(process,aq,ar,as,at)local args;if aq.status==\"starting\"then args=aq.args elseif aq.status==\"syscall\"then args=table.pack(table.unpack(aq.syscall_return,3,aq.syscall_return.n))elseif aq.status==\"preempt\"then args=ap elseif aq.status==\"suspended\"then args={ar[1],deepcopy(ar[2])}elseif aq.status==\"paused\"then return false,at end;if aq.status~=\"dead\"and(not aq.filter or aq.filter(process,aq,ar))then local au=as;as=false;aq.filter=nil;local av;if aq.yielding then av={n=aq.syscall_return.n,true,\"syscall\",aq.yielding,table.unpack(aq.syscall_return,4,aq.syscall_return.n)}aq.yielding=nil else local aw=globalMetatables;globalMetatables=process.globalMetatables;updateGlobalMetatables()local ax=ao()av=table.pack(coroutine.resume(aq.coro,table.unpack(args,1,args.n)))process.cputime=process.cputime+(ao()-ax)/1000;globalMetatables=aw;updateGlobalMetatables()end;if av[2]==\"syscall\"then aq.status=\"syscall\"local ay=at;at=false;if av[3]and syscalls[av[3]]then local ax=ao()aq.syscall_return=table.pack(coroutine.resume(aq.syscall,av[3],process,aq,table.unpack(av,4,av.n)))process.systime=process.systime+(ao()-ax)/1000;if aq.syscall_return[2]==kSyscallComplete then if not aq.syscall_return[3]and type(aq.syscall_return[4])==\"string\"then syslog.log({level=\"debug\",category=\"Syscall Failure\",process=0,module=av[3]},aq.syscall_return[4])aq.syscall_return[4]=aq.syscall_return[4]:gsub(\"kernel:%d+: \",\"\")end;if aq.syscall_return[4]==kSyscallYield then aq.yielding=aq.syscall_return[5]at=ay end else aq.yielding=av[3]end else aq.syscall_return={false,\"No such syscall\",n=2}end elseif av[2]==\"preempt\"then aq.status=\"preempt\"at=false elseif coroutine.status(aq.coro)==\"dead\"then aq.status=\"dead\"aq.return_value=av[2]if av[1]then process.lastReturnValue={pid=process.id,thread=aq.id,value=av[2],n=av.n-1,table.unpack(av,2,av.n)}else process.lastReturnValue={pid=process.id,thread=aq.id,error=av[2],traceback=debug.traceback(aq.coro)}end;if not av[1]then aq.did_error=true;syslog.log({level=_G.args.traceback and\"error\"or\"debug\",process=process.id,thread=aq.id,category=\"Application Error\",traceback=true},debug.traceback(aq.coro,av[2]))if av[2]and process.stderr and process.stderr.isTTY then terminal.write(process.stderr,av[2]..\"\\n\")end end;process.threads[aq.id]=nil;as=au else aq.status=\"suspended\"at=at and#process.eventQueue==0 end end;return as,at end;mainThread=coroutine.running()function userModeCallback(process,az,...)local aA=syscalls.newthread(process,nil,az,...)local aq=process.threads[aA]while aq.status~=\"dead\"do if coroutine.running()==mainThread then error(\"userModeCallback not called from a yieldable context\",2)end;coroutine.yield()end;syslog.log({level=\"debug\",process=process.id,thread=aA},\"Usermode callback completed\")return not aq.did_error,aq.return_value end;function make_ENV(e)if type(e)~=\"table\"or _VERSION~=\"Lua 5.1\"then return e end;repeat local aB=getmetatable(e)if aB and aB.__env then e=aB.__env end until not aB or not aB.__env;local y=setmetatable({},{__index=function(self,aC)if self==e then e=getmetatable(self).__env end;if aC==\"_ENV\"then return e else return e[aC]end end,__newindex=function(self,aC,aD)if self==e then e=getmetatable(self).__env end;if aC==\"_ENV\"then e=aD else e[aC]=aD end end,__pairs=function(self)if self==e then e=getmetatable(self).__env end;return next,e end,__len=function(self)if self==e then e=getmetatable(self).__env end;return#e end,__env=e})return y end;for z,i in ipairs({...})do local aE,aF=i:match(\"^([^=]+)=(.+)$\")if aE and aF then if type(args[aE])==\"boolean\"then args[aE]=aF:lower()==\"true\"or aF==\"1\"elseif type(args[aE])==\"number\"then args[aE]=tonumber(aF)else args[aE]=aF end elseif aE==\"silent\"then args.loglevel=5 elseif aE==\"quiet\"then args.loglevel=3 end end;local function aG(aH)local u;if _CC_VERSION then u=aH<=_CC_VERSION elseif not _HOST then u=aH<=os.version():gsub(\"CraftOS \",\"\")elseif _HOST:match(\"ComputerCraft 1%.1%d+\")~=aH:match(\"1%.1%d+\")then aH=aH:gsub(\"(1%.)([02-9])\",\"%10%2\")local aI=_HOST:gsub(\"(ComputerCraft 1%.)([02-9])\",\"%10%2\")u=aH<=aI:match(\"ComputerCraft ([0-9%.]+)\")else u=aH<=_HOST:match(\"ComputerCraft ([0-9%.]+)\")end;return u end;if not aG\"1.87.0\"then panic(\"Phoenix requires ComputerCraft 1.87.0 or later. Please upgrade your version of ComputerCraft.\")end;if jit and args.preemptive then panic(\"Phoenix does not support preemption when running under LuaJIT. Please set preemptive to false in the kernel arguments.\")end;if not debug and args.preemptive then panic(\"Phoenix does not support preemption without the debug API. Please set preemptive to false in the kernel arguments.\")end;if args.preemptive then PHOENIX_BUILD=PHOENIX_BUILD..\" PREEMPT\"end;if not getfenv then if not debug then panic(\"Phoenix requires the debug API when running under Lua 5.2 and later.\")end;function getfenv(g)local v=1;while true do local m,aD=debug.getupvalue(g,v)if m==\"_ENV\"then return aD elseif not m then break end;v=v+1 end end;function setfenv(g,e)local v=1;while true do local m=debug.getupvalue(g,v)if m==\"_ENV\"then debug.upvaluejoin(g,v,function()return e end,1)break elseif not m then break end;v=v+1 end;return g end end;globalMetatables={[\"nil\"]={},[\"boolean\"]={},[\"number\"]={},[\"string\"]={__index=string},[\"function\"]={},[\"thread\"]={__index=coroutine,__call=coroutine.resume},[\"userdata\"]={}}local aJ,aK=debug.getmetatable,debug.setmetatable;function updateGlobalMetatables()aK(nil,globalMetatables[\"nil\"])aK(false,globalMetatables[\"boolean\"])aK(0,globalMetatables[\"number\"])aK(\"\",globalMetatables[\"string\"])aK(assert,globalMetatables[\"function\"])aK(coroutine.running(),globalMetatables[\"thread\"])if debug.upvalueid then aK(debug.upvalueid(executeThread,1),globalMetatables[\"userdata\"])end end;local type=type;function debug.getmetatable(aD)if type(aD)==\"table\"then return aJ(aD)else return globalMetatables[type(aD)]end end;function debug.setmetatable(aD,al)expect(2,al,\"table\")if type(aD)==\"table\"then return aK(aD,al)else globalMetatables[type(aD)]=al end end;do local aL;local aM,aN,aO,aP,aQ,aR,aS,aT,aU=getfenv,setfenv,debug.getfenv,debug.getlocal,debug.getupvalue,debug.setfenv,debug.setlocal,debug.setupvalue,debug.upvaluejoin;local error,aV,aW,select,setmetatable,type,tonumber=error,debug.getinfo,coroutine.running,select,setmetatable,type,tonumber;local aX;local function keys(y,i,...)if i then y[i]=true end;if select(\"#\",...)>0 then return keys(y,...)else return y end end;local function aY(i,...)if select(\"#\",...)>0 then return aX[i or\"\"]or i,aY(...)else return aX[i or\"\"]or i end end;local function aZ(r)r=bit32.band(tonumber(r),0xFFFFFFFF)if bit32.btest(r,0x80000000)then r=r-0x100000000 end;return r end;function debug.getinfo(aq,az,a_)if type(aq)~=\"thread\"then a_,az,aq=az,aq,aW()end;local a5;if tonumber(az)then a5=aV(aq,az+1,a_)else a5=aV(aq,az,a_)end;if a5 and a5.func then a5.func=aX[a5.func]or a5.func end;return a5 end;function debug.getlocal(aq,b0,b1)if b1==nil then b1,b0,aq=b0,aq,aW()end;local h,i;if type(b0)==\"function\"then local b2=aV(2,\"f\")if aL[b0]and not(b2 and aL[b0][b2.func])then return nil end;h,i=aY(aP(b0,b1))elseif tonumber(b0)then local b3=aV(aq,b0+1,\"f\")local b2=aV(2,\"f\")if b3 and aL[b3.func]and not(b2 and aL[b3.func][b2.func])then return nil end;h,i=aY(aP(aq,b0+1,b1))else h,i=aY(aP(aq,b0,b1))end;return h,i end;function debug.getupvalue(az,b4)if type(az)==\"function\"then local b2=aV(2,\"f\")if aL[az]and not(b2 and aL[az][b2.func])then return nil end end;local h,i=aY(aQ(az,b4))return h,i end;function debug.setlocal(aq,b0,b1,aF)if b1==nil then b1,b0,aq=b0,aq,aW()end;if tonumber(b0)then local b3=aV(aq,b0+1,\"f\")local b2=aV(2,\"f\")if b3 and aL[b3.func]and not(b2 and aL[b3.func][b2.func])then error(\"attempt to set local of protected function\",2)end;aS(aq,b0+1,b1,aF)else aS(aq,b0,b1,aF)end end;function debug.setupvalue(az,b4,aF)if type(az)==\"function\"then local b2=aV(2,\"f\")if aL[az]and not(b2 and aL[az][b2.func])then error(\"attempt to set upvalue of protected function\",2)end end;aT(az,b4,aF)end;function _G.getfenv(f)local i;if f==nil then i=aM(2)elseif tonumber(f)and aZ(f)>0 then local b3=aV(f+1,\"f\")local b2=aV(2,\"f\")if b3 and aL[b3.func]and not(b2 and aL[b3.func][b2.func])then return nil end;i=aM(f+1)elseif type(f)==\"function\"then local b2=aV(2,\"f\")if aL[f]and not(b2 and aL[f][b2.func])then return nil end;i=aM(f)else i=aM(f)end;return i end;function _G.setfenv(f,al)if tonumber(f)and aZ(f)>0 then local b3=aV(f+1,\"f\")local b2=aV(2,\"f\")if b3 and aL[b3.func]and not(b2 and aL[b3.func][b2.func])then error(\"attempt to set environment of protected function\",2)end;aN(f+1,al)elseif type(f)==\"function\"then local b2=aV(2,\"f\")if aL[f]and not(b2 and aL[f][b2.func])then error(\"attempt to set environment of protected function\",2)end end;aN(f,al)end;if aO then function debug.getfenv(b5)if type(b5)==\"function\"then local b2=aV(2,\"f\")if aL[b5]and not(b2 and aL[b5][b2.func])then return nil end end;local i=aO(b5)return i end;function debug.setfenv(b5,al)if type(b5)==\"function\"then local b2=aV(2,\"f\")if aL[b5]and not(b2 and aL[b5][b2.func])then error(\"attempt to set environment of protected function\",2)end end;aR(b5,al)end end;if aU then function debug.upvaluejoin(b6,b7,b8,b9)if type(b6)==\"function\"and type(b8)==\"function\"then local b2=aV(2,\"f\")if aL[b6]and not(b2 and aL[b6][b2.func])then error(\"attempt to get upvalue of protected function\",2)end;if aL[b8]and not(b2 and aL[b8][b2.func])then error(\"attempt to set upvalue of protected function\",2)end end;aU(b6,b7,b8,b9)end end;function debug.protect(az)if type(az)~=\"function\"then error(\"bad argument #1 (expected function, got \"..type(az)..\")\",2)end;if aL[az]then error(\"attempt to protect a protected function\",2)end;aL[az]=keys(setmetatable({},{__mode=\"k\"}))end;aX={[aP]=debug.getlocal,[aS]=debug.setlocal,[aQ]=debug.getupvalue,[aT]=debug.setupvalue,[aV]=debug.getinfo,[aY]=function()end}if debug.upvaluejoin then aX[aU]=debug.upvaluejoin end;if debug.getfenv then aX[aO]=debug.getfenv end;if debug.setfenv then aX[aR]=debug.setfenv end;if _G.getfenv then aX[aM]=_G.getfenv end;if _G.setfenv then aX[aN]=_G.setfenv end;aL=keys(setmetatable({},{__mode=\"k\"}),getfenv,setfenv,debug.getfenv,debug.setfenv,debug.getlocal,debug.setlocal,debug.getupvalue,debug.setupvalue,debug.upvaluejoin,debug.getinfo,aY,debug.protect)for h,i in pairs(aL)do aL[h]={}end end;fs=fs;mounts={}fifos={}filesystems={craftos={meta={meta={type=\"directory\",owner=\"root\",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}},metapath=\"/meta.ltn\",lastDispatch=0},tmpfs={},drivefs={},tablefs={},bind={}}local function ba(process,bb)local E=fs.combine(process.root,bb:sub(1,1)==\"/\"and\"\"or process.dir,bb)if\"/\"..E..\"/\"~=process.root and E:find(process.root:sub(2),1,true)~=1 then error(bb..\": No such file or directory\",4)end;return E end;local function bc(process,bb)local bd=split(ba(process,bb),\"/\\\\\")if#bd==0 then return mounts[\"\"],bb,\"\"end;local be;for h in pairs(mounts)do local bf=true;for v,a9 in ipairs(split(h,\"/\\\\\"))do if bd[v]~=a9 then bf=false;break end end;if bf and(not be or#h>#be)then be=h end end;if not be then panic(\"Could not find mount for path \"..bb..\". Where is root?\")end;local bg=split(be,\"/\\\\\")local E=#bd>=#bg+1 and fs.combine(table.unpack(bd,#bg+1,#bd))or\"\"return mounts[be],E,be end;function filesystem.readhandle(process,bh,bi)local a7=1;local bj=false;local y={readLine=function(bk)if bj then error(\"attempt to use a closed file\",2)end;if a7>#bh then return nil end;local bl;bl,a7=bh:match(\"([^\\n]*\"..(bk and\"\\n?)\"or\")\\n?\")..\"()\",a7)return bl end,readAll=function()if bj then error(\"attempt to use a closed file\",2)end;if a7>#bh then return nil end;local bl=bh:sub(a7)a7=#bl+1;return bl end,read=function(r)if bj then error(\"attempt to use a closed file\",2)end;if r~=nil and type(r)~=\"number\"then error(\"bad argument #1 (expected number, got \"..type(r)..\")\",2)end;r=r or 1;if a7>#bh then return nil end;local bl=bh:sub(a7,a7+r-1)a7=a7+r;return bl end,close=function()if bj then error(\"attempt to use a closed file\",2)end;bj=true end}if bi then y.read=function(r)if bj then error(\"attempt to use a closed file\",2)end;if r~=nil and type(r)~=\"number\"then error(\"bad argument #1 (expected number, got \"..type(r)..\")\",2)end;if a7>#bh then return nil end;if r then local bl=bh:sub(a7,a7+r-1)a7=a7+r;return bl else local bl=bh:byte(a7)a7=a7+1;return bl end end;y.seek=function(bm,U)if bm~=nil and type(bm)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(bm)..\")\",2)end;if U~=nil and type(U)~=\"number\"then error(\"bad argument #2 (expected number, got \"..type(U)..\")\",2)end;bm=bm or\"cur\"U=U or 0;if bj then error(\"attempt to use closed file\",2)end;if bm==\"set\"then a7=U+1 elseif bm==\"cur\"then a7=a7+U elseif bm==\"end\"then a7=math.max(#bh-U,1)else error(\"Invalid whence\",2)end;return a7-1 end else bh=bh:gsub(\"[\\x80-\\xFF]+\",function(bn)local bo=\"\"if not pcall(function()for z,bp in utf8.codes(bn)do bo=bo..(bp<256 and string.char(bp)or\"?\")end end)then return bn end;return bo end)end;for z,i in pairs(y)do setfenv(i,process.env)debug.protect(i)end;return setmetatable(y,{__name=\"file\"})end;function filesystem.writehandle(process,bq,bi)local function br(y)for z,i in pairs(y)do setfenv(i,process.env)debug.protect(i)end;return setmetatable(y,{__name=\"file\"})end;local bj=false;if bi then local a7=1;local bs=\"\"local bt=\"\"return br{write=function(bl)if bj then error(\"attempt to use a closed file\",2)end;if type(bl)==\"number\"then bs,a7=bs:sub(1,a7-1)..string.char(bl)..bs:sub(a7+1),a7+1;if bt then bt=bt..string.char(bl)end elseif type(bl)==\"string\"then bs,a7=bs:sub(1,a7-1)..bl..bs:sub(a7+#bl),a7+#bl;if bt then bt=bt..bl end else error(\"bad argument #1 (expected string or number, got \"..type(bl)..\")\",2)end end,writeLine=function(bl)if bj then error(\"attempt to use a closed file\",2)end;if type(bl)==\"number\"then bs,a7=bs:sub(1,a7-1)..string.char(bl)..\"\\n\"..bs:sub(a7+2),a7+2;if bt then bt=bt..string.char(bl)..\"\\n\"end elseif type(bl)==\"string\"then bs,a7=bs:sub(1,a7-1)..bl..\"\\n\"..bs:sub(a7+#bl+1),a7+#bl+1;if bt then bt=bt..bl..\"\\n\"end else error(\"bad argument #1 (expected string or number, got \"..type(bl)..\")\",2)end end,seek=function(bm,U)if bm~=nil and type(bm)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(bm)..\")\",2)end;if U~=nil and type(U)~=\"number\"then error(\"bad argument #2 (expected number, got \"..type(U)..\")\",2)end;bm=bm or\"cur\"U=U or 0;if bj then error(\"attempt to use closed file\",2)end;local bu=a7;if bm==\"set\"then a7=U+1 elseif bm==\"cur\"then a7=a7+U elseif bm==\"end\"then a7=math.max(#bs-U,1)else error(\"Invalid whence\",2)end;if bu~=a7 then bt=nil end;return a7-1 end,flush=function()if bj then error(\"attempt to use a closed file\",2)end;if bt then bq(bt,false)else bq(bs,true)end;bt=\"\"end,close=function()if bj then error(\"attempt to use a closed file\",2)end;bj=true;if bt then bq(bt,false)else bq(bs,true)end;bt=\"\"end}else local bs=\"\"return br{write=function(bl)if bj then error(\"attempt to use a closed file\",2)end;bs=bs..tostring(bl)end,writeLine=function(bl)if bj then error(\"attempt to use a closed file\",2)end;bs=bs..tostring(bl)..\"\\n\"end,flush=function()if bj then error(\"attempt to use a closed file\",2)end;bq(bs,false)bs=\"\"end,close=function()if bj then error(\"attempt to use a closed file\",2)end;bq(bs,false)bs=\"\"bj=true end}end end;function filesystem.fifohandle(process,bv,n)local bj=false;local function br(y)for z,i in pairs(y)do setfenv(i,process.env)debug.protect(i)end;return setmetatable(y,{__name=\"file\"})end;if n==\"r\"then return br{readLine=function(bk)if bj then error(\"attempt to use a closed file\",2)end;if#bv.data==0 then return nil end;local bl;bl,bv.data=bv.data:match(\"([^\\n]*\"..(bk and\"\\n?)\"or\")\\n?\")..\"(.*)\")return bl end,readAll=function()if bj then error(\"attempt to use a closed file\",2)end;if#bv.data==0 then return nil end;local bl=bv.data;bv.data=\"\"return bl end,read=function(r)if bj then error(\"attempt to use a closed file\",2)end;if r~=nil and type(r)~=\"number\"then error(\"bad argument #1 (expected number, got \"..type(r)..\")\",2)end;r=r or 1;if#bv.data==0 then return nil end;local bl=bv.data:sub(1,r)bv.data=bv.data:sub(r+1)return bl end,close=function()if bj then error(\"attempt to use a closed file\",2)end;bj=true end}elseif n==\"w\"or n==\"a\"then local bs=bv.data;return br{write=function(bl)if bj then error(\"attempt to use a closed file\",2)end;bs=bs..tostring(bl)end,writeLine=function(bl)if bj then error(\"attempt to use a closed file\",2)end;bs=bs..tostring(bl)..\"\\n\"end,flush=function()if bj then error(\"attempt to use a closed file\",2)end;bv.data=bs end,close=function()if bj then error(\"attempt to use a closed file\",2)end;bv.data=bs;bj=true end}elseif n==\"rb\"then return br{readLine=function(bk)if bj then error(\"attempt to use a closed file\",2)end;if#bv.data==0 then return nil end;local bl;bl,bv.data=bv.data:match(\"([^\\n]*\"..(bk and\"\\n?)\"or\")\\n?\")..\"(.*)\")return bl end,readAll=function()if bj then error(\"attempt to use a closed file\",2)end;if#bv.data==0 then return nil end;local bl=bv.data;bv.data=\"\"return bl end,read=function(r)if bj then error(\"attempt to use a closed file\",2)end;if r~=nil and type(r)~=\"number\"then error(\"bad argument #1 (expected number, got \"..type(r)..\")\",2)end;if#bv.data==0 then return nil end;if r then local bl=bv.data:sub(1,r)bv.data=bv.data:sub(r+1)return bl else local bl=bv.data:byte()bv.data=bv.data:sub(2)return bl end end,seek=function(bm,U)if bm~=nil and type(bm)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(bm)..\")\",2)end;if U~=nil and type(U)~=\"number\"then error(\"bad argument #2 (expected number, got \"..type(U)..\")\",2)end;if bj then error(\"attempt to use closed file\",2)end;return 0 end,close=function()if bj then error(\"attempt to use a closed file\",2)end;bj=true end}elseif n==\"wb\"or n==\"ab\"then local bs=bv.data;return br{write=function(bl)if bj then error(\"attempt to use a closed file\",2)end;if type(bl)==\"number\"then bs=bs..string.char(bl)elseif type(bl)==\"string\"then bs=bs..bl else error(\"bad argument #1 (expected string or number, got \"..type(bl)..\")\",2)end end,writeLine=function(bl)if bj then error(\"attempt to use a closed file\",2)end;if type(bl)==\"number\"then bs=bs..string.char(bl)..\"\\n\"elseif type(bl)==\"string\"then bs=bs..bl..\"\\n\"else error(\"bad argument #1 (expected string or number, got \"..type(bl)..\")\",2)end end,seek=function(bm,U)if bm~=nil and type(bm)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(bm)..\")\",2)end;if U~=nil and type(U)~=\"number\"then error(\"bad argument #2 (expected number, got \"..type(U)..\")\",2)end;if bj then error(\"attempt to use closed file\",2)end;return#bv.data+#bs end,flush=function()if bj then error(\"attempt to use a closed file\",2)end;bv.data=bs end,close=function()if bj then error(\"attempt to use a closed file\",2)end;bv.data=bs;bj=true end}else return nil,\"Invalid mode\"end end;filesystem.openfifo=filesystem.fifohandle;do local a=fs.open(\"/meta.ltn\",\"r\")if a then filesystems.craftos.meta=unserialize(a.readAll())or filesystems.craftos.meta;filesystems.craftos.lastDispatch=os.epoch\"utc\"a.close()end end;shutdownHooks[#shutdownHooks+1]=function()local a=assert(fs.open(filesystems.craftos.metapath,\"w\"))a.write(serialize(filesystems.craftos.meta,{compact=true}))a.close()end;if args.fsmeta then local a=fs.open(args.fsmeta,\"r\")if a then local bw=unserialize(a.readAll())a.close()if bw then local function bx(by,bz)for h,i in pairs(by)do if bz[h]and type(bz[h])==\"table\"and type(i)==\"table\"then bx(i,bz[h])else bz[h]=i end end end;bx(bw,filesystems.craftos.meta)end end end;function filesystems.craftos:getmeta(user,bb,bA)local bB={}local y=self.meta;local bg=split(bb,\"/\\\\\")for v,E in ipairs(bg)do if E==\"..\"then y=table.remove(bB)if not y then return nil end elseif not E:match\"^%.*$\"then if not y then return nil elseif y.meta.type~=\"directory\"then error(\"Not a directory\",2)elseif y.meta.permissions[user]then if not y.meta.permissions[user].execute then error(\"Permission denied\",2)end elseif not y.meta.worldPermissions.execute then error(\"Permission denied\",2)end;bB[#bB+1]=y;y=y.contents[E]if y and y.meta.type==\"link\"and not(bA and v==#bg)then syslog.debug(\"linking \"..bb..\" to \"..filesystem.combine(y.meta.link,table.unpack(bg,v+1)))error{link=true,path=filesystem.combine(y.meta.link,table.unpack(bg,v+1)),orig=bb}end end end;return y and y.meta end;function filesystems.craftos:setmeta(user,bb,bw,bA)local bB={}local y=self.meta;local m;local bg=split(bb,\"/\\\\\")for v,E in ipairs(bg)do if E==\"..\"then y=table.remove(bB)if not y then error(\"Not a directory\",2)end elseif not E:match\"^%.*$\"then if y.meta.type~=\"directory\"then error(\"Not a directory\",2)elseif y.meta.permissions[user]then if not y.meta.permissions[user].execute then error(\"Permission denied\",2)end elseif not y.meta.worldPermissions.execute then error(\"Permission denied\",2)end;if not y.contents[E]then y.contents[E]={meta={type=\"directory\",owner=y.meta.owner or\"root\",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}}end;bB[#bB+1]=y;y=y.contents[E]m=E;if y and y.meta.type==\"link\"and not(bA and v==#bg)then syslog.debug(\"linking \"..bb..\" to \"..filesystem.combine(y.meta.link,table.unpack(bg,v+1)))error{link=true,path=filesystem.combine(y.meta.link,table.unpack(bg,v+1)),orig=bb}end end end;if bw~=nil then y.meta={type=bw.type,owner=bw.owner,permissions=deepcopy(bw.permissions),worldPermissions=deepcopy(bw.worldPermissions),setuser=bw.setuser,link=bw.link}if bw.type~=\"directory\"then y.contents=nil end else bB[#bB].contents[m]=nil end;if os.epoch\"utc\"-self.lastDispatch>1000 then local a=assert(fs.open(self.metapath,\"w\"))a.write(serialize(self.meta,{compact=true}))a.close()self.lastDispatch=os.epoch\"utc\"end end;function filesystems.craftos:new(process,bb,bC)expect.field(bC,\"ro\",\"boolean\",\"nil\")if process.user~=\"root\"then error(\"Could not mount \"..bb..\": Permission denied\",3)elseif not fs.isDir(bb)then error(\"Could not mount \"..bb..\": No such directory\",3)end;return setmetatable({path=bb,readOnly=bC.ro},{__index=self})end;function filesystems.craftos:open(process,bb,n)local bf,bD=pcall(self.stat,self,process,bb)if not bf then if type(bD)==\"table\"then error(bD)end;return nil,bD elseif not bD then if n:sub(1,1)==\"w\"or n:sub(1,1)==\"a\"then if self.readOnly then return nil,\"Read-only filesystem\"end;local bE,bF=pcall(self.stat,self,process,fs.getDir(bb))if not bE or not bF then if type(bF)==\"table\"then error(bF)end;local bG,o=pcall(self.mkdir,self,process,fs.getDir(bb))if not bG then if type(o)==\"table\"then error(o)end;return nil,o:gsub(\"kernel:%d: \",\"\")end;bF=self:stat(process,fs.getDir(bb))if not bF then return nil,\"Could not stat \"..fs.getDir(bb)end end;if process.user~=\"root\"then local bH=bF.permissions[process.user]or bF.worldPermissions;if not bH.write then return nil,\"Permission denied\"end end;local bw={type=\"file\",owner=process.user,permissions=deepcopy(bF.permissions),worldPermissions=deepcopy(bF.worldPermissions),setuser=false}if bF.owner then local y=bw.permissions[bF.owner]bw.permissions[bF.owner]=nil;bw.permissions[process.user]=y end;self:setmeta(process.user,fs.combine(self.path,bb),bw)local a,o=fs.open(fs.combine(self.path,bb),n)if not a then return a,o end;return setmetatable(a,{__name=\"file\"})else return nil,\"File not found\"end elseif bD.type==\"directory\"then return nil,\"Is a directory\"end;local bH=bD.permissions[process.user]or bD.worldPermissions;if n:sub(1,1)==\"r\"and not bH.read or(n:sub(1,1)==\"w\"or n:sub(1,1)==\"a\")and not bH.write then return nil,\"Permission denied\"end;if bD.type==\"fifo\"then local bw=self:getmeta(process.user,fs.combine(self.path,bb))local bI=fifos[bw]if not bI then bI={data=\"\"}fifos[bw]=bI end;return filesystem.fifohandle(process,bI,n)end;return setmetatable(fs.open(fs.combine(self.path,bb),n),{__name=\"file\"})end;function filesystems.craftos:list(process,bb)local bD=self:stat(process,bb)if not bD or bD.type~=\"directory\"then error(bb..\": Not a directory\",2)end;if process.user~=\"root\"then local bH=bD.permissions[process.user]or bD.worldPermissions;if not bH.read then error(bb..\": Permission denied\",2)end end;return fs.list(fs.combine(self.path,bb))end;function filesystems.craftos:stat(process,bb,bA)local E=fs.combine(self.path,bb)if E:find(self.path:gsub(\"^/\",\"\"):gsub(\"/$\",\"\"),1,false)~=1 then return nil end;local bf,bJ=pcall(fs.attributes,E)if not bf or not bJ then return nil end;bJ.type=bJ.isDir and\"directory\"or\"file\"bJ.special={}bJ.isDir=nil;if not bJ.modified then bJ.modified=bJ.modification end;bJ.modification=nil;bJ.capacity=fs.getCapacity(E)bJ.freeSpace=fs.getFreeSpace(E)local bK=bJ.isReadOnly;bJ.isReadOnly=nil;local bw=self:getmeta(process.user,fs.combine(self.path,bb),bA)if bw then bJ.owner=bw.owner;bJ.permissions=deepcopy(bw.permissions)bJ.worldPermissions=deepcopy(bw.worldPermissions)bJ.type=bw.type or bJ.type;bJ.setuser=bw.setuser;bJ.link=bw.link else bJ.owner=\"root\"bJ.permissions={root={read=true,write=true,execute=true}}bJ.worldPermissions={read=true,write=false,execute=true}bJ.setuser=false end;if bK then bJ.worldPermissions.write=false;for z,i in pairs(bJ.permissions)do i.write=false end end;return bJ end;function filesystems.craftos:remove(process,bb)if self.readOnly then error(bb..\": Read-only filesystem\",2)end;local bD=self:stat(process,bb,true)if not bD then return end;local function bL(E)local bn=self:stat(process,E,true)local bH=bn.permissions[process.user]or bn.worldPermissions;if process.user~=\"root\"and not bH.write then error(E..\": Permission denied\",3)end;if bn.type==\"directory\"then if process.user~=\"root\"and not bH.read then error(E..\": Permission denied\",3)end;for z,i in ipairs(fs.list(fs.combine(self.path,E)))do bL(fs.combine(E,i))end end end;bL(bb)fs.delete(fs.combine(self.path,bb))self:setmeta(process.user,fs.combine(self.path,bb),nil,true)end;function filesystems.craftos:rename(process,bM,bN)if self.readOnly then error(\"Read-only filesystem\",2)end;local bO=self:stat(process,bM,true)local bP=self:stat(process,bN,true)if not bO then error(bM..\": No such file or directory\",2)elseif bP then error(bN..\": \"..bP.type:gsub(\"%w\",string.upper,1)..\" already exists\",2)end;bP=self:stat(process,fs.getDir(bN))if not bP then self:mkdir(process,fs.getDir(bN))bP=self:stat(process,fs.getDir(bN))end;if process.user~=\"root\"then local bH=bP.permissions[process.user]or bP.worldPermissions;if not bH.write then error(bN..\": Permission denied\",2)end end;fs.move(fs.combine(self.path,bM),fs.combine(self.path,bN))self:setmeta(process.user,fs.combine(self.path,bN),self:getmeta(process.user,fs.combine(self.path,bM),true),true)self:setmeta(process.user,fs.combine(self.path,bM),nil,true)end;function filesystems.craftos:mkdir(process,bb)if self.readOnly then error(bb..\": Read-only filesystem\",2)end;local bD=self:stat(process,bb)if bD then if bD.type==\"directory\"then return else error(bb..\": File already exists\",2)end end;local bg=split(bb,\"/\\\\\")local v=#bg;repeat v=v-1;bD=self:stat(process,table.concat(bg,\"/\",1,v))if bD then if bD.type==\"directory\"then break else error(bb..\": File already exists\",2)end end until bD or v<=0;if not bD then if bb:match\"^/\"then bD=assert(self:stat(process,\"/\"))else bD=assert(filesystem.stat(process,process.dir))end end;if process.user~=\"root\"then local bH=bD.permissions[process.user]or bD.worldPermissions;if not bH.write then error(bb..\": Permission denied\",2)end end;local bw={type=\"directory\",owner=process.user,permissions=deepcopy(bD.permissions),worldPermissions=deepcopy(bD.worldPermissions)}if bD.owner then local y=bw.permissions[bD.owner]bw.permissions[bD.owner]=nil;bw.permissions[process.user]=y end;v=v+1;while v<=#bg do self:setmeta(process.user,fs.combine(self.path,table.concat(bg,\"/\",1,v)),deepcopy(bw))v=v+1 end;fs.makeDir(fs.combine(self.path,bb))end;function filesystems.craftos:link(process,bb,bQ)local bD=self:stat(process,bb)if bD then error(bb..\": File exists\",2)end;self:open(process,bb,\"w\").close()local bw=self:getmeta(process.user,fs.combine(self.path,bb),true)bw.type,bw.link=\"link\",bQ;self:setmeta(process.user,fs.combine(self.path,bb),bw,true)end;function filesystems.craftos:mkfifo(process,bb)local bD=self:stat(process,bb)if bD then error(bb..\": File exists\",2)end;self:open(process,bb,\"w\").close()local bw=self:getmeta(process.user,fs.combine(self.path,bb),true)bw.type=\"fifo\"self:setmeta(process.user,fs.combine(self.path,bb),bw,true)end;function filesystems.craftos:chmod(process,bb,user,n)if self.readOnly then error(bb..\": Read-only filesystem\",2)end;local bD=self:stat(process,bb,true)if not bD then error(bb..\": No such file or directory\",2)end;if not bD.owner or process.user~=\"root\"and process.user~=bD.owner then error(bb..\": Permission denied\",2)end;local bH;if user==nil then bH=bD.worldPermissions else bH=bD.permissions[user]if not bH then bH=deepcopy(bD.worldPermissions)bD.permissions[user]=bH end end;if type(n)==\"string\"then if n:match\"^[%+%-=][rwxs]+$\"then local A=n:sub(1,1)local y={}for a9 in n:gmatch(\"[rwxs]\")do if a9==\"r\"then y.read=true elseif a9==\"w\"then y.write=true elseif a9==\"s\"then y.setuser=true else y.execute=true end end;if A==\"+\"then if y.read then bH.read=true end;if y.write then bH.write=true end;if y.execute then bH.execute=true end;if y.setuser then bD.setuser=true end elseif A==\"-\"then if y.read then bH.read=false end;if y.write then bH.write=false end;if y.execute then bH.execute=false end;if y.setuser then bD.setuser=false end else bH.read=y.read or false;bH.write=y.write or false;bH.execute=y.execute or false;bD.setuser=y.setuser or false end else bH.read=n:sub(1,1)~=\"-\"bH.write=n:sub(2,2)~=\"-\"bH.execute=n:sub(3,3)~=\"-\"bD.setuser=n:sub(3,3)==\"s\"end elseif type(n)==\"number\"then bD.setuser=bit32.btest(n,8)bH.read=bit32.btest(n,4)bH.write=bit32.btest(n,2)bH.execute=bit32.btest(n,1)else if n.read~=nil then bH.read=n.read end;if n.write~=nil then bH.write=n.write end;if n.execute~=nil then bH.execute=n.execute end;if n.setuser~=nil then bD.setuser=n.setuser end end;self:setmeta(process.user,fs.combine(self.path,bb),deepcopy(bD),true)end;function filesystems.craftos:chown(process,bb,bR)if self.readOnly then error(bb..\": Read-only filesystem\",2)end;local bD=self:stat(process,bb,true)if not bD then error(bb..\": No such file or directory\",2)end;if not bD.owner or process.user~=\"root\"and process.user~=bD.owner then error(bb..\": Permission denied\",2)end;bD.owner=bR;bD.setuser=false;self:setmeta(process.user,fs.combine(self.path,bb),deepcopy(bD),true)end;function filesystems.craftos:info()return\"craftos\",self.path,{ro=self.readOnly}end;function filesystems.tmpfs:getpath(user,bb,bA)local y=self;local bg=split(bb,\"/\\\\\")for v,E in ipairs(bg)do if not y then return nil elseif y.type~=\"directory\"then error(\"Not a directory\",2)elseif y.permissions[user]then if not y.permissions[user].execute then error(\"Permission denied\",2)end elseif not y.worldPermissions.execute then error(\"Permission denied\",2)end;y=y.contents[E]if y and y.type==\"link\"and not(bA and v==#bg)then error{link=true,path=filesystem.combine(y.link,table.unpack(bg,v+1)),orig=bb}end end;return y end;function filesystems.tmpfs:setpath(user,bb,bh,bA)local y=self;local K=split(bb,\"/\\\\\")local bS=K[#K]K[#K]=nil;for v,E in ipairs(K)do if y.type~=\"directory\"then error(\"Not a directory\",2)elseif y.permissions[user]then if not y.permissions[user].execute then error(\"Permission denied\",2)end elseif not y.worldPermissions.execute then error(\"Permission denied\",2)end;if not y.contents[E]then y.contents[E]={type=\"directory\",owner=y.owner,permissions=deepcopy(y.permissions),worldPermissions=deepcopy(y.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\",contents={}}end;y=y.contents[E]if y and y.type==\"link\"then error{link=true,path=filesystem.combine(y.link,table.unpack(K,v+1)),orig=bb}end end;if y.type~=\"directory\"then error(\"Not a directory\",2)elseif user~=\"root\"then if y.permissions[user]then if not y.permissions[user].execute then error(\"Permission denied\",2)end elseif not y.worldPermissions.execute then error(\"Permission denied\",2)end end;if not bA and y.contents[bS]and y.contents[bS].type==\"link\"then error{link=true,path=y.contents[bS].link,orig=bb}end;y.contents[bS]=bh end;function filesystems.tmpfs:new(process,by,bC)return setmetatable({type=\"directory\",owner=process.user,permissions={[process.user]={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\",contents={}},{__index=self})end;function filesystems.tmpfs:_open_internal(process,bb,n)local bT=os.epoch;local bh=self:getpath(process.user,bb)if not bh then return nil,\"No such file\"end;if n==\"r\"or n==\"rb\"then return filesystem.readhandle(process,bh.data,n==\"rb\")elseif n==\"w\"or n==\"wb\"then bh.data=\"\"bh.modified=bT\"utc\"return filesystem.writehandle(process,function(bs,bU)if bU then bh.data=bs else bh.data=bh.data..bs end;bh.modified=bT\"utc\"if self.__flush then self:__flush()end end,n==\"wb\")elseif n==\"a\"or n==\"ab\"then local bV=bh.data;return filesystem.writehandle(process,function(bs,bU)if bU then bh.data=bV..bs else bh.data=bh.data..bs end;bh.modified=bT\"utc\"if self.__flush then self:__flush()end end,n==\"ab\")else return nil,\"Invalid mode\"end end;function filesystems.tmpfs:open(process,bb,n)if self.readOnly and(n:sub(1,1)==\"w\"or n:sub(1,1)==\"a\")then return nil,\"Read-only filesystem\"end;local bf,bD=pcall(self.stat,self,process,bb)if not bf then if type(bD)==\"table\"then error(bD)end;return nil,bD elseif not bD then if n:sub(1,1)==\"w\"or n:sub(1,1)==\"a\"then local bE,bF=pcall(self.stat,self,process,fs.getDir(bb))if not bE or not bF then if type(bF)==\"table\"then error(bF)end;local bG,o=pcall(self.mkdir,self,process,fs.getDir(bb))if not bG then if type(o)==\"table\"then error(o)end;return nil,o:gsub(\"kernel:%d: \",\"\")end;bF=self:stat(process,fs.getDir(bb))end;if process.user~=\"root\"then local bH=bF.permissions[process.user]or bF.worldPermissions;if not bH.write then return nil,\"Permission denied\"end end;local bw={type=\"file\",owner=process.user,permissions=deepcopy(bF.permissions),worldPermissions=deepcopy(bF.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\",data=\"\"}local y=bw.permissions[bF.owner]bw.permissions[bF.owner]=nil;bw.permissions[process.user]=y;self:setpath(process.user,bb,bw)return self:_open_internal(process,bb,n)else return nil,\"File not found\"end elseif bD.type==\"directory\"then return nil,\"Is a directory\"end;if process.user~=\"root\"then local bH=bD.permissions[process.user]or bD.worldPermissions;if n:sub(1,1)==\"r\"and not bH.read or(n:sub(1,1)==\"w\"or n:sub(1,1)==\"a\")and not bH.write then return nil,\"Permission denied\"end end;if bD.type==\"fifo\"then local bw=self:getpath(process.user,bb)local bI=fifos[bw]if not bI then bI={data=\"\"}fifos[bw]=bI end;return filesystem.fifohandle(process,bI,n)end;return self:_open_internal(process,bb,n)end;function filesystems.tmpfs:list(process,bb)local bh=self:getpath(process.user,bb)if not bh or bh.type~=\"directory\"then error(bb..\": Not a directory\",2)end;if process.user~=\"root\"then local bH=bh.permissions[process.user]or bh.worldPermissions;if not bH.read then error(bb..\": Permission denied\",2)end end;local a5={}for h in pairs(bh.contents)do a5[#a5+1]=h end;table.sort(a5)return a5 end;function filesystems.tmpfs:stat(process,bb,bA)local bh=self:getpath(process.user,bb,bA)if not bh then return nil end;return{size=bh.type==\"file\"and#bh.data or(bh.type==\"directory\"and#bh.contents or 0),type=bh.type,created=bh.created,modified=bh.modified,owner=bh.owner,permissions=deepcopy(bh.permissions),worldPermissions=deepcopy(bh.worldPermissions),setuser=bh.setuser,capacity=math.huge,freeSpace=math.huge,link=rawget(bh,\"link\"),special={}}end;function filesystems.tmpfs:remove(process,bb)if self.readOnly then error(\"Read-only filesystem\",2)end;local bW=self:getpath(process.user,fs.getDir(bb))local m=fs.getName(bb)if not bW or bW.type~=\"directory\"or not bW.contents[m]then return end;if process.user~=\"root\"and not(bW.permissions[process.user]or bW.worldPermissions).write then error(bb..\": Permission denied\",2)end;local bh=bW.contents[m]if process.user~=\"root\"and not(bh.permissions[process.user]or bh.worldPermissions).write then error(bb..\": Permission denied\",2)end;local function bL(bn)local bH=bn.permissions[process.user]or bn.worldPermissions;if process.user~=\"root\"and not bH.write then error(bb..\": Permission denied\",3)end;if bn.type==\"directory\"then if process.user~=\"root\"and not bH.read then error(bb..\": Permission denied\",3)end;for z,i in pairs(bn.contents)do bL(i)end end end;bL(bh)bW.contents[m]=nil;bW.modified=os.epoch\"utc\"end;function filesystems.tmpfs:rename(process,bM,bN)if self.readOnly then error(\"Read-only filesystem\",2)end;local bX=self:getpath(process.user,fs.getDir(bM))local bY=fs.getName(bM)if not bX or bX.type~=\"directory\"or not bX.contents[bY]then error(bM..\": No such file or directory\",2)end;if process.user~=\"root\"and not(bX.permissions[process.user]or bX.worldPermissions).write then error(bM..\": Permission denied\",2)end;local bZ=bX.contents[bY]if process.user~=\"root\"and not(bZ.permissions[process.user]or bZ.worldPermissions).write then error(bM..\": Permission denied\",2)end;local b_=self:getpath(process.user,fs.getDir(bN))local c0=fs.getName(bN)if not b_ or b_.type~=\"directory\"then error(bN..\": No such file or directory\",2)end;if process.user~=\"root\"and not(b_.permissions[process.user]or b_.worldPermissions).write then error(bN..\": Permission denied\",2)end;local c1=b_.contents[c0]if c1 then error(bN..\": File already exists\",2)end;b_.contents[c0],bX.contents[bY]=bZ,nil;local c2=os.epoch\"utc\"bX.modified,b_.modified=c2,c2 end;function filesystems.tmpfs:mkdir(process,bb)if self.readOnly then error(\"Read-only filesystem\",2)end;local y=self;for z,E in ipairs(split(bb,\"/\\\\\"))do local bH=y.permissions[process.user]or y.worldPermissions;if y.type~=\"directory\"then error(bb..\": File exists\",2)elseif process.user~=\"root\"and not bH.execute then error(bb..\": Permission denied\",2)end;if not y.contents[E]then if process.user~=\"root\"and not bH.write then error(bb..\": Permission denied\",2)end;y.contents[E]={type=\"directory\",owner=y.owner,permissions=deepcopy(y.permissions),worldPermissions=deepcopy(y.worldPermissions),created=os.epoch\"utc\",modified=os.epoch\"utc\",contents={}}y.modified=os.epoch\"utc\"end;y=y.contents[E]end end;function filesystems.tmpfs:link(process,bb,bQ)if self.readOnly then error(\"Read-only filesystem\",2)end;local bD=self:stat(process,bb)if bD then error(bb..\": File exists\",2)end;local bE,bF=pcall(self.stat,self,process,fs.getDir(bb))if not bE or not bF then if type(bF)==\"table\"then error(bF)end;local bG,o=pcall(self.mkdir,self,process,fs.getDir(bb))if not bG then if type(o)==\"table\"then error(o)end;return nil,type(o)==\"string\"and o:gsub(\"kernel:%d: \",\"\")or o end;bF=self:stat(process,fs.getDir(bb))end;self:setpath(process.user,bb,{type=\"link\",owner=process.user,permissions=deepcopy(bF.permissions),worldPermissions=deepcopy(bF.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\",path=bQ},true)end;function filesystems.tmpfs:mkfifo(process,bb)if self.readOnly then error(\"Read-only filesystem\",2)end;local bD=self:stat(process,bb)if bD then error(bb..\": File exists\",2)end;local bE,bF=pcall(self.stat,self,process,fs.getDir(bb))if not bE or not bF then if type(bF)==\"table\"then error(bF)end;local bG,o=pcall(self.mkdir,self,process,fs.getDir(bb))if not bG then if type(o)==\"table\"then error(o)end;return nil,type(o)==\"string\"and o:gsub(\"kernel:%d: \",\"\")or o end;bF=self:stat(process,fs.getDir(bb))end;self:setpath(process.user,bb,{type=\"fifo\",owner=process.user,permissions=deepcopy(bF.permissions),worldPermissions=deepcopy(bF.worldPermissions),setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\"},true)end;function filesystems.tmpfs:chmod(process,bb,user,n)if self.readOnly then error(\"Read-only filesystem\",2)end;local bD=self:getpath(process.user,bb,true)if not bD then error(bb..\": No such file or directory\",2)end;if not bD.owner or process.user~=\"root\"and process.user~=bD.owner then error(bb..\": Permission denied\",2)end;local bH;if user==nil then bH=bD.worldPermissions else bH=bD.permissions[user]if not bH then bH=deepcopy(bD.worldPermissions)bD.permissions[user]=bH end end;if type(n)==\"string\"then if n:match\"^[%+%-=][rwxs]+$\"then local A=n:sub(1,1)local y={}for a9 in n:gmatch(\"[rwxs]\")do if a9==\"r\"then y.read=true elseif a9==\"w\"then y.write=true elseif a9==\"s\"then y.setuser=true else y.execute=true end end;if A==\"+\"then if y.read then bH.read=true end;if y.write then bH.write=true end;if y.execute then bH.execute=true end;if y.setuser then bD.setuser=true end elseif A==\"-\"then if y.read then bH.read=false end;if y.write then bH.write=false end;if y.execute then bH.execute=false end;if y.setuser then bD.setuser=false end else bH.read=y.read or false;bH.write=y.write or false;bH.execute=y.execute or false;bD.setuser=y.setuser or false end else bH.read=n:sub(1,1)~=\"-\"bH.write=n:sub(2,2)~=\"-\"bH.execute=n:sub(3,3)~=\"-\"bD.setuser=n:sub(3,3)==\"s\"end elseif type(n)==\"number\"then bD.setuser=bit32.btest(n,8)bH.read=bit32.btest(n,4)bH.write=bit32.btest(n,2)bH.execute=bit32.btest(n,1)else if n.read~=nil then bH.read=n.read end;if n.write~=nil then bH.write=n.write end;if n.execute~=nil then bH.execute=n.execute end;if n.setuser~=nil then bD.setuser=n.setuser end end end;function filesystems.tmpfs:chown(process,bb,bR)if self.readOnly then error(\"Read-only filesystem\",2)end;local bD=self:getpath(process.user,bb,true)if not bD then error(bb..\": No such file or directory\",2)end;if not bD.owner or process.user~=\"root\"and process.user~=bD.owner then error(bb..\": Permission denied\",2)end;bD.owner=bR;bD.setuser=false end;function filesystems.tmpfs:info()return\"tmpfs\",\"memory\",{ro=self.readOnly}end;setmetatable(filesystems.drivefs,{__index=filesystems.craftos})function filesystems.drivefs:stat(process,bb)local u,o=filesystems.craftos.stat(self,process,bb)if bb==\"\"and u==nil then return{size=0,type=\"directory\",created=0,modified=0,owner=self.owner,capacity=0,freeSpace=0,permissions={[self.owner]={read=false,write=true,execute=false}},worldPermissions={read=false,write=false,execute=false},setuser=false}end;return u,o end;function filesystems.drivefs:new(process,by,bC)local c3=hardware.get(by)if not c3 then error(\"Could not find drive at \"..by)end;local bb=hardware.call(process,c3,\"getMountPath\")local fs=filesystems.craftos:new(process,bb,bC)fs.drive=c3.uuid;fs.owner=process.user;fs.meta={meta={type=\"directory\",owner=\"root\",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}}fs.metapath=fs.combine(bb,\".meta.ltn\")local a=fs.open(fs.metapath,\"r\")if a then fs.meta=unserialize(a.readAll())or fs.meta;a.close()end;return setmetatable(fs,{__index=self})end;function filesystems.drivefs:info()return\"drivefs\",self.drive,{ro=self.readOnly}end;setmetatable(filesystems.tablefs,{__index=filesystems.tmpfs})function filesystems.tablefs:new(process,by,bC)local y;local a,o;if process==KERNEL and mounts[\"\"]then a,o=filesystem.open(process,by,\"r\")else a,o=fs.open(by,\"r\")end;if a then local bh=a.readAll()or\"\"a.close()local bf,u=pcall(unserialize,bh)if not bf then error(\"Could not mount \"..by..\": \"..u,3)elseif type(u)~=\"table\"or u.type~=\"directory\"or type(u.contents)~=\"table\"then error(\"Could not mount \"..by..\": Invalid table file\",3)end;y=u else if not(bC.rw and not bC.ro)then error(\"Could not mount \"..by..\": \"..o,3)end;y={type=\"directory\",owner=process.user,permissions={[process.user]={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false,created=os.epoch\"utc\",modified=os.epoch\"utc\",contents={}}end;y.src=by;y.readOnly=bC.ro;if bC.rw and not bC.ro then function y:__flush()local f,bn=self.__flush,self.src;self.__flush,self.src=nil;local bf,u=pcall(serialize,self)self.__flush,self.src=f,bn;if not bf then error(u)end;local a,o=filesystem.open(process,by,\"w\")if not a then syslog.log({level=4},\"Could not save mount to \"..by..\": \"..o)return end;a.write(u)a.close()end end;return setmetatable(y,{__index=self})end;function filesystems.tablefs:info()return\"tablefs\",self.src,{rw=self.__flush~=nil,ro=self.readOnly}end;function filesystems.bind:new(process,bb,bC)local bD,o=filesystem.stat(process,bb)if not bD then error(\"Could not bind \"..bb..\": \"..o,3)elseif bD.type~=\"directory\"then error(\"Could not bind \"..bb..\": Not a directory\",3)end;return setmetatable({path=bb},{__index=self})end;function filesystems.bind:open(process,bb,n)return filesystem.open(process,fs.combine(self.path,bb),n)end;function filesystems.bind:list(process,bb)return filesystem.list(process,fs.combine(self.path,bb))end;function filesystems.bind:stat(process,bb,bA)return filesystem.stat(process,fs.combine(self.path,bb),bA)end;function filesystems.bind:remove(process,bb)return filesystem.remove(process,fs.combine(self.path,bb))end;function filesystems.bind:rename(process,bM,bN)return filesystem.rename(process,fs.combine(self.path,bM),fs.combine(self.path,bN))end;function filesystems.bind:mkdir(process,bb)return filesystem.mkdir(process,fs.combine(self.path,bb))end;function filesystems.bind:link(process,bb,bQ)return filesystem.link(process,fs.combine(self.path,bb),bQ)end;function filesystems.bind:mkfifo(process,bb)return filesystem.mkfifo(process,fs.combine(self.path,bb))end;function filesystems.bind:chmod(process,bb,user,n)return filesystem.chmod(process,fs.combine(self.path,bb),user,n)end;function filesystems.bind:chown(process,bb,bR)return filesystem.chown(process,fs.combine(self.path,bb),bR)end;function filesystems.bind:info()return\"bind\",self.path,{}end;function filesystem.open(process,bb,n)expect(0,process,\"table\")expect(1,bb,\"string\")expect(2,n,\"string\")if not n:match\"^[rwa]b?$\"then error(\"Invalid mode\",0)end;repeat local bf,c4,E=pcall(bc,process,bb)if not bf then return nil,c4 end;local u=table.pack(pcall(c4.open,c4,process,E,n))if u[1]then return table.unpack(u,2,u.n)elseif type(u[2])~=\"table\"or type(u[2].path)~=\"string\"then error(u[2],2)end;bb=u[2].path until u[1]end;function filesystem.list(process,bb)expect(0,process,\"table\")expect(1,bb,\"string\")repeat local c4,E=bc(process,bb)local bf,u=pcall(c4.list,c4,process,E)if bf then return u elseif type(u)~=\"table\"or type(u.path)~=\"string\"then error(u,2)end;bb=u.path until bf end;function filesystem.stat(process,bb,bA)expect(0,process,\"table\")expect(1,bb,\"string\")repeat local bf,c4,E,c5=pcall(bc,process,bb)if not bf then return nil,c4 end;local c6,u,o=pcall(c4.stat,c4,process,E,bA)if c6 then if u then u.mountpoint=\"/\"..c5 end;return u,o elseif type(u)~=\"table\"or type(u.path)~=\"string\"then error(u,2)end;bb=u.path until c6 end;function filesystem.remove(process,bb)expect(0,process,\"table\")expect(1,bb,\"string\")repeat local c4,E=bc(process,bb)local bf,u=pcall(c4.remove,c4,process,E)if bf then return elseif type(u)~=\"table\"or type(u.path)~=\"string\"then error(u,2)end;bb=u.path until bf end;function filesystem.rename(process,bM,bN)expect(0,process,\"table\")expect(1,bM,\"string\")expect(2,bN,\"string\")repeat local c7,c8=bc(process,bM)local c9,ca=bc(process,bN)if c7~=c9 then error(\"Attempt to rename file across two filesystems\",0)end;local bf,u=pcall(c7.rename,c7,process,c8,ca)if bf then return elseif type(u)~=\"table\"or type(u.path)~=\"string\"then error(u,2)end;if u.orig==bM then bM=u.path else bN=u.path end until bf end;function filesystem.mkdir(process,bb)expect(0,process,\"table\")expect(1,bb,\"string\")repeat local c4,E=bc(process,bb)local bf,u=pcall(c4.mkdir,c4,process,E)if bf then return elseif type(u)~=\"table\"or type(u.path)~=\"string\"then error(u,2)end;bb=u.path until bf end;function filesystem.link(process,bb,bQ)expect(0,process,\"table\")expect(1,bb,\"string\")expect(2,bQ,\"string\")if fs.combine(bb)==fs.combine(bQ)then error(\"Cannot link file to itself\",2)end;syslog.debug(\"Creating link\",bb,\" => \",bQ)repeat local c4,E=bc(process,bb)if not c4.link then error(\"Filesystem does not support links\",2)end;local bf,u=pcall(c4.link,c4,process,E,bQ)if bf then return elseif type(u)~=\"table\"or type(u.path)~=\"string\"then error(u,2)end;bb=u.path until bf end;function filesystem.mkfifo(process,bb)expect(0,process,\"table\")expect(1,bb,\"string\")repeat local c4,E=bc(process,bb)if not c4.mkfifo then error(\"Filesystem does not support FIFOs\",2)end;local bf,u=pcall(c4.mkfifo,c4,process,E)if bf then return elseif type(u)~=\"table\"or type(u.path)~=\"string\"then error(u,2)end;bb=u.path until bf end;function filesystem.chmod(process,bb,user,n)expect(0,process,\"table\")expect(1,bb,\"string\")expect(2,user,\"string\",\"nil\")expect(3,n,\"number\",\"string\",\"table\")if type(n)==\"string\"and not n:match\"^[%+%-=][rwxs]+$\"and not n:match\"^[r%-][w%-][xs%-]$\"then error(\"bad argument #3 (invalid mode)\",2)elseif type(n)==\"table\"then expect.field(n,\"read\",\"boolean\",\"nil\")expect.field(n,\"write\",\"boolean\",\"nil\")expect.field(n,\"execute\",\"boolean\",\"nil\")end;repeat local c4,E=bc(process,bb)local bf,u=pcall(c4.chmod,c4,process,E,user,n)if bf then return elseif type(u)~=\"table\"or type(u.path)~=\"string\"then error(u,2)end;bb=u.path until bf end;function filesystem.chown(process,bb,user)expect(0,process,\"table\")expect(1,bb,\"string\")expect(2,user,\"string\")repeat local c4,E=bc(process,bb)local bf,u=pcall(c4.chown,c4,process,E,user)if bf then return elseif type(u)~=\"table\"or type(u.path)~=\"string\"then error(u,2)end;bb=u.path until bf end;function filesystem.chroot(process,bb)expect(0,process,\"table\")expect(1,bb,\"string\")if process.user~=\"root\"then error(\"Could not change root: Permission denied\",2)end;local cb=filesystem.combine(process.root,bb)..\"/\"if cb:find(process.root,1,true)~=1 then error(\"Could not change root: No such file or directory\",2)end;local bn=filesystem.stat(process,\"/\"..bb)if not bn then error(bb..\": No such directory\",2)end;if bn.type~=\"directory\"then error(bb..\": Not a directory\",2)end;process.root=cb end;function filesystem.mount(process,type,by,bz,bC)expect(0,process,\"table\")expect(1,type,\"string\")expect(2,by,\"string\")expect(3,bz,\"string\")expect(4,bC,\"table\",\"nil\")if not filesystems[type]then error(\"No such filesystem '\"..type..\"'\",2)end;local E=ba(process,bz)if E==\"\"then if process.user~=\"root\"then error(\"Could not mount to \"..bz..\": Permission denied\",2)elseif mounts[E]then error(\"Could not mount to \"..bz..\": Mount already exists\")end else local bD=filesystem.stat(process,bz)if not bD then error(\"Could not mount to \"..bz..\": No such directory\",2)elseif bD.type~=\"directory\"then error(\"Could not mount to \"..bz..\": Not a directory\",2)elseif process.user~=\"root\"and not(bD.permissions[process.user]or bD.worldPermissions).write then error(\"Could not mount to \"..bz..\": Permission denied\",2)elseif mounts[E]then error(\"Could not mount to \"..bz..\": Mount already exists\")end end;local c4=filesystems[type]:new(process,by,bC or{})mounts[E]=c4 end;function filesystem.unmount(process,bb)expect(0,process,\"table\")expect(1,bb,\"string\")bb=ba(process,bb)if not mounts[bb]then error(bb..\": No such mount\",2)end;local bD=mounts[bb]:stat(process,\"\")if not bD then error(\"Internal error in unmount: could not get stat for root! Please report this to the maintainer of the target filesystem.\",2)elseif process.user~=\"root\"and not(bD.permissions[process.user]or bD.worldPermissions).write then error(bb..\": Permission denied\",2)end;if mounts[bb].unmount then mounts[bb]:unmount(process)end;mounts[bb]=nil end;function filesystem.mountlist(process)expect(0,process,\"table\")local a5={}for h,i in pairs(mounts)do if\"/\"..h..\"/\"==process.root or h:find(process.root:sub(2),1,true)==1 then local type,bb,bC=i:info()a5[#a5+1]={path=\"/\"..h,type=type,source=bb,options=bC}end end;return a5 end;function filesystem.combine(cc,...)local a0=fs.combine(cc,...)if cc:match\"^/\"then a0=\"/\"..a0 end;return a0 end;function syscalls.open(process,aq,...)return filesystem.open(process,...)end;function syscalls.list(process,aq,...)return filesystem.list(process,...)end;function syscalls.stat(process,aq,...)return filesystem.stat(process,...)end;function syscalls.remove(process,aq,...)return filesystem.remove(process,...)end;function syscalls.rename(process,aq,...)return filesystem.rename(process,...)end;function syscalls.mkdir(process,aq,...)return filesystem.mkdir(process,...)end;function syscalls.link(process,aq,...)return filesystem.link(process,...)end;function syscalls.mkfifo(process,aq,...)return filesystem.mkfifo(process,...)end;function syscalls.chmod(process,aq,...)return filesystem.chmod(process,...)end;function syscalls.chown(process,aq,...)return filesystem.chown(process,...)end;function syscalls.chroot(process,aq,...)return filesystem.chroot(process,...)end;function syscalls.mount(process,aq,...)return filesystem.mount(process,...)end;function syscalls.unmount(process,aq,...)return filesystem.unmount(process,...)end;function syscalls.mountlist(process,aq,...)return filesystem.mountlist(process,...)end;function syscalls.combine(process,aq,...)return filesystem.combine(...)end;function syscalls.loadCraftOSAPI(process,aq,cd)expect(1,cd,\"string\")local e;e=setmetatable({dofile=function(bb)local a,o=fs.open(bb,\"rb\")if not a then error(\"Could not open module: \"..o,0)end;local g,o=load(a.readAll(),\"@\"..bb,nil,e)a.close()if not g then error(\"Could not load module: \"..o,0)end;return g()end,require=function(m)return e.dofile(\"rom/modules/main/\"..m:gsub(\"%.\",\"/\")..\".lua\")end},{__index=process.env})if cd:sub(1,3)==\"cc.\"then local bb=fs.combine(\"rom/modules/main\",cd:gsub(\"%.\",\"/\")..\".lua\")if not bb:match\"^/?rom/modules/main/\"then error(\"Invalid module path\",0)end;return e.dofile(bb)else if not cd:match\"^[a-z]+$\"then error(\"Invalid API name\",0)end;local bb=fs.combine(\"rom/apis\",cd..\".lua\")local a,o=fs.open(bb,\"rb\")if not a then error(\"Could not open module: \"..o,0)end;local g,o=load(a.readAll(),\"@\"..bb,nil,e)a.close()if not g then error(\"Could not load module: \"..o,0)end;g()local y={}for h,i in pairs(e)do if h~=\"dofile\"then y[h]=i end end;return y end end;xpcall(function()if args.initrd then if args.initrd:match\"^_G%..\"then local ce=_G[args.initrd:match\"^_G%.(.+)\"]if type(ce)~=\"table\"then error(\"Requested root filesystem in global '\"..args.initrd..\"' is not a table\")end;ce.src=args.initrd;mounts[\"\"]=setmetatable(ce,{__index=filesystems.tablefs})else mounts[\"\"]=filesystems.tablefs:new(KERNEL,args.initrd,{})end else local bC={}if args.rootflags then for A in args.rootflags:gmatch\"[^,]+\"do local h,i=A:match(\"^([^=]+)=(.*)$\")if h and i then if i==\"true\"then bC[h]=true elseif i==\"false\"then bC[h]=false else bC[h]=tonumber(i)or i end else bC[A]=true end end end;mounts[\"\"]=filesystems[args.rootfstype]:new(KERNEL,args.root,bC)end end,panic)local do_syscall=do_syscall;local expect=expect;local function cf(cg,ch,ci,cj)local ck={bit32.extract(ch,0,16),bit32.extract(ch,16,16),bit32.extract(cg,0,16),bit32.extract(cg,16,16)}local ab={bit32.extract(cj,0,16),bit32.extract(cj,16,16),bit32.extract(ci,0,16),bit32.extract(ci,16,16)}local bt={{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0}}for cl=1,4 do for cm=1,4 do local r=ck[cm]*ab[cl]+bt[cl][cm]bt[cl][cm+1],bt[cl][cm]=bit32.rshift(r,16),bit32.band(r,0xFFFF)end end;local cn={0,0,0,0,0,0,0,0}for co=1,8 do for cp=1,4 do cn[co]=cn[co]+(bt[cp][co-cp+1]or 0)end;cn[co+1],cn[co]=bit32.rshift(cn[co],16),bit32.band(cn[co],0xFFFF)end;return cn[3]+cn[4]*0x10000,cn[1]+cn[2]*0x10000 end;local function cq(ab,cg,ch)return cg+math.floor((ch+ab)/0x100000000),bit32.band(ch+ab,0xFFFFFFFF)end;function makeRandom()local cr,cs=0,0;local function next(ct)cr,cs=cq(0xB,cf(cr,cs,0x5,0xDEECE66D))cr=bit32.band(cr,0xFFFF)return math.floor(cr/2^(16-ct))+math.floor(cs/2^(48-ct))end;local function cu(c,d)expect(1,c,\"number\",\"nil\")expect(2,d,\"number\",\"nil\")if c then expect.range(c,0,0x7FFFFFFF)if not d then c,d=0,c else expect.range(d,0,0x7FFFFFFF)end;local cv=d-c+1;local cw;if math.log(cv,2)%1==0 then cw=math.floor(cv*next(31)/0x80000000)else local ct;repeat ct=next(31)cw=ct%cv until ct-cw+cv-1>=0 end;return cw+c else return(next(26)*0x8000000+next(27))/0x20000000000000 end end;local function cx(cy)expect(1,cy,\"number\")cr,cs=bit32.band(bit32.bxor(0x5,math.floor(cy/0x100000000)),0xFFFF),bit32.bxor(0xDEECE66D,math.floor(cy))end;cx(os.epoch\"utc\"*tonumber(tostring(next):match(\"%x+\")or\"1\",16))return cu,cx end;do math.random,math.randomseed=makeRandom()end;function createLuaLib(process)local cz={}for z,i in ipairs{\"assert\",\"error\",\"getmetatable\",\"ipairs\",\"next\",\"pairs\",\"pcall\",\"rawequal\",\"rawget\",\"rawset\",\"select\",\"setmetatable\",\"tonumber\",\"tostring\",\"type\",\"_VERSION\",\"xpcall\",\"collectgarbage\"}do cz[i]=_G[i]end;function cz.dofile(bb)if bb~=nil and type(bb)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(bb)..\")\",2)end;local g,o=loadfile(bb or io.stdin:read(\"*a\"))if not g then error(o,2)end;return g()end;do local load,getfenv,setfenv,make_ENV=load,getfenv,setfenv,make_ENV;if _VERSION==\"Lua 5.1\"then function cz.load(l,m,n,e)return load(l,m,n,make_ENV(e or process.env))end;function cz.getfenv(f)local i;if f==nil then i=getfenv(2)elseif tonumber(f)and tonumber(f)>0 then i=getfenv(f+1)elseif type(f)==\"function\"then i=getfenv(f)else i=getfenv(f)end;local aB=getmetatable(f)if aB and aB.__env then return aB.__env else return i end end;function cz.setfenv(f,K)return setfenv(f,make_ENV(K))end else cz.load,cz.getfenv,cz.setfenv=function(l,m,n,e)return load(l,m,n,e or process.env)end,getfenv,setfenv end end;function cz.loadfile(bb,n,e)if e==nil and type(n)==\"table\"then e,n=n,nil end;if type(bb)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(bb)..\")\",2)end;if n~=nil and type(n)~=\"string\"then error(\"bad argument #2 (expected string, got \"..type(n)..\")\",2)end;if e~=nil and type(e)~=\"table\"then error(\"bad argument #3 (expected table, got \"..type(e)..\")\",2)end;local a,o=do_syscall(\"open\",bb,\"rb\")if not a then error(o,2)end;local bh=a.readAll()a.close()return load(bh,\"@\"..bb,n,e)end;function cz.print(...)local args=table.pack(...)if args.n==0 then args={\"\",n=1}end;args[args.n]=tostring(args[args.n])..\"\\n\"return do_syscall(\"write\",table.unpack(args,1,args.n))end;cz.coroutine=deepcopy(coroutine)cz.string=deepcopy(string)cz.table=deepcopy(table)cz.math=deepcopy(math)cz.bit32=deepcopy(bit32)cz.math.random,cz.math.randomseed=makeRandom()local cA=cz.coroutine.resume;cz.coroutine.resume=function(...)local a5=table.pack(cA(...))while a5.n==2 and a5[1]==true and a5[2]==\"preempt\"do a5=table.pack(cA(coroutine.yield(\"preempt\")))end;return table.unpack(a5,1,a5.n)end;local cB=\"\"local cC=setmetatable({close=function()end,lines=function(self,...)local args=table.pack(...)return function()return self:read(table.unpack(args,1,args.n))end end,read=function(self,a6,...)local bn,K;a6=a6 or\"*l\"if type(a6)==\"number\"then while#cB<a6 do cB=cB..do_syscall(\"read\",a6)end elseif type(a6)==\"string\"then a6=a6:gsub(\"^%*\",\"\")if a6==\"n\"then while not cB:find(\"%d\")do local bo=do_syscall(\"readline\")if bo==nil then break end;cB=cB..bo..\"\\n\"end elseif a6==\"a\"then while true do local bo=do_syscall(\"readline\")if bo==nil then break end;cB=cB..bo..\"\\n\"end elseif a6==\"l\"or a6==\"L\"then local bo=do_syscall(\"readline\")if bo==nil then return nil end;cB=cB..bo..\"\\n\"else error(\"bad argument (invalid format '\"..a6 ..\"')\",2)end else error(\"bad argument (expected string or number, got \"..type(a6),2)end;if type(a6)==\"number\"then bn,K=cB:sub(1,a6),a6+1 elseif a6==\"n\"then bn,K=cB:match(\"(%d)()\")elseif a6==\"a\"then bn,K=cB,#cB+1 elseif a6==\"l\"then bn,K=cB:match(\"(.*)\\n()\")else bn,K=cB:match(\"(.*\\n)()\")end;if not bn then return nil end;cB=cB:sub(K)if select(\"#\",...)>0 then return bn,self:read(...)else return bn end end,seek=function()return nil,\"Cannot seek default file\"end,setvbuf=function()end},{__name=\"FILE*\"})local cD=setmetatable({close=function()end,flush=function()end,seek=function()return nil,\"Cannot seek default file\"end,setvbuf=function()end,write=function(self,...)do_syscall(\"write\",...)return self end},{__name=\"FILE*\"})local cE=setmetatable({close=function()end,flush=function()end,seek=function()return nil,\"Cannot seek default file\"end,setvbuf=function()end,write=function(self,...)do_syscall(\"writeerr\",...)return self end},{__name=\"FILE*\"})local cF,cG=cC,cD;local cH={close=function(self)self._file.close()self._closed=true end,lines=function(self,...)local args=table.pack(...)return function()return self:read(table.unpack(args,1,args.n))end end,read=function(self,a6,...)local i;if a6==nil then a6=\"l\"end;if type(a6)==\"number\"then i=self._file.read(a6)elseif type(a6)==\"string\"then a6=a6:gsub(\"^%*\",\"\")if a6==\"a\"then i=self._file.readAll()elseif a6==\"l\"then i=self._file.readLine(false)elseif a6==\"L\"then i=self._file.readLine(true)elseif a6==\"n\"then local bn,a9=\"\"repeat a9=self._file.read(1)until a9:match(\"%d\")while a9:match(\"%d\")do bn,a9=bn..a9,self._file.read(1)end;i=tonumber(bn)else error(\"bad argument (invalid format '\"..a6 ..\"')\",2)end else error(\"bad argument (expected string or number, got \"..type(a6)..\")\",2)end;if select(\"#\",...)>0 then return i,self:read(...)else return i end end,seek=function(self,bm,U)if self._file.seek then return self._file.seek(bm,U)else return nil,\"Cannot seek text file\"end end,setvbuf=function()end}local cI={close=function(self)self._file.close()self._closed=true end,flush=function(self)self._file:flush()end,seek=function(self,bm,U)if self._file.seek then return self._file.seek(bm,U)else return nil,\"Cannot seek text file\"end end,setvbuf=function()end,write=function(self,...)self._file.write(...)return self end}cz.io={close=function(a)if a==nil then cG:close()elseif type(a)==\"table\"and getmetatable(a)and getmetatable(a).__name==\"FILE*\"then a:close()else error(\"bad argument #1 (expected FILE*, got \"..type(a)..\")\",2)end end,flush=function()return cG:flush()end,input=function(a)if a==nil then return cF elseif type(a)==\"string\"then local ag,o=io.open(a,\"r\")if not ag then error(o,2)end;cF=ag elseif type(a)==\"table\"and getmetatable(a)and getmetatable(a).__name==\"FILE*\"then cF=a else error(\"bad argument #1 (expected string or FILE*, got \"..type(a)..\")\",2)end end,lines=function(cJ,...)if cJ==nil then return cF:lines(...)end;if type(cJ)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(cJ)..\")\",2)end;local ag,o=io.open(cJ,\"r\")if not ag then error(o,2)end;local g=ag:lines(...)return function(...)local a5=table.pack(g(...))if a5.n==0 or a5[1]==nil then ag:close()end;return table.unpack(a5,1,a5.n)end end,open=function(cJ,n)if type(cJ)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(cJ)..\")\",2)end;if type(n)~=\"string\"then error(\"bad argument #2 (expected string, got \"..type(n)..\")\",2)end;local a,o=do_syscall(\"open\",cJ,n)if not a then return nil,o elseif n:find(\"r\")then return setmetatable({_file=a},{__index=cH,__name=\"FILE*\"})else return setmetatable({_file=a},{__index=cI,__name=\"FILE*\"})end end,output=function(a)if a==nil then return cG elseif type(a)==\"string\"then local ag,o=io.open(a,\"w\")if not ag then error(o,2)end;cG=ag elseif type(a)==\"table\"and getmetatable(a)and getmetatable(a).__name==\"FILE*\"then cG=a else error(\"bad argument #1 (expected string or FILE*, got \"..type(a)..\")\",2)end end,popen=function(bb,n)expect(1,bb,\"string\")n=expect(2,n,\"string\",\"nil\")or\"r\"if n~=\"r\"and n~=\"w\"and n~=\"rw\"then error(\"bad argument #2 (invalid mode)\",2)end;if n==\"rw\"then local cK,cL=\"\",\"\"local cM;local cN={read=function(r)if cK==\"\"then return nil elseif r then local bn=cK:sub(1,r)cK=cK:sub(r+1)return bn else local bn,K=cK:match\"([^\\n]*)\\n*()\"cK=cK:sub(K)return bn end end}local cO={write=function(bn)cK=cK..bn end,flush=function()end,close=function()local b3=do_syscall(\"getpinfo\",cM)if not b3 then return end;repeat local ar,cP=coroutine.yield()until ar==\"process_complete\"and cP.pid==cM end}local cQ={read=function(r)if cL==\"\"then return nil elseif r then local bn=cL:sub(1,r)cL=cL:sub(r+1)return bn else local bn,K=cL:match\"([^\\n]*)\\n*()\"cL=cL:sub(K)return bn end end,readLine=function()local bn,K=cL:match\"([^\\n]*)\\n*()\"cL=cL:sub(K)return bn end,readAll=function()local bn=cL;cL=\"\"return bn end,close=function()local b3=do_syscall(\"getpinfo\",cM)if not b3 then return end;repeat local ar,cP=coroutine.yield()until ar==\"process_complete\"and cP.pid==cM end}local cR={write=function(bn)cL=cL..bn end}cM=do_syscall(\"fork\",function()do_syscall(\"stdin\",cN)do_syscall(\"stdout\",cR)do_syscall(\"exec\",\"/bin/sh\",\"-c\",bb)end)return setmetatable({_file=cQ},{__index=cH,__name=\"FILE*\"}),setmetatable({_file=cO},{__index=cI,__name=\"FILE*\"})else local cS=\"\"local bj=false;local cM;local cT={read=function(r)if cS==\"\"then if bj then return nil else return\"\"end elseif r then local bn=cS:sub(1,r)cS=cS:sub(r+1)return bn else local bn,K=cS:match\"([^\\n]*\\n?)()\"cS=cS:sub(K)return bn end end,readLine=function()local bn,K=cS:match\"([^\\n]*\\n?)()\"cS=cS:sub(K)return bn end,readAll=function()local bn=cS;cS=\"\"return bn end,close=function()bj=true;local b3=do_syscall(\"getpinfo\",cM)if not b3 then return end;repeat local ar,cP=coroutine.yield()until ar==\"process_complete\"and cP.pid==cM end}local cU={write=function(bn)cS=cS..bn end,flush=function()end,close=function()bj=true;local b3=do_syscall(\"getpinfo\",cM)if not b3 then return end;repeat local ar,cP=coroutine.yield()until ar==\"process_complete\"and cP.pid==cM end}cM=do_syscall(\"fork\",function()do_syscall(n==\"r\"and\"stdout\"or\"stdin\",n==\"r\"and cU or cT)do_syscall(\"exec\",\"/bin/sh\",\"-c\",bb)end)return n==\"r\"and setmetatable({_file=cT},{__index=cH,__name=\"FILE*\"})or setmetatable({_file=cU},{__index=cI,__name=\"FILE*\"})end end,read=function(...)return cF:read(...)end,tmpfile=function()return io.open(os.tmpname(),\"a\")end,type=function(bv)if type(bv)==\"table\"and getmetatable(bv)and getmetatable(bv).__name==\"FILE*\"then if bv._closed then return\"closed file\"else return\"file\"end else return nil end end,write=function(...)return cG:write(...)end,stdin=cC,stdout=cD,stderr=cE}local cV=os;cz.os={clock=function()return do_syscall(\"clock\")end,date=function(a6,c2)if type(a6)==\"string\"and a6:sub(1,1)==\"?\"then local bl=cV.date(\"!\"..a6:sub(2),c2 or cV.epoch\"ingame\"/1000)if type(bl)==\"table\"then bl.year=bl.year-1970 end;return bl else return cV.date(a6,c2)end end,difftime=function(ck,ab)return ck-ab end,execute=function(bb)do_syscall(\"exec\",\"/bin/sh\",\"-c\",bb)end,exit=function(bp)do_syscall(\"exit\",bp)end,getenv=function(m)expect(1,m,\"string\")local e=do_syscall(\"getenv\")if not e then return nil end;return e[m]end,remove=function(bb)expect(1,bb,\"string\")local bf,o=do_syscall(\"remove\",bb)if not bf then bf=nil end;return bf,o end,rename=function(bM,bN)expect(1,bM,\"string\")expect(2,bN,\"string\")local bf,o=do_syscall(\"rename\",bM,bN)if not bf then bf=nil end;return bf,o end,setlocale=function(cW)if cW then error(\"setlocale is not supported\",2)else return\"C\"end end,time=function(y)if y==\"ingame\"then return cV.epoch\"ingame\"/1000 elseif y==\"nano\"then return ccemux and ccemux.nanoTime()or cV.epoch\"nano\"end;expect(1,y,\"table\",\"nil\")if y then return cV.time(y)else return cV.epoch\"utc\"/1000 end end,tmpname=function()local m=\"/tmp/lua_\"for v=1,6 do local r=math.random(1,64)m=m..(\"qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890._\"):sub(r,r)end;return m end}cz.debug=deepcopy(debug)createRequire(process,cz)for h,i in pairs(cz)do if type(i)==\"function\"then pcall(setfenv,i,cz)pcall(debug.protect,i)elseif type(i)==\"table\"and h~=\"debug\"then for z,af in pairs(i)do if type(af)==\"function\"then pcall(setfenv,af,cz)pcall(debug.protect,af)end end end end;return cz end;function loadfile(bb,n,e)if e==nil and type(n)==\"table\"then e,n=n,nil end;if type(bb)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(bb)..\")\",2)end;if n~=nil and type(n)~=\"string\"then error(\"bad argument #2 (expected string, got \"..type(n)..\")\",2)end;if e~=nil and type(e)~=\"table\"then error(\"bad argument #3 (expected table, got \"..type(e)..\")\",2)end;local a,o=filesystem.open(KERNEL,bb,\"rb\")if not a then error(o,2)end;local bh=a.readAll()a.close()return load(bh,\"@\"..bb,n,e)end;function dofile(bb)if bb~=nil and type(bb)~=\"string\"then error(\"bad argument #1 (expected string, got \"..type(bb)..\")\",2)end;local g,o=loadfile(bb or io.stdin:read(\"*a\"))if not g then error(o,2)end;return g()end;function print(...)for v=1,select(\"#\",...)do local i=tostring(select(v,...))terminal.write(TTY[1],i)end end;function terminal.makeTTY(term,t,cX)local a5={isTTY=true,flags={cbreak=false,delay=true,echo=true,keypad=false,nlcr=true,raw=false},cursor={x=1,y=1},cursorBlink=true,colors={fg='0',bg='f',bold=false},size={width=t,height=cX},dirtyLines={},palette={},dirtyPalette={},buffer=\"\",preBuffer=\"\",isLocked=false,isGraphics=false,textBuffer={},graphicsBuffer={},frontmostProcess=nil,processList={},eof=false,term=term}for q=1,cX do a5[q]={(' '):rep(t),('0'):rep(t),('f'):rep(t)}a5.dirtyLines[q]=true end;for v=0,15 do a5.palette[v]={_G.term.nativePaletteColor(2^v)}a5.dirtyPalette[v]=true end;return a5 end;do local cY,cZ=term.getSize()TTY={terminal.makeTTY(term,cY,cZ),terminal.makeTTY(term,cY,cZ),terminal.makeTTY(term,cY,cZ),terminal.makeTTY(term,cY,cZ),terminal.makeTTY(term,cY,cZ),terminal.makeTTY(term,cY,cZ),terminal.makeTTY(term,cY,cZ),terminal.makeTTY(term,cY,cZ)}end;currentTTY=TTY[1]terminal.userTTYs={}do local r=args.console:match\"^tty(%d+)$\"if r then KERNEL.stdout,KERNEL.stderr,KERNEL.stdin=TTY[tonumber(r)],TTY[tonumber(r)],TTY[tonumber(r)]end end;keysHeld={ctrl=false,alt=false,shift=false}eventHooks.term_resize=eventHooks.term_resize or{}eventHooks.char=eventHooks.char or{}eventHooks.paste=eventHooks.paste or{}eventHooks.key=eventHooks.key or{}eventHooks.key_up=eventHooks.key_up or{}eventHooks.term_resize[#eventHooks.term_resize+1]=function()local af,ag=term.getSize()for v=1,8 do terminal.resize(TTY[v],af,ag)end end;eventHooks.char[#eventHooks.char+1]=function(ar)if not currentTTY.isLocked then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer..ar[2]else currentTTY.preBuffer=currentTTY.preBuffer..ar[2]end;if currentTTY.flags.echo then terminal.write(currentTTY,ar[2])terminal.redraw(currentTTY)end end end;eventHooks.paste[#eventHooks.paste+1]=function(ar)if not currentTTY.isLocked then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer..ar[2]else currentTTY.preBuffer=currentTTY.preBuffer..ar[2]end;if currentTTY.flags.echo then terminal.write(currentTTY,ar[2])terminal.redraw(currentTTY)end end end;eventHooks.key[#eventHooks.key+1]=function(ar)if not currentTTY.isLocked then if ar[2]==keys.enter then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer..\"\\n\"else currentTTY.buffer=currentTTY.buffer..currentTTY.preBuffer..\"\\n\"currentTTY.preBuffer=\"\"end;if currentTTY.flags.echo then terminal.write(currentTTY,\"\\n\")terminal.redraw(currentTTY)end elseif ar[2]==keys.backspace then if currentTTY.flags.cbreak then elseif#currentTTY.preBuffer>0 then currentTTY.preBuffer=currentTTY.preBuffer:sub(1,-2)if currentTTY.flags.echo then terminal.write(currentTTY,\"\\b \\b\")terminal.redraw(currentTTY)end end end end;if ar[2]==keys.leftCtrl or ar[2]==keys.rightCtrl then keysHeld.ctrl=true elseif ar[2]==keys.leftAlt or ar[2]==keys.rightAlt then keysHeld.alt=true elseif ar[2]==keys.leftShift or ar[2]==keys.rightShift then keysHeld.shift=true end;if not currentTTY.flags.raw and currentTTY.frontmostProcess and keysHeld.ctrl and not keysHeld.alt and not keysHeld.shift then if ar[2]==keys.c then killProcess(currentTTY.frontmostProcess.id,2)terminal.write(currentTTY,\"^C\")elseif ar[2]==keys.backslash then killProcess(currentTTY.frontmostProcess.id,3)terminal.write(currentTTY,\"^\\\\\")elseif ar[2]==keys.z then killProcess(currentTTY.frontmostProcess.id,19)terminal.write(currentTTY,\"^Z\")elseif ar[2]==keys.d then currentTTY.eof=true;terminal.write(currentTTY,\"^D\")end end;if keysHeld.ctrl and keysHeld.alt and not keysHeld.shift then local c_=true;if ar[2]==keys.one then currentTTY=TTY[1]elseif ar[2]==keys.two then currentTTY=TTY[2]elseif ar[2]==keys.three then currentTTY=TTY[3]elseif ar[2]==keys.four then currentTTY=TTY[4]elseif ar[2]==keys.five then currentTTY=TTY[5]elseif ar[2]==keys.six then currentTTY=TTY[6]elseif ar[2]==keys.seven then currentTTY=TTY[7]elseif ar[2]==keys.eight then currentTTY=TTY[8]elseif ar[2]==keys.left then for v=1,8 do if currentTTY==TTY[v]then currentTTY=TTY[(v+7)%8]break end end elseif ar[2]==keys.right then for v=1,8 do if currentTTY==TTY[v]then currentTTY=TTY[(v+1)%8]break end end else c_=false end;if c_ then terminal.redraw(currentTTY,true)end end end;eventHooks.key_up[#eventHooks.key_up+1]=function(ar)if ar[2]==keys.leftCtrl or ar[2]==keys.rightCtrl then keysHeld.ctrl=false elseif ar[2]==keys.leftAlt or ar[2]==keys.rightAlt then keysHeld.alt=false elseif ar[2]==keys.leftShift or ar[2]==keys.rightShift then keysHeld.shift=false end end;function terminal.redraw(d0,bU)if d0.process then d0.process.eventQueue[#d0.process.eventQueue+1]={\"tty_redraw\",{id=d0.id}}return elseif currentTTY~=d0 and not d0.isMonitor then return end;local term=d0.term;local cS=d0;if d0.isLocked then if d0.isGraphics then term.setGraphicsMode(2)if term.setFrozen then term.setFrozen(true)end;if bU then term.clear()term.drawPixels(0,0,d0.graphicsBuffer)for v=0,255 do term.setPaletteColor(v,d0.graphicsBuffer.palette[v][1],d0.graphicsBuffer.palette[v][2],d0.graphicsBuffer.palette[v][3])end else if d0.graphicsBuffer.frozen then if term.setFrozen then term.setFrozen(false)end;return end;for z,i in ipairs(d0.graphicsBuffer.dirtyRects)do if i.color then term.setPixel(i.x,i.y,i.color,i.width,i.height)else term.drawPixels(i.x,i.y,i)end end;for v in pairs(d0.graphicsBuffer.dirtyPalette)do term.setPaletteColor(v,d0.graphicsBuffer.palette[v][1],d0.graphicsBuffer.palette[v][2],d0.graphicsBuffer.palette[v][3])end end;if term.setFrozen then term.setFrozen(false)end;cS.dirtyRects,cS.dirtyPalette={},{}return end;if term.setGraphicsMode then term.setGraphicsMode(false)end;cS=d0.textBuffer elseif d0.isGraphics then term.setGraphicsMode(false)d0.isGraphics=false end;term.setCursorBlink(false)if bU then term.clear()for q=1,d0.size.height do term.setCursorPos(1,q)term.blit(cS[q][1],cS[q][2],cS[q][3])end;for v=0,15 do term.setPaletteColor(2^v,cS.palette[v][1],cS.palette[v][2],cS.palette[v][3])end else for q in pairs(cS.dirtyLines)do if not cS[q]then error(debug.traceback(q))end;term.setCursorPos(1,q)if#cS[q][1]~=#cS[q][2]or#cS[q][2]~=#cS[q][3]then syslog.log({level=\"critical\"},\"Bug in text writer! Inequal lengths: \"..#cS[q][1]..\", \"..#cS[q][2]..\", \"..#cS[q][3])error(\"Invalid lengths\")end;term.blit(cS[q][1],cS[q][2],cS[q][3])end;for v in pairs(cS.dirtyPalette)do term.setPaletteColor(2^v,cS.palette[v][1],cS.palette[v][2],cS.palette[v][3])end end;term.setCursorPos(cS.cursor.x,cS.cursor.y)term.setCursorBlink(cS.cursorBlink)cS.dirtyLines,cS.dirtyPalette={},{}end;function terminal.resize(d0,t,cX)if t>d0.size.width then for q=1,d0.size.height do d0[q][1]=d0[q][1]..(' '):rep(t-d0.size.width)d0[q][2]=d0[q][2]..d0.colors.fg:rep(t-d0.size.width)d0[q][3]=d0[q][3]..d0.colors.bg:rep(t-d0.size.width)d0.dirtyLines[q]=true end;if d0.isLocked then if d0.isGraphics then for q=1,d0.size.height*9 do d0.graphicsBuffer[q]=d0.graphicsBuffer[q]..('\\15'):rep((t-d0.size.width)*6)end;d0.graphicsBuffer.dirtyRects[#d0.graphicsBuffer.dirtyRects+1]={x=d0.size.width*6+1,y=1,width=(t-d0.size.width)*6,height=d0.size.height*9}else for q=1,d0.size.height do d0.textBuffer[q][1]=d0.textBuffer[q][1]..(' '):rep(t-d0.size.width)d0.textBuffer[q][2]=d0.textBuffer[q][2]..d0.textBuffer.colors.fg:rep(t-d0.size.width)d0.textBuffer[q][3]=d0.textBuffer[q][3]..d0.textBuffer.colors.bg:rep(t-d0.size.width)d0.textBuffer.dirtyLines[q]=true end end end elseif t<d0.size.width then for q=1,d0.size.height do d0[q][1]=d0[q][1]:sub(1,t)d0[q][2]=d0[q][2]:sub(1,t)d0[q][3]=d0[q][3]:sub(1,t)d0.dirtyLines[q]=true end;if d0.isLocked then if d0.isGraphics then for q=1,d0.size.height*9 do d0.graphicsBuffer[q]=d0.graphicsBuffer[q]:sub(1,t*6)end else for q=1,d0.size.height do d0.textBuffer[q][1]=d0.textBuffer[q][1]:sub(1,t)d0.textBuffer[q][2]=d0.textBuffer[q][2]:sub(1,t)d0.textBuffer[q][3]=d0.textBuffer[q][3]:sub(1,t)end end end end;d0.size.width=t;if cX>d0.size.height then for q=d0.size.height+1,cX do d0[q]={(' '):rep(t),d0.colors.fg:rep(t),d0.colors.bg:rep(t)}d0.dirtyLines[q]=true end;if d0.isLocked then if d0.isGraphics then for q=d0.size.height*9+1,cX*9 do d0.graphicsBuffer[q]=('\\15'):rep(t*6)end;d0.graphicsBuffer.dirtyRects[#d0.graphicsBuffer.dirtyRects+1]={x=1,y=d0.size.height*9+1,width=d0.size.width*6,height=(cX-d0.size.height)*9}else for q=d0.size.height+1,cX do d0.textBuffer[q]={(' '):rep(t),d0.textBuffer.colors.fg:rep(t),d0.textBuffer.colors.bg:rep(t)}d0.textBuffer.dirtyLines[q]=true end end end elseif cX<d0.size.height then for q=cX+1,d0.size.height do d0[q]=nil;d0.dirtyLines[q]=nil end;if d0.isLocked then if d0.isGraphics then for q=cX*9+1,d0.size.height*9 do d0.graphicsBuffer[q]=nil end else for q=cX+1,d0.size.height do d0.textBuffer[q]=nil;d0.textBuffer.dirtyLines[q]=nil end end end end;d0.size.height=cX end;local function d1(d0)local d2=d0.cursor;local q=d2.y+1;d2.y=q;local S=d0.size;local cX=S.height;if q>cX then local d3=d0.dirtyLines;for v=1,cX-1 do d0[v]=d0[v+1]d3[v]=true end;local t=S.width;local d4=d0.colors;d0[cX]={(' '):rep(t),d4.fg:rep(t),d4.bg:rep(t)}d3[cX]=true;d2.y=cX end end;local d5={['@']=function(d0,av)local E=av[1]or 1;if E==0 then E=1 end;local d6,d7=E%d0.size.width,math.floor(E/d0.size.width)local r={d0[d0.cursor.y][1]:sub(d0.size.width-d6+1),d0[d0.cursor.y][2]:sub(d0.size.width-d6+1),d0[d0.cursor.y][3]:sub(d0.size.width-d6+1)}d0[d0.cursor.y][1]=d0[d0.cursor.y][1]:sub(1,d0.cursor.x-1)..(\" \"):rep(E)..d0[d0.cursor.y+d7][1]:sub(d0.cursor.x,d0.size.width-d6)d0[d0.cursor.y][2]=d0[d0.cursor.y][2]:sub(1,d0.cursor.x-1)..d0.colors.fg:rep(E)..d0[d0.cursor.y+d7][2]:sub(d0.cursor.x,d0.size.width-d6)d0[d0.cursor.y][3]=d0[d0.cursor.y][3]:sub(1,d0.cursor.x-1)..d0.colors.bg:rep(E)..d0[d0.cursor.y+d7][3]:sub(d0.cursor.x,d0.size.width-d6)d0.dirtyLines[d0.cursor.y]=true;for q=d0.cursor.y+d7+1,d0.size.height do local d8={d0[q-d7][1]:sub(d0.size.width-E+1),d0[q-d7][2]:sub(d0.size.width-E+1),d0[q-d7][3]:sub(d0.size.width-E+1)}d0[q][1]=r[1]..d0[q-d7][1]:sub(1,d0.size.width-d6)d0[q][2]=r[2]..d0[q-d7][2]:sub(1,d0.size.width-d6)d0[q][3]=r[3]..d0[q-d7][3]:sub(1,d0.size.width-d6)d0.dirtyLines[q]=true;r=d8 end;for q=d0.cursor.y+1,d0.cursor.y+d7 do d0[q][1]=(\" \"):rep(d0.size.width)d0[q][2]=d0.colors.fg:rep(d0.size.width)d0[q][3]=d0.colors.bg:rep(d0.size.width)d0.dirtyLines[q]=true end end,A=function(d0,av)local E=av[1]or 1;if E==0 then E=1 end;d0.cursor.y=math.max(d0.cursor.y-E,1)end,B=function(d0,av)local E=av[1]or 1;if E==0 then E=1 end;d0.cursor.y=math.min(d0.cursor.y+E,d0.size.height)end,C=function(d0,av)local E=av[1]or 1;if E==0 then E=1 end;d0.cursor.y=d0.cursor.y+math.floor((d0.cursor.x-1+E)/d0.size.width)d0.cursor.x=(d0.cursor.x-1+E)%d0.size.width+1 end,D=function(d0,av)local E=av[1]or 1;if E==0 then E=1 end;d0.cursor.y=d0.cursor.y+math.floor((d0.cursor.x-1-E)/d0.size.width)d0.cursor.x=(d0.cursor.x-1-E)%d0.size.width+1 end,E=function(d0,av)local E=av[1]or 1;if E==0 then E=1 end;d0.cursor.y=math.min(d0.cursor.y+E,d0.size.height)d0.cursor.x=1 end,F=function(d0,av)local E=av[1]or 1;if E==0 then E=1 end;d0.cursor.y=math.max(d0.cursor.y-E,1)d0.cursor.x=1 end,G=function(d0,av)local E=av[1]or 1;if E==0 then E=1 end;d0.cursor.x=math.min(E,d0.size.width)end,H=function(d0,av)local bo,a9=av[1]or 1,av[2]or 1;if bo==0 then bo=1 end;if a9==0 then a9=1 end;d0.cursor.x,d0.cursor.y=math.min(a9,d0.size.width),math.min(bo,d0.size.height)end,I=function(d0,av)end,J=function(d0,av)local r=av[1]or 0;if r==0 then d0[d0.cursor.y][1]=d0[d0.cursor.y][1]:sub(1,d0.cursor.x-1)..(\" \"):rep(d0.size.width-d0.cursor.x)d0[d0.cursor.y][2]=d0[d0.cursor.y][2]:sub(1,d0.cursor.x-1)..d0.colors.fg:rep(d0.size.width-d0.cursor.x)d0[d0.cursor.y][3]=d0[d0.cursor.y][3]:sub(1,d0.cursor.x-1)..d0.colors.bg:rep(d0.size.width-d0.cursor.x)d0.dirtyLines[d0.cursor.y]=true;for q=d0.cursor.y+1,d0.size.height do d0[q][1]=(\" \"):rep(d0.size.width)d0[q][2]=d0.colors.fg:rep(d0.size.width)d0[q][3]=d0.colors.bg:rep(d0.size.width)d0.dirtyLines[q]=true end elseif r==1 then d0[d0.cursor.y][1]=(\" \"):rep(d0.cursor.x)..d0[d0.cursor.y][1]:sub(d0.cursor.x)d0[d0.cursor.y][2]=d0.colors.fg:rep(d0.cursor.x)..d0[d0.cursor.y][2]:sub(d0.cursor.x)d0[d0.cursor.y][3]=d0.colors.bg:rep(d0.cursor.x)..d0[d0.cursor.y][3]:sub(d0.cursor.x)d0.dirtyLines[d0.cursor.y]=true;for q=d0.cursor.y-1,1,-1 do d0[q][1]=(\" \"):rep(d0.size.width)d0[q][2]=d0.colors.fg:rep(d0.size.width)d0[q][3]=d0.colors.bg:rep(d0.size.width)d0.dirtyLines[q]=true end elseif r==2 then for q=1,d0.size.height do d0[q][1]=(\" \"):rep(d0.size.width)d0[q][2]=d0.colors.fg:rep(d0.size.width)d0[q][3]=d0.colors.bg:rep(d0.size.width)d0.dirtyLines[q]=true end end end,K=function(d0,av)local r=av[1]or 0;if r==0 then d0[d0.cursor.y][1]=d0[d0.cursor.y][1]:sub(1,d0.cursor.x-1)..(\" \"):rep(d0.size.width-d0.cursor.x)d0[d0.cursor.y][2]=d0[d0.cursor.y][2]:sub(1,d0.cursor.x-1)..d0.colors.fg:rep(d0.size.width-d0.cursor.x)d0[d0.cursor.y][3]=d0[d0.cursor.y][3]:sub(1,d0.cursor.x-1)..d0.colors.bg:rep(d0.size.width-d0.cursor.x)d0.dirtyLines[d0.cursor.y]=true elseif r==1 then d0[d0.cursor.y][1]=(\" \"):rep(d0.cursor.x)..d0[d0.cursor.y][1]:sub(d0.cursor.x)d0[d0.cursor.y][2]=d0.colors.fg:rep(d0.cursor.x)..d0[d0.cursor.y][2]:sub(d0.cursor.x)d0[d0.cursor.y][3]=d0.colors.bg:rep(d0.cursor.x)..d0[d0.cursor.y][3]:sub(d0.cursor.x)d0.dirtyLines[d0.cursor.y]=true elseif r==2 then d0[d0.cursor.y][1]=(\" \"):rep(d0.size.width)d0[d0.cursor.y][2]=d0.colors.fg:rep(d0.size.width)d0[d0.cursor.y][3]=d0.colors.bg:rep(d0.size.width)d0.dirtyLines[d0.cursor.y]=true end end,L=function(d0,av)end,M=function(d0,av)end,N=function(d0,av)end,O=function(d0,av)end,P=function(d0,av)local E=av[1]or 1;if E==0 then E=1 end;local d6,d7=E%d0.size.width,math.floor(E/d0.size.width)local r={(\" \"):rep(d6),d0.colors.fg:rep(d6),d0.colors.bg:rep(d6)}for q=d0.size.height-d7,d0.cursor.y+1,-1 do local d8={d0[q+d7][1]:sub(1,d6),d0[q+d7][2]:sub(1,d6),d0[q+d7][3]:sub(1,d6)}d0[q][1]=d0[q+d7][1]:sub(d6+1)..r[1]d0[q][2]=d0[q+d7][2]:sub(d6+1)..r[2]d0[q][3]=d0[q+d7][3]:sub(d6+1)..r[3]d0.dirtyLines[q]=true;r=d8 end;for q=d0.size.height-d7+1,d0.size.height do d0[q][1]=(\" \"):rep(d0.size.width)d0[q][2]=d0.colors.fg:rep(d0.size.width)d0[q][3]=d0.colors.bg:rep(d0.size.width)d0.dirtyLines[q]=true end;d0[d0.cursor.y][1]=d0[d0.cursor.y][1]:sub(1,d0.cursor.x-1)..d0[d0.cursor.y+d7][1]:sub(d0.cursor.x+d6,d0.size.width)..r[1]d0[d0.cursor.y][2]=d0[d0.cursor.y][2]:sub(1,d0.cursor.x-1)..d0[d0.cursor.y+d7][2]:sub(d0.cursor.x+d6,d0.size.width)..r[2]d0[d0.cursor.y][3]=d0[d0.cursor.y][3]:sub(1,d0.cursor.x-1)..d0[d0.cursor.y+d7][3]:sub(d0.cursor.x+d6,d0.size.width)..r[3]d0.dirtyLines[d0.cursor.y]=true end,Q=function(d0,av)end,R=function(d0,av)end,S=function(d0,av)local r=av[1]or 0;if r==0 then r=1 end;for z=1,r do table.insert(d0,1,{(' '):rep(d0.size.width),d0.colors.fg:rep(d0.size.width),d0.colors.bg:rep(d0.size.width)})d0[d0.size.height+1]=nil end end,T=function(d0,av)local r=av[1]or 0;if r==0 then r=1 end;for z=1,r do table.remove(d0,1)d0[d0.size.height]={(' '):rep(d0.size.width),d0.colors.fg:rep(d0.size.width),d0.colors.bg:rep(d0.size.width)}end end,U=function(d0,av)end,V=function(d0,av)end,W=function(d0,av)end,X=function(d0,av)end,Y=function(d0,av)end,Z=function(d0,av)end,['[']=function(d0,av)end,['\\\\']=function(d0,av)end,[']']=function(d0,av)end,['^']=function(d0,av)end,['_']=function(d0,av)end,['`']=function(d0,av)end,a=function(d0,av)end,b=function(d0,av)end,c=function(d0,av)end,d=function(d0,av)end,e=function(d0,av)end,f=function(d0,av)end,g=function(d0,av)end,h=function(d0,av)if av[1]==25 then d0.cursorBlink=true end end,i=function(d0,av)end,j=function(d0,av)end,k=function(d0,av)end,l=function(d0,av)if av[1]==25 then d0.cursorBlink=false end end,m=function(d0,av)local r,A=av[1]or 0,av[2]if r==0 then d0.colors.fg,d0.colors.bg,d0.colors.bold='0','f',false elseif r==1 then d0.colors.bold=true elseif r==7 or r==27 then d0.colors.fg,d0.colors.bg=d0.colors.bg,d0.colors.fg elseif r==22 then d0.colors.bold=false elseif r>=30 and r<=37 then d0.colors.fg=(\"%x\"):format(15-(r-30)-(d0.colors.bold and 8 or 0))elseif r==39 then d0.colors.fg='0'elseif r>=40 and r<=47 then d0.colors.bg=(\"%x\"):format(15-(r-40)-(d0.colors.bold and 8 or 0))elseif r==49 then d0.colors.bg='f'elseif r>=90 and r<=97 then d0.colors.fg=(\"%x\"):format(15-(r-90)-8)elseif r>=100 and r<=107 then d0.colors.bg=(\"%x\"):format(15-(r-100)-8)end;if A~=nil then if A==0 then d0.colors.fg,d0.colors.bg='0','f'elseif A==1 then d0.colors.bold=true elseif A==7 or A==27 then d0.colors.fg,d0.colors.bg=d0.colors.bg,d0.colors.fg elseif A==22 then d0.colors.bold=false elseif A>=30 and A<=37 then d0.colors.fg=(\"%x\"):format(15-(A-30)-(d0.colors.bold and 8 or 0))elseif A==39 then d0.colors.fg='0'elseif A>=40 and A<=47 then d0.colors.bg=(\"%x\"):format(15-(A-40)-(d0.colors.bold and 8 or 0))elseif A==49 then d0.colors.bg='f'elseif A>=90 and A<=97 then d0.colors.fg=(\"%x\"):format(15-(A-90)-8)elseif A>=100 and A<=107 then d0.colors.bg=(\"%x\"):format(15-(A-100)-8)end end end,n=function(d0,av)end,o=function(d0,av)end}for v=0x70,0x7F do d5[string.char(v)]=function(d0,av)end end;function terminal.write(d0,d9)local ax,S=1,0;local function da(p)if S==0 then ax,S=p,0;return end;while d0.cursor.x+S>d0.size.width do d0[d0.cursor.y][1]=d0[d0.cursor.y][1]:sub(1,d0.cursor.x-1)..d9:sub(ax,ax+d0.size.width-d0.cursor.x)d0[d0.cursor.y][2]=d0[d0.cursor.y][2]:sub(1,d0.cursor.x-1)..d0.colors.fg:rep(d0.size.width-d0.cursor.x+1)d0[d0.cursor.y][3]=d0[d0.cursor.y][3]:sub(1,d0.cursor.x-1)..d0.colors.bg:rep(d0.size.width-d0.cursor.x+1)d0.dirtyLines[d0.cursor.y]=true;ax=ax+d0.size.width-d0.cursor.x+1;S=S-(d0.size.width-d0.cursor.x+1)d0.cursor.x=1;d1(d0)end;d0[d0.cursor.y][1]=d0[d0.cursor.y][1]:sub(1,d0.cursor.x-1)..d9:sub(ax,ax+S-1)..d0[d0.cursor.y][1]:sub(d0.cursor.x+S)d0[d0.cursor.y][2]=d0[d0.cursor.y][2]:sub(1,d0.cursor.x-1)..d0.colors.fg:rep(S)..d0[d0.cursor.y][2]:sub(d0.cursor.x+S)d0[d0.cursor.y][3]=d0[d0.cursor.y][3]:sub(1,d0.cursor.x-1)..d0.colors.bg:rep(S)..d0[d0.cursor.y][3]:sub(d0.cursor.x+S)d0.dirtyLines[d0.cursor.y]=true;d0.cursor.x=d0.cursor.x+S;ax,S=p,0 end;local db=0;local av,dc;for p,a9,r in d9:gmatch\"()(.)()\"do if db==0 then if a9=='\\a'then da(r)elseif a9=='\\b'then da(r)if d0.cursor.x==1 then if d0.cursor.y>1 then d0.cursor.x,d0.cursor.y=d0.size.width,d0.cursor.y-1 end else d0.cursor.x=d0.cursor.x-1 end elseif a9=='\\t'then da(r)d0.cursor.x=math.floor((d0.cursor.x-1)/8)*8+9;if d0.cursor.x>d0.size.width then d0.cursor.x=1;d1(d0)end elseif a9=='\\n'then da(r)d1(d0)if d0.flags.nlcr then d0.cursor.x=1 end elseif a9=='\\f'then da(r)d1(d0)elseif a9=='\\r'then da(r)d0.cursor.x=1 elseif a9=='\\27'then db=1 else S=S+1 end elseif db==1 then if false then elseif a9=='['then db=2;av,dc={},0 elseif a9==']'then if d9:byte(r)==0x50 then db=4;av={}else db=3;av,dc={},0 end else da(r)db=0 end elseif db==2 then if a9>='@'and a9<='\\127'then da(r)av[#av+1]=dc;d5[a9](d0,av)db=0 elseif a9>='0'and a9<='?'then if a9<='9'then dc=dc*10+tonumber(a9)elseif a9==';'then av[#av+1],dc=dc,0 end else da(r)db=0 end elseif db==3 then if a9=='\\\\'and d9:byte(p-1)=='\\27'then da(r)db=0 end elseif db==4 then if#av==0 then av[1]=tonumber(a9,16)or 0 elseif#av==1 and not dc then dc=(tonumber(a9,16)or 0)*16 elseif#av==1 then av[2],dc=dc+(tonumber(a9,16)or 0),nil elseif#av==2 and not dc then dc=(tonumber(a9,16)or 0)*16 elseif#av==2 then av[3],dc=dc+(tonumber(a9,16)or 0),nil elseif#av==3 and not dc then dc=(tonumber(a9,16)or 0)*16 elseif#av==3 then da(r)av[4],dc=dc+(tonumber(a9,16)or 0),nil;d0.palette[av[1]]={av[2]/255,av[3]/255,av[4]/255}d0.dirtyPalette[av[1]]=true;db=0 end end end;da()end;function syscalls.write(process,aq,...)if not process.stdout then return end;local function dd(y)if process.stdout.isTTY then terminal.write(process.stdout,y)else process.stdout.write(y)end end;local args=table.pack(...)for v=1,args.n do if v>1 then dd(\"\\t\")end;dd(tostring(args[v]))end;if process.stdout.isTTY then terminal.redraw(process.stdout)end end;function syscalls.writeerr(process,aq,...)if not process.stderr then return end;local function dd(y)if process.stderr.isTTY then terminal.write(process.stderr,y)else process.stderr.write(y)end end;local args=table.pack(...)for v=1,args.n do if v>1 then dd(\"\\t\")end;dd(tostring(args[v]))end;if process.stderr.isTTY then terminal.redraw(process.stderr)end end;function syscalls.read(process,aq,r)expect(1,r,\"number\")if process.stdin then if process.stdin.eof then process.stdin.eof=false;return nil end;while#process.stdin.buffer<r do if process.stdin.eof then process.stdin.eof=false;return nil end;if process.stdin.isTTY and not process.stdin.flags.delay then return nil end;if process.stdin.read then local bn=process.stdin.read(r-#process.stdin.buffer)if not bn then return nil end;process.stdin.buffer=process.stdin.buffer..bn else return kSyscallYield,\"read\",r end end;local bn=process.stdin.buffer:sub(1,r-1)process.stdin.buffer=process.stdin.buffer:sub(r)return bn else return nil end end;function syscalls.readline(process,aq)if process.stdin then if process.stdin.eof then process.stdin.eof=false;return nil end;while not process.stdin.buffer:find(\"\\n\")do if process.stdin.eof then process.stdin.eof=false;return nil end;if process.stdin.isTTY and not process.stdin.flags.delay then return nil end;if process.stdin.read then local bn=process.stdin.read()if not bn then return nil end;process.stdin.buffer=process.stdin.buffer..bn else return kSyscallYield,\"readline\"end end;local r=process.stdin.buffer:find(\"\\n\")local bn=process.stdin.buffer:sub(1,r-1)process.stdin.buffer=process.stdin.buffer:sub(r+1)return bn else return nil end end;function syscalls.termctl(process,aq,de)expect(1,de,\"table\",\"nil\")if not process.stdout or not process.stdout.isTTY then return nil end;if de then expect.field(de,\"cbreak\",\"boolean\",\"nil\")expect.field(de,\"delay\",\"boolean\",\"nil\")expect.field(de,\"echo\",\"boolean\",\"nil\")expect.field(de,\"keypad\",\"boolean\",\"nil\")expect.field(de,\"nlcr\",\"boolean\",\"nil\")expect.field(de,\"raw\",\"boolean\",\"nil\")for h,i in pairs(de)do if process.stdout.flags[h]~=nil then process.stdout.flags[h]=i end end end;local y=deepcopy(process.stdout.flags)y.hasgfx=term.getGraphicsMode~=nil;return y end;function terminal.openterm(d0,process)if d0.isLocked then if not d0.isGraphics and d0.frontmostProcess==process then return d0.screenHandle end;return nil,\"Terminal already in use\"end;local S=d0.size;local cS={cursor={x=1,y=1},cursorBlink=false,colors={fg='0',bg='f'},palette={},dirtyLines={},dirtyPalette={}}d0.textBuffer=cS;d0.isLocked=true;d0.isGraphics=false;for q=1,S.height do cS[q]={(' '):rep(S.width),('0'):rep(S.width),('f'):rep(S.width)}cS.dirtyLines[q]=true end;for v=0,15 do cS.palette[v]={term.nativePaletteColor(2^v)}cS.dirtyPalette[v]=true end;d0.processList[#d0.processList+1]=d0.frontmostProcess;d0.frontmostProcess=process;local df=setmetatable({},{__name=\"Terminal\"})local dg=terminal.redraw;local expect=expect;d0.screenHandle=df;function df.close()if not df then error(\"terminal is already closed\",2)end;df=nil;d0.isLocked=false;d0.frontmostProcess=table.remove(d0.processList)d0.screenHandle=nil;dg(d0,true)end;function df.write(d9)if not df then error(\"terminal is already closed\",2)end;d9=tostring(d9)expect(1,d9,\"string\")if cS.cursor.y<1 or cS.cursor.y>S.height then return elseif cS.cursor.x>S.width or cS.cursor.x+#d9<1 then cS.cursor.x=cS.cursor.x+#d9;return elseif cS.cursor.x<1 then d9=d9:sub(-cS.cursor.x+2)cS.cursor.x=1 end;local dh=#d9;if cS.cursor.x+#d9>S.width then d9=d9:sub(1,S.width-cS.cursor.x+1)end;cS[cS.cursor.y][1]=cS[cS.cursor.y][1]:sub(1,cS.cursor.x-1)..d9 ..cS[cS.cursor.y][1]:sub(cS.cursor.x+#d9)cS[cS.cursor.y][2]=cS[cS.cursor.y][2]:sub(1,cS.cursor.x-1)..cS.colors.fg:rep(#d9)..cS[cS.cursor.y][2]:sub(cS.cursor.x+#d9)cS[cS.cursor.y][3]=cS[cS.cursor.y][3]:sub(1,cS.cursor.x-1)..cS.colors.bg:rep(#d9)..cS[cS.cursor.y][3]:sub(cS.cursor.x+#d9)cS.cursor.x=cS.cursor.x+dh;cS.dirtyLines[cS.cursor.y]=true end;function df.blit(d9,di,dj)if not df then error(\"terminal is already closed\",2)end;d9=tostring(d9)expect(1,d9,\"string\")expect(2,di,\"string\")expect(3,dj,\"string\")if#d9~=#di or#di~=#dj then error(\"Arguments must be the same length\",2)end;if cS.cursor.y<1 or cS.cursor.y>S.height then return elseif cS.cursor.x>S.width or cS.cursor.x<1-#d9 then cS.cursor.x=cS.cursor.x+#d9;dg(d0)return elseif cS.cursor.x<1 then d9,di,dj=d9:sub(-cS.cursor.x+2),di:sub(-cS.cursor.x+2),dj:sub(-cS.cursor.x+2)cS.cursor.x=1 end;local dh=#d9;if cS.cursor.x+#d9>S.width then d9,di,dj=d9:sub(1,S.width-cS.cursor.x+1),di:sub(1,S.width-cS.cursor.x+1),dj:sub(1,S.width-cS.cursor.x+1)end;cS[cS.cursor.y][1]=cS[cS.cursor.y][1]:sub(1,cS.cursor.x-1)..d9 ..cS[cS.cursor.y][1]:sub(cS.cursor.x+#d9)cS[cS.cursor.y][2]=cS[cS.cursor.y][2]:sub(1,cS.cursor.x-1)..di..cS[cS.cursor.y][2]:sub(cS.cursor.x+#di)cS[cS.cursor.y][3]=cS[cS.cursor.y][3]:sub(1,cS.cursor.x-1)..dj..cS[cS.cursor.y][3]:sub(cS.cursor.x+#dj)cS.cursor.x=cS.cursor.x+dh;cS.dirtyLines[cS.cursor.y]=true end;function df.clear()if not df then error(\"terminal is already closed\",2)end;for q=1,S.height do cS[q]={(' '):rep(S.width),cS.colors.fg:rep(S.width),cS.colors.bg:rep(S.width)}cS.dirtyLines[q]=true end end;function df.clearLine()if not df then error(\"terminal is already closed\",2)end;if cS.cursor.y>=1 and cS.cursor.y<=S.height then cS[cS.cursor.y]={(' '):rep(S.width),cS.colors.fg:rep(S.width),cS.colors.bg:rep(S.width)}cS.dirtyLines[cS.cursor.y]=true end end;function df.getCursorPos()if not df then error(\"terminal is already closed\",2)end;return cS.cursor.x,cS.cursor.y end;function df.setCursorPos(dk,dl)if not df then error(\"terminal is already closed\",2)end;expect(1,dk,\"number\")expect(2,dl,\"number\")if dk==cS.cursor.x and dl==cS.cursor.y then return end;cS.cursor.x,cS.cursor.y=math.floor(dk),math.floor(dl)end;function df.getCursorBlink()if not df then error(\"terminal is already closed\",2)end;return cS.cursorBlink end;function df.setCursorBlink(ab)if not df then error(\"terminal is already closed\",2)end;expect(1,ab,\"boolean\")cS.cursorBlink=ab end;function df.isColor()if not df then error(\"terminal is already closed\",2)end;return true end;function df.getSize()if not df then error(\"terminal is already closed\",2)end;return S.width,S.height end;function df.scroll(dm)if not df then error(\"terminal is already closed\",2)end;expect(1,dm,\"number\")if math.abs(dm)>=S.width then for q=1,S.height do cS[q]={(' '):rep(S.width),cS.colors.fg:rep(S.width),cS.colors.bg:rep(S.width)}end elseif dm>0 then for v=dm+1,S.height do cS[v-dm]=cS[v]end;for v=S.height-dm+1,S.height do cS[v]={(' '):rep(S.width),cS.colors.fg:rep(S.width),cS.colors.bg:rep(S.width)}end elseif dm<0 then for v=1,S.height+dm do cS[v-dm]=cS[v]end;for v=1,-dm do cS[v]={(' '):rep(S.width),cS.colors.fg:rep(S.width),cS.colors.bg:rep(S.width)}end else return end;for v=1,S.height do cS.dirtyLines[v]=true end end;function df.getTextColor()if not df then error(\"terminal is already closed\",2)end;return tonumber(cS.colors.fg,16)end;function df.setTextColor(dn)if not df then error(\"terminal is already closed\",2)end;expect(1,dn,\"number\")expect.range(dn,0,15)cS.colors.fg=(\"%x\"):format(dn)end;function df.getBackgroundColor()if not df then error(\"terminal is already closed\",2)end;return tonumber(cS.colors.bg,16)end;function df.setBackgroundColor(dn)if not df then error(\"terminal is already closed\",2)end;expect(1,dn,\"number\")expect.range(dn,0,15)cS.colors.bg=(\"%x\"):format(dn)end;function df.getPaletteColor(dn)if not df then error(\"terminal is already closed\",2)end;expect(1,dn,\"number\")expect.range(dn,0,15)return table.unpack(cS.palette[math.floor(dn)])end;function df.setPaletteColor(dn,bo,dp,ab)if not df then error(\"terminal is already closed\",2)end;expect(1,dn,\"number\")expect(2,bo,\"number\")if dp==nil and ab==nil then bo,dp,ab=bit32.band(bit32.rshift(bo,16),0xFF)/255,bit32.band(bit32.rshift(bo,8),0xFF)/255,bit32.band(bo,0xFF)/255 end;expect(3,dp,\"number\")expect(4,ab,\"number\")expect.range(dn,0,15)if bo<0 or bo>1 then error(\"bad argument #2 (value out of range)\",2)end;if dp<0 or dp>1 then error(\"bad argument #3 (value out of range)\",2)end;if ab<0 or ab>1 then error(\"bad argument #4 (value out of range)\",2)end;cS.palette[math.floor(dn)]={bo,dp,ab}cS.dirtyPalette[math.floor(dn)]=true end;function df.getLine(q)if not df then error(\"terminal is already closed\",2)end;expect(1,q,\"number\")local N=cS[q]return N and table.unpack(N,1,3)end;for z,i in pairs(df)do setfenv(i,process.env)debug.protect(i)end;df.isColour=df.isColor;df.getTextColour=df.getTextColor;df.setTextColour=df.setTextColor;df.getBackgroundColour=df.getBackgroundColor;df.setBackgroundColour=df.setBackgroundColor;df.getPaletteColour=df.getPaletteColor;df.setPaletteColour=df.setPaletteColor;process.dependents[#process.dependents+1]={gc=function()if df then return df.close()end end}dg(d0,true)return df end;function syscalls.openterm(process,aq)if not process.stdout or not process.stdout.isTTY then return nil,\"No valid TTY attached\"end;if process~=process.stdout.frontmostProcess then syscalls.kill(KERNEL,nil,process.id,22)if process.paused then return kSyscallYield,\"openterm\"end end;return terminal.openterm(process.stdout,process)end;function terminal.opengfx(d0,process)if not term.drawPixels then return nil,\"Graphics mode not supported\"end;if d0.isLocked then if d0.isGraphics and d0.frontmostProcess==process then return d0.screenHandle end;return nil,\"Terminal already in use\"end;local S=d0.size;local cS={palette={},dirtyRects={},dirtyPalette={},frozen=false}d0.graphicsBuffer=cS;d0.isLocked=true;d0.isGraphics=true;for q=1,S.height*9 do cS[q]=('\\15'):rep(S.width*6)end;for v=0,15 do cS.palette[v]={term.nativePaletteColor(2^v)}cS.dirtyPalette[v]=true end;for v=16,255 do cS.palette[v]={0,0,0}cS.dirtyPalette[v]=true end;d0.processList[#d0.processList+1]=d0.frontmostProcess;d0.frontmostProcess=process;local df=setmetatable({},{__name=\"GFXTerminal\"})local dg=terminal.redraw;local expect=expect;d0.screenHandle=df;function df.close()if not df then error(\"terminal is already closed\",2)end;df=nil;d0.isLocked=false;d0.frontmostProcess=table.remove(d0.processList)d0.screenHandle=nil;dg(d0,true)end;function df.getSize()return S.width*6,S.height*9 end;function df.clear()if not df then error(\"terminal is already closed\",2)end;for q=1,S.height*9 do cS[q]=('\\15'):rep(S.width*6)end;dg(d0,true)end;function df.getPixel(p,q)if not df then error(\"terminal is already closed\",2)end;expect(1,p,\"number\")expect(2,q,\"number\")expect.range(p,0,S.width*6-1)expect.range(q,0,S.height*9-1)p,q=math.floor(p),math.floor(q)return cS[q+1]:byte(p+1)end;function df.setPixel(p,q,dn)if not df then error(\"terminal is already closed\",2)end;expect(1,p,\"number\")expect(2,q,\"number\")expect(3,dn,\"number\")expect.range(p,0,S.width*6-1)expect.range(q,0,S.height*9-1)expect.range(dn,0,255)p,q=math.floor(p),math.floor(q)cS[q+1]=cS[q+1]:sub(1,p)..string.char(dn)..cS[q+1]:sub(p+2)cS.dirtyRects[#cS.dirtyRects+1]={x=p,y=q,color=dn}end;function df.getPixels(p,q,t,cX,dq)if not df then error(\"terminal is already closed\",2)end;expect(1,p,\"number\")expect(2,q,\"number\")expect(3,t,\"number\")expect(4,cX,\"number\")expect(5,dq,\"boolean\",\"nil\")expect.range(t,0)expect.range(cX,0)p,q=math.floor(p),math.floor(q)local y={}for dr=1,cX do if dq then y[dr]=cS[q+dr]:sub(p+1,p+t)else y[dr]={cS[q+dr]:sub(p+1,p+t):byte(1,-1)}end end;return y end;function df.drawPixels(p,q,bh,t,cX)if not df then error(\"terminal is already closed\",2)end;expect(1,p,\"number\")expect(2,q,\"number\")expect(3,bh,\"table\",\"number\")local ds=type(bh)==\"number\"expect(4,t,\"number\",not ds and\"nil\"or nil)expect(5,cX,\"number\",not ds and\"nil\"or nil)expect.range(p,0,S.width*6-1)expect.range(q,0,S.height*9-1)if t then expect.range(t,0)end;if cX then expect.range(cX,0)end;if ds then expect.range(bh,0,255)end;if t==0 or cX==0 then return end;p,q=math.floor(p),math.floor(q)if t and p+t>=S.width*6 then t=S.width*6-p end;cX=cX or#bh;local dt={x=p,y=q,width=t,height=cX}for dr=1,cX do if q+dr>S.height*9 then break end;if ds then local bn=string.char(bh):rep(t)cS[q+dr]=cS[q+dr]:sub(1,p)..bn..cS[q+dr]:sub(p+t+1)dt[dr]=bn elseif bh[dr]~=nil then if type(bh[dr])~=\"table\"and type(bh[dr])~=\"string\"then error(\"bad argument #3 to 'drawPixels' (invalid row \"..dr..\")\",2)end;local t=t or#bh[dr]if p+t>=S.width*6 then t=S.width*6-p end;local bn;if type(bh[dr])==\"string\"then bn=bh[dr]if#bn<t then bn=bn..('\\15'):rep(t-#bn)elseif#bn>t then bn=bn:sub(1,t)end else bn=\"\"for du=1,t do bn=bn..string.char(bh[dr][du]or cS[q+dr]:byte(p+du))end end;cS[q+dr]=cS[q+dr]:sub(1,p)..bn..cS[q+dr]:sub(p+t+1)dt[dr]=bn end end;cS.dirtyRects[#cS.dirtyRects+1]=dt end;function df.getFrozen()if not df then error(\"terminal is already closed\",2)end;return cS.frozen end;function df.setFrozen(f)if not df then error(\"terminal is already closed\",2)end;expect(1,f,\"boolean\")cS.frozen=f end;function df.getPaletteColor(dn)if not df then error(\"terminal is already closed\",2)end;expect(1,dn,\"number\")expect.range(dn,0,255)return table.unpack(cS.palette[dn])end;function df.setPaletteColor(dn,bo,dp,ab)if not df then error(\"terminal is already closed\",2)end;expect(1,dn,\"number\")expect(2,bo,\"number\")if dp==nil and ab==nil then bo,dp,ab=bit32.band(bit32.rshift(bo,16),0xFF)/255,bit32.band(bit32.rshift(bo,8),0xFF)/255,bit32.band(bo,0xFF)/255 end;expect(3,dp,\"number\")expect(4,ab,\"number\")expect.range(bo,0,1)expect.range(dp,0,1)expect.range(ab,0,1)expect.range(dn,0,255)cS.palette[dn]={bo,dp,ab}cS.dirtyPalette[dn]=true end;for z,i in pairs(df)do setfenv(i,process.env)debug.protect(i)end;df.getPaletteColour=df.getPaletteColor;df.setPaletteColour=df.setPaletteColor;process.dependents[#process.dependents+1]={gc=function()if df then return df.close()end end}dg(d0,true)return df end;function syscalls.opengfx(process,aq)if not process.stdout or not process.stdout.isTTY then return nil,\"No valid TTY attached\"end;if process~=process.stdout.frontmostProcess then syscalls.kill(KERNEL,nil,process.id,22)if process.paused then return kSyscallYield,\"openterm\"end end;return terminal.opengfx(process.stdout,process)end;function syscalls.mktty(process,aq,t,cX)expect(1,t,\"number\")expect(2,cX,\"number\")expect.range(t,1)expect.range(cX,1)local d0=terminal.makeTTY(term,t,cX)d0.id=math.random(0,0x7FFFFFFF)d0.process=process;local a5=setmetatable({},{__index=d0,__metatable={}})terminal.userTTYs[a5]=d0;process.dependents[#process.dependents+1]={gc=function()terminal.userTTYs[a5]=nil end}return a5 end;function syscalls.stdin(process,aq,dv)expect(1,dv,\"number\",\"table\",\"string\",\"nil\")if process.stdin and process.stdin.isTTY and process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)process.stdin.preBuffer=\"\"end;if type(dv)==\"number\"then process.stdin=TTY[dv]elseif type(dv)==\"string\"then local dw=hardware.get(dv)if not dw then error(\"bad argument #1 (no such device)\",2)end;if not dw.internalState.tty then error(\"bad argument #1 (no TTY available on device)\",2)end;dv=dw.internalState.tty;if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)dv.processList[#dv.processList+1]=dv.frontmostProcess;dv.frontmostProcess=process end;process.stdin=dv elseif dv==nil then process.stdin=nil else if dv.isTTY then dv=terminal.userTTYs[dv]if not dv then error(\"bad argument #1 (invalid TTY)\",2)end;if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)dv.processList[#dv.processList+1]=dv.frontmostProcess;dv.frontmostProcess=process;dv.preBuffer=\"\"end else expect.field(dv,\"read\",\"function\")local dx=dv.read;dv={buffer=\"\",read=function(...)local bf,u=userModeCallback(process,dx,...)if bf then return u else error(u,2)end end}end;process.stdin=dv end end;function syscalls.stdout(process,aq,dv)expect(1,dv,\"number\",\"table\",\"string\",\"nil\")if process.stdout and process.stdout.isTTY and process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)if discord and process.stdout==currentTTY then discord(\"Phoenix\",\"Executing \"..process.stdout.frontmostProcess.name)end end;if type(dv)==\"number\"then process.stdout=TTY[dv]elseif type(dv)==\"string\"then local dw=hardware.get(dv)if not dw then error(\"bad argument #1 (no such device)\",2)end;if not dw.internalState.tty then error(\"bad argument #1 (no TTY available on device)\",2)end;dv=dw.internalState.tty;if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)dv.processList[#dv.processList+1]=dv.frontmostProcess;dv.frontmostProcess=process;if discord and process.stdout==currentTTY then discord(\"Phoenix\",\"Executing \"..process.name)end end;process.stdout=dv elseif dv==nil then process.stdout=nil else if dv.isTTY then dv=terminal.userTTYs[dv]if not dv then error(\"bad argument #1 (invalid TTY)\",2)end;if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)dv.processList[#dv.processList+1]=dv.frontmostProcess;dv.frontmostProcess=process;if discord and process.stdout==currentTTY then discord(\"Phoenix\",\"Executing \"..process.name)end end else expect.field(dv,\"write\",\"function\")local dd=dv.write;dv={write=function(...)local bf,u=userModeCallback(process,dd,...)if bf then return u else error(u,2)end end}end;process.stdout=dv end end;function syscalls.stderr(process,aq,dv)expect(1,dv,\"number\",\"table\",\"string\",\"nil\")if process.stderr and process.stderr.isTTY and process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)end;if type(dv)==\"number\"then process.stderr=TTY[dv]elseif type(dv)==\"string\"then local dw=hardware.get(dv)if not dw then error(\"bad argument #1 (no such device)\",2)end;if not dw.internalState.tty then error(\"bad argument #1 (no TTY available on device)\",2)end;dv=dw.internalState.tty;if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)dv.processList[#dv.processList+1]=dv.frontmostProcess;dv.frontmostProcess=process end;process.stderr=dv elseif dv==nil then process.stderr=nil else if dv.isTTY then dv=terminal.userTTYs[dv]if not dv then error(\"bad argument #1 (invalid TTY)\",2)end;if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)dv.processList[#dv.processList+1]=dv.frontmostProcess;dv.frontmostProcess=process end else expect.field(dv,\"write\",\"function\")local dd=dv.write;dv={write=function(...)local bf,u=userModeCallback(process,dd,...)if bf then return u else error(u,2)end end}end;process.stderr=dv end end;function syscalls.istty(process,aq)return process.stdin and process.stdin.isTTY,process.stdout and process.stdout.isTTY end;function syscalls.termsize(process,aq)if not process.stdout or not process.stdout.isTTY then return nil,nil end;return process.stdout.size.width,process.stdout.size.height end;syslogs={default={stream={},tty=KERNEL.stdout,tty_level=args.loglevel,colorize=true}}local dy={[0]=\"Debug\",\"Info\",\"Notice\",\"Warning\",\"Error\",\"Critical\",\"Panic\"}local dz={}for v=0,#dy do dz[dy[v]:lower()]=v end;local dA={[0]='\\27[90m','\\27[97m','\\27[36m','\\27[93m','\\27[31m','\\27[95m','\\27[96m'}local function dB(y,am,v,aa)if v>=aa then return tostring(y[v])else return tostring(y[v])..am..dB(y,am,v+1,aa)end end;function syscalls.syslog(process,aq,bC,...)local args=table.pack(...)if type(bC)==\"table\"then expect.field(bC,\"name\",\"string\",\"nil\")expect.field(bC,\"category\",\"string\",\"nil\")expect.field(bC,\"level\",\"number\",\"string\",\"nil\")expect.field(bC,\"time\",\"number\",\"nil\")expect.field(bC,\"process\",\"number\",\"nil\")expect.field(bC,\"thread\",\"number\",\"nil\")expect.field(bC,\"module\",\"string\",\"nil\")expect.field(bC,\"traceback\",\"boolean\",\"nil\")if type(bC.level)==\"string\"then bC.level=dz[bC.level:lower()]if not bC.level then error(\"bad field 'level' (invalid name)\",0)end elseif bC.level and(bC.level<0 or bC.level>#dy)then error(\"bad field 'level' (level out of range)\",0)end;bC.name=bC.name or\"default\"bC.process=bC.process or process.id;bC.thread=bC.thread or aq and aq.id;bC.level=bC.level or 1;bC.time=bC.time or os.epoch\"utc\"else local r=args.n;table.insert(args,1,bC)args.n=r+1;bC={process=process.id,thread=aq and aq.id,level=1,name=\"default\",time=os.epoch\"utc\"}end;local dC=syslogs[bC.name]if dC==nil then error(\"No such log named \"..bC.name,0)end;local ae;for v=1,args.n do ae=(v==1 and\"\"or ae..\" \")..serialize(args[v])end;if dC.file then dC.file.write((\"[%s]%s %s[%d%s]%s [%s]: %s\\n\"):format(os.date(\"%b %d %X\",bC.time/1000),bC.category and\" <\"..bC.category..\">\"or\"\",processes[bC.process]and processes[bC.process].name or\"(unknown)\",bC.process,bC.thread and\":\"..bC.thread or\"\",bC.module and\" (\"..bC.module..\")\"or\"\",dy[bC.level],dB(args,\" \",1,args.n)))dC.file.flush()end;if dC.stream then bC.message=ae;for z,i in pairs(dC.stream)do local bf=true;if i.filter then local m,dD,aD=\"\"local v=1;local dE,dF=false,false;while v<#i.filter do if dD==nil then m,v=i.filter:match(\"(%a+)%s*()\",v)if bC[m]==nil then bf=false;break end;dD=\"\"elseif aD==nil then local b5=i.filter:sub(v,v+1)if b5==\"==\"or b5==\"!=\"or b5==\"=%\"or b5==\"!%\"or b5==\"<=\"or b5==\">=\"then dD=b5 elseif b5==\"~=\"then dD=\"!=\"elseif b5==\"~%\"then dD=\"!%\"elseif i.filter:sub(v,v)=='<'or i.filter:sub(v,v)=='>'then dD=i.filter:sub(v,v)else bf=false;break end;aD=\"\"else local a9=i.filter:sub(v,v)if dE then if a9==dE and not dF then dE,dF=false,false else aD=aD..a9;if not dF and a9=='\\\\'then dF=true else dF=false end end elseif a9=='\"'or a9==\"'\"then dE=a9 elseif a9=='|'or a9==';'then if dD==\"==\"and bC[m]==aD or dD==\"!=\"and bC[m]~=aD or dD==\"=%\"and bC[m]:match(aD)or dD==\"!%\"and not bC[m]:match(aD)or dD==\"<\"and(tonumber(bC[m])or 0)<(tonumber(aD)or 0)or dD==\"<=\"and(tonumber(bC[m])or 0)<=(tonumber(aD)or 0)or dD==\">=\"and(tonumber(bC[m])or 0)>=(tonumber(aD)or 0)or dD==\">\"and(tonumber(bC[m])or 0)>(tonumber(aD)or 0)then if a9=='|'then v=i.filter:match(\"[^;]*;+()\",v)if v==nil then break end;v=v-1 end;m,dD,aD=\"\"dE,dF=false,false else bf=a9=='|'aD=\"\"if not bf then break end end elseif not(a9==' 'and aD==\"\")then aD=aD..a9 end;v=v+1 end end;if dE then bf=false;break end end;if bf then local process=processes[i.pid]if process then process.eventQueue[#process.eventQueue+1]={\"syslog\",deepcopy(bC)}end end end end;if dC.tty and dC.tty_level<=bC.level then if dC.tty.isTTY then local a0=dB(args,\" \",1,args.n)if dC.colorize and bC.traceback then a0=a0:gsub(\"\\t\",\"  \"):gsub(\"([^\\n]+):(%d+):\",\"\\27[96m%1\\27[37m:\\27[95m%2\\27[37m:\"):gsub(\"'([^']+)'\\n\",\"\\27[93m'%1'\\27[37m\\n\")end;terminal.write(dC.tty,(\"%s[%s]%s %s[%d%s]%s [%s]: %s%s\\n\"):format(dC.colorize and dA[bC.level]or\"\",os.date(\"%b %d %X\",bC.time/1000),bC.category and\" <\"..bC.category..\">\"or\"\",processes[bC.process]and processes[bC.process].name or\"(unknown)\",bC.process,bC.thread and\":\"..bC.thread or\"\",bC.module and\" (\"..bC.module..\")\"or\"\",dy[bC.level],a0,dC.colorize and\"\\27[0m\"or\"\"))terminal.redraw(dC.tty)else end end end;function syscalls.mklog(process,aq,m,dG,bb)expect(1,m,\"string\")expect(2,dG,\"boolean\",\"nil\")expect(3,bb,\"string\",\"nil\")if syslogs[m]then return end;syslogs[m]={}if bb then local o;syslogs[m].file,o=filesystem.open(process,bb,\"a\")if syslogs[m].file==nil then syslogs[m]=nil;return error(\"Could not open log file: \"..o,0)end end;if dG then syslogs[m].stream={}end end;function syscalls.rmlog(process,aq,m)expect(1,m,\"string\")if m==\"default\"then error(\"Cannot delete default log\",0)end;if not syslogs[m]then error(\"Log does not exist\",0)end;if syslogs[m].stream then for z,i in pairs(syslogs[m].stream)do processes[i.pid].eventQueue[#processes[i.pid].eventQueue+1]={\"syslog_close\",{id=i.id}}processes[i.pid].dependents[i.id]=nil end end;syslogs[m]=nil end;function syscalls.openlog(process,aq,m,dH)expect(1,m,\"string\")expect(2,dH,\"string\",\"nil\")if not syslogs[m]then error(\"Log does not exist\",0)end;if not syslogs[m].stream then error(\"Log does not have streaming enabled\",0)end;local aA=#process.dependents+1;local cM=process.id;process.dependents[aA]={type=\"log\",name=m,filter=dH,gc=function()for v,i in pairs(syslogs[m].stream)do if i.id==aA and i.pid==cM then syslogs[m].stream[v]=nil end end end}syslogs[m].stream[#syslogs[m].stream+1]={pid=cM,id=aA,filter=dH}return aA end;function syscalls.closelog(process,aq,m)expect(1,m,\"string\",\"number\")if type(m)==\"string\"then if not syslogs[m]then error(\"Log does not exist\",0)end;if not syslogs[m].stream then error(\"Log does not have streaming enabled\",0)end;for v,i in pairs(syslogs[m].stream)do if i.pid==process.id then process.dependents[i.id]=nil;syslogs[m].stream[v]=nil end end else if not process.dependents[m]then error(\"Log connection does not exist\",0)end;local dC=syslogs[process.dependents[m].name].stream;for v,i in pairs(dC)do if i.pid==process.id and i.id==m then process.dependents[i.id]=nil;dC[v]=nil;break end end end end;function syscalls.logtty(process,aq,m,d0,b0)if process.user~=\"root\"then error(\"Permission denied\",0)end;expect(1,m,\"string\")expect(2,d0,\"table\",\"number\",\"nil\")expect(3,b0,\"number\",\"nil\")if not syslogs[m]then error(\"Log does not exist\",0)end;syslogs[m].tty=type(d0)==\"table\"and d0 or TTY[d0]syslogs[m].tty_level=b0;return true end;function syslog.log(bC,...)return pcall(syscalls.syslog,KERNEL,nil,bC,...)end;function syslog.debug(...)return pcall(syscalls.syslog,KERNEL,nil,{level=\"debug\",process=0},...)end;local dI=panic;function panic(ae)xpcall(function()syslog.log({level=\"panic\"},\"Kernel panic:\",ae)if debug then local ai=debug.traceback(nil,2)syslog.log({level=\"panic\",traceback=true},ai)end;syslog.log({level=\"panic\"},\"We are hanging here...\")term.setCursorBlink(false)mainThread=nil;while true do coroutine.yield()end end,function(A)dI(ae..\"; and an error occurred while logging the error: \"..A)end)end;xpcall(function()local o;syslogs.default.file,o=filesystem.open(KERNEL,\"/var/log/default.log\",\"a\")shutdownHooks[#shutdownHooks+1]=function()if syslogs.default.file then syslogs.default.file.close()end end;syslog.log(\"Starting Phoenix version\",PHOENIX_VERSION,PHOENIX_BUILD)syslog.log(\"Initialized system logger\")syslog.log(\"System started at \"..systemStartTime..\" on computer \"..os.computerID()..(os.computerLabel()and\"('\"..os.computerLabel()..\"')\"or\"\"))syslog.log(\"Computer host is \".._HOST)if syslogs.default.file==nil then syslog.log({level=\"notice\"},\"An error occurred while opening the log file at /var/log/default.log:\",o,\". System logs will not be saved to disk.\")end end,panic)local function dJ(bn)return string.match(bn,'^()%s*$')and''or string.match(bn,'^%s*(.*%S)')end;local expect,do_syscall=expect,do_syscall;local function dK(bh)local a7=1;local function dx(a9)if a7>#bh then return nil end;a9=a9 or 1;local bn=bh:sub(a7,a7+a9-1)a7=a7+a9;return bn end;if dx(8)~=\"!<arch>\\n\"then error(\"Not an ar archive\",2)end;local a5={}local dL=nil;local dM={}while true do local bh={}local dN=dx()while dN==\"\\n\"do dN=dx()end;if dN==nil then break end;local m=dx(15)if m==nil then break end;m=dN..m;if string.find(m,\"/\")and string.find(m,\"/\")>1 then m=string.sub(m,1,string.find(m,\"/\")-1)else m=dJ(m)end;bh.timestamp=tonumber(dJ(dx(12)))bh.owner=tonumber(dJ(dx(6)))bh.group=tonumber(dJ(dx(6)))bh.mode=tonumber(dJ(dx(8)),8)local S=tonumber(dJ(dx(10)))if dx(2)~=\"`\\n\"then error(\"Invalid header for file \"..m,2)end;if string.match(m,\"^#1/%d+$\")then m=dx(tonumber(string.match(m,\"#1/(%d+)\")))elseif string.match(m,\"^/%d+$\")then if dL then local r=tonumber(string.match(m,\"/(%d+)\"))m=dL:match(\"[^/]*\",r+1)else table.insert(dM,m)end end;bh.name=m;bh.data=dx(S)if m==\"//\"then dL=bh.data elseif m~=\"/\"and m~=\"/SYM64/\"then table.insert(a5,bh)end end;if dL then for h,i in pairs(dM)do local r=tonumber(string.match(i,\"/(%d+)\"))for N,af in pairs(a5)do if af.name==i then af.name=dL:match(\"[^/]*\",r+1)break end end end end;local dO={}for z,i in ipairs(a5)do dO[i.name]=i end;return dO end;function createRequire(process,cz)local dP,dQ={},{}cz.package={}local dR=processes[process.parent]and processes[process.parent].env;if dR then cz.package.path=dR.package and dR.package.path;cz.package.libpath=dR.package and dR.package.libpath end;cz.package.path=cz.package.path or\"/lib/?.lua;/lib/?/init.lua;/usr/lib/?.lua;/usr/lib/?/init.lua;./?.lua;./?/init.lua\"if type(process.vars.PACKAGE_PATH)==\"string\"then cz.package.path=process.vars.PACKAGE_PATH..';'..cz.package.path end;cz.package.libpath=cz.package.libpath or\"/lib/lib?.a;/usr/lib/lib?.a\"if type(process.vars.PACKAGE_LIBPATH)==\"string\"then cz.package.libpath=process.vars.PACKAGE_LIBPATH..';'..cz.package.libpath end;cz.package.config=\"/\\n;\\n?\\n!\\n-\"cz.package.loaded=dP;cz.package.preload=dQ;cz.package.forceload=false;for h,i in pairs(cz)do if type(i)==\"table\"then dP[h]=i end end;local dS=setmetatable({},{__newindex=function()end,__metatable=false})local dT={}local function dU(m,bb)local a,o=do_syscall(\"open\",bb,\"rb\")if not a then error(bb..\": \"..o,3)end;local bh=a.readAll()a.close()local g,o=load(bh,\"@\"..bb,nil,_ENV)if not g then error(bb..\": \"..o,3)end;local dV=bb:match(\"^(.*)/[^/]*$\")or\"/\"dT[#dT+1]=function(dW)local bb,o=package.searchpath(dW,dV..\"/?.lua;\"..dV..\"/?/init.lua\")if not bb then return nil,o end;return dU,bb end;local bf,u=pcall(g,m)dT[#dT]=nil;if bf then return u else error(bb..\": \"..u,3)end end;local function dX(m,bb)local dY;if bb:find\"%z\"then bb,dY=bb:match\"^([^%z]*)%z(.*)$\"elseif m:find\"%-\"then dY=m:match(\"^([^%-]*)%-(.*)$\")else dY=\"init\"end;local a,o=do_syscall(\"open\",bb,\"rb\")if not a then error(bb..\": \"..o,3)end;local bh=a.readAll()a.close()local dV=dK(bh)local function dZ(m)local E=m..\".lua\"if not dV[E]then error(bb..\":\"..E..\": File not found\",0)end;local bh=dV[E].data;local g,o=load(bh,\"@\"..bb..\":\"..E,nil,_ENV)if not g then error(bb..\":\"..E..\": \"..o,3)end;local bf,u=pcall(g,m)if bf then return u else error(bb..\":\"..E..\": \"..u)end end;dT[#dT+1]=function(dW)return dZ,dW end;local u=dZ(dY)dT[#dT]=nil;return u end;dT[1]=function(m)local dV=do_syscall(\"getname\"):match(\"^(.*)/[^/]*$\")or\"/\"local bb,o=package.searchpath(m,dV..\"/?.lua;\"..dV..\"/?/init.lua\")if not bb then return nil,o end;return dU,bb end;function cz.package.searchpath(m,bb,am,d_)expect(1,m,\"string\")expect(2,bb,\"string\")expect(3,am,\"string\",\"nil\")expect(4,d_,\"string\",\"nil\")am=(am or\".\"):gsub(\"([%^%$%(%)%%%.%[%]%*%+%-%?])\",\"%%%1\")d_=(d_ or\"/\"):gsub(\"([%^%$%(%)%%%.%[%]%*%+%-%?])\",\"%%%1\")local e0=\"\"for E in bb:gmatch\"[^;]+\"do local e1=E:gsub(\"%?\",m:gsub(am,d_),nil)local a,o=do_syscall(\"open\",e1,\"r\")if a then a.close()return e1 else e0=e0 ..\"\\t\"..e1 ..\": \"..o..\"\\n\"end end;return nil,e0 end;cz.package.searchers={function(m)local E=dQ[m]if E then return E else return nil,\"\\tpackage.preload['\"..m..\"']: No such field\\n\"end end,function(m)local bb,o=package.searchpath(m,package.path)if not bb then return nil,o end;return dU,bb,bb end,function(m)local bb,o=package.searchpath(m:match(\"^[^%-]*\"),package.libpath)if not bb then return nil,o end;local r=m:match(\"%-(.+)$\")if r then return dX,bb,bb..\":\"..r else return dX,bb,bb..\":init\"end end,function(m)if not m:find\"%.\"then return nil end;local bb,o=package.searchpath(m:match(\"^[^%.]*\"),package.libpath)if not bb then return nil,o end;local r=m:match(\"^[^%.]*%.(.*)$\")return dX,bb..\"\\0\"..r,bb..\":\"..r end,function(m)if#dT>0 then return dT[#dT](m)end;return nil,\"no local loaders found\"end}setfenv(dU,cz)debug.protect(dU)setfenv(dX,cz)debug.protect(dX)setfenv(dT[1],cz)debug.protect(dT[1])for z,i in pairs(cz.package.searchers)do setfenv(i,cz)debug.protect(i)end;function cz.require(m)expect(1,m,\"string\")local o=\"module '\"..m..\"' not found:\\n\"local e2,e3,e4;for z,i in ipairs(package.searchers)do e2,e3,e4=i(m)if e2 then break end;o=o..(e3 or\"\")end;if not e2 then error(o,2)end;if e4 then if dP[e4]then if dP[e4]==dS then error(\"loop detected loading '\"..m..\"'\",3)elseif not package.forceload then return dP[e4]end end;dP[e4]=dS else if dP[m]then if dP[m]==dS then error(\"loop detected loading '\"..m..\"'\",3)elseif not package.forceload then return dP[m]end end end;dP[m]=dS;local bf,u=pcall(e2,m,e3)if bf then if u~=nil then dP[m]=u elseif dP[m]==dS then dP[m]=true end;if e4 then if u~=nil then dP[e4]=u elseif dP[e4]==dS then dP[e4]=true end end;return dP[m]else dP[m]=nil;if e4 then dP[e4]=nil end;error(o..\"\\t\"..u..\"\\n\",2)end end;return cz end;timerMap={}alarmMap={}local e5={}function syscalls.kill(process,aq,cM,e6)expect(1,cM,\"number\")expect(2,e6,\"number\")local e7=processes[cM]if not e7 then error(\"No such process\",2)end;if process.user~=\"root\"and process.user~=e7.user then error(\"Permission denied\",2)end;if e6==9 then reap_process(e7)if processes[e7.parent]then syscalls.queueEvent(processes[e7.parent],nil,\"process_complete\",{id=cM,result=9})end;processes[cM]=nil elseif e7.signalHandlers[e6]then userModeCallback(e7,e7.signalHandlers[e6],e6)else syscalls.queueEvent(e7,nil,\"signal\",{signal=e6})end end;function killProcess(cM,e6)expect(1,cM,\"number\")expect(2,e6,\"number\")local e7=processes[cM]if not e7 then return end;if e6==9 then reap_process(e7)if processes[e7.parent]then syscalls.queueEvent(processes[e7.parent],nil,\"process_complete\",{id=cM,result=9})end;processes[cM]=nil elseif e7.signalHandlers[e6]then syscalls.newthread(e7,nil,e7.signalHandlers[e6],e6)else syscalls.queueEvent(e7,nil,\"signal\",{signal=e6})end end;function syscalls.signal(process,aq,e6,e8)expect(1,e6,\"number\")expect(2,e8,\"function\",\"nil\")process.signalHandlers[e6]=e8 end;function syscalls.queueEvent(process,aq,m,av)expect(1,m,\"string\")expect(2,av,\"table\")process.eventQueue[#process.eventQueue+1]={m,av}end;function syscalls.sendEvent(process,aq,cM,m,av)expect(1,cM,\"number\")expect(2,m,\"string\")local e7=processes[cM]if not e7 then return false end;e7.eventQueue[#e7.eventQueue+1]={\"remote_event\",{type=m,sender=process.id,data=av}}return true end;function syscalls.register(process,aq,m)expect(1,m,\"string\")if e5[m]then return false end;e5[m]=process.id;process.dependents[#process.dependents+1]={gc=function()e5[m]=nil end}return true end;function syscalls.lookup(process,aq,m)expect(1,m,\"string\")return e5[m]end;function syscalls.timer(process,aq,e9)expect(1,e9,\"number\")local ea=os.startTimer(e9)timerMap[ea]=process;return bit32.band(ea,0x7FFFFFFF)end;function syscalls.alarm(process,aq,e9)expect(1,e9,\"number\")local ea=os.setAlarm(e9)alarmMap[ea]=process;return bit32.bor(ea,0x80000000)end;function syscalls.cancel(process,aq,ea)expect(1,ea,\"number\")if bit32.btest(ea,0x80000000)then ea=bit32.band(ea,0x7FFFFFFF)if alarmMap[ea]~=process then error(\"No such alarm\")end;os.cancelAlarm(ea)alarmMap[ea]=nil else if timerMap[ea]~=process then error(\"No such timer\")end;os.cancelTimer(ea)timerMap[ea]=nil end end;eventHooks.terminate=eventHooks.terminate or{}eventHooks.terminate[#eventHooks.terminate+1]=function()if currentTTY.frontmostProcess then syscalls.kill(KERNEL,nil,currentTTY.frontmostProcess.id,2)terminal.write(currentTTY,\"^T\")end end;eventParameterMap={alarm={\"id\"},char={\"character\"},key={\"keycode\",\"isRepeat\"},key_up={\"keycode\"},mouse_click={\"button\",\"x\",\"y\"},mouse_drag={\"button\",\"x\",\"y\"},mouse_up={\"button\",\"x\",\"y\"},mouse_scroll={\"direction\",\"x\",\"y\"},paste={\"text\"},redstone={},term_resize={},timer={\"id\"},turtle_inventory={}}do local eb=0;for z,i in pairs(keys)do if type(i)==\"number\"then eb=math.max(eb,i)end end;local bp;local ec,ed=pcall(string.dump,function()end)if ec then local ee=(function(p)if p<8 then return p end;local K=0;while p>=128 do p,K=bit32.rshift(p+0xf,4),K+4 end;while p>=16 do p,K=bit32.rshift(p+1,1),K+1 end;return bit32.bor((K+1)*8,p-8)end)(eb)syslog.debug(\"Key table sizes:\",eb,ee)if _VERSION==\"Lua 5.1\"then bp=ed:sub(1,12)..(\"I\"..ed:byte(9)..\"IIBBBBIIIIIIII\"):pack(0,0,0,0,0,0,1,2,ee*0x800000+10,0x0100001E,0,0,0,0,0)elseif _VERSION==\"Lua 5.2\"then bp=ed:sub(1,18)..(\"IIBBBIIIIIIIIII\"):pack(0,0,0,0,1,2,ee*0x800000+11,0x0100001F,0,0,0,0,0,0,0)elseif _VERSION==\"Lua 5.3\"then bp=ed:sub(1,17+(\"jn\"):packsize())..(\"BBIIBBBIIIIIIIII\"):pack(0,0,0,0,0,0,1,2,ee*0x800000+11,0x01000026,0,0,0,0,0,0)elseif _VERSION==\"Lua 5.4\"then bp=ed:sub(1,15+(\"jn\"):packsize())..(\"BBBBBBBBIIIBBBBBBB\"):pack(0,0x80,0x80,0x80,0,0,1,0x83,0x00000013,eb*0x80+82,0x00008048,0x80,0x80,0x80,0x80,0x80,0x80,0x80)end;if bp then local g,o=load(bp,nil,\"b\")if g then keymap=g()else syslog.debug(\"Could not load key table code:\",o)end end end;if not keymap then keymap=load(\"return {\"..(\"nil,\"):rep(eb)..\"}\")()end;for v=0x61,0x7A do keymap[keys[string.char(v)]]=v end;for v=0x81,0x99 do if keys[\"f\"..bit32.band(v,31)]then keymap[keys[\"f\"..bit32.band(v,31)]]=v end end;for v=0xA0,0xA9 do keymap[keys[\"numPad\"..bit32.band(v,15)]]=v end;keymap[keys.backspace]=0x08;keymap[keys.tab]=0x09;keymap[keys.enter or keys[\"return\"]]=0x0A;keymap[keys.space]=0x20;keymap[keys.apostrophe]=0x27;keymap[keys.comma]=0x2C;keymap[keys.minus]=0x2D;keymap[keys.period]=0x2E;keymap[keys.slash]=0x2F;keymap[keys.zero]=0x30;keymap[keys.one]=0x31;keymap[keys.two]=0x32;keymap[keys.three]=0x33;keymap[keys.four]=0x34;keymap[keys.five]=0x35;keymap[keys.six]=0x36;keymap[keys.seven]=0x37;keymap[keys.eight]=0x38;keymap[keys.nine]=0x39;keymap[keys.semicolon or keys.semiColon]=0x3B;keymap[keys.equals]=0x3D;keymap[keys.leftBracket]=0x5B;keymap[keys.backslash]=0x5C;keymap[keys.rightBracket]=0x5D;keymap[keys.grave]=0x60;keymap[keys.delete]=0x7F;keymap[keys.insert]=0x80;if keys.convert then keymap[keys.convert]=0x9A end;if keys.noconvert then keymap[keys.noconvert]=0x9B end;if keys.kana then keymap[keys.kana]=0x9C end;if keys.kanji then keymap[keys.kanji]=0x9D end;if keys.yen then keymap[keys.yen]=0x9E end;keymap[keys.numPadDecimal]=0x9F;keymap[keys.numPadAdd]=0xAA;keymap[keys.numPadSubtract]=0xAB;if keys.numPadMultiply then keymap[keys.numPadMultiply]=0xAC end;keymap[keys.numPadDivide]=0xAD;keymap[keys.numPadEqual or keys.numPadEquals]=0xAE;keymap[keys.numPadEnter]=0xAF;keymap[keys.leftCtrl]=0xB0;keymap[keys.rightCtrl]=0xB1;keymap[keys.leftAlt]=0xB2;keymap[keys.rightAlt]=0xB3;keymap[keys.leftShift]=0xB4;keymap[keys.rightShift]=0xB5;if keys.leftSuper then keymap[keys.leftSuper]=0xB6 end;if keys.rightSuper then keymap[keys.rightSuper]=0xB7 end;keymap[keys.capsLock]=0xB8;keymap[keys.numLock]=0xB9;keymap[keys.scrollLock or keys.scollLock]=0xBA;if keys.printScreen then keymap[keys.printScreen]=0xBB end;keymap[keys.pause]=0xBC;if keys.menu then keymap[keys.menu]=0xBD end;if keys.stop then keymap[keys.stop]=0xBE end;if keys.ax then keymap[keys.ax]=0xBF end;keymap[keys.up]=0xC0;keymap[keys.down]=0xC1;keymap[keys.left]=0xC2;keymap[keys.right]=0xC3;keymap[keys.pageUp]=0xC4;keymap[keys.pageDown]=0xC5;keymap[keys.home]=0xC6;keymap[keys[\"end\"]]=0xC7;if keys.circumflex or keys.cimcumflex then keymap[keys.circumflex or keys.cimcumflex]=0xC8 end;if keys.at then keymap[keys.at]=0xC9 end;if keys.colon then keymap[keys.colon]=0xCA end;if keys.underscore then keymap[keys.underscore]=0xCB end end;local ef={id=0,name=\"\",coro=coroutine.create(function()end),status=\"starting\",args={\"a\",n=1},filter=function(process,aq,eg)end}local eh={id=1,name=\"init\",user=\"root\",dependents={{gc=function()end}},parent=0,dir=\"/\",stdin=TTY[1],stdout={},stderr=TTY[1],cputime=0.2,systime=0.1,env={},syscallyield=nil,eventQueue={},signalHandlers={},paused=false,nice=0,threads={[0]=ef}}local ei=1;local function ej(process)local e=createLuaLib(process)if _VERSION<\"Lua 5.2\"then e=make_ENV(e)end;e._G=e;return e end;local function ek()coroutine.yield(\"preempt\",\"test\",7)end;local el={load}function addProcessLoader(e2)table.insert(el,1,e2)end;function removeProcessLoader(e2)for v,i in ipairs(el)do if i==e2 then table.remove(el,v)return end end end;function reap_process(process)syslog.debug(\"Reaping process \"..process.id..\" (\"..process.name..\")\")for z,i in ipairs(process.dependents)do i:gc()end;if process.stdin and process.stdin.isTTY then if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)process.stdin.preBuffer=\"\"if discord and process.stdout==currentTTY and process.stdout.frontmostProcess then discord(\"Phoenix\",\"Executing \"..process.stdout.frontmostProcess.name)end else for v,i in ipairs(process.stdin.processList)do if i==process then table.remove(process.stdin.processList,v)break end end end end;if process.stdout and process.stdout.isTTY then if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)else for v,i in ipairs(process.stdout.processList)do if i==process then table.remove(process.stdout.processList,v)break end end end end;if process.stderr and process.stderr.isTTY then if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)else for v,i in ipairs(process.stderr.processList)do if i==process then table.remove(process.stderr.processList,v)break end end end end end;function syscalls.getpid(process,aq)return process.id end;function syscalls.getppid(process,aq)return process.parent end;function syscalls.clock(process,aq)return process.cputime end;function syscalls.getenv(process,aq)return process.vars end;function syscalls.getname(process,aq)return process.name end;function syscalls.getcwd(process,aq)return process.dir end;function syscalls.chdir(process,aq,dV)expect(1,dV,\"string\")local bD=filesystem.stat(process,dV)if not bD or bD.type~=\"directory\"then return false,\"No such file or directory\"elseif not(bD.permissions[process.user]or bD.worldPermissions).execute then return false,\"Permission denied\"end;process.dir=dV:gsub(\"^([^/])\",\"/\"..process.dir..\"/%1\")return true end;function syscalls.getuser(process,aq)return process.user,process.realuser end;function syscalls.setuser(process,aq,user)expect(1,user,\"string\")if process.user~=\"root\"then error(\"Permission denied\")end;process.user=user;process.realuser=nil end;function syscalls.fork(process,aq,az,m,...)expect(1,az,\"function\")expect(2,m,\"string\",\"nil\")local aA=ei;ei=ei+1;processes[aA]={id=aA,name=m or process.name,user=process.user,dependents={},parent=process.id,dir=process.dir,root=process.root,stdin=process.stdin,stdout=process.stdout,stderr=process.stderr,vars=deepcopy(process.vars),globalMetatables=deepcopy(globalMetatables),cputime=0,systime=0,syscallyield=nil,eventQueue={},signalHandlers={[1]=function()return coroutine.yield(\"syscall\",\"exit\",1)end,[2]=function()return coroutine.yield(\"syscall\",\"exit\",1)end,[3]=function()coroutine.yield(\"syscall\",\"syslog\",{level=\"error\",category=\"Application Error\",traceback=true},debug.traceback(\"Quit\"))return coroutine.yield(\"syscall\",\"exit\",1)end,[6]=function(o)coroutine.yield(\"syscall\",\"syslog\",{level=\"error\",category=\"Application Error\",traceback=true},debug.traceback(o or\"Aborted\"))return coroutine.yield(\"syscall\",\"exit\",1)end,[13]=function()return coroutine.yield(\"syscall\",\"exit\",1)end,[15]=function()return coroutine.yield(\"syscall\",\"exit\",1)end,[19]=function()return coroutine.yield(\"syscall\",\"suspend\")end,[21]=function()return coroutine.yield(\"syscall\",\"suspend\")end,[22]=function()return coroutine.yield(\"syscall\",\"suspend\")end},paused=false,nice=0,threads={[0]={id=0,name=\"<main thread>\",coro=coroutine.create(az),syscall=coroutine.create(function(...)local args=table.pack(...)while true do args=table.pack(coroutine.yield(kSyscallComplete,xpcall(syscalls[args[1]],debug.traceback,table.unpack(args,2,args.n))))end end),status=\"starting\",args=table.pack(...),filter=nil}}}processes[aA].env=ej(processes[aA])setfenv(az,processes[aA].env)if process.stdin and process.stdin.isTTY and not process.stdin.isLocked then process.stdin.processList[#process.stdin.processList+1]=process.stdin.frontmostProcess;process.stdin.frontmostProcess=processes[aA]process.stdin.preBuffer=\"\"if discord and process.stdout==currentTTY then discord(\"Phoenix\",\"Executing \"..process.name)end end;if process.stdout and process.stdout.isTTY and not process.stdout.isLocked and process.stdout.frontmostProcess~=processes[aA]then process.stdout.processList[#process.stdout.processList+1]=process.stdout.frontmostProcess;process.stdout.frontmostProcess=processes[aA]end;if process.stderr and process.stderr.isTTY and not process.stderr.isLocked and process.stderr.frontmostProcess~=processes[aA]then process.stderr.processList[#process.stderr.processList+1]=process.stderr.frontmostProcess;process.stderr.frontmostProcess=processes[aA]end;if args.preemptive then debug.sethook(processes[aA].threads[0].coro,ek,\"\",args.quantum)end;return aA end;function syscalls.exec(process,aq,bb,...)expect(1,bb,\"string\")local a,o=filesystem.open(process,bb,\"r\")if not a then bb=bb..\".lua\"a,o=filesystem.open(process,bb,\"r\")if not a then error(\"Could not open file: \"..o,0)end end;local em=a.readAll()a.close()if em:find(\"[%z\\1-\\31]\")then a,o=filesystem.open(process,bb,\"rb\")if not a then error(\"Could not open file: \"..o,0)end;em=a.readAll()a.close()end;local bD=filesystem.stat(process,bb)if not(bD.permissions[bD.owner]or bD.worldPermissions).execute then error(\"Could not execute file: Permission denied\",0)end;if bD.setuser then process.realuser,process.user=process.user,bD.owner end;if em:sub(1,2)==\"#!\"then local en=em:sub(3,em:find(\"\\n\")-1)local args,v={},0;for bn in en:gmatch\"%S+\"do args[v]=bn;v=v+1 end;args[v],v=bb,v+1;for z,i in ipairs{...}do args[v]=i;v=v+1 end;if args[0]==bb then error(\"Recursive path detected while resolving shebang\",0)end;syscalls.exec(process,aq,args[0],table.unpack(args,1,v))process.name=\"/\"..fs.combine(bb:sub(1,1)==\"/\"and\"\"or process.dir,bb)else local az,o;for z,e2 in ipairs(el)do az,o=e2(em,\"@\"..bb,\"bt\",process.env)if az then break end end;if not az then error(\"Could not execute file: \"..o,0)end;process.name=\"/\"..fs.combine(bb:sub(1,1)==\"/\"and\"\"or process.dir,bb)process.threads={[0]={id=0,name=\"<main thread>\",coro=coroutine.create(az),syscall=coroutine.create(function(...)local args=table.pack(...)while true do args=table.pack(coroutine.yield(kSyscallComplete,xpcall(syscalls[args[1]],debug.traceback,table.unpack(args,2,args.n))))end end),status=\"starting\",args=table.pack(...),filter=nil}}if args.preemptive then debug.sethook(process.threads[0].coro,ek,\"\",args.quantum*10^(process.nice/-10))end end;if discord and process.stdin and process.stdin.isTTY and process.stdin.frontmostProcess==process then discord(\"Phoenix\",\"Executing \"..process.name)end end;function syscalls.newthread(process,aq,az,...)expect(1,az,\"function\")local aA=#process.threads+1;process.threads[aA]={id=aA,name=\"<thread:\"..aA..\">\",coro=coroutine.create(az),syscall=coroutine.create(function(...)local args=table.pack(...)while true do args=table.pack(coroutine.yield(kSyscallComplete,xpcall(syscalls[args[1]],debug.traceback,table.unpack(args,2,args.n))))end end),status=\"starting\",args=table.pack(...),filter=nil}setfenv(az,process.env)if args.preemptive then debug.sethook(process.threads[aA].coro,ek,\"\",args.quantum*10^(process.nice/-10))end;return aA end;function syscalls.exit(process,aq,bp)process.lastReturnValue={pid=process.id,thread=aq.id,value=bp,n=1,bp}for z,aq in pairs(process.threads)do aq.status=\"dead\"aq.return_value=bp end end;function syscalls.getplist(process,aq)local eo={}for h in pairs(processes)do eo[#eo+1]=h end;table.sort(eo)return eo end;function syscalls.getpinfo(process,aq,cM)expect(1,cM,\"number\")local E=processes[cM]if not E then return nil,\"No such process\"end;local ep,eq,er;for v,i in ipairs(TTY)do if E.stdin==i then ep=v end;if E.stdout==i then eq=v end;if E.stderr==i then er=v end end;local es={}if E.threads then for v,i in pairs(E.threads)do es[v]={id=i.id,name=i.name,status=i.status}end end;return{id=E.id,name=E.name,user=E.user,realuser=E.realuser,parent=E.parent,dir=E.dir,stdin=ep,stdout=eq,stderr=er,cputime=E.cputime or 0,systime=E.systime or 0,threads=es}end;function syscalls.suspend(process,aq)process.paused=true end;function syscalls.nice(process,aq,b0,cM)expect(1,b0,\"number\")expect.range(b0,-20,20)expect(2,cM,\"number\",\"nil\")if b0<0 and process.user~=\"root\"then error(\"Permission denied\",0)end;local e7=cM and assert(processes[cM],\"Invalid process ID\")or process;if e7.user~=process.user and process.user~=\"root\"then error(\"Permission denied\",0)end;e7.nice=b0;if args.preemptive then for z,y in pairs(e7.threads)do debug.sethook(y.coro,ek,\"\",args.quantum*10^(b0/-10))end end end;local function et(a0)a0=a0 ..\"\\x80\"..(\"\\0\"):rep(-(#a0+9)%64)..(\">I8\"):pack(#a0)local eu,ev,ew,ex,ey,af=0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476,0xC3D2E1F0,{}for ez=1,#a0,64 do local eA=ez;for v=0,15 do af[v]=a0:byte(eA)*0x1000000+a0:byte(eA+1)*0x10000+a0:byte(eA+2)*0x100+a0:byte(eA+3)eA=eA+4 end;for v=16,79 do af[v]=bit32.lrotate(bit32.bxor(af[v-3],af[v-8],af[v-14],af[v-16]),1)end;local ck,ab,a9,bl,K=eu,ev,ew,ex,ey;for v=0,79 do local f,h;if v<=19 then f,h=bit32.bxor(bl,bit32.band(ab,bit32.bxor(a9,bl))),0x5A827999 elseif v<=39 then f,h=bit32.bxor(ab,a9,bl),0x6ED9EBA1 elseif v<=59 then f,h=bit32.bor(bit32.band(ab,bit32.bor(a9,bl)),bit32.band(a9,bl)),0x8F1BBCDC else f,h=bit32.bxor(ab,a9,bl),0xCA62C1D6 end;local eB=bit32.band(bit32.lrotate(ck,5)+f+K+h+af[v],0xFFFFFFFF)K,bl,a9,ab,ck=bl,a9,bit32.lrotate(ab,30),ck,eB end;eu=bit32.band(eu+ck,0xFFFFFFFF)ev=bit32.band(ev+ab,0xFFFFFFFF)ew=bit32.band(ew+a9,0xFFFFFFFF)ex=bit32.band(ex+bl,0xFFFFFFFF)ey=bit32.band(ey+K,0xFFFFFFFF)end;return{eu,ev,ew,ex,ey}end;local function eC(eD,m)local eE=et(eD:gsub(\"%X\",\"\"):gsub(\"%x%x\",function(bn)return string.char(tonumber(bn,16))end)..m)local ck,ab,a9,bl=eE[1],bit32.bor(bit32.band(eE[2],0xFFFF0FFF),0x5000),bit32.bor(bit32.band(eE[3],0x3FFFFFFF),0x80000000),eE[4]return(\"%08x-%04x-%04x-%04x-%04x%08x\"):format(ck,bit32.rshift(ab,16),bit32.band(ab,0xFFFF),bit32.rshift(a9,16),bit32.band(a9,0xFFFF),bl)end;local eF=\"a6f53b7d-50f3-4e51-adef-8728c83e3f3a\"deviceTreeRoot={id=tostring(os.getComputerID()),uuid=eC(eF,tostring(os.getComputerID())),parent=nil,displayName=os.getComputerLabel()or\"\",drivers={},metadata={},internalState={},children={},listeners=setmetatable({},{__mode=\"k\"})}local eG={[deviceTreeRoot.uuid]=deviceTreeRoot}local eH={}function hardware.get(bb)expect(1,bb,\"string\")if bb:find(\"^%x+%-%x+%-%x+%-%x+%-%x+$\")then return eG[bb]elseif bb==\"\"or bb:find(\"/\")then local dw=deviceTreeRoot;for m in bb:gmatch\"[^/]+\"do dw=dw.children[m]if dw==nil then break end end;return dw else local eI={}local function eJ(dw)if dw.id==bb or dw.alias==bb then eI[#eI+1]=dw end;for z,i in pairs(dw.children)do eJ(i)end end;eJ(deviceTreeRoot)return table.unpack(eI)end end;function hardware.find(type)expect(1,type,\"string\")local eK={}local function eL(dw)for z,i in ipairs(dw.drivers)do if i.type==type then eK[#eK+1]=dw;break end end;for z,i in pairs(dw.children)do eL(i)end end;eL(deviceTreeRoot)return table.unpack(eK)end;function hardware.path(dw)expect(1,dw,\"table\")expect.field(dw,\"uuid\",\"string\")if not eG[dw.uuid]then error(\"bad argument #1 (invalid node)\",2)end;local bb=dw.id;dw=dw.parent;while dw do bb=dw.id..\"/\"..bb;dw=dw.parent end;bb=bb:gsub(\"^[^/]+\",\"\")return bb==\"\"and\"/\"or bb end;function hardware.add(bW,m)expect(1,bW,\"table\")expect(2,m,\"string\")expect.field(bW,\"uuid\",\"string\")if not eG[bW.uuid]then return nil,\"Invalid parent node\"end;if bW.children[m]then return nil,\"Node already exists\"end;local dw={id=m,uuid=eC(bW.uuid,m),parent=bW,displayName=\"\",drivers={},metadata={},internalState={},children={},listeners=setmetatable({},{__mode=\"k\"})}bW.children[m]=dw;eG[dw.uuid]=dw;syslog.log({module=\"Hardware\"},\"Added new device at \"..hardware.path(dw))for z,i in ipairs(eH)do if(not i.parent or i.parent==bW)and(not i.pattern or m:match(i.pattern))then i.callback(dw)end end;return dw end;function hardware.remove(dw)expect(1,dw,\"table\")expect.field(dw,\"uuid\",\"string\")if not eG[dw.uuid]then return false,\"Invalid node\"end;if dw==deviceTreeRoot or not dw.parent then return false,\"Cannot remove root node\"end;for v=#dw.drivers,1,-1 do hardware.deregister(dw,dw.drivers[v])end;for z,i in pairs(dw.children)do hardware.remove(i)end;syslog.log({module=\"Hardware\"},\"Device at \"..hardware.path(dw)..\" has been removed\")dw.parent.children[dw.id]=nil;eG[dw.uuid]=nil;dw.parent=nil;return true end;function hardware.register(dw,eM)expect(1,dw,\"table\")expect(2,eM,\"table\")expect.field(dw,\"uuid\",\"string\")expect.field(eM,\"name\",\"string\")expect.field(eM,\"type\",\"string\")expect.field(eM,\"properties\",\"table\")expect.field(eM,\"methods\",\"table\")expect.field(eM,\"init\",\"function\",\"nil\")expect.field(eM,\"deinit\",\"function\",\"nil\")for h in pairs(eM.methods)do if type(h)~=\"string\"then error(\"bad method name '\"..tostring(h)..\"' (not a string)\",2)end;expect.field(eM.methods,h,\"function\")end;for z,i in ipairs(eM.properties)do if type(i)~=\"string\"then error(\"bad property name '\"..tostring(i)..\"' (not a string)\",2)end;if not eM.methods[\"get\"..i:sub(1,1):upper()..i:sub(2)]then error(\"bad property '\"..i..\"' (no getter present)\",2)end end;if not eG[dw.uuid]then error(\"bad argument #1 (invalid node)\",2)end;for z,i in ipairs(dw.drivers)do if i==eM then return false end end;dw.drivers[#dw.drivers+1]=eM;syslog.log({module=\"Hardware\"},\"Registered device with type \"..eM.type..\" on device \"..hardware.path(dw)..\" using driver \"..eM.name)if eM.init then eM.init(dw)end;return true end;function hardware.register_callback(eM)return function(dw)return hardware.register(dw,eM)end end;function hardware.deregister(dw,eM)expect(1,dw,\"table\")expect(2,eM,\"table\")expect.field(dw,\"uuid\",\"string\")if not eG[dw.uuid]then error(\"bad argument #1 (invalid node)\",2)end;for v,i in ipairs(dw.drivers)do if i==eM then if eM.deinit then eM.deinit(dw)end;table.remove(dw.drivers,v)syslog.log({module=\"Hardware\"},\"Driver \"..eM.name..\" has been deregistered from device \"..hardware.path(dw))return true end end;return false end;function hardware.listen(eN,bW,eO)expect(1,eN,\"function\")expect(2,bW,\"table\",\"nil\")expect(3,eO,\"string\",\"nil\")if bW then expect.field(bW,\"uuid\",\"string\")end;if eO and not pcall(string.match,\"\",eO)then error(\"bad argument #3 (invalid pattern)\",2)end;eH[#eH+1]={callback=eN,parent=bW,pattern=eO}end;function hardware.unlisten(eN)expect(1,eN,\"function\")local v=1;while v<#eH do if eH[v].callback==eN then table.remove(eH,v)else v=v+1 end end end;function hardware.broadcast(dw,eg,cP)expect(1,dw,\"table\")expect(2,eg,\"string\")expect(3,cP,\"table\")expect.field(dw,\"uuid\",\"string\")if not eG[dw.uuid]then error(\"bad argument #1 (invalid node)\",2)end;for i in pairs(dw.listeners)do i.eventQueue[#i.eventQueue+1]={eg,cP}end end;function hardware.call(process,dw,eP,...)for z,eM in ipairs(dw.drivers)do if eM.methods[eP]then return eM.methods[eP](dw,process,...)end end;error(\"No such method\",2)end;function syscalls.devlookup(process,aq,m)expect(1,m,\"string\")local eQ={hardware.get(m)}for h,i in ipairs(eQ)do eQ[h]=hardware.path(i)end;return table.unpack(eQ)end;function syscalls.devfind(process,aq,type)expect(1,type,\"string\")local eQ={hardware.find(type)}for h,i in ipairs(eQ)do eQ[h]=hardware.path(i)end;return table.unpack(eQ)end;function syscalls.devinfo(process,aq,eR)expect(1,eR,\"string\")local dw=hardware.get(eR)if not dw then return nil end;local eS={}for z,i in ipairs(dw.drivers)do eS[i.type]=i.name end;return{id=dw.id,uuid=dw.uuid,alias=dw.alias,parent=dw.parent and hardware.path(dw.parent)or\"/\",displayName=dw.displayName,types=eS,metadata=deepcopy(dw.metadata)}end;function syscalls.devalias(process,aq,eR,eT)expect(1,eR,\"string\")expect(2,eT,\"string\",\"nil\")local dw=hardware.get(eR)if not dw then error(\"No such device\",2)end;dw.alias=eT end;function syscalls.devmethods(process,aq,eR)expect(1,eR,\"string\")local dw=hardware.get(eR)if not dw then error(\"No such device\",2)end;local eU={}for z,i in ipairs(dw.drivers)do for h in pairs(i.methods)do eU[#eU+1]=h end end;return eU end;function syscalls.devproperties(process,aq,eR)expect(1,eR,\"string\")local dw=hardware.get(eR)if not dw then error(\"No such device\",2)end;local eV={}for z,i in ipairs(dw.drivers)do for z,h in pairs(i.properties)do eV[#eV+1]=h end end;return eV end;function syscalls.devchildren(process,aq,eR)expect(1,eR,\"string\")local dw=hardware.get(eR)if not dw then error(\"No such device\",2)end;local eW={}for h in pairs(dw.children)do eW[#eW+1]=h end;return eW end;function syscalls.devcall(process,aq,eR,eP,...)expect(1,eR,\"string\")expect(2,eP,\"string\")local dw=hardware.get(eR)if not dw then error(\"No such device\",2)end;if dw.process and dw.process~=process.id then error(\"Device is locked\",2)end;return hardware.call(process,dw,eP,...)end;function syscalls.devlisten(process,aq,eR,db)expect(1,eR,\"string\")expect(2,db,\"boolean\",\"nil\")if db==nil then db=true end;local dw=hardware.get(eR)if not dw then error(\"No such device\",2)end;if db then for z,i in ipairs(dw.listeners)do if i==process then return end end;dw.listeners[process]=true;process.dependents[#process.dependents+1]={type=\"hardware listen\",node=dw,gc=function()dw.listeners[process]=nil end}else dw.listeners[process]=nil;for v,i in ipairs(process.dependents)do if i.type==\"hardware listen\"and i.node==dw then table.remove(process.dependents,v)break end end end end;function syscalls.devlock(process,aq,eR,eX)expect(1,eR,\"string\")expect(2,eX,\"boolean\",\"nil\")if eX==nil then eX=true end;local dw=hardware.get(eR)if not dw then error(\"No such device\",2)end;if dw.process==nil then dw.process=process.id;process.dependents[#process.dependents+1]={type=\"hardware lock\",node=dw,gc=function()dw.process=nil end}return true elseif dw.process==process.id then return true elseif eX then aq.filter=function(process,aq)return dw.process==nil or dw.process==process.id end;return kSyscallYield,\"devlock\",eR,true else return false end end;function syscalls.devunlock(process,aq,eR)expect(1,eR,\"string\")local dw=hardware.get(eR)if not dw then error(\"No such device\",2)end;if dw.process and dw.process~=process.id then error(\"Device is locked\",2)end;dw.process=nil;for v,i in ipairs(process.dependents)do if i.type==\"hardware lock\"and i.node==dw then table.remove(process.dependents,v)break end end end;function syscalls.version(process,aq,eY)if eY then return PHOENIX_BUILD else return PHOENIX_VERSION end end;function syscalls.cchost(process,aq)return _HOST end;function syscalls.uptime(process,aq)return(os.epoch\"utc\"-systemStartTime)/1000 end;function syscalls.attach(process,aq,eZ,_type,...)if process.user~=\"root\"then error(\"Permission denied\")end;expect(1,eZ,\"string\",\"number\")expect(2,_type,\"string\")local bf,o;if periphemu then bf=periphemu.create(eZ,_type,...)elseif ccemux then if type(eZ)==\"number\"then eZ=_type..\"_\"..eZ end;if _type==\"drive\"then _type=\"disk_drive\"elseif _type==\"modem\"then _type=\"wireless_modem\"end;if _type==\"computer\"then local aA=tonumber(eZ:match(\"%d+\"))if aA then bf,o=pcall(ccemux.openEmu,aA)else bf,o=false,\"Invalid side\"end else bf,o=pcall(ccemux.attach,eZ,_type,...)end else bf,o=false,\"Operation not supported\"end;return bf,o end;function syscalls.detach(process,aq,eZ)if process.user~=\"root\"then error(\"Permission denied\")end;expect(1,eZ,\"string\",\"number\")local bf,o;if periphemu then bf=periphemu.remove(eZ)elseif ccemux then if type(eZ)==\"number\"then eZ=_type..\"_\"..eZ end;bf,o=pcall(ccemux.detach,eZ)else bf,o=false,\"Operation not supported\"end;return bf,o end;function syscalls.kernargs(process,aq)return deepcopy(args)end;local e_=0;function syscalls.lockmutex(process,aq,f0)expect(1,f0,\"table\")while f0.owner~=nil and f0.owner~=aq.id do coroutine.yield()end;if f0.owner then if type(f0.recursive)==\"number\"then f0.recursive=f0.recursive+1;return else error(\"cannot recursively lock mutex\",0)end end;f0.owner=aq.id;if f0.recursive then f0.recursive=1 end end;function syscalls.__timeout_check(process,aq,b3)if b3.timeout then return false end;return syscalls[b3.call](process,aq,b3.object,0)end;function syscalls.timelockmutex(process,aq,f0,e9)expect(1,f0,\"table\")expect(2,e9,\"number\")if f0.owner then if f0.owner~=aq.id then local f1=os.startTimer(e9)local b3={object=f0,timeout=false,call=\"timelockmutex\"}aq.filter=function(process,aq,ar)if ar[1]==\"timer\"and ar[2].id==f1 then b3.timeout=true;return true end;return f0.owner==nil or f0.owner==aq.id end;return kSyscallYield,\"__timeout_check\",b3 elseif type(f0.recursive)==\"number\"then f0.recursive=f0.recursive+1 else error(\"cannot recursively lock mutex\",0)end else f0.owner=aq.id;if f0.recursive then f0.recursive=1 end end;return true end;function syscalls.unlockmutex(process,aq,f0)expect(1,f0,\"table\")if f0.owner==aq.id then if type(f0.recursive)==\"number\"then f0.recursive=f0.recursive-1;if f0.recursive<=0 then f0.owner=nil end else f0.owner=nil end elseif f0.owner==nil then error(\"mutex already unlocked\",0)else error(\"mutex not locked by current thread\")end end;function syscalls.trylockmutex(process,aq,f0)expect(1,f0,\"table\")if f0.owner then if f0.owner~=process.id then return false elseif type(f0.recursive)==\"number\"then f0.recursive=f0.recursive+1;return true else error(\"cannot recursively lock mutex\",0)end else f0.owner=process.id;if f0.recursive then f0.recursive=1 end;return true end end;function syscalls.acquiresemaphore(process,aq,f2)expect(1,f2,\"table\")expect.field(f2,\"count\",\"number\")while f2.count<=0 do coroutine.yield()end;f2.count=f2.count-1 end;function syscalls.timeacquiresemaphore(process,aq,f2,e9)expect(1,f2,\"table\")expect.field(f2,\"count\",\"number\")expect(2,e9,\"number\")if f2.count<=0 then local f1=os.startTimer(e9)local b3={object=f2,timeout=false,call=\"timeacquiresemaphore\"}aq.filter=function(process,aq,ar)if ar[1]==\"timer\"and ar[2].id==f1 then b3.timeout=true;return true end;return type(f2.count)~=\"number\"or f2.count>0 end;return kSyscallYield,\"__timeout_check\",b3 end;f2.count=f2.count-1;return true end;function syscalls.releasesemaphore(process,aq,f2)expect(1,f2,\"table\")expect.field(f2,\"count\",\"number\")f2.count=f2.count+1 end;local f3={name=\"root\",type=\"computer\",properties={\"label\",\"id\"},methods={getLabel=function()end,setLabel=function(f4)end,getId=function()end,shutdown=function()end,reboot=function()end},init=function(dw)end,deinit=function(dw)end}local f5={top=true,bottom=true,left=true,right=true,front=true,back=true}local f6={}function getNodeById(m)if f5[m]then if deviceTreeRoot.children[m]then return deviceTreeRoot.children[m]end else for h in pairs(f5)do if peripheral.getType(h)==\"modem\"and not peripheral.call(h,\"isWireless\")and deviceTreeRoot.children[h]and deviceTreeRoot.children[h].children[m]then return deviceTreeRoot.children[h].children[m]end end end end;local function f7(self)self.internalState.peripheral=self.internalState.peripheral or{}if not self.internalState.peripheral.call then self.internalState.peripheral.call=peripheral.call end;if self.internalState.peripheral.call==peripheral.call or not self.parent then self.internalState.peripheral.getMethods=peripheral.getMethods else self.internalState.peripheral.getMethods=function(aA)return peripheral.call(self.parent.id,\"getMethodsRemote\",aA)end end end;local function f8(process,aB)aB.__metatable={}for z,i in pairs(aB)do setfenv(i,process.env)debug.protect(i)end;return setmetatable({},aB)end;local function f9(eM,type)return function(dw)local eS,g;if dw.parent==deviceTreeRoot then eS,g={peripheral.getType(dw.id)},peripheral.call else eS,g={peripheral.call(dw.parent.id,\"getTypeRemote\",dw.id)},function(...)return peripheral.call(dw.parent.id,\"callRemote\",...)end end;for z,i in ipairs(eS)do if i==type then dw.internalState.peripheral={call=g}return hardware.register(dw,eM)end end end end;local function fa(type)return hardware.listen(f9(f6[\"peripheral_\"..type],type),deviceTreeRoot)end;local function fb(eP)return function(self)return self.internalState.peripheral.call(self.id,eP)end end;local function fc(eP)return function(self,process)if process.user~=\"root\"then error(\"Permission denied\",0)end;return self.internalState.peripheral.call(self.id,eP)end end;local function fd(eP)return function(...)local eS={...}return function(self,process,aF)expect(1,aF,table.unpack(eS))return self.internalState.peripheral.call(self.id,eP,aF)end end end;local function fe(eP)return function(...)local eS={...}return function(self,process,aF)expect(1,aF,table.unpack(eS))if process.user~=\"root\"then error(\"Permission denied\",0)end;return self.internalState.peripheral.call(self.id,eP,aF)end end end;local function ff()syslog.log(\"Sending SIGTERM to all processes\")local fg=false;for cM,process in pairs(processes)do if cM~=0 then killProcess(cM,15)local fh,ar=false,nil;local as=true;for fi,aq in pairs(process.threads)do if not fh and aq.status==\"suspended\"then ar=table.remove(process.eventQueue,1)fh=true end;if ar or aq.status~=\"suspended\"then as=executeThread(process,aq,ar or{n=0},as,true)else as=false end end;if as then process.isDead=true;if process.parent~=0 and processes[process.parent]then processes[process.parent].eventQueue[#processes[process.parent].eventQueue+1]={\"process_complete\",process.lastReturnValue}end;reap_process(process)processes[cM]=nil else fg=true end end end;terminal.redraw(currentTTY)if fg then syslog.log(\"Sending SIGKILL to all processes\")for cM in pairs(processes)do if cM~=0 then killProcess(cM,9)end end end end;f6.root={name=\"root\",type=\"computer\",properties={\"isOn\",\"label\"},methods={}}function f6.root.methods:getIsOn(process)return true end;function f6.root.methods:getLabel(process)return os.getComputerLabel()end;function f6.root.methods:setLabel(process,f4)expect(1,f4,\"string\",\"nil\")os.setComputerLabel(f4)end;function f6.root.methods:turnOn(process)end;function f6.root.methods:shutdown(process)if process.user~=\"root\"then error(\"Permission denied\",2)end;syslog.log(\"System is shutting down.\")function postkill()hardware.deregister(deviceTreeRoot,f6.root)syslog.log(\"Halting system\")for z,i in ipairs(shutdownHooks)do i()end;os.shutdown()while true do coroutine.yield()end end;ff()end;function f6.root.methods:reboot(process)if process.user~=\"root\"then error(\"Permission denied\",2)end;syslog.log(\"System is restarting.\")function postkill()hardware.deregister(deviceTreeRoot,f6.root)syslog.log(\"Rebooting system\")for z,i in ipairs(shutdownHooks)do i()end;os.reboot()while true do coroutine.yield()end end;ff()end;function f6.root:init()local fj=hardware.add(self,\"redstone\")for z,i in ipairs{\"top\",\"bottom\",\"left\",\"right\",\"front\",\"back\"}do local bl=hardware.add(fj,i)bl.internalState.redstone={side=i}hardware.register(bl,f6.root_redstone)end;hardware.register(hardware.add(deviceTreeRoot,\"lo\"),f6.loopback_modem)registerLoopback()for i in pairs(f5)do if peripheral.isPresent(i)then hardware.add(self,i)end end;self.displayName=os.getComputerLabel()self.metadata.id=os.getComputerID()end;function f6.root:deinit()for i in pairs(f5)do if peripheral.isPresent(i)and self.children[i]then hardware.remove(self.children[i])end end;hardware.remove(hardware.get(\"/lo\"))hardware.remove(hardware.get(\"/redstone\"))end;eventHooks.peripheral=eventHooks.peripheral or{}eventHooks.peripheral[#eventHooks.peripheral+1]=function(ar)if f5[ar[2]]then local dw,o=hardware.add(deviceTreeRoot,ar[2])if dw then hardware.broadcast(deviceTreeRoot,\"device_added\",{device=hardware.path(dw)})else syslog.log({level=\"error\",module=\"Hardware\"},\"Could not create new device: \"..o)end else for h in pairs(f5)do if peripheral.getType(h)==\"modem\"and not peripheral.call(h,\"isWireless\")and peripheral.call(h,\"isPresentRemote\",ar[2])then if not deviceTreeRoot.children[h]then hardware.add(deviceTreeRoot,h)end;local dw,o=hardware.add(deviceTreeRoot.children[h],ar[2])if dw then hardware.broadcast(deviceTreeRoot.children[h],\"device_added\",{device=hardware.path(dw)})else syslog.log({level=\"error\",module=\"Hardware\"},\"Could not create new device: \"..o)end;break end end end end;eventHooks.peripheral_detach=eventHooks.peripheral_detach or{}eventHooks.peripheral_detach[#eventHooks.peripheral_detach+1]=function(ar)local dw=getNodeById(ar[2])if not dw then syslog.log({level=\"notice\",module=\"Hardware\"},\"Received \"..ar[1]..\" event for device ID \"..ar[2]..\", but no device node was found; ignoring\")return end;local bb,bW=hardware.path(dw),dw.parent;hardware.remove(dw)hardware.broadcast(bW,\"device_removed\",{device=bb})end;rootDriver=f6.root;f6.root_redstone={name=\"root_redstone\",type=\"redstone\",properties={\"input\",\"output\",\"bundledInput\",\"bundledOutput\"},methods={}}local function fk(r)if r==0 then return nil else return r end end;function f6.root_redstone.methods:getInput()return fk(redstone.getAnalogInput(self.internalState.redstone.side))end;function f6.root_redstone.methods:getOutput()return fk(redstone.getAnalogOutput(self.internalState.redstone.side))end;function f6.root_redstone.methods:setOutput(process,r)r=expect(1,r,\"number\",\"boolean\",\"nil\")or 0;if r==false then r=0 elseif r==true then r=15 end;expect.range(r,0,15)redstone.setAnalogOutput(self.internalState.redstone.side,r)end;function f6.root_redstone.methods:getBundledInput()return redstone.getBundledInput(self.internalState.redstone.side)end;function f6.root_redstone.methods:getBundledOutput()return redstone.getBundledOutput(self.internalState.redstone.side)end;function f6.root_redstone.methods:setBundledOutput(process,r)expect(1,r,\"number\")expect.range(r,0,65535)redstone.setBundledOutput(self.internalState.redstone.side,r)end;function f6.root_redstone:init()if not self.internalState.redstone or not self.internalState.redstone.side then error(\"No assigned side on redstone device!\",2)end;self.displayName=\"Redstone I/O on side \"..self.internalState.redstone.side end;f6.peripheral_command={name=\"peripheral_command\",type=\"command\",properties={\"command\"},methods={}}f6.peripheral_command.methods.getCommand=fc\"getCommand\"f6.peripheral_command.methods.setCommand=fe\"setCommand\"(\"string\")f6.peripheral_command.methods.run=fc\"runCommand\"function f6.peripheral_command:init()f7(self)self.displayName=\"Command block at \"..self.id end;fa\"command\"f6.peripheral_computer={name=\"peripheral_computer\",type=\"computer\",properties={\"isOn\",\"label\"},methods={}}f6.peripheral_computer.methods.getIsOn=fb\"isOn\"f6.peripheral_computer.methods.getLabel=fb\"getLabel\"f6.peripheral_computer.methods.turnOn=fc\"turnOn\"f6.peripheral_computer.methods.shutdown=fc\"shutdown\"f6.peripheral_computer.methods.reboot=fc\"reboot\"function f6.peripheral_command:init()f7(self)local f4=self.internalState.peripheral.call(self.id,\"getLabel\")self.metadata.id=self.internalState.peripheral.call(self.id,\"getID\")self.displayName=(f4 or\"Computer \"..self.metadata.id)..\" at \"..self.id end;fa\"computer\"hardware.listen(f9(f6[\"peripheral_computer\"],\"turtle\"),deviceTreeRoot)f6.peripheral_drive={name=\"peripheral_drive\",type=\"drive\",properties={\"state\",\"label\"},methods={}}function f6.peripheral_drive.methods:getState(process)if not self.internalState.peripheral.call(self.id,\"isDiskPresent\")then return nil end;return{audio=self.internalState.peripheral.call(self.id,\"getAudioTitle\")or nil,label=self.internalState.peripheral.call(self.id,\"getDiskLabel\"),id=self.internalState.peripheral.call(self.id,\"getDiskID\")}end;f6.peripheral_drive.methods.getLabel=fb\"getDiskLabel\"f6.peripheral_drive.methods.setLabel=fd\"setDiskLabel\"(\"string\",\"nil\")f6.peripheral_drive.methods.getMountPath=fb\"getMountPath\"function f6.peripheral_drive.methods:play(process)if not self.internalState.peripheral.call(self.id,\"hasAudio\")then error(\"Inserted disk is not an audio disc\",2)end;return self.internalState.peripheral.call(self.id,\"playAudio\")end;f6.peripheral_drive.methods.stop=fb\"stopAudio\"f6.peripheral_drive.methods.eject=fb\"ejectDisk\"f6.peripheral_drive.methods.insert=fe\"insertDisk\"(\"string\")function f6.peripheral_drive:init()f7(self)self.displayName=(self.internalState.peripheral.call(self.id,\"getDiskLabel\")or\"No disk\")..\" on drive \"..self.id end;fa\"drive\"eventHooks.disk=eventHooks.disk or{}eventHooks.disk[#eventHooks.disk+1]=function(ar)local dw=getNodeById(ar[2])if not dw then syslog.log({level=\"notice\",module=\"Hardware\"},\"Received \"..ar[1]..\" event for device ID \"..ar[2]..\", but no device node was found; ignoring\")return end;hardware.broadcast(dw,\"disk\",{device=hardware.path(dw)})end;eventHooks.disk_eject=eventHooks.disk_eject or{}eventHooks.disk_eject[#eventHooks.disk_eject+1]=function(ar)local dw=getNodeById(ar[2])if not dw then syslog.log({level=\"notice\",module=\"Hardware\"},\"Received \"..ar[1]..\" event for device ID \"..ar[2]..\", but no device node was found; ignoring\")return end;hardware.broadcast(dw,\"disk_eject\",{device=hardware.path(dw)})end;f6.peripheral_energy_storage={name=\"peripheral_energy_storage\",type=\"energy_storage\",properties={\"energy\"},methods={}}f6.peripheral_energy_storage.methods.getEnergy=fb\"getEnergy\"function f6.peripheral_energy_storage:init()f7(self)self.displayName=\"Energy storage block at \"..self.id;self.metadata.capacity=self.internalState.peripheral.call(self.id,\"getEnergyCapacity\")end;fa\"energy_storage\"f6.peripheral_fluid_storage={name=\"peripheral_fluid_storage\",type=\"fluid_storage\",properties={\"tanks\"},methods={}}f6.peripheral_fluid_storage.methods.getTanks=fb\"tanks\"function f6.peripheral_fluid_storage.methods:push(process,bN,fl,m)expect(1,bN,\"string\")expect(2,fl,\"number\",\"nil\")expect(3,m,\"string\",\"nil\")local e7;local fm={hardware.get(bN)}if#fm==1 then e7=fm[1]else for z,i in ipairs(fm)do if i.parent==self.parent then e7=i;break end end end;if not e7 then error(\"No such device\",0)elseif e7.parent~=self.parent then error(\"Devices must be on the same network\",0)end;local bf=false;for z,i in ipairs(e7.drivers)do if i==f6.peripheral_fluid_storage then bf=true;break end end;if not bf then error(\"Target device is not a fluid storage block\",0)end;return self.internalState.peripheral.call(self.id,\"pushFluid\",e7.id,fl,m)end;function f6.peripheral_fluid_storage.methods:pull(process,bM,fl,m)expect(1,bM,\"string\")expect(2,fl,\"number\",\"nil\")expect(3,m,\"string\",\"nil\")local e7;local fm={hardware.get(bM)}if#fm==1 then e7=fm[1]else for z,i in ipairs(fm)do if i.parent==self.parent then e7=i;break end end end;if not e7 then error(\"No such device\",0)elseif e7.parent~=self.parent then error(\"Devices must be on the same network\",0)end;local bf=false;for z,i in ipairs(e7.drivers)do if i==f6.peripheral_fluid_storage then bf=true;break end end;if not bf then error(\"Target device is not a fluid storage block\",0)end;return self.internalState.peripheral.call(self.id,\"pullFluid\",e7.id,fl,m)end;function f6.peripheral_fluid_storage:init()f7(self)self.displayName=\"Fluid storage block at \"..self.id end;fa\"fluid_storage\"f6.peripheral_inventory={name=\"peripheral_inventory\",type=\"inventory\",properties={\"items\"},methods={}}f6.peripheral_inventory.methods.getItems=fb\"list\"f6.peripheral_inventory.methods.detail=fd\"getItemDetail\"(\"number\")f6.peripheral_inventory.methods.limit=fd\"getItemLimit\"(\"number\")function f6.peripheral_inventory.methods:push(process,bN,fn,fl,fo)expect(1,bN,\"string\")expect(2,fn,\"number\")expect(3,fl,\"number\",\"nil\")expect(4,fo,\"number\",\"nil\")local e7;local fm={hardware.get(bN)}if#fm==1 then e7=fm[1]else for z,i in ipairs(fm)do if i.parent==self.parent then e7=i;break end end end;if not e7 then error(\"No such device\",0)elseif e7.parent~=self.parent then error(\"Devices must be on the same network\",0)end;local bf=false;for z,i in ipairs(e7.drivers)do if i==f6.peripheral_inventory then bf=true;break end end;if not bf then error(\"Target device is not an inventory block\",0)end;return self.internalState.peripheral.call(self.id,\"pushItems\",e7.id,fn,fl,fo)end;function f6.peripheral_inventory.methods:pull(process,bM,fn,fl,fo)expect(1,bM,\"string\")expect(2,fn,\"number\")expect(3,fl,\"number\",\"nil\")expect(4,fo,\"number\",\"nil\")local e7;local fm={hardware.get(bM)}if#fm==1 then e7=fm[1]else for z,i in ipairs(fm)do if i.parent==self.parent then e7=i;break end end end;if not e7 then error(\"No such device\",0)elseif e7.parent~=self.parent then error(\"Devices must be on the same network\",0)end;local bf=false;for z,i in ipairs(e7.drivers)do if i==f6.peripheral_inventory then bf=true;break end end;if not bf then error(\"Target device is not an inventory block\",0)end;return self.internalState.peripheral.call(self.id,\"pullItems\",e7.id,fn,fl,fo)end;function f6.peripheral_inventory:init()f7(self)self.displayName=\"Inventory at \"..self.id;self.metadata.size=self.internalState.peripheral.call(self.id,\"size\")end;fa\"inventory\"f6.peripheral_monitor={name=\"peripheral_monitor\",type=\"monitor\",properties={\"scale\",\"size\"},methods={}}f6.peripheral_monitor.methods.getScale=fb\"getTextScale\"f6.peripheral_monitor.methods.setScale=fd\"setTextScale\"(\"number\")function f6.peripheral_monitor.methods:getSize()local af,ag=self.internalState.peripheral.call(self.id,\"getSize\")return{width=af,height=ag}end;function f6.peripheral_monitor.methods:write(process,...)for v,i in ipairs{...}do if v>1 then terminal.write(self.internalState.tty,\"\\t\")end;terminal.write(self.internalState.tty,i)end;terminal.redraw(self.internalState.tty)end;function f6.peripheral_monitor.methods:termctl(process,de)expect(1,de,\"table\",\"nil\")if de then expect.field(de,\"cbreak\",\"boolean\",\"nil\")expect.field(de,\"delay\",\"boolean\",\"nil\")expect.field(de,\"echo\",\"boolean\",\"nil\")expect.field(de,\"keypad\",\"boolean\",\"nil\")expect.field(de,\"nlcr\",\"boolean\",\"nil\")expect.field(de,\"raw\",\"boolean\",\"nil\")for h,i in pairs(de)do if self.internalState.tty.flags[h]~=nil then self.internalState.tty.flags[h]=i end end end;local y=deepcopy(self.internalState.tty.flags)y.hasgfx=term.getGraphicsMode~=nil;return y end;function f6.peripheral_monitor.methods:openterm(process)return terminal.openterm(self.internalState.tty,process)end;function f6.peripheral_monitor.methods:opengfx(process)return terminal.opengfx(self.internalState.tty,process)end;function f6.peripheral_monitor:init()f7(self)local af,ag=self.internalState.peripheral.call(self.id,\"getSize\")local fp=self.internalState.peripheral.call(self.id,\"getTextScale\")self.displayName=af*fp..\"x\"..ag*fp..\" monitor at \"..self.id;local term={}for z,i in ipairs(self.internalState.peripheral.getMethods(self.id))do term[i]=function(...)return self.internalState.peripheral.call(self.id,i,...)end end;self.internalState.tty=terminal.makeTTY(term,af,ag)self.internalState.tty.isMonitor=true;terminal.redraw(self.internalState.tty,true)end;function f6.peripheral_monitor:deinit()local d0=self.internalState.tty;if d0.frontmostProcess then local i=d0.frontmostProcess;if i.stdin==d0 then i.stdin=nil end;if i.stdout==d0 then i.stdout=nil end;if i.stderr==d0 then i.stderr=nil end end;for z,i in ipairs(d0.processList)do if i.stdin==d0 then i.stdin=nil end;if i.stdout==d0 then i.stdout=nil end;if i.stderr==d0 then i.stderr=nil end end end;fa\"monitor\"eventHooks.monitor_resize=eventHooks.monitor_resize or{}eventHooks.monitor_resize[#eventHooks.monitor_resize+1]=function(ar)local dw=getNodeById(ar[2])if not dw then syslog.log({level=\"notice\",module=\"Hardware\"},\"Received \"..ar[1]..\" event for device ID \"..ar[2]..\", but no device node was found; ignoring\")return end;local af,ag=f6.peripheral_monitor.methods.getSize(dw)terminal.resize(dw.internalState.tty,af,ag)hardware.broadcast(dw,\"monitor_resize\",{device=hardware.path(dw),width=af,height=ag})end;f6.peripheral_printer={name=\"peripheral_printer\",type=\"printer\",properties={\"inkLevel\",\"paperLevel\"},methods={}}f6.peripheral_printer.methods.getInkLevel=fb\"getInkLevel\"f6.peripheral_printer.methods.getPaperLevel=fb\"getPaperLevel\"function f6.peripheral_printer.methods:page(process)if self.internalState.printer.open then self.internalState.peripheral.call(self.id,\"endPage\")self.internalState.printer.open=false end;if not self.internalState.peripheral.call(self.id,\"newPage\")then return nil end;self.internalState.printer.open=true;local fq,p,q;local function dd(...)if not self.internalState.printer.open then error(\"attempt to use closed page\",2)end;return self.internalState.peripheral.call(self.id,\"write\",...)end;local function fr()if not self.internalState.printer.open then return true end;if not self.internalState.peripheral.call(self.id,\"endPage\")then return false end;self.internalState.printer.open=false end;setfenv(dd,process.env)setfenv(fr,process.env)debug.protect(dd)debug.protect(fr)return f8(process,{__index=function(z,aC)if not self.internalState.printer.open then error(\"attempt to use closed page\",2)end;if aC==\"size\"then local t,cX=self.internalState.peripheral.call(self.id,\"getPageSize\")return f8(process,{__index=function(z,aC)if aC==\"width\"then return t elseif aC==\"height\"then return cX end end,__newindex=function()error(\"Cannot modify read-only table\",2)end})elseif aC==\"cursor\"then p,q=self.internalState.peripheral.call(self.id,\"getCursorPos\")return f8(process,{__index=function(z,aC)if aC==\"x\"then return p elseif aC==\"y\"then return q end end,__newindex=function(z,aC,aD)if aC==\"x\"then p=aD;self.internalState.peripheral.call(self.id,\"setCursorPos\",p,q)elseif aC==\"y\"then q=aD;self.internalState.peripheral.call(self.id,\"setCursorPos\",p,q)else error(\"Cannot modify member '\"..aC..\"'\",2)end end})elseif aC==\"title\"then return fq elseif aC==\"isOpen\"then return self.internalState.printer.open elseif aC==\"write\"then return dd elseif aC==\"close\"then return fr end end,__newindex=function(z,aC,aD)if not self.internalState.printer.open then error(\"attempt to use closed page\",2)end;if aC==\"cursor\"then if type(aD)~=\"table\"then error(\"bad value for 'cursor' (expected table, got \"..type(aD)..\")\",2)end;expect.field(aD,\"x\",\"number\")expect.field(aD,\"y\",\"number\")p,q=aD.x,aD.y;self.internalState.peripheral.call(self.id,\"setCursorPos\",p,q)elseif aC==\"title\"then if type(aD)~=\"string\"and aD~=nil then error(\"bad value for 'title' (expected string, got \"..type(aD)..\")\",2)end;fq=aD;self.internalState.peripheral.call(self.id,\"setPageTitle\",fq)else error(\"Cannot modify member '\"..aC..\"'\",2)end end})end;function f6.peripheral_printer:init()f7(self)self.displayName=\"Speaker at \"..self.id;self.internalState.printer={open=false}end;fa\"printer\"f6.peripheral_speaker={name=\"peripheral_speaker\",type=\"speaker\",properties={},methods={}}function f6.peripheral_speaker.methods:playNote(process,ft,fu,fv)expect(1,ft,\"string\")expect(2,fu,\"number\",\"nil\")expect(3,fv,\"number\",\"nil\")if fu then expect.range(fu,0,3)end;if fv then expect.range(fv,0,24)end;return self.internalState.peripheral.call(self.id,\"playNote\",ft,fu,fv)end;function f6.peripheral_speaker.methods:playSound(process,m,fu,fw)expect(1,m,\"string\")expect(2,fu,\"number\",\"nil\")expect(3,fw,\"number\",\"nil\")if fu then expect.range(fu,0,3)end;if fw then expect.range(fw,0.5,2.0)end;return self.internalState.peripheral.call(self.id,\"playNote\",m,fu,fw)end;function f6.peripheral_speaker.methods:playAudio(fx,fu)expect(1,fx,\"table\")expect(2,fu,\"number\",\"nil\")if fu then expect.range(fu,0,3)end;return self.internalState.peripheral.call(self.id,\"playAudio\",fx,fu)end;f6.peripheral_speaker.methods.stop=fb\"stop\"function f6.peripheral_command:init()f7(self)self.displayName=\"Speaker at \"..self.id end;fa\"speaker\"eventHooks.speaker_audio_empty=eventHooks.speaker_audio_empty or{}eventHooks.speaker_audio_empty[#eventHooks.speaker_audio_empty+1]=function(ar)local dw=getNodeById(ar[2])if not dw then syslog.log({level=\"notice\",module=\"Hardware\"},\"Received \"..ar[1]..\" event for device ID \"..ar[2]..\", but no device node was found; ignoring\")return end;hardware.broadcast(dw,\"speaker_audio_empty\",{device=hardware.path(dw)})end;local fy={f6.peripheral_command,f6.peripheral_computer,f6.peripheral_drive,f6.peripheral_energy_storage,f6.peripheral_fluid_storage,f6.peripheral_inventory,f6.peripheral_monitor,f6.peripheral_printer,f6.peripheral_speaker}function registerDriver(eM)local fz=eM.init;eM.init=function(dw)f7(dw)if fz then return fz(dw)end end;eM.__callback=f9(eM,eM.type)hardware.listen(eM.__callback,deviceTreeRoot)fy[#fy+1]=eM;for z,dw in ipairs(hardware.find(\"modem\"))do if not dw.metadata.wireless then hardware.listen(eM.__callback,dw)dw.internalState.modem.callbacks[#dw.internalState.modem.callbacks+1]=f end end end;function deregisterDriver(eM)if not eM.__callback then return end;hardware.unlisten(eM.__callback)for z,i in ipairs(hardware.find(eM.type))do hardware.deregister(i,eM)end;for v,i in ipairs(f5)do if i==eM then table.remove(f5,v)break end end;for z,dw in ipairs(hardware.find(\"modem\"))do if not dw.metadata.wireless then hardware.unlisten(eM.__callback)for v,i in ipairs(dw.internalState.modem.callbacks)do if i==eM.__callback then table.remove(dw.internalState.modem.callbacks,v)break end end end end end;f6.peripheral_modem={name=\"peripheral_modem\",type=\"modem\",properties={\"remainingChannels\"},methods={}}function f6.peripheral_modem.methods:getRemainingChannels()local b=128;for z in pairs(self.internalState.modem)do b=b-1 end;return b end;function f6.peripheral_modem.methods:open(process,fA)if not self.internalState.modem[fA]then self.internalState.peripheral.call(self.id,\"open\",fA)self.internalState.modem[fA]={}end;self.internalState.modem[fA][process]=true end;function f6.peripheral_modem.methods:isOpen(process,fA)return self.internalState.modem[fA]and self.internalState.modem[fA][process]end;function f6.peripheral_modem.methods:close(process,fA)self.internalState.modem[fA][process]=nil;if not next(self.internalState.modem[fA])then self.internalState.peripheral.call(self.id,\"close\",fA)self.internalState.modem[fA]=nil end end;function f6.peripheral_modem.methods:closeAll(process)for fA=0,65535 do self.internalState.modem[fA][process]=nil;if not next(self.internalState.modem[fA])then self.internalState.peripheral.call(self.id,\"close\",fA)self.internalState.modem[fA]=nil end end end;function f6.peripheral_modem.methods:transmit(process,fA,fB,fC)expect(1,fA,\"number\")fB=expect(2,fB,\"number\",\"nil\")or fA;return self.internalState.peripheral.call(self.id,\"transmit\",fA,fB,fC)end;function f6.peripheral_modem:init()f7(self)self.metadata.wireless=self.internalState.peripheral.call(self.id,\"isWireless\")self.displayName=(self.metadata.wireless and\"Wireless\"or\"Wired\")..\" modem at \"..self.id;self.internalState.modem={}self.internalState.modem.channels={}self.internalState.peripheral.call(self.id,\"closeAll\")if not self.metadata.wireless then self.internalState.modem.callbacks={}for z,i in ipairs(fy)do local f=f9(i,i.type)hardware.listen(f,self)self.internalState.modem.callbacks[#self.internalState.modem.callbacks+1]=f end;local f=f9(f6[\"peripheral_computer\"],\"turtle\")hardware.listen(f,self)self.internalState.modem.callbacks[#self.internalState.modem.callbacks+1]=f;for z,m in ipairs(self.internalState.peripheral.call(self.id,\"getNamesRemote\"))do hardware.add(self,m)end end end;function f6.peripheral_modem:deinit()if not self.metadata.wireless then for z,i in ipairs(self.internalState.modem.callbacks)do hardware.unlisten(i)end end end;fa\"modem\"eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(ar)local dw=getNodeById(ar[2])or hardware.get(ar[2])if not dw then syslog.log({level=\"notice\",module=\"Hardware\"},\"Received \"..ar[1]..\" event for device ID \"..ar[2]..\", but no device node was found; ignoring\")return end;local a5=false;for i in pairs(dw.listeners)do if dw.internalState.modem[ar[3]][i]then i.eventQueue[#i.eventQueue+1],a5={\"modem_message\",{device=hardware.path(dw),channel=ar[3],replyChannel=ar[4],message=ar[5],distance=ar[6]}},true end end;return a5 end;f6.loopback_modem={name=\"loopback_modem\",type=\"modem\",properties={\"remainingChannels\"},methods={}}function f6.loopback_modem.methods:getRemainingChannels()local b=128;for z in pairs(self.internalState.modem)do b=b-1 end;return b end;function f6.loopback_modem.methods:open(process,fA)if not self.internalState.modem[fA]then self.internalState.modem[fA]={}end;self.internalState.modem[fA][process]=true end;function f6.loopback_modem.methods:isOpen(process,fA)return self.internalState.modem[fA]and self.internalState.modem[fA][process]end;function f6.loopback_modem.methods:close(process,fA)self.internalState.modem[fA][process]=nil;if not next(self.internalState.modem[fA])then self.internalState.modem[fA]=nil end end;function f6.loopback_modem.methods:closeAll(process)for fA=0,65535 do self.internalState.modem[fA][process]=nil;if not next(self.internalState.modem[fA])then self.internalState.modem[fA]=nil end end end;function f6.loopback_modem.methods:transmit(process,fA,fB,fC)expect(1,fA,\"number\")fB=expect(2,fB,\"number\",\"nil\")or fA;os.queueEvent(\"modem_message\",self.uuid,fA,fB,fC,0)end;function f6.loopback_modem:init()self.metadata.wireless=true;self.displayName=\"Loopback modem\"self.internalState.modem={}self.internalState.modem.channels={}end;local function fD(fE)local b3={scheme=\"\"}for a9 in fE:gmatch\".\"do if b3.fragment then if a9:match\"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/?]\"then b3.fragment=b3.fragment..a9 else error(\"Invalid URI\",3)end elseif b3.query then if a9==\"#\"then b3.fragment=\"\"elseif a9:match\"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/?]\"then b3.query=b3.query..a9 else error(\"Invalid URI\",3)end elseif b3.path then if a9==\"/\"and b3.path==\"/\"and not b3.host then b3.path,b3.host=nil,\"\"elseif a9==\"?\"then b3.query=\"\"elseif a9==\"#\"then b3.fragment=\"\"elseif a9:match\"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/]\"then b3.path=b3.path..a9 else error(\"Invalid URI\",3)end elseif b3.port then if tonumber(a9)then b3.port=b3.port..a9 elseif a9==\"/\"then b3.path=\"/\"else error(\"Invalid URI\",3)end elseif b3.host then if a9==\"@\"and not b3.user then b3.user,b3.host=b3.host,\"\"elseif a9==\":\"then b3.port=\"\"elseif a9==\"/\"then b3.path=\"/\"elseif a9:match\"[%w%-%._~%%/!%$&'%(%)%*%+,;=]\"then b3.host=b3.host..a9 else error(\"Invalid URI\",3)end else if a9==\":\"then b3.path=\"\"elseif a9:match(b3.scheme==\"\"and\"[%a%+%-%.]\"or\"[%w%+%-%.]\")then b3.scheme=b3.scheme..a9 else error(\"Invalid URI\",3)end end end;if b3.port then b3.port=tonumber(b3.port)end;return b3 end;local function fF(fG)if fG:match\"^%d+$\"then return tonumber(fG)elseif fG:match\"^%d+%.%d+$\"then return tonumber(fG:match\"^%d+\")*0x1000000+tonumber(fG:match\"^%d+%.(%d+)\")elseif fG:match\"^%d+%.%d+%.%d+$\"then return tonumber(fG:match\"^(%d+)\")*0x1000000+tonumber(fG:match\"^%d+%.(%d+)\")*0x10000+tonumber(fG:match\"^%d+%.%d+%.(%d+)\")elseif fG:match\"^%d+%.%d+%.%d+%.%d+$\"then return tonumber(fG:match\"^(%d+)\")*0x1000000+tonumber(fG:match\"^%d+%.(%d+)\")*0x10000+tonumber(fG:match\"^%d+%.%d+%.(%d+)\")*0x100+tonumber(fG:match\"^%d+%.%d+%.%d+%.(%d+)\")else error(\"Invalid IP address\",2)end end;local function fH(b)if not b then return nil end;return(\"%d.%d.%d.%d\"):format(bit32.band(bit32.rshift(b,24),0xFF),bit32.band(bit32.rshift(b,16),0xFF),bit32.band(bit32.rshift(b,8),0xFF),bit32.band(b,0xFF))end;local function fI(fJ)local bn=\"\"for v=1,fJ do bn=bn..string.char(math.random(0,255))end;return bn end;local function fK(b)return bit32.bnot(2^(32-b)-1)end;local function fL(w)local r=0;while bit32.btest(w,0x80000000)do w,r=bit32.lshift(w,1),r+1 end;return r end;local function fM(dw)if not dw then error(\"No such device\")end;for z,i in pairs(dw.drivers)do if i.type==\"modem\"then return dw end end;error(\"Not a modem\")end;local fN=0;local fO={}local fP={maxn=0,[0]={}}local fQ={}local fR={send={},recv={}}local fS={}local fT={}local fU=setmetatable({},{__mode=\"k\"})local fV={arp={},socket={}}local fW={}function fR.send.link(b3,fX,ae)expect(2,fX,\"number\",\"nil\")expect.field(b3,\"device\",\"table\")local bv={PhoenixNetworking=true,type=\"link\",source=os.computerID(),destination=fX,payload=ae}if fX==os.computerID()then os.queueEvent(\"modem_message\",b3.device.id,b3.outPort or 0,b3.inPort or 0,bv,0)else hardware.call(b3.process or KERNEL,b3.device,\"transmit\",b3.outPort or 0,b3.inPort or 0,bv)end end;function fR.send.arp_request(b3,fG)expect.field(b3,\"device\",\"table\")expect(2,fG,\"string\")hardware.call(b3.process or KERNEL,b3.device,\"transmit\",0,0,{PhoenixNetworking=true,type=\"arp\",reply=false,source=os.computerID(),sourceIP=fO[b3.device.uuid]and fH(fO[b3.device.uuid].ip),destinationIP=fG})end;function fR.send.arp_reply(b3,fX,fY)expect.field(b3,\"device\",\"table\")expect(2,fX,\"number\")expect(3,fY,\"string\",\"nil\")hardware.call(b3.process or KERNEL,b3.device,\"transmit\",0,0,{PhoenixNetworking=true,type=\"arp\",reply=true,source=os.computerID(),sourceIP=fH(fO[b3.device.uuid].ip),destination=fX,destinationIP=fY})end;function fR.send.internet(b3,fX,ae)expect(2,fX,\"number\")local e0={PhoenixNetworking=true,type=\"internet\",hopsLeft=15,payload=ae,destination=fH(fX)}local aA=fI(32)e0.messageID=aA;local i;for v=fP.maxn,0,-1 do if fP[v]then for z,fZ in ipairs(fP[v])do if bit32.band(fZ.source,fZ.sourceNetmask)==bit32.band(fX,fZ.sourceNetmask)and(not i or fL(fZ.sourceNetmask)>fL(i.sourceNetmask))then i=fZ end end end end;if not i then return fR.recv.control({},{PhoenixNetworking=true,messageType=\"unreachable\",error=\"No route to host\",payload=e0})end;if i.action==\"unicast\"and fO[i.device.uuid]and fO[i.device.uuid].up then b3.device=i.device;e0.source=fH(fO[i.device.uuid].ip)if fQ[i.device.uuid]and fQ[i.device.uuid][i.destination]then return fR.send.link(b3,fQ[i.device.uuid][i.destination],e0)end;local f_=false;local f1;local function g0(z,fG,bz)if not f_ and fF(fG)==i.destination then f_=true;fR.send.link(b3,bz,e0)end;if f_ then for v,f in ipairs(fV.arp)do if f==g0 then table.remove(fV.arp,v)break end end end end;local function g1(ar)if ar[2]==f1 then if not f_ then fR.recv.control({},{PhoenixNetworking=true,messageType=\"unreachable\",error=\"No route to host\",payload=e0})end;f_=true;for v,i in ipairs(eventHooks.timer)do if i==g1 then table.remove(eventHooks.timer,v)break end end;for v,f in ipairs(fV.arp)do if f==g0 then table.remove(fV.arp,v)break end end end end;fV.arp[#fV.arp+1]=g0;fR.send.arp_request(b3,fH(i.destination))eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=g1;f1=os.startTimer(2)return elseif i.action==\"broadcast\"and fO[i.device.uuid]and fO[i.device.uuid].up then b3.device=i.device;e0.source=fH(fO[i.device.uuid].ip)return fR.send.link(b3,nil,e0)elseif i.action==\"local\"and fO[i.device.uuid]and fO[i.device.uuid].up then b3.device=i.device;e0.source=fH(fO[i.device.uuid].ip)if fQ[i.device.uuid]and fQ[i.device.uuid][fX]then return fR.send.link(b3,fQ[i.device.uuid][fX],e0)end;local f_=false;local f1;local function g0(z,fG,bz)if not f_ and fF(fG)==fX then f_=true;fR.send.link(b3,bz,e0)end;if f_ then for v,f in ipairs(fV.arp)do if f==g0 then table.remove(fV.arp,v)break end end end end;local function g1(ar)if ar[2]==f1 then if not f_ then fR.recv.control({},{PhoenixNetworking=true,messageType=\"unreachable\",error=\"No route to host\",payload=e0})end;f_=true;for v,i in ipairs(eventHooks.timer)do if i==g1 then table.remove(eventHooks.timer,v)break end end end end;fV.arp[#fV.arp+1]=g0;fR.send.arp_request(b3,fH(fX))eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=g1;f1=os.startTimer(2)return elseif i.action==\"unreachable\"then return fR.recv.control({},{PhoenixNetworking=true,messageType=\"unreachable\",error=\"Destination unreachable\",payload=e0})elseif i.action==\"prohibit\"then return fR.recv.control({},{PhoenixNetworking=true,messageType=\"unreachable\",error=\"Prohibited\",payload=e0})elseif i.action==\"blackhole\"then return end end;function fR.send.control(b3,fX,type,o,g2)expect(3,type,\"string\")expect(4,o,\"string\",\"nil\")return fR.send.internet(b3,fX,{PhoenixNetworking=true,type=\"control\",messageType=type,error=o,payload=g2})end;fR.send.socket={}function fR.send.socket.connect(b3,fG,g3,g4)for v=1,16384 do local E=math.random(49152,65535)if not fS[E]or not fS[E][g3]then g4.localPort=E;break end end;if not g4.localPort then error(\"Too many open sockets\")end;g4.id=fN;fN=fN+1;g4.ip=fG;g4.port=g3;g4.sendSeq=math.floor(math.random()*0x10000000000)g4.sendSeqNext=g4.sendSeq+2;g4.sendSeqMax=g4.sendSeq+256;b3.outPort=g3;b3.inPort=g4.localPort;fU[g4]=function(E)if E.type==\"control\"and E.payload.destination==fH(fG)then g4.status=\"error\"g4.error=E.error;return true end;return false end;fR.send.internet(b3,fG,{PhoenixNetworking=true,type=\"socket\",sequence=g4.sendSeqNext-1,windowSize=256,synchronize=true})local bf,o=pcall(hardware.call,b3.process or KERNEL,b3.device,\"open\",g4.localPort)if not bf then fR.send.internet(b3,fG,{PhoenixNetworking=true,type=\"socket\",sequence=g4.sendSeqNext,windowSize=0,reset=true})g4.status=\"error\"g4.error=o;return false end;g4.status=\"syn-sent\"g4.nextUpdate=os.epoch\"utc\"+5000;g4.process=b3.process;g4.retryCount=0;fS[g4.localPort]=fS[g4.localPort]or{}fS[g4.localPort][g3]=g4;fT[g4.id]=g4 end;function fR.send.socket.data(b3,ae,g4)b3.outPort=g4.port;b3.inPort=g4.localPort;ae.PhoenixNetworking=true;ae.type=\"socket\"if not ae.sequence then ae.sequence=g4.sendSeqNext;g4.sendSeqNext=g4.sendSeqNext+1 end;ae.acknowledgement=ae.acknowledgement or g4.recvSeq-1;g4.nextAck=nil;if not ae.final then ae.windowSize=256 end;return fR.send.internet(b3,g4.ip,ae)end;function fR.send.socket.ack(b3,b,g4)return fR.send.socket.data(b3,{acknowledgement=b},g4)end;function fR.send.socket.reset(b3,fG,g3,g5,g6,g7)b3.outPort=g3;b3.inPort=g7 or g3;return fR.send.internet(b3,fG,{PhoenixNetworking=true,type=\"socket\",sequence=g5,acknowledgement=g6,reset=true})end;local function g8(g4,n,...)n=n or\"*l\"if type(n)~=\"string\"and type(n)~=\"number\"then error(\"bad argument (expected string or number, got \"..type(n)..\")\",2)end;if g4.buffer==\"\"then return nil end;n=n:gsub(\"^%*\",\"\")if n==\"a\"then local a0=g4.buffer;g4.buffer=\"\"syslog.debug(\"read socket\",a0)return a0 elseif n==\"l\"then local a0,a7=g4.buffer:match\"^([^\\n]*)\\n?()\"if a0 then g4.buffer=g4.buffer:sub(a7)if select(\"#\",...)>0 then return a0,g8(g4,...)else return a0 end else return nil end elseif n==\"L\"then local a0,a7=g4.buffer:match\"^([^\\n]*\\n?)()\"if a0 then g4.buffer=g4.buffer:sub(a7)if select(\"#\",...)>0 then return a0,g8(g4,...)else return a0 end else return nil end elseif n==\"n\"then local a0,a7=g4.buffer:match\"(%d+)()\"if a0 then g4.buffer=g4.buffer:sub(a7)if select(\"#\",...)>0 then return tonumber(a0),g8(g4,...)else return tonumber(a0)end else return nil end elseif type(n)==\"number\"then local a0=g4.buffer:sub(1,n)g4.buffer=g4.buffer:sub(n+1)if select(\"#\",...)>0 then return a0,g8(g4,...)else return a0 end else error(\"bad argument (invalid mode '\"..n..\"')\",2)end end;local function g9(g4,bh,...)bh=tostring(bh)g4.outQueue[g4.sendSeqNext]=bh;fR.send.socket.data({},{payload=bh},g4)if select(\"#\",...)>0 then return g9(g4,...)end end;function syscalls.__socketcall(process,aq,aA,eP,...)local g4=fT[aA]if not g4 then error(\"No such socket\")end;local ga=process;while process~=g4.process do if process==nil then error(\"No such socket\")end;process=processes[process.parent or-1]end;if eP==\"close\"then g4.sendSeqMax=g4.sendSeqNext;fR.send.socket.data({},{final=true},g4)g4.status=\"fin-wait\"elseif eP==\"read\"then return g8(g4,...)elseif eP==\"write\"then return g9(g4,...)elseif eP==\"transfer\"then g4.process=ga else error(\"No such method\")end end;local do_syscall=do_syscall;local function gb(g4)local bv=setmetatable({id=g4.id},{__name=\"socket\"})function bv:localIP()return g4.localIP end;function bv:status()if g4.status==\"listening\"or g4.status==\"syn-sent\"or g4.status==\"syn-received\"then return\"connecting\"elseif g4.status==\"connected\"or g4.buffer~=\"\"then return\"open\"elseif g4.status==\"error\"then return\"error\",g4.error else return\"closed\"end end;function bv:read(n,...)if g4.status~=\"connected\"and g4.status~=\"close-wait\"and g4.status~=\"closed\"then error(\"attempt to read from a \"..g4.status..\" handle\",2)end;return do_syscall(\"__socketcall\",g4.id,\"read\",n,...)end;function bv:write(bh,...)if g4.status~=\"connected\"then error(\"attempt to write to a \"..g4.status..\" handle\",2)end;return do_syscall(\"__socketcall\",g4.id,\"write\",bh,...)end;function bv:close()if g4.status==\"closing\"or g4.status==\"fin-wait\"or g4.status==\"closed\"then return end;if not(g4.status==\"listening\"or g4.status==\"syn-sent\"or g4.status==\"syn-received\"or g4.status==\"connected\")then error(\"attempt to close a \"..g4.status..\" handle\",2)end;return do_syscall(\"__socketcall\",g4.id,\"close\")end;function bv:transfer()return do_syscall(\"__socketcall\",g4.id,\"transfer\")end;return bv end;function fR.recv.link(b3,ae)expect.field(ae,\"source\",\"number\")expect.field(ae,\"destination\",\"number\")expect.field(ae,\"payload\",\"table\")syslog.debug(\"Received link message from\",ae.source,\"to\",ae.destination)if ae.destination~=os.computerID()then return end;b3.sourceID=ae.source;assert(ae.payload.PhoenixNetworking)expect.field(ae.payload,\"type\",\"string\")if not fR.recv[ae.payload.type]then error(\"Unknown protocol '\"..ae.payload.type..\"'\")end;return fR.recv[ae.payload.type](b3,ae.payload)end;function fR.recv.arp(b3,ae)expect.field(ae,\"source\",\"number\")expect.field(ae,\"reply\",\"boolean\")syslog.debug(\"Received arp message from\",ae.source)if not ae.reply and ae.destinationIP and ae.sourceIP~=ae.destinationIP then local fG=fF(expect.field(ae,\"destinationIP\",\"string\"))if fO[b3.device.uuid]and fO[b3.device.uuid].ip==fG then fR.send.arp_reply(b3,ae.source,ae.sourceIP)end end;if ae.sourceIP then local fG=fF(expect.field(ae,\"sourceIP\",\"string\"))fQ[b3.device.uuid]=fQ[b3.device.uuid]or{}fQ[b3.device.uuid][fG]=ae.source;local gc={}for v,i in ipairs(fV.arp)do gc[v]=i end;for z,i in ipairs(gc)do i(i,ae.sourceIP,ae.source)end end end;function fR.recv.internet(b3,ae)b3.sourceIP=fF(expect.field(ae,\"source\",\"string\"))local bz=fF(expect.field(ae,\"destination\",\"string\"))b3.localIP=bz;syslog.debug(\"Received internet message from\",ae.source,\"to\",ae.destination)expect.field(ae,\"payload\",\"table\")if fW[expect.field(ae,\"messageID\",\"number\",\"string\")]then return end;fW[ae.messageID]=os.epoch\"utc\"if not fO[b3.device.uuid]or fO[b3.device.uuid].ip~=bz then return end;b3.ipPacket=ae;assert(ae.payload.PhoenixNetworking)expect.field(ae.payload,\"type\",\"string\")if not fR.recv[ae.payload.type]then error(\"Unknown protocol '\"..ae.payload.type..\"'\")end;return fR.recv[ae.payload.type](b3,ae.payload)end;function fR.recv.control(b3,ae)expect.field(ae,\"messageType\",\"string\")syslog.debug(\"Received control message\",ae.messageType)local a5=false;if ae.messageType==\"ping\"then fR.send.control({device=b3.device},b3.sourceIP,\"pong\",nil,b3.ipPacket)else for z,i in pairs(fU)do a5=i{type=\"control\",messageType=ae.messageType,error=ae.error,payload=ae.payload,sender=fH(b3.sourceIP)}or a5 end end;return a5 end;function fR.recv.socket(b3,ae)expect.field(ae,\"sequence\",\"number\")expect.field(ae,\"acknowledgement\",\"number\",\"nil\")expect.field(ae,\"windowSize\",\"number\",\"nil\")expect.field(ae,\"payload\",\"string\",\"nil\")if b3.channel==0 or b3.replyChannel==0 then syslog.debug(\"Received socket event on channel 0; discarding.\")return end;local g4=(fS[b3.channel]or{})[b3.replyChannel]or(fS[b3.channel]or{}).listen;if not g4 then if ae.acknowledgement then fR.send.socket.reset(b3,b3.sourceIP,b3.replyChannel,ae.acknowledgement,nil,b3.channel)else fR.send.socket.reset(b3,b3.sourceIP,b3.replyChannel,0,ae.sequence+(ae.windowSize or 0),b3.channel)end;return end;do local bn={}for h,i in pairs(g4)do if h~=\"process\"then bn[h]=i end end;syslog.debug(\"Received socket message:\",serialize(ae),\"\\nSocket info:\",serialize(bn))end;if g4.status==\"listening\"then if ae.reset then return end;if ae.acknowledgement then fR.send.socket.reset(b3,b3.sourceIP,b3.replyChannel,ae.acknowledgement,nil,b3.channel)return end;if not ae.synchronize then return end;g4.ip=b3.sourceIP;g4.localIP=fH(b3.localIP)g4.port=b3.replyChannel;g4.recvSeq=ae.sequence+1;g4.recvSeqMax=g4.recvSeq+(ae.windowSize or 0)g4.sendSeq=math.floor(math.random()*0x10000000000)g4.sendSeqNext=g4.sendSeq+2;g4.sendSeqMax=g4.sendSeq+(ae.windowSize or 0)g4.status=\"syn-received\"g4.nextUpdate=os.epoch\"utc\"+5000;g4.retryCount=0;fS[b3.channel][b3.replyChannel]=g4;fS[b3.channel].listen=nil;fR.send.internet({inPort=b3.channel,outPort=b3.replyChannel},g4.ip,{PhoenixNetworking=true,type=\"socket\",sequence=g4.sendSeqNext-1,acknowledgement=g4.recvSeq,windowSize=256,synchronize=true})elseif g4.status==\"syn-sent\"then if ae.reset then g4.status=\"error\"g4.error=\"Connection refused\"fS[b3.channel][b3.replyChannel]=nil;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={\"handle_status_change\",{id=g4.id,status=\"error\"}}end;return true end;if not ae.synchronize or not ae.acknowledgement or ae.acknowledgement<g4.sendSeq then fR.send.socket.reset(b3,b3.sourceIP,b3.replyChannel,ae.acknowledgement,nil,b3.channel)g4.status=\"error\"g4.error=\"Connection refused\"fS[b3.channel][b3.replyChannel]=nil;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={\"handle_status_change\",{id=g4.id,status=\"error\"}}end;return true end;g4.localIP=fH(b3.localIP)g4.status=\"connected\"g4.sendSeq=ae.acknowledgement;g4.sendSeqMax=g4.sendSeq+256;g4.recvSeq=ae.sequence+1;g4.recvSeqMax=g4.recvSeq+(ae.windowSize or 0)g4.outQueue={}g4.nextUpdate=os.epoch\"utc\"+2000;fR.send.socket.ack({},g4.recvSeq,g4)if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={\"handle_status_change\",{id=g4.id,status=\"connected\"}}end;return true else if ae.sequence<g4.recvSeq or ae.sequence>g4.recvSeqMax then syslog.debug(\"Sequence out of range\")if ae.reset then g4.status=\"error\"g4.error=\"Connection reset by peer\"fS[b3.channel][b3.replyChannel]=nil;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={\"handle_status_change\",{id=g4.id,status=\"error\"}}end;return true else fR.send.socket.ack({},g4.recvSeq,g4)return end end;if ae.reset then syslog.debug(\"Received reset\")if g4.status==\"syn-received\"then g4.status=\"listening\"return elseif g4.status==\"connected\"or g4.status==\"fin-wait\"then g4.status=\"error\"g4.error=\"Connection reset by peer\"fS[b3.channel][b3.replyChannel]=nil;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={\"handle_status_change\",{id=g4.id,status=\"error\"}}end;return true else g4.status=\"closed\"fS[b3.channel][b3.replyChannel]=nil;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={\"handle_status_change\",{id=g4.id,status=\"closed\"}}end;return true end end;if ae.synchronize then fR.send.socket.reset(b3,b3.sourceIP,b3.replyChannel,ae.acknowledgement,nil,b3.channel)g4.status=\"error\"g4.error=\"Connection reset by host\"fS[b3.channel][b3.replyChannel]=nil;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={\"handle_status_change\",{id=g4.id,status=\"error\"}}end;return true end;local a5;if not ae.acknowledgement then syslog.debug(\"No acknowledgement\")return end;if g4.status==\"syn-received\"then if ae.acknowledgement>=g4.sendSeq and ae.acknowledgement<=g4.sendSeqNext then g4.status=\"connected\"g4.outQueue={}g4.nextUpdate=os.epoch\"utc\"+2000;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={\"network_request\",{uri=g4.uri,ip=fH(b3.sourceIP),handle=gb(g4)}}end;a5=true else fR.send.socket.reset(b3,b3.sourceIP,b3.replyChannel,ae.acknowledgement,nil,b3.channel)g4.status=\"error\"g4.error=\"Connection reset by host\"fS[b3.channel][b3.replyChannel]=nil;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={\"handle_status_change\",{id=g4.id,status=\"error\"}}end;return true end elseif g4.status==\"close-wait\"then if ae.acknowledgement==g4.sendSeqMax then syslog.debug(\"Socket closed\")g4.status=\"closed\"fS[b3.channel][b3.replyChannel]=nil;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={\"handle_status_change\",{id=g4.id,status=\"closed\"}}end;return true end elseif g4.status==\"time-wait\"then if ae.final then fR.send.socket.ack({},ae.sequence,g4)g4.nextUpdate=os.epoch\"utc\"+10000;return end else if ae.acknowledgement>g4.sendSeq and ae.acknowledgement<=g4.sendSeqNext then for v=g4.sendSeq,ae.acknowledgement do g4.outQueue[v]=nil end;g4.sendSeq=ae.acknowledgement;if ae.windowSize then g4.sendSeqMax=g4.sendSeq+ae.windowSize end end;if g4.status==\"fin-wait\"then if ae.acknowledgement==g4.sendSeqMax then if not ae.final then fR.send.socket.reset(b3,b3.sourceIP,b3.replyChannel,ae.acknowledgement,nil,b3.channel)g4.status=\"error\"g4.error=\"Connection reset by host\"fS[b3.channel][b3.replyChannel]=nil;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={\"handle_status_change\",{id=g4.id,status=\"error\"}}end;return true end;g4.status=\"time-wait\"g4.nextUpdate=os.epoch\"utc\"+10000 end elseif g4.status==\"closing\"then if ae.acknowledgement==g4.sendSeqMax then g4.status=\"time-wait\"g4.nextUpdate=os.epoch\"utc\"+10000 end end end;if g4.status==\"connected\"and ae.sequence==g4.recvSeq then if ae.payload then g4.buffer=g4.buffer..ae.payload;g4.nextAck=true;g4.nextUpdate=os.epoch\"utc\"+100;if g4.process then syslog.debug(\"Sending data event to PID \"..g4.process.id)g4.process.eventQueue[#g4.process.eventQueue+1]={\"handle_data_ready\",{id=g4.id}}end;a5=true end;g4.recvSeq=g4.recvSeq+1 end;if ae.final then syslog.debug(\"Got final message\")g4.recvSeq=ae.sequence+1;if g4.status==\"syn-received\"or g4.status==\"connected\"then g4.sendSeqMax=g4.sendSeqNext;fR.send.socket.data({},{final=true,acknowledgement=ae.sequence},g4)g4.status=\"close-wait\"if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={\"handle_status_change\",{id=g4.id,status=\"closed\"}}end;return true elseif g4.status==\"fin-wait\"then fR.send.socket.ack({},ae.sequence,g4)if ae.acknowledgement~=g4.sendSeqMax then g4.status=\"closing\"else g4.status=\"time-wait\"g4.nextUpdate=os.epoch\"utc\"+10000 end else fR.send.socket.ack({},ae.sequence,g4)end;syslog.debug(g4.status)end;return a5 end end;local function gd()local c2=os.epoch\"utc\"local eg=false;for g3,ge in pairs(fS)do for gf,g4 in pairs(ge)do if c2>=g4.nextUpdate then if g4.status==\"syn-sent\"then g4.status=\"error\"g4.error=\"Connection timed out (syn-sent)\"fS[g3][gf]=nil;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={\"handle_status_change\",{id=g4.id,status=\"error\"}}eg=true end elseif g4.status==\"syn-received\"then g4.retryCount=g4.retryCount+1;if g4.retryCount>3 then g4.status=\"error\"g4.error=\"Connection timed out (syn-received)\"fS[g3][gf]=nil;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={\"handle_status_change\",{id=g4.id,status=\"error\"}}eg=true end else g4.nextUpdate=os.epoch\"utc\"+2000 end elseif g4.status==\"connected\"then for v=g4.sendSeq+1,g4.sendSeqNext-1 do if g4.outQueue[v]then fR.send.socket.data({},{sequence=v,payload=g4.outQueue[v]},g4)end end;if g4.nextAck then fR.send.socket.ack({},g4.recvSeq-1,g4)g4.nextAck=nil end;g4.nextUpdate=os.epoch\"utc\"+2000 elseif g4.status==\"fin-wait\"then elseif g4.status==\"close-wait\"then elseif g4.status==\"time-wait\"then syslog.debug(\"Time wait finished on port \"..g3)g4.status=\"closed\"fS[g3][gf]=nil end end end end;return eg end;eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(ar)if type(ar[5])==\"table\"and ar[5].PhoenixNetworking and type(ar[5].type)==\"string\"and fR.recv[ar[5].type]then local dw=getNodeById(ar[2])or hardware.get(ar[2])if not dw then syslog.log({level=\"notice\",module=\"Network\"},\"Received network event for device ID \"..ar[2]..\", but no device node was found; ignoring\")return end;if not fO[dw.uuid]or not fO[dw.uuid].up then return end;syslog.debug(ar[2],serialize(ar[5]))local bf,o=pcall(fR.recv[ar[5].type],{channel=ar[3],replyChannel=ar[4],device=dw},ar[5])if not bf then syslog.log({level=\"debug\",module=\"Network\"},\"Network event errored while processing:\",o)else return o end end end;local gg=os.startTimer(1)eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=function(ar)if ar[2]==gg then gg=os.startTimer(1)return gd()end end;local function gh(process,bC)local fE=fD(bC.url)if not fE.port then error(\"No port specified\")end;local fG=fF(fE.host)local g3=fE.port;local g4={process=process,buffer=\"\"}fR.send.socket.connect({process=process},fG,g3,g4)return gb(g4)end;local gi={}local gj={}local gk={}local gl=os.computerID()%65500;local gm={}eventHooks.http_success=eventHooks.http_success or{}eventHooks.http_success[#eventHooks.http_success+1]=function(ar)local b3=gi[ar[2]]if b3 then b3.handle,b3.status=ar[3],\"open\"b3.process.eventQueue[#b3.process.eventQueue+1]={\"handle_status_change\",{id=b3.id,status=\"open\"}}gi[ar[2]]=nil;return true else syslog.log({level=\"notice\"},\"Received HTTP response for \"..ar[2]..\" but nobody requested it; ignoring.\")end end;eventHooks.http_failure=eventHooks.http_failure or{}eventHooks.http_failure[#eventHooks.http_failure+1]=function(ar)local b3=gi[ar[2]]if b3 then if ar[4]then b3.handle,b3.status=ar[3],\"open\"else b3.status,b3.error=\"error\",ar[3]end;b3.process.eventQueue[#b3.process.eventQueue+1]={\"handle_status_change\",{id=b3.id,status=b3.status}}gi[ar[2]]=nil;return true else syslog.log({level=\"notice\"},\"Received HTTP response for \"..ar[2]..\" but nobody requested it; ignoring.\")end end;eventHooks.websocket_success=eventHooks.websocket_success or{}eventHooks.websocket_success[#eventHooks.websocket_success+1]=function(ar)local b3=gi[ar[2]]if b3 then b3.handle,b3.status=ar[3],\"open\"b3.process.eventQueue[#b3.process.eventQueue+1]={\"handle_status_change\",{id=b3.id,status=\"open\"}}return true else syslog.log({level=\"notice\"},\"Received WebSocket response for \"..ar[2]..\" but nobody requested it; ignoring.\")end end;eventHooks.websocket_failure=eventHooks.websocket_failure or{}eventHooks.websocket_failure[#eventHooks.websocket_failure+1]=function(ar)local b3=gi[ar[2]]if b3 then b3.status,b3.error=\"error\",ar[3]b3.process.eventQueue[#b3.process.eventQueue+1]={\"handle_status_change\",{id=b3.id,status=b3.status}}return true else syslog.log({level=\"notice\"},\"Received WebSocket response for \"..ar[2]..\" but nobody requested it; ignoring.\")end end;eventHooks.websocket_message=eventHooks.websocket_message or{}eventHooks.websocket_message[#eventHooks.websocket_message+1]=function(ar)local b3=gi[ar[2]]if b3 then b3.buffer=b3.buffer..ar[3]b3.process.eventQueue[#b3.process.eventQueue+1]={\"handle_data_ready\",{id=b3.id}}return true else syslog.log({level=\"notice\"},\"Received WebSocket message for \"..ar[2]..\" but nobody requested it; ignoring.\")end end;eventHooks.websocket_closed=eventHooks.websocket_closed or{}eventHooks.websocket_closed[#eventHooks.websocket_closed+1]=function(ar)local b3=gi[ar[2]]if b3 then b3.status=\"closed\"b3.process.eventQueue[#b3.process.eventQueue+1]={\"handle_status_change\",{id=b3.id,status=b3.status}}gi[ar[2]]=nil;return true else syslog.log({level=\"notice\"},\"Received WebSocket message for \"..ar[2]..\" but it's not open; ignoring.\")end end;eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(ar)local a5=false;if gj[ar[2]]and(ar[3]==gl or ar[3]==65535)and type(ar[5])==\"table\"and type(ar[5].nMessageID)==\"number\"and ar[5].nMessageID==ar[5].nMessageID and not gm[ar[5].nMessageID]and(ar[5].nRecipient and ar[5].nRecipient==os.computerID()or ar[3]==65535)then if gk[ar[5].nSender]then for z,i in ipairs(gk[ar[5].nSender])do if not i.protocol or i.protocol==ar[5].sProtocol then i.buffer[#i.buffer+1]=deepcopy(ar[5].message)gm[ar[5].nMessageID]=os.clock()+9.5;i.process.eventQueue[#i.process.eventQueue+1]={\"handle_data_ready\",{id=i.id}}a5=true end end end;if gk[0xFFFFFFFF]then for z,i in ipairs(gk[0xFFFFFFFF])do if not i.protocol or i.protocol==ar[5].sProtocol then i.buffer[#i.buffer+1]=deepcopy(ar[5].message)gm[ar[5].nMessageID]=os.clock()+9.5;i.process.eventQueue[#i.process.eventQueue+1]={\"handle_data_ready\",{id=i.id}}a5=true end end end;for h,i in pairs(gm)do if i<os.clock()then gm[h]=nil end end end;return a5 end;local gn=http.request;local function go(process,bC)expect.field(bC,\"encoding\",\"string\",\"nil\")expect.field(bC,\"headers\",\"table\",\"nil\")expect.field(bC,\"method\",\"string\",\"nil\")expect.field(bC,\"redirect\",\"boolean\",\"nil\")local b3={status=\"ready\",process=process,id=fN}local bv=setmetatable({id=fN},{__name=\"socket\"})fN=fN+1;function bv:status()return b3.status,b3.error end;function bv:read(n,...)if b3.status~=\"open\"then error(\"attempt to read from a \"..b3.status..\" handle\",2)end;n=n or\"*l\"if type(n)~=\"string\"and type(n)~=\"number\"then error(\"bad argument (expected string or number, got \"..type(n)..\")\",2)end;n=n:gsub(\"^%*\",\"\")if n==\"a\"then if select(\"#\",...)>0 then return b3.handle.readAll(),self:read(...)else return b3.handle.readAll()end elseif n==\"l\"then if select(\"#\",...)>0 then return b3.handle.readLine(false),self:read(...)else return b3.handle.readLine(false)end elseif n==\"L\"then if select(\"#\",...)>0 then return b3.handle.readLine(true),self:read(...)else return b3.handle.readLine(true)end elseif n==\"n\"then local a0;repeat a0=b3.handle.read(1)if not a0 then return nil end until tonumber(a0)while true do local a9=b3.handle.read(1)if not a9 or not a9:match\"%d\"then break end;a0=a0 ..a9 end;if select(\"#\",...)>0 then return tonumber(a0),self:read(...)else return tonumber(a0)end elseif type(n)==\"number\"then if select(\"#\",...)>0 then return b3.handle.read(n),self:read(...)else return b3.handle.read(n)end else error(\"bad argument (invalid mode '\"..n..\"')\",2)end end;function bv:write(...)if b3.status~=\"ready\"then error(\"attempt to write to a \"..b3.status..\" handle\",2)end;local bh;if select(\"#\",...)>0 then bh=\"\"for z,i in ipairs{...}do bh=bh..tostring(i)end end;local gp=bC.url..\"#\"..b3.id;local bf,o=gn{url=gp,body=bh,headers=bC.headers,binary=bC.encoding==\"binary\"or bC.encoding==nil,method=bC.method,redirect=bC.redirect}if bf then gi[gp]=b3;b3.status=\"connecting\"else b3.status,b3.error=\"error\",o end end;function bv:close()if b3.status~=\"open\"then error(\"attempt to close a \"..b3.status..\" handle\",2)end;b3.handle.close()b3.status=\"closed\"end;function bv:responseHeaders()if b3.status~=\"open\"then error(\"attempt to read from a \"..b3.status..\" handle\",2)end;return b3.handle.getResponseHeaders()end;function bv:responseCode()if b3.status~=\"open\"then error(\"attempt to read from a \"..b3.status..\" handle\",2)end;return b3.handle.getResponseCode()end;return bv end;local function gq(process,bC)expect.field(bC,\"encoding\",\"string\",\"nil\")expect.field(bC,\"headers\",\"table\",\"nil\")local b3={process=process,id=fN,buffer=\"\"}local bv=setmetatable({id=fN},{__name=\"socket\"})fN=fN+1;function bv:status()return b3.status,b3.error end;function bv:read(n,...)if b3.status~=\"open\"then error(\"attempt to read from a \"..b3.status..\" handle\",2)end;n=n or\"*l\"if type(n)~=\"string\"and type(n)~=\"number\"then error(\"bad argument (expected string or number, got \"..type(n)..\")\",2)end;if b3.buffer==\"\"then return nil end;n=n:gsub(\"^%*\",\"\")if n==\"a\"then local a0=b3.buffer;b3.buffer=\"\"return a0 elseif n==\"l\"then local a0,a7=b3.buffer:match\"^([^\\n]*)\\n?()\"if a0 then b3.buffer=b3.buffer:sub(a7)if select(\"#\",...)>0 then return a0,self:read(...)else return a0 end else return nil end elseif n==\"L\"then local a0,a7=b3.buffer:match\"^([^\\n]*\\n?)()\"if a0 then b3.buffer=b3.buffer:sub(a7)if select(\"#\",...)>0 then return a0,self:read(...)else return a0 end else return nil end elseif n==\"n\"then local a0,a7=b3.buffer:match\"(%d+)()\"if a0 then b3.buffer=b3.buffer:sub(a7)if select(\"#\",...)>0 then return tonumber(a0),self:read(...)else return tonumber(a0)end else return nil end elseif type(n)==\"number\"then local a0=b3.buffer:sub(1,n)b3.buffer=b3.buffer:sub(n+1)if select(\"#\",...)>0 then return a0,self:read(...)else return a0 end else error(\"bad argument (invalid mode '\"..n..\"')\",2)end end;function bv:write(bh,...)if b3.status~=\"open\"then error(\"attempt to write to a \"..b3.status..\" handle\",2)end;b3.handle.send(tostring(bh),bC.encoding==\"binary\")if select(\"#\",...)>0 then return self:write(...)end end;function bv:close()if b3.status~=\"open\"then error(\"attempt to close a \"..b3.status..\" handle\",2)end;b3.handle.close()b3.status=\"closed\"end;local gp=bC.url..\"#\"..b3.id;local bf,o=http.websocket(gp,bC.headers)if bf then gi[gp]=b3;b3.status=\"connecting\"else return nil,o end;return bv end;local function gr(process,bC)expect.field(bC,\"device\",\"string\",\"nil\")local gs;if bC.device then gs={hardware.get(bC.device)}else gs={hardware.find(\"modem\")}end;if#gs==0 then error(\"Could not find a modem\",2)end;for z,i in ipairs(gs)do fM(i)if not gj[i]then hardware.call(process,i,\"open\",gl)hardware.call(process,i,\"open\",65535)gj[i]=1 else gj[i]=gj[i]+1 end end;local fE=fD(bC.url)if not fE.host then error(\"Missing host\",2)end;local aA=fF(fE.host)local b3={process=process,id=fN,buffer={},protocol=fE.scheme:match\"rednet%+(.+)\"}local bv=setmetatable({id=fN},{__name=\"socket\"})fN=fN+1;function bv:status()return b3.closed and\"closed\"or\"open\"end;function bv:read(n,...)if b3.closed then error(\"attempt to read from a \"..b3.status..\" handle\",2)end;n=n or\"*l\"if type(n)~=\"string\"and type(n)~=\"number\"then error(\"bad argument (expected string or number, got \"..type(n)..\")\",2)end;if#b3.buffer==0 then return nil end;n=n:gsub(\"^%*\",\"\")if n==\"a\"then return table.remove(b3.buffer,1)elseif n==\"l\"then b3.buffer[1]=tostring(b3.buffer[1])local a0,a7=b3.buffer[1]:match\"^([^\\n]*)\\n?()\"if a0 then b3.buffer[1]=b3.buffer[1]:sub(a7)if select(\"#\",...)>0 then return a0,self:read(...)else return a0 end else table.remove(b3.buffer,1)return self:read(n,...)end elseif n==\"L\"then b3.buffer[1]=tostring(b3.buffer[1])local a0,a7=b3.buffer[1]:match\"^([^\\n]*\\n?)()\"if a0 then b3.buffer[1]=b3.buffer[1]:sub(a7)if select(\"#\",...)>0 then return a0,self:read(...)else return a0 end else table.remove(b3.buffer,1)return self:read(n,...)end elseif n==\"n\"then b3.buffer[1]=tostring(b3.buffer[1])local a0,a7=b3.buffer[1]:match\"(%d+)()\"if a0 then b3.buffer[1]=b3.buffer[1]:sub(a7)if select(\"#\",...)>0 then return tonumber(a0),self:read(...)else return tonumber(a0)end else table.remove(b3.buffer,1)return self:read(n,...)end elseif type(n)==\"number\"then local a0=\"\"while#a0<n do b3.buffer[1]=tostring(b3.buffer[1])a0=a0 ..b3.buffer[1]:sub(1,n-#a0)b3.buffer[1]=b3.buffer[1]:sub(n-#a0+1)if b3.buffer[1]==\"\"then table.remove(b3.buffer,1)end;if#b3.buffer==0 then break end end;if select(\"#\",...)>0 then return a0,self:read(...)else return a0 end else error(\"bad argument (invalid mode '\"..n..\"')\",2)end end;function bv:write(bh,...)if b3.closed then error(\"attempt to write to a \"..b3.status..\" handle\",2)end;local gt=math.random(1,0x7FFFFFFF)local e0={nMessageID=gt,nRecipient=aA,nSender=os.computerID(),message=bh,sProtocol=b3.protocol}if aA==os.computerID()then for z,i in ipairs(gs)do os.queueEvent(\"modem_message\",i.id,gl,gl,e0,0)end else gm[gt]=os.clock()+9.5;for z,i in ipairs(gs)do hardware.call(process,i,\"transmit\",aA==0xFFFFFFFF and 65535 or aA%65500,gl,e0)hardware.call(process,i,\"transmit\",65533,gl,e0)end end;if select(\"#\",...)>0 then return self:write(...)end end;function bv:close()if b3.closed then error(\"attempt to close a \"..b3.status..\" handle\",2)end;for z,i in ipairs(gs)do gj[i]=gj[i]-1;if gj[i]==0 then hardware.call(process,i,\"close\",gl)hardware.call(process,i,\"close\",65535)gj[i]=nil end end;b3.status=\"closed\"end;return bv end;uriSchemes={[\"https?\"]=go,[\"wss?\"]=gq,[\"rednet\"]=gr,[\"rednet%+%a+\"]=gr,[\"psp\"]=gh}function syscalls.connect(process,aq,bC)if type(bC)==\"string\"then bC={url=bC}end;expect(1,bC,\"table\")expect.field(bC,\"url\",\"string\")local fE=fD(bC.url)local bv,o;for h,i in pairs(uriSchemes)do if fE.scheme:match(h)then bv,o=i(process,bC)break end end;if not bv and not o then error(\"Invalid protocol \"..fE.scheme)end;if bv then for z,i in pairs(bv)do if type(i)==\"function\"then setfenv(i,process.env)debug.protect(i)end end end;return bv,o end;function syscalls.listen(process,aq,fE)expect(1,fE,\"string\")local gu=fD(fE)if http.addListener then if gu.scheme==\"http\"then http.addListener(gu.port or 80)return elseif gu.scheme==\"ws\"then http.websocket(gu.port or 80)return end end;if gu.scheme==\"psp\"then if not gu.port then error(\"Missing port\")end;local fG=fF(gu.host)for h,i in pairs(fO)do if i.up and(fG==0 or i.ip==fG)then hardware.call(process,hardware.get(h),\"open\",gu.port)end end;local g4={localPort=gu.port,id=fN,status=\"listening\",process=process,nextUpdate=math.huge,retryCount=0,uri=fE,buffer=\"\"}fN=fN+1;fS[gu.port]=fS[gu.port]or{}fS[gu.port].listen=g4;fT[g4.id]=g4;return end;error(\"Invalid protocol \"..gu.scheme)end;function syscalls.unlisten(process,aq,fE)end;function syscalls.ipconfig(process,aq,eR,b3)if b3 and process.user~=\"root\"then error(\"Permission denied\")end;expect(1,eR,\"string\")expect(2,b3,\"table\",\"nil\")local dw=fM(hardware.get(eR))local y=fO[dw.uuid]if not y then if b3 then expect.field(b3,\"ip\",\"string\",\"number\")expect.field(b3,\"netmask\",\"string\",\"number\")y={up=true}fO[dw.uuid]=y;hardware.call(KERNEL,dw,\"open\",0)else return nil end end;if b3 then expect.field(b3,\"ip\",\"string\",\"number\",\"nil\")expect.field(b3,\"netmask\",\"string\",\"number\",\"nil\")expect.field(b3,\"up\",\"boolean\",\"nil\")local gv,gw;if y.ip then for z,i in ipairs(fP[0])do if i.source==bit32.band(y.ip,y.netmask)and i.netmask==y.netmask then gv=i elseif i.source==bit32.bor(bit32.band(y.ip,y.netmask),bit32.bnot(y.netmask))and i.netmask==0xFFFFFFFF then gw=i end end end;if b3.ip then if fQ[dw.uuid]then fQ[dw.uuid][y.ip]=nil end;if type(b3.ip)==\"number\"then y.ip=bit32.band(b3.ip,0xFFFFFFFF)else y.ip=fF(b3.ip)end;if gv then gv.source=bit32.band(y.ip,y.netmask)end;if gw then gw.source=bit32.bor(bit32.band(y.ip,y.netmask),bit32.bnot(y.netmask))end;fQ[dw.uuid]=fQ[dw.uuid]or{}fQ[dw.uuid][y.ip]=os.computerID()end;if b3.netmask then if type(b3.netmask)==\"number\"then y.netmask=fK(b3.netmask)else y.netmask=fF(b3.netmask)end;if gv then gv.source=bit32.band(y.ip,y.netmask)end;if gw then gw.source=bit32.bor(bit32.band(y.ip,y.netmask),bit32.bnot(y.netmask))end end;if b3.up~=nil then y.up=b3.up;if y.up then hardware.call(KERNEL,dw,\"open\",0)else hardware.call(KERNEL,dw,\"close\",0)end end;if not gv then fP[0][#fP[0]+1]={source=bit32.band(y.ip,y.netmask),sourceNetmask=y.netmask,action=\"local\",device=dw}end;if not gw then fP[0][#fP[0]+1]={source=bit32.bor(bit32.band(y.ip,y.netmask),bit32.bnot(y.netmask)),sourceNetmask=0xFFFFFFFF,action=\"broadcast\",device=dw}end end;return{ip=fH(y.ip),netmask=fL(y.netmask),up=y.up}end;function syscalls.routelist(process,aq,b)b=expect(1,b,\"number\",\"nil\")or 1;expect.range(b,0)if not fP[b]then return nil end;local a5={}for v,y in ipairs(fP[b])do a5[v]={source=fH(y.source),sourceNetmask=fL(y.sourceNetmask),action=y.action,device=y.device and hardware.path(y.device),destination=y.destination and fH(y.destination)}end;return a5 end;local gx={unicast=true,broadcast=true,[\"local\"]=true,unreachable=true,prohibit=true,blackhole=true}function syscalls.routeadd(process,aq,bC)if process.user~=\"root\"then error(\"Permission denied\")end;expect(1,bC,\"table\")expect.field(bC,\"source\",\"string\",\"number\")expect.field(bC,\"sourceNetmask\",\"string\",\"number\")expect.field(bC,\"action\",\"string\")expect.field(bC,\"device\",\"string\",bC.action~=\"unicast\"and bC.action~=\"broadcast\"and bC.action~=\"local\"and\"nil\"or nil)expect.field(bC,\"destination\",\"string\",bC.action~=\"unicast\"and\"nil\"or nil)expect.range(expect.field(bC,\"table\",\"number\",\"nil\")or 1,1)bC.table=bC.table or 1;if not gx[bC.action]then error(\"bad field 'action' (invalid option '\"..bC.action..\"')\")end;local y={}if type(bC.source)==\"number\"then y.source=bit32.band(bC.source,0xFFFFFFFF)else y.source=fF(bC.source)end;if type(bC.sourceNetmask)==\"number\"then y.sourceNetmask=fK(bC.sourceNetmask)else y.sourceNetmask=fF(bC.sourceNetmask)end;y.source=bit32.band(y.source,y.sourceNetmask)y.action=bC.action;y.device=bC.device and fM(hardware.get(bC.device))y.destination=bC.destination and fF(bC.destination)fP[bC.table]=fP[bC.table]or{}for z,i in ipairs(fP[bC.table])do if i.source==y.source and i.sourceNetmask==y.sourceNetmask then error(\"Route already exists\")end end;fP[bC.table][#fP[bC.table]+1]=y;fP.maxn=math.max(fP.maxn,bC.table)end;function syscalls.routedel(process,aq,gy,w,b)if process.user~=\"root\"then error(\"Permission denied\")end;expect(1,gy,\"string\",\"number\")expect(2,w,\"string\",\"number\")b=expect(3,b,\"number\",\"nil\")or 1;expect.range(b,1)if type(w)==\"number\"then w=fK(w)else w=fF(w)end;if type(gy)==\"number\"then gy=bit32.band(gy,w)else gy=bit32.band(fF(gy),w)end;if not fP[b]then error(\"Route table does not exist\")end;for v,i in ipairs(fP[b])do if i.source==gy and i.sourceNetmask==w then table.remove(fP[b],v)return end end end;function syscalls.arplist(process,aq,eR)expect(1,eR,\"string\")local dw=fM(hardware.get(eR))local a5={}for h,i in pairs(fQ[dw.uuid]or{})do a5[fH(h)]=i end;return a5 end;function syscalls.arpset(process,aq,eR,fG,aA)if process.user~=\"root\"then error(\"Permission denied\")end;expect(1,eR,\"string\")expect(2,fG,\"string\",\"number\")expect(3,aA,\"number\")local dw=fM(hardware.get(eR))if type(fG)==\"string\"then fG=fF(fG)else fG=bit32.band(fG,0xFFFFFFFF)end;fQ[dw.uuid]=fQ[dw.uuid]or{}fQ[dw.uuid][fG]=aA end;local gz={ping=true,pong=true,unreachable=true,timeout=true}function syscalls.netcontrol(process,aq,fG,gA,o)if process.user~=\"root\"then error(\"Permission denied\")end;expect(1,fG,\"string\",\"number\")expect(2,gA,\"string\")expect(3,o,\"string\",\"nil\")if not gz[gA]then error(\"bad argument #2 (invalid option '\"..gA..\"')\")end;if type(fG)==\"string\"then fG=fF(fG)else fG=bit32.band(fG,0xFFFFFFFF)end;fR.send.control({process=process},fG,gA,o)end;function syscalls.netevent(process,aq,db)if process.user~=\"root\"then error(\"Permission denied\")end;expect(1,db,\"boolean\",\"nil\")if db==true then fU[process]=function(ae)process.eventQueue[#process.eventQueue+1]={\"network_event\",deepcopy(ae)}return true end elseif db==false then fU[process]=nil end;return fU[process]~=nil end;function syscalls.checkuri(process,aq,fE)end;function registerLoopback()local dw=hardware.get(\"/lo\")if dw then fO[dw.uuid]={ip=0x7F000001,netmask=0xFF000000,up=true}fP[0][#fP[0]+1]={source=0x7F000000,sourceNetmask=0xFF000000,action=\"local\",device=dw}fP[0][#fP[0]+1]={source=0x7FFFFFFF,sourceNetmask=0xFFFFFFFF,action=\"broadcast\",device=dw}fQ[dw.uuid]=setmetatable({},{__index=function()return os.computerID()end})syslog.log(\"Configured IP for loopback device\")end end;function syscalls.listmodules()local a5={}for h in pairs(modules)do a5[#a5+1]=h end;return a5 end;function syscalls.loadmodule(process,aq,bb)expect(1,bb,\"string\")if process.user~=\"root\"then error(\"Could not load kernel module: Permission denied\",2)end;local bD=filesystem.stat(process,bb)if bD.type==\"directory\"then error(\"Could not load kernel module: Is a directory\",2)end;if bD.owner~=\"root\"or bD.worldPermissions.write then error(\"Insecure permissions set on kernel module, refusing to load\",2)end;local m=bb:match\"([^%./]+)[^/]*$\"syslog.log(\"Loading kernel module \"..m..\" from \"..bb)local a,o=filesystem.open(process,bb,\"rb\")if a then local bh=a.readAll()or\"\"a.close()local g,o=load(bh,\"@\"..bb)if g then local bf,u=pcall(g,bb)if bf then modules[m]=u or true else syslog.log({level=\"error\"},\"Kernel module \"..m..\" threw an error:\",u)end else syslog.log({level=\"error\"},\"Could not load \"..m..\":\",o)end else syslog.log({level=\"error\"},\"Could not open \"..bb..\":\",o)end end;function syscalls.unloadmodule(process,aq,m)expect(1,m,\"string\")if process.user~=\"root\"then error(\"Could not load kernel module: Permission denied\",2)end;if type(modules[m])==\"table\"and modules[m].unload then modules[m].unload(process,aq)end;modules[m]=nil end;function syscalls.callmodule(process,aq,m,az,...)expect(1,m,\"string\")expect(2,az,\"string\")if not modules[m]then error(\"Module '\"..m..\"' does not exist\",2)elseif type(modules[m])~=\"table\"then error(\"Module '\"..m..\"' does not have a callable interface\",2)elseif az==\"unload\"or type(modules[m][az])~=\"function\"then error(\"Module '\"..m..\"' does not have a method '\"..az..\"'\",2)end;return modules[m][az](process,aq,...)end;syslog.log(\"Loading kernel modules from /lib/modules\")local bf,gB=pcall(filesystem.list,KERNEL,\"/lib/modules\")if bf then for z,i in ipairs(gB)do local E=filesystem.combine(\"/lib/modules\",i)local bD=filesystem.stat(KERNEL,E)if bD.type~=\"directory\"then local bf,o=pcall(syscalls.loadmodule,KERNEL,nil,E)if not bf then syslog.log({level=\"error\"},\"Could not load module from \"..E..\": \"..o)end end end else syslog.log({level=\"notice\"},\"Could not open /lib/modules:\",gB)end;xpcall(hardware.register,function(error)panic(\"An error occurred while registering devices: \"..error)end,deviceTreeRoot,rootDriver)local ap={n=0}local gC=processes[syscalls.fork(KERNEL,nil,function()end,\"init\")]local gD=gC.id;local gE,gF;if args.init then gE,gF=pcall(syscalls.exec,gC,nil,args.initrd and\"/init\"or args.init)end;if not gE then syslog.log({level=\"error\",process=0},\"Could not load init:\",gF)syslog.log(\"Could not find provided init, trying default locations\")for z,i in ipairs{\"/sbin/init\",\"/etc/init\",\"/bin/init\",\"/bin/sh\"}do syslog.log(\"Trying\",i)gE,gF=pcall(syscalls.exec,gC,nil,i)if not gE then syslog.log({level=\"error\",process=0},\"Could not load init:\",gF)end;if gE then break end end;if not gE then panic(\"No working init found\")end end;syslog.log(\"Starting init from \"..processes[gD].name)local at=false;local gG=coroutine.yield;function coroutine.yield(...)if coroutine.running()==mainThread then error(\"attempt to yield from kernel main thread\",2)end;return gG(...)end;debug.protect(coroutine.yield)eventHooks.key=eventHooks.key or{}eventHooks.key[#eventHooks.key+1]=function(ar)if keysHeld.ctrl and keysHeld.shift and ar[2]==keys.f10 then term.clear()term.setCursorPos(1,1)term.write(\"Entering debug console.\")local q=2;local aW=true;term.setCursorPos(1,q)while aW do local aj=\"\"local af,ag=term.getSize()term.write(\"lua> \")term.setCursorBlink(true)while true do local ar={gG()}if ar[1]==\"char\"or ar[1]==\"paste\"then aj=aj..ar[2]term.write(ar[2])elseif ar[1]==\"key\"then if ar[2]==keys.backspace and#aj>0 then aj=aj:sub(1,-2)term.setCursorPos(term.getCursorPos()-1,q)term.write(\" \")term.setCursorPos(term.getCursorPos()-1,q)elseif ar[2]==keys.enter then break end end end;q=q+1;if q>ag then q=q-1;term.scroll(1)end;term.setCursorPos(1,q)local g,o=load(\"return \"..aj,\"=lua\",\"t\",setmetatable({exit=function()aW=false end},{__index=_G}))if not g then g,o=load(aj,\"=lua\",\"t\",setmetatable({exit=function()aW=false end},{__index=_G}))end;if g then local u=table.pack(pcall(g))if u[1]then for v=2,u.n do term.write(tostring(u[v]))q=q+1;if q>ag then q=q-1;term.scroll(1)end;term.setCursorPos(1,q)end else term.setTextColor(16384)term.write(u[2])term.setTextColor(1)q=q+1;if q>ag then q=q-1;term.scroll(1)end;term.setCursorPos(1,q)end else term.setTextColor(16384)term.write(o)term.setTextColor(1)q=q+1;if q>ag then q=q-1;term.scroll(1)end;term.setCursorPos(1,q)end end;term.setCursorBlink(false)term.clear()terminal.redraw(currentTTY,true)end end;local gH={char=true,key=true,key_up=true,mouse_click=true,mouse_up=true,mouse_drag=true,mouse_scroll=true,paste=true}local bf,o=xpcall(function()while processes[gD]do if not at then os.queueEvent(\"__event_queue_back\")end;while true do local ar=table.pack(gG())local m=ar[1]if m==\"__event_queue_back\"then break end;local gI=false;if eventHooks[m]then for z,i in ipairs(eventHooks[m])do gI=i(ar)or gI end end;if eventParameterMap[m]then local av={}for v=2,#eventParameterMap[m]+1 do av[eventParameterMap[m][v-1]]=ar[v]end;if m==\"key\"or m==\"key_up\"then av.keycode=keymap[av.keycode]av.ctrlHeld=keysHeld.ctrl;av.altHeld=keysHeld.alt;av.shiftHeld=keysHeld.shift end;if gH[m]and currentTTY.frontmostProcess then currentTTY.frontmostProcess.eventQueue[#currentTTY.frontmostProcess.eventQueue+1]={m,av}gI=true elseif m==\"timer\"or m==\"alarm\"then local gJ;if m==\"timer\"then gJ=timerMap[ar[2]]else gJ,av.id=alarmMap[ar[2]],bit32.bor(av.id,0x80000000)end;if gJ then gJ.eventQueue[#gJ.eventQueue+1],gI={m,av},true end end end;if at and gI then break end end;at=true;for cM,process in pairs(processes)do if cM~=0 and not process.paused then local fh,ar=false,nil;local as=true;for fi,aq in pairs(process.threads)do if not fh and aq.status==\"suspended\"then ar=table.remove(process.eventQueue,1)fh=true end;if ar or aq.status~=\"suspended\"then local gK;as,gK=executeThread(process,aq,ar or ap,as,at)at=gK and at else as=false end end;if as then process.isDead=true;if process.lastReturnValue then if cM==gD then init_retval=process.lastReturnValue.value or process.lastReturnValue.error elseif processes[process.parent]then process.lastReturnValue.id=cM;processes[process.parent].eventQueue[#processes[process.parent].eventQueue+1]={\"process_complete\",process.lastReturnValue}end end;reap_process(process)processes[cM]=nil;at=false end end end;terminal.redraw(currentTTY)end end,debug.traceback)if not bf then syslog.log({level=\"critical\",traceback=true},o)end;if postkill then postkill()end;if init_retval~=nil then syslog.log({level=4},\"init exited with result\",init_retval)end;panic(\"init program exited\")\n",created=1704748610119,setuser=false,worldPermissions={execute=true,write=false,read=true},owner="root",type="file",permissions={root={execute=true,write=true,read=true}},size=243856},["config.lua.d"]={modified=1704748612344,created=1704748612344,contents={["99-craftos.lua"]={modified=1704748612340,data="menuentry\"CraftOS\"{description\"Boot into CraftOS.\",craftos}\n",created=1704748612344,owner="root",setuser=false,worldPermissions={execute=false,write=false,read=true},type="file",permissions={root={execute=false,write=true,read=true}},size=60}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0}},owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},root={modified=1704748613177,created=1704748613177,contents={},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0},bin={modified=1704748612788,created=1704748612788,contents={["curl.lua"]={modified=1704748610364,data="local a=require\"system.network\"local b=require\"system.serialization\"local c=require\"system.util\"local function d(e)return e:gsub(\"[^A-Za-z0-9%-_%.~]\",function(f)return(\"%%%02X\"):format(f:byte())end)end;local g={[100]=\"Continue\",[101]=\"Switching Protocols\",[102]=\"Processing\",[200]=\"OK\",[201]=\"Created\",[202]=\"Accepted\",[203]=\"Non-authoritative Information\",[204]=\"No Content\",[205]=\"Reset Content\",[206]=\"Partial Content\",[207]=\"Multi-Status\",[208]=\"Already Reported\",[226]=\"IM Used\",[300]=\"Multiple Choices\",[301]=\"Moved Permanently\",[302]=\"Found\",[303]=\"See Other\",[304]=\"Not Modified\",[305]=\"Use Proxy\",[307]=\"Temporary Redirect\",[308]=\"Permanent Redirect\",[400]=\"Bad Request\",[401]=\"Unauthorized\",[402]=\"Payment Required\",[403]=\"Forbidden\",[404]=\"Not Found\",[405]=\"Method Not Allowed\",[406]=\"Not Acceptable\",[407]=\"Proxy Authentication Required\",[408]=\"Request Timeout\",[409]=\"Conflict\",[410]=\"Gone\",[411]=\"Length Required\",[412]=\"Precondition Failed\",[413]=\"Payload Too Large\",[414]=\"Request-URI Too Long\",[415]=\"Unsupported Media Type\",[416]=\"Requested Range Not Satisfiable\",[417]=\"Expectation Failed\",[418]=\"I'm a teapot\",[421]=\"Misdirected Request\",[422]=\"Unprocessable Entity\",[423]=\"Locked\",[424]=\"Failed Dependency\",[426]=\"Upgrade Required\",[428]=\"Precondition Required\",[429]=\"Too Many Requests\",[431]=\"Request Header Fields Too Large\",[444]=\"Connection Closed Without Response\",[451]=\"Unavailable For Legal Reasons\",[499]=\"Client Closed Request\",[500]=\"Internal Server Error\",[501]=\"Not Implemented\",[502]=\"Bad Gateway\",[503]=\"Service Unavailable\",[504]=\"Gateway Timeout\",[505]=\"HTTP Version Not Supported\",[506]=\"Variant Also Negotiates\",[507]=\"Insufficient Storage\",[508]=\"Loop Detected\",[510]=\"Not Extended\",[511]=\"Network Authentication Required\",[599]=\"Network Connect Timeout Error\"}local h=assert(c.argparse({[\"\"]={stopProcessingOnPositionalArgument=true},A=true,[\"user-agent\"]=\"@A\",b=true,cookie=\"@b\",c=true,[\"cookie-jar\"]=\"@c\",d=\"multiple\",data=\"@d\",[\"data-ascii\"]=\"@d\",D=true,[\"dump-header\"]=\"@D\",e=true,referer=\"@e\",G=false,get=\"@G\",H=\"multiple\",header=\"@H\",I=false,head=\"@I\",i=false,include=\"@i\",J=false,[\"remote-header-name\"]=\"@J\",L=false,location=\"@L\",o=false,output=\"@o\",O=false,[\"remote-name\"]=\"@O\",r=true,range=\"@r\",R=false,run=\"@R\",s=false,silent=\"@s\",S=false,[\"show-error\"]=\"@S\",T=true,[\"upload-file\"]=\"@T\",u=true,user=\"@u\",v=false,verbose=\"@v\",X=true,request=\"@X\",[\"#\"]=false,[\"progress-bar\"]=\"@#\",basic=false,[\"data-binary\"]=\"multiple\",[\"data-raw\"]=\"multiple\",[\"data-urlencode\"]=\"multiple\",digest=false,[\"disallow-username-in-url\"]=false,[\"doh-url\"]=true,json=true,[\"location-trusted\"]=false,[\"oauth2-bearer\"]=true,[\"output-dir\"]=true,post301=false,post302=false,post303=false,retry=\"number\",[\"retry-delay\"]=\"number\",h=false,help=\"@h\"},...))if h.h then print[[\nUsage: curl [options...] URL\nOptions:\n  -o, --output <path>     Path to write to\n  -H, --header <header>   Add a header to the request\n      --run               Run the file as a Lua script\n  -h, --help              Show this help\n]]return end;local i=h[1]if not i then error(\"curl: Missing URL.\")end;local j={}if h.H then for k,l in ipairs(h.H)do local m,n=l:match(\"^([^:]+):%s*(.+)$\")if not m then error(\"curl: Malformed header \"..l)end;j[m]=n end end;if h.A then j[\"User-Agent\"]=h.A end;if h.b then end;if h.c then end;if h.e then j[\"Referer\"]=h.e end;if h.u then if not h.u:find\":\"then io.stdout:write(\"Password: \")terminal.termctl({echo=false})h.u=h.u..\":\"..io.stdin:read()terminal.termctl({echo=true})print()end;if h.basic then j[\"Authorization\"]=\"Basic \"..b.base64.encode(h.u)elseif h.digest then elseif h[\"oauth2-bearer\"]then j[\"Authorization\"]=\"Bearer \"..h[\"oauth2-bearer\"]else i=i:gsub(\"^(https?://)\",\"%1\"..h.u)end end;local o;if h.d then for k,l in ipairs(h.d)do if o then o=o..\"&\"else o=\"\"end;if l:sub(1,1)==\"@\"then local p=l:sub(2):gsub(\"[\\r\\n]\",\"\")local q,r=io.open(p,\"r\")if not q then error(\"curl: Could not open \"..p..\": \"..r)end;o=o..q:read(\"*a\")q:close()else o=o..l end end end;if h[\"data-raw\"]then for k,l in ipairs(h[\"data-raw\"])do if o then o=o..\"&\"else o=\"\"end;o=o..l end end;if h[\"data-binary\"]then for k,l in ipairs(h[\"data-binary\"])do if o then o=o..\"&\"else o=\"\"end;if l:sub(1,1)==\"@\"then local p=l:sub(2):gsub(\"[\\r\\n]\",\"\")local q,r=io.open(p,\"rb\")if not q then error(\"curl: Could not open \"..p..\": \"..r)end;o=o..q:read(\"*a\")q:close()else o=o..l end end end;if h[\"data-urlencode\"]then for k,l in ipairs(h[\"data-urlencode\"])do if o then o=o..\"&\"else o=\"\"end;local s,t=l:match\"^([^=]+)=(.+)$\"local u,p=l:match\"^([^@]*)@(.*)$\"if s then o=o..s..\"=\"..d(t)elseif u then if u~=\"\"then o=o..u..\"=\"end;local q,r=io.open(p,\"r\")if not q then error(\"curl: Could not open \"..p..\": \"..r)end;o=o..d(q:read(\"*a\"))q:close()else o=o..l end end end;if h.json then if o then o=o..\"&\"else o=\"\"end;if h.json:sub(1,1)==\"@\"then local p=h.json:sub(2):gsub(\"[\\r\\n]\",\"\")local q,r=io.open(p,\"rb\")if not q then error(\"curl: Could not open \"..p..\": \"..r)end;o=o..q:read(\"*a\")q:close()else o=o..h.json end;j[\"Content-Type\"]=\"application/json\"j[\"Accept\"]=\"application/json\"end;local v;if h.X then v=h.X:upper()elseif h.G then v=\"GET\"if o then i=i..\"?\"..o end elseif h.I then v=\"HEAD\"elseif h.T then v=\"PUT\"local q,r=io.open(h.T,\"rb\")if not q then error(\"curl: Could not open \"..h.T..\": \"..r)end;o=q:read(\"*a\")q:close()elseif o then v=\"POST\"else v=\"GET\"end;if h.v then io.stderr:write(\"* Opening connection to \"..i:match(\"^https?://([^/]+)\")..\"\\n\")io.stderr:write(\"> GET \"..i:match(\"^https?://[^/]+(/[^#]+)\")..\" HTTP/1.1\\n\")for m,l in pairs(j)do io.stderr:write(\"> \"..m..\": \"..l..\"\\n\")end;io.stderr:write(\"> \\n\")end;local w;for k=0,h.retry or 0 do w=a.connect{url=i,method=v,headers=j,redirect=h.L}w:write(o)local x=false;while true do local y,z=coroutine.yield()if y==\"handle_status_change\"and z.id==w.id then if z.status==\"open\"then x=true;break elseif z.status==\"error\"then io.stderr:write(select(2,w:status()))w=nil;break end end end;if x then break end end;if not w then return false end;local A=w:responseCode()local B=w:responseHeaders()if h.o then io.output(h.o)elseif h.O then local s=i:gsub(\"%?.*$\",\"\"):gsub(\"#.*$\",\"\"):match(\"([^/]+)/*$\")if h.J then s=B[\"Content-Disposition\"]or s end;if h[\"output-dir\"]then s=h[\"output-dir\"]..\"/\"..s end;io.output(s)end;if h.v or h.i then local C=function(D)return io.write(D)end;if h.v then C=function(D)return io.stderr:write(\"< \"..D)end end;C(\"HTTP/1.1 \"..A..\" \"..(g[A]or\"Unknown\"))for m,l in pairs(B)do C(m..\": \"..l)end;C(\"\")end;if h.D then local q,r=io.open(h.D,\"w\")if q then for m,l in pairs(B)do q:write(m..\": \"..l..\"\\n\")end;q:close()else io.stderr:write(\"curl: Could not open header dump file: \"..r..\"\\n\")end end;if h.R then if math.floor(A/100)~=2 then error(\"curl: Got HTTP response \"..A..\", not running data.\")end;local s=i:gsub(\"%?.*$\",\"\"):gsub(\"#.*$\",\"\"):match(\"([^/]+)/*$\")if h.J then s=B[\"Content-Disposition\"]or s end;local E,r=load(function()return w:read(\"*L\")end,\"=\"..s)if not E then error(\"curl: Could not load file: \"..r)end;return E(table.unpack(h,2,h.n))end;io.write(w:read(\"*a\"))w:close()io.output():close()\n",created=1704748610408,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=7063},["whoami.lua"]={modified=1704748610393,data="local a=require\"system.process\"local b=a.getuser()print(b)\n",created=1704748610433,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=59},["kill.lua"]={modified=1704748610372,data="local a=require\"system.ipc\"local b={}local c=a.signal.SIGTERM;local d;for e,f in ipairs{...}do if d then c,d=a.signal[\"SIG\"..f]or c,nil elseif f:sub(1,1)==\"-\"then f=f:sub(2)if f==\"s\"then d=true elseif f==\"l\"then b.l=true elseif a.signal[\"SIG\"..f]then c=a.signal[\"SIG\"..f]elseif tonumber(f)then c=tonumber(f)else error(\"unknown argument \"..f)end else b[#b+1]=assert(tonumber(f),\"invalid PID \"..f)end end;if b.l then if b[1]then for g,f in pairs(a.signal)do if f==b[1]then print(g:sub(4))return end end;print(\"UNKNOWN\")return false else for g,f in pairs(a.signal)do io.write(g:sub(4)..\" \")end;print()end else for e,f in ipairs(b)do a.kill(f,c)end end\n",created=1704748610414,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=649},["false.lua"]={modified=1704748610370,data="return false\n",created=1704748610413,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=13},["nice.lua"]={modified=1704748610382,data="local a=require\"system.process\"local b=require\"system.util\"local c=assert(b.argparse({n=\"number\"},...))if not c[1]then error(\"Usage: nice [-n <increment>] <program> [args...]\")end;local d=a.fork(function()a.nice(c.n or 10)a.execp(table.unpack(c))end,c[1])local e,f;repeat e,f=coroutine.yield()until e==\"process_complete\"and f.id==d;return f.value\n",created=1704748610421,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=347},["tar.lua"]={modified=1704748612779,data="local a=require\"tar\"local b=require\"system.filesystem\"local c=require\"system.process\"local function d(e,f,g)return string.len(e)<f and string.sub(e,1,f)..string.rep(g or\" \",f-string.len(e))or e end;local function h(e,f,g)return string.len(e)<f and string.rep(g or\" \",f-string.len(e))..string.sub(e,1,f)or e end;local function i(j)return 0x38+(j.worldPermissions.read and 4 or 0)+(j.worldPermissions.write and 2 or 0)+(j.worldPermissions.execute and 1 or 0)+(j.permissions[j.owner].read and 256 or 0)+(j.permissions[j.owner].write and 128 or 0)+(j.permissions[j.owner].execute and 64 or 0)end;local function k(l,e,g)local m=\"\"for n=1,string.len(e)do m=m..(bit32.band(l,bit32.lshift(1,string.len(e)-n))==0 and g or string.sub(e,n,n))end;return m end;local o=[=[Usage: tar [OPTION...] [FILE]...\nPhoenix 'tar' saves many files together into a single tape or disk archive, and\ncan restore individual files from the archive.\n\nExamples:\n  tar -cf archive.tar foo bar  # Create archive.tar from files foo and bar.\n  tar -tvf archive.tar         # List all files in archive.tar verbosely.\n  tar -xf archive.tar          # Extract all files from archive.tar.\n\n Local file name selection:\n\n      --add-file=FILE        add given FILE to the archive (useful if its name\n                             starts with a dash)\n  -C, --directory=DIR        change to directory DIR\n      --no-null              disable the effect of the previous --null option\n      --no-recursion         avoid descending automatically in directories\n      --null                 -T reads null-terminated names; implies\n                             --verbatim-files-from\n      --recursion            recurse into directories (default)\n  -T, --files-from=FILE      get names to extract or create from FILE\n\n Main operation mode:\n\n  -A, --catenate, --concatenate   append tar files to an archive\n  -c, --create               create a new archive\n  -d, --diff, --compare      find differences between archive and file system\n      --delete               delete from the archive (not on mag tapes!)\n  -r, --append               append files to the end of an archive\n  -t, --list                 list the contents of an archive\n  -u, --update               only append files newer than copy in archive\n  -x, --extract, --get       extract files from an archive\n\n Overwrite control:\n\n  -k, --keep-old-files       don't replace existing files when extracting,\n                             treat them as errors\n      --overwrite            overwrite existing files when extracting\n      --remove-files         remove files after adding them to the archive\n  -W, --verify               attempt to verify the archive after writing it\n\n Device selection and switching:\n\n  -f, --file=ARCHIVE         use archive file or device ARCHIVE\n\n Device blocking:\n\n  -i, --ignore-zeros         ignore zeroed blocks in archive (means EOF)\n\n Compression options:\n\n  -z, --gzip, --gunzip, --ungzip   filter the archive through gzip\n\n Local file selection:\n\n  -N, --newer=DATE-OR-FILE, --after-date=DATE-OR-FILE\n                             only store files newer than DATE-OR-FILE\n\n Informative output:\n\n  -v, --verbose              verbosely list files processed\n\n Other options:\n\n  -?, --help                 give this help list\n      --usage                give a short usage message\n      --version              print program version]=]local p={...}local q=nil;local r={}local s=nil;local t=nil;local u=true;local v=false;local w=false;local x=nil;local y=false;local z=false;local A=nil;local B=0;local C=false;local D=false;for E,F in ipairs(p)do if t then if t==0 then q=F elseif t==1 then x=F elseif t==2 then A=F elseif t==3 then B=tonumber(F)elseif t==4 then local G=b.open(F,\"r\")local H=G.readLine()while H~=nil do if C then table.insert(r,H)else table.insert(p,H)end;H=G.readLine()end;G.close()end;t=nil elseif E==1 or string.sub(F,1,1)==\"-\"and string.sub(F,2,2)~=\"-\"then if string.find(F,\"A\")then s=0 end;if string.find(F,\"d\")then s=2 end;if string.find(F,\"c\")then s=1 end;if string.find(F,\"r\")then s=3 end;if string.find(F,\"t\")then s=4 end;if string.find(F,\"u\")then s=5 end;if string.find(F,\"x\")then s=6 end;if string.find(F,\"f\")then t=0 end;if string.find(F,\"k\")then u=false end;if string.find(F,\"U\")then v=true end;if string.find(F,\"W\")then w=true end;if string.find(F,\"O\")then x=0 end;if string.find(F,\"p\")then y=true end;if string.find(F,\"i\")then a.ignore_zero=true end;if string.find(F,\"z\")then z=true end;if string.find(F,\"C\")then t=1 end;if string.find(F,\"K\")then t=2 end;if string.find(F,\"N\")then t=3 end;if string.find(F,\"T\")then t=4 end;if string.find(F,\"v\")then a.verbosity=1 end;if string.find(F,\"?\")then print(o)return 2 end elseif string.sub(F,1,2)==\"--\"then if F==\"--catenate\"then s=0 elseif F==\"--concatenate\"then s=0 elseif F==\"--create\"then s=1 elseif F==\"--diff\"then s=2 elseif F==\"--compare\"then s=2 elseif F==\"--delete\"then s=7 elseif F==\"--append\"then s=3 elseif F==\"--list\"then s=4 elseif F==\"--update\"then s=5 elseif F==\"--extract\"then s=6 elseif F==\"--get\"then s=6 elseif F==\"--help\"or F==\"--usage\"then print(o)return 2 elseif F==\"--version\"then print(\"Phoenix tar v1.0\")return 2 elseif F==\"--keep-old-files\"then u=false elseif F==\"--overwrite\"then u=true elseif F==\"--remove-files\"then v=true elseif F==\"--unlink-first\"then v=true elseif F==\"--verify\"then w=true elseif F==\"--to-stdout\"then x=0 elseif F==\"--preserve-permissions\"then y=true elseif F==\"--same-permissions\"then y=true elseif F==\"--preserve\"then y=true elseif string.find(F,\"--file=\")then q=string.sub(F,8)elseif F==\"--ignore-zeros\"then a.ignore_zero=true elseif F==\"--gzip\"or F==\"--gunzip\"or F==\"--ungzip\"then z=true elseif string.find(F,\"--add-file=\")then table.insert(r,string.sub(F,12))elseif string.find(F,\"--directory=\")then x=string.sub(F,13)elseif string.find(F,\"--starting-file=\")then A=string.sub(F,17)elseif F==\"--no-null\"then C=false elseif F==\"--null\"then C=true elseif string.find(F,\"--newer=\")then B=tonumber(string.sub(F,9))elseif string.find(F,\"--after-date=\")then B=tonumber(string.sub(F,14))elseif string.find(F,\"--files-from=\")then local G=b.open(string.sub(F,14),\"r\")local H=G.readLine()while H~=nil do if C then table.insert(r,H)else table.insert(p,H)end;H=G.readLine()end;G.close()elseif F==\"--verbose\"then a.verbosity=1 elseif F==\"--no-recursion\"then D=true end else table.insert(r,F)end end;if z and LibDeflate==nil then LibDeflate=require\"LibDeflate\"if LibDeflate==nil then error(\"Compression is only supported when LibDeflate.lua is available in the PATH.\")end end;local I=c.getcwd()if type(x)==\"string\"then c.chdir(x)end;local function J(e)c.chdir(I)error(e)end;local function K(L)if z then local M=\"\"local G=b.open(q,\"rb\")local g=G.read()while g~=nil do M=M..string.char(g)g=G.read()if string.len(M)%10240==0 then os.queueEvent(\"nosleep\")os.pullEvent()end end;G.close()return a.load(LibDeflate:DecompressGzip(M),L,true)else return a.load(q,L)end end;local function N(O)if not z and q then a.save(O,q)else local m=a.save(O,nil)if z then m=LibDeflate:CompressGzip(m)end;if x==0 then io.write(m)elseif m then local G=b.open(q,\"wb\")for g in string.gmatch(m,\".\")do G.write(string.byte(g))end;G.close()end end end;if s==0 then if z==true then J(\"Compressed files cannot be concatenated\")end;if q==nil then J(\"You must specify an arhive with -f <first.tar>.\")end;local P=b.open(q,\"ab\")for E,F in pairs(r)do local Q=b.open(F,\"rb\")local g=Q.read()while g do P.write(g)g=Q.read()end;Q.close()end;P.close()elseif s==1 then if q==nil and x~=0 then J(\"You must specify an archive with -f <output.tar> or -O.\")end;local O={}for E,F in pairs(r)do local R=split(F,\"/\")local S=O;local T=nil;for E,F in pairs(R)do if E==#R then break end;T=T and b.combine(T,F)or F;if S[F]==nil then S[F]={}end;S=S[F]end;if string.sub(F,1,1)==\"/\"then S[R[#R]]=(D and a.read or a.pack)(\"/\",string.sub(F,2))else S[R[#R]]=(D and a.read or a.pack)(c.getcwd(),F)end;if v then b.remove(F)end end;N(O)elseif s==2 then J(\"Not implemented\")elseif s==3 then if q==nil and x~=0 then J(\"You must specify an archive with -f <output.tar> or -O.\")end;local O=K(true)for E,F in pairs(r)do if string.sub(F,1,1)==\"/\"then table.insert(O,(D and a.read or a.pack)(\"/\",string.sub(F,2)))else table.insert(O,(D and a.read or a.pack)(c.getcwd(),F))end;if v then b.remove(F)end end;N(O)elseif s==4 then if q==nil then J(\"You must specify an archive with -f <file.tar>.\")end;local O=K(true)if a.verbosity>0 then local U={}local V={0,0,0,0,0}for E,F in pairs(O)do local S=os.date(\"%F %R\",F.timestamp or 0)local W={k(F.mode+(F.type==5 and 0x200 or 0),\"drwxrwxrwx\",\"-\"),(F.ownerName or F.owner or 0)..\"/\"..(F.groupName or F.group or 0),string.len(F.data or\"\"),S,F.name..(F.link and F.link~=\"\"and\" -> \"..F.link or\"\")}for X,Y in pairs(W)do if string.len(Y)+1>V[X]then V[X]=string.len(Y)+1 end end;table.insert(U,W)end;for E,F in pairs(U)do for X,Y in pairs(F)do io.write((X==3 and h or d)(Y,V[X])..(X==3 and\" \"or\"\"))end;print(\"\")end else for E,F in pairs(O)do print(F.name)end end elseif s==5 then if q==nil and x~=0 then J(\"You must specify an archive with -f <output.tar> or -O.\")end;local O=K()for E,F in pairs(r)do local R=split(F,\"/\")local S=O;local T=nil;for E,F in pairs(R)do if E==#R then break end;T=T and b.combine(T,F)or F;local j=b.stat(T)if S[F]==nil then S[F]={[\"//\"]={name=T,mode=i(j),owner=0,group=0,timestamp=j.modified,type=5,link=\"\",ownerName=j.owner,groupName=\"\",deviceNumber=nil,data=nil}}end;S=S[F]end;if string.sub(F,1,1)==\"/\"then S[R[#R]]=(D and a.read or a.pack)(\"/\",string.sub(F,2))else S[R[#R]]=(D and a.read or a.pack)(c.getcwd(),F)end;if v then b.remove(F)end end;N(O)elseif s==6 then if q==nil then J(\"You must specify an archive with -f <file.tar>.\")end;local O=K()a.extract(O,c.getcwd())elseif s==7 then if q==nil then J(\"You must specify an archive with -f <file.tar>.\")end;local O=K(true)for E,F in pairs(r)do for X,Y in pairs(O)do if Y.name==F then O[X]=nil;break end end end;N(O)else J(\"You must specify one of -Acdrtux, see --help for details.\")end;c.chdir(I)\n",created=1704748612788,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=10000},["mount.lua"]={modified=1704748610379,data="local a=require\"system.filesystem\"local b=require\"system.util\"if select(\"#\",...)==0 then for c,d in ipairs(a.mountlist())do local e={}for f,g in pairs(d.options)do if g==true then e[#e+1]=f elseif type(g)==\"string\"then e[#e+1]=g elseif type(g)==\"number\"then e[#e+1]=tostring(g)end end;print((\"%s on %s type %s (%s)\"):format(d.source,d.path,d.type,table.concat(e,\",\")))end;return end;local h={}local i=a.open(\"/etc/fstab\",\"r\")if i then for j in i.readLine do local k,l,type,e,c,m=j:gsub(\"#.*\",\"\"):match(\"(%S+)%s+(%S+)%s+(%S+)%s+(%S+)%s+(%S+)%s+(%S+)\")if k then k=k:gsub(\"\\\\([0-3][0-7][0-7])\",function(n)return string.char(tonumber(n,8))end):gsub(\"\\\\x(%x%x)\",function(n)return string.char(tonumber(n,16))end)l=l:gsub(\"\\\\([0-3][0-7][0-7])\",function(n)return string.char(tonumber(n,8))end):gsub(\"\\\\x(%x%x)\",function(n)return string.char(tonumber(n,16))end)local o={}for p in e:gmatch\"[^,]+\"do local f,d=p:match\"([^=]+)=?(.*)\"if f==\"defaults\"then o.rw=true;o.suid=true;o.dev=true;o.exec=true;o.auto=true;o.owner=true;o.async=true else if not f then f,d=p,true end;o[f]=d end end;h[k]={src=k,dest=l,type=type,options=o,check=tonumber(m)}h[#h+1]=h[k]end end end;local q=assert(b.argparse({t=true,o=true,a=false},...))if q.a then local r=true;for c,d in ipairs(h)do if d.options.auto and not d.options.noauto then local s,t=pcall(a.mount,d.type,d.src,d.dest,d.options)if not s and not d.options.nofail then io.stderr:write(\"mount: could not mount \"..d.src..\": \"..t..\"\\n\")r=false end end end;return r end;if q[1]and not q[2]and h[q[1]]then q[2]=h[q[1]].dest end;if#q<2 then error(\"Usage: mount [-t type] [-o options] device [mountpoint]\\n       mount -a\")end;local type=q.t or h[q[1]]and h[q[1]].type or\"craftos\"local o=h[q[1]]and h[q[1]].options or{rw=true,suid=true,dev=true,exec=true,auto=true,owner=true,async=true}if q.o then for p in q.o:gmatch\"[^,]+\"do local f,d=p:match\"([^=]+)=?(.*)\"if not f then f,d=p,true end;o[f]=d end end;return a.mount(type,q[1],q[2],o)\n",created=1704748610420,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1960},["chmod.lua"]={modified=1704748610359,data="local a=require\"system.filesystem\"local b={...}local c=false;if b[1]==\"-R\"then c=true;table.remove(b,1)end;local d=table.remove(b,1)local e=tonumber(d,8)local function f(g)local h=a.stat(g,true)if e then a.chmod(g,h.owner,bit32.band(bit32.rshift(e,6),7))a.chmod(g,nil,bit32.band(e,7))else for i in d:gmatch\"[^,]+\"do local j,k=i:match\"^([^%+%-=]*)([%+%-=][rwxs]+)$\"if not j then error(\"chmod: invalid mode: \"..i)end;if j==\"\"then j=nil end;a.chmod(g,j,k)end end;if c and h.type==\"directory\"then for l,m in ipairs(a.list(g))do f(a.combine(g,m))end end end;for l,g in ipairs(b)do f(g)end\n",created=1704748610402,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=584},["man.lua"]={modified=1704748610377,data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=assert(b.argparse({k=false,apropos=\"@k\",P=true,pager=\"@P\",M=true,manpath=\"@M\",S=true,s=\"@S\",sections=\"@S\",r=true,prompt=\"@r\",u=false,update=\"@u\"},...))local d=c.M or os.getenv(\"MANPATH\")or\"/usr/share/man\"local e=c.S or os.getenv(\"MANSECT\")or\"1 8 3 2 5 4 9 6 7\"local f={[\"and\"]=true,[\"break\"]=true,[\"do\"]=true,[\"else\"]=true,[\"elseif\"]=true,[\"end\"]=true,[\"for\"]=true,[\"function\"]=true,[\"if\"]=true,[\"in\"]=true,[\"local\"]=true,[\"not\"]=true,[\"or\"]=true,[\"repeat\"]=true,[\"return\"]=true,[\"then\"]=true,[\"until\"]=true,[\"while\"]=true}local g={[\"false\"]=true,[\"nil\"]=true,[\"true\"]=true}if c.u then for h in d:gmatch\"[^:]+\"do local i=assert(io.open(a.combine(h,\".mandb\"),\"w\"))for j,k in ipairs(a.list(h))do if k:match\"^man\"then for j,l in ipairs(a.list(a.combine(h,k)))do local m=l:match(\"^[^%.]+\")..\"(\"..k:sub(4)..\"): \"local n=io.open(a.combine(h,k,l),\"r\")if n then for o in n:lines()do local p=o:match(\"<summary>(.-)</summary>\")if p then m=m..p;break end end;n:close()end;i:write(m..\"\\n\")end end end;i:close()end;return true elseif c.k then for j,q in ipairs(c)do for h in d:gmatch\"[^:]+\"do local i=io.open(a.combine(h,\".mandb\"),\"r\")if i then for o in i:lines()do if o:match(q)then print(o)end end;i:close()end end end;return true end;if#c>1 and c[1]:match(\"^%d\")then e=table.remove(c,1)end;for j,q in ipairs(c)do for h in d:gmatch\"[^:]+\"do local r=nil;for s in e:gmatch\"[0-9a-z]+\"do if a.exists(a.combine(h,\"man\"..s,q..\".md\"))then r=a.combine(h,\"man\"..s,q..\".md\")break elseif a.exists(a.combine(h,\"man\"..s,q))then r=a.combine(h,\"man\"..s,q)break end end;if r then local m=\"\"local t=true;local u=false;for o in io.lines(r)do if u then if o==\"```\"then u=false;t=true;m=m..\"\\x1b[0m\\n\"else if u==\"lua\"then o=o:gsub(\"%f[%d](%d+)%f[%D]\",\"\\x1b[94m%1\\x1b[37m\"):gsub(\"%-%-.*$\",\"\\x1b[32m%0\\x1b[37m\"):gsub(\"%f[\\\\'\\\"]['\\\"].*%f[\\\\'\\\"]['\\\"]\",\"\\x1b[31m%0\\x1b[37m\")for v in pairs(f)do o=o:gsub(\"%f[0-9A-Za-z_]\"..v..\"%f[^0-9A-Za-z_]\",\"\\x1b[93m%0\\x1b[37m\")end;for v in pairs(g)do o=o:gsub(\"%f[0-9A-Za-z_]\"..v..\"%f[^0-9A-Za-z_]\",\"\\x1b[34m%0\\x1b[37m\")end end;m=m..o..\"\\n\"end else if o:match\"^#\"then if not t then m=m..\"\\n\"end;m=m..\"\\x1b[92m\"..o:match\"^#+%s*(.*)$\"..\"\\x1b[0m\\n\"t=true elseif o:match\"^%s*[%-%*]%s+\"then if not t then m=m..\"\\n\"end;m=m..o:match\"^(%s*)\"..\" \\7 \"..o:match\"^%s*[%-%*]%s+(.*)$\"..\"\\n\"t=true elseif o:match\"^%d+%.%s\"then if not t then m=m..\"\\n\"end;m=m..o..\"\\n\"t=true elseif o:match\"^>%s\"then if not t then m=m..\"\\n\"end;m=m..\"\\x1b[47m\\x1b[30m\\x95\\x1b[49m\\x1b[37m \"..o:match\"^>%s+(.*)$\"..\"\\x1b[0m\\n\"t=true elseif o:match\"^%-%-%-\"then if not t then m=m..\"\\n\"end;m=m..\"\\x8C\\x8C\\x8C\\x8C\\x8C\\x8C\\x8C\\x8C\\x8C\\x8C\\n\"t=true elseif o:match\"<summary>.*</summary>\"then elseif o:match\"^```\"then if o==\"```lua\"then u=\"lua\"else u=true end;if not t then m=m..\"\\n\"end;m=m..\"\\x1b[37m\"else o=o:gsub(\"%f[\\\\%*]%*%*(%S.-)%f[\\\\%*]%*%*\",\"\\x1b[94m%1\\x1b[0m\"):gsub(\"%f[\\\\%*]%*(%S.-)%f[\\\\%*]%*\",\"\\x1b[92m%1\\x1b[0m\"):gsub(\"%f[\\\\`]`(.-)%f[\\\\`]`\",\"\\x1b[37m%1\\x1b[0m\"):gsub(\"\\\\x(%x%x)\",function(w)return string.char(tonumber(w,16))end):gsub(\"\\\\e\",\"\\x1b\")m=m..o..\" \"t=false end;if not t then if o:match\"^%s*$\"then m=m..\"\\n\\n\"t=true elseif o:match\"%s%s$\"then m=m..\"\\n\"t=true end end end end;io.popen(c.P or\"/bin/less -P '\"..(c.r or\"Manual page \"..q)..\"'\",\"w\"):write(m..\"\\n\"):close()break end end end\n",created=1704748610418,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=3328},["craftos.lua"]={modified=1704748611234,data="for a,b in pairs(require\"craftos\")do _G[a]=b end;return coroutine.yield(\"syscall\",\"exec\",...)\n",created=1704748611249,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=94},["lua.lua"]={modified=1704748610376,data="local a=require\"system.pretty\"local b=require\"system.terminal\"local c=require\"system.util\"local d=assert(c.argparse({h=false,help=false,e=true,l=true,i=false,v=false},...))for e,f in ipairs(d)do if f==\"--\"then table.remove(d,e)break end end;if d.h then print[=[\nusage: lua [options] [script [args]].\nAvailable options are:\n  -e stat  execute string 'stat'\n  -l name  require library 'name'\n  -i       enter interactive mode after executing 'script'\n  -v       show version information\n  --       stop handling options\n  -        execute stdin and stop handling options\n]=]return 0 elseif d.v then print(_VERSION,\"Copyright (C) 2021 JackMacWindows\")return 0 end;if d.l then _ENV[d.l]=require(d.l)end;if d.e then assert(load(d.e,\"=(command line)\",\"t\"))()end;if d[1]then local g;if d[1]==\"-\"then g=assert(load(function()return io.stdin:read(\"*L\")end,\"=stdin\"))else g=assert(load(d[1],\"@\"..d[1]))end;g(table.unpack(d,2,#d))if not d.i then return 0 end end;exit=setmetatable({},{__tostring=function()return\"Press Ctrl+D or Ctrl+C to exit\"end})quit=exit;print(_VERSION,\"Copyright (C) 2021 JackMacWindows\")local h={}while true do local i=\"\"local g,j;repeat if i==\"\"then io.stdout:write(\"> \")else io.stdout:write(\">> \")end;local k=b.readline2(h)if not k then print()return 0 end;i=i..k..\"\\n\"g,j=load(\"return \"..i,\"=stdin\")if not g then g,j=load(i,\"=stdin\")end until g or not j:match(\"<eof>\")if g then local l=table.pack(pcall(g))if l[1]then for e=2,l.n do a.print(a.pretty(l[e],{function_source=true,function_args=true}))end else io.stderr:write(l[2]..\"\\n\")end else io.stderr:write(j..\"\\n\")end;table.insert(h,1,i:sub(1,-2))end\n",created=1704748610418,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1619},["unmount.lua"]={modified=1704748610392,data="return coroutine.yield(\"syscall\",\"unmount\",assert(...,\"Usage: unmount <path>\"))\n",created=1704748610432,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=80},["reboot.lua"]={modified=1704748610385,data="return coroutine.yield(\"syscall\",\"devcall\",\"/\",\"reboot\")\n",created=1704748610423,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=57},["cp.lua"]={modified=1704748610363,data="local a=require\"system.util\"local b=require\"system.filesystem\"local c=assert(a.argparse({P=false,f=false,i=false,p=false,R=false,H=false,L=false,n=false},...))if#c<2 then error(\"cp: missing operand\")end;local function d(e,f)local g=b.stat(e)if not g then error(\"cp: \"..e..\": No such file or directory\")end;local h=b.stat(f)if g.type==\"directory\"then local i=false;if not c.R then io.stderr:write(\"cp: -R not specified, omitting directory '\"..e..\"'\\n\")return false end;if h then if h.type~=\"directory\"then io.stderr:write(\"cp: omitting existing \"..h.type..\" '\"..f..\"'\\n\")return false end else b.mkdir(f)i=true end;local j=b.list(e)local k=true;for l,m in ipairs(j)do k=d(b.combine(e,m),b.combine(f,m))and k end;if i then b.chmod(f,nil,g.worldPermissions)for n,m in pairs(g.permissions)do b.chmod(f,n,m)end;if g.owner then b.chown(f,g.owner)end end;return k else if h then if c.i then io.stderr:write(\"overwrite \"..h.type..\" \"..f..\"? \")local o=io.read()if o:lower()~=\"y\"then return false end elseif c.n then return false end end;local p,q=b.open(e,\"rb\")if not p then error(\"cp: \"..e..\": \"..q,2)end;local r,q=b.open(f,\"wb\")if not r then if c.f and h then b.remove(f)r,q=b.open(f,\"wb\")end;if not r then p.close()error(q,2)end end;repeat local s=p.read(512)if s then r.write(s)end until not s;r.close()p.close()if c.p then b.chmod(f,nil,g.worldPermissions)for n,m in pairs(g.permissions)do b.chmod(f,n,m)end;if g.owner then b.chown(f,g.owner)end end;return true end end;local t=table.remove(c)if#c==1 and not b.isDir(t)then return d(c[1],t)else if not b.isDir(t)then error(\"cp: target is not a directory\")end;local k=true;for l,m in ipairs(c)do k=d(m,b.combine(t,b.basename(m)))and k end;return k end\n",created=1704748610407,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1696},["cd.lua"]={modified=1704748610358,data="return coroutine.yield(\"syscall\",\"chdir\",...)\n",created=1704748610402,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=46},["mkdir.lua"]={modified=1704748610377,data="local a=require\"system.util\"local b=require\"system.filesystem\"local c=assert(a.argparse({p=false,m=true},...))local d=c.m;local e=d and tonumber(d,8)local function f(g)local h=b.stat(g)if e then b.chmod(g,h.owner,bit32.band(bit32.rshift(e,6),7))b.chmod(g,nil,bit32.band(e,7))else for i in d:gmatch\"[^,]+\"do local j,k=i:match\"^([^%+%-=]*)([%+%-=][rwxs]+)$\"if not j then error(\"mkdir: invalid mode: \"..i)end;if j==\"\"then j=nil end;b.chmod(g,j,k)end end end;for l,m in ipairs(c)do if not c.p and not b.isDir(b.dirname(m))then error(\"mkdir: \"..b.dirname(m)..\": Not a directory\")end;b.mkdir(m)if d then f(m)end end\n",created=1704748610419,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=610},["compress.lua"]={modified=1704748610363,data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=string.char;local type=type;local d=string.sub;local e=math.floor;local f={}for g=0,255 do local h=c(g)f[h]=g end;local function i(j,k,l,m)if l>=256 then l,m=0,m+1;if m>=256 then k={}m=1 end end;k[j]=m*256+l;l=l+1;return k,l,m end;local function n(o,p)if type(o)~=\"string\"then return nil,\"string expected, got \"..type(o)end;local q=#o;local k={}local l,m=1,1;local r=\"\"local s,t,u,v=9,\"\\x1F\\x9D\\x90\",0,0;for g=1,q do local w=d(o,g,g)local x=r..w;if not(f[x]or k[x])then local y=f[r]or k[r]if not y then return nil,\"algorithm error, could not fetch word\"end;u=u+y*2^v;v=v+s;while v>=8 do t=t..c(u%256)u=e(u/256)v=v-8 end;if m<p then k,l,m=i(x,k,l,m)if l==1 and m==2^(s-8)then if v>0 then t=t..c(u%256)end;u=0;v=0;s=s+1 end end;r=w else r=x end end;u=u+(f[r]or k[r])*2^v;v=v+s;while v>=8 do t=t..c(u%256)u=e(u/256)v=v-8 end;if v>0 then t=t..c(u)end;return t end;local z=assert(b.argparse({b=\"number\",c=false,f=false,k=false,v=false},...))local A;if z[1]==\"-\"or z[1]==nil then A=io.read(\"*a\")else local B=assert(io.open(z[1],\"rb\"))A=B:read(\"*a\")B:close()end;local C=n(A,z.b and 2^(z.b-8)or 256)if z.v then io.stderr:write((\"%s: %.3g%%\\n\"):format(z[1],#C/#A*100))end;if z.c then io.write(C)return end;if not z.f and#C>#A then return 2 end;if not z.f and a.exists(z[1]..\".Z\")then io.write(\"replace file \"..z[1]..\".Z? (y/N) \")local D=io.read()if D~=\"Y\"and D~=\"y\"then return 1 end end;local B=assert(io.open(z[1]..\".Z\",\"wb\"))B:write(C)B:close()if not z.k then os.remove(z[1])end\n",created=1704748610407,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1542},["id.lua"]={modified=1704748610371,data="local a=require\"system.hardware\"if...then local b=assert(a.wrap(...),\"No such device\")local c=b.state;if c and c.id then print(\"This drive has disk #\"..c.id)else error(\"No disk in drive\")end else print(\"This is computer #\"..a.info(\"/\").metadata.id)end\n",created=1704748610414,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=252},["date.lua"]={modified=1704748610364,data="local a=false;local b=\"%c\"for c,d in ipairs{...}do if d==\"-u\"then a=true elseif d:sub(1,1)==\"+\"then b=d:sub(2)end end;if a then b=\"!\"..b end;print(os.date(b))\n",created=1704748610408,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=159},["ps.lua"]={modified=1704748610384,data="local a=setmetatable({},{__index=function(self,b)return function(...)local c=table.pack(coroutine.yield(\"syscall\",b,...))if c[1]then return table.unpack(c,2,c.n)else error(c[2],2)end end end,__newindex=function()end})local d=a.getplist()print(\"PID\\tTTY\\tTIME\\t\\tCMD\")for e,f in ipairs(d)do local g=a.getpinfo(f)if g then print(f,g.stdout and\"tty\"..g.stdout or\"?\",(\"%02d:%02d:%02d.%03d\"):format(math.floor(g.cputime/3600),math.floor(g.cputime/60),math.floor(g.cputime),math.floor(g.cputime*1000)%1000),g.name)end end\n",created=1704748610422,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=516},["apropos.lua"]={modified=1704748610354,data="return coroutine.yield(\"syscall\",\"exec\",\"/bin/man\",\"-k\",...)\n",created=1704748610399,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=61},["ls.lua"]={modified=1704748610375,data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=b.argparse({A=false,C=false,F=false,H=false,L=false,R=false,S=false,a=false,c=false,d=false,f=false,g=false,i=false,k=false,l=false,m=false,n=false,o=false,p=false,q=false,r=false,s=false,t=false,u=false,x=false,[\"1\"]=false},...)if not c[1]then c[1]=\".\"end;if c.f then c.a,c.r,c.S,c.t=true,false,false,false end;if c.a then c.A=true end;if c.g or c.n or c.o then c.l=true end;local d={file='-',directory='d',fifo='p',link='l'}local function e(f,g,h)if c.p and g.type==\"directory\"then f=f..\"/\"elseif c.F then if g.type==\"directory\"then f=f..\"/\"elseif g.type==\"fifo\"then f=f..\"|\"elseif g.type==\"link\"then f=f..\"@\"elseif g.worldPermissions.execute then f=f..\"*\"end end;if c.q then f=f:gsub(\"[\\0-\\31\\127-\\255]\",\"?\")end;if c.s then io.stdout:write(math.ceil(g.size/(c.k and 1024 or 512))..\" \")end;if c.l then local i=g.worldPermissions;local j=g.permissions[g.owner]or g.worldPermissions;local k=(i.read and'r'or'-')..(i.write and'w'or'-')..(i.execute and'x'or'-')local l=(\"%s%s%s%s%s%s\"):format(d[g.type],j.read and'r'or'-',j.write and'w'or'-',j.execute and(g.setuser and's'or'x')or'-',k,k)local m=os.time()-g.modified>15552000000 and os.date(\"%b %e  %Y\",g.modified/1000)or os.date(\"%b %e %H:%M\",g.modified/1000)print((\"%s %u %s %s\\t%\"..h..\"u %s %s%s\"):format(l,0,c.g and\"\"or g.owner,\"\",math.ceil(g.size/(c.k and 1024 or 512)),m,f,g.type==\"link\"and\" -> \"..g.link or\"\"))elseif c.m then io.stdout:write(f..\", \")elseif c.C then elseif c.x then else print(f)end end;for n,o in ipairs(c)do if#c>1 then print(o..\":\")end;local g,p=a.stat(o,true)local q;if g then if g.type==\"directory\"then q=a.list(o)else o,q=a.dirname(o),{a.basename(o)}end;local r={}if c.a then q[#q+1]=\".\"q[#q+1]=\"..\"end;for n,s in ipairs(q)do if c.A or not s:match\"^%.\"then local t=a.stat(a.combine(o,s),true)if t then r[#r+1]={name=s,stat=t}end end end;local u;if c.r then u=function(v,w)return v>=w end else u=function(v,w)return v<w end end;if c.S then table.sort(r,function(v,w)if v.stat.size==w.stat.size then return u(v.name,w.name)else return not u(v.stat.size,w.stat.size)end end)elseif c.t then table.sort(r,function(v,w)if v.stat.modified==w.stat.modified then return u(v.name,w.name)else return not u(v.stat.modified,w.stat.modified)end end)elseif not c.f then table.sort(r,function(v,w)return u(v.name,w.name)end)end;if c.l or c.s then local x=0;for n,y in ipairs(r)do x=x+math.ceil(y.stat.size/(c.k and 1024 or 512))end;print(\"total \"..x)end;local z=0;for n,y in ipairs(r)do z=math.max(z,math.ceil(math.log(y.stat.size/(c.k and 1024 or 512),10)))end;for n,y in ipairs(r)do e(y.name,y.stat,z)end;if c.m then print()end else io.stderr:write(\"ls: cannot access '\"..o..\"': \"..(p or\"\")..\"\\n\")end end\n",created=1704748610417,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=2738},["echo.lua"]={modified=1704748610367,data="print(...)\n",created=1704748610411,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=11},["renice.lua"]={modified=1704748610386,data="local a=require\"system.process\"local b=require\"system.util\"local c=assert(b.argparse({n=\"number\"},...))if not c[1]or not c.n then error(\"Usage: renice -n <increment> <PID...>\")end;for d,e in ipairs(c)do e=tonumber(e)or error(\"renice: argument \"..e..\" is not a PID\")a.nice(c.n,e)end\n",created=1704748610424,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=282},["pwd.lua"]={modified=1704748610384,data="print(select(2,coroutine.yield(\"syscall\",\"getcwd\")))\n",created=1704748610423,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=53},["redstone.lua"]={modified=1704748610385,data="local a=require\"system.hardware\"local b=require\"system.util\"local c={...}if c[1]==\"probe\"then local d=false;print(\"Redstone inputs:\")local e={}for f,g in ipairs(a.children(\"/redstone\"))do local h=a.wrap(\"/redstone/\"..g)local i=h.bundledInput;if i and i>0 then d=true end;local j=h.input;if j then e[#e+1]=g..\" (\"..j..\")\"end end;if#e>0 then print(table.concat(e,\", \"))else print(\"None.\")end;if d then print()print(\"Bundled inputs:\")local k={[0]=\"white\",\"orange\",\"magenta\",\"lightBlue\",\"yellow\",\"lime\",\"pink\",\"gray\",\"lightGray\",\"cyan\",\"purple\",\"blue\",\"brown\",\"green\",\"red\",\"black\"}for f,g in ipairs(a.children(\"/redstone\"))do local h=a.wrap(\"/redstone/\"..g)local i=h.bundledInput;if i and i>0 then io.write(g..\": \")local e={}for l=0,15 do if bit32.btest(i,2^l)then e[#e+1]=k[l]end end;print(table.concat(e,\", \"))end end end elseif c[1]==\"set\"then if#c<3 then error(\"Usage: redstone set <side> [color] <value>\")end;local h=assert(a.wrap(\"/redstone/\"..c[2]),\"Not a side\")if#c>=4 then if not h.bundledOutput then error(\"Bundled output is not available\")end;local k={white=0,orange=1,magenta=2,lightBlue=3,yellow=4,lime=5,pink=6,gray=7,grey=7,lightGray=8,lightGrey=8,cyan=9,purple=10,blue=11,brown=12,green=13,red=14,black=15}local m=2^assert(k[c[3]],\"Invalid color\")if c[4]:lower()==\"true\"then h.bundledOutput=bit32.bor(h.bundledOutput,m)else h.bundledOutput=bit32.band(h.bundledOutput,bit32.bnot(m))end else local n;if c[3]:lower()==\"true\"then n=15 else n=tonumber(c[3])or 0 end;h.output=n end elseif c[1]==\"pulse\"then if#c<4 then error(\"Usage: redstone pulse <side> <count> <period>\")end;local h=assert(a.wrap(\"/redstone/\"..c[2]),\"Not a side\")local o=tonumber(c[3])or 1;local p=tonumber(c[4])or 0.5;for f=1,o do h.output=true;b.sleep(p/2)h.output=false;b.sleep(p/2)end else print(\"Usage: redstone <probe|set|pulse> ...\")end\n",created=1704748610424,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1820},["basename.lua"]={modified=1704748610356,data="local a=assert(...,\"basename: missing path\")if a==\"\"then print\".\"elseif a:match\"^/+$\"then print\"/\"else local b=a:gsub(\"/+$\",\"\"):match\"[^/]+$\"local c=select(2,...)if c and b~=c then b=b:gsub(c..\"$\",\"\")end;print(b)end\n",created=1704748610400,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=216},["link.lua"]={modified=1704748610374,data="return coroutine.yield(\"syscall\",\"link\",...)\n",created=1704748610416,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=45},["eject.lua"]={modified=1704748610368,data="if not...then error(\"Usage: eject <drive>\")end;return assert(coroutine.yield(\"syscall\",\"devcall\",...,\"eject\"))\n",created=1704748610411,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=111},["expr.lua"]={modified=1704748610369,data="print(assert(load(table.concat({...},\" \"):gsub(\"&\",\" and \"):gsub(\"|\",\" or \"),\"=expr\",\"t\",{}))())\n",created=1704748610412,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=97},["shell.lua"]={modified=1704748611235,data="for a,b in pairs(require\"craftos\")do if a~=\"shell\"and a~=\"multishell\"then _G[a]=b end end;if not fs.isDir(\"/rom\")then if select(2,coroutine.yield(\"syscall\",\"getuser\"))~=\"root\"then error(\"The CraftOS ROM must be mounted to /rom. Please mount it as root.\")end;fs.makeDir(\"/rom\")end;if not fs.isDir(\"/rom/programs\")then if select(2,coroutine.yield(\"syscall\",\"getuser\"))~=\"root\"then error(\"The CraftOS ROM must be mounted to /rom. Please mount it as root.\")end;coroutine.yield(\"syscall\",\"mount\",\"craftos\",\"/rom\",\"/rom\",{})end;local c=coroutine.resume;function coroutine.resume(d,...)local e=table.pack(c(d,...))while e[1]and e[2]==\"syscall\"do e=table.pack(c(d,coroutine.yield(table.unpack(e,2,e.n))))end;return table.unpack(e,1,e.n)end;coroutine.yield(\"syscall\",\"chdir\",\"/\")return coroutine.yield(\"syscall\",\"exec\",\"/rom/programs/shell.lua\",...)\n",created=1704748611250,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=841},["cal.lua"]={modified=1704748610357,data="local a={...}local b={\"january\",\"february\",\"march\",\"april\",\"may\",\"june\",\"july\",\"august\",\"september\",\"october\",\"november\",\"december\"}local c={31,28,31,30,31,30,31,31,30,31,30,31}local function d(e)if#e<3 then return end;local f=\"^\"..e:lower()for g,h in ipairs(b)do if h:match(f)then return g end end end;local i=os.date(\"*t\")local j,k;if a[2]then j,k=assert(tonumber(a[1])or d(a[1]),\"cal: \"..a[1]..\" is neither a month number (1..12) nor a name\"),assert(tonumber(a[2]),\"cal: year `\"..a[2]..\"' not in range 1..9999\")elseif a[1]then k=assert(tonumber(a[1]),\"cal: year `\"..a[1]..\"' not in range 1..9999\")else j,k=i.month,i.year end;if k<1 or k>9999 then error(\"cal: year `\"..k..\"' not in range 1..9999\")end;if j and(j<1 or j>12)then error(\"cal: \"..j..\" is neither a month number (1..12) nor a name\")end;if j then local l=b[j]:gsub(\"^.\",string.upper)..\" \"..k;l=(\" \"):rep(math.floor((20-#l)/2))..l;print(l)print(\"Su Mo Tu We Th Fr Sa\")local m=os.date(\"*t\",os.time({year=k,month=j,day=1})).wday;io.stdout:write((\"   \"):rep(m-1))local n=c[j]if j==2 and(k%4==0 and k%100~=0 or k%400==0)then n=29 end;for g=1,n do if i.year==k and i.month==j and i.day==g then io.stdout:write((\"\\x1b[7m%2d\\x1b[7m \"):format(g))else io.stdout:write((\"%2d \"):format(g))end;m=m+1;if m>7 then print()m=1 end end;if m>1 then print()end else print((\"                              %4d\"):format(k))local function o(p)local l=b[p]:gsub(\"^.\",string.upper)l=(\" \"):rep(math.floor((20-#l)/2))..l..(\" \"):rep(math.ceil((20-#l)/2))coroutine.yield(l)coroutine.yield(\"Su Mo Tu We Th Fr Sa\")local m=os.date(\"*t\",os.time({year=k,month=p,day=1})).wday;local q=(\"   \"):rep(m-1)local n=c[p]if p==2 and(k%4==0 and k%100~=0 or k%400==0)then n=29 end;for g=1,n do if i.year==k and i.month==p and i.day==g then q=q..(\"\\x1b[7m%2d\\x1b[7m \"):format(g)else q=q..(\"%2d \"):format(g)end;m=m+1;if m>7 then coroutine.yield(q:sub(1,-2))q,m=\"\",1 end end;if m>1 then coroutine.yield(q:sub(1,-2)..(\" \"):rep(20-#q+1))end end;for g=0,3 do local r,s,t=coroutine.create(function()o(g*3+1)end),coroutine.create(function()o(g*3+2)end),coroutine.create(function()o(g*3+3)end)while coroutine.status(r)==\"suspended\"or coroutine.status(s)==\"suspended\"or coroutine.status(t)==\"suspended\"do local q=\"\"local u,v=coroutine.resume(r)if u and v then q=v..\"  \"end;u,v=coroutine.resume(s)if u and v then q=q..v..\"  \"end;u,v=coroutine.resume(t)if u and v then q=q..v end;print(q)end end end\n",created=1704748610400,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=2404},["du.lua"]={modified=1704748610367,data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=assert(b.argparse({a=false,s=false,k=false,h=false,x=false,H=false,L=false},...))if#c==0 then c[1]=\".\"end;local d=0;local function e(f)if c.h then if f>=1000000000000 then return(\"%.3gT\"):format(f/1000000000000)elseif f>=1000000000 then return(\"%.3gG\"):format(f/1000000000)elseif f>=1000000 then return(\"%.3gM\"):format(f/1000000)elseif f>=1000 then return(\"%.3gK\"):format(f/1000)else return(\"%.3g \"):format(f)end elseif c.k then return math.ceil(f/1024)else return math.ceil(f/512)end end;local function g(h,i,j)local k,l=a.stat(h,not(j and c.H or c.L))if k then if i==true then i=k.mountpoint end;if i and i~=k.mountpoint then return 0 end;if k.type==\"directory\"then local m=0;for n,o in ipairs(a.list(h))do m=m+g(a.combine(h,o),i)end;if not c.s then print(e(m),h)end;return m else if c.a and not c.s then print(e(k.size),h)end;return k.size end else io.stderr:write(\"du: could not stat \"..h..\": \"..(l or\"\")..\"\\n\")d=1;return 0 end end;for n,o in ipairs(c)do local m=g(o,c.x,true)if c.s then print(e(m),o)end end;return d\n",created=1704748610410,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1092},["cash.lua"]={modified=1704748610357,data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=require\"system.serialization\"local d=require\"system.terminal\"local e=require\"system.util\"local f=assert(e.argparse({c=false,i=false,s=false},...))local g,h;if f.c then h=table.remove(f,1)end;if not f.s then g=table.remove(f,1)end;if not f.c and not f.s and e.syscall.istty()then f.i=true end;local i={}local j=os.time()local k=true;local l=0;local m;local n;local o=b.getenv()if table.maxn==nil then table.maxn=function(p)local q=1;while p[q]~=nil do q=q+1 end;return q-1 end end;local function r(s)return string.match(s,'^()%s*$')and''or string.match(s,'^%s*(.*%S)')end;o.HOME=o.HOME or\"/\"o.SHELL=b.getname()o.PATH=o.PATH or\"/bin:/sbin:/usr/bin\"o.USER=b.getuser()o.EDITOR=o.EDITOR or\"nano\"o.OLDPWD=b.getcwd()o.PWD=o.OLDPWD;o.SHLVL=o.SHLVL and o.SHLVL+1 or 1;o.TERM=o.TERM or\"craftos\"o.COLORTERM=o.COLORTERM or\"16color\"local t={PS1=\"\\\\s-\\\\v\\\\$ \",PS2=\"> \",IFS=\"\\n\",CASH=o.SHELL,CASH_VERSION=\"0.4.1\",RANDOM=function()return math.random(0,32767)end,SECONDS=function()return math.floor((os.time()-j)/1000)end,HOSTNAME=\"localhost\",TERMINATE_QUIT=\"no\",[\"*\"]=table.concat(f,\" \"),[\"@\"]=function()return table.concat(f,\" \")end,[\"#\"]=#f,[\"?\"]=0,[\"0\"]=o.SHELL,_=o.SHELL,[\"$\"]=b.getpid()}local u={}local v={}local w={}local x,y={},0;local z,A={},0;local B,C={},0;local D=nil;local E={}local F={}local G;local H,I;local J=false;local K=false;local L=false;local M={}local N={}local O={}local function P(...)io.write(...)io.write(\"\\n\")end;local Q;Q={[\":\"]=function()return 0 end,[\".\"]=function(R)local S=io.open(R,\"r\")if not S then return 1 end;t.LINENUM=1;for T in S:lines()do i.run(T)t.LINENUM=t.LINENUM+1 end;t.LINENUM=nil;S:close()end,echo=function(...)P(...)return 0 end,builtin=function(U,...)return Q[U](...)end,cd=function(V)V=V or\"/\"if not V:match\"^/\"then V=a.combine(o.PWD,V)end;local W,X=b.chdir(V)if not W then io.stderr:write(\"cash: cd: \"..V..\": \"..X..\"\\n\")return 1 end;o.OLDPWD=o.PWD;o.PWD=V end,command=function(...)L=true;i.run(...)L=false;return t[\"?\"]end,complete=function()end,eval=function(...)i.run(...)return t[\"?\"]end,exec=function(...)m=table.concat({...},' ')i.exit()end,exit=function(...)return i.exit(...)end,export=function(...)local t={...}if#t==0 or t[1]==\"-p\"then for Y,Z in pairs(o)do if type(Z)==\"string\"or type(Z)==\"number\"then P(\"export \"..Y..\"=\"..Z)end end else for Y,Z in ipairs(t)do local _,a0=string.match(Z,\"(.+)=(.+)\")if not(_==nil or a0==nil)and(o[_]==nil or type(o[_])==\"string\"or type(o[_])==\"number\")then o[_]=a0 end end end end,history=function(...)if({...})[1]==\"-c\"then G.close()G=a.open(\".cash_history\",\"w\")F={}return end;local a1={}for Y,Z in ipairs(F)do P(\" \"..Y..string.rep(\" \",math.floor(math.log10(#F))-math.floor(math.log10(Y))+2)..Z)end end,jobs=function(...)local a2={...}for Y,Z in pairs(N)do if Z.cmd~=\"jobs\"then if#a2==0 then P(\"[\"..Y..\"]+  \"..(Z.paused and\"Paused\"or\"Running\")..\"  \"..Z.cmd)else for a3,a4 in ipairs(a2)do if Y==a4 then P(\"[\"..Y..\"]+  \"..(Z.paused and\"Paused\"or\"Running\")..\"  \"..Z.cmd)end end end end end end,pushd=function(a5)if a5 then if not a5:match\"^/\"then a5=a.combine(o.PWD,a5)end;local W,X=b.chdir(a5)if not W then io.stderr:write(\"cash: pushd: \"..a5 ..\": \"..X..\"\\n\")return 1 end end;table.insert(M,o.PWD)if a5 then o.OLDPWD=o.PWD;o.PWD=a5 end;io.write((o.PWD==\"\"and\"/\"or o.PWD)..\" \")for q=#M,1,-1 do io.write((M[q]==\"\"and\"/\"or M[q])..\" \")end;P()end,popd=function()if#M==0 then io.stderr:write(\"cash: popd: directory stack empty\\n\")return-1 end;local W,X=b.chdir(M[#M])if not W then io.stderr:write(\"cash: popd: \"..M[#M]..\": \"..X..\"\\n\")return 1 end;o.PWD=table.remove(M,#M)io.write((o.PWD==\"\"and\"/\"or o.PWD)..\" \")for q=#M,1,-1 do io.write((M[q]==\"\"and\"/\"or M[q])..\" \")end;P()end,dirs=function()io.write((o.PWD==\"\"and\"/\"or o.PWD)..\" \")for q=#M,1,-1 do io.write((M[q]==\"\"and\"/\"or M[q])..\" \")end;P()end,pwd=function()P(o.PWD)end,read=function(a6)t[a6]=io.read()end,set=function(...)local a7={...}if#a7==0 then for Y,Z in pairs(t)do P(Y..\"=\"..Z)end else for Y,Z in ipairs(a7)do if Z:match\"^%-\"then for a8 in Z:sub(2):gmatch\".\"do u[a8]=true end elseif string.find(Z,\"=\")then local _,a0=string.match(Z,\"(.+)=(.+)\")t[_]=a0 end end end end,alias=function(...)local t={...}if#t==0 or t[1]==\"-p\"then for Y,Z in pairs(v)do P(\"alias \"..Y..\"=\"..Z)end else for Y,Z in ipairs(t)do local _,a0=string.match(Z,\"(.+)=(.+)\")v[_]=a0 end end end,sleep=function(a9)e.sleep(tonumber(a9)or 0)end,test=function(...)local f={...}if#f<1 then io.stderr:write(\"cash: test: unary operator expected\\n\")return-1 end;local function aa(Z)return Z end;if f[1]==\"!\"then table.remove(f,1)aa=function(Z)return not Z end end;if string.sub(f[1],1,1)==\"-\"then if f[2]==nil then return aa(true)elseif f[1]==\"-d\"then return aa((a.stat(f[2])or{}).type==\"directory\")elseif f[1]==\"-e\"then return aa(a.stat(f[2])~=nil)elseif f[1]==\"-f\"then return aa((a.stat(f[2])or{}).type==\"file\")elseif f[1]==\"-n\"then return aa(#f[2]>0)elseif f[1]==\"-s\"then return aa(a.stat(f[2])>0)elseif f[1]==\"-u\"then return aa((a.stat(f[2])or{}).permissions.setuid)elseif f[1]==\"-w\"then local ab=a.stat(f[2])if not ab then return aa(false)end;return aa((ab.permissions[b.getuser()]or ab.worldPermissions).write)elseif f[1]==\"-x\"then local ab=a.stat(f[2])if not ab then return aa(false)end;return aa((ab.permissions[b.getuser()]or ab.worldPermissions).execute)elseif f[1]==\"-z\"then return aa(#f[2]==0)else return aa(false)end elseif f[3]and string.sub(f[2],1,1)==\"-\"then if f[2]==\"-eq\"then return aa(tonumber(f[1])==tonumber(f[3]))elseif f[2]==\"-ne\"then return aa(tonumber(f[1])~=tonumber(f[3]))elseif f[2]==\"-lt\"then return aa(tonumber(f[1])<tonumber(f[3]))elseif f[2]==\"-gt\"then return aa(tonumber(f[1])>tonumber(f[3]))elseif f[2]==\"-le\"then return aa(tonumber(f[1])<=tonumber(f[3]))elseif f[2]==\"-ge\"then return aa(tonumber(f[1])>=tonumber(f[3]))else return aa(false)end elseif f[2]==\"=\"then return aa(f[1]==f[3])elseif f[2]==\"!=\"then return aa(f[1]~=f[3])else io.stderr:write(\"cash: test: unary operator expected\\n\")return 2 end end,time=function(...)if not...then io.stderr:write(\"cash: time: missing program path\\n\")return false end;local ac=os.time()local Z={vars={},[0]=...,select(2,...)}local R,ad=i.resolveProgram(Z[0])R=R or Z[0]if not(ad and string.find(Z[0],\"/\")==nil)then Z[0]=R end;local ae=I(Z)if not ae then ae={cputime=0,systime=0}end;P(table.concat({...},\" \"),(\"%.2f user %.2f sys %.3f total\"):format(ae.cputime,ae.systime,(os.time()-ac)/1000))return t[\"?\"]end,[\"true\"]=function()return 0 end,[\"false\"]=function()return 1 end,unalias=function(...)for Y,Z in ipairs({...})do v[Z]=nil end end,unset=function(...)for Y,Z in ipairs({...})do if Z:match\"^%-\"then for a8 in Z:sub(2):gmatch\".\"do u[a8]=nil end else t[Z]=nil end end end,wait=function(af)if af then while N[tonumber(af)]~=nil do sleep(0.1)end else while table.maxn(N)~=0 do sleep(0.1)end end end,cat=function(...)for Y,Z in ipairs({...})do local S=a.open(Z,\"r\")if S~=nil then P(S.readAll())S.close()end end end,which=function(U)local U,Z=i.resolveProgram(U)if not Z and U then P(U)end end,[\"if\"]=function(...)i.run(...)table.insert(x,{cond=t[\"?\"]==0,inv=false})end,[\"then\"]=function(...)if y>=table.maxn(x)then io.stderr:write(\"cash: syntax error near unexpected token `then'\\n\")return-1 end;y=y+1;i.run(...)return t[\"?\"]end,[\"else\"]=function(...)if y<1 or x[y].inv then io.stderr:write(\"cash: syntax error near unexpected token `else'\\n\")return-1 end;x[y].inv=true;x[y].cond=not x[y].cond;i.run(...)return t[\"?\"]end,fi=function()if y<1 then io.stderr:write(\"cash: syntax error near unexpected token `fi'\\n\")return-1 end;table.remove(x,y)y=y-1 end,[\"while\"]=function(...)table.insert(z,{cond={...},lines={}})end,[\"do\"]=function(...)if table.maxn(z)==0 then io.stderr:write(\"cash: syntax error near unexpected token `do'\\n\")return-1 end;A=A+1 end,done=function()if A<1 then io.stderr:write(\"cash: syntax error near unexpected token `done'\\n\")return-1 end;A=A-1;if A==0 then local ag=table.remove(z,A+1)if type(ag.cond)==\"function\"then ag.cond()else i.run(table.unpack(ag.cond))end;local ah=t[\"?\"]K=false;while ah==0 and not K do for Y,Z in ipairs(ag.lines)do if type(Z)==\"function\"then Z()else i.run(Z)end end;if type(ag.cond)==\"function\"then ag.cond()else i.run(table.unpack(ag.cond))end;ah=t[\"?\"]end end end,[\"break\"]=function()K=true end,[\"for\"]=function(...)local f={...}if f[2]~=\"in\"then io.stderr:write(\"cash: missing `in' in for loop\\n\")return-1 end;local q=2;table.insert(z,{cond=function()q=q+1;t[\"?\"]=f[q]~=nil and 0 or 1 end,lines={function()t[f[1]]=f[q]end}})end,[\"function\"]=function(U,ai)if D~=nil then io.stderr:write(\"cash: syntax error near unexpected token `function'\\n\")return-1 end;if ai~=\"{\"then io.stderr:write(\"cash: syntax error near token `\"..U..\"'\\n\")return-1 end;D=U;E[D]={}end,[\"}\"]=function()if D==nil then io.stderr:write(\"cash: syntax error near unexpected token `}'\\n\")return-1 end;D=nil end,[\"return\"]=function(a6)if J==false then io.stderr:write(\"cash: syntax error near unexpected token `return'\\n\")return-1 end;J=false;return a6 end,bg=function(p)if n then N[n].isfg=false;N[n].paused=false;if CCKernel2 then kernel.signal(signal.SIGCONT,N[n].pid)end;n=nil;return 0 elseif tonumber(p)and N[tonumber(p)]then local aj=tonumber(p)N[aj].isfg=false;N[aj].paused=false;if CCKernel2 then kernel.signal(signal.SIGCONT,N[aj].pid)end;return 0 else io.stderr:write(\"cash: bg: current: no such job\\n\")return 1 end end,fg=function(p)if n then N[n].isfg=true;N[n].paused=false;if CCKernel2 then kernel.signal(signal.SIGCONT,N[n].pid)end;n=nil;return 0 elseif tonumber(p)and N[tonumber(p)]then local aj=tonumber(p)N[aj].isfg=true;N[aj].paused=false;if CCKernel2 then kernel.signal(signal.SIGCONT,N[aj].pid)end;return 0 else io.stderr:write(\"cash: fg: current: no such job\\n\")return 1 end end}Q[\"[\"]=Q.test;function i.exit(ak)k=false;l=ak or 0 end;function i.resolveProgram(U)if Q[U]~=nil then return U end;if v[U]~=nil then U=v[U]end;for R in string.gmatch(o.PATH,\"[^:]+\")do local ai=a.combine(R,U)local ab=a.stat(ai)if ab and ab.type==\"file\"and(ab.permissions[b.getuser()]or ab.worldPermissions).execute then return ai else ai=a.combine(R,U..\".lua\")ab=a.stat(ai)if ab and ab.type==\"file\"and(ab.permissions[b.getuser()]or ab.worldPermissions).execute then return ai end end end;if(a.stat(U)or{}).type==\"file\"then return U,string.find(U,\"/\")==nil end;if(a.stat(U..\".lua\")or{}).type==\"file\"then return U..\".lua\",string.find(U,\"/\")==nil end;return nil end;local function al(a6)if string.sub(a6,1,1)~=\"$\"then return nil end;if string.sub(a6,2,2)==\"{\"then local am=string.sub(string.match(a6,\"%b{}\"),2,-2)local ak=o[am]or t[am]if type(ak)==\"function\"then return ak(),#am+2 else return ak or\"\",#am+2 end elseif string.sub(a6,2,3)==\"((\"then local an=string.gsub(string.sub(string.match(string.sub(a6,3),\"%b()\"),2,-2),\"%$\",\"\")local ao=loadstring(\"return \"..an)local ap=setmetatable({},{__index=_ENV})for Y,Z in pairs(t)do ap[Y]=Z end;setfenv(ao,ap)return tostring(ao()),#an+4 elseif tonumber(string.sub(a6,2,2))then local am=tonumber(string.match(string.sub(a6,2,2),\"[0-9]+\"))if am==0 then return t[\"0\"],1 else return f[am]or\"\",math.floor(math.log10(am))+1 end else local am=\"\"for a8 in string.gmatch(string.sub(a6,2),\".\")do if a8==\" \"then return\"\",#am end;am=am..a8;if o[am]or t[am]then local ak=o[am]or t[am]if type(ak)==\"function\"then return ak(),#am else return ak or\"\",#am end end end;return\"\",#a6-1 end end;local function aq(ar)local as=false;local at=false;local au=1;local ak={\"\"}local av,aw;for a8 in string.gmatch(ar,\".\")do if av=='&'and a8~='&'and aw~='&'and not at and not as then au=au+1;ak[au]=\"\"end;local ax=false;if a8=='\"'or a8=='\\''and not as then at=not at elseif a8=='\\\\'and not at and not as then ax=true;as=true end;if a8==';'and not at and not as then au=au+1;ak[au]=\"\"elseif not(a8==' 'and ak[au]==\"\")then ak[au]=ak[au]..a8 end;if not ax then as=false end;aw=av;av=a8 end;return ak end;local function ay(ar,az)local aA=false;local as=false;local aB=\"\"local q=1;local function aC(Z)if type(Z)==\"boolean\"then return Z and\"true\"or\"false\"elseif Z==nil then return\"nil\"elseif type(Z)==\"table\"then return c.lua.encode(Z)elseif type(Z)==\"string\"then return Z else return tostring(Z)end end;if az then aB=ar else while q<=#ar do local a8=string.sub(ar,q,q)if a8=='$'and not as and not aA then local s,aa=al(string.sub(ar,q))s=aC(s)aB=aB..s;q=q+aa else if a8=='\\''and not as then aA=not aA end;as=a8=='\\\\'and not as;aB=aB..a8 end;q=q+1 end end;local ak={{[0]=\"\"}}q=0;local au=1;local at=false;as=false;local av,aD;for a8 in string.gmatch(aB,\".\")do if aD then if a8==';'then au=au+1;q=0;ak[au]={[0]=\"\"}elseif av=='&'and a8=='&'then ak[au][aD]=string.sub(ak[au][aD],1,-2)au=au+1;q=0;ak[au]={[0]=\"\",last=0}elseif av=='|'and a8=='|'then ak[au][aD]=string.sub(ak[au][aD],1,-2)au=au+1;q=0;ak[au]={[0]=\"\",last=1}elseif av=='2'and a8=='>'then ak[au].stderr=\"\"aD=\"stderr\"elseif a8=='>'then ak[au].stdout=\"\"aD=\"stdout\"elseif a8=='<'then ak[au].stdin=\"\"aD=\"stdin\"elseif a8~=' 'or ak[au][aD]~=\"\"then ak[au][aD]=ak[au][aD]..a8 end elseif not as then if(a8=='\"'or a8=='\\'')and not as then at=not at elseif not at then if a8==' 'then if#ak[au][q]>0 then q=q+1;ak[au][q]=\"\"end elseif a8==';'then if ak[au][q]==\"\"then ak[au][q]=nil end;au=au+1;q=0;ak[au]={[0]=\"\"}elseif av=='&'and a8=='&'then ak[au][q]=string.sub(ak[au][q],1,-2)if ak[au][q]==\"\"then ak[au][q]=nil end;au=au+1;q=0;ak[au]={[0]=\"\",last=0}elseif av=='|'and a8=='|'then ak[au][q]=string.sub(ak[au][q],1,-2)if ak[au][q]==\"\"then ak[au][q]=nil end;au=au+1;q=0;ak[au]={[0]=\"\",last=1}elseif av=='2'and a8=='>'then if ak[au][q]==\"\"then ak[au][q]=nil end;ak[au].stderr=\"\"aD=\"stderr\"elseif a8=='>'then if ak[au][q]==\"\"then ak[au][q]=nil end;ak[au].stdout=\"\"aD=\"stdout\"elseif a8=='<'then if ak[au][q]==\"\"then ak[au][q]=nil end;ak[au].stdin=\"\"aD=\"stdin\"elseif a8~='\\\\'then ak[au][q]=ak[au][q]..a8 end else ak[au][q]=ak[au][q]..a8 end else ak[au][q]=ak[au][q]..a8 end;as=a8=='\\\\'and not at and not as;av=a8 end;if av=='&'then ak.async=true end;for Y,Z in ipairs(ak)do if Z[0]~=\"\"then local R,ad=i.resolveProgram(Z[0])R=R or Z[0]if not(ad and string.find(Z[0],\"/\")==nil)then Z[0]=R end;Z.vars={}while Z[0]and string.find(Z[0],\"=\")do local a3=string.sub(Z[0],1,string.find(Z[0],\"=\")-1)Z.vars[a3]=string.sub(Z[0],string.find(Z[0],\"=\")+1)Z.vars[a3]=tonumber(Z.vars[a3])or Z.vars[a3]Z[0]=nil;for q=1,table.maxn(Z)do Z[q-1]=Z[q]Z[q]=nil end end end end;return ak end;local aE=31+28+31+30+31+30;local function aF(aG)if aG<=31 then return\"Jan \"..aG elseif aG>31 and aG<=31+28 then return\"Feb \"..aG-31 elseif aG>31+28 and aG<=31+28+31 then return\"Mar \"..aG-31-28 elseif aG>31+28+31 and aG<=31+28+31+30 then return\"Apr \"..aG-31-28-31 elseif aG>31+28+31+30 and aG<=31+28+31+30+31 then return\"May \"..aG-31-28-31-30 elseif aG>31+28+31+30+31 and aG<=aE then return\"Jun \"..aG-31-28-31-30-31 elseif aG>aE and aG<=aE+31 then return\"Jul \"..aG-aE elseif aG>aE+31 and aG<=aE+31+31 then return\"Aug \"..aG-aE-31 elseif aG>aE+31+31 and aG<=aE+31+31+30 then return\"Sep \"..aG-aE-31-31 elseif aG>aE+31+31+30 and aG<=aE+31+31+30+31 then return\"Oct \"..aG-aE-31-31-30 elseif aG>aE+31+31+30+31 and aG<=aE+31+31+30+31+30 then return\"Nov \"..aG-aE-31-31-30-31 else return\"Dec \"..aG-aE-31-31-30-31-30 end end;local function aH()local ak=(y>0 or A>0 or C>0)and t.PS2 or t.PS1 or\"\\\\$ \"for Y,Z in pairs({[\"\\\\d\"]=aF(0),[\"\\\\e\"]=string.char(0x1b),[\"\\\\h\"]=string.sub(\"localhost\",1,string.find(\"localhost\",\"%.\")),[\"\\\\H\"]=\"localhost\",[\"\\\\n\"]=\"\\n\",[\"\\\\s\"]=string.gsub(t[\"0\"]:match(\"[^/]+$\"),\".lua\",\"\"),[\"\\\\t\"]=\"00:00\",[\"\\\\T\"]=\"00:00\",[\"\\\\u\"]=o.USER,[\"\\\\v\"]=t.CASH_VERSION,[\"\\\\V\"]=t.CASH_VERSION,[\"\\\\w\"]=o.PWD,[\"\\\\W\"]=o.PWD:match(\"[^/]+$\")==\".\"and\"/\"or o.PWD:match(\"[^/]+$\"),[\"\\\\%#\"]=t.LINENUM,[\"\\\\%$\"]=o.USER==\"root\"and\"#\"or\"$\",[\"\\\\([0-7][0-7][0-7])\"]=function(aa)return string.char(tonumber(aa,8))end,[\"\\\\\\\\\"]=\"\\\\\",[\"\\\\%[.+\\\\%]\"]=\"\"})do ak=string.gsub(ak,Y,Z)end;return ak end;function I(aI)local R=aI[0]if R==nil then return end;if#aI==0 and string.find(R,\"=\")~=nil then local Y=string.sub(R,1,string.find(R,\"=\")-1)t[Y]=string.sub(R,string.find(R,\"=\")+1)t[Y]=tonumber(t[Y])or t[Y]return end;local aJ={}for Y,Z in pairs(aI.vars)do aJ[Y]=_ENV[Y]_ENV[Y]=Z end;if y>0 and not x[y].cond and R~=\"else\"and R~=\"elif\"and R~=\"fi\"then return end;if u.x then P(\"- \"..table.concat(aI,\" \",0))end;local ae;if Q[R]~=nil then local aK,aL=io.input(),io.output()if aI.stdin then io.input(aI.stdin)end;if aI.stdout then io.output(aI.stdout)end;t[\"?\"]=Q[R](table.unpack(aI))if aI.stdin then io.input():close()io.input(aK)end;if aI.stdout then io.output():close()io.output(aL)end;if t[\"?\"]==nil or t[\"?\"]==true then t[\"?\"]=0 elseif t[\"?\"]==false then t[\"?\"]=1 end elseif E[R]~=nil and not L then local aM=f;f=aI;J=true;for Y,Z in ipairs(E[R])do i.run(Z)if not J then break end end;f=aM else local ab=a.stat(R)if not ab then io.stderr:write(\"cash: \"..R..\": No such file or directory\\n\")t[\"?\"]=-1;return elseif not(ab.permissions[b.getuser()]or ab.worldPermissions).execute then io.stderr:write(\"cash: \"..R..\": Permission denied\\n\")t[\"?\"]=-1;return end;if aI.stdin then aI.stdin=a.open(aI.stdin,\"rb\")end;if aI.stdout then aI.stdout=a.open(aI.stdout,\"wb\")end;if aI.stderr then aI.stderr=a.open(aI.stderr,\"wb\")end;local aN=t._;t._=R;if m then if aI.stdin then e.syscall.stdin(aI.stdin)end;if aI.stdout then e.syscall.stdout(aI.stdout)end;if aI.stderr then e.syscall.stderr(aI.stderr)end;b.exec(R,table.unpack(aI))return end;local aO=b.fork(function()if aI.stdin then e.syscall.stdin(aI.stdin)end;if aI.stdout then e.syscall.stdout(aI.stdout)end;if aI.stderr then e.syscall.stderr(aI.stderr)end;b.exec(R,table.unpack(aI))end)while true do local U,aP=coroutine.yield()if U==\"process_complete\"and aP.pid==aO then t[\"?\"]=aP.return_value;break end;ae=b.getpinfo(aO)end;if aI.stdin then aI.stdin.close()end;if aI.stdout then aI.stdout.close()end;if aI.stderr then aI.stderr.close()end;if t[\"?\"]==nil or t[\"?\"]==true then t[\"?\"]=0 elseif t[\"?\"]==false then t[\"?\"]=1 end;t._=aN end;for Y,Z in pairs(aI.vars)do _ENV[Y]=aJ[Y]end;return ae end;function H(aI,aQ)if aI.async and not aQ then local aO=b.fork(function()return H(aI,true)end,\"cash\")local aR=#N+1;N[aR]={cmd=aI[1][0]..\" \"..table.concat(aI[1],\" \"),pid=aO,isfg=false,start=true}P(\"[\"..aR..\"] \"..(aO or\"\"))else for aS,aT in ipairs(aI)do if aT[0]then if r(aT[0])~=\"\"and(aT.last==0 and t[\"?\"]==0)or aT.last==1 and t[\"?\"]~=0 or aT.last==nil then I(aT)end else for Y,Z in pairs(aT.vars)do t[Y]=tonumber(Z)or Z end end end end;return t[\"?\"]==0 end;local aU=function(aI)local aO=b.fork(function()return H(aI,true)end,\"cash\")local aR=#N+1;N[aR]={cmd=aI[1][0]and aI[1][0]..\" \"..table.concat(aI[1],\" \")or\"cash\",pid=aO,isfg=not aI.async,start=true}if aI.async then P(\"[\"..aR..\"] \"..(aO or\"\"))end end;function i.run(...)local aV=table.concat({...},\" \")if aV==\"\"or string.sub(aV,1,1)==\"#\"then return end;if D~=nil then if string.find(aV,\"}\")then D=nil else table.insert(E[D],aV)end;return true elseif A>0 then local aI=aq(aV)for Y,T in ipairs(aI)do T=string.sub(T,#string.match(T,\"^ *\")+1)if T==\"do\"or T==\"done\"or string.find(T,\"^do \")or string.find(T,\"^done \")then H(ay(T))end;if A>0 then table.insert(z[1].lines,T)end end;return true end;local a1=aq(aV)for Y,Z in ipairs(a1)do H(ay(Z,string.sub(Z,1,6)==\"while \"))end;return t[\"?\"]==0 end;function i.runAsync(...)local aV=table.concat({...},\" \")if aV==\"\"or string.sub(aV,1,1)==\"#\"then return end;if D~=nil then if string.find(aV,\"}\")then D=nil else table.insert(E[D],aV)end;return true elseif A>0 then local aI=aq(aV)for Y,T in ipairs(aI)do T=string.sub(T,#string.match(T,\"^ *\")+1)if T==\"do\"or T==\"done\"or string.find(T,\"^do \")or string.find(T,\"^done \")then H(ay(T))end;if A>0 then table.insert(z[1].lines,T)end end;return true end;local a1=aq(aV)for Y,Z in ipairs(a1)do aU(ay(Z,string.sub(Z,1,6)==\"while \"))end;return t[\"?\"]==0 end;if a.stat(\"/etc/cashrc\")then local S,X=io.open(\"/etc/cashrc\",\"r\")if not S then io.stderr:write(\"Could not open /etc/cashrc:\",X)else for T in S:lines()do i.run(T)end;S:close()end end;if a.stat(a.combine(o.HOME,\".cashrc\"))then local S,X=io.open(a.combine(o.HOME,\".cashrc\"),\"r\")if not S then io.stderr:write(\"Could not open .cashrc:\",X)else for T in S:lines()do i.run(T)end;S:close()end end;if a.stat(a.combine(o.HOME,\".cash_history\"))then local S,X=io.open(a.combine(o.HOME,\".cash_history\"),\"r\")if not S then io.stderr:write(\"Could not open .cashhistory:\",X)else for T in S:lines()do table.insert(F,1,T)end;S:close()end;G=a.open(a.combine(o.HOME,\".cash_history\"),\"a\")else G=a.open(a.combine(o.HOME,\".cash_history\"),\"w\")end;if h then t[\"0\"]=g;t.LINENUM=1;i.run(h)t.LINENUM=nil;return l end;if g then if g==\"-\"then t.LINENUM=1;for T in io.lines()do i.run(T)t.LINENUM=t.LINENUM+1;if not k then break end end;t.LINENUM=nil;return l else local S=io.open(g,\"r\")if not S then S=io.open(i.resolveProgram(g),\"r\")if not S then return 1 end end;t[\"0\"]=g;t.LINENUM=1;for T in S:lines()do i.run(T)t.LINENUM=t.LINENUM+1;if not k then break end end;S:close()t.LINENUM=nil;return l end end;while k do if f.i then local aW=aH()io.stdout:write(aW)end;local aX=d.readline2(F,function(aY)if aY:find\" \"then local R=aY:match\"%S*$\"local aZ=a.find(R..\"*\")for q,Z in ipairs(aZ)do if a.isDir(Z)then aZ[q]=Z:gsub(\"^\"..R:gsub(\"[%^%$%(%)%[%]%%%.%*%+%-%?]\",\"%%%1\"),\"\")..\"/\"else aZ[q]=Z:gsub(\"^\"..R:gsub(\"[%^%$%(%)%[%]%%%.%*%+%-%?]\",\"%%%1\"),\"\")..\" \"end end;table.sort(aZ)return aZ else local a_={}for Y in pairs(Q)do if Y:sub(1,#aY)==aY then a_[#a_+1]=Y:sub(#aY+1)..\" \"end end;for Y in pairs(E)do if Y:sub(1,#aY)==aY then a_[#a_+1]=Y:sub(#aY+1)..\" \"end end;for R in o.PATH:gmatch\"[^:]+\"do R=a.combine(R,aY)local aZ=a.find(R..\"*\")for aS,Z in ipairs(aZ)do a_[#a_+1]=Z:gsub(\"^\"..R:gsub(\"[%^%$%(%)%[%]%%%.%*%+%-%?]\",\"%%%1\"),\"\"):gsub(\"%.lua$\",\"\")..\" \"end end;table.sort(a_)return a_ end end)if f.i then if G and aX~=\"\"and aX~=F[1]then table.insert(F,1,aX)G.writeLine(aX)G.flush()end end;i.run(aX)end;if m then i.run(m)return t[\"?\"]end;G.close()return l\n",created=1704748610401,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=21869},["sh.lua"]={modified=1704748610388,data="return coroutine.yield(\"syscall\",\"exec\",\"/bin/cash\",...)\n",created=1704748610426,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=57},["printf.lua"]={modified=1704748610383,data="local a={...}if#a<1 then error(\"printf: missing format\")end;local b=table.remove(a,1)local c={}for d in b:gmatch\"%%[%-%+ #0]?%d*%.?%d*[jzt]?[diuoxXfFeEgGaAcsq]\"do local e=d:sub(-1,-1)local f=#c+1;local g=assert(a[f],\"printf: missing argument for \"..d)if e==\"q\"or e==\"s\"then c[f]=g else c[f]=assert(tonumber(g),\"printf: argument \"..g..\" not a number\")end end;print(b:format(table.unpack(c)))\n",created=1704748610422,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=391},["env.lua"]={modified=1704748610368,data="local a=require\"system.process\"local b={...}local c=a.getenv()while#b>0 do if b[1]==\"-i\"then for d in pairs(c)do c[d]=nil end;table.remove(b,1)elseif b[1]:find(\"=\")then local d,e=table.remove(b,1):match\"^([^=]+)=(.*)$\"c[d]=e else break end end;if#b==0 then for d,e in pairs(c)do print(d..\"=\"..e)end else return a.execp(table.unpack(b))end\n",created=1704748610412,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=339},["mkfifo.lua"]={modified=1704748610378,data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=assert(b.argparse({m=true},...))local function d(e)local f=a.stat(e,true)local g=tonumber(c.m,8)if g then a.chmod(e,f.owner,bit32.band(bit32.rshift(g,6),7))a.chmod(e,nil,bit32.band(g,7))else for h in c.m:gmatch\"[^,]+\"do local i,j=h:match\"^([^%+%-=]*)([%+%-=][rwxs]+)$\"if not i then error(\"chmod: invalid mode: \"..h)end;if i==\"\"then i=nil end;a.chmod(e,i,j)end end end;for k,l in ipairs(c)do a.mkfifo(l)if c.m then d(l)end end\n",created=1704748610419,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=496},["clear.lua"]={modified=1704748610361,data="io.write(\"\\x1b[0m\\x1b[2J\\x1b[H\")\n",created=1704748610404,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=33},["uncompress.lua"]={modified=1704748610391,data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=string.char;local type=type;local d=string.sub;local e=table.concat;local f=math.floor;local g=string.byte;local h={}for i=0,255 do local j=c(i)h[i]=j end;local function k(l,m,n,o)if n>=256 then n,o=0,o+1;if o>=256 then m={}o=1 end end;m[o*256+n]=l;n=n+1;return m,n,o end;local function p(q)if type(q)~=\"string\"then return nil,\"string expected, got \"..type(q)end;if#q<1 then return nil,\"invalid input - not a compressed string\"end;local r=#q;if r<3 then return nil,\"invalid input - not a compressed string\"end;if d(q,1,2)~=\"\\x1F\\x9D\"then return nil,\"invalid input - not a compressed string\"end;local s,t,u,v=9,0,0,4;local function w()while u<s do if v>r then return nil end;t=t+g(q,v)*2^u;v=v+1;u=u+8 end;local x=t%2^s;t=f(t/2^s)u=u-s;return x end;local m={}local n,o=1,1;local y={}local z=1;local A=w()y[z]=h[A]or m[A]z=z+1;while true do local B=w()if not B then break end;local C=h[A]or m[A]if not C then return nil,\"could not find last from dict. Invalid input?\"end;local D=h[B]or m[B]if D then y[z]=D;z=z+1;m,n,o=k(C..d(D,1,1),m,n,o)else local E=C..d(C,1,1)y[z]=E;z=z+1;m,n,o=k(E,m,n,o)end;if n==256 and o==2^(s-8)-1 then local F=u%8;if F~=0 then t=f(t/2^F)u=u-F end;s=s+1 end;A=B end;return e(y)end;local G=assert(b.argparse({c=false,f=false,k=false,v=false},...))local H;if G[1]==\"-\"or G[1]==nil then H=io.read(\"*a\")else local I=assert(io.open(G[1],\"rb\"))H=I:read(\"*a\")I:close()end;local J=assert(p(H))if G.v then io.stderr:write((\"%s: %.3g%%\\n\"):format(G[1],#J/#H*100))end;if G.c then io.write(J)return end;local K=G[1]:gsub(\"%.Z$\",\"\")if not G.f and a.exists(K)then io.write(\"replace file \"..K..\"? (y/N) \")local L=io.read()if L~=\"Y\"and L~=\"y\"then return 1 end end;local I=assert(io.open(K,\"wb\"))I:write(J)I:close()if not G.k then os.remove(G[1])end\n",created=1704748610430,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1826},["logger.lua"]={modified=1704748610374,data="local a=require\"system.log\"local b=require\"system.process\"local c=require\"system.util\"local d={[0]=\"Debug\",\"Info\",\"Notice\",\"Warning\",\"Error\",\"Critical\",\"Panic\"}local e={[0]='\\27[90m','\\27[97m','\\27[36m','\\27[93m','\\27[31m','\\27[95m','\\27[96m'}local f={...}local g=table.remove(f,1)if g==\"log\"then f=assert(c.argparse({c=true,l=true,m=true,n=true},table.unpack(f)))a.log({name=f.n,level=f.l,category=f.c,module=f.m},table.unpack(f))elseif g==\"create\"then f=assert(c.argparse({F=true,s=false},table.unpack(f)))if not f[1]then error(\"Usage: logger create [-F <file>] [-s] <log>\")end;a.create(f[1],f.s,f.F)elseif g==\"delete\"then f=assert(c.argparse({p=true},table.unpack(f)))if not f[1]then error(\"Usage: logger delete [-p] <log>\")end;a.remove(f[1])if f.p then os.remove(\"/var/log/\"..f[1]..\".log\")end elseif g==\"view\"then if not f[1]then error(\"Usage: logger view <log>\")end;b.run(\"/bin/less\",\"/var/log/\"..f[1]..\".log\")elseif g==\"follow\"then f=assert(c.argparse({f=true},table.unpack(f)))if not f[1]then error(\"Usage: logger follow [-f <filter>] <log>\")end;a.open(f[1],f.f)print(\"Listening for messages...\")while true do local h,i=coroutine.yield()if h==\"syslog\"then if i.traceback then i.message=i.message:gsub(\"\\t\",\"  \"):gsub(\"([^\\n]+):(%d+):\",\"\\27[96m%1\\27[37m:\\27[95m%2\\27[37m:\"):gsub(\"'([^']+)'\\n\",\"\\27[93m'%1'\\27[37m\\n\")end;local j=b.getpinfo(i.process)print((\"%s[%s]%s %s[%d%s]%s [%s]: %s\\27[0m\"):format(e[i.level],os.date(\"%b %d %X\",i.time/1000),i.category and\" <\"..i.category..\">\"or\"\",j and j.name or\"(unknown)\",i.process,i.thread and\":\"..i.thread or\"\",i.module and\" (\"..i.module..\")\"or\"\",d[i.level],i.message))end end else error(\"Usage: logger <log|create|delete|view|follow> ...\")end\n",created=1704748610416,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1691},["chown.lua"]={modified=1704748610359,data="local a=require\"system.util\"local b=require\"system.filesystem\"local c=assert(a.argparse({h=false,H=false,L=false,P=false,R=false},...))if#c<2 then error(\"usage: chown [-h] [-R [-H|-L|-P]] <owner> <file...>\")end;local function d(e,f)b.chown(e,f)if b.stat(e,true).type==\"directory\"then for g,h in ipairs(b.list(e))do d(b.combine(e,h),f)end end end;local f=c[1]:gsub(\":.*\",\"\")for i=2,#c do if c.R then d(c[i],f)else b.chown(c[i],f)end end\n",created=1704748610403,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=436},["tty.lua"]={modified=1704748610390,data="local a=require\"system.process\"local b=a.getpinfo(a.getpid())if b.stdout then print(\"tty\"..b.stdout)end\n",created=1704748610429,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=104},["less.lua"]={modified=1704748610373,data="local a=require\"system.filesystem\"local b=require\"system.keys\"local c=require\"system.process\"local d=require\"system.terminal\"local e=require\"system.util\"local f=assert(e.argparse({[\"chop-long-lines\"]=false,S=\"@chop-long-lines\",[\"prompt\"]=true,P=\"@prompt\",help=false,version=false},...))local g=f[1]local h=not f[\"chop-long-lines\"]local i=f.prompt;if g==nil and not d.istty()then g=\"-\"end;if g==nil then error(\"Missing filename (\\\"less --help\\\" for help)\")end;local j;local k=assert(d.openterm())local l,m,n={},{},{}local o,p=1,1;local q,r=k.getSize()r=r-1;local function s()l={}if g==\"-\"then if not j then j={}repeat local t=io.stdin:read()j[#j+1]=t until not t end;for u,v in ipairs(j)do l[u]=v end else local w=a.open(g,\"r\")if w==nil then error(\"Could not open file \"..g)end;local t=w.readLine()while t do table.insert(l,({string.gsub(t,\"\\t\",\"    \")})[1])t=w.readLine()end;w.close()end;for u,v in ipairs(l)do local x,y,z=\"\",\"\",\"\"local A=1;local B,C=\"0\",\"f\"for D,E,F in v:gmatch\"()%f[\\x1b]\\x1b%[(%d+)m()\"do x=x..v:sub(A,D-1)y=y..B:rep(D-A)z=z..C:rep(D-A)E=tonumber(E)if E==0 then B,C=\"0\",\"f\"elseif E>=30 and E<=37 then B=(\"%x\"):format(15-(E-30))elseif E==39 then B='0'elseif E>=40 and E<=47 then C=(\"%x\"):format(15-(E-40))elseif E==49 then C='f'elseif E>=90 and E<=97 then B=(\"%x\"):format(15-(E-90)-8)elseif E>=100 and E<=107 then C=(\"%x\"):format(15-(E-100)-8)end;A=F end;x=x..v:sub(A)y=y..B:rep(#v-A+1)z=z..C:rep(#v-A+1)l[u],m[u],n[u]=x,y,z end;if h and p==1 then local u=1;while u<=#l do while#l[u]>q do local G=q-(l[u]:sub(1,q):reverse():find(\" \")or 1)+1;table.insert(l,u+1,string.sub(l[u],G+1)or\"\")table.insert(m,u+1,string.sub(m[u],G+1)or\"\")table.insert(n,u+1,string.sub(n[u],G+1)or\"\")l[u],m[u],n[u]=l[u]:sub(1,G),m[u]:sub(1,G),n[u]:sub(1,G)end;u=u+1 end end end;local function H()k.clear()k.setCursorPos(1,1)k.setCursorBlink(false)for u=o,o+r-1 do if l[u]~=nil then k.blit(l[u]:sub(p),m[u]:sub(p),n[u]:sub(p))end;k.setCursorPos(1,u-o+2)end;k.setCursorPos(1,r+1)if i then k.blit(i,string.rep(\"f\",#i),string.rep(\"0\",#i))elseif o>=#l-r then k.blit(\"(END)\",\"fffff\",\"00000\")else k.write(\":\")end;k.setCursorBlink(true)end;local function I(J,m,n)k.setCursorPos(1,r+1)k.clearLine()k.blit(J,m or string.rep(\"0\",#J),n or string.rep(\"f\",#J))local K=\"\"local L=1;while true do k.setCursorPos(#J+1,r+1)k.write(K..string.rep(\" \",q-#K-#J-2))k.setCursorPos(#J+L,r+1)k.setCursorBlink(true)local M,N=coroutine.yield()if M==\"key\"then if N.keycode==b.backspace then if K==\"\"then return nil elseif L>1 then K=string.sub(K,1,L-2)..string.sub(K,L)L=L-1 end elseif N.keycode==b.left and L>1 then L=L-1 elseif N.keycode==b.right and L<#K+1 then L=L+1 elseif N.keycode==b.enter then return K end elseif M==\"char\"then K=string.sub(K,1,L-1)..N.character..string.sub(K,L)L=L+1 end end end;local function O()local P,n,Q=k.getPaletteColor(d.colors.black)k.setPaletteColor(d.colors.black,k.getPaletteColor(d.colors.lightGray))e.sleep(0.1)k.setPaletteColor(d.colors.black,k.getPaletteColor(d.colors.gray))e.sleep(0.05)k.setPaletteColor(d.colors.black,P,n,Q)e.sleep(0.05)end;s()local R=nil;while true do H()local M,N=coroutine.yield()local S=i;i=nil;if M==\"key\"then if N.keycode==b.left and p>q/2 then p=p-q/2 elseif N.keycode==b.right then p=p+q/2 elseif N.keycode==b.up then if o>1 then o=o-1 else O()end elseif N.keycode==b.down or N.keycode==b.enter then if o<#l-r then o=o+1 else O()end elseif N.keycode==b.space then if o<#l-r then o=o+(o<#l-2*r+1 and r or#l-r-o)else O()end end elseif M==\"char\"then if N.character==\"q\"then break elseif N.character==\"f\"then if o<#l-r then o=o+(o<#l-2*r+1 and r or#l-r-o)else O()end elseif N.character==\"b\"then if o>1 then o=o-(o>r+1 and r or o-1)else O()end elseif N.character==\"d\"then if o<#l-r then o=o+(o<#l-1.5*r+1 and r/2 or#l-r-o)else O()end elseif N.character==\"u\"then if o>1 then o=o-(o>r/2+1 and r/2 or o-1)else O()end elseif N.character==\"g\"or N.character==\"<\"then o=1 elseif N.character==\"G\"or N.character==\">\"then o=#l-r elseif N.character==\"e\"or N.character==\"j\"then if o<#l-r then o=o+1 else O()end elseif N.character==\"y\"or N.character==\"k\"then if o>1 then o=o-1 else O()end elseif N.character==\"K\"or N.character==\"Y\"then o=o-1 elseif N.character==\"J\"then o=o+1 elseif N.character==\"/\"then local T=I(\"/\")if T==\"\"then T=R end;if T~=nil then R=T;local U=false;for u=o+1,#l do if string.match(l[u],T)then o=u;U=true;break end end;if o>#l-r then o=#l-r end;if not U then i=\"Pattern not found\"end end elseif N.character==\"?\"then local T=I(\"?\")if T==\"\"then T=R end;if T~=nil then R=T;local U=false;for u=o-1,1,-1 do if string.match(l[u],T)then o=u;U=true;break end end;if o>#l-r then o=#l-r end;if not U then i=\"Pattern not found\"end end elseif N.character==\"n\"then local U=false;for u=o+1,#l do if string.match(l[u],R)then o=u;U=true;break end end;if o>#l-r then o=#l-r end;if not U then i=\"Pattern not found\"end elseif N.character==\"N\"then local U=false;for u=o-1,1,-1 do if string.match(l[u],R)then o=u;U=true;break end end;if o>#l-r then o=#l-r end;if not U then i=\"Pattern not found\"end elseif N.character==\"v\"then local V=c.start(EDITOR or\"/bin/vi\",g)repeat local M,N=coroutine.yield()until M==\"process_complete\"and N.id==V;s()elseif N.character==\"!\"then local W=I(\"!\")if W then local V=c.start(string.gsub(W,\"%%\",g))repeat local M,N=coroutine.yield()until M==\"process_complete\"and N.id==V end end elseif M==\"term_resize\"then q,r=k.getSize()r=r-1;s()elseif M==\"mouse_scroll\"then if N.direction==1 and o<#l-r then o=o+1 elseif N.direction==-1 and o>1 then o=o-1 end else i=S end end;k.clear()k.setCursorPos(1,1)k.close()\n",created=1704748610415,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=5547},["ar.lua"]={modified=1704748610203,data="local a=require\"ar\"local function b(c,d,e)return string.len(c)<d and string.sub(c,1,d)..string.rep(e or\" \",d-string.len(c))or c end;local function f(g,c,e)local h=\"\"for i=1,string.len(c)do h=h..(bit32.band(g,bit32.lshift(1,string.len(c)-i))==0 and e or string.sub(c,i,i))end;return h end;local j={...}if#j<2 then error(\"Usage: ar <dpqrtx[cfTuv]> <archive.a> [path] [files...]\")end;if j[1]==\"--version\"then print(\"Phoenix ar (baseutils) 1.0 (compatible with GNU/BSD ar)\\nCopyright (c) 2019-2022 JackMacWindows.\")return 2 end;local k=nil;local l=false;local m=false;if string.find(j[1],\"d\")then k=0 end;if string.find(j[1],\"p\")then k=1 end;if string.find(j[1],\"q\")then k=2 end;if string.find(j[1],\"r\")then k=3 end;if string.find(j[1],\"t\")then k=4 end;if string.find(j[1],\"x\")then k=5 end;if string.find(j[1],\"c\")then a.verbosity=-1 end;if string.find(j[1],\"v\")then a.verbosity=1 end;if string.find(j[1],\"u\")then l=true end;if string.find(j[1],\"T\")then m=true end;if string.find(j[1],\"f\")then m=true end;local n=a.load(j[2])local o={...}table.remove(o,1)table.remove(o,1)if n==nil then if a.verbosity>-1 then print(\"ar: Creating archive \"..j[2])end;n={}end;if k==0 then for p,q in pairs(n)do for r,s in pairs(o)do if q.name==s then n[p]=nil;break end end end;a.save(n,j[2])elseif k==1 then if#j>2 then for p,q in pairs(n)do for r,s in pairs(o)do if q.name==s then print(q.data)break end end end else for p,q in pairs(n)do print(q.data)end end elseif k==2 then for p,q in pairs(o)do local t=a.read(q)t.name=string.sub(t.name,1,m and 15 or nil)table.insert(n,t)end;a.save(n,j[2])elseif k==3 then for p,q in pairs(o)do local t=a.read(q)t.name=string.sub(t.name,1,m and 15 or nil)local u=false;for r,s in pairs(n)do if s.name==t.name then u=true;for v,w in pairs(t)do s[v]=t[v]end;break end end;if not u then table.insert(n,t)end end;a.save(n,j[2])elseif k==4 then if a.verbosity>0 then local x={}local y={0,0,0,0,0}for p,q in pairs(n)do local z=os.date(\"%c\",q.timestamp or 0)local A={f(q.mode,\"rwxrwxrwx\",\"-\"),q.owner..\"/\"..q.group,string.len(q.data),z,q.name}for r,s in pairs(A)do if string.len(s)+3>y[r]then y[r]=string.len(s)+3 end end;table.insert(x,A)end;for p,q in pairs(x)do for r,s in pairs(q)do io.write(b(s,y[r]))end;print(\"\")end else for p,q in pairs(n)do print(q.name)end end elseif k==5 then local B=#o>0 and table.remove(o,1)or\".\"local t;if#o>0 then t={}for p,q in pairs(n)do for r,s in pairs(o)do if q.name==s then table.insert(t,q)break end end end else t=n end;a.extract(t,B)else error(\"Unknown mode\")end\n",created=1704748610206,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=2516},["true.lua"]={modified=1704748610389,data="return true\n",created=1704748610428,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=12},["uname.lua"]={modified=1704748610391,data="local a=require\"system.util\"local b=assert(a.argparse({a=false,m=false,n=false,r=false,s=false,v=false},...))if next(b)==nil then b.s=true end;if b.a then b.m,b.n,b.r,b.s,b.v=true,true,true,true,true end;local c={}if b.s then c[#c+1]=\"Phoenix\"end;if b.n then c[#c+1]=a.syscall.devinfo(\"/\").name end;if b.r then c[#c+1]=a.syscall.version()end;if b.v then c[#c+1]=a.syscall.version(true)end;if b.m then c[#c+1]=a.syscall.cchost()end;print(table.concat(c,\" \"))\n",created=1704748610429,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=458},["halt.lua"]={modified=1704748610371,data="coroutine.yield(\"syscall\",\"devcall\",\"/\",\"shutdown\")\n",created=1704748610413,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=52},["df.lua"]={modified=1704748610365,data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=assert(b.argparse({k=false,P=false,t=false,h=false},...))local d=a.mountlist()local e={}if#c==0 then for f,g in ipairs(d)do e[f],g.stat=g,a.stat(g.path)end else for f,g in ipairs(c)do local h,i=a.stat(g)if h then for j,k in ipairs(d)do if k.path==h.mountpoint then e[f],k.stat=k,h;break end end else io.stderr:write(\"df: could not stat \"..g..\": \"..(i or\"\")..\"\\n\")end end end;if c.P then local l=c.k and 1024 or 512;print(\"Filesystem \"..l..\"-blocks Used Available Capacity Mounted on\")for j,g in ipairs(e)do print((\"%s %d %d %d %d%% %s\"):format(g.source,math.ceil(g.stat.capacity/l),math.ceil((g.stat.capacity-g.stat.freeSpace)/l),math.ceil(g.stat.freeSpace/l),math.floor((g.stat.capacity-g.stat.freeSpace)/g.stat.capacity*100),g.path))end elseif c.h then local function m(n)if n>=1000000000000 then return(\"%.3gT\"):format(n/1000000000000)elseif n>=1000000000 then return(\"%.3gG\"):format(n/1000000000)elseif n>=1000000 then return(\"%.3gM\"):format(n/1000000)elseif n>=1000 then return(\"%.3gK\"):format(n/1000)else return(\"%.3g \"):format(n)end end;print(\"Filesystem\\tSize\\tUsed\\tAvail\\tUse%\\tMounted on\")for j,g in ipairs(e)do print((\"%s\\t%s\\t%s\\t%s\\t%3d%%\\t%s\"):format(g.source..(#g.source<8 and\"\\t\"or\"\"),m(g.stat.capacity),m(g.stat.capacity-g.stat.freeSpace),m(g.stat.freeSpace),math.floor((g.stat.capacity-g.stat.freeSpace)/g.stat.capacity*100),g.path))end else local l=c.k and 1024 or 512;print(\"Filesystem\\tSize\\tUsed\\tAvail\\tUse%\\tMounted on\")for j,g in ipairs(e)do print((\"%s\\t%d\\t%d\\t%d\\t%d%%\\t%s\"):format(g.source..(#g.source<8 and\"\\t\"or\"\"),math.ceil(g.stat.capacity/l),math.ceil((g.stat.capacity-g.stat.freeSpace)/l),math.ceil(g.stat.freeSpace/l),math.floor((g.stat.capacity-g.stat.freeSpace)/g.stat.capacity*100),g.path))end end\n",created=1704748610409,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1806},["cksum.lua"]={modified=1704748610360,data="local a={...}local b={[0]=0x00000000,0x04c11db7,0x09823b6e,0x0d4326d9,0x130476dc,0x17c56b6b,0x1a864db2,0x1e475005,0x2608edb8,0x22c9f00f,0x2f8ad6d6,0x2b4bcb61,0x350c9b64,0x31cd86d3,0x3c8ea00a,0x384fbdbd,0x4c11db70,0x48d0c6c7,0x4593e01e,0x4152fda9,0x5f15adac,0x5bd4b01b,0x569796c2,0x52568b75,0x6a1936c8,0x6ed82b7f,0x639b0da6,0x675a1011,0x791d4014,0x7ddc5da3,0x709f7b7a,0x745e66cd,0x9823b6e0,0x9ce2ab57,0x91a18d8e,0x95609039,0x8b27c03c,0x8fe6dd8b,0x82a5fb52,0x8664e6e5,0xbe2b5b58,0xbaea46ef,0xb7a96036,0xb3687d81,0xad2f2d84,0xa9ee3033,0xa4ad16ea,0xa06c0b5d,0xd4326d90,0xd0f37027,0xddb056fe,0xd9714b49,0xc7361b4c,0xc3f706fb,0xceb42022,0xca753d95,0xf23a8028,0xf6fb9d9f,0xfbb8bb46,0xff79a6f1,0xe13ef6f4,0xe5ffeb43,0xe8bccd9a,0xec7dd02d,0x34867077,0x30476dc0,0x3d044b19,0x39c556ae,0x278206ab,0x23431b1c,0x2e003dc5,0x2ac12072,0x128e9dcf,0x164f8078,0x1b0ca6a1,0x1fcdbb16,0x018aeb13,0x054bf6a4,0x0808d07d,0x0cc9cdca,0x7897ab07,0x7c56b6b0,0x71159069,0x75d48dde,0x6b93dddb,0x6f52c06c,0x6211e6b5,0x66d0fb02,0x5e9f46bf,0x5a5e5b08,0x571d7dd1,0x53dc6066,0x4d9b3063,0x495a2dd4,0x44190b0d,0x40d816ba,0xaca5c697,0xa864db20,0xa527fdf9,0xa1e6e04e,0xbfa1b04b,0xbb60adfc,0xb6238b25,0xb2e29692,0x8aad2b2f,0x8e6c3698,0x832f1041,0x87ee0df6,0x99a95df3,0x9d684044,0x902b669d,0x94ea7b2a,0xe0b41de7,0xe4750050,0xe9362689,0xedf73b3e,0xf3b06b3b,0xf771768c,0xfa325055,0xfef34de2,0xc6bcf05f,0xc27dede8,0xcf3ecb31,0xcbffd686,0xd5b88683,0xd1799b34,0xdc3abded,0xd8fba05a,0x690ce0ee,0x6dcdfd59,0x608edb80,0x644fc637,0x7a089632,0x7ec98b85,0x738aad5c,0x774bb0eb,0x4f040d56,0x4bc510e1,0x46863638,0x42472b8f,0x5c007b8a,0x58c1663d,0x558240e4,0x51435d53,0x251d3b9e,0x21dc2629,0x2c9f00f0,0x285e1d47,0x36194d42,0x32d850f5,0x3f9b762c,0x3b5a6b9b,0x0315d626,0x07d4cb91,0x0a97ed48,0x0e56f0ff,0x1011a0fa,0x14d0bd4d,0x19939b94,0x1d528623,0xf12f560e,0xf5ee4bb9,0xf8ad6d60,0xfc6c70d7,0xe22b20d2,0xe6ea3d65,0xeba91bbc,0xef68060b,0xd727bbb6,0xd3e6a601,0xdea580d8,0xda649d6f,0xc423cd6a,0xc0e2d0dd,0xcda1f604,0xc960ebb3,0xbd3e8d7e,0xb9ff90c9,0xb4bcb610,0xb07daba7,0xae3afba2,0xaafbe615,0xa7b8c0cc,0xa379dd7b,0x9b3660c6,0x9ff77d71,0x92b45ba8,0x9675461f,0x8832161a,0x8cf30bad,0x81b02d74,0x857130c3,0x5d8a9099,0x594b8d2e,0x5408abf7,0x50c9b640,0x4e8ee645,0x4a4ffbf2,0x470cdd2b,0x43cdc09c,0x7b827d21,0x7f436096,0x7200464f,0x76c15bf8,0x68860bfd,0x6c47164a,0x61043093,0x65c52d24,0x119b4be9,0x155a565e,0x18197087,0x1cd86d30,0x029f3d35,0x065e2082,0x0b1d065b,0x0fdc1bec,0x3793a651,0x3352bbe6,0x3e119d3f,0x3ad08088,0x2497d08d,0x2056cd3a,0x2d15ebe3,0x29d4f654,0xc5a92679,0xc1683bce,0xcc2b1d17,0xc8ea00a0,0xd6ad50a5,0xd26c4d12,0xdf2f6bcb,0xdbee767c,0xe3a1cbc1,0xe760d676,0xea23f0af,0xeee2ed18,0xf0a5bd1d,0xf464a0aa,0xf9278673,0xfde69bc4,0x89b8fd09,0x8d79e0be,0x803ac667,0x84fbdbd0,0x9abc8bd5,0x9e7d9662,0x933eb0bb,0x97ffad0c,0xafb010b1,0xab710d06,0xa6322bdf,0xa2f33668,0xbcb4666d,0xb8757bda,0xb5365d03,0xb1f740b4}local function c(d)d=d..((\"%x\"):format(#d):reverse()..\"0\"):gsub(\"%x%x\",function(e)return string.char(tonumber(e:sub(1,1),16)+tonumber(e:sub(2,2),16)*16)end)local f=0;for g=1,#d do f=bit32.bxor(bit32.lshift(f,8),b[bit32.bxor(bit32.rshift(f,24),d:byte(g))])end;return bit32.bnot(f)end;if#a==0 then a[1]=\"-\"end;local h=0;for i,j in ipairs(a)do local d;if j==\"-\"then d=io.read(\"*a\")else local k,h=io.open(j,\"rb\")if k then d=k:read(\"*a\")k:close()else io.stderr:write(\"Could not open \"..j..\": \"..h..\"\\n\")h=h+1 end end;print((\"%u %d %s\"):format(c(d),#d,j))end;return h\n",created=1704748610404,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=3404},["luz.lua"]={modified=1704748611563,data="local a=require\"luz.lex\"local b=require\"luz.minify\"local c=require\"luz.compress\"local d=require\"luz.decompress\"local function e()print[[Usage: luz [options] <input> [output]\nOptions:\n  -c       Force compression\n  -d       Force decompression\n  -l <num> Compression level (0-9)\n  -m       Minify before compression (experimental)\n  -r       Run compressed file\n  --help   Show this help\n]]end;local f,g,h={}local i,j;local k=false;local l;for m,n in ipairs{...}do if l then if l==1 then j=tonumber(n)end;l=nil elseif n:sub(1,2)==\"--\"then if n==\"--help\"then return e()end elseif n:sub(1,1)==\"-\"then for o in n:sub(2):gmatch(\".\")do if o==\"c\"then i=1 elseif o==\"d\"then i=2 elseif o==\"l\"then l=1 elseif o==\"r\"then i=3 elseif o==\"m\"then k=true end end elseif not g then g=n elseif not h then h=n else f[#f+1]=n end end;if not g then return e()end;if i==3 then table.insert(f,1,h)h=nil end;if shell then g,h=shell.resolve(g),h and shell.resolve(h)end;local p=assert(io.open(g,\"rb\"))local q=p:read(\"*a\")p:close()if not i then i=q:sub(1,5)==\"\\27LuzQ\"and 2 or 1 end;local r=pcall(load,\"\")if i==3 then local s=d(q)return assert((r and load or loadstring)(s,\"@\"..g,\"t\",_ENV))((table.unpack or unpack)(f))elseif i==2 then h=h or g..\".lua\"local s=d(q)p=assert(io.open(h,\"w\"))p:write(s)p:close()else h=h or g..\".luz\"assert((r and load or loadstring)(q))local t=a(q,1,2)if k then t=b(t)end;local u=c(t,j)p=assert(io.open(h,\"wb\"))p:write(u)p:close()print(g..\": \"..#q..\" => \"..#u)end\n",created=1704748611570,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=1467},["comm.lua"]={modified=1704748610362,data="local a=require\"system.util\"local b=assert(a.argparse({[\"1\"]=false,[\"2\"]=false,[\"3\"]=false},...))if#b<2 then error(\"Usage: comm [-123] <file1> <file2>\")end;local c=b[1]==\"-\"and io.input()or assert(io.open(b[1],\"r\"))local d=b[2]==\"-\"and io.input()or assert(io.open(b[2],\"r\"))local e,f=c,d;local g=e:read(\"*l\")while g do local h=f:read(\"*l\")if not h then break end;if g<h then if e==c then if not b[\"1\"]then print(g)end elseif not b[\"2\"]then print((b[\"1\"]and\"\"or\"\\t\")..g)end;e,f=f,e;g=h elseif g==h then if not b[\"3\"]then print((b[\"1\"]and\"\"or\"\\t\")..(b[\"2\"]and\"\"or\"\\t\")..g)end;g=e:read(\"*l\")if not g then e,g=f,h;break end else if f==c then if not b[\"1\"]then print(h)end elseif not b[\"2\"]then print((b[\"1\"]and\"\"or\"\\t\")..h)end end end;while g do if e==c then if not b[\"1\"]then print(g)end elseif not b[\"2\"]then print((b[\"1\"]and\"\"or\"\\t\")..g)end;g=e:read(\"*l\")end;c:close()if c~=d then d:close()end\n",created=1704748610406,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=893},["lsdev.lua"]={modified=1704748610375,data="local a=require\"system.hardware\"local b=require\"system.util\"local c=assert(b.argparse({v=false},...))local function d(e,f)for g,h in ipairs(a.children(e))do local i=a.info(e..\"/\"..h)if c.v then print((\"%sDevice %s (%s): %s\"):format((\" \"):rep(f),h,i.uuid,i.displayName or\"\"))io.write((\" \"):rep(f)..\"Types: \")local j=true;for k,l in pairs(i.types)do io.write((j and\"\"or\", \")..k..\" (\"..l..\")\")j=false end;print()else print((\"%sDevice %s: %s\"):format((\" \"):rep(f),h,i.displayName or\"\"))end;d(e..\"/\"..h,f+2)end end;local i=a.info(\"/\")if c.v then print((\"Device / (%s): %s\"):format(i.uuid,i.displayName or\"\"))io.write(\"Types: \")local j=true;for k,l in pairs(i.types)do io.write((j and\"\"or\", \")..k..\" (\"..l..\")\")j=false end;print()else print((\"Device /: %s\"):format(i.displayName or\"\"))end;d(\"/\",2)\n",created=1704748610417,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=792},["dj.lua"]={modified=1704748610366,data="local a=require\"system.hardware\"local b={...}local c=b[2]and a.wrap(b[2])or a.find(\"drive\")if not c then if b[2]then error(\"Could not find drive named \"..b[2])else error(\"Could not find any attached drives\")end end;if b[1]==\"play\"then local d=c.state;if not d then error(\"No disc in drive\")elseif not d.audio then error(\"Disc in drive is not a record\")end;c.play()print(\"Playing '\"..d.audio..\"'\")elseif b[1]==\"stop\"then c.stop()else error(\"Usage: dj <play|stop> [drive]\")end\n",created=1704748610410,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=475},["rmdir.lua"]={modified=1704748610387,data="local a=require\"system.filesystem\"local b=false;local function c(d)if not a.isDir(d)or#a.list(d)>0 then error(\"rmdir: \"..d..\": directory not empty\")end;a.remove(d)if b and d:find\"/\"then return c(a.dirname(d))end end;for e,f in ipairs{...}do if f==\"-p\"then b=true else c(f)end end\n",created=1704748610425,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=280},["rm.lua"]={modified=1704748610386,data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=assert(b.argparse({f=false,i=false,R=\"@r\",r=false,[\"no-preserve-root\"]=false},...))local d=true;for e,f in ipairs(c)do local g=a.stat(f)if not c[\"no-preserve-root\"]and a.combine(f)==\"/\"then io.stderr:write(\"rm: refusing to remove root directory\")elseif not g then if not c.f then io.stderr:write(\"rm: \"..f..\": No such file or directory\\n\")end;d=false elseif g.type==\"directory\"then if c.r then a.remove(f)else io.stderr:write(\"rm: -r not specified, skipping directory \"..f..\"\\n\")d=false end else a.remove(f)end end;return d\n",created=1704748610425,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=594},["sleep.lua"]={modified=1704748610388,data="require\"system.util\".sleep(tonumber(...))\n",created=1704748610427,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=42},["dirname.lua"]={modified=1704748610365,data="local a=require\"system.filesystem\"print(a.dirname(...))\n",created=1704748610409,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=56},["label.lua"]={modified=1704748610372,data="local a=require\"system.hardware\"local b={...}if b[1]==\"set\"and not b[3]then b[3],b[2]=b[2],nil end;local c;if b[2]then c=assert(a.wrap(b[2]),\"No such device '\"..b[2]..\"'\")else c=a.wrap(\"/\")end;if not c.getLabel then error(\"Device does not support labels\")end;if b[1]==\"get\"then local d=c.label;if d then print((b[2]or\"Computer\")..\" is labeled '\"..d..\"'\")else print(\"No \"..(b[2]or\"computer\")..\" label\")end elseif b[1]==\"set\"then c.label=b[3]print(\"Set \"..(b[2]or\"computer\")..\" label to '\"..b[3]..\"'\")elseif b[1]==\"clear\"then c.label=nil;print(\"Cleared \"..(b[2]or\"computer\")..\" label\")else error(\"Usage: label <get|set|clear> [drive] [label]\")end\n",created=1704748610415,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=645},["nano.lua"]={modified=1704748610381,data="local a=require\"system.filesystem\"local b=require\"system.framebuffer\"local c=require\"system.keys\"local d=require\"system.terminal\"local e=require\"system.util\"local f=\"0.1\"local g=assert(e.argparse({},...))local h={[c.leftBracket]='{',[c.rightBracket]='}',[c.minus]='_',[c.nine]='(',[c.zero]=')',[c.semicolon]=':',[c.up]='\\24',[c.down]='\\25',[c.left]='\\27',[c.right]='\\26'}local i,j;local k=assert(d.openterm())local l=d.termctl()d.termctl{raw=true}local m,n=k.getSize()local o=g[1]local p={}local q=1;local r,s=1,1;local t=b.window(k,1,2,m,n-4)local u=false;local v,w;local x=false;local y,z=\"\",1;local A;local B=true;local C={}local function D(E,F,G)if#E<F then return(G and\"\"or(' '):rep(math.ceil((F-#E)/2)))..E..(' '):rep(math.floor((F-#E)/(G and 1 or 2)))elseif#E==F then return E elseif G then return E:sub(1,F)else return\"...\"..E:sub(-F+3)end end;local function H(I)local J=\"\"if I.key==c.delete and I.shift then J=\"Sh-\"end;if I.ctrl then J=J..\"^\"elseif I.alt then J=J..\"M-\"end;if h[I.key]then J=J..h[I.key]else J=J..c.getCharacter(I.key):upper()end;return J end;local function K()if v then k.setTextColor(d.colors.black)k.setBackgroundColor(d.colors.white)if x then k.setCursorPos(1,n-2)k.clearLine()k.write(v)local F=m-#v-1;if#y>F then if z<F-1 then k.write(y:sub(1,F-1)..\">\")k.setCursorPos(#v+z,n-2)else local L=math.floor((z-F+1)/(F-8)+1)*(F-8)+2;k.write(\"<\"..y:sub(L,L+F-3))if#y>L+m-1 then k.write(\">\")else k.write(y:sub(L+F-3,L+F-2))end;k.setCursorPos(#v+z-L+2,n-2)end else k.write(y)k.setCursorPos(#v+z,n-2)end else k.setCursorPos(math.floor((m-#v)/2)+1,n-2)k.write(v)end;k.setTextColor(d.colors.white)k.setBackgroundColor(d.colors.black)end end;local M;local function N()k.setBackgroundColor(d.colors.black)k.clear()k.setCursorBlink(false)k.setCursorPos(1,1)k.setBackgroundColor(d.colors.white)k.setTextColor(d.colors.black)if m>=#f+#o+26 then k.write(\"  Phoenix nano \"..f..D(o,m-#f-26)..(u and\" Modified  \"or(' '):rep(11)))elseif m>=#o+13 then k.write(\"  \"..D(o,m-13)..(u and\" Modified  \"or(' '):rep(11)))elseif m>=#o+4 and not u then k.write(\"  \"..D(o,m-4)..\"  \")else k.write(D(o,u and m-9 or m)..(u and\" Modified\"or\"\"))end;K()local O,P=k.getCursorPos()k.setCursorPos(1,n-1)local Q=math.floor(m/20)+2;local R=math.floor(m/Q)for S=1,Q do if not i[1][S]then break end;local I=H(i[1][S])local E=D(I..\" \"..i[1][S].description,S==Q and m-R*(S-1)or R,true)k.blit(E,('f'):rep(#I)..('0'):rep(#E-#I),('0'):rep(#I)..('f'):rep(#E-#I))end;k.setCursorPos(1,n)for S=1,Q do if not i[2][S]then break end;local I=H(i[2][S])local E=D(I..\" \"..i[2][S].description,S==Q and m-R*(S-1)or R,true)k.blit(E,('f'):rep(#I)..('0'):rep(#E-#I),('0'):rep(#I)..('f'):rep(#E-#I))end;M()if v and x then k.setCursorPos(O,P)end end;M=function()t.setBackgroundColor(d.colors.black)t.setTextColor(d.colors.white)t.clear()t.setCursorBlink(false)local T,U;for S=1,n-4 do t.setCursorPos(1,S)if p[q+S-1]==nil then break end;if S+q-1==s and#p[q+S-1]>m then if r<m-1 then t.write(p[q+S-1]:sub(1,m-1))t.blit(\">\",\"f\",\"0\")t.setBackgroundColor(d.colors.black)t.setTextColor(d.colors.white)else local L=math.floor((r-m+1)/(m-8)+1)*(m-8)+2;t.blit(\"<\",\"f\",\"0\")t.setBackgroundColor(d.colors.black)t.setTextColor(d.colors.white)t.write(p[q+S-1]:sub(L,L+m-3))if#p[q+S-1]>L+m-1 then t.blit(\">\",\"f\",\"0\")t.setBackgroundColor(d.colors.black)t.setTextColor(d.colors.white)else t.write(p[q+S-1]:sub(L+m-3,L+m-2))end;T,U=r-L+2,s-q+1 end elseif#p[q+S-1]>m then t.write(p[q+S-1]:sub(1,m-1))t.blit(\">\",\"f\",\"0\")t.setBackgroundColor(d.colors.black)t.setTextColor(d.colors.white)else t.write(p[q+S-1])end end;if T==nil then T,U=r,s-q+1 end;t.setCursorPos(T,U)t.setCursorBlink(true)end;local function V(W)v=W;x=false;w=20;N()end;local function X(W,Y,Z)v=W;w=nil;x=true;i=Y or i;y=\"\"z=1;A=Z;N()end;local function _(a0)local a1=1;local a2={\"File Name to Write: \",\"File Name to Write [DOS Format]: \",\"File Name to Write [Mac Format]: \"}X(\"File Name to Write: \",{{{key=c.g,ctrl=true,description=\"Help\"},{key=c.d,alt=true,description=\"DOS Format\",action=function()if a1==2 then a1=1 else a1=2 end;v=a2[a1]K()end},{key=c.a,alt=true,description=\"Append\"},{key=c.b,alt=true,description=\"Backup File\"}},{{key=c.c,ctrl=true,description=\"Cancel\",action=function()i=j;V\"[ Cancelled ]\"end},{key=c.m,alt=true,description=\"Mac Format\",action=function()if a1==3 then a1=1 else a1=3 end;v=a2[a1]K()end},{key=c.p,alt=true,description=\"Prepend\"},{key=c.t,ctrl=true,description=\"Browse\"}}},function(a3)local a4,a5=a.open(a3,\"w\")if not a4 then V(\"[ Could not write file: \"..a5 ..\" ]\")return end;local a6=({\"\\n\",\"\\r\\n\",\"\\r\"})[a1]for a7,a8 in ipairs(p)do a4.write(a8 ..a6)end;a4.close()u=false;if a0 then B=false else V(\"[ Wrote \"..#p..\" lines ]\")end end)if g[1]then y=o;z=#o+1;K()end end;j={{{key=c.g,ctrl=true,description=\"Get Help\"},{key=c.o,ctrl=true,description=\"Write Out\",action=_},{key=c.w,ctrl=true,description=\"Where Is\"},{key=c.k,ctrl=true,description=\"Cut Text\",action=function()if s==#p then V(\"[ Nothing was cut ]\")else C[#C+1]=table.remove(p,s)r=math.min(r,#p[s]+1)if not u then u=true;N()else M()end end end},{key=c.j,ctrl=true,description=\"Justify\"},{key=c.c,ctrl=true,description=\"Cur Pos\",action=function()local a9=0;for U=1,s-1 do a9=a9+#p[U]end;local aa=a9;for U=s,#p do aa=aa+#p[U]end;V((\"[ line %d/%d, col %d/%d, char %d/%d ]\"):format(s,#p,r,#p[s],a9+r-1,aa))end},{key=c.u,alt=true,description=\"Undo\"},{key=c.a,alt=true,description=\"Mark Text\"},{key=c.rightBracket,alt=true,description=\"To Bracket\"},{key=c.q,alt=true,description=\"Previous\"},{key=c.b,ctrl=true,description=\"Back\"},{key=c.left,ctrl=true,description=\"Prev Word\"},{key=c.a,ctrl=true,description=\"Home\"},{key=c.p,ctrl=true,description=\"Prev Line\"},{key=c.up,alt=true,description=\"Scroll Up\"},{key=c.up,ctrl=true,description=\"Prev Block\"},{key=c.nine,shift=true,alt=true,description=\"Beg of Par\"},{key=c.y,ctrl=true,description=\"Prev Page\"},{key=c.backslash,alt=true,description=\"First Line\"},{key=c.left,alt=true,description=\"Prev File\"},{key=c.i,ctrl=true,description=\"Tab\"},{key=c.h,ctrl=true,description=\"Backspace\"},{key=c.delete,shift=true,ctrl=true,description=\"Chop Left\"},{key=c.t,alt=true,description=\"CutTillEnd\"},{key=c.d,alt=true,description=\"Word Count\"},{key=c.l,ctrl=true,description=\"Refresh\"},{key=c.rightBracket,shift=true,alt=true,description=\"Indent\"},{key=c.three,alt=true,description=\"Comment Lines\"},{key=c.semicolon,shift=true,alt=true,description=\"Record\"},{key=c.delete,alt=true,description=\"Zap Text\"},{key=c.f,alt=true,description=\"Formatter\"}},{{key=c.x,ctrl=true,description=\"Exit\"},{key=c.r,ctrl=true,description=\"Read File\"},{key=c.backslash,ctrl=true,description=\"Replace\"},{key=c.u,ctrl=true,description=\"Paste Text\",action=function()if#C==0 then V(\"[ Nothing was pasted ]\")else for S=#C,1,-1 do table.insert(p,s,C[S])end;C={}if not u then u=true;N()else M()end end end},{key=c.t,ctrl=true,description=\"To Spell\"},{key=c.minus,shift=true,ctrl=true,description=\"Go To Line\",action=function()X(\"Enter line number, column number: \",{{{key=c.g,ctrl=true,description=\"Help\"},{key=c.w,ctrl=true,description=\"Begin of Paragr.\"},{key=c.y,ctrl=true,description=\"First Line\"},{key=c.t,ctrl=true,description=\"Go To Text\"}},{{key=c.c,ctrl=true,description=\"Cancel\",action=function()i=j;V\"[ Cancelled ]\"end},{key=c.o,ctrl=true,description=\"End of Paragraph\"},{key=c.v,ctrl=true,description=\"Last Line\"}}},function(W)local ab=tonumber(W)if ab and ab<=#p then s=ab;if s<q then q=s elseif s-n+5>q then q=s-n+5 end else V\"[ Invalid line or column number ]\"end end)end},{key=c.e,alt=true,description=\"Redo\"},{key=c.six,alt=true,description=\"Copy Text\"},{key=c.q,ctrl=true,description=\"Where Was\"},{key=c.w,alt=true,description=\"Next\"},{key=c.f,ctrl=true,description=\"Forward\"},{key=c.right,ctrl=true,description=\"Next Word\"},{key=c.e,ctrl=true,description=\"End\"},{key=c.n,ctrl=true,description=\"Next Line\"},{key=c.down,alt=true,description=\"Scroll Down\"},{key=c.down,ctrl=true,description=\"Next Block\"},{key=c.zero,shift=true,alt=true,description=\"End of Par\"},{key=c.v,ctrl=true,description=\"Next Page\"},{key=c.slash,alt=true,description=\"Last Line\"},{key=c.right,alt=true,description=\"Next File\"},{key=c.m,ctrl=true,description=\"Enter\"},{key=c.d,ctrl=true,description=\"Delete\"},{key=c.delete,ctrl=true,description=\"Chop Right\"},{key=c.j,alt=true,description=\"FullJstify\"},{key=c.v,alt=true,description=\"Verbatim\"},{key=c.z,ctrl=true,description=\"Suspend\"},{key=c.leftBracket,shift=true,alt=true,description=\"Unindent\"},{key=c.rightBracket,ctrl=true,description=\"Complete\"},{key=c.semicolon,alt=true,description=\"Run Macro\"},{key=c.b,alt=true,description=\"To Linter\"},{key=c.s,ctrl=true,description=\"Save\"}}}i=j;if o then if a.stat(o)then for ac in io.lines(o)do table.insert(p,ac)end;V(\"[ Read \"..#p..\" lines ]\")else V\"[ New File ]\"end else o=\"New Buffer\"V\"[ Welcome to nano. For basic help, type Ctrl+G. ]\"end;N()while B do local ad,ae=coroutine.yield()if v and x then if ad==\"key\"then if ae.keycode==c.left and z>1 then z=z-1;K()elseif ae.keycode==c.right and z<=#y then z=z+1;K()elseif ae.keycode==c.backspace and z>1 then y=y:sub(1,z-2)..y:sub(z)z=z-1;K()elseif ae.keycode==c.delete then y=y:sub(1,z-1)..y:sub(z+1)K()elseif ae.keycode==c.enter then v,x=nil;i=j;A(y)N()else local af;for a7,a8 in ipairs(i[1])do if ae.keycode==a8.key and ae.ctrlHeld==(a8.ctrl or false)and ae.altHeld==(a8.alt or false)and ae.shiftHeld==(a8.shift or false)then if a8.action then a8.action()end;af=true;break end end;if not af then for a7,a8 in ipairs(i[2])do if ae.keycode==a8.key and ae.ctrlHeld==(a8.ctrl or false)and ae.altHeld==(a8.alt or false)and ae.shiftHeld==(a8.shift or false)then if a8.action then a8.action()end;af=true;break end end end end elseif ad==\"char\"then y=y:sub(1,z-1)..ae.character..y:sub(z)z=z+1;K()end else if ad==\"key\"then if ae.keycode==c.up and s>1 then s=s-1;if s<q then q=s end;if not p[s]then r=1 elseif r>#p[s]+1 then r=#p[s]+1 end;M()elseif ae.keycode==c.down and s<=#p then s=s+1;if s-n+5>q then q=s-n+5 end;if not p[s]then r=1 elseif r>#p[s]+1 then r=#p[s]+1 end;M()elseif ae.keycode==c.right and p[s]then if#p[s]<r then s=s+1;r=1 else r=r+1 end;M()elseif ae.keycode==c.left and(r>1 or s>1)then if r==1 then s=s-1;r=#p[s]+1 else r=r-1 end;M()elseif ae.keycode==c.backspace then if r==1 then if s~=1 then r=#p[s-1]+1;p[s-1]=p[s-1]..(table.remove(p,s)or\"\")s=s-1;if s<q then q=s end end else p[s]=p[s]:sub(1,r-2)..p[s]:sub(r)r=r-1 end;if not u then u=true;N()else M()end elseif ae.keycode==c.delete and p[s]then if r==#p[s]+1 then p[s]=p[s]..(table.remove(p,s+1)or\"\")else p[s]=p[s]:sub(1,r-1)..p[s]:sub(r+1)end;if not u then u=true;N()else M()end elseif ae.keycode==c.enter then local ag=(p[s]or\"\"):sub(r)p[s]=(p[s]or\"\"):sub(1,r-1)table.insert(p,s+1,ag)r=1;s=s+1;if s-n+5>q then q=s-n+5 end;if not u then u=true;N()else M()end elseif ae.keycode==c.x and ae.ctrlHeld then local ah=true;if u then k.setCursorPos(1,n-2)k.setBackgroundColor(d.colors.white)k.setTextColor(d.colors.black)k.clearLine()k.write(\"Save modified buffer?\")k.setBackgroundColor(d.colors.black)k.setTextColor(d.colors.white)k.setCursorPos(1,n-1)k.clearLine()k.blit(\" Y Yes\",\"ff0000\",\"00ffff\")k.setCursorPos(1,n)k.clearLine()k.blit(\" N No       ^C Cancel\",\"ff0000000000ff0000000\",\"00ffffffffff00fffffff\")k.setCursorBlink(false)while true do ad,ae=coroutine.yield()if ad==\"key\"and ae.keycode==c.c and ae.ctrlHeld then ah=false;break elseif ad==\"char\"then if ae.character==\"y\"then _(true)ah=false;break elseif ae.character==\"n\"then break end end end end;if ah then break end;if not x then V\"[ Cancelled ]\"end else local af;for a7,a8 in ipairs(i[1])do if ae.keycode==a8.key and ae.ctrlHeld==(a8.ctrl or false)and ae.altHeld==(a8.alt or false)and ae.shiftHeld==(a8.shift or false)then if a8.action then a8.action()end;af=true;break end end;if not af then for a7,a8 in ipairs(i[2])do if ae.keycode==a8.key and ae.ctrlHeld==(a8.ctrl or false)and ae.altHeld==(a8.alt or false)and ae.shiftHeld==(a8.shift or false)then if a8.action then a8.action()end;af=true;break end end end end elseif ad==\"char\"then if p[s]then p[s]=p[s]:sub(1,r-1)..ae.character..p[s]:sub(r)else p[s]=ae.character end;r=r+1;if not u then u=true;N()else M()end end end;if w then w=w-1;if w==0 then v,w=nil;N()end end end;k.setBackgroundColor(d.colors.black)k.setTextColor(d.colors.white)k.clear()k.setCursorPos(1,1)k.close()d.termctl(l)\n",created=1704748610421,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=12311},["cat.lua"]={modified=1704748610358,data="local a={...}if a[1]==\"-u\"then table.remove(a,1)end;if#a==0 then a[1]=\"-\"end;for b,c in ipairs(a)do if c==\"-\"then io.stdout:write(io.stdin:read(\"*a\"))else local d,e=io.open(c,\"rb\")if not d then error(\"cat: \"..c..\": \"..e)end;io.stdout:write(d:read(\"*a\"))d:close()end end\n",created=1704748610401,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=270},["screenfetch.lua"]={modified=1704748610387,data="local a=require\"system.filesystem\"local b=require\"system.hardware\"local c=require\"system.process\"local d=require\"system.terminal\"local e=require\"system.util\"local f={\"\\x1b[30;40m                \\x1b[0m\",\"\\x1b[30;40m  \\x1b[33;106m\\x88\\x1b[96;43m\\x8F\\x1b[96;40m\\x90 \\x1b[30;106m\\x9F\\x1b[96;40m\\x90   \\x1b[30;106m\\x9F\\x1b[96;43m\\x8F\\x1b[33;106m\\x84\\x1b[30;40m  \\x1b[0m\",\"\\x1b[96;40m \\x9A\\x1b[33;106m\\x89\\x84\\x1b[33;41m\\x82\\x1b[33;40m\\x94\\x1b[30;106m\\x95 \\x1b[96;40m\\x90 \\x1b[30;43m\\x97\\x1b[33;41m\\x81\\x1b[33;106m\\x88\\x86\\x1b[30;106m\\x9A\\x1b[30;40m \\x1b[0m\",\"\\x1b[30;106m\\x9F\\x1b[96;43m\\x9B\\x8C\\x1b[96;41m\\x95 \\x1b[33;40m\\x95\\x1b[30;106m\\x95 \\x96\\x1b[30;40m \\x1b[30;43m\\x95\\x1b[96;41m \\x1b[31;106m\\x95\\x1b[96;43m\\x8C\\x1b[33;106m\\x98\\x1b[96;40m\\x90\\x1b[0m\",\"\\x1b[30;106m\\x95\\x1b[33;106m\\x8C\\x84\\x1b[96;41m\\x95 \\x1b[30;43m\\x8A\\x1b[30;106m\\x95\\x1b[96;100m\\x8F\\x8F\\x1b[96;40m\\x95\\x1b[30;43m\\x85\\x1b[96;41m \\x1b[31;106m\\x95\\x1b[33;106m\\x88\\x8C\\x1b[96;40m\\x95\\x1b[0m\",\"\\x1b[96;40m\\x8A\\x1b[96;43m\\x9C\\x8E\\x1b[31;106m\\x82\\x1b[33;41m \\x82\\x1b[90;106m\\x95\\x1b[33;106m\\x90\\x1b[96;43m\\x9F\\x1b[96;100m\\x95\\x1b[33;41m\\x81 \\x1b[31;106m\\x81\\x1b[96;43m\\x8D\\x1b[33;106m\\x93\\x1b[96;40m\\x85\\x1b[0m\",\"\\x1b[30;40m \\x1b[96;43m\\x9E\\x1b[33;106m\\x8C\\x1b[96;43m\\x9B\\x1b[31;106m\\x82\\x1b[96;41m\\x90\\x1b[90;106m\\x95\\x1b[33;106m\\x85\\x8A\\x1b[96;100m\\x95\\x1b[31;106m\\x9F\\x81\\x1b[33;106m\\x98\\x8C\\x92\\x1b[30;40m \\x1b[0m\",\"\\x1b[96;40m \\x82\\x1b[33;106m\\x86\\x99\\x99\\x1b[96;100m\\x95\\x1b[33;106m\\x8A\\x88\\x81\\x85\\x1b[90;106m\\x95\\x1b[96;43m\\x99\\x99\\x1b[33;106m\\x89\\x1b[106;40m\\x81 \\x1b[0m\",\"\\x1b[33;40m  \\x82\\x8B\\x1b[90;106m \\x96 \\x1b[33;106m\\x95\\x1b[96;43m\\x95\\x1b[96;106m \\x1b[96;100m\\x96\\x1b[96;106m \\x1b[33;40m\\x87\\x81  \\x1b[0m\",\"\\x1b[96;40m     \\x83\\x8B\\x8F\\x8F\\x87\\x83     \\x1b[0m\",\"\\x1b[30;40m                \\x1b[0m\"}local function g(h)local i=math.floor(h/3600)local j=math.floor(h/60)%60;local k=h%60;local l=k..\"s\"if j>0 or i>0 then l=j..\"m \"..l end;if i>0 then l=i..\"h \"..l end;return l end;local function m(h)if h>=1073741824 then return(\"%.3g GiB\"):format(h/1073741824)elseif h>=1048576 then return(\"%.3g MiB\"):format(h/1048576)elseif h>=1024 then return(\"%.3g kiB\"):format(h/1024)else return(\"%.3g B\"):format(h)end end;local n={\"\\x1b[96m\"..c.getuser()..\"\\x1b[0m@\\x1b[96m\"..(b.call(\"/\",\"getLabel\")or\"Computer \"..b.info(\"/\").id)}n[#n+1]=(\"-\"):rep(#n[1]-14)local function o(p,q)n[#n+1]=\"\\x1b[96m\"..p..\"\\x1b[0m: \"..q end;o(\"OS\",\"Phoenix \"..e.syscall.version())o(\"Uptime\",g(e.syscall.uptime()))o(\"Runtime\",e.syscall.cchost():match(\"%b()\"):sub(2,-2))o(\"Lua\",_VERSION)o(\"CC Version\",e.syscall.cchost():match(\"ComputerCraft [%d%.]+\"))o(\"Resolution\",table.concat({d.termsize()},\"x\"))local r=a.stat(\"/\")o(\"Disk Space\",m(r.freeSpace)..\" / \"..m(r.capacity))if collectgarbage then o(\"Memory\",m(collectgarbage(\"count\")*1024))end;n[#n+1]=\"\"n[#n+1]=\"\\x1b[40m   \\x1b[41m   \\x1b[42m   \\x1b[43m   \\x1b[44m   \\x1b[45m   \\x1b[46m   \\x1b[47m   \\x1b[0m\"n[#n+1]=\"\\x1b[100m   \\x1b[101m   \\x1b[102m   \\x1b[103m   \\x1b[104m   \\x1b[105m   \\x1b[106m   \\x1b[107m   \\x1b[0m\"n[#n+1]=\"\"local s=d.termsize()-18;for t=1,math.max(#f,#n)do local k=n[t]or\"\"local u,v=0,false;for w,x in k:gmatch\"(.)()\"do if v then if w=='m'then v=false end elseif w=='\\x1b'then v=true else u=u+1;if u==s then k=k:sub(1,x)v=true;break end end end;if v then io.write((f[t]or\"                \")..\"  \"..k)else print((f[t]or\"                \")..\"  \"..k)end end\n",created=1704748610426,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=3370},["attach.lua"]={modified=1704748610355,data="local a={...}if type(a[1])~=\"string\"or type(a[2])~=\"string\"then print(\"Usage: attach <side> <type> [options...]\")else if tonumber(a[3])~=nil then a[3]=tonumber(a[3])end;local b,c,d=coroutine.yield(\"syscall\",\"attach\",a[1],a[2],a[3])if not b then io.stderr:write(\"Could not attach peripheral\"..(c and\": \"..c or\"\")..\"\\n\")elseif not c then io.stderr:write(\"Could not attach peripheral\"..(d and\": \"..d or\"\")..\"\\n\")end end\n",created=1704748610399,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=417},["chroot.lua"]={modified=1704748610360,data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=require\"system.util\"local d=assert(c.argparse({userspec=true,[\"skip-chdir\"]=false},...))if b.getuser()~=\"root\"then error(\"This program requires root.\")end;local e=table.remove(d,1)if not e then error(\"Usage: chroot [options] <path> [program] [args...]\")end;if#d==0 then d[1],d[2]=b.getenv().SHELL or\"/bin/sh\",\"-i\"end;a.chroot(e)if not d[\"skip-chdir\"]then b.chdir(\"/\")end;if d.userspec then b.setuser(d.userspec)end;return b.execp(table.unpack(d))\n",created=1704748610403,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=520},["unlink.lua"]={modified=1704748610392,data="return coroutine.yield(\"syscall\",\"remove\",...)\n",created=1704748610431,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=47},["cmp.lua"]={modified=1704748610362,data="local a=require\"system.util\"local b=assert(a.argparse({l=false,s=false},...))if#b<2 then error(\"usage: cmp [-ls] <file1> <file2>\")end;local c,d;if b[1]==\"-\"then c=io.stdin else c=io.open(b[1],\"rb\")end;if b[2]==\"-\"then d=io.stdin else d=io.open(b[2],\"rb\")end;local function e(f)if c~=io.stdin then c:close()end;if d~=io.stdin then d:close()end;return f end;if c==d then return e(0)end;local g,h=1,0;for i=1,math.huge do local j=c:read(1)local k=d:read(1)if j~=k then h=1;if not j then if not b.s then io.stderr:write(\"cmp: EOF on \"..b[1]..\"\\n\")end elseif not k then if not b.s then io.stderr:write(\"cmp: EOF on \"..b[2]..\"\\n\")end elseif not b.s then if b.l then io.write(i..\" \"..j..\" \"..k..\"\\n\")else io.write((\"%s %s differ: char %d, line %d\\n\"):format(b[1],b[2],i,g))end end;if not b.l then return e(1)end end;if j==\"\\n\"then g=g+1 end;if not j or not k then break end end;return e(h)\n",created=1704748610405,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=883},["mv.lua"]={modified=1704748610380,data="local a=require\"system.filesystem\"local b=require\"system.util\"local c=assert(b.argparse({i=false,f=false},...))if#c<2 then error(\"mv: missing operand\")end;local d=table.remove(c)local e=a.stat(d)if#c==1 and(not e or e.type~=\"directory\")then if e and not c.f and(not a.effectivePermissions(e).write and b.syscall.istty()or c.i)then io.stderr:write(\"mv: overwrite \"..e.type..\" \"..d..\"? \")local f=io.read()if f:lower()~=\"y\"then return false end end;a.move(c[1],d)return end;if not e or e.type~=\"directory\"then error(\"mv: \"..d..\": not a directory\")end;for g,h in ipairs(c)do local i=a.combine(d,a.basename(h))e=a.stat(i)if e and not c.f and(not a.effectivePermissions(e).write and b.syscall.istty()or c.i)then io.stderr:write(\"mv: overwrite \"..e.type..\" \"..i..\"? \")local f=io.read()if f:lower()~=\"y\"then return false end end;a.move(h,i)end\n",created=1704748610420,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=836},["nm.lua"]={modified=1704748610382,data="local a=require\"system.filesystem\"local b=require\"system.process\"local c=require\"system.util\"local d=assert(c.argparse({A=false,e=false,f=false,g=false,o=false,P=false,t=true,u=false,v=false,x=false},...))if d.t then assert(d.t:match\"^[dox]$\",\"nm: invalid option '\"..d.t..\"' for argument -t\")end;if#d==0 then error(\"nm: missing file operand\")end;if d.o then d.t=\"o\"end;d.t=d.t or(d.P and\"d\"or\"x\")local e={d=\"%s%s %s %d %d\",o=\"%s%s %s %o %o\",x=\"%s%s %s %x %x\"}for f,g in ipairs(d)do local h={}local require=require;local j={}local k=setmetatable({require=function(l)local m=require(l)local n={name=l,lib=m,used={}}h[#h+1]=n;return setmetatable({},{__index=function(f,o)n.used[o]=true;return m[o]end,__newindex=function(f,o,p)n.used[o]=true;m[o]=p end})end,__scrapelocals=function()if not d.g and not d.e then for i=1,math.huge do local q,r=debug.getlocal(2,i)if not q then break end;local s=type(r)if s==\"function\"then j[#j+1]={lib=g,type=\"t\",name=q,value=tonumber(tostring(r):match(\": (%x+)\"),16),size=#string.dump(r)}elseif s==\"string\"then j[#j+1]={lib=g,type=\"d\",name=q,value=i,size=#r}elseif s==\"number\"then j[#j+1]={lib=g,type=\"d\",name=q,value=i,size=8}elseif s==\"boolean\"then j[#j+1]={lib=g,type=\"d\",name=q,value=i,size=1}elseif s==\"nil\"then j[#j+1]={lib=g,type=\"d\",name=q,value=i,size=0}else j[#j+1]={lib=g,type=\"d\",name=q,value=tonumber(tostring(r):match(\": (%x+)\"),16),size=#r or 8}end end end end},{__index=_G})local t,u=a.open(g,\"r\")if t then local v=t.readAll()t.close()local w;repeat local x=v:find(\"%f[A-Za-z0-9_]return%f[^A-Za-z0-9_]\",w and w+1)if x then w=x end until not x;if w and v:find(\"%f[A-Za-z0-9_]end%f[^A-Za-z0-9_]\",w)then w=nil end;if w then v=v:sub(1,w-1)..\" __scrapelocals() \"..v:sub(w)else v=v..\" __scrapelocals()\"end;local y,u=load(v,\"@\"..g,nil,k)if y then local z=b.getcwd()b.chdir(a.dirname(g))local A,B=pcall(y,a.basename(g):gsub(\"%.lua$\",\"\"),g)b.chdir(z)if A then local C=type(B)if not d.u then if C==\"function\"then j[#j+1]={lib=g,type=\"T\",name=\"\",value=tonumber(tostring(B):match(\": (%x+)\"),16),size=#string.dump(B)}elseif C==\"table\"then local i=1;for q,r in pairs(B)do local s=type(r)if s==\"function\"then j[#j+1]={lib=g,type=\"T\",name=q,value=tonumber(tostring(r):match(\": (%x+)\"),16),size=#string.dump(r)}elseif s==\"string\"then j[#j+1]={lib=g,type=\"D\",name=q,value=i,size=#r}elseif s==\"number\"then j[#j+1]={lib=g,type=\"D\",name=q,value=i,size=8}elseif s==\"boolean\"then j[#j+1]={lib=g,type=\"D\",name=q,value=i,size=1}elseif s==\"nil\"then j[#j+1]={lib=g,type=\"D\",name=q,value=i,size=0}else j[#j+1]={lib=g,type=\"D\",name=q,value=tonumber(tostring(r):match(\": (%x+)\"),16),size=#r or 8}end;i=i+1 end end end else io.stderr:write(\"nm: could not require \"..g..\": \"..B..\"\\n\")end;if not d.u then for q,r in pairs(k)do if q~=\"require\"and q~=\"__scrapelocals\"and q~=\"_ENV\"and q~=\"_G\"then local s=type(r)if s==\"function\"then j[#j+1]={lib=g,type=\"A\",name=q,value=tonumber(tostring(r):match(\": (%x+)\"),16),size=#string.dump(r)}elseif s==\"string\"then j[#j+1]={lib=g,type=\"A\",name=q,value=i,size=#r}elseif s==\"number\"then j[#j+1]={lib=g,type=\"A\",name=q,value=i,size=8}elseif s==\"boolean\"then j[#j+1]={lib=g,type=\"A\",name=q,value=i,size=1}elseif s==\"nil\"then j[#j+1]={lib=g,type=\"A\",name=q,value=i,size=0}else j[#j+1]={lib=g,type=\"A\",name=q,value=tonumber(tostring(r):match(\": (%x+)\"),16),size=#r or 8}end end end end;if not d.g and not d.e then for f,m in ipairs(h)do for q in pairs(m.used)do j[#j+1]={lib=m.name,type=\"U\",name=q}end end end;if d.v then table.sort(j,function(D,E)return(D.value or-1)<(E.value or-1)end)else table.sort(j,function(D,E)return D.name<E.name end)end;if#d>1 then print(g..\":\")end;for f,F in ipairs(j)do if d.P then print(e[d.t]:format(d.A and F.lib..\": \"or\"\",F.name,F.type,F.value or 0,F.size or 0))else if d.A then io.write(F.name..\":\")end;if F.value then io.write((\"%016x \"):format(F.value))else io.write(\"         \")end;print(F.type..\" \"..F.name)end end else io.stderr:write(\"nm: could not load \"..g..\": \"..u..\"\\n\")end else io.stderr:write(\"nm: could not load \"..g..\": \"..u..\"\\n\")end end\n",created=1704748610421,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=4032},["touch.lua"]={modified=1704748610389,data="for a,b in ipairs{...}do if b:sub(1,1)~=\"-\"then assert(io.open(b,\"a\")):close()end end\n",created=1704748610428,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=86},["expand.lua"]={modified=1704748610369,data="local a=require\"system.util\"local b=assert(a.argparse({t=true},...))b.t=b.t or\"8\"if#b==0 then b[1]=\"-\"end;local c={}if b.t:match(\"^%d+$\")then local d=tonumber(b.t)setmetatable(c,{__index=function(e,f)return math.ceil((f+1)/d)*d-f end})elseif b.t:match(\"^[%d, ]+$\")then local g=1;for h in b.t:gmatch\"%d+\"do local d=tonumber(h)assert(d>g,\"expand: invalid tab stop format\")for i=g,d-1 do c[i]=d-i end;g=d end;setmetatable(c,{__index=function(e,f)return 1 end})else error(\"expand: invalid tab stop format\")end;for e,j in ipairs(b)do for k in io.lines(j~=\"-\"and j or nil)do print(k:gsub(\"()\\t\",function(f)return(\" \"):rep(c[f])end))end end\n",created=1704748610412,owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="file",permissions={root={execute=true,write=true,read=true}},size=634}},owner="root",worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0}},owner="root",setuser=false,worldPermissions={execute=true,write=false,read=true},type="directory",permissions={root={execute=true,write=true,read=true}},size=0}