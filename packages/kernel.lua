PHOENIX_VERSION="0.0.8"PHOENIX_BUILD="PRERELEASE NONFREE Sun Mar  2 01:26:48 2025"systemStartTime=os.epoch"utc"args={init="/sbin/init.lua",root="/root",rootfstype="craftos",preemptive=true,quantum=20000,splitkernpath="/boot/kernel.lua.d",loglevel=1,console="tty1",traceback=true}syscalls={}processes={[0]={name="kernel",id=0,user="root",dir="/",root="/",env=_G,vars={},dependents={}}}KERNEL=processes[0]modules={}eventHooks={}shutdownHooks={}debugHooks=setmetatable({},{__mode="k"})kSyscallYield={}kSyscallComplete={}process={}filesystem={}terminal={}syslog={}hardware={}if discord then discord("Phoenix","Booting Phoenix "..PHOENIX_VERSION)end;do local a=fs.open("/rom/modules/main/cc/expect.lua","r")expect=(loadstring or load)(a.readAll(),"@/rom/modules/main/cc/expect.lua")()a.close()setmetatable(expect,{__call=function(self,...)return self.expect(...)end})if not expect.range then function expect.range(b,c,d)expect(1,b,"number")expect(2,c,"number","nil")expect(3,d,"number","nil")if d and c and d<c then error("bad argument #3 (min must be less than or equal to max)",2)end;if b~=b or b<(c or-math.huge)or b>(d or math.huge)then error(("number outside of range (expected %s to be within %s and %s)"):format(b,c or-math.huge,d or math.huge),3)end;return b end end end;do local a=fs.open("/rom/apis/textutils.lua","r")local e=setmetatable({dofile=function(g)if g=="rom/modules/main/cc/expect.lua"then return expect elseif g=="rom/modules/main/cc/require.lua"then return{make=function()return function(h)if h=="cc.expect"then return expect else return{}end end end}elseif g=="rom/modules/main/cc/internal/tiny_require.lua"then return function(h)if h=="cc.expect"then return expect else return{}end end else return{}end end},{__index=_G})local i;if loadstring and setfenv then i=loadstring(a.readAll(),"@/rom/apis/textutils.lua")setfenv(i,e)else i=load(a.readAll(),"@/rom/apis/textutils.lua","t",e)end;a.close()i()serialize,unserialize=e.serialize,e.unserialize end;do local a=fs.open("/rom/apis/keys.lua","r")local e=setmetatable({dofile=function()return expect end},{__index=_G})if _VERSION<"Lua 5.2"then e._ENV=e end;local i;if loadstring and setfenv then i=loadstring(a.readAll(),"@/rom/apis/keys.lua")setfenv(i,e)else i=load(a.readAll(),"@/rom/apis/keys.lua","t",e)end;a.close()i()keys={}for j,k in pairs(e)do keys[j]=k end end;if not pcall(load,"return","=test","t",{})then local l,m,expect,setfenv=load,loadstring,expect,setfenv;function load(n,o,p,e)expect(1,n,"string","function")expect(2,o,"string","nil")expect(3,p,"string","nil")expect(4,e,"table","nil")if type(n)=="string"then if n:sub(1,4)=="\27Lua"then if p==nil or p:find"b"then local i,q=m(n,o)if i and e then setfenv(i,e)end;return i,q else return nil,"attempt to load a binary chunk (mode is '"..(p or"bt").."')"end else if p==nil or p:find"t"then local i,q=m(n,o)if i and e then setfenv(i,e)end;return i,q else return nil,"attempt to load a text chunk (mode is '"..(p or"bt").."')"end end else local i,q=l(n,o)if i then setfenv(i,e)end;return i,q end end end;loadstring=nil;if bit then if not bit32 then local bit=bit;bit32={bnot=bit.bnot,lshift=bit.blshift,rshift=bit.blogic_rshift,arshift=bit.brshift}function bit32.band(r,s,...)expect(1,r,"number")expect(2,s,"number","nil")if not s then return r end;return bit32.band(bit.band(r,s),...)end;function bit32.bor(r,s,...)expect(1,r,"number")expect(2,s,"number","nil")if not s then return r end;return bit32.bor(bit.bor(r,s),...)end;function bit32.bxor(r,s,...)expect(1,r,"number")expect(2,s,"number","nil")if not s then return r end;return bit32.bxor(bit.bxor(r,s),...)end;function bit32.btest(...)return bit32.band(...)~=0 end;function bit32.extract(t,u,v)expect(1,t,"number")expect(2,u,"number")expect(3,v,"number","nil")(expect.range or function()end)(u,0,31)(expect.range or function()end)(u+v-1,0,31)v=v or 1;local w=0;for x=u+v-1,u,-1 do w=w*2+bit.band(t,2^x)/2^x end;return w end;function bit32.replace(t,k,u,v)expect(1,t,"number")expect(2,k,"number")expect(3,u,"number")expect(4,v,"number","nil")(expect.range or function()end)(u,0,31)(expect.range or function()end)(u+v-1,0,31)v=v or 1;local y=2^v-1;return bit.bor(bit.band(t,bit.bnot(bit.blshift(y,u))),bit.blshift(bit.band(k,y),u))end;function bit32.lrotate(r,z)return bit.bor(bit.blshift(r,z),bit.blogic_rshift(r,32-z))end;function bit32.rrotate(r,z)return bit.bor(bit.blogic_rshift(r,z),bit.blshift(r,32-z))end end;bit=nil end;if _VERSION=="Lua 5.1"and load("::a:: goto a")then _VERSION="Lua 5.2"if load("return 1 >> 2 & 3")then _VERSION="Lua 5.3"if load("local <const> a = 2")then _VERSION="Lua 5.4"end end end;if _VERSION=="Lua 5.1"then if not table.pack then table.pack=function(...)local A={...}A.n=select("#",...)return A end end;if not table.unpack then table.unpack,unpack=unpack,nil end;local B,k=xpcall(function(C)return C end,function()end,true)if not k then local D=xpcall;xpcall=function(f,E,...)if select("#",...)>0 then local args=table.pack(...)return D(function()return f(table.unpack(args,1,args.n))end,E)else return D(f,E)end end end end;if tonumber(_HOST:match"ComputerCraft 1.(%d+)")<95 then local F=fs.combine;function fs.combine(G,...)if...~=nil then return F(G,fs.combine(...))else return G end end end;if not string.pack then local expect=expect.expect;local H={BIG_ENDIAN=1,LITTLE_ENDIAN=2}local I={b=1,B=1,h=1,H=1,l=1,L=1,j=1,J=1,T=1}local J={b=1,B=1,x=1,h=2,H=2,f=4,j=4,J=4,l=8,L=8,T=8,d=8,n=8}local function K(t)if t%1>=0.5 then return math.ceil(t)else return math.floor(t)end end;local function L(f)if f==0 then return 0 elseif f==-0 then return 0x80000000 elseif f==math.huge then return 0x7F800000 elseif f==-math.huge then return 0xFF800000 end;local C,M=math.frexp(f)if M>127 or M<-126 then error("number out of range",3)end;M,C=M+126,K((math.abs(C)-0.5)*0x1000000)if C>0x7FFFFF then M=M+1 end;return bit32.bor(f<0 and 0x80000000 or 0,bit32.lshift(bit32.band(M,0xFF),23),bit32.band(C,0x7FFFFF))end;local function N(f)if f==0 then return 0,0 elseif f==-0 then return 0x80000000,0 elseif f==math.huge then return 0x7FF00000,0 elseif f==-math.huge then return 0xFFF00000,0 end;local C,M=math.frexp(f)if M>1023 or M<-1022 then error("number out of range",3)end;M,C=M+1022,K((math.abs(C)-0.5)*0x20000000000000)if C>0xFFFFFFFFFFFFF then M=M+1 end;return bit32.bor(f<0 and 0x80000000 or 0,bit32.lshift(bit32.band(M,0x7FF),20),bit32.band(C/0x100000000,0xFFFFF)),bit32.band(C,0xFFFFFFFF)end;local function O(P)if P==0 then return 0 elseif P==0x80000000 then return-0 elseif P==0x7F800000 then return math.huge elseif P==0xFF800000 then return-math.huge end;local C,M=bit32.band(P,0x7FFFFF),bit32.band(bit32.rshift(P,23),0xFF)M,C=M-126,C/0x1000000+0.5;local t=math.ldexp(C,M)return bit32.btest(P,0x80000000)and-t or t end;local function Q(R,S)if R==0 and S==0 then return 0 elseif R==0x80000000 and S==0 then return-0 elseif R==0x7FF00000 and S==0 then return math.huge elseif R==0xFFF00000 and S==0 then return-math.huge end;local C,M=bit32.band(R,0xFFFFF)*0x100000000+bit32.band(S,0xFFFFFFFF),bit32.band(bit32.rshift(R,20),0x7FF)M,C=M-1022,C/0x20000000000000+0.5;local t=math.ldexp(C,M)return bit32.btest(R,0x80000000)and-t or t end;local function T(b,U,V,W,X,Y,Z)local _=0;if W%math.min(U,X)~=0 and X>1 then local x=0;while W%math.min(U,X)~=0 and x<X do V[W]=0;W=W+1;_=_+1;x=x+1 end end;if Y==H.BIG_ENDIAN then local a0=0;if U>8 then for x=0,U-9 do V[W+x]=Z and b>=2^(U*8-1)~=0 and 0xFF or 0;a0=a0+1;_=_+1 end end;for x=a0,U-1 do V[W+x]=bit32.band(bit32.rshift(b,(U-x-1)*8),0xFF)_=_+1 end else for x=0,math.min(U,8)-1 do V[W+x]=b/2^(x*8)%256;_=_+1 end;for x=8,U-1 do V[W+x]=Z and b>=2^(U*8-1)~=0 and 0xFF or 0;_=_+1 end end;return _ end;local function a1(a2,W,U,Y,X,Z)local a3,a4=0,0;if W%math.min(U,X)~=0 and X>1 then for x=0,X-1 do if W%math.min(U,X)==0 then break end;W=W+1;a4=a4+1 end end;for x=0,U-1 do a3=a3+a2:byte(W+x)*2^((Y==H.BIG_ENDIAN and U-x-1 or x)*8)a4=a4+1 end;if Z and a3>=2^(U*8-1)then a3=a3-2^(U*8)end;return a3,a4 end;local function a5(a6,X)local a7=J[a6]or 0;if X>1 and a7%X~=0 then a7=a7+X-a7%X end;return a7 end;function string.pack(...)local a8=expect(1,...,"string")local Y=H.LITTLE_ENDIAN;local X=1;local a9=1;local aa=2;local V={}local x=1;while x<=#a8 do local ab=a8:sub(x,x)x=x+1;if ab=='='or ab=='<'then Y=H.LITTLE_ENDIAN elseif ab=='>'then Y=H.BIG_ENDIAN elseif ab=='!'then local U=-1;while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=math.max(U,0)*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 or U==0 then error(string.format("integral size (%d) out of limits [1,16]",U),2)elseif U==-1 then X=4 else X=U end elseif I[ab]then local b=expect(aa,select(aa,...),"number")aa=aa+1;if b>=math.pow(2,a5(ab,0)*8-(ab:match("%l")and 1 or 0))or b<(ab:match("%l")and-math.pow(2,a5(ab,0)*8-1)or 0)then error(string.format("bad argument #%d to 'pack' (integer overflow)",aa-1),2)end;a9=a9+T(b,a5(ab,0),V,a9,X,Y,false)elseif ab:lower()=='i'then local Z=ab=='i'local U=-1;while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=math.max(U,0)*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 or U==0 then error(string.format("integral size (%d) out of limits [1,16]",U),2)elseif X>1 and(U~=1 and U~=2 and U~=4 and U~=8 and U~=16)then error("bad argument #1 to 'pack' (format asks for alignment not power of 2)",2)elseif U==-1 then U=4 end;local b=expect(aa,select(aa,...),"number")aa=aa+1;if b>=math.pow(2,U*8-(ab:match("%l")and 1 or 0))or b<(ab:match("%l")and-math.pow(2,U*8-1)or 0)then error(string.format("bad argument #%d to 'pack' (integer overflow)",aa-1),2)end;a9=a9+T(b,U,V,a9,X,Y,Z)elseif ab=='f'then local f=expect(aa,select(aa,...),"number")aa=aa+1;local P=L(f)if a9%math.min(4,X)~=0 and X>1 then for ac=0,X-1 do if a9%math.min(4,X)==0 then break end;V[a9]=0;a9=a9+1 end end;for ac=0,3 do V[a9+(Y==H.BIG_ENDIAN and 3-ac or ac)]=bit32.band(bit32.rshift(P,ac*8),0xFF)end;a9=a9+4 elseif ab=='d'or ab=='n'then local f=expect(aa,select(aa,...),"number")aa=aa+1;local R,S=N(f)if a9%math.min(8,X)~=0 and X>1 then for ac=0,X-1 do if a9%math.min(8,X)==0 then break end;V[a9]=0;a9=a9+1 end end;for ac=0,3 do V[a9+(Y==H.BIG_ENDIAN and 7-ac or ac)]=bit32.band(bit32.rshift(S,ac*8),0xFF)end;for ac=4,7 do V[a9+(Y==H.BIG_ENDIAN and 7-ac or ac)]=bit32.band(bit32.rshift(R,(ac-4)*8),0xFF)end;a9=a9+8 elseif ab=='c'then local U=0;if x>#a8 or not a8:sub(x,x):match("%d")then error("missing size for format option 'c'",2)end;while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if a9+U<a9 or a9+U>0xFFFFFFFF then error("bad argument #1 to 'pack' (format result too large)",2)end;local a2=expect(aa,select(aa,...),"string")aa=aa+1;if#a2>U then error(string.format("bad argument #%d to 'pack' (string longer than given size)",aa-1),2)end;if U>0 then for ac=0,U-1 do V[a9+ac]=a2:byte(ac+1)or 0 end;a9=a9+U end elseif ab=='z'then local a2=expect(aa,select(aa,...),"string")aa=aa+1;for ad in a2:gmatch"."do if ad=='\0'then error(string.format("bad argument #%d to 'pack' (string contains zeros)",aa-1),2)end end;for ac=0,#a2-1 do V[a9+ac]=a2:byte(ac+1)end;V[a9+#a2]=0;a9=a9+#a2+1 elseif ab=='s'then local U=0;while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 then error(string.format("integral size (%d) out of limits [1,16]",U),2)elseif U==0 then U=4 end;local a2=expect(aa,select(aa,...),"string")aa=aa+1;if#a2>=math.pow(2,U*8)then error(string.format("bad argument #%d to 'pack' (string length does not fit in given size)",aa-1),2)end;T(#a2,U,V,a9,1,Y,false)for ac=U,#a2+U-1 do V[a9+ac]=a2:byte(ac-U+1)or 0 end;a9=a9+#a2+U elseif ab=='x'then V[a9]=0;a9=a9+1 elseif ab=='X'then if x>=#a8 then error("invalid next option for option 'X'",2)end;local U=0;local ab=a8:sub(x,x)x=x+1;if ab:lower()=='i'then while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 or U==0 then error(string.format("integral size (%d) out of limits [1,16]",U),2)end else U=a5(ab,0)end;if U<1 then error("invalid next option for option 'X'",2)end;if a9%math.min(U,X)~=0 and X>1 then for ac=1,X do if a9%math.min(U,X)==0 then break end;V[a9]=0;a9=a9+1 end end elseif ab~=' 'then error(string.format("invalid format option '%s'",ab),2)end end;return string.char(table.unpack(V))end;function string.packsize(a8)local a9=0;local X=1;local x=1;while x<=#a8 do local ab=a8:sub(x,x)x=x+1;if ab=='!'then local U=0;while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 then error(string.format("integral size (%d) out of limits [1,16]",U),2)elseif U==0 then X=4 else X=U end elseif I[ab]then local U=a5(ab,0)if a9%math.min(U,X)~=0 and X>1 then for ac=1,X do if a9%math.min(U,X)==0 then break end;a9=a9+1 end end;a9=a9+U elseif ab:lower()=='i'then local U=0;while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 then error(string.format("integral size (%d) out of limits [1,16]",U))elseif X>1 and(U~=1 and U~=2 and U~=4 and U~=8 and U~=16)then error("bad argument #1 to 'pack' (format asks for alignment not power of 2)",2)elseif U==0 then U=4 end;if a9%math.min(U,X)~=0 and X>1 then for ac=1,X do if a9%math.min(U,X)==0 then break end;a9=a9+1 end end;a9=a9+U elseif ab=='f'then if a9%math.min(4,X)~=0 and X>1 then for ac=1,X do if a9%math.min(4,X)==0 then break end;a9=a9+1 end end;a9=a9+4 elseif ab=='d'or ab=='n'then if a9%math.min(8,X)~=0 and X>1 then for ac=1,X do if a9%math.min(8,X)==0 then break end;a9=a9+1 end end;a9=a9+8 elseif ab=='c'then local U=0;if x>#a8 or not a8:sub(x,x):match("%d")then error("missing size for format option 'c'",2)end;while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if a9+U<a9 or a9+U>0x7FFFFFFF then error("bad argument #1 to 'packsize' (format result too large)",2)end;a9=a9+U elseif ab=='x'then a9=a9+1 elseif ab=='X'then if x>=#a8 then error("invalid next option for option 'X'",2)end;local U=0;local ab=a8:sub(x,x)x=x+1;if ab:lower()=='i'then while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 or U==0 then error(string.format("integral size (%d) out of limits [1,16]",U),2)end else U=a5(ab,0)end;if U<1 then error("invalid next option for option 'X'",2)end;if a9%math.min(U,X)~=0 and X>1 then for ac=1,X do if a9%math.min(U,X)==0 then break end;a9=a9+1 end end elseif ab=='s'or ab=='z'then error("bad argument #1 to 'packsize' (variable-length format)",2)elseif ab~=' 'and ab~='<'and ab~='>'and ab~='='then error(string.format("invalid format option '%s'",ab),2)end end;return a9 end;function string.unpack(a8,a2,a9)expect(1,a8,"string")expect(2,a2,"string")expect(3,a9,"number","nil")if a9 then if a9<0 then a9=#a2+a9 elseif a9==0 then error("bad argument #3 to 'unpack' (initial position out of string)",2)end;if a9>#a2 or a9<0 then error("bad argument #3 to 'unpack' (initial position out of string)",2)end else a9=1 end;local Y=H.LITTLE_ENDIAN;local X=1;local a7={}local x=1;while x<=#a8 do local ab=a8:sub(x,x)x=x+1;if ab=='<'or ab=='='then Y=H.LITTLE_ENDIAN elseif ab=='>'then Y=H.BIG_ENDIAN elseif ab=='!'then local U=0;while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 then error(string.format("integral size (%d) out of limits [1,16]",U))elseif U==0 then X=4 else X=U end elseif I[ab]then if a9+a5(ab,0)>#a2+1 then error("data string too short",2)end;local w,ae=a1(a2,a9,a5(ab,0),Y,X,ab:match("%l")~=nil)a7[#a7+1]=w;a9=a9+ae elseif ab:lower()=='i'then local Z=ab=='i'local U=0;while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 then error(string.format("integral size (%d) out of limits [1,16]",U),2)elseif U>8 then error(string.format("%d-byte integer does not fit into Lua Integer",U),2)elseif U==0 then U=4 end;if a9+U>#a2+1 then error("data string too short",2)end;local w,ae=a1(a2,a9,U,Y,X,Z)a7[#a7+1]=w;a9=a9+ae elseif ab=='f'then if a9%math.min(4,X)~=0 and X>1 then for ac=1,X do if a9%math.min(4,X)==0 then break end;a9=a9+1 end end;if a9+4>#a2+1 then error("data string too short",2)end;local w=a1(a2,a9,4,Y,X,false)a7[#a7+1]=O(w)a9=a9+4 elseif ab=='d'or ab=='n'then if a9%math.min(8,X)~=0 and X>1 then for ac=1,X do if a9%math.min(8,X)==0 then break end;a9=a9+1 end end;if a9+8>#a2+1 then error("data string too short",2)end;local R,S=0,0;for ac=0,3 do R=bit32.bor(R,bit32.lshift(a2:byte(a9+ac),(Y==H.BIG_ENDIAN and 3-ac or ac)*8))end;for ac=0,3 do S=bit32.bor(S,bit32.lshift(a2:byte(a9+ac+4),(Y==H.BIG_ENDIAN and 3-ac or ac)*8))end;if Y==H.LITTLE_ENDIAN then R,S=S,R end;a7[#a7+1]=Q(R,S)a9=a9+8 elseif ab=='c'then local U=0;if x>#a8 or not a8:sub(x,x):match("%d")then error("missing size for format option 'c'",2)end;while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)")end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if a9+U>#a2+1 then error("data string too short",2)end;a7[#a7+1]=a2:sub(a9,a9+U-1)a9=a9+U elseif ab=='z'then local U=0;while a2:byte(a9+U)~=0 do U=U+1;if a9+U>#a2 then error("unfinished string for format 'z'",2)end end;a7[#a7+1]=a2:sub(a9,a9+U-1)a9=a9+U+1 elseif ab=='s'then local U=0;while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 then error(string.format("integral size (%d) out of limits [1,16]",U),2)elseif U==0 then U=4 end;if a9+U>#a2+1 then error("data string too short",2)end;local b,af=a1(a2,a9,U,Y,X,false)a9=a9+af;if a9+b>#a2+1 then error("data string too short",2)end;a7[#a7+1]=a2:sub(a9,a9+b-1)a9=a9+b elseif ab=='x'then a9=a9+1 elseif ab=='X'then if x>=#a8 then error("invalid next option for option 'X'",2)end;local U=0;local ab=a8:sub(x,x)x=x+1;if ab:lower()=='i'then while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 or U==0 then error(string.format("integral size (%d) out of limits [1,16]",U),2)elseif U==-1 then U=4 end else U=a5(ab,0)end;if U<1 then error("invalid next option for option 'X'",2)end;if a9%math.min(U,X)~=0 and X>1 then for ac=1,X do if a9%math.min(U,X)==0 then break end;a9=a9+1 end end elseif ab~=' 'then error(string.format("invalid format option '%s'",ab),2)end end;a7[#a7+1]=a9;return table.unpack(a7)end end;function panic(ag)term.setBackgroundColor(32768)term.setTextColor(16384)term.setCursorBlink(false)local r,s=term.getCursorPos()r=1;local ah,ai=term.getSize()ag="panic: "..(ag or"unknown")for aj in ag:gmatch"%S+"do if r+#aj>=ah then r,s=1,s+1;if s>ai then term.scroll(1)s=s-1 end end;term.setCursorPos(r,s)if r==1 then term.clearLine()end;term.write(aj.." ")r=r+#aj+1 end;r,s=1,s+1;if s>ai then term.scroll(1)s=s-1 end;if debug then local ak=debug.traceback(nil,2)for al in ak:gmatch"[^\n]+"do term.setCursorPos(1,s)term.write(al)s=s+1;if s>ai then term.scroll(1)s=s-1 end end end;term.setCursorPos(1,s)term.setTextColor(2)term.write("panic: We are hanging here...")mainThread=nil;if _HEADLESS then os.shutdown(1)end;while true do coroutine.yield()end end;function do_syscall(am,...)local w=table.pack(coroutine.yield("syscall",am,...))if w[1]then return table.unpack(w,2,w.n)else error(w[2],3)end end;function deepcopy(an)if type(an)=="table"then local a7=setmetatable({},deepcopy(getmetatable(an)))for j,k in pairs(an)do a7[deepcopy(j)]=deepcopy(k)end;return a7 else return an end end;function split(a2,ao)local A={}for ap in a2:gmatch("[^"..(ao or"%s").."]+")do A[#A+1]=ap end;return A end;local aq=pcall(os.epoch,"nano")and function()return os.epoch"nano"/1000000 end or(ccemux and function()return ccemux.nanoTime()/1000000 end or function()return os.epoch"utc"end)local ar;function getCurrentThread()return ar end;local as={n=0}function executeThread(process,at,au,av,aw)local args;if at.paused then return false,aw end;if at.status=="starting"then args=at.args elseif at.status=="syscall"then args=table.pack(table.unpack(at.syscall_return,3,at.syscall_return.n))elseif at.status=="preempt"then args=as elseif at.status=="suspended"then args={au[1],{}}for j,k in pairs(au[2])do args[2][j]=k end elseif at.status=="paused"then return false,aw end;if at.status~="dead"and(not at.filter or at.filter(process,at,au))then local ax=av;av=false;at.filter=nil;local ay;if at.yielding then ay={n=at.syscall_return.n,true,"syscall",at.yielding,table.unpack(at.syscall_return,4,at.syscall_return.n)}at.yielding=nil else ar=at;local az=globalMetatables;globalMetatables=process.globalMetatables;updateGlobalMetatables()local aA=aq()ay=table.pack(coroutine.resume(at.coro,table.unpack(args,1,args.n)))process.cputime=process.cputime+(aq()-aA)/1000;globalMetatables=az;updateGlobalMetatables()ar=nil end;if ay[2]=="secure_syscall"then ay[2]="syscall"elseif ay[2]=="secure_event"then ay[2]=nil end;if ay[2]=="syscall"then at.status="syscall"local aB=aw;aw=false;if ay[3]and syscalls[ay[3]]then local aA=aq()at.syscall_return=table.pack(coroutine.resume(at.syscall,ay[3],process,at,table.unpack(ay,4,ay.n)))process.systime=process.systime+(aq()-aA)/1000;if at.syscall_return[2]==kSyscallComplete then if not at.syscall_return[3]and type(at.syscall_return[4])=="string"then syslog.log({level="debug",category="Syscall Failure",process=0,module=ay[3]},at.syscall_return[4])at.syscall_return[4]=at.syscall_return[4]:gsub("kernel:%d+: ","")end;if at.syscall_return[4]==kSyscallYield then at.yielding=at.syscall_return[5]aw=aB end else at.yielding=ay[3]end else at.syscall_return={false,"No such syscall",n=2}end elseif ay[2]=="preempt"then at.status="preempt"aw=false elseif coroutine.status(at.coro)=="dead"then at.status="dead"at.return_value=ay[2]if ay[1]then process.lastReturnValue={pid=process.id,thread=at.id,value=ay[2],n=ay.n-1,table.unpack(ay,2,ay.n)}else process.lastReturnValue={pid=process.id,thread=at.id,error=ay[2],traceback=debug.traceback(at.coro)}end;if not ay[1]then at.did_error=true;syslog.log({level=_G.args.traceback and"error"or"debug",process=process.id,thread=at.id,category="Application Error",traceback=true},debug.traceback(at.coro,ay[2]))if ay[2]and process.stderr and process.stderr.isTTY then terminal.write(process.stderr,ay[2].."\n")end end;process.threads[at.id]=nil;av=ax else at.status="suspended"aw=aw and#process.eventQueue==0 end end;return av,aw end;mainThread=coroutine.running()function userModeCallback(process,aC,...)local aD=syscalls.newthread(process,nil,aC,...)local at=process.threads[aD]at.name="<user mode callback>"while at.status~="dead"do if coroutine.running()==mainThread then error("userModeCallback not called from a yieldable context",2)end;coroutine.yield()end;return not at.did_error,at.return_value end;function make_ENV(e)if type(e)~="table"or _VERSION~="Lua 5.1"then return e end;repeat local aE=getmetatable(e)if aE and aE.__env then e=aE.__env end until not aE or not aE.__env;local A=setmetatable({},{__index=function(self,aF)if self==e then e=getmetatable(self).__env end;if aF=="_ENV"then return e else return e[aF]end end,__newindex=function(self,aF,aG)if self==e then e=getmetatable(self).__env end;if aF=="_ENV"then e=aG else e[aF]=aG end end,__pairs=function(self)if self==e then e=getmetatable(self).__env end;return next,e end,__len=function(self)if self==e then e=getmetatable(self).__env end;return#e end,__env=e})return A end;for B,k in ipairs({...})do local aH,aI=k:match("^([^=]+)=(.+)$")if aH and aI then if type(args[aH])=="boolean"then args[aH]=aI:lower()=="true"or aI=="1"elseif type(args[aH])=="number"then args[aH]=tonumber(aI)else args[aH]=aI end elseif aH=="silent"then args.loglevel=5 elseif aH=="quiet"then args.loglevel=3 end end;if _HEADLESS then args.headless=true end;local function aJ(aK)local w;if _CC_VERSION then w=aK<=_CC_VERSION elseif not _HOST then w=aK<=os.version():gsub("CraftOS ","")elseif _HOST:match("ComputerCraft 1%.1%d+")~=aK:match("1%.1%d+")then aK=aK:gsub("(1%.)([02-9])","%10%2")local aL=_HOST:gsub("(ComputerCraft 1%.)([02-9])","%10%2")w=aK<=aL:match("ComputerCraft ([0-9%.]+)")else w=aK<=_HOST:match("ComputerCraft ([0-9%.]+)")end;return w end;if not aJ"1.87.0"then panic("Phoenix requires ComputerCraft 1.87.0 or later. Please upgrade your version of ComputerCraft.")end;if jit and args.preemptive then panic("Phoenix does not support preemption when running under LuaJIT. Please set preemptive to false in the kernel arguments.")end;if not debug and args.preemptive then panic("Phoenix does not support preemption without the debug API. Please set preemptive to false in the kernel arguments.")end;if args.preemptive then PHOENIX_BUILD=PHOENIX_BUILD.." PREEMPT"end;if not getfenv then if not debug then panic("Phoenix requires the debug API when running under Lua 5.2 and later.")end;function getfenv(i)local x=1;while true do local o,aG=debug.getupvalue(i,x)if o=="_ENV"then return aG elseif not o then break end;x=x+1 end end;function setfenv(i,e)local x=1;while true do local o=debug.getupvalue(i,x)if o=="_ENV"then debug.upvaluejoin(i,x,function()return e end,1)break elseif not o then break end;x=x+1 end;return i end end;globalMetatables={["nil"]={},["boolean"]={},["number"]={},["string"]={__index=string},["function"]={},["thread"]={__index=coroutine,__call=coroutine.resume},["userdata"]={}}local aM,aN=debug.getmetatable,debug.setmetatable;function updateGlobalMetatables()aN(nil,globalMetatables["nil"])aN(false,globalMetatables["boolean"])aN(0,globalMetatables["number"])aN("",globalMetatables["string"])aN(assert,globalMetatables["function"])aN(coroutine.running(),globalMetatables["thread"])if debug.upvalueid then aN(debug.upvalueid(executeThread,1),globalMetatables["userdata"])end end;local type=type;function debug.getmetatable(aG)if type(aG)=="table"then return aM(aG)else return globalMetatables[type(aG)]end end;function debug.setmetatable(aG,an)expect(2,an,"table")if type(aG)=="table"then return aN(aG,an)else globalMetatables[type(aG)]=an end end;do local aO;local aP,aQ,aR,aS,aT,aU,aV,aW,aX=getfenv,setfenv,debug.getfenv,debug.getlocal,debug.getupvalue,debug.setfenv,debug.setlocal,debug.setupvalue,debug.upvaluejoin;local error,aY,aZ,select,setmetatable,type,tonumber=error,debug.getinfo,coroutine.running,select,setmetatable,type,tonumber;local a_;local function keys(A,k,...)if k then A[k]=true end;if select("#",...)>0 then return keys(A,...)else return A end end;local function b0(k,...)if select("#",...)>0 then return a_[k or""]or k,b0(...)else return a_[k or""]or k end end;local function b1(t)t=bit32.band(tonumber(t),0xFFFFFFFF)if bit32.btest(t,0x80000000)then t=t-0x100000000 end;return t end;function debug.getinfo(at,aC,b2)if type(at)~="thread"then b2,aC,at=aC,at,aZ()end;local a7;if tonumber(aC)then a7=aY(at,aC+1,b2)else a7=aY(at,aC,b2)end;if a7 and a7.func then a7.func=a_[a7.func]or a7.func end;return a7 end;function debug.getlocal(at,b3,b4)if b4==nil then b4,b3,at=b3,at,aZ()end;local j,k;if type(b3)=="function"then local b5=aY(2,"f")if aO[b3]and not(b5 and aO[b3][b5.func])then return nil end;j,k=b0(aS(b3,b4))elseif tonumber(b3)then local info=aY(at,b3+1,"f")local b5=aY(2,"f")if info and aO[info.func]and not(b5 and aO[info.func][b5.func])then return nil end;j,k=b0(aS(at,b3+1,b4))else j,k=b0(aS(at,b3,b4))end;return j,k end;function debug.getupvalue(aC,b6)if type(aC)=="function"then local b5=aY(2,"f")if aO[aC]and not(b5 and aO[aC][b5.func])then return nil end end;local j,k=b0(aT(aC,b6))return j,k end;function debug.setlocal(at,b3,b4,aI)if b4==nil then b4,b3,at=b3,at,aZ()end;if tonumber(b3)then local info=aY(at,b3+1,"f")local b5=aY(2,"f")if info and aO[info.func]and not(b5 and aO[info.func][b5.func])then error("attempt to set local of protected function",2)end;aV(at,b3+1,b4,aI)else aV(at,b3,b4,aI)end end;function debug.setupvalue(aC,b6,aI)if type(aC)=="function"then local b5=aY(2,"f")if aO[aC]and not(b5 and aO[aC][b5.func])then error("attempt to set upvalue of protected function",2)end end;aW(aC,b6,aI)end;function _G.getfenv(f)local k;if f==nil then k=aP(2)elseif tonumber(f)and b1(f)>0 then local info=aY(f+1,"f")local b5=aY(2,"f")if info and aO[info.func]and not(b5 and aO[info.func][b5.func])then return nil end;k=aP(f+1)elseif type(f)=="function"then local b5=aY(2,"f")if aO[f]and not(b5 and aO[f][b5.func])then return nil end;k=aP(f)else k=aP(f)end;return k end;function _G.setfenv(f,an)if tonumber(f)and b1(f)>0 then local info=aY(f+1,"f")local b5=aY(2,"f")if info and aO[info.func]and not(b5 and aO[info.func][b5.func])then error("attempt to set environment of protected function",2)end;aQ(f+1,an)elseif type(f)=="function"then local b5=aY(2,"f")if aO[f]and not(b5 and aO[f][b5.func])then error("attempt to set environment of protected function",2)end end;aQ(f,an)end;if aR then function debug.getfenv(b7)if type(b7)=="function"then local b5=aY(2,"f")if aO[b7]and not(b5 and aO[b7][b5.func])then return nil end end;local k=aR(b7)return k end;function debug.setfenv(b7,an)if type(b7)=="function"then local b5=aY(2,"f")if aO[b7]and not(b5 and aO[b7][b5.func])then error("attempt to set environment of protected function",2)end end;aU(b7,an)end end;if aX then function debug.upvaluejoin(b8,b9,ba,bb)if type(b8)=="function"and type(ba)=="function"then local b5=aY(2,"f")if aO[b8]and not(b5 and aO[b8][b5.func])then error("attempt to get upvalue of protected function",2)end;if aO[ba]and not(b5 and aO[ba][b5.func])then error("attempt to set upvalue of protected function",2)end end;aX(b8,b9,ba,bb)end end;function debug.protect(aC)if type(aC)~="function"then error("bad argument #1 (expected function, got "..type(aC)..")",2)end;if aO[aC]then error("attempt to protect a protected function",2)end;aO[aC]=keys(setmetatable({},{__mode="k"}))end;a_={[aS]=debug.getlocal,[aV]=debug.setlocal,[aT]=debug.getupvalue,[aW]=debug.setupvalue,[aY]=debug.getinfo,[b0]=function()end}if debug.upvaluejoin then a_[aX]=debug.upvaluejoin end;if debug.getfenv then a_[aR]=debug.getfenv end;if debug.setfenv then a_[aU]=debug.setfenv end;if _G.getfenv then a_[aP]=_G.getfenv end;if _G.setfenv then a_[aQ]=_G.setfenv end;aO=keys(setmetatable({},{__mode="k"}),getfenv,setfenv,debug.getfenv,debug.setfenv,debug.getlocal,debug.setlocal,debug.getupvalue,debug.setupvalue,debug.upvaluejoin,debug.getinfo,b0,debug.protect)for j,k in pairs(aO)do aO[j]={}end end;mounts={}fifos={}fsevents={}filesystems={craftos={meta={meta={type="directory",owner="root",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}},metapath="/meta.ltn",lastDispatch=0},tmpfs={},drivefs={},tablefs={},bind={}}local function bc(process,g)local G=fs.combine(process.root,g:sub(1,1)=="/"and""or process.dir,g)if"/"..G.."/"~=process.root and G:find(process.root:sub(2),1,true)~=1 then error(g..": No such file or directory",4)end;return G end;local function bd(process,g,be)local bf=split(bc(process,g),"/\\")if#bf==0 then if be then return mounts[""],g,""end;return mounts[""][1],g,""end;local bg;for j in pairs(mounts)do local bh=true;for x,ab in ipairs(split(j,"/\\"))do if bf[x]~=ab then bh=false;break end end;if bh and(not bg or#j>#bg)then bg=j end end;if not bg then panic("Could not find mount for path "..g..". Where is root?")end;local bi=split(bg,"/\\")local G=#bf>=#bi+1 and fs.combine(table.unpack(bf,#bi+1,#bf))or""local mounts=mounts[bg]if be then return mounts,G,bg end;local bj=mounts[1]if#mounts>1 then for B,k in ipairs(mounts)do local bh,w=pcall(k.stat,k,process,G,true)if bh and w then bj=k;break end end end;return bj,G,bg end;function filesystem.readhandle(process,bk,bl)if bk==""then local bm=false;local function bn()if bm then return nil end;bm=true;return""end;local bo={readLine=bn,readAll=bn,read=bn,close=function()end}if bl then function bo.seek()bm=false end;function bo.read(t)if not t then return nil end;return bn()end end;return bo end;local a9=1;local bp=false;local A={readLine=function(bq)if bp then error("attempt to use a closed file",2)end;if a9>#bk then return nil end;local br;br,a9=bk:match("([^\n]*"..(bq and"\n?)"or")\n?").."()",a9)return br end,readAll=function()if bp then error("attempt to use a closed file",2)end;if a9>#bk then return nil end;local br=bk:sub(a9)a9=#br+1;return br end,read=function(t)if bp then error("attempt to use a closed file",2)end;if t~=nil and type(t)~="number"then error("bad argument #1 (expected number, got "..type(t)..")",2)end;t=t or 1;if a9>#bk then return nil end;local br=bk:sub(a9,a9+t-1)a9=a9+t;return br end,close=function()if bp then error("attempt to use a closed file",2)end;bp=true end}if bl then A.read=function(t)if bp then error("attempt to use a closed file",2)end;if t~=nil and type(t)~="number"then error("bad argument #1 (expected number, got "..type(t)..")",2)end;if a9>#bk then return nil end;if t then local br=bk:sub(a9,a9+t-1)a9=a9+t;return br else local br=bk:byte(a9)a9=a9+1;return br end end;A.seek=function(bs,W)if bs~=nil and type(bs)~="string"then error("bad argument #1 (expected string, got "..type(bs)..")",2)end;if W~=nil and type(W)~="number"then error("bad argument #2 (expected number, got "..type(W)..")",2)end;bs=bs or"cur"W=W or 0;if bp then error("attempt to use closed file",2)end;if bs=="set"then a9=W+1 elseif bs=="cur"then a9=a9+W elseif bs=="end"then a9=math.max(#bk-W,1)else error("Invalid whence",2)end;return a9-1 end else bk=bk:gsub("[\x80-\xFF]+",function(bt)local bu=""if not pcall(function()for B,bv in utf8.codes(bt)do bu=bu..(bv<256 and string.char(bv)or"?")end end)then return bt end;return bu end)end;for B,k in pairs(A)do setfenv(k,process.env)debug.protect(k)end;return setmetatable(A,{__name="file"})end;function filesystem.writehandle(process,bw,bl)setfenv(bw,process.env)local function bx(A)for B,k in pairs(A)do setfenv(k,process.env)debug.protect(k)end;return setmetatable(A,{__name="file"})end;local bp=false;if bl then local a9=1;local by=""local bz=""return bx{write=function(br)if bp then error("attempt to use a closed file",2)end;if type(br)=="number"then by,a9=by:sub(1,a9-1)..string.char(br)..by:sub(a9+1),a9+1;if bz then bz=bz..string.char(br)end elseif type(br)=="string"then by,a9=by:sub(1,a9-1)..br..by:sub(a9+#br),a9+#br;if bz then bz=bz..br end else error("bad argument #1 (expected string or number, got "..type(br)..")",2)end end,writeLine=function(br)if bp then error("attempt to use a closed file",2)end;if type(br)=="number"then by,a9=by:sub(1,a9-1)..string.char(br).."\n"..by:sub(a9+2),a9+2;if bz then bz=bz..string.char(br).."\n"end elseif type(br)=="string"then by,a9=by:sub(1,a9-1)..br.."\n"..by:sub(a9+#br+1),a9+#br+1;if bz then bz=bz..br.."\n"end else error("bad argument #1 (expected string or number, got "..type(br)..")",2)end end,seek=function(bs,W)if bs~=nil and type(bs)~="string"then error("bad argument #1 (expected string, got "..type(bs)..")",2)end;if W~=nil and type(W)~="number"then error("bad argument #2 (expected number, got "..type(W)..")",2)end;bs=bs or"cur"W=W or 0;if bp then error("attempt to use closed file",2)end;local bA=a9;if bs=="set"then a9=W+1 elseif bs=="cur"then a9=a9+W elseif bs=="end"then a9=math.max(#by-W,1)else error("Invalid whence",2)end;if bA~=a9 then bz=nil end;return a9-1 end,flush=function()if bp then error("attempt to use a closed file",2)end;if bz then bw(bz,false)else bw(by,true)end;bz=""end,close=function()if bp then error("attempt to use a closed file",2)end;bp=true;if bz then bw(bz,false)else bw(by,true)end;bz=""end}else local by=""return bx{write=function(br)if bp then error("attempt to use a closed file",2)end;by=by..tostring(br)end,writeLine=function(br)if bp then error("attempt to use a closed file",2)end;by=by..tostring(br).."\n"end,flush=function()if bp then error("attempt to use a closed file",2)end;bw(by,false)by=""end,close=function()if bp then error("attempt to use a closed file",2)end;bw(by,false)by=""bp=true end}end end;function filesystem.fifohandle(process,bB,p)local bp=false;local function bx(A)for B,k in pairs(A)do setfenv(k,process.env)debug.protect(k)end;return setmetatable(A,{__name="file"})end;if p=="r"then return bx{readLine=function(bq)if bp then error("attempt to use a closed file",2)end;if#bB.data==0 then return nil end;local br;br,bB.data=bB.data:match("([^\n]*"..(bq and"\n?)"or")\n?").."(.*)")return br end,readAll=function()if bp then error("attempt to use a closed file",2)end;if#bB.data==0 then return nil end;local br=bB.data;bB.data=""return br end,read=function(t)if bp then error("attempt to use a closed file",2)end;if t~=nil and type(t)~="number"then error("bad argument #1 (expected number, got "..type(t)..")",2)end;t=t or 1;if#bB.data==0 then return nil end;local br=bB.data:sub(1,t)bB.data=bB.data:sub(t+1)return br end,close=function()if bp then error("attempt to use a closed file",2)end;bp=true end}elseif p=="w"or p=="a"then local by=bB.data;return bx{write=function(br)if bp then error("attempt to use a closed file",2)end;by=by..tostring(br)end,writeLine=function(br)if bp then error("attempt to use a closed file",2)end;by=by..tostring(br).."\n"end,flush=function()if bp then error("attempt to use a closed file",2)end;bB.data=by end,close=function()if bp then error("attempt to use a closed file",2)end;bB.data=by;bp=true end}elseif p=="rb"then return bx{readLine=function(bq)if bp then error("attempt to use a closed file",2)end;if#bB.data==0 then return nil end;local br;br,bB.data=bB.data:match("([^\n]*"..(bq and"\n?)"or")\n?").."(.*)")return br end,readAll=function()if bp then error("attempt to use a closed file",2)end;if#bB.data==0 then return nil end;local br=bB.data;bB.data=""return br end,read=function(t)if bp then error("attempt to use a closed file",2)end;if t~=nil and type(t)~="number"then error("bad argument #1 (expected number, got "..type(t)..")",2)end;if#bB.data==0 then return nil end;if t then local br=bB.data:sub(1,t)bB.data=bB.data:sub(t+1)return br else local br=bB.data:byte()bB.data=bB.data:sub(2)return br end end,seek=function(bs,W)if bs~=nil and type(bs)~="string"then error("bad argument #1 (expected string, got "..type(bs)..")",2)end;if W~=nil and type(W)~="number"then error("bad argument #2 (expected number, got "..type(W)..")",2)end;if bp then error("attempt to use closed file",2)end;return 0 end,close=function()if bp then error("attempt to use a closed file",2)end;bp=true end}elseif p=="wb"or p=="ab"then local by=bB.data;return bx{write=function(br)if bp then error("attempt to use a closed file",2)end;if type(br)=="number"then by=by..string.char(br)elseif type(br)=="string"then by=by..br else error("bad argument #1 (expected string or number, got "..type(br)..")",2)end end,writeLine=function(br)if bp then error("attempt to use a closed file",2)end;if type(br)=="number"then by=by..string.char(br).."\n"elseif type(br)=="string"then by=by..br.."\n"else error("bad argument #1 (expected string or number, got "..type(br)..")",2)end end,seek=function(bs,W)if bs~=nil and type(bs)~="string"then error("bad argument #1 (expected string, got "..type(bs)..")",2)end;if W~=nil and type(W)~="number"then error("bad argument #2 (expected number, got "..type(W)..")",2)end;if bp then error("attempt to use closed file",2)end;return#bB.data+#by end,flush=function()if bp then error("attempt to use a closed file",2)end;bB.data=by end,close=function()if bp then error("attempt to use a closed file",2)end;bB.data=by;bp=true end}else return nil,"Invalid mode"end end;filesystem.openfifo=filesystem.fifohandle;do local a=fs.open("/meta.ltn","r")if a then filesystems.craftos.meta=unserialize(a.readAll())or filesystems.craftos.meta;filesystems.craftos.lastDispatch=os.epoch"utc"a.close()end end;shutdownHooks[#shutdownHooks+1]=function()syslog.log("Syncing filesystem")local a=fs.open(filesystems.craftos.metapath,"w")if a then a.write(serialize(filesystems.craftos.meta,{compact=true}))a.close()end end;if args.fsmeta then local a=fs.open(args.fsmeta,"r")if a then local bC=unserialize(a.readAll())a.close()if bC then local function bD(bE,bF)for j,k in pairs(bE)do if bF[j]and type(bF[j])=="table"and type(k)=="table"then bD(k,bF[j])else bF[j]=k end end end;bD(bC,filesystems.craftos.meta)end end end;function filesystems.craftos:getmeta(bG,g,bH)local bI={}local A=self.meta;local bi=split(g,"/\\")for x,G in ipairs(bi)do if G==".."then A=table.remove(bI)if not A then return nil end elseif not G:match"^%.*$"then if not A then return nil elseif A.meta.type~="directory"then error("Not a directory",2)elseif A.meta.permissions[bG]then if not A.meta.permissions[bG].execute then error("Permission denied",2)end elseif not A.meta.worldPermissions.execute then error("Permission denied",2)end;bI[#bI+1]=A;A=A.contents[G]if A and A.meta.type=="link"and not bH then local bJ=filesystem.combine(A.meta.link,table.unpack(bi,x+1))if fs.combine(bJ)==fs.combine(g)then error("Loop in link",2)end;error{link=true,path=bJ,orig=g}end end end;return A and A.meta end;function filesystems.craftos:setmeta(bG,g,bC,bH)local bI={}local A=self.meta;local o;local bi=split(g,"/\\")for x,G in ipairs(bi)do if G==".."then A=table.remove(bI)if not A then error("Not a directory",2)end elseif not G:match"^%.*$"then if A.meta.type~="directory"then error("Not a directory",2)elseif A.meta.permissions[bG]then if not A.meta.permissions[bG].execute then error("Permission denied",2)end elseif not A.meta.worldPermissions.execute then error("Permission denied",2)end;if not A.contents[G]then A.contents[G]={meta={type="directory",owner=A.meta.owner or"root",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}}end;bI[#bI+1]=A;A=A.contents[G]o=G;if A and A.meta.type=="link"and not bH then local bJ=filesystem.combine(A.meta.link,table.unpack(bi,x+1))if fs.combine(bJ)==fs.combine(g)then error("Loop in link",2)end;error{link=true,path=bJ,orig=g}end end end;if bC~=nil then A.meta={type=bC.type,owner=bC.owner,permissions=deepcopy(bC.permissions),worldPermissions=deepcopy(bC.worldPermissions),setuser=bC.setuser,link=bC.link}if bC.type~="directory"then A.contents=nil end else bI[#bI].contents[o]=nil end;if os.epoch"utc"-self.lastDispatch>1000 then local a=assert(fs.open(self.metapath,"w"))a.write(serialize(self.meta,{compact=true}))a.close()self.lastDispatch=os.epoch"utc"end end;function filesystems.craftos:new(process,g,bK)expect.field(bK,"ro","boolean","nil")if process.user~="root"then error("Could not mount "..g..": Permission denied",3)elseif not fs.isDir(g)then error("Could not mount "..g..": No such directory",3)end;return setmetatable({path=g,readOnly=bK.ro},{__index=self})end;function filesystems.craftos:open(process,g,p)local bh,bL=pcall(self.stat,self,process,g)if not bh then if type(bL)=="table"then error(bL)end;return nil,bL elseif not bL then if p:sub(1,1)=="w"or p:sub(1,1)=="a"then if self.readOnly then return nil,"Read-only filesystem"end;local bM,bN=pcall(self.stat,self,process,fs.getDir(g))if not bM or not bN then if type(bN)=="table"then error(bN)end;local bO,q=pcall(self.mkdir,self,process,fs.getDir(g))if not bO then if type(q)=="table"then error(q)end;return nil,q:gsub("kernel:%d: ","")end;bN=self:stat(process,fs.getDir(g))if not bN then return nil,"Could not stat "..fs.getDir(g)end end;if process.user~="root"then local bP=bN.permissions[process.user]or bN.worldPermissions;if not bP.write then return nil,"Permission denied"end end;local bC={type="file",owner=process.user,permissions=deepcopy(bN.permissions),worldPermissions=deepcopy(bN.worldPermissions),setuser=false}if bN.owner then local A=bC.permissions[bN.owner]bC.permissions[bN.owner]=nil;bC.permissions[process.user]=A end;self:setmeta(process.user,fs.combine(self.path,g),bC)local a,q=fs.open(fs.combine(self.path,g),p)if not a then return a,q end;return setmetatable(a,{__name="file"})else return nil,"File not found"end elseif bL.type=="directory"then return nil,"Is a directory"end;local bP=bL.permissions[process.user]or bL.worldPermissions;if process.user~="root"and(p:sub(1,1)=="r"and not bP.read or(p:sub(1,1)=="w"or p:sub(1,1)=="a")and not bP.write)then return nil,"Permission denied"end;if bL.type=="fifo"then local bC=self:getmeta(process.user,fs.combine(self.path,g))local bQ=fifos[bC]if not bQ then bQ={data=""}fifos[bC]=bQ end;return filesystem.fifohandle(process,bQ,p)end;local a,q=fs.open(fs.combine(self.path,g),p)if not a then return nil,q end;return setmetatable(a,{__name="file"})end;function filesystems.craftos:list(process,g)local bL=self:stat(process,g)if not bL or bL.type~="directory"then error(g..": Not a directory",2)end;if process.user~="root"then local bP=bL.permissions[process.user]or bL.worldPermissions;if not bP.read then error(g..": Permission denied",2)end end;return fs.list(fs.combine(self.path,g))end;function filesystems.craftos:stat(process,g,bH)local G=fs.combine(self.path,g)if G:find(self.path:gsub("^/",""):gsub("/$",""),1,false)~=1 then return nil end;local bh,bR=pcall(fs.attributes,G)if not bh or not bR then return nil end;bR.type=bR.isDir and"directory"or"file"bR.special={}bR.isDir=nil;if not bR.modified then bR.modified=bR.modification end;bR.modification=nil;bR.capacity=fs.getCapacity(G)or 0;bR.freeSpace=fs.getFreeSpace(G)local bS=bR.isReadOnly;bR.isReadOnly=nil;local bC=self:getmeta(process.user,fs.combine(self.path,g),bH)if bC then bR.owner=bC.owner;bR.permissions=deepcopy(bC.permissions)bR.worldPermissions=deepcopy(bC.worldPermissions)bR.type=bC.type or bR.type;bR.setuser=bC.setuser;bR.link=bC.link else bR.owner="root"bR.permissions={root={read=true,write=true,execute=true}}bR.worldPermissions={read=true,write=false,execute=true}bR.setuser=false end;if bS then bR.worldPermissions.write=false;for B,k in pairs(bR.permissions)do k.write=false end end;return bR end;function filesystems.craftos:remove(process,g)if self.readOnly then error(g..": Read-only filesystem",2)end;local bL=self:stat(process,g,true)if not bL then return end;local function bT(G)local bt=self:stat(process,G,true)local bP=bt.permissions[process.user]or bt.worldPermissions;if process.user~="root"and not bP.write then error(G..": Permission denied",3)end;if bt.type=="directory"then if process.user~="root"and not bP.read then error(G..": Permission denied",3)end;for B,k in ipairs(fs.list(fs.combine(self.path,G)))do bT(fs.combine(G,k))end end end;bT(g)fs.delete(fs.combine(self.path,g))self:setmeta(process.user,fs.combine(self.path,g),nil,true)end;function filesystems.craftos:rename(process,bU,bV)if self.readOnly then error("Read-only filesystem",2)end;local bW=self:stat(process,bU,true)local bX=self:stat(process,bV,true)if not bW then error(bU..": No such file or directory",2)elseif bX then error(bV..": "..bX.type:gsub("%w",string.upper,1).." already exists",2)end;bX=self:stat(process,fs.getDir(bV))if not bX then self:mkdir(process,fs.getDir(bV))bX=self:stat(process,fs.getDir(bV))end;if process.user~="root"then local bP=bX.permissions[process.user]or bX.worldPermissions;if not bP.write then error(bV..": Permission denied",2)end end;fs.move(fs.combine(self.path,bU),fs.combine(self.path,bV))self:setmeta(process.user,fs.combine(self.path,bV),self:getmeta(process.user,fs.combine(self.path,bU),true),true)self:setmeta(process.user,fs.combine(self.path,bU),nil,true)end;function filesystems.craftos:mkdir(process,g)if self.readOnly then error(g..": Read-only filesystem",2)end;local bL=self:stat(process,g)if bL then if bL.type=="directory"then return else error(g..": File already exists",2)end end;local bi=split(g,"/\\")local x=#bi;repeat x=x-1;bL=self:stat(process,table.concat(bi,"/",1,x))if bL then if bL.type=="directory"then break else error(g..": File already exists",2)end end until bL or x<=0;if not bL then if g:match"^/"then bL=assert(self:stat(process,"/"))else bL=assert(filesystem.stat(process,process.dir))end end;if process.user~="root"then local bP=bL.permissions[process.user]or bL.worldPermissions;if not bP.write then error(g..": Permission denied",2)end end;local bC={type="directory",owner=process.user,permissions=deepcopy(bL.permissions),worldPermissions=deepcopy(bL.worldPermissions)}if bL.owner then local A=bC.permissions[bL.owner]bC.permissions[bL.owner]=nil;bC.permissions[process.user]=A end;x=x+1;while x<=#bi do self:setmeta(process.user,fs.combine(self.path,table.concat(bi,"/",1,x)),deepcopy(bC))x=x+1 end;fs.makeDir(fs.combine(self.path,g))end;function filesystems.craftos:link(process,g,bY)local bL=self:stat(process,g,true)if bL then error(g..": File exists",2)end;self:setmeta(process.user,fs.combine(self.path,g),nil,true)assert(self:open(process,g,"w")).close()local bC=self:getmeta(process.user,fs.combine(self.path,g),true)bC.type,bC.link="link",bY;self:setmeta(process.user,fs.combine(self.path,g),bC,true)end;function filesystems.craftos:mkfifo(process,g)local bL=self:stat(process,g)if bL then error(g..": File exists",2)end;assert(self:open(process,g,"w")).close()local bC=self:getmeta(process.user,fs.combine(self.path,g),true)bC.type="fifo"self:setmeta(process.user,fs.combine(self.path,g),bC,true)end;function filesystems.craftos:chmod(process,g,bG,p)if self.readOnly then error(g..": Read-only filesystem",2)end;local bL=self:stat(process,g,true)if not bL then error(g..": No such file or directory",2)end;if not bL.owner or process.user~="root"and process.user~=bL.owner then error(g..": Permission denied",2)end;local bP;if bG==nil then bP=bL.worldPermissions else bP=bL.permissions[bG]if not bP then bP=deepcopy(bL.worldPermissions)bL.permissions[bG]=bP end end;if type(p)=="string"then if p:match"^[%+%-=][rwxs]+$"then local C=p:sub(1,1)local A={}for ab in p:gmatch("[rwxs]")do if ab=="r"then A.read=true elseif ab=="w"then A.write=true elseif ab=="s"then A.setuser=true else A.execute=true end end;if C=="+"then if A.read then bP.read=true end;if A.write then bP.write=true end;if A.execute then bP.execute=true end;if A.setuser then bL.setuser=true end elseif C=="-"then if A.read then bP.read=false end;if A.write then bP.write=false end;if A.execute then bP.execute=false end;if A.setuser then bL.setuser=false end else bP.read=A.read or false;bP.write=A.write or false;bP.execute=A.execute or false;bL.setuser=A.setuser or false end else bP.read=p:sub(1,1)~="-"bP.write=p:sub(2,2)~="-"bP.execute=p:sub(3,3)~="-"bL.setuser=p:sub(3,3)=="s"end elseif type(p)=="number"then bL.setuser=bit32.btest(p,8)bP.read=bit32.btest(p,4)bP.write=bit32.btest(p,2)bP.execute=bit32.btest(p,1)else if p.read~=nil then bP.read=p.read end;if p.write~=nil then bP.write=p.write end;if p.execute~=nil then bP.execute=p.execute end;if p.setuser~=nil then bL.setuser=p.setuser end end;self:setmeta(process.user,fs.combine(self.path,g),deepcopy(bL),true)end;function filesystems.craftos:chown(process,g,bZ)if self.readOnly then error(g..": Read-only filesystem",2)end;local bL=self:stat(process,g,true)if not bL then error(g..": No such file or directory",2)end;if not bL.owner or process.user~="root"and process.user~=bL.owner then error(g..": Permission denied",2)end;bL.owner=bZ;bL.setuser=false;self:setmeta(process.user,fs.combine(self.path,g),deepcopy(bL),true)end;function filesystems.craftos:info()return"craftos",self.path,{ro=self.readOnly}end;function filesystems.tmpfs:getpath(bG,g,bH)local A=self;local bi=split(g,"/\\")for x,G in ipairs(bi)do if not A then return nil elseif A.type~="directory"then error("Not a directory",2)elseif A.permissions[bG]then if not A.permissions[bG].execute then error("Permission denied",2)end elseif not A.worldPermissions.execute then error("Permission denied",2)end;A=A.contents[G]if A and A.type=="link"and not(bH and x==#bi)then error{link=true,path=filesystem.combine(A.link,table.unpack(bi,x+1)),orig=g}end end;return A end;function filesystems.tmpfs:setpath(bG,g,bk,bH)local A=self;local M=split(g,"/\\")local b_=M[#M]M[#M]=nil;for x,G in ipairs(M)do if A.type~="directory"then error("Not a directory",2)elseif A.permissions[bG]then if not A.permissions[bG].execute then error("Permission denied",2)end elseif not A.worldPermissions.execute then error("Permission denied",2)end;if not A.contents[G]then A.contents[G]={type="directory",owner=A.owner,permissions=deepcopy(A.permissions),worldPermissions=deepcopy(A.worldPermissions),setuser=false,created=os.epoch"utc",modified=os.epoch"utc",contents={}}end;A=A.contents[G]if A and A.type=="link"then error{link=true,path=filesystem.combine(A.link,table.unpack(M,x+1)),orig=g}end end;if A.type~="directory"then error("Not a directory",2)elseif bG~="root"then if A.permissions[bG]then if not A.permissions[bG].execute then error("Permission denied",2)end elseif not A.worldPermissions.execute then error("Permission denied",2)end end;if not bH and A.contents[b_]and A.contents[b_].type=="link"then error{link=true,path=A.contents[b_].link,orig=g}end;A.contents[b_]=bk end;function filesystems.tmpfs:new(process,bE,bK)return setmetatable({type="directory",owner=process.user,permissions={[process.user]={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false,created=os.epoch"utc",modified=os.epoch"utc",contents={}},{__index=self})end;function filesystems.tmpfs:_open_internal(process,g,p)local c0=os.epoch;local bk=self:getpath(process.user,g)if not bk then return nil,"No such file"end;if p=="r"or p=="rb"then return filesystem.readhandle(process,bk.data,p=="rb")elseif p=="w"or p=="wb"then bk.data=""bk.modified=c0"utc"return filesystem.writehandle(process,function(by,c1)if c1 then bk.data=by else bk.data=bk.data..by end;bk.modified=c0"utc"if self.__flush then self:__flush()end end,p=="wb")elseif p=="a"or p=="ab"then local c2=bk.data;return filesystem.writehandle(process,function(by,c1)if c1 then bk.data=c2 ..by else bk.data=bk.data..by end;bk.modified=c0"utc"if self.__flush then self:__flush()end end,p=="ab")else return nil,"Invalid mode"end end;function filesystems.tmpfs:open(process,g,p)if self.readOnly and(p:sub(1,1)=="w"or p:sub(1,1)=="a")then return nil,"Read-only filesystem"end;local bh,bL=pcall(self.stat,self,process,g)if not bh then if type(bL)=="table"then error(bL)end;return nil,bL elseif not bL then if p:sub(1,1)=="w"or p:sub(1,1)=="a"then local bM,bN=pcall(self.stat,self,process,fs.getDir(g))if not bM or not bN then if type(bN)=="table"then error(bN)end;local bO,q=pcall(self.mkdir,self,process,fs.getDir(g))if not bO then if type(q)=="table"then error(q)end;return nil,q:gsub("kernel:%d: ","")end;bN=self:stat(process,fs.getDir(g))end;if process.user~="root"then local bP=bN.permissions[process.user]or bN.worldPermissions;if not bP.write then return nil,"Permission denied"end end;local bC={type="file",owner=process.user,permissions=deepcopy(bN.permissions),worldPermissions=deepcopy(bN.worldPermissions),setuser=false,created=os.epoch"utc",modified=os.epoch"utc",data=""}local A=bC.permissions[bN.owner]bC.permissions[bN.owner]=nil;bC.permissions[process.user]=A;self:setpath(process.user,g,bC)return self:_open_internal(process,g,p)else return nil,"File not found"end elseif bL.type=="directory"then return nil,"Is a directory"end;if process.user~="root"then local bP=bL.permissions[process.user]or bL.worldPermissions;if p:sub(1,1)=="r"and not bP.read or(p:sub(1,1)=="w"or p:sub(1,1)=="a")and not bP.write then return nil,"Permission denied"end end;if bL.type=="fifo"then local bC=self:getpath(process.user,g)local bQ=fifos[bC]if not bQ then bQ={data=""}fifos[bC]=bQ end;return filesystem.fifohandle(process,bQ,p)end;return self:_open_internal(process,g,p)end;function filesystems.tmpfs:list(process,g)local bk=self:getpath(process.user,g)if not bk or bk.type~="directory"then error(g..": Not a directory",2)end;if process.user~="root"then local bP=bk.permissions[process.user]or bk.worldPermissions;if not bP.read then error(g..": Permission denied",2)end end;local a7={}for j in pairs(bk.contents)do a7[#a7+1]=j end;table.sort(a7)return a7 end;function filesystems.tmpfs:stat(process,g,bH)local bk=self:getpath(process.user,g,bH)if not bk then return nil end;return{size=bk.type=="file"and#bk.data or(bk.type=="directory"and#bk.contents or 0),type=bk.type,created=bk.created,modified=bk.modified,owner=bk.owner,permissions=deepcopy(bk.permissions),worldPermissions=deepcopy(bk.worldPermissions),setuser=bk.setuser,capacity=math.huge,freeSpace=math.huge,link=rawget(bk,"link"),special={}}end;function filesystems.tmpfs:remove(process,g)if self.readOnly then error("Read-only filesystem",2)end;local c3=self:getpath(process.user,fs.getDir(g))local o=fs.getName(g)if not c3 or c3.type~="directory"or not c3.contents[o]then return end;if process.user~="root"and not(c3.permissions[process.user]or c3.worldPermissions).write then error(g..": Permission denied",2)end;local bk=c3.contents[o]if process.user~="root"and not(bk.permissions[process.user]or bk.worldPermissions).write then error(g..": Permission denied",2)end;local function bT(bt)local bP=bt.permissions[process.user]or bt.worldPermissions;if process.user~="root"and not bP.write then error(g..": Permission denied",3)end;if bt.type=="directory"then if process.user~="root"and not bP.read then error(g..": Permission denied",3)end;for B,k in pairs(bt.contents)do bT(k)end end end;bT(bk)c3.contents[o]=nil;c3.modified=os.epoch"utc"end;function filesystems.tmpfs:rename(process,bU,bV)if self.readOnly then error("Read-only filesystem",2)end;local c4=self:getpath(process.user,fs.getDir(bU))local c5=fs.getName(bU)if not c4 or c4.type~="directory"or not c4.contents[c5]then error(bU..": No such file or directory",2)end;if process.user~="root"and not(c4.permissions[process.user]or c4.worldPermissions).write then error(bU..": Permission denied",2)end;local c6=c4.contents[c5]if process.user~="root"and not(c6.permissions[process.user]or c6.worldPermissions).write then error(bU..": Permission denied",2)end;local c7=self:getpath(process.user,fs.getDir(bV))local c8=fs.getName(bV)if not c7 or c7.type~="directory"then error(bV..": No such file or directory",2)end;if process.user~="root"and not(c7.permissions[process.user]or c7.worldPermissions).write then error(bV..": Permission denied",2)end;local c9=c7.contents[c8]if c9 then error(bV..": File already exists",2)end;c7.contents[c8],c4.contents[c5]=c6,nil;local ca=os.epoch"utc"c4.modified,c7.modified=ca,ca end;function filesystems.tmpfs:mkdir(process,g)if self.readOnly then error("Read-only filesystem",2)end;local A=self;for B,G in ipairs(split(g,"/\\"))do local bP=A.permissions[process.user]or A.worldPermissions;if A.type~="directory"then error(g..": File exists",2)elseif process.user~="root"and not bP.execute then error(g..": Permission denied",2)end;if not A.contents[G]then if process.user~="root"and not bP.write then error(g..": Permission denied",2)end;A.contents[G]={type="directory",owner=A.owner,permissions=deepcopy(A.permissions),worldPermissions=deepcopy(A.worldPermissions),created=os.epoch"utc",modified=os.epoch"utc",contents={}}A.modified=os.epoch"utc"end;A=A.contents[G]end end;function filesystems.tmpfs:link(process,g,bY)if self.readOnly then error("Read-only filesystem",2)end;local bL=self:stat(process,g)if bL then error(g..": File exists",2)end;local bM,bN=pcall(self.stat,self,process,fs.getDir(g))if not bM or not bN then if type(bN)=="table"then error(bN)end;local bO,q=pcall(self.mkdir,self,process,fs.getDir(g))if not bO then if type(q)=="table"then error(q)end;return nil,type(q)=="string"and q:gsub("kernel:%d: ","")or q end;bN=self:stat(process,fs.getDir(g))end;self:setpath(process.user,g,{type="link",owner=process.user,permissions=deepcopy(bN.permissions),worldPermissions=deepcopy(bN.worldPermissions),setuser=false,created=os.epoch"utc",modified=os.epoch"utc",path=bY},true)end;function filesystems.tmpfs:mkfifo(process,g)if self.readOnly then error("Read-only filesystem",2)end;local bL=self:stat(process,g)if bL then error(g..": File exists",2)end;local bM,bN=pcall(self.stat,self,process,fs.getDir(g))if not bM or not bN then if type(bN)=="table"then error(bN)end;local bO,q=pcall(self.mkdir,self,process,fs.getDir(g))if not bO then if type(q)=="table"then error(q)end;return nil,type(q)=="string"and q:gsub("kernel:%d: ","")or q end;bN=self:stat(process,fs.getDir(g))end;self:setpath(process.user,g,{type="fifo",owner=process.user,permissions=deepcopy(bN.permissions),worldPermissions=deepcopy(bN.worldPermissions),setuser=false,created=os.epoch"utc",modified=os.epoch"utc"},true)end;function filesystems.tmpfs:chmod(process,g,bG,p)if self.readOnly then error("Read-only filesystem",2)end;local bL=self:getpath(process.user,g,true)if not bL then error(g..": No such file or directory",2)end;if not bL.owner or process.user~="root"and process.user~=bL.owner then error(g..": Permission denied",2)end;local bP;if bG==nil then bP=bL.worldPermissions else bP=bL.permissions[bG]if not bP then bP=deepcopy(bL.worldPermissions)bL.permissions[bG]=bP end end;if type(p)=="string"then if p:match"^[%+%-=][rwxs]+$"then local C=p:sub(1,1)local A={}for ab in p:gmatch("[rwxs]")do if ab=="r"then A.read=true elseif ab=="w"then A.write=true elseif ab=="s"then A.setuser=true else A.execute=true end end;if C=="+"then if A.read then bP.read=true end;if A.write then bP.write=true end;if A.execute then bP.execute=true end;if A.setuser then bL.setuser=true end elseif C=="-"then if A.read then bP.read=false end;if A.write then bP.write=false end;if A.execute then bP.execute=false end;if A.setuser then bL.setuser=false end else bP.read=A.read or false;bP.write=A.write or false;bP.execute=A.execute or false;bL.setuser=A.setuser or false end else bP.read=p:sub(1,1)~="-"bP.write=p:sub(2,2)~="-"bP.execute=p:sub(3,3)~="-"bL.setuser=p:sub(3,3)=="s"end elseif type(p)=="number"then bL.setuser=bit32.btest(p,8)bP.read=bit32.btest(p,4)bP.write=bit32.btest(p,2)bP.execute=bit32.btest(p,1)else if p.read~=nil then bP.read=p.read end;if p.write~=nil then bP.write=p.write end;if p.execute~=nil then bP.execute=p.execute end;if p.setuser~=nil then bL.setuser=p.setuser end end end;function filesystems.tmpfs:chown(process,g,bZ)if self.readOnly then error("Read-only filesystem",2)end;local bL=self:getpath(process.user,g,true)if not bL then error(g..": No such file or directory",2)end;if not bL.owner or process.user~="root"and process.user~=bL.owner then error(g..": Permission denied",2)end;bL.owner=bZ;bL.setuser=false end;function filesystems.tmpfs:info()return"tmpfs","memory",{ro=self.readOnly}end;setmetatable(filesystems.drivefs,{__index=filesystems.craftos})function filesystems.drivefs:stat(process,g)local w,q=filesystems.craftos.stat(self,process,g)if g==""and w==nil then return{size=0,type="directory",created=0,modified=0,owner=self.owner,capacity=0,freeSpace=0,permissions={[self.owner]={read=false,write=true,execute=false}},worldPermissions={read=false,write=false,execute=false},setuser=false}end;return w,q end;function filesystems.drivefs:new(process,bE,bK)local cb=hardware.get(bE)if not cb then error("Could not find drive at "..bE)end;local g=hardware.call(process,cb,"getMountPath")local fs=filesystems.craftos:new(process,g,bK)fs.drive=cb.uuid;fs.owner=process.user;fs.meta={meta={type="directory",owner="root",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}}fs.metapath=fs.combine(g,".meta.ltn")local a=fs.open(fs.metapath,"r")if a then fs.meta=unserialize(a.readAll())or fs.meta;a.close()end;return setmetatable(fs,{__index=self})end;function filesystems.drivefs:info()return"drivefs",self.drive,{ro=self.readOnly}end;setmetatable(filesystems.tablefs,{__index=filesystems.tmpfs})function filesystems.tablefs:new(process,bE,bK)local A;local a,q;if process~=KERNEL and mounts[""]then a,q=filesystem.open(process,bE,"r")else a,q=fs.open(bE,"r")end;if a then local bk=a.readAll()or""a.close()local bh,w=pcall(unserialize,bk)if not bh then error("Could not mount "..bE..": "..w,3)elseif type(w)~="table"or w.type~="directory"or type(w.contents)~="table"then error("Could not mount "..bE..": Invalid table file",3)end;A=w else if not(bK.rw and not bK.ro)then error("Could not mount "..bE..": "..q,3)end;A={type="directory",owner=process.user,permissions={[process.user]={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false,created=os.epoch"utc",modified=os.epoch"utc",contents={}}end;A.src=bE;A.readOnly=bK.ro;if bK.rw and not bK.ro then function A:__flush()local f,bt=self.__flush,self.src;self.__flush,self.src=nil;local bh,w=pcall(serialize,self)self.__flush,self.src=f,bt;if not bh then error(w)end;local a,q=filesystem.open(process,bE,"w")if not a then syslog.log({level=4},"Could not save mount to "..bE..": "..q)return end;a.write(w)a.close()end end;return setmetatable(A,{__index=self})end;function filesystems.tablefs:info()return"tablefs",self.src,{rw=self.__flush~=nil,ro=self.readOnly}end;function filesystems.bind:new(process,g,bK)local bL,q=filesystem.stat(process,g)if not bL then error("Could not bind "..g..": "..q,3)elseif bL.type~="directory"then error("Could not bind "..g..": Not a directory",3)end;return setmetatable({path=g},{__index=self})end;function filesystems.bind:open(process,g,p)return filesystem.open(process,fs.combine(self.path,g),p)end;function filesystems.bind:list(process,g)return filesystem.list(process,fs.combine(self.path,g))end;function filesystems.bind:stat(process,g,bH)return filesystem.stat(process,fs.combine(self.path,g),bH)end;function filesystems.bind:remove(process,g)return filesystem.remove(process,fs.combine(self.path,g))end;function filesystems.bind:rename(process,bU,bV)return filesystem.rename(process,fs.combine(self.path,bU),fs.combine(self.path,bV))end;function filesystems.bind:mkdir(process,g)return filesystem.mkdir(process,fs.combine(self.path,g))end;function filesystems.bind:link(process,g,bY)return filesystem.link(process,fs.combine(self.path,g),bY)end;function filesystems.bind:mkfifo(process,g)return filesystem.mkfifo(process,fs.combine(self.path,g))end;function filesystems.bind:chmod(process,g,bG,p)return filesystem.chmod(process,fs.combine(self.path,g),bG,p)end;function filesystems.bind:chown(process,g,bZ)return filesystem.chown(process,fs.combine(self.path,g),bZ)end;function filesystems.bind:info()return"bind",self.path,{}end;local function cc(process,g,cd,ce)local cf=bc(process,g)if ce then if cf==""then cf=nil else cf=fs.getDir(cf)end end;if cf and fsevents[cf]then for B,k in pairs(fsevents[cf])do local cg=cf;if cg:find(k.root,1,true)==1 then cg=cg:sub(#k.root+1)end;k.eventQueue[#k.eventQueue+1]={"fsevent",{path=cg,event=cd,name=ce and fs.getName(cf)or nil,process=process.id}}wakeup(k)end end end;function filesystem.open(process,g,p)expect(0,process,"table")expect(1,g,"string")expect(2,p,"string")if not p:match"^[rwa]b?$"then error("Invalid mode",0)end;for B=1,1000 do local bh,bj,G=pcall(bd,process,g)if not bh then return nil,bj end;local w=table.pack(pcall(bj.open,bj,process,G,p))if w[1]then if w[2]and p~="r"and p~="rb"then cc(process,g,"open",false)cc(process,g,"open_child",true)end;return table.unpack(w,2,w.n)elseif type(w[2])~="table"or type(w[2].path)~="string"then error(w[2],2)end;g=w[2].path end;error("Too many levels of symbolic links",2)end;local function ch(process,g,ci)local a7={}local mounts,G=bd(process,g,true)for B,bj in ipairs(mounts)do local bh,w=pcall(bj.list,bj,process,G)if not bh then if type(w)~="table"or type(w.path)~="string"then if#mounts==1 and ci then error(w,2)else w={}end else w=ch(process,w.path,false)end end;for B,k in ipairs(w)do a7[#a7+1]=k end end;return a7 end;function filesystem.list(process,g)expect(0,process,"table")expect(1,g,"string")local a7=ch(process,g,true)table.sort(a7)return a7 end;function filesystem.stat(process,g,bH)expect(0,process,"table")expect(1,g,"string")for B=1,1000 do local bh,bj,G,cj=pcall(bd,process,g)if not bh then return nil,bj end;local ck,w,q=pcall(bj.stat,bj,process,G,bH)if ck then if w then w.mountpoint="/"..cj end;return w,q elseif type(w)~="table"or type(w.path)~="string"then error(w,2)end;g=w.path end;error("Too many levels of symbolic links",2)end;function filesystem.remove(process,g)expect(0,process,"table")expect(1,g,"string")for B=1,1000 do local bj,G=bd(process,g)local bh,w=pcall(bj.remove,bj,process,G)if bh then cc(process,g,"remove",false)cc(process,g,"remove_child",true)return elseif type(w)~="table"or type(w.path)~="string"then error(w,2)end;g=w.path end;error("Too many levels of symbolic links",2)end;function filesystem.rename(process,bU,bV)expect(0,process,"table")expect(1,bU,"string")expect(2,bV,"string")for B=1,1000 do local cl,cm=bd(process,bU)local cn,co=bd(process,bV)if cl~=cn then error("Attempt to rename file across two filesystems",0)end;local bh,w=pcall(cl.rename,cl,process,cm,co)if bh then cc(process,bU,"rename_from",false)cc(process,bU,"rename_from_child",true)cc(process,bV,"rename_to",false)cc(process,bV,"rename_to_child",true)return elseif type(w)~="table"or type(w.path)~="string"then error(w,2)end;if w.orig==bU then bU=w.path else bV=w.path end end;error("Too many levels of symbolic links",2)end;function filesystem.mkdir(process,g)expect(0,process,"table")expect(1,g,"string")for B=1,1000 do local bj,G=bd(process,g)local bh,w=pcall(bj.mkdir,bj,process,G)if bh then cc(process,g,"mkdir",false)cc(process,g,"mkdir_child",true)return elseif type(w)~="table"or type(w.path)~="string"then error(w,2)end;g=w.path end;error("Too many levels of symbolic links",2)end;function filesystem.link(process,g,bY)expect(0,process,"table")expect(1,g,"string")expect(2,bY,"string")if fs.combine(g)==fs.combine(bY)then error("Cannot link file to itself",2)end;syslog.debug("Creating link",g," => ",bY)for B=1,1000 do local bj,G=bd(process,g)if not bj.link then error("Filesystem does not support links",2)end;local bh,w=pcall(bj.link,bj,process,G,bY)if bh then cc(process,g,"link",false)cc(process,g,"link_child",true)return elseif type(w)~="table"or type(w.path)~="string"then error(w,2)end;g=w.path end;error("Too many levels of symbolic links",2)end;function filesystem.mkfifo(process,g)expect(0,process,"table")expect(1,g,"string")for B=1,1000 do local bj,G=bd(process,g)if not bj.mkfifo then error("Filesystem does not support FIFOs",2)end;local bh,w=pcall(bj.mkfifo,bj,process,G)if bh then cc(process,g,"mkfifo",false)cc(process,g,"mkfifo_child",true)return elseif type(w)~="table"or type(w.path)~="string"then error(w,2)end;g=w.path end;error("Too many levels of symbolic links",2)end;function filesystem.chmod(process,g,bG,p)expect(0,process,"table")expect(1,g,"string")expect(2,bG,"string","nil")expect(3,p,"number","string","table")if type(p)=="string"and not p:match"^[%+%-=][rwxs]+$"and not p:match"^[r%-][w%-][xs%-]$"then error("bad argument #3 (invalid mode)",2)elseif type(p)=="table"then expect.field(p,"read","boolean","nil")expect.field(p,"write","boolean","nil")expect.field(p,"execute","boolean","nil")end;for B=1,1000 do local bj,G=bd(process,g)local bh,w=pcall(bj.chmod,bj,process,G,bG,p)if bh then return elseif type(w)~="table"or type(w.path)~="string"then error(w,2)end;g=w.path end;error("Too many levels of symbolic links",2)end;function filesystem.chown(process,g,bG)expect(0,process,"table")expect(1,g,"string")expect(2,bG,"string")for B=1,1000 do local bj,G=bd(process,g)local bh,w=pcall(bj.chown,bj,process,G,bG)if bh then return elseif type(w)~="table"or type(w.path)~="string"then error(w,2)end;g=w.path end;error("Too many levels of symbolic links",2)end;function filesystem.chroot(process,g)expect(0,process,"table")expect(1,g,"string")if process.user~="root"then error("Could not change root: Permission denied",2)end;local cp=filesystem.combine(process.root,g).."/"if cp:find(process.root,1,true)~=1 then error("Could not change root: No such file or directory",2)end;local bt=filesystem.stat(process,"/"..g)if not bt then error(g..": No such directory",2)end;if bt.type~="directory"then error(g..": Not a directory",2)end;process.root=cp end;function filesystem.mount(process,type,bE,bF,bK)expect(0,process,"table")expect(1,type,"string")expect(2,bE,"string")expect(3,bF,"string")expect(4,bK,"table","nil")if not filesystems[type]then error("No such filesystem '"..type.."'",2)end;local G=bc(process,bF)if G==""then if process.user~="root"then error("Could not mount to "..bF..": Permission denied",2)end;if mounts[G]and not(bK and bK.overlay)then error("Could not mount to "..bF..": Mount already exists (use overlay to mount over)")end;if not mounts[G]and(bK and bK.overlay)then error("Could not mount to "..bF..": No base mount exists for overlay")end else local bL=filesystem.stat(process,bF)if not bL then error("Could not mount to "..bF..": No such directory",2)end;if bL.type~="directory"then error("Could not mount to "..bF..": Not a directory",2)end;if process.user~="root"and not(bL.permissions[process.user]or bL.worldPermissions).write then error("Could not mount to "..bF..": Permission denied",2)end;if mounts[G]and not(bK and bK.overlay)then error("Could not mount to "..bF..": Mount already exists (use overlay to mount over)")end;if not mounts[G]and(bK and bK.overlay)then error("Could not mount to "..bF..": No base mount exists for overlay")end end;local bj=filesystems[type]:new(process,bE,bK or{})if bK and bK.overlay then mounts[G][#mounts[G]+1]=bj else mounts[G]={bj}end end;function filesystem.unmount(process,g)expect(0,process,"table")expect(1,g,"string")g=bc(process,g)if not mounts[g]then error(g..": No such mount",2)end;local b_=#mounts[g]local bL=mounts[g][b_]:stat(process,"")if not bL then error("Internal error in unmount: could not get stat for root! Please report this to the maintainer of the target filesystem.",2)elseif process.user~="root"and not(bL.permissions[process.user]or bL.worldPermissions).write then error(g..": Permission denied",2)end;if mounts[g][b_].unmount then mounts[g][b_]:unmount(process)end;mounts[g][b_]=nil;if b_==1 then mounts[g]=nil end end;function filesystem.mountlist(process)expect(0,process,"table")local a7={}for j,k in pairs(mounts)do if"/"..j.."/"==process.root or j:find(process.root:sub(2),1,true)==1 then for B,bj in ipairs(k)do local type,g,bK=bj:info()a7[#a7+1]={path="/"..j,type=type,source=g,options=bK}end end end;return a7 end;function filesystem.combine(cq,...)expect(1,cq,"string")local a2=fs.combine(cq,...)if cq:match"^/"then a2="/"..a2 end;return a2 end;function syscalls.open(process,at,...)return filesystem.open(process,...)end;function syscalls.list(process,at,...)return filesystem.list(process,...)end;function syscalls.stat(process,at,...)return filesystem.stat(process,...)end;function syscalls.remove(process,at,...)return filesystem.remove(process,...)end;function syscalls.rename(process,at,...)return filesystem.rename(process,...)end;function syscalls.mkdir(process,at,...)return filesystem.mkdir(process,...)end;function syscalls.link(process,at,...)return filesystem.link(process,...)end;function syscalls.mkfifo(process,at,...)return filesystem.mkfifo(process,...)end;function syscalls.chmod(process,at,...)return filesystem.chmod(process,...)end;function syscalls.chown(process,at,...)return filesystem.chown(process,...)end;function syscalls.chroot(process,at,...)return filesystem.chroot(process,...)end;function syscalls.mount(process,at,...)return filesystem.mount(process,...)end;function syscalls.unmount(process,at,...)return filesystem.unmount(process,...)end;function syscalls.mountlist(process,at,...)return filesystem.mountlist(process,...)end;function syscalls.combine(process,at,...)return filesystem.combine(...)end;function syscalls.loadCraftOSAPI(process,at,cr)expect(1,cr,"string")local e;e=setmetatable({dofile=function(g)local a,q=fs.open(g,"rb")if not a then error("Could not open module: "..q,0)end;local i,q=load(a.readAll(),"@"..g,nil,e)a.close()if not i then error("Could not load module: "..q,0)end;return i()end,require=function(o)return e.dofile("rom/modules/main/"..o:gsub("%.","/")..".lua")end},{__index=process.env})e._ENV=e;if cr:sub(1,3)=="cc."then local g=fs.combine("rom/modules/main",cr:gsub("%.","/")..".lua")if not g:match"^/?rom/modules/main/"then error("Invalid module path",0)end;return e.dofile(g)else if not cr:match"^[a-z]+$"then error("Invalid API name",0)end;local g=fs.combine("rom/apis",cr..".lua")local a,q=fs.open(g,"rb")if not a then error("Could not open module: "..q,0)end;local i,q=load(a.readAll(),"@"..g,nil,e)a.close()if not i then error("Could not load module: "..q,0)end;i()local A={}for j,k in pairs(e)do if j~="dofile"and j~="require"and j~="_ENV"then A[j]=k end end;return A end end;function syscalls.fsevent(process,at,g,cs)expect(1,g,"string")expect(2,cs,"boolean","nil")if cs==nil then cs=true end;g=bc(process,g)syslog.debug("Registering fsevents for",g)fsevents[g]=fsevents[g]or setmetatable({},{__mode="v"})fsevents[g][#fsevents[g]+1]=cs and process or nil end;xpcall(function()if args.initrd then if args.initrd:match"^_G%.."then local ci=_G[args.initrd:match"^_G%.(.+)"]if type(ci)~="table"then error("Requested root filesystem in global '"..args.initrd.."' is not a table")end;ci.src=args.initrd;mounts[""]={setmetatable(ci,{__index=filesystems.tablefs})}else mounts[""]={filesystems.tablefs:new(KERNEL,args.initrd,{})}end else local bK={}if args.rootflags then for C in args.rootflags:gmatch"[^,]+"do local j,k=C:match("^([^=]+)=(.*)$")if j and k then if k=="true"then bK[j]=true elseif k=="false"then bK[j]=false else bK[j]=tonumber(k)or k end else bK[C]=true end end end;mounts[""]={filesystems[args.rootfstype]:new(KERNEL,args.root,bK)}end end,panic)local do_syscall=do_syscall;local expect=expect;local function ct(cu,cv,cw,cx)local cy={bit32.extract(cv,0,16),bit32.extract(cv,16,16),bit32.extract(cu,0,16),bit32.extract(cu,16,16)}local ad={bit32.extract(cx,0,16),bit32.extract(cx,16,16),bit32.extract(cw,0,16),bit32.extract(cw,16,16)}local bz={{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0}}for cz=1,4 do for cA=1,4 do local t=cy[cA]*ad[cz]+bz[cz][cA]bz[cz][cA+1],bz[cz][cA]=bit32.rshift(t,16),bit32.band(t,0xFFFF)end end;local cB={0,0,0,0,0,0,0,0}for cC=1,8 do for cD=1,4 do cB[cC]=cB[cC]+(bz[cD][cC-cD+1]or 0)end;cB[cC+1],cB[cC]=bit32.rshift(cB[cC],16),bit32.band(cB[cC],0xFFFF)end;return cB[3]+cB[4]*0x10000,cB[1]+cB[2]*0x10000 end;local function cE(ad,cu,cv)return cu+math.floor((cv+ad)/0x100000000),bit32.band(cv+ad,0xFFFFFFFF)end;function makeRandom()local cF,cG=0,0;local function next(cH)cF,cG=cE(0xB,ct(cF,cG,0x5,0xDEECE66D))cF=bit32.band(cF,0xFFFF)return math.floor(cF/2^(16-cH))+math.floor(cG/2^(48-cH))end;local function cI(c,d)expect(1,c,"number","nil")expect(2,d,"number","nil")if c then expect.range(c,0,0x7FFFFFFF)if not d then c,d=0,c else expect.range(d,0,0x7FFFFFFF)end;local cJ=d-c+1;local cK;if math.log(cJ,2)%1==0 then cK=math.floor(cJ*next(31)/0x80000000)else local cH;repeat cH=next(31)cK=cH%cJ until cH-cK+cJ-1>=0 end;return cK+c else return(next(26)*0x8000000+next(27))/0x20000000000000 end end;local function cL(cM)expect(1,cM,"number")cF,cG=bit32.band(bit32.bxor(0x5,math.floor(cM/0x100000000)),0xFFFF),bit32.bxor(0xDEECE66D,math.floor(cM))end;cL(os.epoch"utc"*tonumber(tostring(next):match("%x+")or"1",16))return cI,cL end;do math.random,math.randomseed=makeRandom()end;function createLuaLib(process)local cN={}for B,k in ipairs{"assert","error","getmetatable","ipairs","next","pairs","pcall","rawequal","rawget","rawset","select","setmetatable","tonumber","tostring","type","_VERSION","xpcall","collectgarbage"}do cN[k]=_G[k]end;function cN.dofile(g)if g~=nil and type(g)~="string"then error("bad argument #1 (expected string, got "..type(g)..")",2)end;local i,q=loadfile(g or io.stdin:read("*a"))if not i then error(q,2)end;return i()end;do local load,getfenv,setfenv,make_ENV=load,getfenv,setfenv,make_ENV;if _VERSION=="Lua 5.1"then function cN.load(n,o,p,e)return load(n,o,p,make_ENV(e or process.env))end;function cN.getfenv(f)local k;if f==nil then k=getfenv(2)elseif tonumber(f)and tonumber(f)>0 then k=getfenv(f+1)elseif type(f)=="function"then k=getfenv(f)else k=getfenv(f)end;local aE=getmetatable(f)if aE and aE.__env then return aE.__env else return k end end;function cN.setfenv(f,M)return setfenv(f,make_ENV(M))end else cN.load,cN.getfenv,cN.setfenv=function(n,o,p,e)return load(n,o,p,e or process.env)end,getfenv,setfenv end end;function cN.loadfile(g,p,e)if e==nil and type(p)=="table"then e,p=p,nil end;if type(g)~="string"then error("bad argument #1 (expected string, got "..type(g)..")",2)end;if p~=nil and type(p)~="string"then error("bad argument #2 (expected string, got "..type(p)..")",2)end;if e~=nil and type(e)~="table"then error("bad argument #3 (expected table, got "..type(e)..")",2)end;local a,q=do_syscall("open",g,"rb")if not a then error(q,2)end;local bk=a.readAll()a.close()return load(bk,"@"..g,p,e)end;function cN.print(...)local args=table.pack(...)if args.n==0 then args={"",n=1}end;args[args.n]=tostring(args[args.n]).."\n"return do_syscall("write",table.unpack(args,1,args.n))end;cN.coroutine=deepcopy(coroutine)cN.string=deepcopy(string)cN.table=deepcopy(table)cN.math=deepcopy(math)cN.bit32=deepcopy(bit32)cN.utf8=deepcopy(utf8)cN.math.random,cN.math.randomseed=makeRandom()local cO=""local cP=setmetatable({close=function()end,lines=function(self,...)local args=table.pack(...)return function()return self:read(table.unpack(args,1,args.n))end end,read=function(self,a8,...)local bt,M;a8=a8 or"*l"if type(a8)=="number"then while#cO<a8 do cO=cO..do_syscall("read",a8)end elseif type(a8)=="string"then a8=a8:gsub("^%*","")if a8=="n"then while not cO:find("%d")do local bu=do_syscall("readline")if bu==nil then break end;cO=cO..bu.."\n"end elseif a8=="a"then while true do local bu=do_syscall("readline")if bu==nil then break end;cO=cO..bu.."\n"end elseif a8=="l"or a8=="L"then local bu=do_syscall("readline")if bu==nil then return nil end;cO=cO..bu.."\n"else error("bad argument (invalid format '"..a8 .."')",2)end else error("bad argument (expected string or number, got "..type(a8),2)end;if type(a8)=="number"then bt,M=cO:sub(1,a8),a8+1 elseif a8=="n"then bt,M=cO:match("(%d)()")elseif a8=="a"then bt,M=cO,#cO+1 elseif a8=="l"then bt,M=cO:match("(.*)\n()")else bt,M=cO:match("(.*\n)()")end;if not bt then return nil end;cO=cO:sub(M)if select("#",...)>0 then return bt,self:read(...)else return bt end end,seek=function()return nil,"Cannot seek default file"end,setvbuf=function()end},{__name="FILE*"})local cQ=setmetatable({close=function()end,flush=function()end,seek=function()return nil,"Cannot seek default file"end,setvbuf=function()end,write=function(self,...)do_syscall("write",...)return self end},{__name="FILE*"})local cR=setmetatable({close=function()end,flush=function()end,seek=function()return nil,"Cannot seek default file"end,setvbuf=function()end,write=function(self,...)do_syscall("writeerr",...)return self end},{__name="FILE*"})local cS,cT=cP,cQ;local cU={close=function(self)self._file.close()self._closed=true end,lines=function(self,...)local args=table.pack(...)return function()return self:read(table.unpack(args,1,args.n))end end,read=function(self,a8,...)local k;if a8==nil then a8="l"end;if type(a8)=="number"then k=self._file.read(a8)elseif type(a8)=="string"then a8=a8:gsub("^%*","")if a8=="a"then k=self._file.readAll()elseif a8=="l"then k=self._file.readLine(false)elseif a8=="L"then k=self._file.readLine(true)elseif a8=="n"then local bt,ab=""repeat ab=self._file.read(1)until ab:match("%d")while ab:match("%d")do bt,ab=bt..ab,self._file.read(1)end;k=tonumber(bt)else error("bad argument (invalid format '"..a8 .."')",2)end else error("bad argument (expected string or number, got "..type(a8)..")",2)end;if select("#",...)>0 then return k,self:read(...)else return k end end,seek=function(self,bs,W)if self._file.seek then return self._file.seek(bs,W)else return nil,"Cannot seek text file"end end,setvbuf=function()end}local cV={close=function(self)self._file.close()self._closed=true end,flush=function(self)self._file:flush()end,seek=function(self,bs,W)if self._file.seek then return self._file.seek(bs,W)else return nil,"Cannot seek text file"end end,setvbuf=function()end,write=function(self,...)self._file.write(...)return self end}cN.io={close=function(a)if a==nil then cT:close()elseif type(a)=="table"and getmetatable(a)and getmetatable(a).__name=="FILE*"then a:close()else error("bad argument #1 (expected FILE*, got "..type(a)..")",2)end end,flush=function()return cT:flush()end,input=function(a)if a==nil then return cS elseif type(a)=="string"then local ai,q=io.open(a,"r")if not ai then error(q,2)end;cS=ai elseif type(a)=="table"and getmetatable(a)and getmetatable(a).__name=="FILE*"then cS=a else error("bad argument #1 (expected string or FILE*, got "..type(a)..")",2)end end,lines=function(cW,...)if cW==nil then return cS:lines(...)end;if type(cW)~="string"then error("bad argument #1 (expected string, got "..type(cW)..")",2)end;local ai,q=io.open(cW,"r")if not ai then error(q,2)end;local i=ai:lines(...)return function(...)local a7=table.pack(i(...))if a7.n==0 or a7[1]==nil then ai:close()end;return table.unpack(a7,1,a7.n)end end,open=function(cW,p)if type(cW)~="string"then error("bad argument #1 (expected string, got "..type(cW)..")",2)end;if p==nil then p="r"end;if type(p)~="string"then error("bad argument #2 (expected string, got "..type(p)..")",2)end;local a,q=do_syscall("open",cW,p)if not a then return nil,q elseif p:find("r")then return setmetatable({_file=a},{__index=cU,__name="FILE*"})else return setmetatable({_file=a},{__index=cV,__name="FILE*"})end end,output=function(a)if a==nil then return cT elseif type(a)=="string"then local ai,q=io.open(a,"w")if not ai then error(q,2)end;cT=ai elseif type(a)=="table"and getmetatable(a)and getmetatable(a).__name=="FILE*"then cT=a else error("bad argument #1 (expected string or FILE*, got "..type(a)..")",2)end end,popen=function(g,p)expect(1,g,"string")p=expect(2,p,"string","nil")or"r"if p~="r"and p~="w"and p~="rw"then error("bad argument #2 (invalid mode)",2)end;if p=="rw"then local cX,cY="",""local cZ;local c_={read=function(t)if cX==""then return nil elseif t then local bt=cX:sub(1,t)cX=cX:sub(t+1)return bt else local bt,M=cX:match"([^\n]*)\n*()"cX=cX:sub(M)return bt end end}local d0={write=function(bt)cX=cX..bt end,flush=function()end,close=function()local info=do_syscall("getpinfo",cZ)if not info then return end;repeat local au,d1=coroutine.yield()until au=="process_complete"and d1.pid==cZ end}local d2={read=function(t)if cY==""then return nil elseif t then local bt=cY:sub(1,t)cY=cY:sub(t+1)return bt else local bt,M=cY:match"([^\n]*)\n*()"cY=cY:sub(M)return bt end end,readLine=function()local bt,M=cY:match"([^\n]*)\n*()"cY=cY:sub(M)return bt end,readAll=function()local bt=cY;cY=""return bt end,close=function()local info=do_syscall("getpinfo",cZ)if not info then return end;repeat local au,d1=coroutine.yield()until au=="process_complete"and d1.pid==cZ end}local d3={write=function(bt)cY=cY..bt end}cZ=do_syscall("fork",function()do_syscall("stdin",c_)do_syscall("stdout",d3)do_syscall("exec","/bin/sh","-c",g)end)return setmetatable({_file=d2},{__index=cU,__name="FILE*"}),setmetatable({_file=d0},{__index=cV,__name="FILE*"})else local d4=""local bp=false;local cZ;local d5={read=function(t)if d4==""then if bp then return nil else return""end elseif t then local bt=d4:sub(1,t)d4=d4:sub(t+1)return bt else local bt,M=d4:match"([^\n]*\n?)()"d4=d4:sub(M)return bt end end,readLine=function()local bt,M=d4:match"([^\n]*\n?)()"d4=d4:sub(M)return bt end,readAll=function()local bt=d4;d4=""return bt end,close=function()bp=true;local info=do_syscall("getpinfo",cZ)if not info then return end;repeat local au,d1=coroutine.yield()until au=="process_complete"and d1.pid==cZ end}local d6={write=function(bt)d4=d4 ..bt end,flush=function()end,close=function()bp=true;local info=do_syscall("getpinfo",cZ)if not info then return end;repeat local au,d1=coroutine.yield()until au=="process_complete"and d1.pid==cZ end}cZ=do_syscall("fork",function()do_syscall(p=="r"and"stdout"or"stdin",p=="r"and d6 or d5)do_syscall("exec","/bin/sh","-c",g)end)return p=="r"and setmetatable({_file=d5},{__index=cU,__name="FILE*"})or setmetatable({_file=d6},{__index=cV,__name="FILE*"})end end,read=function(...)return cS:read(...)end,tmpfile=function()return io.open(os.tmpname(),"a")end,type=function(bB)if type(bB)=="table"and getmetatable(bB)and getmetatable(bB).__name=="FILE*"then if bB._closed then return"closed file"else return"file"end else return nil end end,write=function(...)return cT:write(...)end,stdin=cP,stdout=cQ,stderr=cR}local d7=os;cN.os={clock=function()return do_syscall("clock")end,date=function(a8,ca)if type(a8)=="string"and a8:sub(1,1)=="?"then local br=d7.date("!"..a8:sub(2),ca or d7.epoch"ingame"/1000)if type(br)=="table"then br.year=br.year-1970 end;return br else return d7.date(a8,ca)end end,difftime=function(cy,ad)return cy-ad end,execute=function(g)do_syscall("exec","/bin/sh","-c",g)end,exit=function(bv)do_syscall("exit",bv)end,getenv=function(o)expect(1,o,"string")local e=do_syscall("getenv")if not e then return nil end;return e[o]end,remove=function(g)expect(1,g,"string")local bh,q=do_syscall("remove",g)if not bh then bh=nil end;return bh,q end,rename=function(bU,bV)expect(1,bU,"string")expect(2,bV,"string")local bh,q=do_syscall("rename",bU,bV)if not bh then bh=nil end;return bh,q end,setlocale=function(d8)if d8 then error("setlocale is not supported",2)else return"C"end end,time=function(A)if A=="ingame"then return d7.epoch"ingame"/1000 elseif A=="nano"then return ccemux and ccemux.nanoTime()or d7.epoch"nano"end;expect(1,A,"table","nil")if A then return d7.time(A)else return d7.epoch"utc"/1000 end end,tmpname=function()local o="/tmp/lua_"for x=1,6 do local t=math.random(1,64)o=o..("qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890._"):sub(t,t)end;return o end}cN.debug=deepcopy(debug)local d9,da,db,aY,getCurrentThread,dc,dd,next,xpcall,wakeup=coroutine.resume,coroutine.yield,debug.sethook,debug.getinfo,getCurrentThread,table.pack,table.unpack,next,xpcall,wakeup;local de=debugHooks;function cN.coroutine.resume(df,...)expect(1,df,"thread")local at=getCurrentThread()if process.debugging then for aD,dg in next,process.breakpoints do if dg.type=="resume"and(dg.thread==nil or dg.thread==at.id)then local bh=true;if dg.filter then for j,k in next,dg.filter do if info[j]~=k then bh=false;break end end end;if bh then dg.process.eventQueue[#dg.process.eventQueue+1]={"debug_break",{process=process.id,thread=at.id,breakpoint=aD}}wakeup(dg.process)at.paused=true;da("preempt")end end end end;local dh=#at.coroStack+1;at.coroStack[dh]=df;local a7=dc(d9(df,...))while a7.n>=2 and a7[1]==true and(a7[2]=="preempt"or a7[2]=="secure_syscall"or a7[2]=="secure_event")do a7=dc(d9(df,da(dd(a7,2,a7.n))))end;if process.debugging and not a7[1]then local info=aY(df,1)for aD,dg in next,process.breakpoints do if dg.type=="error"and(dg.thread==nil or dg.thread==at.id)then local bh=true;if dg.filter then for j,k in next,dg.filter do if info[j]~=k then bh=false;break end end end;if bh then dg.process.eventQueue[#dg.process.eventQueue+1]={"debug_break",{process=process.id,thread=at.id,breakpoint=aD}}wakeup(dg.process)at.paused=true;da("preempt")end end end end;at.coroStack[dh]=nil;return dd(a7,1,a7.n)end;function cN.coroutine.yield(cy,ad,...)if process.debugging then local at=getCurrentThread()local info=aY(2)for aD,dg in next,process.breakpoints do if dg.type=="syscall"and not(dg.filter and dg.filter.name and dg.filter.name~=ad)and(dg.thread==nil or dg.thread==at.id)then dg.process.eventQueue[#dg.process.eventQueue+1]={"debug_break",{process=process.id,thread=at.id,breakpoint=aD}}wakeup(dg.process)at.paused=true;da("preempt")elseif dg.type=="yield"and(dg.thread==nil or dg.thread==at.id)then local bh=true;if dg.filter then for j,k in next,dg.filter do if info[j]~=k then bh=false;break end end end;if bh then dg.process.eventQueue[#dg.process.eventQueue+1]={"debug_break",{process=process.id,thread=at.id,breakpoint=aD}}wakeup(dg.process)at.paused=true;da("preempt")end end end end;return da(cy,ad,...)end;function cN.debug.gethook(df)expect(1,df,"thread","nil")df=df or coroutine.running()local ai=de[df]if not ai then return nil end;return ai.func,ai.mask,ai.count end;function cN.debug.sethook(df,aC,y,di)if type(df)~="thread"then df,aC,y,di=coroutine.running(),df,aC,y end;expect(1,df,"thread")expect(2,aC,"function","nil")if aC then expect(3,y,"string")expect(4,di,"number","nil")de[df]={func=aC,mask=y,count=di}if not process.debugging then db(df,process.hookf,y,process.quantum)end else de[df]=nil;if not process.debugging then db(df,process.hookf,"",process.quantum)end end end;function cN.pcall(f,...)return xpcall(f,function(q)if process.debugging then local at=getCurrentThread()local info=aY(2)for aD,dg in next,process.breakpoints do if dg.type=="error"and(dg.thread==nil or dg.thread==at.id)then local bh=true;if dg.filter then for j,k in next,dg.filter do if info[j]~=k then bh=false;break end end end;if bh then dg.process.eventQueue[#dg.process.eventQueue+1]={"debug_break",{process=process.id,thread=at.id,breakpoint=aD,error=q}}wakeup(dg.process)at.paused=true;da("preempt")end end end end;return q end,...)end;function cN.xpcall(f,dj,...)return xpcall(f,function(q)if process.debugging then local at=getCurrentThread()local info=aY(2)for aD,dg in next,process.breakpoints do if dg.type=="error"and(dg.thread==nil or dg.thread==at.id)then local bh=true;if dg.filter then for j,k in next,dg.filter do if info[j]~=k then bh=false;break end end end;if bh then dg.process.eventQueue[#dg.process.eventQueue+1]={"debug_break",{process=process.id,thread=at.id,breakpoint=aD,error=q}}wakeup(dg.process)at.paused=true;da("preempt")end end end end;return dj(q)end,...)end;createRequire(process,cN)for j,k in pairs(cN)do if type(k)=="function"then pcall(setfenv,k,cN)pcall(debug.protect,k)elseif type(k)=="table"and j~="debug"then for B,ah in pairs(k)do if type(ah)=="function"then pcall(setfenv,ah,cN)pcall(debug.protect,ah)end end end end;return cN end;function loadfile(g,p,e)if e==nil and type(p)=="table"then e,p=p,nil end;if type(g)~="string"then error("bad argument #1 (expected string, got "..type(g)..")",2)end;if p~=nil and type(p)~="string"then error("bad argument #2 (expected string, got "..type(p)..")",2)end;if e~=nil and type(e)~="table"then error("bad argument #3 (expected table, got "..type(e)..")",2)end;local a,q=filesystem.open(KERNEL,g,"rb")if not a then error(q,2)end;local bk=a.readAll()a.close()return load(bk,"@"..g,p,e)end;function dofile(g)if g~=nil and type(g)~="string"then error("bad argument #1 (expected string, got "..type(g)..")",2)end;local i,q=loadfile(g or io.stdin:read("*a"))if not i then error(q,2)end;return i()end;function print(...)for x=1,select("#",...)do local k=tostring(select(x,...))terminal.write(TTY[1],k)end end;function terminal.makeTTY(term,v,dk)local a7={isTTY=true,flags={cbreak=false,delay=true,echo=true,keypad=false,nlcr=true,raw=false},cursor={x=1,y=1},cursorBlink=true,colors={fg='0',bg='f',bold=false},size={width=v,height=dk},dirtyLines={},palette={},dirtyPalette={},buffer="",preBuffer="",isLocked=false,isGraphics=false,textBuffer={},graphicsBuffer={},frontmostProcess=nil,processList={},eof=false,term=term}for s=1,dk do a7[s]={(' '):rep(v),('0'):rep(v),('f'):rep(v)}a7.dirtyLines[s]=true end;for x=0,15 do a7.palette[x]={_G.term.nativePaletteColor(2^x)}a7.dirtyPalette[x]=true end;return a7 end;do local dl,dm=term.getSize()TTY={terminal.makeTTY(term,dl,dm),terminal.makeTTY(term,dl,dm),terminal.makeTTY(term,dl,dm),terminal.makeTTY(term,dl,dm),terminal.makeTTY(term,dl,dm),terminal.makeTTY(term,dl,dm),terminal.makeTTY(term,dl,dm),terminal.makeTTY(term,dl,dm)}end;currentTTY=TTY[1]terminal.userTTYs={}do local t=args.console:match"^tty(%d+)$"if t then KERNEL.stdout,KERNEL.stderr,KERNEL.stdin=TTY[tonumber(t)],TTY[tonumber(t)],TTY[tonumber(t)]end end;keysHeld={ctrl=false,alt=false,shift=false}eventHooks.term_resize=eventHooks.term_resize or{}eventHooks.char=eventHooks.char or{}eventHooks.paste=eventHooks.paste or{}eventHooks.key=eventHooks.key or{}eventHooks.key_up=eventHooks.key_up or{}eventHooks.term_resize[#eventHooks.term_resize+1]=function()local ah,ai=term.getSize()for x=1,8 do terminal.resize(TTY[x],ah,ai)end end;eventHooks.char[#eventHooks.char+1]=function(au)if not currentTTY.isLocked then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer..au[2]else currentTTY.preBuffer=currentTTY.preBuffer..au[2]end;if currentTTY.flags.echo then terminal.write(currentTTY,au[2])terminal.redraw(currentTTY)end end end;eventHooks.paste[#eventHooks.paste+1]=function(au)if not currentTTY.isLocked then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer..au[2]else currentTTY.preBuffer=currentTTY.preBuffer..au[2]end;if currentTTY.flags.echo then terminal.write(currentTTY,au[2])terminal.redraw(currentTTY)end end end;eventHooks.key[#eventHooks.key+1]=function(au)if not currentTTY.isLocked then if au[2]==keys.enter then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer.."\n"else currentTTY.buffer=currentTTY.buffer..currentTTY.preBuffer.."\n"currentTTY.preBuffer=""end;if currentTTY.flags.echo then terminal.write(currentTTY,"\n")terminal.redraw(currentTTY)end elseif au[2]==keys.backspace then if currentTTY.flags.cbreak then elseif#currentTTY.preBuffer>0 then currentTTY.preBuffer=currentTTY.preBuffer:sub(1,-2)if currentTTY.flags.echo then terminal.write(currentTTY,"\b \b")terminal.redraw(currentTTY)end end end end;if au[2]==keys.leftCtrl or au[2]==keys.rightCtrl then keysHeld.ctrl=true elseif au[2]==keys.leftAlt or au[2]==keys.rightAlt then keysHeld.alt=true elseif au[2]==keys.leftShift or au[2]==keys.rightShift then keysHeld.shift=true end;if not currentTTY.flags.raw and currentTTY.frontmostProcess and keysHeld.ctrl and not keysHeld.alt and not keysHeld.shift then if au[2]==keys.c then killProcess(currentTTY.frontmostProcess.id,2)terminal.write(currentTTY,"^C")elseif au[2]==keys.backslash then killProcess(currentTTY.frontmostProcess.id,3)terminal.write(currentTTY,"^\\")elseif au[2]==keys.z then killProcess(currentTTY.frontmostProcess.id,19)terminal.write(currentTTY,"^Z")elseif au[2]==keys.d then currentTTY.eof=true;terminal.write(currentTTY,"^D")elseif au[2]==keys.l and currentTTY.cursor.y>1 then local s=currentTTY.cursor.y-1;terminal.write(currentTTY,"\x1b["..s.."T\x1b[1;"..currentTTY.cursor.x.."H")end end;if keysHeld.ctrl and not keysHeld.alt and keysHeld.shift then local dn=true;if au[2]==keys.f1 then currentTTY=TTY[1]elseif au[2]==keys.f2 then currentTTY=TTY[2]elseif au[2]==keys.f3 then currentTTY=TTY[3]elseif au[2]==keys.f4 then currentTTY=TTY[4]elseif au[2]==keys.f5 then currentTTY=TTY[5]elseif au[2]==keys.f6 then currentTTY=TTY[6]elseif au[2]==keys.f7 then currentTTY=TTY[7]elseif au[2]==keys.f8 then currentTTY=TTY[8]elseif au[2]==keys.left then for x=1,8 do if currentTTY==TTY[x]then currentTTY=TTY[(x+7)%8]break end end elseif au[2]==keys.right then for x=1,8 do if currentTTY==TTY[x]then currentTTY=TTY[(x+1)%8]break end end else dn=false end;if dn then terminal.redraw(currentTTY,true)end end end;eventHooks.key_up[#eventHooks.key_up+1]=function(au)if au[2]==keys.leftCtrl or au[2]==keys.rightCtrl then keysHeld.ctrl=false elseif au[2]==keys.leftAlt or au[2]==keys.rightAlt then keysHeld.alt=false elseif au[2]==keys.leftShift or au[2]==keys.rightShift then keysHeld.shift=false end end;function terminal.redraw(dp,c1)if _HEADLESS and dp==TTY[1]and not dp.isLocked then return end;if dp.process then dp.process.eventQueue[#dp.process.eventQueue+1]={"tty_redraw",{id=dp.id}}return elseif currentTTY~=dp and not dp.isMonitor then return end;local term=dp.term;local d4=dp;if dp.isLocked then if dp.isGraphics then term.setGraphicsMode(2)if term.setFrozen then term.setFrozen(true)end;if c1 then term.clear()term.drawPixels(0,0,dp.graphicsBuffer)for x=0,255 do term.setPaletteColor(x,dp.graphicsBuffer.palette[x][1],dp.graphicsBuffer.palette[x][2],dp.graphicsBuffer.palette[x][3])end else if dp.graphicsBuffer.frozen then if term.setFrozen then term.setFrozen(false)end;return end;for B,k in ipairs(dp.graphicsBuffer.dirtyRects)do if k.color then term.setPixel(k.x,k.y,k.color,k.width,k.height)else term.drawPixels(k.x,k.y,k)end end;for x in pairs(dp.graphicsBuffer.dirtyPalette)do term.setPaletteColor(x,dp.graphicsBuffer.palette[x][1],dp.graphicsBuffer.palette[x][2],dp.graphicsBuffer.palette[x][3])end end;if term.setFrozen then term.setFrozen(false)end;d4.dirtyRects,d4.dirtyPalette={},{}return end;if term.setGraphicsMode then term.setGraphicsMode(false)end;d4=dp.textBuffer elseif dp.isGraphics then term.setGraphicsMode(false)dp.isGraphics=false end;term.setCursorBlink(false)if c1 then term.clear()for s=1,dp.size.height do term.setCursorPos(1,s)term.blit(d4[s][1],d4[s][2],d4[s][3])end;for x=0,15 do term.setPaletteColor(2^x,d4.palette[x][1],d4.palette[x][2],d4.palette[x][3])end else for s in pairs(d4.dirtyLines)do if not d4[s]then error(debug.traceback(s))end;term.setCursorPos(1,s)if#d4[s][1]~=#d4[s][2]or#d4[s][2]~=#d4[s][3]then syslog.log({level="critical"},"Bug in text writer! Inequal lengths: "..#d4[s][1]..", "..#d4[s][2]..", "..#d4[s][3])error("Invalid lengths")end;term.blit(d4[s][1],d4[s][2],d4[s][3])end;for x in pairs(d4.dirtyPalette)do term.setPaletteColor(2^x,d4.palette[x][1],d4.palette[x][2],d4.palette[x][3])end end;term.setCursorPos(d4.cursor.x,d4.cursor.y)term.setCursorBlink(d4.cursorBlink)term.setTextColor(2^tonumber(d4.colors.fg,16))d4.dirtyLines,d4.dirtyPalette={},{}end;function terminal.resize(dp,v,dk)if v>dp.size.width then for s=1,dp.size.height do dp[s][1]=dp[s][1]..(' '):rep(v-dp.size.width)dp[s][2]=dp[s][2]..dp.colors.fg:rep(v-dp.size.width)dp[s][3]=dp[s][3]..dp.colors.bg:rep(v-dp.size.width)dp.dirtyLines[s]=true end;if dp.isLocked then if dp.isGraphics then for s=1,dp.size.height*9 do dp.graphicsBuffer[s]=dp.graphicsBuffer[s]..('\15'):rep((v-dp.size.width)*6)end;dp.graphicsBuffer.dirtyRects[#dp.graphicsBuffer.dirtyRects+1]={x=dp.size.width*6+1,y=1,width=(v-dp.size.width)*6,height=dp.size.height*9}else for s=1,dp.size.height do dp.textBuffer[s][1]=dp.textBuffer[s][1]..(' '):rep(v-dp.size.width)dp.textBuffer[s][2]=dp.textBuffer[s][2]..dp.textBuffer.colors.fg:rep(v-dp.size.width)dp.textBuffer[s][3]=dp.textBuffer[s][3]..dp.textBuffer.colors.bg:rep(v-dp.size.width)dp.textBuffer.dirtyLines[s]=true end end end elseif v<dp.size.width then for s=1,dp.size.height do dp[s][1]=dp[s][1]:sub(1,v)dp[s][2]=dp[s][2]:sub(1,v)dp[s][3]=dp[s][3]:sub(1,v)dp.dirtyLines[s]=true end;if dp.isLocked then if dp.isGraphics then for s=1,dp.size.height*9 do dp.graphicsBuffer[s]=dp.graphicsBuffer[s]:sub(1,v*6)end else for s=1,dp.size.height do dp.textBuffer[s][1]=dp.textBuffer[s][1]:sub(1,v)dp.textBuffer[s][2]=dp.textBuffer[s][2]:sub(1,v)dp.textBuffer[s][3]=dp.textBuffer[s][3]:sub(1,v)end end end end;dp.size.width=v;if dk>dp.size.height then for s=dp.size.height+1,dk do dp[s]={(' '):rep(v),dp.colors.fg:rep(v),dp.colors.bg:rep(v)}dp.dirtyLines[s]=true end;if dp.isLocked then if dp.isGraphics then for s=dp.size.height*9+1,dk*9 do dp.graphicsBuffer[s]=('\15'):rep(v*6)end;dp.graphicsBuffer.dirtyRects[#dp.graphicsBuffer.dirtyRects+1]={x=1,y=dp.size.height*9+1,width=dp.size.width*6,height=(dk-dp.size.height)*9}else for s=dp.size.height+1,dk do dp.textBuffer[s]={(' '):rep(v),dp.textBuffer.colors.fg:rep(v),dp.textBuffer.colors.bg:rep(v)}dp.textBuffer.dirtyLines[s]=true end end end elseif dk<dp.size.height then for s=dk+1,dp.size.height do dp[s]=nil;dp.dirtyLines[s]=nil end;if dp.isLocked then if dp.isGraphics then for s=dk*9+1,dp.size.height*9 do dp.graphicsBuffer[s]=nil end else for s=dk+1,dp.size.height do dp.textBuffer[s]=nil;dp.textBuffer.dirtyLines[s]=nil end end end end;dp.size.height=dk end;local function dq(dp)local dr=dp.cursor;local s=dr.y+1;dr.y=s;local U=dp.size;local dk=U.height;if s>dk then local ds=dp.dirtyLines;for x=1,dk-1 do dp[x]=dp[x+1]ds[x]=true end;local v=U.width;local dt=dp.colors;dp[dk]={(' '):rep(v),dt.fg:rep(v),dt.bg:rep(v)}ds[dk]=true;dr.y=dk end end;local du={['@']=function(dp,ay)local G=ay[1]or 1;if G==0 then G=1 end;local dv,dw=G%dp.size.width,math.floor(G/dp.size.width)local t={dp[dp.cursor.y][1]:sub(dp.size.width-dv+1),dp[dp.cursor.y][2]:sub(dp.size.width-dv+1),dp[dp.cursor.y][3]:sub(dp.size.width-dv+1)}dp[dp.cursor.y][1]=dp[dp.cursor.y][1]:sub(1,dp.cursor.x-1)..(" "):rep(G)..dp[dp.cursor.y+dw][1]:sub(dp.cursor.x,dp.size.width-dv)dp[dp.cursor.y][2]=dp[dp.cursor.y][2]:sub(1,dp.cursor.x-1)..dp.colors.fg:rep(G)..dp[dp.cursor.y+dw][2]:sub(dp.cursor.x,dp.size.width-dv)dp[dp.cursor.y][3]=dp[dp.cursor.y][3]:sub(1,dp.cursor.x-1)..dp.colors.bg:rep(G)..dp[dp.cursor.y+dw][3]:sub(dp.cursor.x,dp.size.width-dv)dp.dirtyLines[dp.cursor.y]=true;for s=dp.cursor.y+dw+1,dp.size.height do local dx={dp[s-dw][1]:sub(dp.size.width-G+1),dp[s-dw][2]:sub(dp.size.width-G+1),dp[s-dw][3]:sub(dp.size.width-G+1)}dp[s][1]=t[1]..dp[s-dw][1]:sub(1,dp.size.width-dv)dp[s][2]=t[2]..dp[s-dw][2]:sub(1,dp.size.width-dv)dp[s][3]=t[3]..dp[s-dw][3]:sub(1,dp.size.width-dv)dp.dirtyLines[s]=true;t=dx end;for s=dp.cursor.y+1,dp.cursor.y+dw do dp[s][1]=(" "):rep(dp.size.width)dp[s][2]=dp.colors.fg:rep(dp.size.width)dp[s][3]=dp.colors.bg:rep(dp.size.width)dp.dirtyLines[s]=true end end,A=function(dp,ay)local G=ay[1]or 1;if G==0 then G=1 end;dp.cursor.y=math.max(dp.cursor.y-G,1)end,B=function(dp,ay)local G=ay[1]or 1;if G==0 then G=1 end;dp.cursor.y=math.min(dp.cursor.y+G,dp.size.height)end,C=function(dp,ay)local G=ay[1]or 1;if G==0 then G=1 end;dp.cursor.y=dp.cursor.y+math.floor((dp.cursor.x-1+G)/dp.size.width)dp.cursor.x=(dp.cursor.x-1+G)%dp.size.width+1 end,D=function(dp,ay)local G=ay[1]or 1;if G==0 then G=1 end;dp.cursor.y=dp.cursor.y+math.floor((dp.cursor.x-1-G)/dp.size.width)dp.cursor.x=(dp.cursor.x-1-G)%dp.size.width+1 end,E=function(dp,ay)local G=ay[1]or 1;if G==0 then G=1 end;dp.cursor.y=math.min(dp.cursor.y+G,dp.size.height)dp.cursor.x=1 end,F=function(dp,ay)local G=ay[1]or 1;if G==0 then G=1 end;dp.cursor.y=math.max(dp.cursor.y-G,1)dp.cursor.x=1 end,G=function(dp,ay)local G=ay[1]or 1;if G==0 then G=1 end;dp.cursor.x=math.min(G,dp.size.width)end,H=function(dp,ay)local bu,ab=ay[1]or 1,ay[2]or 1;if bu==0 then bu=1 end;if ab==0 then ab=1 end;dp.cursor.x,dp.cursor.y=math.min(ab,dp.size.width),math.min(bu,dp.size.height)end,I=function(dp,ay)end,J=function(dp,ay)local t=ay[1]or 0;if t==0 then dp[dp.cursor.y][1]=dp[dp.cursor.y][1]:sub(1,dp.cursor.x-1)..(" "):rep(dp.size.width-dp.cursor.x)dp[dp.cursor.y][2]=dp[dp.cursor.y][2]:sub(1,dp.cursor.x-1)..dp.colors.fg:rep(dp.size.width-dp.cursor.x)dp[dp.cursor.y][3]=dp[dp.cursor.y][3]:sub(1,dp.cursor.x-1)..dp.colors.bg:rep(dp.size.width-dp.cursor.x)dp.dirtyLines[dp.cursor.y]=true;for s=dp.cursor.y+1,dp.size.height do dp[s][1]=(" "):rep(dp.size.width)dp[s][2]=dp.colors.fg:rep(dp.size.width)dp[s][3]=dp.colors.bg:rep(dp.size.width)dp.dirtyLines[s]=true end elseif t==1 then dp[dp.cursor.y][1]=(" "):rep(dp.cursor.x)..dp[dp.cursor.y][1]:sub(dp.cursor.x)dp[dp.cursor.y][2]=dp.colors.fg:rep(dp.cursor.x)..dp[dp.cursor.y][2]:sub(dp.cursor.x)dp[dp.cursor.y][3]=dp.colors.bg:rep(dp.cursor.x)..dp[dp.cursor.y][3]:sub(dp.cursor.x)dp.dirtyLines[dp.cursor.y]=true;for s=dp.cursor.y-1,1,-1 do dp[s][1]=(" "):rep(dp.size.width)dp[s][2]=dp.colors.fg:rep(dp.size.width)dp[s][3]=dp.colors.bg:rep(dp.size.width)dp.dirtyLines[s]=true end elseif t==2 then for s=1,dp.size.height do dp[s][1]=(" "):rep(dp.size.width)dp[s][2]=dp.colors.fg:rep(dp.size.width)dp[s][3]=dp.colors.bg:rep(dp.size.width)dp.dirtyLines[s]=true end end end,K=function(dp,ay)local t=ay[1]or 0;if t==0 then dp[dp.cursor.y][1]=dp[dp.cursor.y][1]:sub(1,dp.cursor.x-1)..(" "):rep(dp.size.width-dp.cursor.x)dp[dp.cursor.y][2]=dp[dp.cursor.y][2]:sub(1,dp.cursor.x-1)..dp.colors.fg:rep(dp.size.width-dp.cursor.x)dp[dp.cursor.y][3]=dp[dp.cursor.y][3]:sub(1,dp.cursor.x-1)..dp.colors.bg:rep(dp.size.width-dp.cursor.x)dp.dirtyLines[dp.cursor.y]=true elseif t==1 then dp[dp.cursor.y][1]=(" "):rep(dp.cursor.x)..dp[dp.cursor.y][1]:sub(dp.cursor.x)dp[dp.cursor.y][2]=dp.colors.fg:rep(dp.cursor.x)..dp[dp.cursor.y][2]:sub(dp.cursor.x)dp[dp.cursor.y][3]=dp.colors.bg:rep(dp.cursor.x)..dp[dp.cursor.y][3]:sub(dp.cursor.x)dp.dirtyLines[dp.cursor.y]=true elseif t==2 then dp[dp.cursor.y][1]=(" "):rep(dp.size.width)dp[dp.cursor.y][2]=dp.colors.fg:rep(dp.size.width)dp[dp.cursor.y][3]=dp.colors.bg:rep(dp.size.width)dp.dirtyLines[dp.cursor.y]=true end end,L=function(dp,ay)end,M=function(dp,ay)end,N=function(dp,ay)end,O=function(dp,ay)end,P=function(dp,ay)local G=ay[1]or 1;if G==0 then G=1 end;local dv,dw=G%dp.size.width,math.floor(G/dp.size.width)local t={(" "):rep(dv),dp.colors.fg:rep(dv),dp.colors.bg:rep(dv)}for s=dp.size.height-dw,dp.cursor.y+1,-1 do local dx={dp[s+dw][1]:sub(1,dv),dp[s+dw][2]:sub(1,dv),dp[s+dw][3]:sub(1,dv)}dp[s][1]=dp[s+dw][1]:sub(dv+1)..t[1]dp[s][2]=dp[s+dw][2]:sub(dv+1)..t[2]dp[s][3]=dp[s+dw][3]:sub(dv+1)..t[3]dp.dirtyLines[s]=true;t=dx end;for s=dp.size.height-dw+1,dp.size.height do dp[s][1]=(" "):rep(dp.size.width)dp[s][2]=dp.colors.fg:rep(dp.size.width)dp[s][3]=dp.colors.bg:rep(dp.size.width)dp.dirtyLines[s]=true end;dp[dp.cursor.y][1]=dp[dp.cursor.y][1]:sub(1,dp.cursor.x-1)..dp[dp.cursor.y+dw][1]:sub(dp.cursor.x+dv,dp.size.width)..t[1]dp[dp.cursor.y][2]=dp[dp.cursor.y][2]:sub(1,dp.cursor.x-1)..dp[dp.cursor.y+dw][2]:sub(dp.cursor.x+dv,dp.size.width)..t[2]dp[dp.cursor.y][3]=dp[dp.cursor.y][3]:sub(1,dp.cursor.x-1)..dp[dp.cursor.y+dw][3]:sub(dp.cursor.x+dv,dp.size.width)..t[3]dp.dirtyLines[dp.cursor.y]=true end,Q=function(dp,ay)end,R=function(dp,ay)end,S=function(dp,ay)local t=ay[1]or 0;if t==0 then t=1 end;for B=1,t do table.insert(dp,1,{(' '):rep(dp.size.width),dp.colors.fg:rep(dp.size.width),dp.colors.bg:rep(dp.size.width)})dp[dp.size.height+1]=nil end;for s=1,dp.size.height do dp.dirtyLines[s]=true end end,T=function(dp,ay)local t=ay[1]or 0;if t==0 then t=1 end;for B=1,t do table.remove(dp,1)dp[dp.size.height]={(' '):rep(dp.size.width),dp.colors.fg:rep(dp.size.width),dp.colors.bg:rep(dp.size.width)}end;for s=1,dp.size.height do dp.dirtyLines[s]=true end end,U=function(dp,ay)end,V=function(dp,ay)end,W=function(dp,ay)end,X=function(dp,ay)end,Y=function(dp,ay)end,Z=function(dp,ay)end,['[']=function(dp,ay)end,['\\']=function(dp,ay)end,[']']=function(dp,ay)end,['^']=function(dp,ay)end,['_']=function(dp,ay)end,['`']=function(dp,ay)end,a=function(dp,ay)end,b=function(dp,ay)end,c=function(dp,ay)end,d=function(dp,ay)end,e=function(dp,ay)end,f=function(dp,ay)end,g=function(dp,ay)end,h=function(dp,ay)if ay[1]==25 then dp.cursorBlink=true end end,i=function(dp,ay)end,j=function(dp,ay)end,k=function(dp,ay)end,l=function(dp,ay)if ay[1]==25 then dp.cursorBlink=false end end,m=function(dp,ay)local t,C=ay[1]or 0,ay[2]if t==0 then dp.colors.fg,dp.colors.bg,dp.colors.bold='0','f',false elseif t==1 then dp.colors.bold=true elseif t==7 or t==27 then dp.colors.fg,dp.colors.bg=dp.colors.bg,dp.colors.fg elseif t==22 then dp.colors.bold=false elseif t>=30 and t<=37 then dp.colors.fg=("%x"):format(15-(t-30)-(dp.colors.bold and 8 or 0))elseif t==39 then dp.colors.fg='0'elseif t>=40 and t<=47 then dp.colors.bg=("%x"):format(15-(t-40)-(dp.colors.bold and 8 or 0))elseif t==49 then dp.colors.bg='f'elseif t>=90 and t<=97 then dp.colors.fg=("%x"):format(15-(t-90)-8)elseif t>=100 and t<=107 then dp.colors.bg=("%x"):format(15-(t-100)-8)end;if C~=nil then if C==0 then dp.colors.fg,dp.colors.bg='0','f'elseif C==1 then dp.colors.bold=true elseif C==7 or C==27 then dp.colors.fg,dp.colors.bg=dp.colors.bg,dp.colors.fg elseif C==22 then dp.colors.bold=false elseif C>=30 and C<=37 then dp.colors.fg=("%x"):format(15-(C-30)-(dp.colors.bold and 8 or 0))elseif C==39 then dp.colors.fg='0'elseif C>=40 and C<=47 then dp.colors.bg=("%x"):format(15-(C-40)-(dp.colors.bold and 8 or 0))elseif C==49 then dp.colors.bg='f'elseif C>=90 and C<=97 then dp.colors.fg=("%x"):format(15-(C-90)-8)elseif C>=100 and C<=107 then dp.colors.bg=("%x"):format(15-(C-100)-8)end end end,n=function(dp,ay)end,o=function(dp,ay)end}for x=0x70,0x7F do du[string.char(x)]=function(dp,ay)end end;function terminal.write(dp,dy)if _HEADLESS and dp==TTY[1]then return term.write(dy)end;local aA,U=1,0;local function dz(r)if U==0 then aA,U=r,0;return end;while dp.cursor.x+U>dp.size.width do dp[dp.cursor.y][1]=dp[dp.cursor.y][1]:sub(1,dp.cursor.x-1)..dy:sub(aA,aA+dp.size.width-dp.cursor.x)dp[dp.cursor.y][2]=dp[dp.cursor.y][2]:sub(1,dp.cursor.x-1)..dp.colors.fg:rep(dp.size.width-dp.cursor.x+1)dp[dp.cursor.y][3]=dp[dp.cursor.y][3]:sub(1,dp.cursor.x-1)..dp.colors.bg:rep(dp.size.width-dp.cursor.x+1)dp.dirtyLines[dp.cursor.y]=true;aA=aA+dp.size.width-dp.cursor.x+1;U=U-(dp.size.width-dp.cursor.x+1)dp.cursor.x=1;dq(dp)end;dp[dp.cursor.y][1]=dp[dp.cursor.y][1]:sub(1,dp.cursor.x-1)..dy:sub(aA,aA+U-1)..dp[dp.cursor.y][1]:sub(dp.cursor.x+U)dp[dp.cursor.y][2]=dp[dp.cursor.y][2]:sub(1,dp.cursor.x-1)..dp.colors.fg:rep(U)..dp[dp.cursor.y][2]:sub(dp.cursor.x+U)dp[dp.cursor.y][3]=dp[dp.cursor.y][3]:sub(1,dp.cursor.x-1)..dp.colors.bg:rep(U)..dp[dp.cursor.y][3]:sub(dp.cursor.x+U)dp.dirtyLines[dp.cursor.y]=true;dp.cursor.x=dp.cursor.x+U;aA,U=r,0 end;local dA=0;local ay,dB;for r,ab,t in dy:gmatch"()(.)()"do if dA==0 then if ab=='\a'then dz(t)local dC=hardware.find("speaker")if dC then hardware.call(dC,"playNote","pling")end elseif ab=='\b'then dz(t)if dp.cursor.x==1 then if dp.cursor.y>1 then dp.cursor.x,dp.cursor.y=dp.size.width,dp.cursor.y-1 end else dp.cursor.x=dp.cursor.x-1 end elseif ab=='\t'then dz(t)dp.cursor.x=math.floor((dp.cursor.x-1)/8)*8+9;if dp.cursor.x>dp.size.width then dp.cursor.x=1;dq(dp)end elseif ab=='\n'then dz(t)dq(dp)if dp.flags.nlcr then dp.cursor.x=1 end elseif ab=='\f'then dz(t)dq(dp)elseif ab=='\r'then dz(t)dp.cursor.x=1 elseif ab=='\27'then dA=1 else U=U+1 end elseif dA==1 then if false then elseif ab=='['then dA=2;ay,dB={},0 elseif ab==']'then if dy:byte(t)==0x50 then dA=4;ay={}else dA=3;ay,dB={},0 end else dz(t)dA=0 end elseif dA==2 then if ab>='@'and ab<='\127'then dz(t)ay[#ay+1]=dB;du[ab](dp,ay)dA=0 elseif ab>='0'and ab<='?'then if ab<='9'then dB=dB*10+tonumber(ab)elseif ab==';'then ay[#ay+1],dB=dB,0 end else dz(t)dA=0 end elseif dA==3 then if ab=='\\'and dy:byte(r-1)=='\27'then dz(t)dA=0 end elseif dA==4 then if#ay==0 then ay[1]=tonumber(ab,16)or 0 elseif#ay==1 and not dB then dB=(tonumber(ab,16)or 0)*16 elseif#ay==1 then ay[2],dB=dB+(tonumber(ab,16)or 0),nil elseif#ay==2 and not dB then dB=(tonumber(ab,16)or 0)*16 elseif#ay==2 then ay[3],dB=dB+(tonumber(ab,16)or 0),nil elseif#ay==3 and not dB then dB=(tonumber(ab,16)or 0)*16 elseif#ay==3 then dz(t)ay[4],dB=dB+(tonumber(ab,16)or 0),nil;dp.palette[ay[1]]={ay[2]/255,ay[3]/255,ay[4]/255}dp.dirtyPalette[ay[1]]=true;dA=0 end end end;dz()end;function syscalls.write(process,at,...)if not process.stdout then return end;local function dD(A)if process.stdout.isTTY then terminal.write(process.stdout,A)else process.stdout.write(A)end end;local args=table.pack(...)for x=1,args.n do if x>1 then dD("\t")end;dD(tostring(args[x]))end;if process.stdout.isTTY then terminal.redraw(process.stdout)end end;function syscalls.writeerr(process,at,...)if not process.stderr then return end;local function dD(A)if process.stderr.isTTY then terminal.write(process.stderr,A)else process.stderr.write(A)end end;local args=table.pack(...)for x=1,args.n do if x>1 then dD("\t")end;dD(tostring(args[x]))end;if process.stderr.isTTY then terminal.redraw(process.stderr)end end;function syscalls.read(process,at,t)expect(1,t,"number")if process.stdin then if process.stdin.eof then process.stdin.eof=false;return nil end;while#process.stdin.buffer<t do if process.stdin.eof then process.stdin.eof=false;return nil end;if process.stdin.isTTY and not process.stdin.flags.delay then return nil end;if process.stdin.read then local bt=process.stdin.read(t-#process.stdin.buffer)if not bt then return nil end;process.stdin.buffer=process.stdin.buffer..bt else return kSyscallYield,"read",t end end;local bt=process.stdin.buffer:sub(1,t-1)process.stdin.buffer=process.stdin.buffer:sub(t)return bt else return nil end end;function syscalls.readline(process,at)if process.stdin then if process.stdin.eof then process.stdin.eof=false;return nil end;while not process.stdin.buffer:find("\n")do if process.stdin.eof then process.stdin.eof=false;return nil end;if process.stdin.isTTY and not process.stdin.flags.delay then return nil end;if process.stdin.read then local bt=process.stdin.read()if not bt then return nil end;process.stdin.buffer=process.stdin.buffer..bt else return kSyscallYield,"readline"end end;local t=process.stdin.buffer:find("\n")local bt=process.stdin.buffer:sub(1,t-1)process.stdin.buffer=process.stdin.buffer:sub(t+1)return bt else return nil end end;function syscalls.termctl(process,at,dE)expect(1,dE,"table","nil")if not process.stdout or not process.stdout.isTTY then return nil end;if dE then expect.field(dE,"cbreak","boolean","nil")expect.field(dE,"delay","boolean","nil")expect.field(dE,"echo","boolean","nil")expect.field(dE,"keypad","boolean","nil")expect.field(dE,"nlcr","boolean","nil")expect.field(dE,"raw","boolean","nil")for j,k in pairs(dE)do if process.stdout.flags[j]~=nil then process.stdout.flags[j]=k end end end;local A=deepcopy(process.stdout.flags)A.hasgfx=term.getGraphicsMode~=nil;return A end;function terminal.openterm(dp,process)if dp.isLocked then if not dp.isGraphics and dp.frontmostProcess==process then return dp.screenHandle end;return nil,"Terminal already in use"end;local U=dp.size;local d4={cursor={x=1,y=1},cursorBlink=false,colors={fg='0',bg='f'},palette={},dirtyLines={},dirtyPalette={}}dp.textBuffer=d4;dp.isLocked=true;dp.isGraphics=false;for s=1,U.height do d4[s]={(' '):rep(U.width),('0'):rep(U.width),('f'):rep(U.width)}d4.dirtyLines[s]=true end;for x=0,15 do d4.palette[x]={term.nativePaletteColor(2^x)}d4.dirtyPalette[x]=true end;dp.processList[#dp.processList+1]=dp.frontmostProcess;dp.frontmostProcess=process;local dF=setmetatable({},{__name="Terminal"})local dG=terminal.redraw;local expect=expect;dp.screenHandle=dF;function dF.close()if not dF then error("terminal is already closed",2)end;dF=nil;dp.isLocked=false;dp.frontmostProcess=table.remove(dp.processList)dp.screenHandle=nil;dG(dp,true)end;function dF.write(dy)if not dF then error("terminal is already closed",2)end;dy=tostring(dy)expect(1,dy,"string")if d4.cursor.y<1 or d4.cursor.y>U.height then return elseif d4.cursor.x>U.width or d4.cursor.x+#dy<1 then d4.cursor.x=d4.cursor.x+#dy;return elseif d4.cursor.x<1 then dy=dy:sub(-d4.cursor.x+2)d4.cursor.x=1 end;local dH=#dy;if d4.cursor.x+#dy>U.width then dy=dy:sub(1,U.width-d4.cursor.x+1)end;d4[d4.cursor.y][1]=d4[d4.cursor.y][1]:sub(1,d4.cursor.x-1)..dy..d4[d4.cursor.y][1]:sub(d4.cursor.x+#dy)d4[d4.cursor.y][2]=d4[d4.cursor.y][2]:sub(1,d4.cursor.x-1)..d4.colors.fg:rep(#dy)..d4[d4.cursor.y][2]:sub(d4.cursor.x+#dy)d4[d4.cursor.y][3]=d4[d4.cursor.y][3]:sub(1,d4.cursor.x-1)..d4.colors.bg:rep(#dy)..d4[d4.cursor.y][3]:sub(d4.cursor.x+#dy)d4.cursor.x=d4.cursor.x+dH;d4.dirtyLines[d4.cursor.y]=true end;function dF.blit(dy,dI,dJ)if not dF then error("terminal is already closed",2)end;dy=tostring(dy)expect(1,dy,"string")expect(2,dI,"string")expect(3,dJ,"string")if#dy~=#dI or#dI~=#dJ then error("Arguments must be the same length",2)end;if d4.cursor.y<1 or d4.cursor.y>U.height then return elseif d4.cursor.x>U.width or d4.cursor.x<1-#dy then d4.cursor.x=d4.cursor.x+#dy;dG(dp)return elseif d4.cursor.x<1 then dy,dI,dJ=dy:sub(-d4.cursor.x+2),dI:sub(-d4.cursor.x+2),dJ:sub(-d4.cursor.x+2)d4.cursor.x=1 end;local dH=#dy;if d4.cursor.x+#dy>U.width then dy,dI,dJ=dy:sub(1,U.width-d4.cursor.x+1),dI:sub(1,U.width-d4.cursor.x+1),dJ:sub(1,U.width-d4.cursor.x+1)end;d4[d4.cursor.y][1]=d4[d4.cursor.y][1]:sub(1,d4.cursor.x-1)..dy..d4[d4.cursor.y][1]:sub(d4.cursor.x+#dy)d4[d4.cursor.y][2]=d4[d4.cursor.y][2]:sub(1,d4.cursor.x-1)..dI..d4[d4.cursor.y][2]:sub(d4.cursor.x+#dI)d4[d4.cursor.y][3]=d4[d4.cursor.y][3]:sub(1,d4.cursor.x-1)..dJ..d4[d4.cursor.y][3]:sub(d4.cursor.x+#dJ)d4.cursor.x=d4.cursor.x+dH;d4.dirtyLines[d4.cursor.y]=true end;function dF.clear()if not dF then error("terminal is already closed",2)end;for s=1,U.height do d4[s]={(' '):rep(U.width),d4.colors.fg:rep(U.width),d4.colors.bg:rep(U.width)}d4.dirtyLines[s]=true end end;function dF.clearLine()if not dF then error("terminal is already closed",2)end;if d4.cursor.y>=1 and d4.cursor.y<=U.height then d4[d4.cursor.y]={(' '):rep(U.width),d4.colors.fg:rep(U.width),d4.colors.bg:rep(U.width)}d4.dirtyLines[d4.cursor.y]=true end end;function dF.getCursorPos()if not dF then error("terminal is already closed",2)end;return d4.cursor.x,d4.cursor.y end;function dF.setCursorPos(dK,dL)if not dF then error("terminal is already closed",2)end;expect(1,dK,"number")expect(2,dL,"number")if dK==d4.cursor.x and dL==d4.cursor.y then return end;d4.cursor.x,d4.cursor.y=math.floor(dK),math.floor(dL)end;function dF.getCursorBlink()if not dF then error("terminal is already closed",2)end;return d4.cursorBlink end;function dF.setCursorBlink(ad)if not dF then error("terminal is already closed",2)end;expect(1,ad,"boolean")d4.cursorBlink=ad end;function dF.isColor()if not dF then error("terminal is already closed",2)end;return true end;function dF.getSize()if not dF then error("terminal is already closed",2)end;return U.width,U.height end;function dF.scroll(dM)if not dF then error("terminal is already closed",2)end;expect(1,dM,"number")if math.abs(dM)>=U.width then for s=1,U.height do d4[s]={(' '):rep(U.width),d4.colors.fg:rep(U.width),d4.colors.bg:rep(U.width)}end elseif dM>0 then for x=dM+1,U.height do d4[x]=d4[x-dM]end;for x=U.height-dM+1,U.height do d4[x]={(' '):rep(U.width),d4.colors.fg:rep(U.width),d4.colors.bg:rep(U.width)}end elseif dM<0 then for x=1,U.height+dM do d4[x-dM]=d4[x]end;for x=1,-dM do d4[x]={(' '):rep(U.width),d4.colors.fg:rep(U.width),d4.colors.bg:rep(U.width)}end else return end;for x=1,U.height do d4.dirtyLines[x]=true end end;function dF.getTextColor()if not dF then error("terminal is already closed",2)end;return tonumber(d4.colors.fg,16)end;function dF.setTextColor(dN)if not dF then error("terminal is already closed",2)end;expect(1,dN,"number")expect.range(dN,0,15)d4.colors.fg=("%x"):format(dN)end;function dF.getBackgroundColor()if not dF then error("terminal is already closed",2)end;return tonumber(d4.colors.bg,16)end;function dF.setBackgroundColor(dN)if not dF then error("terminal is already closed",2)end;expect(1,dN,"number")expect.range(dN,0,15)d4.colors.bg=("%x"):format(dN)end;function dF.getPaletteColor(dN)if not dF then error("terminal is already closed",2)end;expect(1,dN,"number")expect.range(dN,0,15)return table.unpack(d4.palette[math.floor(dN)])end;function dF.setPaletteColor(dN,bu,dO,ad)if not dF then error("terminal is already closed",2)end;expect(1,dN,"number")expect(2,bu,"number")if dO==nil and ad==nil then bu,dO,ad=bit32.band(bit32.rshift(bu,16),0xFF)/255,bit32.band(bit32.rshift(bu,8),0xFF)/255,bit32.band(bu,0xFF)/255 end;expect(3,dO,"number")expect(4,ad,"number")expect.range(dN,0,15)if bu<0 or bu>1 then error("bad argument #2 (value out of range)",2)end;if dO<0 or dO>1 then error("bad argument #3 (value out of range)",2)end;if ad<0 or ad>1 then error("bad argument #4 (value out of range)",2)end;d4.palette[math.floor(dN)]={bu,dO,ad}d4.dirtyPalette[math.floor(dN)]=true end;function dF.getLine(s)if not dF then error("terminal is already closed",2)end;expect(1,s,"number")local P=d4[s]if P then return table.unpack(P,1,3)end end;local dP=term.nativePaletteColor;function dF.nativePaletteColor(dN)expect(1,dN,"number")expect.range(dN,0,15)return dP(2^dN)end;for B,k in pairs(dF)do setfenv(k,process.env)debug.protect(k)end;dF.isColour=dF.isColor;dF.getTextColour=dF.getTextColor;dF.setTextColour=dF.setTextColor;dF.getBackgroundColour=dF.getBackgroundColor;dF.setBackgroundColour=dF.setBackgroundColor;dF.getPaletteColour=dF.getPaletteColor;dF.setPaletteColour=dF.setPaletteColor;dF.nativePaletteColour=dF.nativePaletteColor;process.dependents[#process.dependents+1]={gc=function()if dF then return dF.close()end end}dG(dp,true)return dF end;function syscalls.openterm(process,at)if not process.stdout or not process.stdout.isTTY then return nil,"No valid TTY attached"end;if process~=process.stdout.frontmostProcess then syscalls.kill(KERNEL,nil,process.id,22)if process.paused then return kSyscallYield,"openterm"end end;return terminal.openterm(process.stdout,process)end;function terminal.opengfx(dp,process)if not term.drawPixels then return nil,"Graphics mode not supported"end;if dp.isLocked then if dp.isGraphics and dp.frontmostProcess==process then return dp.screenHandle end;return nil,"Terminal already in use"end;local U=dp.size;local d4={palette={},dirtyRects={},dirtyPalette={},frozen=false}dp.graphicsBuffer=d4;dp.isLocked=true;dp.isGraphics=true;for s=1,U.height*9 do d4[s]=('\15'):rep(U.width*6)end;for x=0,15 do d4.palette[x]={term.nativePaletteColor(2^x)}d4.dirtyPalette[x]=true end;for x=16,255 do d4.palette[x]={0,0,0}d4.dirtyPalette[x]=true end;dp.processList[#dp.processList+1]=dp.frontmostProcess;dp.frontmostProcess=process;local dF=setmetatable({},{__name="GFXTerminal"})local dG=terminal.redraw;local expect=expect;dp.screenHandle=dF;function dF.close()if not dF then error("terminal is already closed",2)end;dF=nil;dp.isLocked=false;dp.frontmostProcess=table.remove(dp.processList)dp.screenHandle=nil;dG(dp,true)end;function dF.getSize()return U.width*6,U.height*9 end;function dF.clear()if not dF then error("terminal is already closed",2)end;for s=1,U.height*9 do d4[s]=('\15'):rep(U.width*6)end;dG(dp,true)end;function dF.getPixel(r,s)if not dF then error("terminal is already closed",2)end;expect(1,r,"number")expect(2,s,"number")expect.range(r,0,U.width*6-1)expect.range(s,0,U.height*9-1)r,s=math.floor(r),math.floor(s)return d4[s+1]:byte(r+1)end;function dF.setPixel(r,s,dN)if not dF then error("terminal is already closed",2)end;expect(1,r,"number")expect(2,s,"number")expect(3,dN,"number")expect.range(r,0,U.width*6-1)expect.range(s,0,U.height*9-1)expect.range(dN,0,255)r,s=math.floor(r),math.floor(s)d4[s+1]=d4[s+1]:sub(1,r)..string.char(dN)..d4[s+1]:sub(r+2)d4.dirtyRects[#d4.dirtyRects+1]={x=r,y=s,color=dN}end;function dF.getPixels(r,s,v,dk,dQ)if not dF then error("terminal is already closed",2)end;expect(1,r,"number")expect(2,s,"number")expect(3,v,"number")expect(4,dk,"number")expect(5,dQ,"boolean","nil")expect.range(v,0)expect.range(dk,0)r,s=math.floor(r),math.floor(s)local A={}for dR=1,dk do if dQ then A[dR]=d4[s+dR]:sub(r+1,r+v)else A[dR]={d4[s+dR]:sub(r+1,r+v):byte(1,-1)}end end;return A end;function dF.drawPixels(r,s,bk,v,dk)if not dF then error("terminal is already closed",2)end;expect(1,r,"number")expect(2,s,"number")expect(3,bk,"table","number")local dS=type(bk)=="number"expect(4,v,"number",not dS and"nil"or nil)expect(5,dk,"number",not dS and"nil"or nil)expect.range(r,0,U.width*6-1)expect.range(s,0,U.height*9-1)if v then expect.range(v,0)end;if dk then expect.range(dk,0)end;if dS then expect.range(bk,0,255)end;if v==0 or dk==0 then return end;r,s=math.floor(r),math.floor(s)if v and r+v>=U.width*6 then v=U.width*6-r end;dk=dk or#bk;local dT={x=r,y=s,width=v,height=dk}for dR=1,dk do if s+dR>U.height*9 then break end;if dS then local bt=string.char(bk):rep(v)d4[s+dR]=d4[s+dR]:sub(1,r)..bt..d4[s+dR]:sub(r+v+1)dT[dR]=bt elseif bk[dR]~=nil then if type(bk[dR])~="table"and type(bk[dR])~="string"then error("bad argument #3 to 'drawPixels' (invalid row "..dR..")",2)end;local v=v or#bk[dR]if r+v>=U.width*6 then v=U.width*6-r end;local bt;if type(bk[dR])=="string"then bt=bk[dR]if#bt<v then bt=bt..('\15'):rep(v-#bt)elseif#bt>v then bt=bt:sub(1,v)end else bt=""for dU=1,v do bt=bt..string.char(bk[dR][dU]or d4[s+dR]:byte(r+dU))end end;d4[s+dR]=d4[s+dR]:sub(1,r)..bt..d4[s+dR]:sub(r+v+1)dT[dR]=bt end end;d4.dirtyRects[#d4.dirtyRects+1]=dT end;function dF.getFrozen()if not dF then error("terminal is already closed",2)end;return d4.frozen end;function dF.setFrozen(f)if not dF then error("terminal is already closed",2)end;expect(1,f,"boolean")d4.frozen=f end;function dF.getPaletteColor(dN)if not dF then error("terminal is already closed",2)end;expect(1,dN,"number")expect.range(dN,0,255)return table.unpack(d4.palette[dN])end;function dF.setPaletteColor(dN,bu,dO,ad)if not dF then error("terminal is already closed",2)end;expect(1,dN,"number")expect(2,bu,"number")if dO==nil and ad==nil then bu,dO,ad=bit32.band(bit32.rshift(bu,16),0xFF)/255,bit32.band(bit32.rshift(bu,8),0xFF)/255,bit32.band(bu,0xFF)/255 end;expect(3,dO,"number")expect(4,ad,"number")expect.range(bu,0,1)expect.range(dO,0,1)expect.range(ad,0,1)expect.range(dN,0,255)d4.palette[dN]={bu,dO,ad}d4.dirtyPalette[dN]=true end;local dP=term.nativePaletteColor;function dF.nativePaletteColor(dN)expect(1,dN,"number")expect.range(dN,0,15)return dP(2^dN)end;for B,k in pairs(dF)do setfenv(k,process.env)debug.protect(k)end;dF.getPaletteColour=dF.getPaletteColor;dF.setPaletteColour=dF.setPaletteColor;dF.nativePaletteColour=dF.nativePaletteColor;process.dependents[#process.dependents+1]={gc=function()if dF then return dF.close()end end}dG(dp,true)return dF end;function syscalls.opengfx(process,at)if not process.stdout or not process.stdout.isTTY then return nil,"No valid TTY attached"end;if process~=process.stdout.frontmostProcess then syscalls.kill(KERNEL,nil,process.id,22)if process.paused then return kSyscallYield,"openterm"end end;return terminal.opengfx(process.stdout,process)end;function syscalls.mktty(process,at,v,dk)expect(1,v,"number")expect(2,dk,"number")expect.range(v,1)expect.range(dk,1)local dp=terminal.makeTTY(term,v,dk)dp.id=math.random(0,0x7FFFFFFF)dp.process=process;local aE={__index=dp,__metatable={__name="TTY"}}local a7=setmetatable({},aE)local do_syscall=do_syscall;function a7.sendEvent(cd,d1)return do_syscall("__ttyevent",a7,cd,d1)end;function a7.write(dy)return do_syscall("__ttyevent",a7,"paste",tostring(dy))end;debug.protect(a7.sendEvent)debug.protect(a7.write)aE.__newindex=function()error("cannot modify TTY",2)end;terminal.userTTYs[a7]=dp;process.dependents[#process.dependents+1]={gc=function()terminal.userTTYs[a7]=nil end}return a7 end;function syscalls.__ttyevent(process,at,dV,cd,d1)expect(1,dV,"table")expect(2,cd,"string")expect(3,d1,"table")local dp=terminal.userTTYs[dV]if not dp then error("Invalid TTY")end;if dp.process~=process then error("Invalid TTY")end;if not dp.frontmostProcess then return end;if cd=="key"then expect.field(d1,"keycode","number")expect.field(d1,"isRepeat","boolean")dp.frontmostProcess.eventQueue[#dp.frontmostProcess.eventQueue+1]={"key",{keycode=d1.keycode,isRepeat=d1.isRepeat,ctrlHeld=keysHeld.ctrl,altHeld=keysHeld.alt,shiftHeld=keysHeld.shift}}if not dp.isLocked then if d1.keycode==10 then if dp.flags.cbreak then dp.buffer=dp.buffer.."\n"else dp.buffer=dp.buffer..dp.preBuffer.."\n"dp.preBuffer=""end;if dp.flags.echo then terminal.write(dp,"\n")terminal.redraw(dp)end elseif d1.keycode==8 then if dp.flags.cbreak then elseif#dp.preBuffer>0 then dp.preBuffer=dp.preBuffer:sub(1,-2)if dp.flags.echo then terminal.write(dp,"\b \b")terminal.redraw(dp)end end end end elseif cd=="key_up"then expect.field(d1,"keycode","number")dp.frontmostProcess.eventQueue[#dp.frontmostProcess.eventQueue+1]={"key_up",{keycode=d1.keycode,ctrlHeld=keysHeld.ctrl,altHeld=keysHeld.alt,shiftHeld=keysHeld.shift}}elseif cd=="char"then expect.field(d1,"character","string")dp.frontmostProcess.eventQueue[#dp.frontmostProcess.eventQueue+1]={"char",{character=d1.character}}if not dp.isLocked then if dp.flags.cbreak then dp.buffer=dp.buffer..d1.character else dp.preBuffer=dp.preBuffer..d1.character end;if dp.flags.echo then terminal.write(dp,d1.character)terminal.redraw(dp)end end elseif cd=="paste"then expect.field(d1,"text","string")dp.frontmostProcess.eventQueue[#dp.frontmostProcess.eventQueue+1]={"paste",{text=d1.text}}if not dp.isLocked then if dp.flags.cbreak then dp.buffer=dp.buffer..d1.text else dp.preBuffer=dp.preBuffer..d1.text end;if dp.flags.echo then terminal.write(dp,d1.text)terminal.redraw(dp)end end elseif cd=="mouse_click"or cd=="mouse_up"or cd=="mouse_drag"then expect.field(d1,"x","number")expect.field(d1,"y","number")expect.field(d1,"button","number")dp.frontmostProcess.eventQueue[#dp.frontmostProcess.eventQueue+1]={cd,{x=d1.x,y=d1.y,button=d1.button,buttonMask=0}}elseif cd=="mouse_scroll"then expect.field(d1,"x","number")expect.field(d1,"y","number")expect.field(d1,"direction","number")dp.frontmostProcess.eventQueue[#dp.frontmostProcess.eventQueue+1]={cd,{x=d1.x,y=d1.y,button=d1.direction}}else error("Invalid event")end;wakeup(dp.frontmostProcess)end;function syscalls.capture(process,at)local bo=process.stdin;if not bo or not bo.isTTY then return end;bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process end;function syscalls.release(process,at)local bo=process.stdin;if not bo or not bo.isTTY then return end;if bo.frontmostProcess==process then bo.frontmostProcess=table.remove(bo.processList)else local dW=nil;for x=#bo.processList,1,-1 do if bo.processList[x]==process then if dW then table.remove(bo.processList,dW)break else dW=x end end end end end;function syscalls.stdin(process,at,bo)expect(1,bo,"number","table","string","nil")if process.stdin and process.stdin.isTTY and process.stdin.frontmostProcess==process then process.stdin.preBuffer=""end;if type(bo)=="number"then bo=TTY[bo]if bo and process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process;if discord and process.stdin==currentTTY then discord("Phoenix","Executing "..process.name)end end;process.stdin=bo elseif type(bo)=="string"then local dX=hardware.get(bo)if not dX then error("bad argument #1 (no such device)",2)end;if not dX.internalState.tty then error("bad argument #1 (no TTY available on device)",2)end;bo=dX.internalState.tty;if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process end;process.stdin=bo elseif bo==nil then if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)end;process.stdin=nil else if bo.isTTY then bo=terminal.userTTYs[bo]if not bo then error("bad argument #1 (invalid TTY)",2)end;if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process;bo.preBuffer=""end else expect.field(bo,"read","function")local bn=bo.read;bo={buffer="",read=function(...)local bh,w=userModeCallback(process,bn,...)if bh then return w else error(w,2)end end}end;process.stdin=bo end end;function syscalls.stdout(process,at,bo)expect(1,bo,"number","table","string","nil")if process.stdout and process.stdout.isTTY and process.stdout.frontmostProcess==process then if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.stdout.frontmostProcess.name)end end;if type(bo)=="number"then bo=TTY[bo]if bo and process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process;if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.name)end end;process.stdout=bo elseif type(bo)=="string"then local dX=hardware.get(bo)if not dX then error("bad argument #1 (no such device)",2)end;if not dX.internalState.tty then error("bad argument #1 (no TTY available on device)",2)end;bo=dX.internalState.tty;if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process;if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.name)end end;process.stdout=bo elseif bo==nil then if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.name)end end;process.stdout=nil else if bo.isTTY then bo=terminal.userTTYs[bo]if not bo then error("bad argument #1 (invalid TTY)",2)end;if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process;if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.name)end end else expect.field(bo,"write","function")local dD=bo.write;bo={write=function(...)local bh,w=userModeCallback(process,dD,...)if bh then return w else error(w,2)end end}end;process.stdout=bo end end;function syscalls.stderr(process,at,bo)expect(1,bo,"number","table","string","nil")if process.stderr and process.stderr.isTTY and process.stderr.frontmostProcess==process then end;if type(bo)=="number"then bo=TTY[bo]if bo and process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process;if discord and process.stderr==currentTTY then discord("Phoenix","Executing "..process.name)end end;process.stderr=bo elseif type(bo)=="string"then local dX=hardware.get(bo)if not dX then error("bad argument #1 (no such device)",2)end;if not dX.internalState.tty then error("bad argument #1 (no TTY available on device)",2)end;bo=dX.internalState.tty;if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process end;process.stderr=bo elseif bo==nil then if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)end;process.stderr=nil else if bo.isTTY then bo=terminal.userTTYs[bo]if not bo then error("bad argument #1 (invalid TTY)",2)end;if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process end else expect.field(bo,"write","function")local dD=bo.write;bo={write=function(...)local bh,w=userModeCallback(process,dD,...)if bh then return w else error(w,2)end end}end;process.stderr=bo end end;function syscalls.istty(process,at)return process.stdin and process.stdin.isTTY,process.stdout and process.stdout.isTTY end;function syscalls.termsize(process,at)if not process.stdout or not process.stdout.isTTY then return nil,nil end;return process.stdout.size.width,process.stdout.size.height end;syslogs={default={stream={},tty=KERNEL.stdout,tty_level=args.loglevel,colorize=true}}local dY={[0]="Debug","Info","Notice","Warning","Error","Critical","Panic"}local dZ={}for x=0,#dY do dZ[dY[x]:lower()]=x end;local d_={[0]='\27[90m','\27[97m','\27[36m','\27[93m','\27[31m','\27[95m','\27[96m'}local function e0(A,ao,x,ac)if x>=ac then return tostring(A[x])else return tostring(A[x])..ao..e0(A,ao,x+1,ac)end end;function syscalls.syslog(process,at,bK,...)local args=table.pack(...)if type(bK)=="table"then expect.field(bK,"name","string","nil")expect.field(bK,"category","string","nil")expect.field(bK,"level","number","string","nil")expect.field(bK,"time","number","nil")expect.field(bK,"process","number","nil")expect.field(bK,"thread","number","nil")expect.field(bK,"module","string","nil")expect.field(bK,"traceback","boolean","nil")if type(bK.level)=="string"then bK.level=dZ[bK.level:lower()]if not bK.level then error("bad field 'level' (invalid name)",0)end elseif bK.level and(bK.level<0 or bK.level>#dY)then error("bad field 'level' (level out of range)",0)end;bK.name=bK.name or"default"bK.process=bK.process or process.id;bK.thread=bK.thread or at and at.id;bK.level=bK.level or 1;bK.time=bK.time or os.epoch"utc"else local t=args.n;table.insert(args,1,bK)args.n=t+1;bK={process=process.id,thread=at and at.id,level=1,name="default",time=os.epoch"utc"}end;local e1=syslogs[bK.name]if e1==nil then error("No such log named "..bK.name,0)end;local ag;for x=1,args.n do ag=(x==1 and""or ag.." ")..serialize(args[x])end;if e1.file then e1.file.write(("[%s]%s %s[%d%s]%s [%s]: %s\n"):format(os.date("%b %d %X",bK.time/1000),bK.category and" <"..bK.category..">"or"",processes[bK.process]and processes[bK.process].name or"(unknown)",bK.process,bK.thread and":"..bK.thread or"",bK.module and" ("..bK.module..")"or"",dY[bK.level],e0(args," ",1,args.n)))e1.file.flush()end;if e1.stream then bK.message=ag;for B,k in pairs(e1.stream)do local bh=true;if k.filter then local o,e2,aG=""local x=1;local e3,e4=false,false;while x<#k.filter do if e2==nil then o,x=k.filter:match("(%a+)%s*()",x)if bK[o]==nil then bh=false;break end;e2=""elseif aG==nil then local b7=k.filter:sub(x,x+1)if b7=="=="or b7=="!="or b7=="=%"or b7=="!%"or b7=="<="or b7==">="then e2=b7 elseif b7=="~="then e2="!="elseif b7=="~%"then e2="!%"elseif k.filter:sub(x,x)=='<'or k.filter:sub(x,x)=='>'then e2=k.filter:sub(x,x)else bh=false;break end;aG=""else local ab=k.filter:sub(x,x)if e3 then if ab==e3 and not e4 then e3,e4=false,false else aG=aG..ab;if not e4 and ab=='\\'then e4=true else e4=false end end elseif ab=='"'or ab=="'"then e3=ab elseif ab=='|'or ab==';'then if e2=="=="and bK[o]==aG or e2=="!="and bK[o]~=aG or e2=="=%"and bK[o]:match(aG)or e2=="!%"and not bK[o]:match(aG)or e2=="<"and(tonumber(bK[o])or 0)<(tonumber(aG)or 0)or e2=="<="and(tonumber(bK[o])or 0)<=(tonumber(aG)or 0)or e2==">="and(tonumber(bK[o])or 0)>=(tonumber(aG)or 0)or e2==">"and(tonumber(bK[o])or 0)>(tonumber(aG)or 0)then if ab=='|'then x=k.filter:match("[^;]*;+()",x)if x==nil then break end;x=x-1 end;o,e2,aG=""e3,e4=false,false else bh=ab=='|'aG=""if not bh then break end end elseif not(ab==' 'and aG=="")then aG=aG..ab end;x=x+1 end end;if e3 then bh=false;break end end;if bh then local process=processes[k.pid]if process then process.eventQueue[#process.eventQueue+1]={"syslog",deepcopy(bK)}end end end end;if e1.tty and e1.tty_level<=bK.level then if e1.tty.isTTY then local a2=e0(args," ",1,args.n)if e1.colorize and bK.traceback then a2=a2:gsub("\t","  "):gsub("([^\n]+):(%d+):","\27[96m%1\27[37m:\27[95m%2\27[37m:"):gsub("'([^']+)'\n","\27[93m'%1'\27[37m\n")end;terminal.write(e1.tty,("%s[%s]%s %s[%d%s]%s [%s]: %s%s\n"):format(e1.colorize and d_[bK.level]or"",os.date("%b %d %X",bK.time/1000),bK.category and" <"..bK.category..">"or"",processes[bK.process]and processes[bK.process].name or"(unknown)",bK.process,bK.thread and":"..bK.thread or"",bK.module and" ("..bK.module..")"or"",dY[bK.level],a2,e1.colorize and"\27[0m"or""))terminal.redraw(e1.tty)else end end end;function syscalls.mklog(process,at,o,e5,g)expect(1,o,"string")expect(2,e5,"boolean","nil")expect(3,g,"string","nil")if syslogs[o]then return end;syslogs[o]={}if g then local q;syslogs[o].file,q=filesystem.open(process,g,"a")if syslogs[o].file==nil then syslogs[o]=nil;return error("Could not open log file: "..q,0)end end;if e5 then syslogs[o].stream={}end end;function syscalls.rmlog(process,at,o)expect(1,o,"string")if o=="default"then error("Cannot delete default log",0)end;if not syslogs[o]then error("Log does not exist",0)end;if syslogs[o].stream then for B,k in pairs(syslogs[o].stream)do processes[k.pid].eventQueue[#processes[k.pid].eventQueue+1]={"syslog_close",{id=k.id}}processes[k.pid].dependents[k.id]=nil;wakeup(processes[k.pid])end end;syslogs[o]=nil end;function syscalls.openlog(process,at,o,e6)expect(1,o,"string")expect(2,e6,"string","nil")if not syslogs[o]then error("Log does not exist",0)end;if not syslogs[o].stream then error("Log does not have streaming enabled",0)end;local aD=#process.dependents+1;local cZ=process.id;process.dependents[aD]={type="log",name=o,filter=e6,gc=function()for x,k in pairs(syslogs[o].stream)do if k.id==aD and k.pid==cZ then syslogs[o].stream[x]=nil end end end}syslogs[o].stream[#syslogs[o].stream+1]={pid=cZ,id=aD,filter=e6}return aD end;function syscalls.closelog(process,at,o)expect(1,o,"string","number")if type(o)=="string"then if not syslogs[o]then error("Log does not exist",0)end;if not syslogs[o].stream then error("Log does not have streaming enabled",0)end;for x,k in pairs(syslogs[o].stream)do if k.pid==process.id then process.dependents[k.id]=nil;syslogs[o].stream[x]=nil end end else if not process.dependents[o]then error("Log connection does not exist",0)end;local e1=syslogs[process.dependents[o].name].stream;for x,k in pairs(e1)do if k.pid==process.id and k.id==o then process.dependents[k.id]=nil;e1[x]=nil;break end end end end;function syscalls.logtty(process,at,o,dp,b3)if process.user~="root"then error("Permission denied",0)end;expect(1,o,"string")expect(2,dp,"table","number","nil")expect(3,b3,"number","nil")if not syslogs[o]then error("Log does not exist",0)end;syslogs[o].tty=type(dp)=="table"and dp or TTY[dp]syslogs[o].tty_level=b3;return true end;function syslog.log(bK,...)return pcall(syscalls.syslog,KERNEL,nil,bK,...)end;function syslog.debug(...)return pcall(syscalls.syslog,KERNEL,nil,{level="debug",process=0},...)end;local e7=panic;function panic(ag)xpcall(function()TTY[1].isLocked=false;syslog.log({level="panic"},"Kernel panic:",ag)if debug then local ak=debug.traceback(nil,2)syslog.log({level="panic",traceback=true},ak)end;syslog.log({level="panic"},"We are hanging here...")terminal.redraw(TTY[1],true)term.setCursorBlink(false)mainThread=nil;if _HEADLESS then os.shutdown(1)end;while true do coroutine.yield()end end,function(C)e7(ag.."; and an error occurred while logging the error: "..C)end)end;xpcall(function()local q;syslogs.default.file,q=filesystem.open(KERNEL,"/var/log/default.log","a")shutdownHooks[#shutdownHooks+1]=function()if syslogs.default.file then syslogs.default.file.close()end end;syslog.log("Starting Phoenix version",PHOENIX_VERSION,PHOENIX_BUILD)syslog.log("Initialized system logger")syslog.log("System started at "..systemStartTime.." on computer "..os.computerID()..(os.computerLabel()and"('"..os.computerLabel().."')"or""))syslog.log("Computer host is ".._HOST)if syslogs.default.file==nil then syslog.log({level="notice"},"An error occurred while opening the log file at /var/log/default.log:",q,". System logs will not be saved to disk.")end end,panic)local function e8(bt)return string.match(bt,'^()%s*$')and''or string.match(bt,'^%s*(.*%S)')end;local expect,do_syscall=expect,do_syscall;local function e9(bk)local a9=1;local function bn(ab)if a9>#bk then return nil end;ab=ab or 1;local bt=bk:sub(a9,a9+ab-1)a9=a9+ab;return bt end;if bn(8)~="!<arch>\n"then error("Not an ar archive",2)end;local a7={}local ea=nil;local eb={}while true do local bk={}local ec=bn()while ec=="\n"do ec=bn()end;if ec==nil then break end;local o=bn(15)if o==nil then break end;o=ec..o;if string.find(o,"/")and string.find(o,"/")>1 then o=string.sub(o,1,string.find(o,"/")-1)else o=e8(o)end;bk.timestamp=tonumber(e8(bn(12)))bk.owner=tonumber(e8(bn(6)))bk.group=tonumber(e8(bn(6)))bk.mode=tonumber(e8(bn(8)),8)local U=tonumber(e8(bn(10)))if bn(2)~="`\n"then error("Invalid header for file "..o,2)end;if string.match(o,"^#1/%d+$")then o=bn(tonumber(string.match(o,"#1/(%d+)")))elseif string.match(o,"^/%d+$")then if ea then local t=tonumber(string.match(o,"/(%d+)"))o=ea:match("[^/]*",t+1)else table.insert(eb,o)end end;bk.name=o;bk.data=bn(U)if o=="//"then ea=bk.data elseif o~="/"and o~="/SYM64/"then table.insert(a7,bk)end end;if ea then for j,k in pairs(eb)do local t=tonumber(string.match(k,"/(%d+)"))for P,ah in pairs(a7)do if ah.name==k then ah.name=ea:match("[^/]*",t+1)break end end end end;local ed={}for B,k in ipairs(a7)do ed[k.name]=k end;return ed end;function createRequire(process,cN)local ee,ef={},{}cN.package={}local eg=processes[process.parent]and processes[process.parent].env;if eg then cN.package.path=eg.package and eg.package.path;cN.package.libpath=eg.package and eg.package.libpath end;cN.package.path=cN.package.path or"/lib/?.lua;/lib/?/init.lua;/usr/lib/?.lua;/usr/lib/?/init.lua;./?.lua;./?/init.lua"if type(process.vars.PACKAGE_PATH)=="string"then cN.package.path=process.vars.PACKAGE_PATH..';'..cN.package.path end;cN.package.libpath=cN.package.libpath or"/lib/lib?.a;/usr/lib/lib?.a"if type(process.vars.PACKAGE_LIBPATH)=="string"then cN.package.libpath=process.vars.PACKAGE_LIBPATH..';'..cN.package.libpath end;cN.package.config="/\n;\n?\n!\n-"cN.package.loaded=ee;cN.package.preload=ef;cN.package.forceload=false;for j,k in pairs(cN)do if type(k)=="table"then ee[j]=k end end;local eh=setmetatable({},{__newindex=function()end,__metatable=false})local ei={}local function ej(o,g)local a,q=do_syscall("open",g,"rb")if not a then error(g..": "..q,3)end;local bk=a.readAll()a.close()local i,q=load(bk,"@"..g,nil,_ENV)if not i then error(g..": "..q,3)end;local ce=g:match("^(.*)/[^/]*$")or"/"ei[#ei+1]=function(ek)local g,q=package.searchpath(ek,ce.."/?.lua;"..ce.."/?/init.lua")if not g then return nil,q end;return ej,g end;local bh,w=pcall(i,o)ei[#ei]=nil;if bh then return w else error(g..": "..w,3)end end;local function el(o,g)local em;if g:find"%z"then g,em=g:match"^([^%z]*)%z(.*)$"elseif o:find"%-"then em=o:match("^([^%-]*)%-(.*)$")else em="init"end;local a,q=do_syscall("open",g,"rb")if not a then error(g..": "..q,3)end;local bk=a.readAll()a.close()local ce=e9(bk)local function en(o)local G=o..".lua"if not ce[G]then error(g..":"..G..": File not found",0)end;local bk=ce[G].data;local i,q=load(bk,"@"..g..":"..G,nil,_ENV)if not i then error(g..":"..G..": "..q,3)end;local bh,w=pcall(i,o)if bh then return w else error(g..":"..G..": "..w)end end;ei[#ei+1]=function(ek)return en,ek end;local w=en(em)ei[#ei]=nil;return w end;ei[1]=function(o)local ce=do_syscall("getname"):match("^(.*)/[^/]*$")or"/"local g,q=package.searchpath(o,ce.."/?.lua;"..ce.."/?/init.lua")if not g then return nil,q end;return ej,g end;function cN.package.searchpath(o,g,ao,eo)expect(1,o,"string")expect(2,g,"string")expect(3,ao,"string","nil")expect(4,eo,"string","nil")ao=(ao or"."):gsub("([%^%$%(%)%%%.%[%]%*%+%-%?])","%%%1")eo=(eo or"/"):gsub("([%^%$%(%)%%%.%[%]%*%+%-%?])","%%%1")local ep=""for G in g:gmatch"[^;]+"do local cg=G:gsub("%?",o:gsub(ao,eo),nil)local a,q=do_syscall("open",cg,"r")if a then a.close()return cg else ep=ep.."\t"..cg..": "..q.."\n"end end;return nil,ep end;cN.package.searchers={function(o)local G=ef[o]if G then return G else return nil,"\tpackage.preload['"..o.."']: No such field\n"end end,function(o)local g,q=package.searchpath(o,package.path)if not g then return nil,q end;return ej,g,g end,function(o)local g,q=package.searchpath(o:match("^[^%-]*"),package.libpath)if not g then return nil,q end;local t=o:match("%-(.+)$")if t then return el,g,g..":"..t else return el,g,g..":init"end end,function(o)if not o:find"%."then return nil end;local g,q=package.searchpath(o:match("^[^%.]*"),package.libpath)if not g then return nil,q end;local t=o:match("^[^%.]*%.(.*)$")return el,g.."\0"..t,g..":"..t end,function(o)if#ei>0 then return ei[#ei](o)end;return nil,"no local loaders found"end}setfenv(ej,cN)debug.protect(ej)setfenv(el,cN)debug.protect(el)setfenv(ei[1],cN)debug.protect(ei[1])for B,k in pairs(cN.package.searchers)do setfenv(k,cN)debug.protect(k)end;function cN.require(o)expect(1,o,"string")local q="module '"..o.."' not found:\n"local eq,er,es;for B,k in ipairs(package.searchers)do eq,er,es=k(o)if eq then break end;q=q..(er or"")end;if not eq then error(q,2)end;if es then if ee[es]then if ee[es]==eh then error("loop detected loading '"..o.."'",3)elseif not package.forceload then return ee[es]end end;ee[es]=eh else if ee[o]then if ee[o]==eh then error("loop detected loading '"..o.."'",3)elseif not package.forceload then return ee[o]end end end;ee[o]=eh;local bh,w=pcall(eq,o,er)if bh then if w~=nil then ee[o]=w elseif ee[o]==eh then ee[o]=true end;if es then if w~=nil then ee[es]=w elseif ee[es]==eh then ee[es]=true end end;return ee[o]else ee[o]=nil;if es then ee[es]=nil end;error(q.."\t"..w.."\n",2)end end;return cN end;do local ee,ef={},{}package={}package.path="/lib/?.lua;/lib/?/init.lua;/usr/lib/?.lua;/usr/lib/?/init.lua"package.libpath="/lib/lib?.a;/usr/lib/lib?.a"package.config="/\n;\n?\n!\n-"package.loaded=ee;package.preload=ef;package.forceload=false;for j,k in pairs(_G)do if type(k)=="table"then ee[j]=k end end;local eh=setmetatable({},{__newindex=function()end,__metatable=false})local ei={}local function ej(o,g)local bL,q=filesystem.stat(KERNEL,g)if not bL then error(g..": "..q,3)end;if bL.owner~="root"or bL.worldPermissions.write then error(g..": Insecure file permissions",3)end;for j,k in pairs(bL.permissions)do if j~="root"and k.write then error(g..": Insecure file permissions",3)end end;local a,q=filesystem.open(KERNEL,g,"rb")if not a then error(g..": "..q,3)end;local bk=a.readAll()a.close()local i,q=load(bk,"@"..g,nil,_G)if not i then error(g..": "..q,3)end;local ce=g:match("^(.*)/[^/]*$")or"/"ei[#ei+1]=function(ek)local g,q=package.searchpath(ek,ce.."/?.lua;"..ce.."/?/init.lua")if not g then return nil,q end;return ej,g end;local bh,w=pcall(i,o)ei[#ei]=nil;if bh then return w else error(g..": "..w,3)end end;local function el(o,g)local em;if g:find"%z"then g,em=g:match"^([^%z]*)%z(.*)$"elseif o:find"%-"then em=o:match("^([^%-]*)%-(.*)$")else em="init"end;local bL,q=filesystem.stat(KERNEL,g)if not bL then error(g..": "..q,3)end;if bL.owner~="root"or bL.worldPermissions.write then error(g..": Insecure file permissions",3)end;for j,k in pairs(bL.permissions)do if j~="root"and k.write then error(g..": Insecure file permissions",3)end end;local a,q=filesystem.open(KERNEL,g,"rb")if not a then error(g..": "..q,3)end;local bk=a.readAll()a.close()local ce=e9(bk)local function en(o)local G=o..".lua"if not ce[G]then error(g..":"..G..": File not found",0)end;local bk=ce[G].data;local i,q=load(bk,"@"..g..":"..G,nil,_ENV)if not i then error(g..":"..G..": "..q,3)end;local bh,w=pcall(i,o)if bh then return w else error(g..":"..G..": "..w)end end;ei[#ei+1]=function(ek)return en,ek end;local w=en(em)ei[#ei]=nil;return w end;function package.searchpath(o,g,ao,eo)expect(1,o,"string")expect(2,g,"string")expect(3,ao,"string","nil")expect(4,eo,"string","nil")ao=(ao or"."):gsub("([%^%$%(%)%%%.%[%]%*%+%-%?])","%%%1")eo=(eo or"/"):gsub("([%^%$%(%)%%%.%[%]%*%+%-%?])","%%%1")local ep=""for G in g:gmatch"[^;]+"do local cg=G:gsub("%?",o:gsub(ao,eo),nil)local a,q=filesystem.open(KERNEL,cg,"r")if a then a.close()return cg else ep=ep.."\t"..cg..": "..q.."\n"end end;return nil,ep end;package.searchers={function(o)local G=ef[o]if G then return G else return nil,"\tpackage.preload['"..o.."']: No such field\n"end end,function(o)local g,q=package.searchpath(o,package.path)if not g then return nil,q end;return ej,g,g end,function(o)local g,q=package.searchpath(o:match("^[^%-]*"),package.libpath)if not g then return nil,q end;local t=o:match("%-(.+)$")if t then return el,g,g..":"..t else return el,g,g..":init"end end,function(o)if not o:find"%."then return nil end;local g,q=package.searchpath(o:match("^[^%.]*"),package.libpath)if not g then return nil,q end;local t=o:match("^[^%.]*%.(.*)$")return el,g.."\0"..t,g..":"..t end,function(o)if#ei>0 then return ei[#ei](o)end;return nil,"\tno local loaders found"end}function require(o)expect(1,o,"string")local q="module '"..o.."' not found:\n"local eq,er,es;for B,k in ipairs(package.searchers)do eq,er,es=k(o)if eq then break end;q=q..(er or"")end;if not eq then error(q,2)end;if es then if ee[es]then if ee[es]==eh then error("loop detected loading '"..o.."'",3)elseif not package.forceload then return ee[es]end end;ee[es]=eh else if ee[o]then if ee[o]==eh then error("loop detected loading '"..o.."'",3)elseif not package.forceload then return ee[o]end end end;ee[o]=eh;local bh,w=pcall(eq,o,er)if bh then if w~=nil then ee[o]=w elseif ee[o]==eh then ee[o]=true end;if es then if w~=nil then ee[es]=w elseif ee[es]==eh then ee[es]=true end end;return ee[o]else ee[o]=nil;if es then ee[es]=nil end;error(q.."\t"..w.."\n",2)end end end;timerMap={}alarmMap={}local et={}function syscalls.kill(process,at,cZ,eu)expect(1,cZ,"number")expect(2,eu,"number")local ev=processes[cZ]if not ev then error("No such process",2)end;if process.user~="root"and process.user~=ev.user then error("Permission denied",2)end;if eu==9 then reap_process(ev)if processes[ev.parent]then syscalls.queueEvent(processes[ev.parent],nil,"process_complete",{id=cZ,result=9})end;processes[cZ]=nil elseif ev.signalHandlers[eu]then userModeCallback(ev,ev.signalHandlers[eu],eu)else syscalls.queueEvent(ev,nil,"signal",{signal=eu})end end;function killProcess(cZ,eu)expect(1,cZ,"number")expect(2,eu,"number")local ev=processes[cZ]if not ev then return end;if eu==9 then reap_process(ev)if processes[ev.parent]then syscalls.queueEvent(processes[ev.parent],nil,"process_complete",{id=cZ,result=9})end;processes[cZ]=nil elseif ev.signalHandlers[eu]then local aD=syscalls.newthread(ev,nil,ev.signalHandlers[eu],eu)ev.threads[aD].name="<signal handler:"..eu..">"else syscalls.queueEvent(ev,nil,"signal",{signal=eu})end end;function syscalls.signal(process,at,eu,ew)expect(1,eu,"number")expect(2,ew,"function","nil")process.signalHandlers[eu]=ew end;function syscalls.queueEvent(process,at,o,ay)expect(1,o,"string")expect(2,ay,"table")process.eventQueue[#process.eventQueue+1]={o,ay}end;function syscalls.sendEvent(process,at,cZ,o,ay)expect(1,cZ,"number")expect(2,o,"string")local ev=processes[cZ]if not ev then return false end;ev.eventQueue[#ev.eventQueue+1]={"remote_event",{type=o,sender=process.id,data=ay}}wakeup(ev)return true end;function syscalls.peekEvent(process,at)local au=process.eventQueue[#process.eventQueue]if not au then return nil end;local args={}for j,k in pairs(au[2])do args[j]=k end;return au[1],args end;function syscalls.register(process,at,o)expect(1,o,"string")if et[o]then return false end;et[o]=process.id;process.dependents[#process.dependents+1]={gc=function()et[o]=nil end}return true end;function syscalls.lookup(process,at,o)expect(1,o,"string")return et[o]end;function syscalls.timer(process,at,ex)expect(1,ex,"number")local ey=os.startTimer(ex)timerMap[ey]=process;return bit32.band(ey,0x7FFFFFFF)end;function syscalls.alarm(process,at,ex)expect(1,ex,"number")local ey=os.setAlarm(ex)alarmMap[ey]=process;return bit32.bor(ey,0x80000000)end;function syscalls.cancel(process,at,ey)expect(1,ey,"number")if bit32.btest(ey,0x80000000)then ey=bit32.band(ey,0x7FFFFFFF)if alarmMap[ey]~=process then error("No such alarm")end;os.cancelAlarm(ey)alarmMap[ey]=nil else if timerMap[ey]~=process then error("No such timer")end;os.cancelTimer(ey)timerMap[ey]=nil end end;eventHooks.terminate=eventHooks.terminate or{}eventHooks.terminate[#eventHooks.terminate+1]=function()if currentTTY.frontmostProcess then syscalls.kill(KERNEL,nil,currentTTY.frontmostProcess.id,2)terminal.write(currentTTY,"^T")end end;eventParameterMap={alarm={"id"},char={"character"},key={"keycode","isRepeat"},key_up={"keycode"},mouse_click={"button","x","y"},mouse_drag={"button","x","y"},mouse_up={"button","x","y"},mouse_scroll={"direction","x","y"},paste={"text"},redstone={},term_resize={},timer={"id"},turtle_inventory={}}do local ez=0;for B,k in pairs(keys)do if type(k)=="number"then ez=math.max(ez,k)end end;local bv;local eA,eB=pcall(string.dump,function()end)if eA then local eC=(function(r)if r<8 then return r end;local M=0;while r>=128 do r,M=bit32.rshift(r+0xf,4),M+4 end;while r>=16 do r,M=bit32.rshift(r+1,1),M+1 end;return bit32.bor((M+1)*8,r-8)end)(ez)syslog.debug("Key table sizes:",ez,eC)if _VERSION=="Lua 5.1"then bv=eB:sub(1,12)..("I"..eB:byte(9).."IIBBBBIIIIIIII"):pack(0,0,0,0,0,0,1,2,eC*0x800000+10,0x0100001E,0,0,0,0,0)elseif _VERSION=="Lua 5.2"then bv=eB:sub(1,18)..("IIBBBIIIIIIIIII"):pack(0,0,0,0,1,2,eC*0x800000+11,0x0100001F,0,0,0,0,0,0,0)elseif _VERSION=="Lua 5.3"then bv=eB:sub(1,17+("jn"):packsize())..("BBIIBBBIIIIIIIII"):pack(0,0,0,0,0,0,1,2,eC*0x800000+11,0x01000026,0,0,0,0,0,0)elseif _VERSION=="Lua 5.4"then bv=eB:sub(1,15+("jn"):packsize())..("BBBBBBBBIIIBBBBBBB"):pack(0,0x80,0x80,0x80,0,0,1,0x83,0x00000013,ez*0x80+82,0x00008048,0x80,0x80,0x80,0x80,0x80,0x80,0x80)end;if bv then local i,q=load(bv,nil,"b")if i then keymap=i()else syslog.debug("Could not load key table code:",q)end end end;if not keymap then keymap=load("return {"..("nil,"):rep(ez).."}")()end;for x=0x61,0x7A do keymap[keys[string.char(x)]]=x end;for x=0x81,0x99 do if keys["f"..bit32.band(x,31)]then keymap[keys["f"..bit32.band(x,31)]]=x end end;for x=0xA0,0xA9 do keymap[keys["numPad"..bit32.band(x,15)]]=x end;keymap[keys.backspace]=0x08;keymap[keys.tab]=0x09;keymap[keys.enter or keys["return"]]=0x0A;keymap[keys.space]=0x20;keymap[keys.apostrophe]=0x27;keymap[keys.comma]=0x2C;keymap[keys.minus]=0x2D;keymap[keys.period]=0x2E;keymap[keys.slash]=0x2F;keymap[keys.zero]=0x30;keymap[keys.one]=0x31;keymap[keys.two]=0x32;keymap[keys.three]=0x33;keymap[keys.four]=0x34;keymap[keys.five]=0x35;keymap[keys.six]=0x36;keymap[keys.seven]=0x37;keymap[keys.eight]=0x38;keymap[keys.nine]=0x39;keymap[keys.semicolon or keys.semiColon]=0x3B;keymap[keys.equals]=0x3D;keymap[keys.leftBracket]=0x5B;keymap[keys.backslash]=0x5C;keymap[keys.rightBracket]=0x5D;keymap[keys.grave]=0x60;keymap[keys.delete]=0x7F;keymap[keys.insert]=0x80;if keys.convert then keymap[keys.convert]=0x9A end;if keys.noconvert then keymap[keys.noconvert]=0x9B end;if keys.kana then keymap[keys.kana]=0x9C end;if keys.kanji then keymap[keys.kanji]=0x9D end;if keys.yen then keymap[keys.yen]=0x9E end;keymap[keys.numPadDecimal]=0x9F;keymap[keys.numPadAdd]=0xAA;keymap[keys.numPadSubtract]=0xAB;if keys.numPadMultiply then keymap[keys.numPadMultiply]=0xAC end;keymap[keys.numPadDivide]=0xAD;keymap[keys.numPadEqual or keys.numPadEquals]=0xAE;keymap[keys.numPadEnter]=0xAF;keymap[keys.leftCtrl]=0xB0;keymap[keys.rightCtrl]=0xB1;keymap[keys.leftAlt]=0xB2;keymap[keys.rightAlt]=0xB3;keymap[keys.leftShift]=0xB4;keymap[keys.rightShift]=0xB5;if keys.leftSuper then keymap[keys.leftSuper]=0xB6 end;if keys.rightSuper then keymap[keys.rightSuper]=0xB7 end;keymap[keys.capsLock]=0xB8;keymap[keys.numLock]=0xB9;keymap[keys.scrollLock or keys.scollLock]=0xBA;if keys.printScreen then keymap[keys.printScreen]=0xBB end;keymap[keys.pause]=0xBC;if keys.menu then keymap[keys.menu]=0xBD end;if keys.stop then keymap[keys.stop]=0xBE end;if keys.ax then keymap[keys.ax]=0xBF end;keymap[keys.up]=0xC0;keymap[keys.down]=0xC1;keymap[keys.left]=0xC2;keymap[keys.right]=0xC3;keymap[keys.pageUp]=0xC4;keymap[keys.pageDown]=0xC5;keymap[keys.home]=0xC6;keymap[keys["end"]]=0xC7;if keys.circumflex or keys.cimcumflex then keymap[keys.circumflex or keys.cimcumflex]=0xC8 end;if keys.at then keymap[keys.at]=0xC9 end;if keys.colon then keymap[keys.colon]=0xCA end;if keys.underscore then keymap[keys.underscore]=0xCB end end;local eD={id=0,name="",coro=coroutine.create(function()end),coroStack={},status="starting",args={"a",n=1},filter=function(process,at,cd)end,paused=false}local eE={id=1,name="init",user="root",dependents={{gc=function()end}},parent=0,dir="/",stdin=TTY[1],stdout={},stderr=TTY[1],cputime=0.2,systime=0.1,debugging=false,allowDebug=true,debugger=nil,breakpoints={},hookf=function()end,env={},syscallyield=nil,eventQueue={},signalHandlers={},paused=false,nice=0,threads={[0]=eD},globalMetatables={}}local eF=1;local function eG(process)local e=createLuaLib(process)if _VERSION<"Lua 5.2"then e=make_ENV(e)end;e._G=e;return e end;local eH,eI,debugHooks=coroutine.yield,coroutine.running,debugHooks;local function eJ(cd,al)if cd=="count"then eH("preempt")end;local ai=debugHooks[eI()]if ai then if cd=="count"and not ai.count then return end;return ai.func(cd,al)end end;local eK={load}function addProcessLoader(eq)table.insert(eK,1,eq)end;function removeProcessLoader(eq)for x,k in ipairs(eK)do if k==eq then table.remove(eK,x)return end end end;function reap_process(process)syslog.debug("Reaping process "..process.id.." ("..process.name..")")for B,k in ipairs(process.dependents)do k:gc()end;if process.stdin and process.stdin.isTTY then if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)process.stdin.preBuffer=""if discord and process.stdout==currentTTY and process.stdout.frontmostProcess then discord("Phoenix","Executing "..process.stdout.frontmostProcess.name)end else for x,k in ipairs(process.stdin.processList)do if k==process then table.remove(process.stdin.processList,x)break end end end end;if process.stdout and process.stdout.isTTY then if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)else for x,k in ipairs(process.stdout.processList)do if k==process then table.remove(process.stdout.processList,x)break end end end end;if process.stderr and process.stderr.isTTY then if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)else for x,k in ipairs(process.stderr.processList)do if k==process then table.remove(process.stderr.processList,x)break end end end end end;function syscalls.getpid(process,at)return process.id end;function syscalls.getppid(process,at)return process.parent end;function syscalls.clock(process,at)return process.cputime end;function syscalls.getenv(process,at)return process.vars end;function syscalls.getfenv(process,at)return process.env end;function syscalls.getname(process,at)return process.name end;function syscalls.getcwd(process,at)return process.dir end;function syscalls.chdir(process,at,ce)expect(1,ce,"string")local bL=filesystem.stat(process,ce)if not bL or bL.type~="directory"then return false,"No such file or directory"elseif not(bL.permissions[process.user]or bL.worldPermissions).execute then return false,"Permission denied"end;process.dir=ce:gsub("^([^/])","/"..process.dir.."/%1")return true end;function syscalls.getuser(process,at)return process.user,process.realuser end;function syscalls.setuser(process,at,bG)expect(1,bG,"string")if process.user~="root"then error("Permission denied")end;process.user=bG;process.realuser=nil end;local function eL(cN)return{["nil"]={},["boolean"]={__unm=function()end},["number"]={},["string"]={__index=cN.string},["function"]={},["thread"]={__index=cN.coroutine,__call=cN.coroutine.resume},["userdata"]={}}end;function syscalls.fork(process,at,aC,o,...)expect(1,aC,"function")expect(2,o,"string","nil")local aD=eF;eF=eF+1;processes[aD]={id=aD,name=o or process.name,user=process.user,dependents={},parent=process.id,dir=process.dir,env=nil,root=process.root,stdin=process.stdin,stdout=process.stdout,stderr=process.stderr,vars=deepcopy(process.vars),cputime=0,systime=0,debugging=false,allowDebug=true,breakpoints={},hookf=eJ,quantum=args.quantum,syscallyield=nil,eventQueue={},globalMetatables=nil,signalHandlers={[1]=function()return coroutine.yield("syscall","exit",1)end,[2]=function()return coroutine.yield("syscall","exit",1)end,[3]=function()coroutine.yield("syscall","syslog",{level="error",category="Application Error",traceback=true},debug.traceback("Quit"))return coroutine.yield("syscall","exit",1)end,[6]=function(q)coroutine.yield("syscall","syslog",{level="error",category="Application Error",traceback=true},debug.traceback(q or"Aborted"))return coroutine.yield("syscall","exit",1)end,[13]=function()return coroutine.yield("syscall","exit",1)end,[15]=function()return coroutine.yield("syscall","exit",1)end,[19]=function()return coroutine.yield("syscall","suspend")end,[21]=function()return coroutine.yield("syscall","suspend")end,[22]=function()return coroutine.yield("syscall","suspend")end},paused=false,nice=0,threads={[0]={id=0,name="<main thread>",coro=coroutine.create(aC),syscall=coroutine.create(function(...)local args=table.pack(...)while true do args=table.pack(coroutine.yield(kSyscallComplete,xpcall(syscalls[args[1]],debug.traceback,table.unpack(args,2,args.n))))end end),status="starting",args=table.pack(...),filter=nil,coroStack=nil,paused=false}}}processes[aD].threads[0].coroStack={processes[aD].threads[0].coro}processes[aD].env=eG(processes[aD])processes[aD].globalMetatables=eL(processes[aD].env)setfenv(aC,processes[aD].env)if process.stdin and process.stdin.isTTY and not process.stdin.isLocked then process.stdin.processList[#process.stdin.processList+1]=process.stdin.frontmostProcess;process.stdin.frontmostProcess=processes[aD]process.stdin.preBuffer=""if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.name)end end;if process.stdout and process.stdout.isTTY and not process.stdout.isLocked and process.stdout.frontmostProcess~=processes[aD]then process.stdout.processList[#process.stdout.processList+1]=process.stdout.frontmostProcess;process.stdout.frontmostProcess=processes[aD]end;if process.stderr and process.stderr.isTTY and not process.stderr.isLocked and process.stderr.frontmostProcess~=processes[aD]then process.stderr.processList[#process.stderr.processList+1]=process.stderr.frontmostProcess;process.stderr.frontmostProcess=processes[aD]end;if args.preemptive then debug.sethook(processes[aD].threads[0].coro,eJ,"",processes[aD].quantum)end;return aD end;function syscalls.exec(process,at,g,...)expect(1,g,"string")local a,q=filesystem.open(process,g,"r")if not a then g=g..".lua"a,q=filesystem.open(process,g,"r")if not a then error("Could not open file: "..q,0)end end;local eM=a.readAll()a.close()if eM:find("[%z\1-\31]")then a,q=filesystem.open(process,g,"rb")if not a then error("Could not open file: "..q,0)end;eM=a.readAll()a.close()end;local bL=assert(filesystem.stat(process,g))if not(bL.permissions[bL.owner]or bL.worldPermissions).execute then error("Could not execute file: Permission denied",0)end;if bL.setuser then process.realuser,process.user=process.user,bL.owner end;if eM:sub(1,2)=="#!"then local eN=eM:sub(3,eM:find("\n")-1)local args,x={},0;for bt in eN:gmatch"%S+"do args[x]=bt;x=x+1 end;args[x],x=g,x+1;for B,k in ipairs{...}do args[x]=k;x=x+1 end;if args[0]==g then error("Recursive path detected while resolving shebang",0)end;syscalls.exec(process,at,args[0],table.unpack(args,1,x))process.name="/"..fs.combine(g:sub(1,1)=="/"and""or process.dir,g)else local aC,q;for B,eq in ipairs(eK)do aC,q=eq(eM,"@"..g,"bt",process.env)if aC then break end end;if not aC then error("Could not execute file: "..q,0)end;process.name="/"..fs.combine(g:sub(1,1)=="/"and""or process.dir,g)process.threads={[0]={id=0,name="<main thread>",coro=coroutine.create(aC),syscall=coroutine.create(function(...)local args=table.pack(...)while true do args=table.pack(coroutine.yield(kSyscallComplete,xpcall(syscalls[args[1]],debug.traceback,table.unpack(args,2,args.n))))end end),status="starting",args=table.pack(...),filter=nil}}process.threads[0].coroStack={process.threads[0].coro}if args.preemptive then debug.sethook(process.threads[0].coro,process.hookf,process.debugging and"crl"or"",process.quantum)end end;if discord and process.stdin and process.stdin.isTTY and process.stdin.frontmostProcess==process then discord("Phoenix","Executing "..process.name)end end;function syscalls.newthread(process,at,aC,...)expect(1,aC,"function")local aD=#process.threads+1;process.threads[aD]={id=aD,name="<thread:"..aD..">",coro=coroutine.create(aC),syscall=coroutine.create(function(...)local args=table.pack(...)while true do args=table.pack(coroutine.yield(kSyscallComplete,xpcall(syscalls[args[1]],debug.traceback,table.unpack(args,2,args.n))))end end),status="starting",args=table.pack(...),filter=nil,coroStack=nil,paused=false}setfenv(aC,process.env)process.threads[aD].coroStack={process.threads[aD].coro}if args.preemptive then debug.sethook(process.threads[aD].coro,process.hookf,process.debugging and"crl"or"",process.quantum)end;return aD end;function syscalls.exit(process,at,bv)process.lastReturnValue={pid=process.id,thread=at.id,value=bv,n=1,bv}for B,at in pairs(process.threads)do at.status="dead"at.return_value=bv end end;function syscalls.atexit(process,at,i)expect(1,i,"function")process.dependents[#process.dependents+1]={gc=function()local aD=syscalls.newthread(process,nil,i)local x=0;while process.threads[aD]and process.threads[aD].coro:status()=="suspended"and x<100 do executeThread(process,process.threads[aD],{n=0},false,false)x=x+1 end end}end;function syscalls.getplist(process,at)local eO={}for j in pairs(processes)do eO[#eO+1]=j end;table.sort(eO)return eO end;function syscalls.getpinfo(process,at,cZ)expect(1,cZ,"number")local G=processes[cZ]if not G then return nil,"No such process"end;local eP,eQ,eR;for x,k in ipairs(TTY)do if G.stdin==k then eP=x end;if G.stdout==k then eQ=x end;if G.stderr==k then eR=x end end;local eS={}if G.threads then for x,k in pairs(G.threads)do eS[x]={id=k.id,name=k.name,status=k.status,paused=k.pause or false}end end;return{id=G.id,name=G.name,user=G.user,realuser=G.realuser,parent=G.parent,dir=G.dir,stdin=eP,stdout=eQ,stderr=eR,cputime=G.cputime or 0,systime=G.systime or 0,threads=eS,allowDebug=G.allowDebug,debugging=G.debugging}end;function syscalls.suspend(process,at)process.paused=true end;function syscalls.nice(process,at,b3,cZ)expect(1,b3,"number")expect.range(b3,-20,20)expect(2,cZ,"number","nil")if b3<0 and process.user~="root"then error("Permission denied",0)end;local ev=cZ and assert(processes[cZ],"Invalid process ID")or process;if ev.user~=process.user and process.user~="root"then error("Permission denied",0)end;ev.nice=b3;ev.quantum=args.quantum*10^(b3/-10)if args.preemptive then for B,A in pairs(ev.threads)do debug.sethook(A.coro,eJ,"",ev.quantum)end end end;local function eT(process)local eU,next,eV,getCurrentThread,wakeup=string.find,next,debug.getinfo,getCurrentThread,wakeup;local function eW(cd,al)if cd=="count"then eH("preempt")end;local info=eV(2)local at=getCurrentThread()for aD,dg in next,process.breakpoints do if dg.type==cd or dg.type=="call"and cd=="tail call"then local bh=dg.thread==nil or dg.thread==at.id;if dg.filter then for j,k in next,dg.filter do if info[j]~=k then bh=false;break end end end;if bh then dg.process.eventQueue[#dg.process.eventQueue+1]={"debug_break",{process=process.id,thread=at.id,breakpoint=aD}}wakeup(dg.process)at.paused=true;eH("preempt")break end end end;while at.pendingExec do local w=table.pack(pcall(at.pendingExec))w.ok=table.remove(w,1)w.n=w.n-1;if not w.ok then w.error=w[1]end;w.process=process.id;w.thread=at.id;local eX=at.pendingExecProcess.eventQueue;eX[#eX+1]={"debug_exec_result",w}wakeup(at.pendingExecProcess)at.pendingExec,at.pendingExecProcess=nil;at.paused=true;eH("preempt")end;local ai=debugHooks[eI()]if ai then if cd=="count"and not ai.count or(cd=="call"or cd=="tail call")and not eU(ai.mask,"c")or cd=="return"and not eU(ai.mask,"r")or cd=="line"and not eU(ai.mask,"l")then return end;return ai.func(cd,al)end end;setfenv(eW,process.env)debug.protect(eW)process.hookf=eW;for B,k in pairs(process.threads)do for B,ah in ipairs(k.coroStack)do debug.sethook(ah,eW,"clr",process.quantum)end end end;local function eY(process)for B,k in pairs(process.threads)do k.paused=false;for B,ah in ipairs(k.coroStack)do local ai=debugHooks[ah]debug.sethook(ah,eJ,ai and ai.mask or"",process.quantum)end end;process.hookf=eJ end;function syscalls.debug_enable(process,at,cZ,cs)expect(1,cZ,"number","nil")expect(2,cs,"boolean")local G;if cZ==process.id or cZ==nil then G=process;process.allowDebug=cs else G=processes[cZ]if not G then error("No such process")end;if not G.allowDebug or G.user~=process.user and process.user~="root"then error("Permission denied")end end;if G.debugging~=cs then if cs then eT(G)else eY(G)end end;G.debugging=cs;if cs and G~=process then G.debugger=process end end;function syscalls.debug_break(process,at,cZ,eZ)if cZ==nil then if not process.debugger or not processes[process.debugger.id]then return end;process.debugger.eventQueue[#process.debugger.eventQueue+1]={"debug_break",{process=process.id,thread=at.id}}wakeup(process.debugger)at.paused=true;return end;expect(1,cZ,"number")expect(2,eZ,"number","nil")local G=processes[cZ]if not G then error("No such process")end;if G.user~=process.user and process.user~="root"then error("Permission denied")end;if not G.debugging then error("Process does not have debugging enabled")end;if eZ then local A=G.threads[eZ]if not A then error("No such thread")end;if not A.paused then process.eventQueue[#process.eventQueue+1]={"debug_break",{process=G.id,thread=A.id}}end;A.paused=true else for B,A in pairs(G.threads)do if not A.paused then process.eventQueue[#process.eventQueue+1]={"debug_break",{process=G.id,thread=A.id}}end;A.paused=true end end end;function syscalls.debug_(process,at,cZ)expect(1,cZ,"number")local G=processes[cZ]if not G then error("No such process")end;if G.user~=process.user and process.user~="root"then error("Permission denied")end;if not G.debugging then error("Process does not have debugging enabled")end end;function syscalls.debug_continue(process,at,cZ,eZ)expect(1,cZ,"number")expect(2,eZ,"number","nil")local G=processes[cZ]if not G then error("No such process")end;if G.user~=process.user and process.user~="root"then error("Permission denied")end;if not G.debugging then error("Process does not have debugging enabled")end;if eZ then local A=G.threads[eZ]if not A then error("No such thread")end;A.paused=false else for B,A in pairs(G.threads)do A.paused=false end end end;local e_={call=true,["return"]=true,line=true,error=true,resume=true,yield=true}function syscalls.debug_setbreakpoint(process,at,cZ,eZ,f0,e6)expect(1,cZ,"number")expect(2,eZ,"number","nil")expect(3,f0,"string","number")expect(4,e6,"table","nil")if type(f0)~="number"and not e_[f0]then error("bad argument #3 (invalid option '"..f0 .."')")end;local G=processes[cZ]if not G then error("No such process")end;if G.user~=process.user and process.user~="root"then error("Permission denied")end;if not G.debugging then error("Process does not have debugging enabled")end;local aD=#G.breakpoints+1;G.breakpoints[aD]={process=process,thread=eZ,type=f0,filter=e6}return aD end;function syscalls.debug_unsetbreakpoint(process,at,cZ,f1)expect(1,cZ,"number")expect(2,f1,"number")local G=processes[cZ]if not G then error("No such process")end;if G.user~=process.user and process.user~="root"then error("Permission denied")end;if not G.debugging then error("Process does not have debugging enabled")end;G.breakpoints[f1]=nil end;function syscalls.debug_listbreakpoints(process,at,cZ)expect(1,cZ,"number")local G=processes[cZ]if not G then error("No such process")end;if G.user~=process.user and process.user~="root"then error("Permission denied")end;if not G.debugging then error("Process does not have debugging enabled")end;local a7={}for aD,dg in pairs(G.breakpoints)do a7[aD]={type=dg.type,thread=dg.thread}if dg.filter then for j,k in pairs(dg.filter)do a7[aD][j]=k end end end;return a7 end;function syscalls.debug_getinfo(process,at,cZ,eZ,b3,b2)expect(1,cZ,"number")expect(2,eZ,"number")expect(3,b3,"number")expect(4,b2,"string","nil")local G=processes[cZ]if not G then error("No such process")end;if G.user~=process.user and process.user~="root"then error("Permission denied")end;if not G.debugging then error("Process does not have debugging enabled")end;local A=G.threads[eZ]if not A then error("No such thread")end;return debug.getinfo(A.coroStack[#A.coroStack],b3,b2)end;function syscalls.debug_getlocal(process,at,cZ,eZ,b3,t)expect(1,cZ,"number")expect(2,eZ,"number")expect(3,b3,"number")expect(4,t,"number")local G=processes[cZ]if not G then error("No such process")end;if G.user~=process.user and process.user~="root"then error("Permission denied")end;if not G.debugging then error("Process does not have debugging enabled")end;local A=G.threads[eZ]if not A then error("No such thread")end;return debug.getlocal(A.coroStack[#A.coroStack],b3,t)end;function syscalls.debug_getupvalue(process,at,cZ,eZ,b3,t)expect(1,cZ,"number")expect(2,eZ,"number")expect(3,b3,"number")expect(4,t,"number")local G=processes[cZ]if not G then error("No such process")end;if G.user~=process.user and process.user~="root"then error("Permission denied")end;if not G.debugging then error("Process does not have debugging enabled")end;local A=G.threads[eZ]if not A then error("No such thread")end;local info=debug.getinfo(A.coroStack[#A.coroStack],b3,"f")if not info then error("bad argument #3 (level out of range)")end;return debug.getupvalue(info.func,t)end;function syscalls.debug_exec(process,at,cZ,eZ,i)expect(1,cZ,"number")expect(2,eZ,"number")expect(3,i,"function")local G=processes[cZ]if not G then error("No such process")end;if G.user~=process.user and process.user~="root"then error("Permission denied")end;if not G.debugging then error("Process does not have debugging enabled")end;local A=G.threads[eZ]if not A then error("No such thread")end;if not A.paused then error("Thread is not paused")end;setfenv(i,G.env)A.pendingExec=i;A.pendingExecProcess=process;A.paused=false end;local function f2(a2)a2=a2 .."\x80"..("\0"):rep(-(#a2+9)%64)..(">I8"):pack(#a2)local f3,f4,f5,f6,f7,ah=0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476,0xC3D2E1F0,{}for f8=1,#a2,64 do local f9=f8;for x=0,15 do ah[x]=a2:byte(f9)*0x1000000+a2:byte(f9+1)*0x10000+a2:byte(f9+2)*0x100+a2:byte(f9+3)f9=f9+4 end;for x=16,79 do ah[x]=bit32.lrotate(bit32.bxor(ah[x-3],ah[x-8],ah[x-14],ah[x-16]),1)end;local cy,ad,ab,br,M=f3,f4,f5,f6,f7;for x=0,79 do local f,j;if x<=19 then f,j=bit32.bxor(br,bit32.band(ad,bit32.bxor(ab,br))),0x5A827999 elseif x<=39 then f,j=bit32.bxor(ad,ab,br),0x6ED9EBA1 elseif x<=59 then f,j=bit32.bor(bit32.band(ad,bit32.bor(ab,br)),bit32.band(ab,br)),0x8F1BBCDC else f,j=bit32.bxor(ad,ab,br),0xCA62C1D6 end;local fa=bit32.band(bit32.lrotate(cy,5)+f+M+j+ah[x],0xFFFFFFFF)M,br,ab,ad,cy=br,ab,bit32.lrotate(ad,30),cy,fa end;f3=bit32.band(f3+cy,0xFFFFFFFF)f4=bit32.band(f4+ad,0xFFFFFFFF)f5=bit32.band(f5+ab,0xFFFFFFFF)f6=bit32.band(f6+br,0xFFFFFFFF)f7=bit32.band(f7+M,0xFFFFFFFF)end;return{f3,f4,f5,f6,f7}end;local function fb(fc,o)local fd=f2(fc:gsub("%X",""):gsub("%x%x",function(bt)return string.char(tonumber(bt,16))end)..o)local cy,ad,ab,br=fd[1],bit32.bor(bit32.band(fd[2],0xFFFF0FFF),0x5000),bit32.bor(bit32.band(fd[3],0x3FFFFFFF),0x80000000),fd[4]return("%08x-%04x-%04x-%04x-%04x%08x"):format(cy,bit32.rshift(ad,16),bit32.band(ad,0xFFFF),bit32.rshift(ab,16),bit32.band(ab,0xFFFF),br)end;local fe="a6f53b7d-50f3-4e51-adef-8728c83e3f3a"deviceTreeRoot={id=tostring(os.getComputerID()),uuid=fb(fe,tostring(os.getComputerID())),parent=nil,displayName=os.getComputerLabel()or"",drivers={},metadata={},internalState={},children={},listeners=setmetatable({},{__mode="k"})}local ff={[deviceTreeRoot.uuid]=deviceTreeRoot}local fg={}function hardware.get(g)expect(1,g,"string")if g:find("^%x+%-%x+%-%x+%-%x+%-%x+$")then return ff[g]elseif g==""or g:find("/")then local dX=deviceTreeRoot;for o in g:gmatch"[^/]+"do dX=dX.children[o]if dX==nil then break end end;return dX else local fh={}local function fi(dX)if dX.id==g or dX.alias==g then fh[#fh+1]=dX end;for B,k in pairs(dX.children)do fi(k)end end;fi(deviceTreeRoot)return table.unpack(fh)end end;function hardware.find(type)expect(1,type,"string")local dW={}local function fj(dX)for B,k in ipairs(dX.drivers)do if k.type==type then dW[#dW+1]=dX;break end end;for B,k in pairs(dX.children)do fj(k)end end;fj(deviceTreeRoot)return table.unpack(dW)end;function hardware.path(dX)expect(1,dX,"table")expect.field(dX,"uuid","string")if not ff[dX.uuid]then error("bad argument #1 (invalid node)",2)end;local g=dX.id;dX=dX.parent;while dX do g=dX.id.."/"..g;dX=dX.parent end;g=g:gsub("^[^/]+","")return g==""and"/"or g end;function hardware.add(c3,o)expect(1,c3,"table")expect(2,o,"string")expect.field(c3,"uuid","string")if not ff[c3.uuid]then return nil,"Invalid parent node"end;if c3.children[o]then return nil,"Node already exists"end;local dX={id=o,uuid=fb(c3.uuid,o),parent=c3,displayName="",drivers={},metadata={},internalState={},children={},listeners=setmetatable({},{__mode="k"})}c3.children[o]=dX;ff[dX.uuid]=dX;syslog.log({module="Hardware"},"Added new device at "..hardware.path(dX))for B,k in ipairs(fg)do if(not k.parent or k.parent==c3)and(not k.pattern or o:match(k.pattern))then k.callback(dX)end end;return dX end;function hardware.remove(dX)expect(1,dX,"table")expect.field(dX,"uuid","string")if not ff[dX.uuid]then return false,"Invalid node"end;if dX==deviceTreeRoot or not dX.parent then return false,"Cannot remove root node"end;for x=#dX.drivers,1,-1 do hardware.deregister(dX,dX.drivers[x])end;for B,k in pairs(dX.children)do hardware.remove(k)end;syslog.log({module="Hardware"},"Device at "..hardware.path(dX).." has been removed")dX.parent.children[dX.id]=nil;ff[dX.uuid]=nil;dX.parent=nil;return true end;function hardware.register(dX,fk)expect(1,dX,"table")expect(2,fk,"table")expect.field(dX,"uuid","string")expect.field(fk,"name","string")expect.field(fk,"type","string")expect.field(fk,"properties","table")expect.field(fk,"methods","table")expect.field(fk,"init","function","nil")expect.field(fk,"deinit","function","nil")for j in pairs(fk.methods)do if type(j)~="string"then error("bad method name '"..tostring(j).."' (not a string)",2)end;expect.field(fk.methods,j,"function")end;for B,k in ipairs(fk.properties)do if type(k)~="string"then error("bad property name '"..tostring(k).."' (not a string)",2)end;if not fk.methods["get"..k:sub(1,1):upper()..k:sub(2)]then error("bad property '"..k.."' (no getter present)",2)end end;if not ff[dX.uuid]then error("bad argument #1 (invalid node)",2)end;for B,k in ipairs(dX.drivers)do if k==fk then return false end end;dX.drivers[#dX.drivers+1]=fk;syslog.log({module="Hardware"},"Registered device with type "..fk.type.." on device "..hardware.path(dX).." using driver "..fk.name)if fk.init then fk.init(dX)end;return true end;function hardware.register_callback(fk)return function(dX)return hardware.register(dX,fk)end end;function hardware.deregister(dX,fk)expect(1,dX,"table")expect(2,fk,"table")expect.field(dX,"uuid","string")if not ff[dX.uuid]then error("bad argument #1 (invalid node)",2)end;for x,k in ipairs(dX.drivers)do if k==fk then if fk.deinit then fk.deinit(dX)end;table.remove(dX.drivers,x)syslog.log({module="Hardware"},"Driver "..fk.name.." has been deregistered from device "..hardware.path(dX))return true end end;return false end;function hardware.listen(fl,c3,fm)expect(1,fl,"function")expect(2,c3,"table","nil")expect(3,fm,"string","nil")if c3 then expect.field(c3,"uuid","string")end;if fm and not pcall(string.match,"",fm)then error("bad argument #3 (invalid pattern)",2)end;fg[#fg+1]={callback=fl,parent=c3,pattern=fm}end;function hardware.unlisten(fl)expect(1,fl,"function")local x=1;while x<#fg do if fg[x].callback==fl then table.remove(fg,x)else x=x+1 end end end;function hardware.broadcast(dX,cd,d1)expect(1,dX,"table")expect(2,cd,"string")expect(3,d1,"table")expect.field(dX,"uuid","string")if not ff[dX.uuid]then error("bad argument #1 (invalid node)",2)end;for k in pairs(dX.listeners)do k.eventQueue[#k.eventQueue+1]={cd,d1}wakeup(k)end end;function hardware.call(process,dX,fn,...)for B,fk in ipairs(dX.drivers)do if fk.methods[fn]then return fk.methods[fn](dX,process,...)end end;error("No such method",2)end;function syscalls.devlookup(process,at,o)expect(1,o,"string")local fo={hardware.get(o)}for j,k in ipairs(fo)do fo[j]=hardware.path(k)end;return table.unpack(fo)end;function syscalls.devfind(process,at,type)expect(1,type,"string")local fo={hardware.find(type)}for j,k in ipairs(fo)do fo[j]=hardware.path(k)end;return table.unpack(fo)end;function syscalls.devinfo(process,at,fp)expect(1,fp,"string")local dX=hardware.get(fp)if not dX then return nil end;local fq={}for B,k in ipairs(dX.drivers)do fq[k.type]=k.name end;return{id=dX.id,uuid=dX.uuid,alias=dX.alias,parent=dX.parent and hardware.path(dX.parent)or"/",displayName=dX.displayName,types=fq,metadata=deepcopy(dX.metadata)}end;function syscalls.devalias(process,at,fp,fr)expect(1,fp,"string")expect(2,fr,"string","nil")local dX=hardware.get(fp)if not dX then error("No such device",2)end;dX.alias=fr end;function syscalls.devmethods(process,at,fp)expect(1,fp,"string")local dX=hardware.get(fp)if not dX then error("No such device",2)end;local ft={}for B,k in ipairs(dX.drivers)do for j in pairs(k.methods)do ft[#ft+1]=j end end;return ft end;function syscalls.devproperties(process,at,fp)expect(1,fp,"string")local dX=hardware.get(fp)if not dX then error("No such device",2)end;local fu={}for B,k in ipairs(dX.drivers)do for B,j in pairs(k.properties)do fu[#fu+1]=j end end;return fu end;function syscalls.devchildren(process,at,fp)expect(1,fp,"string")local dX=hardware.get(fp)if not dX then error("No such device",2)end;local fv={}for j in pairs(dX.children)do fv[#fv+1]=j end;return fv end;function syscalls.devcall(process,at,fp,fn,...)expect(1,fp,"string")expect(2,fn,"string")local dX=hardware.get(fp)if not dX then error("No such device",2)end;if dX.process and dX.process~=process.id then error("Device is locked",2)end;return hardware.call(process,dX,fn,...)end;function syscalls.devlisten(process,at,fp,dA)expect(1,fp,"string")expect(2,dA,"boolean","nil")if dA==nil then dA=true end;local dX=hardware.get(fp)if not dX then error("No such device",2)end;if dA then for B,k in ipairs(dX.listeners)do if k==process then return end end;dX.listeners[process]=true;process.dependents[#process.dependents+1]={type="hardware listen",node=dX,gc=function()dX.listeners[process]=nil end}else dX.listeners[process]=nil;for x,k in ipairs(process.dependents)do if k.type=="hardware listen"and k.node==dX then table.remove(process.dependents,x)break end end end end;function syscalls.devlock(process,at,fp,fw)expect(1,fp,"string")expect(2,fw,"boolean","nil")if fw==nil then fw=true end;local dX=hardware.get(fp)if not dX then error("No such device",2)end;if dX.process==nil then dX.process=process.id;process.dependents[#process.dependents+1]={type="hardware lock",node=dX,gc=function()dX.process=nil end}return true elseif dX.process==process.id then return true elseif fw then at.filter=function(process,at)return dX.process==nil or dX.process==process.id end;return kSyscallYield,"devlock",fp,true else return false end end;function syscalls.devunlock(process,at,fp)expect(1,fp,"string")local dX=hardware.get(fp)if not dX then error("No such device",2)end;if dX.process and dX.process~=process.id then error("Device is locked",2)end;dX.process=nil;for x,k in ipairs(process.dependents)do if k.type=="hardware lock"and k.node==dX then table.remove(process.dependents,x)break end end end;function syscalls.version(process,at,fx)if fx then return PHOENIX_BUILD else return PHOENIX_VERSION end end;function syscalls.cchost(process,at)return _HOST end;function syscalls.uptime(process,at)return(os.epoch"utc"-systemStartTime)/1000 end;function syscalls.attach(process,at,fy,_type,...)if process.user~="root"then error("Permission denied")end;expect(1,fy,"string","number")expect(2,_type,"string")local bh,q;if periphemu then bh=periphemu.create(fy,_type,...)elseif ccemux then if type(fy)=="number"then fy=_type.."_"..fy end;if _type=="drive"then _type="disk_drive"elseif _type=="modem"then _type="wireless_modem"end;if _type=="computer"then local aD=tonumber(fy:match("%d+"))if aD then bh,q=pcall(ccemux.openEmu,aD)else bh,q=false,"Invalid side"end else bh,q=pcall(ccemux.attach,fy,_type,...)end else bh,q=false,"Operation not supported"end;return bh,q end;function syscalls.detach(process,at,fy)if process.user~="root"then error("Permission denied")end;expect(1,fy,"string","number")local bh,q;if periphemu then bh=periphemu.remove(fy)elseif ccemux then if type(fy)=="number"then fy=_type.."_"..fy end;bh,q=pcall(ccemux.detach,fy)else bh,q=false,"Operation not supported"end;return bh,q end;function syscalls.kernargs(process,at)return deepcopy(args)end;local fz=0;function syscalls.lockmutex(process,at,fA)expect(1,fA,"table")while fA.owner~=nil and fA.owner~=at.id or fA.pid~=nil and fA.pid~=process.id do coroutine.yield()end;if fA.owner then if type(fA.recursive)=="number"then fA.recursive=fA.recursive+1;return else error("cannot recursively lock mutex",0)end end;fA.owner=at.id;fA.pid=process.id;if fA.recursive then fA.recursive=1 end end;function syscalls.__timeout_check(process,at,info)if info.timeout then return false end;return syscalls[info.call](process,at,info.object,0)end;function syscalls.timelockmutex(process,at,fA,ex)expect(1,fA,"table")expect(2,ex,"number")if fA.owner then if fA.owner~=at.id then local fB=os.startTimer(ex)local info={object=fA,timeout=false,call="timelockmutex"}at.filter=function(process,at,au)if au[1]=="timer"and au[2].id==fB then info.timeout=true;return true end;return fA.owner==nil or fA.owner==at.id end;return kSyscallYield,"__timeout_check",info elseif type(fA.recursive)=="number"then fA.recursive=fA.recursive+1 else error("cannot recursively lock mutex",0)end else fA.owner=at.id;if fA.recursive then fA.recursive=1 end end;return true end;function syscalls.unlockmutex(process,at,fA)expect(1,fA,"table")if fA.owner==at.id and fA.pid==process.id then if type(fA.recursive)=="number"then fA.recursive=fA.recursive-1;if fA.recursive<=0 then fA.owner=nil end else fA.owner,fA.pid=nil end elseif fA.owner==nil then error("mutex already unlocked",0)else error("mutex not locked by current thread")end end;function syscalls.trylockmutex(process,at,fA)expect(1,fA,"table")if fA.owner then if fA.owner~=at.id or fA.pid~=process.id then return false elseif type(fA.recursive)=="number"then fA.recursive=fA.recursive+1;return true else error("cannot recursively lock mutex",0)end else fA.owner=at.id;fA.pid=process.id;if fA.recursive then fA.recursive=1 end;return true end end;function syscalls.acquiresemaphore(process,at,fC)expect(1,fC,"table")expect.field(fC,"count","number")while fC.count<=0 do coroutine.yield()end;fC.count=fC.count-1 end;function syscalls.timeacquiresemaphore(process,at,fC,ex)expect(1,fC,"table")expect.field(fC,"count","number")expect(2,ex,"number")if fC.count<=0 then local fB=os.startTimer(ex)local info={object=fC,timeout=false,call="timeacquiresemaphore"}at.filter=function(process,at,au)if au[1]=="timer"and au[2].id==fB then info.timeout=true;return true end;return type(fC.count)~="number"or fC.count>0 end;return kSyscallYield,"__timeout_check",info end;fC.count=fC.count-1;return true end;function syscalls.releasesemaphore(process,at,fC)expect(1,fC,"table")expect.field(fC,"count","number")fC.count=fC.count+1 end;local fD={name="root",type="computer",properties={"label","id"},methods={getLabel=function()end,setLabel=function(fE)end,getId=function()end,shutdown=function()end,reboot=function()end},init=function(dX)end,deinit=function(dX)end}local fF={top=true,bottom=true,left=true,right=true,front=true,back=true}local fG={}function getNodeById(o)if fF[o]then if deviceTreeRoot.children[o]then return deviceTreeRoot.children[o]end else for j in pairs(fF)do if peripheral.getType(j)=="modem"and not peripheral.call(j,"isWireless")and deviceTreeRoot.children[j]and deviceTreeRoot.children[j].children[o]then return deviceTreeRoot.children[j].children[o]end end end end;local function fH(self)self.internalState.peripheral=self.internalState.peripheral or{}if not self.internalState.peripheral.call then self.internalState.peripheral.call=peripheral.call end;if self.internalState.peripheral.call==peripheral.call or not self.parent then self.internalState.peripheral.getMethods=peripheral.getMethods else self.internalState.peripheral.getMethods=function(aD)return peripheral.call(self.parent.id,"getMethodsRemote",aD)end end end;local function fI(process,aE)aE.__metatable={}for B,k in pairs(aE)do setfenv(k,process.env)debug.protect(k)end;return setmetatable({},aE)end;local function fJ(fk,type)return function(dX)local fq,i;if dX.parent==deviceTreeRoot then fq,i={peripheral.getType(dX.id)},peripheral.call else fq,i={peripheral.call(dX.parent.id,"getTypeRemote",dX.id)},function(...)return peripheral.call(dX.parent.id,"callRemote",...)end end;for B,k in ipairs(fq)do if k==type then dX.internalState.peripheral={call=i}return hardware.register(dX,fk)end end end end;local function fK(type)return hardware.listen(fJ(fG["peripheral_"..type],type),deviceTreeRoot)end;local function fL(fn)return function(self)return self.internalState.peripheral.call(self.id,fn)end end;local function fM(fn)return function(self,process)if process.user~="root"then error("Permission denied",0)end;return self.internalState.peripheral.call(self.id,fn)end end;local function fN(fn)return function(...)local fq={...}return function(self,process,aI)expect(1,aI,table.unpack(fq))return self.internalState.peripheral.call(self.id,fn,aI)end end end;local function fO(fn)return function(...)local fq={...}return function(self,process,aI)expect(1,aI,table.unpack(fq))if process.user~="root"then error("Permission denied",0)end;return self.internalState.peripheral.call(self.id,fn,aI)end end end;local function fP()syslog.log("Sending SIGTERM to all processes")local fQ=false;for cZ,process in pairs(processes)do if cZ~=0 then killProcess(cZ,15)local fR,au=false,nil;local av=true;for eZ,at in pairs(process.threads)do if not fR and at.status=="suspended"then au=table.remove(process.eventQueue,1)fR=true end;if au or at.status~="suspended"then av=executeThread(process,at,au or{n=0},av,true)else av=false end end;if av then process.isDead=true;if process.parent~=0 and processes[process.parent]then processes[process.parent].eventQueue[#processes[process.parent].eventQueue+1]={"process_complete",process.lastReturnValue}wakeup(processes[process.parent])end;reap_process(process)processes[cZ]=nil else fQ=true end end end;terminal.redraw(currentTTY)if fQ then syslog.log("Sending SIGKILL to all processes")for cZ in pairs(processes)do if cZ~=0 then killProcess(cZ,9)end end end end;fG.root={name="root",type="computer",properties={"isOn","label"},methods={}}function fG.root.methods:getIsOn(process)return true end;function fG.root.methods:getLabel(process)return os.getComputerLabel()end;function fG.root.methods:setLabel(process,fE)expect(1,fE,"string","nil")os.setComputerLabel(fE)end;function fG.root.methods:turnOn(process)end;function fG.root.methods:shutdown(process,a7)if process.user~="root"then error("Permission denied",2)end;syslog.log("System is shutting down.")function postkill()hardware.deregister(deviceTreeRoot,fG.root)syslog.log("Halting system")for B,k in ipairs(shutdownHooks)do k()end;os.shutdown(a7)mainThread=nil;while true do coroutine.yield()end end;fP()end;function fG.root.methods:reboot(process)if process.user~="root"then error("Permission denied",2)end;syslog.log("System is restarting.")function postkill()hardware.deregister(deviceTreeRoot,fG.root)syslog.log("Rebooting system")for B,k in ipairs(shutdownHooks)do k()end;os.reboot()mainThread=nil;while true do coroutine.yield()end end;fP()end;function fG.root:init()local fS=hardware.add(self,"redstone")for B,k in ipairs{"top","bottom","left","right","front","back"}do local br=hardware.add(fS,k)br.internalState.redstone={side=k}hardware.register(br,fG.root_redstone)end;hardware.register(hardware.add(deviceTreeRoot,"lo"),fG.loopback_modem)registerLoopback()for k in pairs(fF)do if peripheral.isPresent(k)then hardware.add(self,k)end end;self.displayName=os.getComputerLabel()self.metadata.id=os.getComputerID()end;function fG.root:deinit()for k in pairs(fF)do if peripheral.isPresent(k)and self.children[k]then hardware.remove(self.children[k])end end;hardware.remove(hardware.get("/lo"))hardware.remove(hardware.get("/redstone"))end;eventHooks.peripheral=eventHooks.peripheral or{}eventHooks.peripheral[#eventHooks.peripheral+1]=function(au)if fF[au[2]]then local dX,q=hardware.add(deviceTreeRoot,au[2])if dX then hardware.broadcast(deviceTreeRoot,"device_added",{device=hardware.path(dX)})else syslog.log({level="error",module="Hardware"},"Could not create new device: "..q)end else for j in pairs(fF)do if peripheral.getType(j)=="modem"and not peripheral.call(j,"isWireless")and peripheral.call(j,"isPresentRemote",au[2])then if not deviceTreeRoot.children[j]then hardware.add(deviceTreeRoot,j)end;local dX,q=hardware.add(deviceTreeRoot.children[j],au[2])if dX then hardware.broadcast(deviceTreeRoot.children[j],"device_added",{device=hardware.path(dX)})else syslog.log({level="error",module="Hardware"},"Could not create new device: "..q)end;break end end end end;eventHooks.peripheral_detach=eventHooks.peripheral_detach or{}eventHooks.peripheral_detach[#eventHooks.peripheral_detach+1]=function(au)local dX=getNodeById(au[2])if not dX then syslog.log({level="notice",module="Hardware"},"Received "..au[1].." event for device ID "..au[2]..", but no device node was found; ignoring")return end;local g,c3=hardware.path(dX),dX.parent;hardware.remove(dX)hardware.broadcast(c3,"device_removed",{device=g})end;rootDriver=fG.root;fG.root_redstone={name="root_redstone",type="redstone",properties={"input","output","bundledInput","bundledOutput"},methods={}}local function fT(t)if t==0 then return nil else return t end end;function fG.root_redstone.methods:getInput()return fT(redstone.getAnalogInput(self.internalState.redstone.side))end;function fG.root_redstone.methods:getOutput()return fT(redstone.getAnalogOutput(self.internalState.redstone.side))end;function fG.root_redstone.methods:setOutput(process,t)t=expect(1,t,"number","boolean","nil")or 0;if t==false then t=0 elseif t==true then t=15 end;expect.range(t,0,15)redstone.setAnalogOutput(self.internalState.redstone.side,t)end;function fG.root_redstone.methods:getBundledInput()return redstone.getBundledInput(self.internalState.redstone.side)end;function fG.root_redstone.methods:getBundledOutput()return redstone.getBundledOutput(self.internalState.redstone.side)end;function fG.root_redstone.methods:setBundledOutput(process,t)expect(1,t,"number")expect.range(t,0,65535)redstone.setBundledOutput(self.internalState.redstone.side,t)end;function fG.root_redstone:init()if not self.internalState.redstone or not self.internalState.redstone.side then error("No assigned side on redstone device!",2)end;self.displayName="Redstone I/O on side "..self.internalState.redstone.side end;fG.peripheral_command={name="peripheral_command",type="command",properties={"command"},methods={}}fG.peripheral_command.methods.getCommand=fM"getCommand"fG.peripheral_command.methods.setCommand=fO"setCommand"("string")fG.peripheral_command.methods.run=fM"runCommand"function fG.peripheral_command:init()fH(self)self.displayName="Command block at "..self.id end;fK"command"fG.peripheral_computer={name="peripheral_computer",type="computer",properties={"isOn","label"},methods={}}fG.peripheral_computer.methods.getIsOn=fL"isOn"fG.peripheral_computer.methods.getLabel=fL"getLabel"fG.peripheral_computer.methods.turnOn=fM"turnOn"fG.peripheral_computer.methods.shutdown=fM"shutdown"fG.peripheral_computer.methods.reboot=fM"reboot"function fG.peripheral_command:init()fH(self)local fE=self.internalState.peripheral.call(self.id,"getLabel")self.metadata.id=self.internalState.peripheral.call(self.id,"getID")self.displayName=(fE or"Computer "..self.metadata.id).." at "..self.id end;fK"computer"hardware.listen(fJ(fG["peripheral_computer"],"turtle"),deviceTreeRoot)fG.peripheral_drive={name="peripheral_drive",type="drive",properties={"state","label"},methods={}}function fG.peripheral_drive.methods:getState(process)if not self.internalState.peripheral.call(self.id,"isDiskPresent")then return nil end;return{audio=self.internalState.peripheral.call(self.id,"getAudioTitle")or nil,label=self.internalState.peripheral.call(self.id,"getDiskLabel"),id=self.internalState.peripheral.call(self.id,"getDiskID")}end;fG.peripheral_drive.methods.getLabel=fL"getDiskLabel"fG.peripheral_drive.methods.setLabel=fN"setDiskLabel"("string","nil")fG.peripheral_drive.methods.getMountPath=fL"getMountPath"function fG.peripheral_drive.methods:play(process)if not self.internalState.peripheral.call(self.id,"hasAudio")then error("Inserted disk is not an audio disc",2)end;return self.internalState.peripheral.call(self.id,"playAudio")end;fG.peripheral_drive.methods.stop=fL"stopAudio"fG.peripheral_drive.methods.eject=fL"ejectDisk"fG.peripheral_drive.methods.insert=fO"insertDisk"("string")function fG.peripheral_drive:init()fH(self)self.displayName=(self.internalState.peripheral.call(self.id,"getDiskLabel")or"No disk").." on drive "..self.id end;fK"drive"eventHooks.disk=eventHooks.disk or{}eventHooks.disk[#eventHooks.disk+1]=function(au)local dX=getNodeById(au[2])if not dX then syslog.log({level="notice",module="Hardware"},"Received "..au[1].." event for device ID "..au[2]..", but no device node was found; ignoring")return end;hardware.broadcast(dX,"disk",{device=hardware.path(dX)})end;eventHooks.disk_eject=eventHooks.disk_eject or{}eventHooks.disk_eject[#eventHooks.disk_eject+1]=function(au)local dX=getNodeById(au[2])if not dX then syslog.log({level="notice",module="Hardware"},"Received "..au[1].." event for device ID "..au[2]..", but no device node was found; ignoring")return end;hardware.broadcast(dX,"disk_eject",{device=hardware.path(dX)})end;fG.peripheral_energy_storage={name="peripheral_energy_storage",type="energy_storage",properties={"energy"},methods={}}fG.peripheral_energy_storage.methods.getEnergy=fL"getEnergy"function fG.peripheral_energy_storage:init()fH(self)self.displayName="Energy storage block at "..self.id;self.metadata.capacity=self.internalState.peripheral.call(self.id,"getEnergyCapacity")end;fK"energy_storage"fG.peripheral_fluid_storage={name="peripheral_fluid_storage",type="fluid_storage",properties={"tanks"},methods={}}fG.peripheral_fluid_storage.methods.getTanks=fL"tanks"function fG.peripheral_fluid_storage.methods:push(process,bV,fU,o)expect(1,bV,"string")expect(2,fU,"number","nil")expect(3,o,"string","nil")local ev;local fV={hardware.get(bV)}if#fV==1 then ev=fV[1]else for B,k in ipairs(fV)do if k.parent==self.parent then ev=k;break end end end;if not ev then error("No such device",0)elseif ev.parent~=self.parent then error("Devices must be on the same network",0)end;local bh=false;for B,k in ipairs(ev.drivers)do if k==fG.peripheral_fluid_storage then bh=true;break end end;if not bh then error("Target device is not a fluid storage block",0)end;return self.internalState.peripheral.call(self.id,"pushFluid",ev.id,fU,o)end;function fG.peripheral_fluid_storage.methods:pull(process,bU,fU,o)expect(1,bU,"string")expect(2,fU,"number","nil")expect(3,o,"string","nil")local ev;local fV={hardware.get(bU)}if#fV==1 then ev=fV[1]else for B,k in ipairs(fV)do if k.parent==self.parent then ev=k;break end end end;if not ev then error("No such device",0)elseif ev.parent~=self.parent then error("Devices must be on the same network",0)end;local bh=false;for B,k in ipairs(ev.drivers)do if k==fG.peripheral_fluid_storage then bh=true;break end end;if not bh then error("Target device is not a fluid storage block",0)end;return self.internalState.peripheral.call(self.id,"pullFluid",ev.id,fU,o)end;function fG.peripheral_fluid_storage:init()fH(self)self.displayName="Fluid storage block at "..self.id end;fK"fluid_storage"fG.peripheral_inventory={name="peripheral_inventory",type="inventory",properties={"items"},methods={}}fG.peripheral_inventory.methods.getItems=fL"list"fG.peripheral_inventory.methods.detail=fN"getItemDetail"("number")fG.peripheral_inventory.methods.limit=fN"getItemLimit"("number")function fG.peripheral_inventory.methods:push(process,bV,fW,fU,fX)expect(1,bV,"string")expect(2,fW,"number")expect(3,fU,"number","nil")expect(4,fX,"number","nil")local ev;local fV={hardware.get(bV)}if#fV==1 then ev=fV[1]else for B,k in ipairs(fV)do if k.parent==self.parent then ev=k;break end end end;if not ev then error("No such device",0)elseif ev.parent~=self.parent then error("Devices must be on the same network",0)end;local bh=false;for B,k in ipairs(ev.drivers)do if k==fG.peripheral_inventory then bh=true;break end end;if not bh then error("Target device is not an inventory block",0)end;return self.internalState.peripheral.call(self.id,"pushItems",ev.id,fW,fU,fX)end;function fG.peripheral_inventory.methods:pull(process,bU,fW,fU,fX)expect(1,bU,"string")expect(2,fW,"number")expect(3,fU,"number","nil")expect(4,fX,"number","nil")local ev;local fV={hardware.get(bU)}if#fV==1 then ev=fV[1]else for B,k in ipairs(fV)do if k.parent==self.parent then ev=k;break end end end;if not ev then error("No such device",0)elseif ev.parent~=self.parent then error("Devices must be on the same network",0)end;local bh=false;for B,k in ipairs(ev.drivers)do if k==fG.peripheral_inventory then bh=true;break end end;if not bh then error("Target device is not an inventory block",0)end;return self.internalState.peripheral.call(self.id,"pullItems",ev.id,fW,fU,fX)end;function fG.peripheral_inventory:init()fH(self)self.displayName="Inventory at "..self.id;self.metadata.size=self.internalState.peripheral.call(self.id,"size")end;fK"inventory"fG.peripheral_monitor={name="peripheral_monitor",type="monitor",properties={"scale","size"},methods={}}fG.peripheral_monitor.methods.getScale=fL"getTextScale"fG.peripheral_monitor.methods.setScale=fN"setTextScale"("number")function fG.peripheral_monitor.methods:getSize()local ah,ai=self.internalState.peripheral.call(self.id,"getSize")return{width=ah,height=ai}end;function fG.peripheral_monitor.methods:write(process,...)for x,k in ipairs{...}do if x>1 then terminal.write(self.internalState.tty,"\t")end;terminal.write(self.internalState.tty,k)end;terminal.redraw(self.internalState.tty)end;function fG.peripheral_monitor.methods:termctl(process,dE)expect(1,dE,"table","nil")if dE then expect.field(dE,"cbreak","boolean","nil")expect.field(dE,"delay","boolean","nil")expect.field(dE,"echo","boolean","nil")expect.field(dE,"keypad","boolean","nil")expect.field(dE,"nlcr","boolean","nil")expect.field(dE,"raw","boolean","nil")for j,k in pairs(dE)do if self.internalState.tty.flags[j]~=nil then self.internalState.tty.flags[j]=k end end end;local A=deepcopy(self.internalState.tty.flags)A.hasgfx=term.getGraphicsMode~=nil;return A end;function fG.peripheral_monitor.methods:openterm(process)return terminal.openterm(self.internalState.tty,process)end;function fG.peripheral_monitor.methods:opengfx(process)return terminal.opengfx(self.internalState.tty,process)end;function fG.peripheral_monitor:init()fH(self)local ah,ai=self.internalState.peripheral.call(self.id,"getSize")local fY=self.internalState.peripheral.call(self.id,"getTextScale")self.displayName=ah*fY.."x"..ai*fY.." monitor at "..self.id;local term={}for B,k in ipairs(self.internalState.peripheral.getMethods(self.id))do term[k]=function(...)return self.internalState.peripheral.call(self.id,k,...)end end;self.internalState.tty=terminal.makeTTY(term,ah,ai)self.internalState.tty.isMonitor=true;terminal.redraw(self.internalState.tty,true)end;function fG.peripheral_monitor:deinit()local dp=self.internalState.tty;if dp.frontmostProcess then local k=dp.frontmostProcess;if k.stdin==dp then k.stdin=nil end;if k.stdout==dp then k.stdout=nil end;if k.stderr==dp then k.stderr=nil end end;for B,k in ipairs(dp.processList)do if k.stdin==dp then k.stdin=nil end;if k.stdout==dp then k.stdout=nil end;if k.stderr==dp then k.stderr=nil end end end;fK"monitor"eventHooks.monitor_resize=eventHooks.monitor_resize or{}eventHooks.monitor_resize[#eventHooks.monitor_resize+1]=function(au)local dX=getNodeById(au[2])if not dX then syslog.log({level="notice",module="Hardware"},"Received "..au[1].." event for device ID "..au[2]..", but no device node was found; ignoring")return end;local U=fG.peripheral_monitor.methods.getSize(dX)terminal.resize(dX.internalState.tty,U.width,U.height)hardware.broadcast(dX,"monitor_resize",{device=hardware.path(dX),width=U.width,height=U.height})end;fG.peripheral_printer={name="peripheral_printer",type="printer",properties={"inkLevel","paperLevel"},methods={}}fG.peripheral_printer.methods.getInkLevel=fL"getInkLevel"fG.peripheral_printer.methods.getPaperLevel=fL"getPaperLevel"function fG.peripheral_printer.methods:page(process)if self.internalState.printer.open then self.internalState.peripheral.call(self.id,"endPage")self.internalState.printer.open=false end;if not self.internalState.peripheral.call(self.id,"newPage")then return nil end;self.internalState.printer.open=true;local fZ,r,s;local function dD(...)if not self.internalState.printer.open then error("attempt to use closed page",2)end;return self.internalState.peripheral.call(self.id,"write",...)end;local function f_()if not self.internalState.printer.open then return true end;if not self.internalState.peripheral.call(self.id,"endPage")then return false end;self.internalState.printer.open=false end;setfenv(dD,process.env)setfenv(f_,process.env)debug.protect(dD)debug.protect(f_)return fI(process,{__index=function(B,aF)if not self.internalState.printer.open then error("attempt to use closed page",2)end;if aF=="size"then local v,dk=self.internalState.peripheral.call(self.id,"getPageSize")return fI(process,{__index=function(B,aF)if aF=="width"then return v elseif aF=="height"then return dk end end,__newindex=function()error("Cannot modify read-only table",2)end})elseif aF=="cursor"then r,s=self.internalState.peripheral.call(self.id,"getCursorPos")return fI(process,{__index=function(B,aF)if aF=="x"then return r elseif aF=="y"then return s end end,__newindex=function(B,aF,aG)if aF=="x"then r=aG;self.internalState.peripheral.call(self.id,"setCursorPos",r,s)elseif aF=="y"then s=aG;self.internalState.peripheral.call(self.id,"setCursorPos",r,s)else error("Cannot modify member '"..aF.."'",2)end end})elseif aF=="title"then return fZ elseif aF=="isOpen"then return self.internalState.printer.open elseif aF=="write"then return dD elseif aF=="close"then return f_ end end,__newindex=function(B,aF,aG)if not self.internalState.printer.open then error("attempt to use closed page",2)end;if aF=="cursor"then if type(aG)~="table"then error("bad value for 'cursor' (expected table, got "..type(aG)..")",2)end;expect.field(aG,"x","number")expect.field(aG,"y","number")r,s=aG.x,aG.y;self.internalState.peripheral.call(self.id,"setCursorPos",r,s)elseif aF=="title"then if type(aG)~="string"and aG~=nil then error("bad value for 'title' (expected string, got "..type(aG)..")",2)end;fZ=aG;self.internalState.peripheral.call(self.id,"setPageTitle",fZ)else error("Cannot modify member '"..aF.."'",2)end end})end;function fG.peripheral_printer:init()fH(self)self.displayName="Speaker at "..self.id;self.internalState.printer={open=false}end;fK"printer"local g0={name="peripheral_redstone_relay_side",type="redstone",properties={"input","output","bundledInput","bundledOutput"},methods={}}function g0.methods:getInput()return fT(self.internalState.peripheral.call(self.id,"getAnalogInput",self.internalState.redstone.side))end;function g0.methods:getOutput()return fT(self.internalState.peripheral.call(self.id,"getAnalogOutput",self.internalState.redstone.side))end;function g0.methods:setOutput(process,t)t=expect(1,t,"number","boolean","nil")or 0;if t==false then t=0 elseif t==true then t=15 end;expect.range(t,0,15)self.internalState.peripheral.call(self.id,"setAnalogOutput",self.internalState.redstone.side,t)end;function g0.methods:getBundledInput()return self.internalState.peripheral.call(self.id,"getBundledInput",self.internalState.redstone.side)end;function g0.methods:getBundledOutput()return self.internalState.peripheral.call(self.id,"getBundledOutput",self.internalState.redstone.side)end;function g0.methods:setBundledOutput(process,t)expect(1,t,"number")expect.range(t,0,65535)return self.internalState.peripheral.call(self.id,"setBundledOnput",self.internalState.redstone.side,t)end;function g0:init()if not self.internalState.redstone or not self.internalState.redstone.side then error("No assigned side on redstone device!",2)end;self.displayName="Redstone Relay '"..self.id.."' on side "..self.internalState.redstone.side end;fG.peripheral_redstone_relay={name="peripheral_redstone_relay",type="redstone_relay",properties={},methods={}}function fG.peripheral_redstone_relay:init()for B,k in ipairs{"top","bottom","left","right","front","back"}do local br=hardware.add(self,k)br.internalState.redstone={side=k}hardware.register(br,g0)end end;fK"redstone_relay"fG.peripheral_speaker={name="peripheral_speaker",type="speaker",properties={},methods={}}function fG.peripheral_speaker.methods:playNote(process,g1,g2,g3)expect(1,g1,"string")expect(2,g2,"number","nil")expect(3,g3,"number","nil")if g2 then expect.range(g2,0,3)end;if g3 then expect.range(g3,0,24)end;return self.internalState.peripheral.call(self.id,"playNote",g1,g2,g3)end;function fG.peripheral_speaker.methods:playSound(process,o,g2,g4)expect(1,o,"string")expect(2,g2,"number","nil")expect(3,g4,"number","nil")if g2 then expect.range(g2,0,3)end;if g4 then expect.range(g4,0.5,2.0)end;return self.internalState.peripheral.call(self.id,"playNote",o,g2,g4)end;function fG.peripheral_speaker.methods:playAudio(g5,g2)expect(1,g5,"table")expect(2,g2,"number","nil")if g2 then expect.range(g2,0,3)end;return self.internalState.peripheral.call(self.id,"playAudio",g5,g2)end;fG.peripheral_speaker.methods.stop=fL"stop"function fG.peripheral_speaker:init()fH(self)self.displayName="Speaker at "..self.id end;fK"speaker"eventHooks.speaker_audio_empty=eventHooks.speaker_audio_empty or{}eventHooks.speaker_audio_empty[#eventHooks.speaker_audio_empty+1]=function(au)local dX=getNodeById(au[2])if not dX then syslog.log({level="notice",module="Hardware"},"Received "..au[1].." event for device ID "..au[2]..", but no device node was found; ignoring")return end;hardware.broadcast(dX,"speaker_audio_empty",{device=hardware.path(dX)})end;local g6={fG.peripheral_command,fG.peripheral_computer,fG.peripheral_drive,fG.peripheral_energy_storage,fG.peripheral_fluid_storage,fG.peripheral_inventory,fG.peripheral_monitor,fG.peripheral_printer,fG.peripheral_speaker}function registerDriver(fk)local g7=fk.init;fk.init=function(dX)fH(dX)if g7 then return g7(dX)end end;fk.__callback=fJ(fk,fk.type)hardware.listen(fk.__callback,deviceTreeRoot)g6[#g6+1]=fk;for B,dX in ipairs{hardware.find("modem")}do if not dX.metadata.wireless then hardware.listen(fk.__callback,dX)dX.internalState.modem.callbacks[#dX.internalState.modem.callbacks+1]=f end end end;function deregisterDriver(fk)if not fk.__callback then return end;hardware.unlisten(fk.__callback)for B,k in ipairs{hardware.find(fk.type)}do hardware.deregister(k,fk)end;for x,k in ipairs(fF)do if k==fk then table.remove(fF,x)break end end;for B,dX in ipairs{hardware.find("modem")}do if not dX.metadata.wireless then hardware.unlisten(fk.__callback)for x,k in ipairs(dX.internalState.modem.callbacks)do if k==fk.__callback then table.remove(dX.internalState.modem.callbacks,x)break end end end end end;fG.peripheral_modem={name="peripheral_modem",type="modem",properties={"remainingChannels"},methods={}}function fG.peripheral_modem.methods:getRemainingChannels()local b=128;for B in pairs(self.internalState.modem)do b=b-1 end;return b end;function fG.peripheral_modem.methods:open(process,g8)if not self.internalState.modem[g8]then self.internalState.peripheral.call(self.id,"open",g8)self.internalState.modem[g8]={}end;self.internalState.modem[g8][process]=true end;function fG.peripheral_modem.methods:isOpen(process,g8)return self.internalState.modem[g8]and self.internalState.modem[g8][process]end;function fG.peripheral_modem.methods:close(process,g8)self.internalState.modem[g8][process]=nil;if not next(self.internalState.modem[g8])then self.internalState.peripheral.call(self.id,"close",g8)self.internalState.modem[g8]=nil end end;function fG.peripheral_modem.methods:closeAll(process)for g8=0,65535 do self.internalState.modem[g8][process]=nil;if not next(self.internalState.modem[g8])then self.internalState.peripheral.call(self.id,"close",g8)self.internalState.modem[g8]=nil end end end;function fG.peripheral_modem.methods:transmit(process,g8,g9,ga)expect(1,g8,"number")g9=expect(2,g9,"number","nil")or g8;return self.internalState.peripheral.call(self.id,"transmit",g8,g9,ga)end;function fG.peripheral_modem:init()fH(self)self.metadata.wireless=self.internalState.peripheral.call(self.id,"isWireless")self.displayName=(self.metadata.wireless and"Wireless"or"Wired").." modem at "..self.id;self.internalState.modem={}self.internalState.modem.channels={}self.internalState.peripheral.call(self.id,"closeAll")if not self.metadata.wireless then self.internalState.modem.callbacks={}for B,k in ipairs(g6)do local f=fJ(k,k.type)hardware.listen(f,self)self.internalState.modem.callbacks[#self.internalState.modem.callbacks+1]=f end;local f=fJ(fG["peripheral_computer"],"turtle")hardware.listen(f,self)self.internalState.modem.callbacks[#self.internalState.modem.callbacks+1]=f;for B,o in ipairs(self.internalState.peripheral.call(self.id,"getNamesRemote"))do hardware.add(self,o)end end end;function fG.peripheral_modem:deinit()if not self.metadata.wireless then for B,k in ipairs(self.internalState.modem.callbacks)do hardware.unlisten(k)end end end;fK"modem"eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(au)local dX=getNodeById(au[2])or hardware.get(au[2])if not dX then syslog.log({level="notice",module="Hardware"},"Received "..au[1].." event for device ID "..au[2]..", but no device node was found; ignoring")return end;local a7=false;for k in pairs(dX.listeners)do if(dX.internalState.modem[au[3]]or{})[k]then k.eventQueue[#k.eventQueue+1],a7={"modem_message",{device=hardware.path(dX),channel=au[3],replyChannel=au[4],message=au[5],distance=au[6]}},true;wakeup(k)end end;return a7 end;fG.loopback_modem={name="loopback_modem",type="modem",properties={"remainingChannels"},methods={}}function fG.loopback_modem.methods:getRemainingChannels()local b=128;for B in pairs(self.internalState.modem)do b=b-1 end;return b end;function fG.loopback_modem.methods:open(process,g8)if not self.internalState.modem[g8]then self.internalState.modem[g8]={}end;self.internalState.modem[g8][process]=true end;function fG.loopback_modem.methods:isOpen(process,g8)return self.internalState.modem[g8]and self.internalState.modem[g8][process]end;function fG.loopback_modem.methods:close(process,g8)self.internalState.modem[g8][process]=nil;if not next(self.internalState.modem[g8])then self.internalState.modem[g8]=nil end end;function fG.loopback_modem.methods:closeAll(process)for g8=0,65535 do self.internalState.modem[g8][process]=nil;if not next(self.internalState.modem[g8])then self.internalState.modem[g8]=nil end end end;function fG.loopback_modem.methods:transmit(process,g8,g9,ga)expect(1,g8,"number")g9=expect(2,g9,"number","nil")or g8;os.queueEvent("modem_message",self.uuid,g8,g9,ga,0)end;function fG.loopback_modem:init()self.metadata.wireless=true;self.displayName="Loopback modem"self.internalState.modem={}self.internalState.modem.channels={}end;local function gb(gc)local info={scheme=""}for ab in gc:gmatch"."do if info.fragment then if ab:match"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/?]"then info.fragment=info.fragment..ab else error("Invalid URI",3)end elseif info.query then if ab=="#"then info.fragment=""elseif ab:match"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/?]"then info.query=info.query..ab else error("Invalid URI",3)end elseif info.path then if ab=="/"and info.path=="/"and not info.host then info.path,info.host=nil,""elseif ab=="?"then info.query=""elseif ab=="#"then info.fragment=""elseif ab:match"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/]"then info.path=info.path..ab else error("Invalid URI",3)end elseif info.port then if tonumber(ab)then info.port=info.port..ab elseif ab=="/"then info.path="/"else error("Invalid URI",3)end elseif info.host then if ab=="@"and not info.user then info.user,info.host=info.host,""elseif ab==":"then info.port=""elseif ab=="/"then info.path="/"elseif ab:match"[%w%-%._~%%/!%$&'%(%)%*%+,;=]"then info.host=info.host..ab else error("Invalid URI",3)end else if ab==":"then info.path=""elseif ab:match(info.scheme==""and"[%a%+%-%.]"or"[%w%+%-%.]")then info.scheme=info.scheme..ab else error("Invalid URI",3)end end end;if info.port then info.port=tonumber(info.port)end;return info end;local function gd(ge)if ge:match"^%d+$"then return tonumber(ge)elseif ge:match"^%d+%.%d+$"then return tonumber(ge:match"^%d+")*0x1000000+tonumber(ge:match"^%d+%.(%d+)")elseif ge:match"^%d+%.%d+%.%d+$"then return tonumber(ge:match"^(%d+)")*0x1000000+tonumber(ge:match"^%d+%.(%d+)")*0x10000+tonumber(ge:match"^%d+%.%d+%.(%d+)")elseif ge:match"^%d+%.%d+%.%d+%.%d+$"then return tonumber(ge:match"^(%d+)")*0x1000000+tonumber(ge:match"^%d+%.(%d+)")*0x10000+tonumber(ge:match"^%d+%.%d+%.(%d+)")*0x100+tonumber(ge:match"^%d+%.%d+%.%d+%.(%d+)")else error("Invalid IP address",2)end end;local function gf(b)if not b then return nil end;return("%d.%d.%d.%d"):format(bit32.band(bit32.rshift(b,24),0xFF),bit32.band(bit32.rshift(b,16),0xFF),bit32.band(bit32.rshift(b,8),0xFF),bit32.band(b,0xFF))end;local function gg(gh)local bt=""for x=1,gh do bt=bt..string.char(math.random(0,255))end;return bt end;local function gi(b)return bit32.bnot(2^(32-b)-1)end;local function gj(y)local t=0;while bit32.btest(y,0x80000000)do y,t=bit32.lshift(y,1),t+1 end;return t end;local function gk(dX)if not dX then error("No such device")end;for B,k in pairs(dX.drivers)do if k.type=="modem"then return dX end end;error("Not a modem")end;local gl=0;local gm={}local gn={maxn=0,[0]={}}local go={}local gp={send={},recv={}}local gq={}local gr={}local gs=setmetatable({},{__mode="k"})local gt={arp={},socket={}}local gu={}function gp.send.link(info,gv,ag)expect(2,gv,"number","nil")expect.field(info,"device","table")local bB={PhoenixNetworking=true,type="link",source=os.computerID(),destination=gv,payload=ag}if gv==os.computerID()then os.queueEvent("modem_message",info.device.id,info.outPort or 0,info.inPort or 0,bB,0)else hardware.call(info.process or KERNEL,info.device,"transmit",info.outPort or 0,info.inPort or 0,bB)end end;function gp.send.arp_request(info,ge)expect.field(info,"device","table")expect(2,ge,"string")hardware.call(info.process or KERNEL,info.device,"transmit",0,0,{PhoenixNetworking=true,type="arp",reply=false,source=os.computerID(),sourceIP=gm[info.device.uuid]and gf(gm[info.device.uuid].ip),destinationIP=ge})end;function gp.send.arp_reply(info,gv,gw)expect.field(info,"device","table")expect(2,gv,"number")expect(3,gw,"string","nil")hardware.call(info.process or KERNEL,info.device,"transmit",0,0,{PhoenixNetworking=true,type="arp",reply=true,source=os.computerID(),sourceIP=gf(gm[info.device.uuid].ip),destination=gv,destinationIP=gw})end;function gp.send.internet(info,gv,ag,gx)expect(2,gv,"number")local ep={PhoenixNetworking=true,type="internet",hopsLeft=gx or 15,payload=ag,destination=gf(gv)}local aD=gg(32)ep.messageID=aD;local k;for x=gn.maxn,0,-1 do if gn[x]then for B,gy in ipairs(gn[x])do if bit32.band(gy.source,gy.sourceNetmask)==bit32.band(gv,gy.sourceNetmask)and(not k or gj(gy.sourceNetmask)>gj(k.sourceNetmask))then k=gy end end end end;if not k then return gp.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="No route to host",payload=ep})end;if k.action=="unicast"and gm[k.device.uuid]and gm[k.device.uuid].up then info.device=k.device;ep.source=gf(gm[k.device.uuid].ip)if go[k.device.uuid]and go[k.device.uuid][k.destination]then return gp.send.link(info,go[k.device.uuid][k.destination],ep)end;local gz=false;local fB;local function gA(B,ge,bF)if not gz and gd(ge)==k.destination then gz=true;gp.send.link(info,bF,ep)end;if gz then for x,f in ipairs(gt.arp)do if f==gA then table.remove(gt.arp,x)break end end end end;local function gB(au)if au[2]==fB then if not gz then gp.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="No route to host",payload=ep})end;gz=true;for x,ah in ipairs(eventHooks.timer)do if ah==gB then table.remove(eventHooks.timer,x)break end end;for x,f in ipairs(gt.arp)do if f==gA then table.remove(gt.arp,x)break end end end end;gt.arp[#gt.arp+1]=gA;gp.send.arp_request(info,gf(k.destination))eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=gB;fB=os.startTimer(2)return elseif k.action=="broadcast"and gm[k.device.uuid]and gm[k.device.uuid].up then info.device=k.device;ep.source=gf(gm[k.device.uuid].ip)return gp.send.link(info,nil,ep)elseif k.action=="local"and gm[k.device.uuid]and gm[k.device.uuid].up then info.device=k.device;ep.source=gf(gm[k.device.uuid].ip)if go[k.device.uuid]and go[k.device.uuid][gv]then return gp.send.link(info,go[k.device.uuid][gv],ep)end;local gz=false;local fB;local function gA(B,ge,bF)if not gz and gd(ge)==gv then gz=true;gp.send.link(info,bF,ep)end;if gz then for x,f in ipairs(gt.arp)do if f==gA then table.remove(gt.arp,x)break end end end end;local function gB(au)if au[2]==fB then if not gz then gp.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="No route to host",payload=ep})end;gz=true;for x,ah in ipairs(eventHooks.timer)do if ah==gB then table.remove(eventHooks.timer,x)break end end end end;gt.arp[#gt.arp+1]=gA;gp.send.arp_request(info,gf(gv))eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=gB;fB=os.startTimer(2)return elseif k.action=="unreachable"then return gp.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="Destination unreachable",payload=ep})elseif k.action=="prohibit"then return gp.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="Prohibited",payload=ep})elseif k.action=="blackhole"then return end end;function gp.send.control(info,gv,type,q,gC,gx)expect(3,type,"string")expect(4,q,"string","nil")return gp.send.internet(info,gv,{PhoenixNetworking=true,type="control",messageType=type,error=q,payload=gC},gx)end;gp.send.socket={}function gp.send.socket.connect(info,ge,gD,gE)for x=1,16384 do local G=math.random(49152,65535)if not gq[G]or not gq[G][gD]then gE.localPort=G;break end end;if not gE.localPort then error("Too many open sockets")end;gE.id=gl;gl=gl+1;gE.ip=ge;gE.port=gD;gE.sendSeq=math.floor(math.random()*0x10000000000)gE.sendSeqNext=gE.sendSeq+2;gE.sendSeqMax=gE.sendSeq+256;info.outPort=gD;info.inPort=gE.localPort;gs[gE]=function(G)if G.type=="control"and G.payload.destination==gf(ge)then gE.status="error"gE.error=G.error;return true end;return false end;gp.send.internet(info,ge,{PhoenixNetworking=true,type="socket",sequence=gE.sendSeqNext-1,windowSize=256,synchronize=true})local bh,q=pcall(hardware.call,info.process or KERNEL,info.device,"open",gE.localPort)if not bh then gp.send.internet(info,ge,{PhoenixNetworking=true,type="socket",sequence=gE.sendSeqNext,windowSize=0,reset=true})gE.status="error"gE.error=q;return false end;gE.status="syn-sent"gE.nextUpdate=os.epoch"utc"+5000;gE.process=info.process;gE.retryCount=0;gq[gE.localPort]=gq[gE.localPort]or{}gq[gE.localPort][gD]=gE;gr[gE.id]=gE end;function gp.send.socket.data(info,ag,gE)info.outPort=gE.port;info.inPort=gE.localPort;ag.PhoenixNetworking=true;ag.type="socket"if not ag.sequence then ag.sequence=gE.sendSeqNext;gE.sendSeqNext=gE.sendSeqNext+1 end;ag.acknowledgement=ag.acknowledgement or gE.recvSeq-1;gE.nextAck=nil;if not ag.final then ag.windowSize=256 end;return gp.send.internet(info,gE.ip,ag)end;function gp.send.socket.ack(info,b,gE)return gp.send.socket.data(info,{acknowledgement=b},gE)end;function gp.send.socket.reset(info,ge,gD,gF,gG,gH)info.outPort=gD;info.inPort=gH or gD;return gp.send.internet(info,ge,{PhoenixNetworking=true,type="socket",sequence=gF,acknowledgement=gG,reset=true})end;local function gI(gE,p,...)p=p or"*l"if type(p)~="string"and type(p)~="number"then error("bad argument (expected string or number, got "..type(p)..")",2)end;if gE.buffer==""then return nil end;p=p:gsub("^%*","")if p=="a"then local a2=gE.buffer;gE.buffer=""return a2 elseif p=="l"then local a2,a9=gE.buffer:match"^([^\n]*)\n?()"if a2 then gE.buffer=gE.buffer:sub(a9)if select("#",...)>0 then return a2,gI(gE,...)else return a2 end else return nil end elseif p=="L"then local a2,a9=gE.buffer:match"^([^\n]*\n?)()"if a2 then gE.buffer=gE.buffer:sub(a9)if select("#",...)>0 then return a2,gI(gE,...)else return a2 end else return nil end elseif p=="n"then local a2,a9=gE.buffer:match"(%d+)()"if a2 then gE.buffer=gE.buffer:sub(a9)if select("#",...)>0 then return tonumber(a2),gI(gE,...)else return tonumber(a2)end else return nil end elseif type(p)=="number"then local a2=gE.buffer:sub(1,p)gE.buffer=gE.buffer:sub(p+1)if select("#",...)>0 then return a2,gI(gE,...)else return a2 end else error("bad argument (invalid mode '"..p.."')",2)end end;local function gJ(gE,bk,...)bk=tostring(bk)gE.outQueue[gE.sendSeqNext]=bk;gp.send.socket.data({},{payload=bk},gE)if select("#",...)>0 then return gJ(gE,...)end end;function syscalls.__socketcall(process,at,aD,fn,...)local gE=gr[aD]if not gE then error("No such socket")end;local gK=process;while process~=gE.process do if process==nil then error("No such socket")end;process=processes[process.parent or-1]end;if fn=="close"then gE.sendSeqMax=gE.sendSeqNext;gp.send.socket.data({},{final=true},gE)gE.status="fin-wait"elseif fn=="read"then return gI(gE,...)elseif fn=="write"then return gJ(gE,...)elseif fn=="transfer"then gE.process=gK else error("No such method")end end;local do_syscall=do_syscall;local function gL(gE)local bB=setmetatable({id=gE.id},{__name="socket"})function bB:localIP()return gE.localIP end;function bB:status()if gE.status=="listening"or gE.status=="syn-sent"or gE.status=="syn-received"then return"connecting"elseif gE.status=="connected"or gE.buffer~=""then return"open"elseif gE.status=="error"then return"error",gE.error else return"closed"end end;function bB:read(p,...)if gE.status~="connected"and gE.status~="close-wait"and gE.status~="closed"then error("attempt to read from a "..gE.status.." handle",2)end;return do_syscall("__socketcall",gE.id,"read",p,...)end;function bB:write(bk,...)if gE.status~="connected"then error("attempt to write to a "..gE.status.." handle",2)end;return do_syscall("__socketcall",gE.id,"write",bk,...)end;function bB:close()if gE.status=="closing"or gE.status=="fin-wait"or gE.status=="closed"then return end;if not(gE.status=="listening"or gE.status=="syn-sent"or gE.status=="syn-received"or gE.status=="connected")then error("attempt to close a "..gE.status.." handle",2)end;return do_syscall("__socketcall",gE.id,"close")end;function bB:transfer()return do_syscall("__socketcall",gE.id,"transfer")end;return bB end;function gp.recv.link(info,ag)expect.field(ag,"source","number")expect.field(ag,"destination","number")expect.field(ag,"payload","table")syslog.debug("Received link message from",ag.source,"to",ag.destination)if ag.destination~=os.computerID()then return end;info.sourceID=ag.source;assert(ag.payload.PhoenixNetworking)expect.field(ag.payload,"type","string")if not gp.recv[ag.payload.type]then error("Unknown protocol '"..ag.payload.type.."'")end;return gp.recv[ag.payload.type](info,ag.payload)end;function gp.recv.arp(info,ag)expect.field(ag,"source","number")expect.field(ag,"reply","boolean")syslog.debug("Received arp message from",ag.source)if not ag.reply and ag.destinationIP and ag.sourceIP~=ag.destinationIP then local ge=gd(expect.field(ag,"destinationIP","string"))if gm[info.device.uuid]and gm[info.device.uuid].ip==ge then gp.send.arp_reply(info,ag.source,ag.sourceIP)end end;if ag.sourceIP then local ge=gd(expect.field(ag,"sourceIP","string"))go[info.device.uuid]=go[info.device.uuid]or{}go[info.device.uuid][ge]=ag.source;local gM={}for x,k in ipairs(gt.arp)do gM[x]=k end;for B,k in ipairs(gM)do k(k,ag.sourceIP,ag.source)end end end;function gp.recv.internet(info,ag)info.sourceIP=gd(expect.field(ag,"source","string"))local bF=gd(expect.field(ag,"destination","string"))info.localIP=bF;syslog.debug("Received internet message from",ag.source,"to",ag.destination)expect.field(ag,"payload","table")if gu[expect.field(ag,"messageID","number","string")]then return end;gu[ag.messageID]=os.epoch"utc"if not gm[info.device.uuid]or gm[info.device.uuid].ip~=bF then local a7=false;for B,k in pairs(gs)do a7=k(ag)or a7 end;return a7 end;info.ipPacket=ag;assert(ag.payload.PhoenixNetworking)expect.field(ag.payload,"type","string")if not gp.recv[ag.payload.type]then error("Unknown protocol '"..ag.payload.type.."'")end;return gp.recv[ag.payload.type](info,ag.payload)end;function gp.recv.control(info,ag)expect.field(ag,"messageType","string")syslog.debug("Received control message",ag.messageType)local a7=false;if ag.messageType=="ping"then gp.send.control({device=info.device},info.sourceIP,"pong",nil,info.ipPacket)else for B,k in pairs(gs)do a7=k{type="control",messageType=ag.messageType,error=ag.error,payload=ag.payload,sender=gf(info.sourceIP)}or a7 end end;return a7 end;function gp.recv.socket(info,ag)expect.field(ag,"sequence","number")expect.field(ag,"acknowledgement","number","nil")expect.field(ag,"windowSize","number","nil")expect.field(ag,"payload","string","nil")if info.channel==0 or info.replyChannel==0 then syslog.debug("Received socket event on channel 0; discarding.")return end;local gE=(gq[info.channel]or{})[info.replyChannel]or(gq[info.channel]or{}).listen;if not gE then if ag.acknowledgement then gp.send.socket.reset(info,info.sourceIP,info.replyChannel,ag.acknowledgement,nil,info.channel)else gp.send.socket.reset(info,info.sourceIP,info.replyChannel,0,ag.sequence+(ag.windowSize or 0),info.channel)end;return end;do local bt={}for j,k in pairs(gE)do if j~="process"then bt[j]=k end end;syslog.debug("Received socket message:",serialize(ag),"\nSocket info:",serialize(bt))end;if gE.status=="listening"then if ag.reset then return end;if ag.acknowledgement then gp.send.socket.reset(info,info.sourceIP,info.replyChannel,ag.acknowledgement,nil,info.channel)return end;if not ag.synchronize then return end;gE.ip=info.sourceIP;gE.localIP=gf(info.localIP)gE.port=info.replyChannel;gE.recvSeq=ag.sequence+1;gE.recvSeqMax=gE.recvSeq+(ag.windowSize or 0)gE.sendSeq=math.floor(math.random()*0x10000000000)gE.sendSeqNext=gE.sendSeq+2;gE.sendSeqMax=gE.sendSeq+(ag.windowSize or 0)gE.status="syn-received"gE.nextUpdate=os.epoch"utc"+5000;gE.retryCount=0;gq[info.channel][info.replyChannel]=gE;gq[info.channel].listen=nil;gp.send.internet({inPort=info.channel,outPort=info.replyChannel},gE.ip,{PhoenixNetworking=true,type="socket",sequence=gE.sendSeqNext-1,acknowledgement=gE.recvSeq,windowSize=256,synchronize=true})elseif gE.status=="syn-sent"then if ag.reset then gE.status="error"gE.error="Connection refused"gq[info.channel][info.replyChannel]=nil;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={"handle_status_change",{id=gE.id,status="error"}}end;return true end;if not ag.synchronize or not ag.acknowledgement or ag.acknowledgement<gE.sendSeq then gp.send.socket.reset(info,info.sourceIP,info.replyChannel,ag.acknowledgement,nil,info.channel)gE.status="error"gE.error="Connection refused"gq[info.channel][info.replyChannel]=nil;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={"handle_status_change",{id=gE.id,status="error"}}end;return true end;gE.localIP=gf(info.localIP)gE.status="connected"gE.sendSeq=ag.acknowledgement;gE.sendSeqMax=gE.sendSeq+256;gE.recvSeq=ag.sequence+1;gE.recvSeqMax=gE.recvSeq+(ag.windowSize or 0)gE.outQueue={}gE.nextUpdate=os.epoch"utc"+2000;gp.send.socket.ack({},gE.recvSeq,gE)if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={"handle_status_change",{id=gE.id,status="connected"}}end;return true else if ag.sequence<gE.recvSeq or ag.sequence>gE.recvSeqMax then syslog.debug("Sequence out of range")if ag.reset then gE.status="error"gE.error="Connection reset by peer"gq[info.channel][info.replyChannel]=nil;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={"handle_status_change",{id=gE.id,status="error"}}end;return true else gp.send.socket.ack({},gE.recvSeq,gE)return end end;if ag.reset then syslog.debug("Received reset")if gE.status=="syn-received"then gE.status="listening"return elseif gE.status=="connected"or gE.status=="fin-wait"then gE.status="error"gE.error="Connection reset by peer"gq[info.channel][info.replyChannel]=nil;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={"handle_status_change",{id=gE.id,status="error"}}end;return true else gE.status="closed"gq[info.channel][info.replyChannel]=nil;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={"handle_status_change",{id=gE.id,status="closed"}}end;return true end end;if ag.synchronize then gp.send.socket.reset(info,info.sourceIP,info.replyChannel,ag.acknowledgement,nil,info.channel)gE.status="error"gE.error="Connection reset by host"gq[info.channel][info.replyChannel]=nil;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={"handle_status_change",{id=gE.id,status="error"}}end;return true end;local a7;if not ag.acknowledgement then syslog.debug("No acknowledgement")return end;if gE.status=="syn-received"then if ag.acknowledgement>=gE.sendSeq and ag.acknowledgement<=gE.sendSeqNext then gE.status="connected"gE.outQueue={}gE.nextUpdate=os.epoch"utc"+2000;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={"network_request",{uri=gE.uri,ip=gf(info.sourceIP),handle=gL(gE)}}end;a7=true else gp.send.socket.reset(info,info.sourceIP,info.replyChannel,ag.acknowledgement,nil,info.channel)gE.status="error"gE.error="Connection reset by host"gq[info.channel][info.replyChannel]=nil;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={"handle_status_change",{id=gE.id,status="error"}}end;return true end elseif gE.status=="close-wait"then if ag.acknowledgement==gE.sendSeqMax then syslog.debug("Socket closed")gE.status="closed"gq[info.channel][info.replyChannel]=nil;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={"handle_status_change",{id=gE.id,status="closed"}}end;return true end elseif gE.status=="time-wait"then if ag.final then gp.send.socket.ack({},ag.sequence,gE)gE.nextUpdate=os.epoch"utc"+10000;return end else if ag.acknowledgement>gE.sendSeq and ag.acknowledgement<=gE.sendSeqNext then for x=gE.sendSeq,ag.acknowledgement do gE.outQueue[x]=nil end;gE.sendSeq=ag.acknowledgement;if ag.windowSize then gE.sendSeqMax=gE.sendSeq+ag.windowSize end end;if gE.status=="fin-wait"then if ag.acknowledgement==gE.sendSeqMax then if not ag.final then gp.send.socket.reset(info,info.sourceIP,info.replyChannel,ag.acknowledgement,nil,info.channel)gE.status="error"gE.error="Connection reset by host"gq[info.channel][info.replyChannel]=nil;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={"handle_status_change",{id=gE.id,status="error"}}end;return true end;gE.status="time-wait"gE.nextUpdate=os.epoch"utc"+10000 end elseif gE.status=="closing"then if ag.acknowledgement==gE.sendSeqMax then gE.status="time-wait"gE.nextUpdate=os.epoch"utc"+10000 end end end;if gE.status=="connected"and ag.sequence==gE.recvSeq then if ag.payload then gE.buffer=gE.buffer..ag.payload;gE.nextAck=true;gE.nextUpdate=os.epoch"utc"+100;if gE.process then syslog.debug("Sending data event to PID "..gE.process.id)gE.process.eventQueue[#gE.process.eventQueue+1]={"handle_data_ready",{id=gE.id}}end;a7=true end;gE.recvSeq=gE.recvSeq+1 end;if ag.final then syslog.debug("Got final message")gE.recvSeq=ag.sequence+1;if gE.status=="syn-received"or gE.status=="connected"then gE.sendSeqMax=gE.sendSeqNext;gp.send.socket.data({},{final=true,acknowledgement=ag.sequence},gE)gE.status="close-wait"if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={"handle_status_change",{id=gE.id,status="closed"}}end;return true elseif gE.status=="fin-wait"then gp.send.socket.ack({},ag.sequence,gE)if ag.acknowledgement~=gE.sendSeqMax then gE.status="closing"else gE.status="time-wait"gE.nextUpdate=os.epoch"utc"+10000 end else gp.send.socket.ack({},ag.sequence,gE)end;syslog.debug(gE.status)end;return a7 end end;local function gN()local ca=os.epoch"utc"local cd=false;for gD,be in pairs(gq)do for gO,gE in pairs(be)do if ca>=gE.nextUpdate then if gE.status=="syn-sent"then gE.status="error"gE.error="Connection timed out (syn-sent)"gq[gD][gO]=nil;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={"handle_status_change",{id=gE.id,status="error"}}cd=true end elseif gE.status=="syn-received"then gE.retryCount=gE.retryCount+1;if gE.retryCount>3 then gE.status="error"gE.error="Connection timed out (syn-received)"gq[gD][gO]=nil;if gE.process then gE.process.eventQueue[#gE.process.eventQueue+1]={"handle_status_change",{id=gE.id,status="error"}}cd=true end else gE.nextUpdate=os.epoch"utc"+2000 end elseif gE.status=="connected"then for x=gE.sendSeq+1,gE.sendSeqNext-1 do if gE.outQueue[x]then gp.send.socket.data({},{sequence=x,payload=gE.outQueue[x]},gE)end end;if gE.nextAck then gp.send.socket.ack({},gE.recvSeq-1,gE)gE.nextAck=nil end;gE.nextUpdate=os.epoch"utc"+2000 elseif gE.status=="fin-wait"then elseif gE.status=="close-wait"then elseif gE.status=="time-wait"then syslog.debug("Time wait finished on port "..gD)gE.status="closed"gq[gD][gO]=nil end end end end;return cd end;eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(au)if type(au[5])=="table"and au[5].PhoenixNetworking and type(au[5].type)=="string"and gp.recv[au[5].type]then local dX=getNodeById(au[2])or hardware.get(au[2])if not dX then syslog.log({level="notice",module="Network"},"Received network event for device ID "..au[2]..", but no device node was found; ignoring")return end;if not gm[dX.uuid]or not gm[dX.uuid].up then return end;syslog.debug(au[2],serialize(au[5]))local bh,q=pcall(gp.recv[au[5].type],{channel=au[3],replyChannel=au[4],device=dX},au[5])if not bh then syslog.log({level="debug",module="Network"},"Network event errored while processing:",q)else return q end end end;local gP=os.startTimer(1)eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=function(au)if au[2]==gP then gP=os.startTimer(1)return gN()end end;local function gQ(process,bK)local gc=gb(bK.url)if not gc.port then error("No port specified")end;local ge=gd(gc.host)local gD=gc.port;local gE={process=process,buffer=""}gp.send.socket.connect({process=process},ge,gD,gE)return gL(gE)end;local gR={}local gS={}local gT={}local gU=os.computerID()%65500;local gV={}eventHooks.http_success=eventHooks.http_success or{}eventHooks.http_success[#eventHooks.http_success+1]=function(au)local info=gR[au[2]]if info then info.handle,info.status=au[3],"open"info.process.eventQueue[#info.process.eventQueue+1]={"handle_status_change",{id=info.id,status="open"}}gR[au[2]]=nil;return true else syslog.log({level="notice"},"Received HTTP response for "..au[2].." but nobody requested it; ignoring.")end end;eventHooks.http_failure=eventHooks.http_failure or{}eventHooks.http_failure[#eventHooks.http_failure+1]=function(au)local info=gR[au[2]]if info then if au[4]then info.handle,info.status=au[4],"open"else info.status,info.error="error",au[3]end;info.process.eventQueue[#info.process.eventQueue+1]={"handle_status_change",{id=info.id,status=info.status}}gR[au[2]]=nil;return true else syslog.log({level="notice"},"Received HTTP response for "..au[2].." but nobody requested it; ignoring.")end end;eventHooks.websocket_success=eventHooks.websocket_success or{}eventHooks.websocket_success[#eventHooks.websocket_success+1]=function(au)local info=gR[au[2]]if info then info.handle,info.status=au[3],"open"info.process.eventQueue[#info.process.eventQueue+1]={"handle_status_change",{id=info.id,status="open"}}return true else syslog.log({level="notice"},"Received WebSocket response for "..au[2].." but nobody requested it; ignoring.")end end;eventHooks.websocket_failure=eventHooks.websocket_failure or{}eventHooks.websocket_failure[#eventHooks.websocket_failure+1]=function(au)local info=gR[au[2]]if info then info.status,info.error="error",au[3]info.process.eventQueue[#info.process.eventQueue+1]={"handle_status_change",{id=info.id,status=info.status}}return true else syslog.log({level="notice"},"Received WebSocket response for "..au[2].." but nobody requested it; ignoring.")end end;eventHooks.websocket_message=eventHooks.websocket_message or{}eventHooks.websocket_message[#eventHooks.websocket_message+1]=function(au)local info=gR[au[2]]if info then info.buffer=info.buffer..au[3]info.process.eventQueue[#info.process.eventQueue+1]={"handle_data_ready",{id=info.id}}return true else syslog.log({level="notice"},"Received WebSocket message for "..au[2].." but nobody requested it; ignoring.")end end;eventHooks.websocket_closed=eventHooks.websocket_closed or{}eventHooks.websocket_closed[#eventHooks.websocket_closed+1]=function(au)local info=gR[au[2]]if info then info.status="closed"info.process.eventQueue[#info.process.eventQueue+1]={"handle_status_change",{id=info.id,status=info.status}}gR[au[2]]=nil;return true else syslog.log({level="notice"},"Received WebSocket message for "..au[2].." but it's not open; ignoring.")end end;eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(au)local a7=false;if gS[au[2]]and(au[3]==gU or au[3]==65535)and type(au[5])=="table"and type(au[5].nMessageID)=="number"and au[5].nMessageID==au[5].nMessageID and not gV[au[5].nMessageID]and(au[5].nRecipient and au[5].nRecipient==os.computerID()or au[3]==65535)then if gT[au[5].nSender]then for B,k in ipairs(gT[au[5].nSender])do if not k.protocol or k.protocol==au[5].sProtocol then k.buffer[#k.buffer+1]=deepcopy(au[5].message)gV[au[5].nMessageID]=os.clock()+9.5;k.process.eventQueue[#k.process.eventQueue+1]={"handle_data_ready",{id=k.id}}a7=true end end end;if gT[0xFFFFFFFF]then for B,k in ipairs(gT[0xFFFFFFFF])do if not k.protocol or k.protocol==au[5].sProtocol then k.buffer[#k.buffer+1]=deepcopy(au[5].message)gV[au[5].nMessageID]=os.clock()+9.5;k.process.eventQueue[#k.process.eventQueue+1]={"handle_data_ready",{id=k.id}}a7=true end end end;for j,k in pairs(gV)do if k<os.clock()then gV[j]=nil end end end;return a7 end;local gW=http.request;local function gX(process,bK)expect.field(bK,"encoding","string","nil")expect.field(bK,"headers","table","nil")expect.field(bK,"method","string","nil")expect.field(bK,"redirect","boolean","nil")local info={status="ready",process=process,id=gl}local bB=setmetatable({id=gl},{__name="socket"})gl=gl+1;function bB:status()return info.status,info.error end;function bB:read(p,...)if info.status~="open"then error("attempt to read from a "..info.status.." handle",2)end;p=p or"*l"if type(p)~="string"and type(p)~="number"then error("bad argument (expected string or number, got "..type(p)..")",2)end;p=p:gsub("^%*","")if p=="a"then if select("#",...)>0 then return info.handle.readAll(),self:read(...)else return info.handle.readAll()end elseif p=="l"then if select("#",...)>0 then return info.handle.readLine(false),self:read(...)else return info.handle.readLine(false)end elseif p=="L"then if select("#",...)>0 then return info.handle.readLine(true),self:read(...)else return info.handle.readLine(true)end elseif p=="n"then local a2;repeat a2=info.handle.read(1)if not a2 then return nil end until tonumber(a2)while true do local ab=info.handle.read(1)if not ab or not ab:match"%d"then break end;a2=a2 ..ab end;if select("#",...)>0 then return tonumber(a2),self:read(...)else return tonumber(a2)end elseif type(p)=="number"then if select("#",...)>0 then return info.handle.read(p),self:read(...)else return info.handle.read(p)end else error("bad argument (invalid mode '"..p.."')",2)end end;function bB:write(...)if info.status~="ready"then error("attempt to write to a "..info.status.." handle",2)end;local bk;if select("#",...)>0 then bk=""for B,k in ipairs{...}do bk=bk..tostring(k)end end;local gY=bK.url.."#"..info.id;local bh,q=gW{url=gY,body=bk,headers=bK.headers,binary=bK.encoding=="binary"or bK.encoding==nil,method=bK.method,redirect=bK.redirect}if bh then gR[gY]=info;info.status="connecting"else info.status,info.error="error",q end end;function bB:close()if info.status~="open"then error("attempt to close a "..info.status.." handle",2)end;info.handle.close()info.status="closed"end;function bB:responseHeaders()if info.status~="open"then error("attempt to read from a "..info.status.." handle",2)end;return info.handle.getResponseHeaders()end;function bB:responseCode()if info.status~="open"then error("attempt to read from a "..info.status.." handle",2)end;return info.handle.getResponseCode()end;return bB end;local function gZ(process,bK)expect.field(bK,"encoding","string","nil")expect.field(bK,"headers","table","nil")local info={process=process,id=gl,buffer=""}local bB=setmetatable({id=gl},{__name="socket"})gl=gl+1;function bB:status()return info.status,info.error end;function bB:read(p,...)if info.status~="open"then error("attempt to read from a "..info.status.." handle",2)end;p=p or"*l"if type(p)~="string"and type(p)~="number"then error("bad argument (expected string or number, got "..type(p)..")",2)end;if info.buffer==""then return nil end;p=p:gsub("^%*","")if p=="a"then local a2=info.buffer;info.buffer=""return a2 elseif p=="l"then local a2,a9=info.buffer:match"^([^\n]*)\n?()"if a2 then info.buffer=info.buffer:sub(a9)if select("#",...)>0 then return a2,self:read(...)else return a2 end else return nil end elseif p=="L"then local a2,a9=info.buffer:match"^([^\n]*\n?)()"if a2 then info.buffer=info.buffer:sub(a9)if select("#",...)>0 then return a2,self:read(...)else return a2 end else return nil end elseif p=="n"then local a2,a9=info.buffer:match"(%d+)()"if a2 then info.buffer=info.buffer:sub(a9)if select("#",...)>0 then return tonumber(a2),self:read(...)else return tonumber(a2)end else return nil end elseif type(p)=="number"then local a2=info.buffer:sub(1,p)info.buffer=info.buffer:sub(p+1)if select("#",...)>0 then return a2,self:read(...)else return a2 end else error("bad argument (invalid mode '"..p.."')",2)end end;function bB:write(bk,...)if info.status~="open"then error("attempt to write to a "..info.status.." handle",2)end;info.handle.send(tostring(bk),bK.encoding=="binary")if select("#",...)>0 then return self:write(...)end end;function bB:close()if info.status~="open"then error("attempt to close a "..info.status.." handle",2)end;info.handle.close()info.status="closed"end;local gY=bK.url.."#"..info.id;local bh,q=http.websocket(gY,bK.headers)if bh then gR[gY]=info;info.status="connecting"else return nil,q end;return bB end;local function g_(process,bK)expect.field(bK,"device","string","nil")local h0;if bK.device then h0={hardware.get(bK.device)}else h0={hardware.find("modem")}end;if#h0==0 then error("Could not find a modem",2)end;for B,k in ipairs(h0)do gk(k)if not gS[k]then hardware.call(process,k,"open",gU)hardware.call(process,k,"open",65535)gS[k]=1 else gS[k]=gS[k]+1 end end;local gc=gb(bK.url)if not gc.host then error("Missing host",2)end;local aD=gd(gc.host)local info={process=process,id=gl,buffer={},protocol=gc.scheme:match"rednet%+(.+)"}local bB=setmetatable({id=gl},{__name="socket"})gl=gl+1;function bB:status()return info.closed and"closed"or"open"end;function bB:read(p,...)if info.closed then error("attempt to read from a "..info.status.." handle",2)end;p=p or"*l"if type(p)~="string"and type(p)~="number"then error("bad argument (expected string or number, got "..type(p)..")",2)end;if#info.buffer==0 then return nil end;p=p:gsub("^%*","")if p=="a"then return table.remove(info.buffer,1)elseif p=="l"then info.buffer[1]=tostring(info.buffer[1])local a2,a9=info.buffer[1]:match"^([^\n]*)\n?()"if a2 then info.buffer[1]=info.buffer[1]:sub(a9)if select("#",...)>0 then return a2,self:read(...)else return a2 end else table.remove(info.buffer,1)return self:read(p,...)end elseif p=="L"then info.buffer[1]=tostring(info.buffer[1])local a2,a9=info.buffer[1]:match"^([^\n]*\n?)()"if a2 then info.buffer[1]=info.buffer[1]:sub(a9)if select("#",...)>0 then return a2,self:read(...)else return a2 end else table.remove(info.buffer,1)return self:read(p,...)end elseif p=="n"then info.buffer[1]=tostring(info.buffer[1])local a2,a9=info.buffer[1]:match"(%d+)()"if a2 then info.buffer[1]=info.buffer[1]:sub(a9)if select("#",...)>0 then return tonumber(a2),self:read(...)else return tonumber(a2)end else table.remove(info.buffer,1)return self:read(p,...)end elseif type(p)=="number"then local a2=""while#a2<p do info.buffer[1]=tostring(info.buffer[1])a2=a2 ..info.buffer[1]:sub(1,p-#a2)info.buffer[1]=info.buffer[1]:sub(p-#a2+1)if info.buffer[1]==""then table.remove(info.buffer,1)end;if#info.buffer==0 then break end end;if select("#",...)>0 then return a2,self:read(...)else return a2 end else error("bad argument (invalid mode '"..p.."')",2)end end;function bB:write(bk,...)if info.closed then error("attempt to write to a "..info.status.." handle",2)end;local h1=math.random(1,0x7FFFFFFF)local ep={nMessageID=h1,nRecipient=aD,nSender=os.computerID(),message=bk,sProtocol=info.protocol}if aD==os.computerID()then for B,k in ipairs(h0)do os.queueEvent("modem_message",k.id,gU,gU,ep,0)end else gV[h1]=os.clock()+9.5;for B,k in ipairs(h0)do hardware.call(process,k,"transmit",aD==0xFFFFFFFF and 65535 or aD%65500,gU,ep)hardware.call(process,k,"transmit",65533,gU,ep)end end;if select("#",...)>0 then return self:write(...)end end;function bB:close()if info.closed then error("attempt to close a "..info.status.." handle",2)end;for B,k in ipairs(h0)do gS[k]=gS[k]-1;if gS[k]==0 then hardware.call(process,k,"close",gU)hardware.call(process,k,"close",65535)gS[k]=nil end end;info.status="closed"end;return bB end;uriSchemes={["https?"]=gX,["wss?"]=gZ,["rednet"]=g_,["rednet%+%a+"]=g_,["psp"]=gQ}function syscalls.connect(process,at,bK)if type(bK)=="string"then bK={url=bK}end;expect(1,bK,"table")expect.field(bK,"url","string")local gc=gb(bK.url)local bB,q;for j,k in pairs(uriSchemes)do if gc.scheme:match(j)then bB,q=k(process,bK)break end end;if not bB and not q then error("Invalid protocol "..gc.scheme)end;if bB then for B,k in pairs(bB)do if type(k)=="function"then setfenv(k,process.env)debug.protect(k)end end end;return bB,q end;function syscalls.listen(process,at,gc)expect(1,gc,"string")local h2=gb(gc)if http.addListener then if h2.scheme=="http"then http.addListener(h2.port or 80)return elseif h2.scheme=="ws"then http.websocket(h2.port or 80)return end end;if h2.scheme=="psp"then if not h2.port then error("Missing port")end;local ge=gd(h2.host)for j,k in pairs(gm)do if k.up and(ge==0 or k.ip==ge)then hardware.call(process,hardware.get(j),"open",h2.port)end end;local gE={localPort=h2.port,id=gl,status="listening",process=process,nextUpdate=math.huge,retryCount=0,uri=gc,buffer=""}gl=gl+1;gq[h2.port]=gq[h2.port]or{}gq[h2.port].listen=gE;gr[gE.id]=gE;return end;error("Invalid protocol "..h2.scheme)end;function syscalls.unlisten(process,at,gc)end;function syscalls.ipconfig(process,at,fp,info)if info and process.user~="root"then error("Permission denied")end;expect(1,fp,"string")expect(2,info,"table","nil")local dX=gk(hardware.get(fp))local A=gm[dX.uuid]if not A then if info then expect.field(info,"ip","string","number")expect.field(info,"netmask","string","number")A={up=true}gm[dX.uuid]=A;hardware.call(KERNEL,dX,"open",0)else return nil end end;if info then expect.field(info,"ip","string","number","nil")expect.field(info,"netmask","string","number","nil")expect.field(info,"up","boolean","nil")local h3,h4;if A.ip then for B,k in ipairs(gn[0])do if k.source==bit32.band(A.ip,A.netmask)and k.netmask==A.netmask then h3=k elseif k.source==bit32.bor(bit32.band(A.ip,A.netmask),bit32.bnot(A.netmask))and k.netmask==0xFFFFFFFF then h4=k end end end;if info.ip then if go[dX.uuid]then go[dX.uuid][A.ip]=nil end;if type(info.ip)=="number"then A.ip=bit32.band(info.ip,0xFFFFFFFF)else A.ip=gd(info.ip)end;if h3 then h3.source=bit32.band(A.ip,A.netmask)end;if h4 then h4.source=bit32.bor(bit32.band(A.ip,A.netmask),bit32.bnot(A.netmask))end;go[dX.uuid]=go[dX.uuid]or{}go[dX.uuid][A.ip]=os.computerID()end;if info.netmask then if type(info.netmask)=="number"then A.netmask=gi(info.netmask)else A.netmask=gd(info.netmask)end;if h3 then h3.source=bit32.band(A.ip,A.netmask)end;if h4 then h4.source=bit32.bor(bit32.band(A.ip,A.netmask),bit32.bnot(A.netmask))end end;if info.up~=nil then A.up=info.up;if A.up then hardware.call(KERNEL,dX,"open",0)else hardware.call(KERNEL,dX,"close",0)end end;if not h3 then gn[0][#gn[0]+1]={source=bit32.band(A.ip,A.netmask),sourceNetmask=A.netmask,action="local",device=dX}end;if not h4 then gn[0][#gn[0]+1]={source=bit32.bor(bit32.band(A.ip,A.netmask),bit32.bnot(A.netmask)),sourceNetmask=0xFFFFFFFF,action="broadcast",device=dX}end end;return{ip=gf(A.ip),netmask=gj(A.netmask),up=A.up}end;function syscalls.routelist(process,at,b)b=expect(1,b,"number","nil")or 1;expect.range(b,0)if not gn[b]then return nil end;local a7={}for x,A in ipairs(gn[b])do a7[x]={source=gf(A.source),sourceNetmask=gj(A.sourceNetmask),action=A.action,device=A.device and hardware.path(A.device),destination=A.destination and gf(A.destination)}end;return a7 end;local h5={unicast=true,broadcast=true,["local"]=true,unreachable=true,prohibit=true,blackhole=true}function syscalls.routeadd(process,at,bK)if process.user~="root"then error("Permission denied")end;expect(1,bK,"table")expect.field(bK,"source","string","number")expect.field(bK,"sourceNetmask","string","number")expect.field(bK,"action","string")expect.field(bK,"device","string",bK.action~="unicast"and bK.action~="broadcast"and bK.action~="local"and"nil"or nil)expect.field(bK,"destination","string",bK.action~="unicast"and"nil"or nil)expect.range(expect.field(bK,"table","number","nil")or 1,1)bK.table=bK.table or 1;if not h5[bK.action]then error("bad field 'action' (invalid option '"..bK.action.."')")end;local A={}if type(bK.source)=="number"then A.source=bit32.band(bK.source,0xFFFFFFFF)else A.source=gd(bK.source)end;if type(bK.sourceNetmask)=="number"then A.sourceNetmask=gi(bK.sourceNetmask)else A.sourceNetmask=gd(bK.sourceNetmask)end;A.source=bit32.band(A.source,A.sourceNetmask)A.action=bK.action;A.device=bK.device and gk(hardware.get(bK.device))A.destination=bK.destination and gd(bK.destination)gn[bK.table]=gn[bK.table]or{}for B,k in ipairs(gn[bK.table])do if k.source==A.source and k.sourceNetmask==A.sourceNetmask then error("Route already exists")end end;gn[bK.table][#gn[bK.table]+1]=A;gn.maxn=math.max(gn.maxn,bK.table)end;function syscalls.routedel(process,at,h6,y,b)if process.user~="root"then error("Permission denied")end;expect(1,h6,"string","number")expect(2,y,"string","number")b=expect(3,b,"number","nil")or 1;expect.range(b,1)if type(y)=="number"then y=gi(y)else y=gd(y)end;if type(h6)=="number"then h6=bit32.band(h6,y)else h6=bit32.band(gd(h6),y)end;if not gn[b]then error("Route table does not exist")end;for x,k in ipairs(gn[b])do if k.source==h6 and k.sourceNetmask==y then table.remove(gn[b],x)return end end end;function syscalls.arplist(process,at,fp)expect(1,fp,"string")local dX=gk(hardware.get(fp))local a7={}for j,k in pairs(go[dX.uuid]or{})do a7[gf(j)]=k end;return a7 end;function syscalls.arpset(process,at,fp,ge,aD)if process.user~="root"then error("Permission denied")end;expect(1,fp,"string")expect(2,ge,"string","number")expect(3,aD,"number")local dX=gk(hardware.get(fp))if type(ge)=="string"then ge=gd(ge)else ge=bit32.band(ge,0xFFFFFFFF)end;go[dX.uuid]=go[dX.uuid]or{}go[dX.uuid][ge]=aD end;local h7={ping=true,pong=true,unreachable=true,timeout=true}function syscalls.netcontrol(process,at,ge,f0,q,gx)if process.user~="root"then error("Permission denied")end;expect(1,ge,"string","number")expect(2,f0,"string")expect(3,q,"string","nil")expect(4,gx,"number","nil")if not h7[f0]then error("bad argument #2 (invalid option '"..f0 .."')")end;if type(ge)=="string"then ge=gd(ge)else ge=bit32.band(ge,0xFFFFFFFF)end;gp.send.control({process=process},ge,f0,q,gx)end;function syscalls.netevent(process,at,dA)if process.user~="root"then error("Permission denied")end;expect(1,dA,"boolean","nil")if dA==true then gs[process]=function(ag)process.eventQueue[#process.eventQueue+1]={"network_event",deepcopy(ag)}return true end elseif dA==false then gs[process]=nil end;return gs[process]~=nil end;function syscalls.checkuri(process,at,gc)end;function registerLoopback()local dX=hardware.get("/lo")if dX then gm[dX.uuid]={ip=0x7F000001,netmask=0xFF000000,up=true}gn[0][#gn[0]+1]={source=0x7F000000,sourceNetmask=0xFF000000,action="local",device=dX}gn[0][#gn[0]+1]={source=0x7FFFFFFF,sourceNetmask=0xFFFFFFFF,action="broadcast",device=dX}go[dX.uuid]=setmetatable({},{__index=function()return os.computerID()end})syslog.log("Configured IP for loopback device")end end;function syscalls.listmodules()local a7={}for j in pairs(modules)do a7[#a7+1]=j end;return a7 end;function syscalls.loadmodule(process,at,g)expect(1,g,"string")if process.user~="root"then error("Could not load kernel module: Permission denied",2)end;local bL=filesystem.stat(process,g)if bL.type=="directory"then error("Could not load kernel module: Is a directory",2)end;if bL.owner~="root"or bL.worldPermissions.write then error("Insecure permissions set on kernel module, refusing to load",2)end;local o=g:match"([^%./]+)[^/]*$"syslog.log("Loading kernel module "..o.." from "..g)local a,q=filesystem.open(process,g,"rb")if a then local bk=a.readAll()or""a.close()local i,q=load(bk,"@"..g)if i then local bh,w=pcall(i,g)if bh then modules[o]=w or true else syslog.log({level="error"},"Kernel module "..o.." threw an error:",w)end else syslog.log({level="error"},"Could not load "..o..":",q)end else syslog.log({level="error"},"Could not open "..g..":",q)end end;function syscalls.unloadmodule(process,at,o)expect(1,o,"string")if process.user~="root"then error("Could not load kernel module: Permission denied",2)end;if type(modules[o])=="table"and modules[o].unload then modules[o].unload(process,at)end;modules[o]=nil end;function syscalls.callmodule(process,at,o,aC,...)expect(1,o,"string")expect(2,aC,"string")if not modules[o]then error("Module '"..o.."' does not exist",2)elseif type(modules[o])~="table"then error("Module '"..o.."' does not have a callable interface",2)elseif aC=="unload"or type(modules[o][aC])~="function"then error("Module '"..o.."' does not have a method '"..aC.."'",2)end;return modules[o][aC](process,at,...)end;syslog.log("Loading kernel modules from /lib/modules")local bh,h8=pcall(filesystem.list,KERNEL,"/lib/modules")if bh then for B,k in ipairs(h8)do local G=filesystem.combine("/lib/modules",k)local bL=filesystem.stat(KERNEL,G)if bL.type~="directory"then local bh,q=pcall(syscalls.loadmodule,KERNEL,nil,G)if not bh then syslog.log({level="error"},"Could not load module from "..G..": "..q)end end end else syslog.log({level="notice"},"Could not open /lib/modules:",h8)end;xpcall(hardware.register,function(error)panic("An error occurred while registering devices: "..error)end,deviceTreeRoot,rootDriver)local as={n=0}local h9=processes[syscalls.fork(KERNEL,nil,function()end,"init")]local ha=h9.id;local hb,hc;if args.init then hb,hc=pcall(syscalls.exec,h9,nil,args.initrd and"/init"or args.init)end;if not hb then syslog.log({level="error",process=0},"Could not load init:",hc)syslog.log("Could not find provided init, trying default locations")for B,k in ipairs{"/sbin/init","/etc/init","/bin/init","/bin/sh"}do syslog.log("Trying",k)hb,hc=pcall(syscalls.exec,h9,nil,k)if not hb then syslog.log({level="error",process=0},"Could not load init:",hc)end;if hb then break end end;if not hb then panic("No working init found")end end;syslog.log("Starting init from "..processes[ha].name)local aw=false;local hd=setmetatable({},{__mode="k"})function wakeup(process)if#process.eventQueue>0 and not hd[process]then aw=false end end;local da=coroutine.yield;function coroutine.yield(...)if coroutine.running()==mainThread then error("attempt to yield from kernel main thread",2)end;return da(...)end;debug.protect(coroutine.yield)eventHooks.key=eventHooks.key or{}eventHooks.key[#eventHooks.key+1]=function(au)if keysHeld.ctrl and keysHeld.shift and au[2]==keys.f10 then term.clear()term.setCursorPos(1,1)term.write("Entering debug console.")local s=2;local aZ=true;term.setCursorPos(1,s)while aZ do local al=""local ah,ai=term.getSize()term.write("lua> ")term.setCursorBlink(true)while true do local au={da()}if au[1]=="char"or au[1]=="paste"then al=al..au[2]term.write(au[2])elseif au[1]=="key"then if au[2]==keys.backspace and#al>0 then al=al:sub(1,-2)term.setCursorPos(term.getCursorPos()-1,s)term.write(" ")term.setCursorPos(term.getCursorPos()-1,s)elseif au[2]==keys.enter then break end end end;s=s+1;if s>ai then s=s-1;term.scroll(1)end;term.setCursorPos(1,s)local i,q=load("return "..al,"=lua","t",setmetatable({exit=function()aZ=false end},{__index=_G}))if not i then i,q=load(al,"=lua","t",setmetatable({exit=function()aZ=false end},{__index=_G}))end;if i then local w=table.pack(pcall(i))if w[1]then for x=2,w.n do term.write(tostring(w[x]))s=s+1;if s>ai then s=s-1;term.scroll(1)end;term.setCursorPos(1,s)end else term.setTextColor(16384)term.write(w[2])term.setTextColor(1)s=s+1;if s>ai then s=s-1;term.scroll(1)end;term.setCursorPos(1,s)end else term.setTextColor(16384)term.write(q)term.setTextColor(1)s=s+1;if s>ai then s=s-1;term.scroll(1)end;term.setCursorPos(1,s)end end;term.setCursorBlink(false)term.clear()terminal.redraw(currentTTY,true)end end;local he={char=true,key=true,key_up=true,mouse_click=true,mouse_up=true,mouse_drag=true,mouse_scroll=true,paste=true}local bh,q=xpcall(function()while processes[ha]do if not aw then os.queueEvent("__event_queue_back")end;while true do local au=table.pack(da())local o=au[1]if o=="__event_queue_back"then break end;local hf=false;if eventHooks[o]then for B,k in ipairs(eventHooks[o])do hf=k(au)or hf end end;if eventParameterMap[o]then local ay={}for x=2,#eventParameterMap[o]+1 do ay[eventParameterMap[o][x-1]]=au[x]end;if o=="key"or o=="key_up"then ay.keycode=keymap[ay.keycode]ay.ctrlHeld=keysHeld.ctrl;ay.altHeld=keysHeld.alt;ay.shiftHeld=keysHeld.shift end;if o=="mouse_scroll"then ay.direction=ay.direction>0 end;if he[o]and currentTTY.frontmostProcess then currentTTY.frontmostProcess.eventQueue[#currentTTY.frontmostProcess.eventQueue+1]={o,ay}hf=true elseif o=="timer"or o=="alarm"then local hg;if o=="timer"then hg=timerMap[au[2]]else hg,ay.id=alarmMap[au[2]],bit32.bor(ay.id,0x80000000)end;if hg then hg.eventQueue[#hg.eventQueue+1],hf={o,ay},true end end end;if aw and hf then break end end;aw=true;hd=setmetatable({},{__mode="k"})for cZ,process in pairs(processes)do if cZ~=0 and not process.paused then local fR,au=false,nil;local av=true;for eZ,at in pairs(process.threads)do if not fR and at.status=="suspended"then au=table.remove(process.eventQueue,1)fR=true end;if au or at.status~="suspended"then local hh;av,hh=executeThread(process,at,au or as,av,aw)aw=hh and aw else av=false end end;if av then process.isDead=true;if process.lastReturnValue then if cZ==ha then init_retval=process.lastReturnValue.value or process.lastReturnValue.error elseif processes[process.parent]then process.lastReturnValue.id=cZ;processes[process.parent].eventQueue[#processes[process.parent].eventQueue+1]={"process_complete",process.lastReturnValue}end end;reap_process(process)processes[cZ]=nil;aw=false end;hd[process]=true end end;terminal.redraw(currentTTY)end end,debug.traceback)if not bh then syslog.log({level="critical",traceback=true},q)end;if postkill then postkill()end;if init_retval~=nil then syslog.log({level=4},"init exited with result",init_retval)end;panic("init program exited")
