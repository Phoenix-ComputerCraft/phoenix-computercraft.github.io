PHOENIX_VERSION="0.0.6"PHOENIX_BUILD="PRERELEASE NONFREE Wed Aug  7 00:22:26 2024"systemStartTime=os.epoch"utc"args={init="/sbin/init.lua",root="/root",rootfstype="craftos",preemptive=true,quantum=20000,splitkernpath="/boot/kernel.lua.d",loglevel=1,console="tty1",traceback=true}syscalls={}processes={[0]={name="kernel",id=0,user="root",dir="/",root="/",env=_G,vars={},dependents={}}}KERNEL=processes[0]modules={}eventHooks={}shutdownHooks={}kSyscallYield={}kSyscallComplete={}process={}filesystem={}terminal={}user={}syslog={}hardware={}if discord then discord("Phoenix","Booting Phoenix "..PHOENIX_VERSION)end;do local a=fs.open("/rom/modules/main/cc/expect.lua","r")expect=(loadstring or load)(a.readAll(),"@/rom/modules/main/cc/expect.lua")()a.close()setmetatable(expect,{__call=function(self,...)return self.expect(...)end})if not expect.range then function expect.range(b,c,d)expect(1,b,"number")expect(2,c,"number","nil")expect(3,d,"number","nil")if d and c and d<c then error("bad argument #3 (min must be less than or equal to max)",2)end;if b~=b or b<(c or-math.huge)or b>(d or math.huge)then error(("number outside of range (expected %s to be within %s and %s)"):format(b,c or-math.huge,d or math.huge),3)end;return b end end end;do local a=fs.open("/rom/apis/textutils.lua","r")local e=setmetatable({dofile=function(path)if path=="rom/modules/main/cc/expect.lua"then return expect elseif path=="rom/modules/main/cc/require.lua"then return{make=function()return function(mod)if mod=="cc.expect"then return expect else return{}end end end}end end},{__index=_G})local g;if loadstring and setfenv then g=loadstring(a.readAll(),"@/rom/apis/textutils.lua")setfenv(g,e)else g=load(a.readAll(),"@/rom/apis/textutils.lua","t",e)end;a.close()g()serialize,unserialize=e.serialize,e.unserialize end;do local a=fs.open("/rom/apis/keys.lua","r")local e=setmetatable({dofile=function()return expect end},{__index=_G})if _VERSION<"Lua 5.2"then e._ENV=e end;local g;if loadstring and setfenv then g=loadstring(a.readAll(),"@/rom/apis/keys.lua")setfenv(g,e)else g=load(a.readAll(),"@/rom/apis/keys.lua","t",e)end;a.close()g()keys={}for h,i in pairs(e)do keys[h]=i end end;if not pcall(load,"return","=test","t",{})then local j,k,expect,setfenv=load,loadstring,expect,setfenv;function load(l,m,n,e)expect(1,l,"string","function")expect(2,m,"string","nil")expect(3,n,"string","nil")expect(4,e,"table","nil")if type(l)=="string"then if l:sub(1,4)=="\27Lua"then if n==nil or n:find"b"then local g,o=k(l,m)if g and e then setfenv(g,e)end;return g,o else return nil,"attempt to load a binary chunk (mode is '"..(n or"bt").."')"end else if n==nil or n:find"t"then local g,o=k(l,m)if g and e then setfenv(g,e)end;return g,o else return nil,"attempt to load a text chunk (mode is '"..(n or"bt").."')"end end else local g,o=j(l,m)if g then setfenv(g,e)end;return g,o end end end;loadstring=nil;if bit then if not bit32 then local bit=bit;bit32={bnot=bit.bnot,lshift=bit.blshift,rshift=bit.blogic_rshift,arshift=bit.brshift}function bit32.band(p,q,...)expect(1,p,"number")expect(2,q,"number","nil")if not q then return p end;return bit32.band(bit.band(p,q),...)end;function bit32.bor(p,q,...)expect(1,p,"number")expect(2,q,"number","nil")if not q then return p end;return bit32.bor(bit.bor(p,q),...)end;function bit32.bxor(p,q,...)expect(1,p,"number")expect(2,q,"number","nil")if not q then return p end;return bit32.bxor(bit.bxor(p,q),...)end;function bit32.btest(...)return bit32.band(...)~=0 end;function bit32.extract(r,s,t)expect(1,r,"number")expect(2,s,"number")expect(3,t,"number","nil")(expect.range or function()end)(s,0,31)(expect.range or function()end)(s+t-1,0,31)t=t or 1;local u=0;for v=s+t-1,s,-1 do u=u*2+bit.band(r,2^v)/2^v end;return u end;function bit32.replace(r,i,s,t)expect(1,r,"number")expect(2,i,"number")expect(3,s,"number")expect(4,t,"number","nil")(expect.range or function()end)(s,0,31)(expect.range or function()end)(s+t-1,0,31)t=t or 1;local w=2^t-1;return bit.bor(bit.band(r,bit.bnot(bit.blshift(w,s))),bit.blshift(bit.band(i,w),s))end;function bit32.lrotate(p,x)return bit.bor(bit.blshift(p,x),bit.blogic_rshift(p,32-x))end;function bit32.rrotate(p,x)return bit.bor(bit.blogic_rshift(p,x),bit.blshift(p,32-x))end end;bit=nil end;if _VERSION=="Lua 5.1"and load("::a:: goto a")then _VERSION="Lua 5.2"if load("return 1 >> 2 & 3")then _VERSION="Lua 5.3"if load("local <const> a = 2")then _VERSION="Lua 5.4"end end end;if _VERSION=="Lua 5.1"then if not table.pack then table.pack=function(...)local y={...}y.n=select("#",...)return y end end;if not table.unpack then table.unpack,unpack=unpack,nil end;local z,i=xpcall(function(A)return A end,function()end,true)if not i then local B=xpcall;xpcall=function(f,C,...)if select("#",...)>0 then local args=table.pack(...)return B(function()return f(table.unpack(args,1,args.n))end,C)else return B(f,C)end end end end;if tonumber(_HOST:match"ComputerCraft 1.(%d+)")<95 then local D=fs.combine;function fs.combine(E,...)if...~=nil then return D(E,fs.combine(...))else return E end end end;if not string.pack then local expect=expect.expect;local F={BIG_ENDIAN=1,LITTLE_ENDIAN=2}local G={b=1,B=1,h=1,H=1,l=1,L=1,j=1,J=1,T=1}local H={b=1,B=1,x=1,h=2,H=2,f=4,j=4,J=4,l=8,L=8,T=8,d=8,n=8}local function I(r)if r%1>=0.5 then return math.ceil(r)else return math.floor(r)end end;local function J(f)if f==0 then return 0 elseif f==-0 then return 0x80000000 elseif f==math.huge then return 0x7F800000 elseif f==-math.huge then return 0xFF800000 end;local A,K=math.frexp(f)if K>127 or K<-126 then error("number out of range",3)end;K,A=K+126,I((math.abs(A)-0.5)*0x1000000)if A>0x7FFFFF then K=K+1 end;return bit32.bor(f<0 and 0x80000000 or 0,bit32.lshift(bit32.band(K,0xFF),23),bit32.band(A,0x7FFFFF))end;local function L(f)if f==0 then return 0,0 elseif f==-0 then return 0x80000000,0 elseif f==math.huge then return 0x7FF00000,0 elseif f==-math.huge then return 0xFFF00000,0 end;local A,K=math.frexp(f)if K>1023 or K<-1022 then error("number out of range",3)end;K,A=K+1022,I((math.abs(A)-0.5)*0x20000000000000)if A>0xFFFFFFFFFFFFF then K=K+1 end;return bit32.bor(f<0 and 0x80000000 or 0,bit32.lshift(bit32.band(K,0x7FF),20),bit32.band(A/0x100000000,0xFFFFF)),bit32.band(A,0xFFFFFFFF)end;local function M(N)if N==0 then return 0 elseif N==0x80000000 then return-0 elseif N==0x7F800000 then return math.huge elseif N==0xFF800000 then return-math.huge end;local A,K=bit32.band(N,0x7FFFFF),bit32.band(bit32.rshift(N,23),0xFF)K,A=K-126,A/0x1000000+0.5;local r=math.ldexp(A,K)return bit32.btest(N,0x80000000)and-r or r end;local function O(P,Q)if P==0 and Q==0 then return 0 elseif P==0x80000000 and Q==0 then return-0 elseif P==0x7FF00000 and Q==0 then return math.huge elseif P==0xFFF00000 and Q==0 then return-math.huge end;local A,K=bit32.band(P,0xFFFFF)*0x100000000+bit32.band(Q,0xFFFFFFFF),bit32.band(bit32.rshift(P,20),0x7FF)K,A=K-1022,A/0x20000000000000+0.5;local r=math.ldexp(A,K)return bit32.btest(P,0x80000000)and-r or r end;local function R(b,S,T,U,V,W,X)local Y=0;if U%math.min(S,V)~=0 and V>1 then local v=0;while U%math.min(S,V)~=0 and v<V do T[U]=0;U=U+1;Y=Y+1;v=v+1 end end;if W==F.BIG_ENDIAN then local Z=0;if S>8 then for v=0,S-9 do T[U+v]=X and b>=2^(S*8-1)~=0 and 0xFF or 0;Z=Z+1;Y=Y+1 end end;for v=Z,S-1 do T[U+v]=bit32.band(bit32.rshift(b,(S-v-1)*8),0xFF)Y=Y+1 end else for v=0,math.min(S,8)-1 do T[U+v]=b/2^(v*8)%256;Y=Y+1 end;for v=8,S-1 do T[U+v]=X and b>=2^(S*8-1)~=0 and 0xFF or 0;Y=Y+1 end end;return Y end;local function _(a0,U,S,W,V,X)local a1,a2=0,0;if U%math.min(S,V)~=0 and V>1 then for v=0,V-1 do if U%math.min(S,V)==0 then break end;U=U+1;a2=a2+1 end end;for v=0,S-1 do a1=a1+a0:byte(U+v)*2^((W==F.BIG_ENDIAN and S-v-1 or v)*8)a2=a2+1 end;if X and a1>=2^(S*8-1)then a1=a1-2^(S*8)end;return a1,a2 end;local function a3(a4,V)local a5=H[a4]or 0;if V>1 and a5%V~=0 then a5=a5+V-a5%V end;return a5 end;function string.pack(...)local a6=expect(1,...,"string")local W=F.LITTLE_ENDIAN;local V=1;local a7=1;local a8=2;local T={}local v=1;while v<=#a6 do local a9=a6:sub(v,v)v=v+1;if a9=='='or a9=='<'then W=F.LITTLE_ENDIAN elseif a9=='>'then W=F.BIG_ENDIAN elseif a9=='!'then local S=-1;while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=math.max(S,0)*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 or S==0 then error(string.format("integral size (%d) out of limits [1,16]",S),2)elseif S==-1 then V=4 else V=S end elseif G[a9]then local b=expect(a8,select(a8,...),"number")a8=a8+1;if b>=math.pow(2,a3(a9,0)*8-(a9:match("%l")and 1 or 0))or b<(a9:match("%l")and-math.pow(2,a3(a9,0)*8-1)or 0)then error(string.format("bad argument #%d to 'pack' (integer overflow)",a8-1),2)end;a7=a7+R(b,a3(a9,0),T,a7,V,W,false)elseif a9:lower()=='i'then local X=a9=='i'local S=-1;while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=math.max(S,0)*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 or S==0 then error(string.format("integral size (%d) out of limits [1,16]",S),2)elseif V>1 and(S~=1 and S~=2 and S~=4 and S~=8 and S~=16)then error("bad argument #1 to 'pack' (format asks for alignment not power of 2)",2)elseif S==-1 then S=4 end;local b=expect(a8,select(a8,...),"number")a8=a8+1;if b>=math.pow(2,S*8-(a9:match("%l")and 1 or 0))or b<(a9:match("%l")and-math.pow(2,S*8-1)or 0)then error(string.format("bad argument #%d to 'pack' (integer overflow)",a8-1),2)end;a7=a7+R(b,S,T,a7,V,W,X)elseif a9=='f'then local f=expect(a8,select(a8,...),"number")a8=a8+1;local N=J(f)if a7%math.min(4,V)~=0 and V>1 then for aa=0,V-1 do if a7%math.min(4,V)==0 then break end;T[a7]=0;a7=a7+1 end end;for aa=0,3 do T[a7+(W==F.BIG_ENDIAN and 3-aa or aa)]=bit32.band(bit32.rshift(N,aa*8),0xFF)end;a7=a7+4 elseif a9=='d'or a9=='n'then local f=expect(a8,select(a8,...),"number")a8=a8+1;local P,Q=L(f)if a7%math.min(8,V)~=0 and V>1 then for aa=0,V-1 do if a7%math.min(8,V)==0 then break end;T[a7]=0;a7=a7+1 end end;for aa=0,3 do T[a7+(W==F.BIG_ENDIAN and 7-aa or aa)]=bit32.band(bit32.rshift(Q,aa*8),0xFF)end;for aa=4,7 do T[a7+(W==F.BIG_ENDIAN and 7-aa or aa)]=bit32.band(bit32.rshift(P,(aa-4)*8),0xFF)end;a7=a7+8 elseif a9=='c'then local S=0;if v>#a6 or not a6:sub(v,v):match("%d")then error("missing size for format option 'c'",2)end;while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if a7+S<a7 or a7+S>0xFFFFFFFF then error("bad argument #1 to 'pack' (format result too large)",2)end;local a0=expect(a8,select(a8,...),"string")a8=a8+1;if#a0>S then error(string.format("bad argument #%d to 'pack' (string longer than given size)",a8-1),2)end;if S>0 then for aa=0,S-1 do T[a7+aa]=a0:byte(aa+1)or 0 end;a7=a7+S end elseif a9=='z'then local a0=expect(a8,select(a8,...),"string")a8=a8+1;for ab in a0:gmatch"."do if ab=='\0'then error(string.format("bad argument #%d to 'pack' (string contains zeros)",a8-1),2)end end;for aa=0,#a0-1 do T[a7+aa]=a0:byte(aa+1)end;T[a7+#a0]=0;a7=a7+#a0+1 elseif a9=='s'then local S=0;while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 then error(string.format("integral size (%d) out of limits [1,16]",S),2)elseif S==0 then S=4 end;local a0=expect(a8,select(a8,...),"string")a8=a8+1;if#a0>=math.pow(2,S*8)then error(string.format("bad argument #%d to 'pack' (string length does not fit in given size)",a8-1),2)end;R(#a0,S,T,a7,1,W,false)for aa=S,#a0+S-1 do T[a7+aa]=a0:byte(aa-S+1)or 0 end;a7=a7+#a0+S elseif a9=='x'then T[a7]=0;a7=a7+1 elseif a9=='X'then if v>=#a6 then error("invalid next option for option 'X'",2)end;local S=0;local a9=a6:sub(v,v)v=v+1;if a9:lower()=='i'then while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 or S==0 then error(string.format("integral size (%d) out of limits [1,16]",S),2)end else S=a3(a9,0)end;if S<1 then error("invalid next option for option 'X'",2)end;if a7%math.min(S,V)~=0 and V>1 then for aa=1,V do if a7%math.min(S,V)==0 then break end;T[a7]=0;a7=a7+1 end end elseif a9~=' 'then error(string.format("invalid format option '%s'",a9),2)end end;return string.char(table.unpack(T))end;function string.packsize(a6)local a7=0;local V=1;local v=1;while v<=#a6 do local a9=a6:sub(v,v)v=v+1;if a9=='!'then local S=0;while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 then error(string.format("integral size (%d) out of limits [1,16]",S),2)elseif S==0 then V=4 else V=S end elseif G[a9]then local S=a3(a9,0)if a7%math.min(S,V)~=0 and V>1 then for aa=1,V do if a7%math.min(S,V)==0 then break end;a7=a7+1 end end;a7=a7+S elseif a9:lower()=='i'then local S=0;while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 then error(string.format("integral size (%d) out of limits [1,16]",S))elseif V>1 and(S~=1 and S~=2 and S~=4 and S~=8 and S~=16)then error("bad argument #1 to 'pack' (format asks for alignment not power of 2)",2)elseif S==0 then S=4 end;if a7%math.min(S,V)~=0 and V>1 then for aa=1,V do if a7%math.min(S,V)==0 then break end;a7=a7+1 end end;a7=a7+S elseif a9=='f'then if a7%math.min(4,V)~=0 and V>1 then for aa=1,V do if a7%math.min(4,V)==0 then break end;a7=a7+1 end end;a7=a7+4 elseif a9=='d'or a9=='n'then if a7%math.min(8,V)~=0 and V>1 then for aa=1,V do if a7%math.min(8,V)==0 then break end;a7=a7+1 end end;a7=a7+8 elseif a9=='c'then local S=0;if v>#a6 or not a6:sub(v,v):match("%d")then error("missing size for format option 'c'",2)end;while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if a7+S<a7 or a7+S>0x7FFFFFFF then error("bad argument #1 to 'packsize' (format result too large)",2)end;a7=a7+S elseif a9=='x'then a7=a7+1 elseif a9=='X'then if v>=#a6 then error("invalid next option for option 'X'",2)end;local S=0;local a9=a6:sub(v,v)v=v+1;if a9:lower()=='i'then while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 or S==0 then error(string.format("integral size (%d) out of limits [1,16]",S),2)end else S=a3(a9,0)end;if S<1 then error("invalid next option for option 'X'",2)end;if a7%math.min(S,V)~=0 and V>1 then for aa=1,V do if a7%math.min(S,V)==0 then break end;a7=a7+1 end end elseif a9=='s'or a9=='z'then error("bad argument #1 to 'packsize' (variable-length format)",2)elseif a9~=' 'and a9~='<'and a9~='>'and a9~='='then error(string.format("invalid format option '%s'",a9),2)end end;return a7 end;function string.unpack(a6,a0,a7)expect(1,a6,"string")expect(2,a0,"string")expect(3,a7,"number","nil")if a7 then if a7<0 then a7=#a0+a7 elseif a7==0 then error("bad argument #3 to 'unpack' (initial position out of string)",2)end;if a7>#a0 or a7<0 then error("bad argument #3 to 'unpack' (initial position out of string)",2)end else a7=1 end;local W=F.LITTLE_ENDIAN;local V=1;local a5={}local v=1;while v<=#a6 do local a9=a6:sub(v,v)v=v+1;if a9=='<'or a9=='='then W=F.LITTLE_ENDIAN elseif a9=='>'then W=F.BIG_ENDIAN elseif a9=='!'then local S=0;while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 then error(string.format("integral size (%d) out of limits [1,16]",S))elseif S==0 then V=4 else V=S end elseif G[a9]then if a7+a3(a9,0)>#a0+1 then error("data string too short",2)end;local u,ac=_(a0,a7,a3(a9,0),W,V,a9:match("%l")~=nil)a5[#a5+1]=u;a7=a7+ac elseif a9:lower()=='i'then local X=a9=='i'local S=0;while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 then error(string.format("integral size (%d) out of limits [1,16]",S),2)elseif S>8 then error(string.format("%d-byte integer does not fit into Lua Integer",S),2)elseif S==0 then S=4 end;if a7+S>#a0+1 then error("data string too short",2)end;local u,ac=_(a0,a7,S,W,V,X)a5[#a5+1]=u;a7=a7+ac elseif a9=='f'then if a7%math.min(4,V)~=0 and V>1 then for aa=1,V do if a7%math.min(4,V)==0 then break end;a7=a7+1 end end;if a7+4>#a0+1 then error("data string too short",2)end;local u=_(a0,a7,4,W,V,false)a5[#a5+1]=M(u)a7=a7+4 elseif a9=='d'or a9=='n'then if a7%math.min(8,V)~=0 and V>1 then for aa=1,V do if a7%math.min(8,V)==0 then break end;a7=a7+1 end end;if a7+8>#a0+1 then error("data string too short",2)end;local P,Q=0,0;for aa=0,3 do P=bit32.bor(P,bit32.lshift(a0:byte(a7+aa),(W==F.BIG_ENDIAN and 3-aa or aa)*8))end;for aa=0,3 do Q=bit32.bor(Q,bit32.lshift(a0:byte(a7+aa+4),(W==F.BIG_ENDIAN and 3-aa or aa)*8))end;if W==F.LITTLE_ENDIAN then P,Q=Q,P end;a5[#a5+1]=O(P,Q)a7=a7+8 elseif a9=='c'then local S=0;if v>#a6 or not a6:sub(v,v):match("%d")then error("missing size for format option 'c'",2)end;while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)")end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if a7+S>#a0+1 then error("data string too short",2)end;a5[#a5+1]=a0:sub(a7,a7+S-1)a7=a7+S elseif a9=='z'then local S=0;while a0:byte(a7+S)~=0 do S=S+1;if a7+S>#a0 then error("unfinished string for format 'z'",2)end end;a5[#a5+1]=a0:sub(a7,a7+S-1)a7=a7+S+1 elseif a9=='s'then local S=0;while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 then error(string.format("integral size (%d) out of limits [1,16]",S),2)elseif S==0 then S=4 end;if a7+S>#a0+1 then error("data string too short",2)end;local b,ad=_(a0,a7,S,W,V,false)a7=a7+ad;if a7+b>#a0+1 then error("data string too short",2)end;a5[#a5+1]=a0:sub(a7,a7+b-1)a7=a7+b elseif a9=='x'then a7=a7+1 elseif a9=='X'then if v>=#a6 then error("invalid next option for option 'X'",2)end;local S=0;local a9=a6:sub(v,v)v=v+1;if a9:lower()=='i'then while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 or S==0 then error(string.format("integral size (%d) out of limits [1,16]",S),2)elseif S==-1 then S=4 end else S=a3(a9,0)end;if S<1 then error("invalid next option for option 'X'",2)end;if a7%math.min(S,V)~=0 and V>1 then for aa=1,V do if a7%math.min(S,V)==0 then break end;a7=a7+1 end end elseif a9~=' 'then error(string.format("invalid format option '%s'",a9),2)end end;a5[#a5+1]=a7;return table.unpack(a5)end end;function panic(ae)term.setBackgroundColor(32768)term.setTextColor(16384)term.setCursorBlink(false)local p,q=term.getCursorPos()p=1;local af,ag=term.getSize()ae="panic: "..(ae or"unknown")for ah in ae:gmatch"%S+"do if p+#ah>=af then p,q=1,q+1;if q>ag then term.scroll(1)q=q-1 end end;term.setCursorPos(p,q)if p==1 then term.clearLine()end;term.write(ah.." ")p=p+#ah+1 end;p,q=1,q+1;if q>ag then term.scroll(1)q=q-1 end;if debug then local ai=debug.traceback(nil,2)for aj in ai:gmatch"[^\n]+"do term.setCursorPos(1,q)term.write(aj)q=q+1;if q>ag then term.scroll(1)q=q-1 end end end;term.setCursorPos(1,q)term.setTextColor(2)term.write("panic: We are hanging here...")mainThread=nil;while true do coroutine.yield()end end;function do_syscall(ak,...)local u=table.pack(coroutine.yield("syscall",ak,...))if u[1]then return table.unpack(u,2,u.n)else error(u[2],3)end end;function deepcopy(al)if type(al)=="table"then local a5=setmetatable({},deepcopy(getmetatable(al)))for h,i in pairs(al)do a5[deepcopy(h)]=deepcopy(i)end;return a5 else return al end end;function split(a0,am)local y={}for an in a0:gmatch("[^"..(am or"%s").."]+")do y[#y+1]=an end;return y end;local ao=pcall(os.epoch,"nano")and function()return os.epoch"nano"/1000000 end or(ccemux and function()return ccemux.nanoTime()/1000000 end or function()return os.epoch"utc"end)local ap={n=0}function executeThread(process,aq,ar,as,at)local args;if aq.status=="starting"then args=aq.args elseif aq.status=="syscall"then args=table.pack(table.unpack(aq.syscall_return,3,aq.syscall_return.n))elseif aq.status=="preempt"then args=ap elseif aq.status=="suspended"then args={ar[1],{}}for h,i in pairs(ar[2])do args[2][h]=i end elseif aq.status=="paused"then return false,at end;if aq.status~="dead"and(not aq.filter or aq.filter(process,aq,ar))then local au=as;as=false;aq.filter=nil;local av;if aq.yielding then av={n=aq.syscall_return.n,true,"syscall",aq.yielding,table.unpack(aq.syscall_return,4,aq.syscall_return.n)}aq.yielding=nil else local aw=globalMetatables;globalMetatables=process.globalMetatables;updateGlobalMetatables()local ax=ao()av=table.pack(coroutine.resume(aq.coro,table.unpack(args,1,args.n)))process.cputime=process.cputime+(ao()-ax)/1000;globalMetatables=aw;updateGlobalMetatables()end;if av[2]=="secure_syscall"then av[2]="syscall"elseif av[2]=="secure_event"then av[2]=nil end;if av[2]=="syscall"then aq.status="syscall"local ay=at;at=false;if av[3]and syscalls[av[3]]then local ax=ao()aq.syscall_return=table.pack(coroutine.resume(aq.syscall,av[3],process,aq,table.unpack(av,4,av.n)))process.systime=process.systime+(ao()-ax)/1000;if aq.syscall_return[2]==kSyscallComplete then if not aq.syscall_return[3]and type(aq.syscall_return[4])=="string"then syslog.log({level="debug",category="Syscall Failure",process=0,module=av[3]},aq.syscall_return[4])aq.syscall_return[4]=aq.syscall_return[4]:gsub("kernel:%d+: ","")end;if aq.syscall_return[4]==kSyscallYield then aq.yielding=aq.syscall_return[5]at=ay end else aq.yielding=av[3]end else aq.syscall_return={false,"No such syscall",n=2}end elseif av[2]=="preempt"then aq.status="preempt"at=false elseif coroutine.status(aq.coro)=="dead"then aq.status="dead"aq.return_value=av[2]if av[1]then process.lastReturnValue={pid=process.id,thread=aq.id,value=av[2],n=av.n-1,table.unpack(av,2,av.n)}else process.lastReturnValue={pid=process.id,thread=aq.id,error=av[2],traceback=debug.traceback(aq.coro)}end;if not av[1]then aq.did_error=true;syslog.log({level=_G.args.traceback and"error"or"debug",process=process.id,thread=aq.id,category="Application Error",traceback=true},debug.traceback(aq.coro,av[2]))if av[2]and process.stderr and process.stderr.isTTY then terminal.write(process.stderr,av[2].."\n")end end;process.threads[aq.id]=nil;as=au else aq.status="suspended"at=at and#process.eventQueue==0 end end;return as,at end;mainThread=coroutine.running()function userModeCallback(process,az,...)local aA=syscalls.newthread(process,nil,az,...)local aq=process.threads[aA]while aq.status~="dead"do if coroutine.running()==mainThread then error("userModeCallback not called from a yieldable context",2)end;coroutine.yield()end;return not aq.did_error,aq.return_value end;function make_ENV(e)if type(e)~="table"or _VERSION~="Lua 5.1"then return e end;repeat local aB=getmetatable(e)if aB and aB.__env then e=aB.__env end until not aB or not aB.__env;local y=setmetatable({},{__index=function(self,aC)if self==e then e=getmetatable(self).__env end;if aC=="_ENV"then return e else return e[aC]end end,__newindex=function(self,aC,aD)if self==e then e=getmetatable(self).__env end;if aC=="_ENV"then e=aD else e[aC]=aD end end,__pairs=function(self)if self==e then e=getmetatable(self).__env end;return next,e end,__len=function(self)if self==e then e=getmetatable(self).__env end;return#e end,__env=e})return y end;for z,i in ipairs({...})do local aE,aF=i:match("^([^=]+)=(.+)$")if aE and aF then if type(args[aE])=="boolean"then args[aE]=aF:lower()=="true"or aF=="1"elseif type(args[aE])=="number"then args[aE]=tonumber(aF)else args[aE]=aF end elseif aE=="silent"then args.loglevel=5 elseif aE=="quiet"then args.loglevel=3 end end;local function aG(aH)local u;if _CC_VERSION then u=aH<=_CC_VERSION elseif not _HOST then u=aH<=os.version():gsub("CraftOS ","")elseif _HOST:match("ComputerCraft 1%.1%d+")~=aH:match("1%.1%d+")then aH=aH:gsub("(1%.)([02-9])","%10%2")local aI=_HOST:gsub("(ComputerCraft 1%.)([02-9])","%10%2")u=aH<=aI:match("ComputerCraft ([0-9%.]+)")else u=aH<=_HOST:match("ComputerCraft ([0-9%.]+)")end;return u end;if not aG"1.87.0"then panic("Phoenix requires ComputerCraft 1.87.0 or later. Please upgrade your version of ComputerCraft.")end;if jit and args.preemptive then panic("Phoenix does not support preemption when running under LuaJIT. Please set preemptive to false in the kernel arguments.")end;if not debug and args.preemptive then panic("Phoenix does not support preemption without the debug API. Please set preemptive to false in the kernel arguments.")end;if args.preemptive then PHOENIX_BUILD=PHOENIX_BUILD.." PREEMPT"end;if not getfenv then if not debug then panic("Phoenix requires the debug API when running under Lua 5.2 and later.")end;function getfenv(g)local v=1;while true do local m,aD=debug.getupvalue(g,v)if m=="_ENV"then return aD elseif not m then break end;v=v+1 end end;function setfenv(g,e)local v=1;while true do local m=debug.getupvalue(g,v)if m=="_ENV"then debug.upvaluejoin(g,v,function()return e end,1)break elseif not m then break end;v=v+1 end;return g end end;globalMetatables={["nil"]={},["boolean"]={},["number"]={},["string"]={__index=string},["function"]={},["thread"]={__index=coroutine,__call=coroutine.resume},["userdata"]={}}local aJ,aK=debug.getmetatable,debug.setmetatable;function updateGlobalMetatables()aK(nil,globalMetatables["nil"])aK(false,globalMetatables["boolean"])aK(0,globalMetatables["number"])aK("",globalMetatables["string"])aK(assert,globalMetatables["function"])aK(coroutine.running(),globalMetatables["thread"])if debug.upvalueid then aK(debug.upvalueid(executeThread,1),globalMetatables["userdata"])end end;local type=type;function debug.getmetatable(aD)if type(aD)=="table"then return aJ(aD)else return globalMetatables[type(aD)]end end;function debug.setmetatable(aD,al)expect(2,al,"table")if type(aD)=="table"then return aK(aD,al)else globalMetatables[type(aD)]=al end end;do local aL;local aM,aN,aO,aP,aQ,aR,aS,aT,aU=getfenv,setfenv,debug.getfenv,debug.getlocal,debug.getupvalue,debug.setfenv,debug.setlocal,debug.setupvalue,debug.upvaluejoin;local error,aV,aW,select,setmetatable,type,tonumber=error,debug.getinfo,coroutine.running,select,setmetatable,type,tonumber;local aX;local function keys(y,i,...)if i then y[i]=true end;if select("#",...)>0 then return keys(y,...)else return y end end;local function aY(i,...)if select("#",...)>0 then return aX[i or""]or i,aY(...)else return aX[i or""]or i end end;local function aZ(r)r=bit32.band(tonumber(r),0xFFFFFFFF)if bit32.btest(r,0x80000000)then r=r-0x100000000 end;return r end;function debug.getinfo(aq,az,a_)if type(aq)~="thread"then a_,az,aq=az,aq,aW()end;local a5;if tonumber(az)then a5=aV(aq,az+1,a_)else a5=aV(aq,az,a_)end;if a5 and a5.func then a5.func=aX[a5.func]or a5.func end;return a5 end;function debug.getlocal(aq,b0,b1)if b1==nil then b1,b0,aq=b0,aq,aW()end;local h,i;if type(b0)=="function"then local b2=aV(2,"f")if aL[b0]and not(b2 and aL[b0][b2.func])then return nil end;h,i=aY(aP(b0,b1))elseif tonumber(b0)then local b3=aV(aq,b0+1,"f")local b2=aV(2,"f")if b3 and aL[b3.func]and not(b2 and aL[b3.func][b2.func])then return nil end;h,i=aY(aP(aq,b0+1,b1))else h,i=aY(aP(aq,b0,b1))end;return h,i end;function debug.getupvalue(az,b4)if type(az)=="function"then local b2=aV(2,"f")if aL[az]and not(b2 and aL[az][b2.func])then return nil end end;local h,i=aY(aQ(az,b4))return h,i end;function debug.setlocal(aq,b0,b1,aF)if b1==nil then b1,b0,aq=b0,aq,aW()end;if tonumber(b0)then local b3=aV(aq,b0+1,"f")local b2=aV(2,"f")if b3 and aL[b3.func]and not(b2 and aL[b3.func][b2.func])then error("attempt to set local of protected function",2)end;aS(aq,b0+1,b1,aF)else aS(aq,b0,b1,aF)end end;function debug.setupvalue(az,b4,aF)if type(az)=="function"then local b2=aV(2,"f")if aL[az]and not(b2 and aL[az][b2.func])then error("attempt to set upvalue of protected function",2)end end;aT(az,b4,aF)end;function _G.getfenv(f)local i;if f==nil then i=aM(2)elseif tonumber(f)and aZ(f)>0 then local b3=aV(f+1,"f")local b2=aV(2,"f")if b3 and aL[b3.func]and not(b2 and aL[b3.func][b2.func])then return nil end;i=aM(f+1)elseif type(f)=="function"then local b2=aV(2,"f")if aL[f]and not(b2 and aL[f][b2.func])then return nil end;i=aM(f)else i=aM(f)end;return i end;function _G.setfenv(f,al)if tonumber(f)and aZ(f)>0 then local b3=aV(f+1,"f")local b2=aV(2,"f")if b3 and aL[b3.func]and not(b2 and aL[b3.func][b2.func])then error("attempt to set environment of protected function",2)end;aN(f+1,al)elseif type(f)=="function"then local b2=aV(2,"f")if aL[f]and not(b2 and aL[f][b2.func])then error("attempt to set environment of protected function",2)end end;aN(f,al)end;if aO then function debug.getfenv(b5)if type(b5)=="function"then local b2=aV(2,"f")if aL[b5]and not(b2 and aL[b5][b2.func])then return nil end end;local i=aO(b5)return i end;function debug.setfenv(b5,al)if type(b5)=="function"then local b2=aV(2,"f")if aL[b5]and not(b2 and aL[b5][b2.func])then error("attempt to set environment of protected function",2)end end;aR(b5,al)end end;if aU then function debug.upvaluejoin(b6,b7,b8,b9)if type(b6)=="function"and type(b8)=="function"then local b2=aV(2,"f")if aL[b6]and not(b2 and aL[b6][b2.func])then error("attempt to get upvalue of protected function",2)end;if aL[b8]and not(b2 and aL[b8][b2.func])then error("attempt to set upvalue of protected function",2)end end;aU(b6,b7,b8,b9)end end;function debug.protect(az)if type(az)~="function"then error("bad argument #1 (expected function, got "..type(az)..")",2)end;if aL[az]then error("attempt to protect a protected function",2)end;aL[az]=keys(setmetatable({},{__mode="k"}))end;aX={[aP]=debug.getlocal,[aS]=debug.setlocal,[aQ]=debug.getupvalue,[aT]=debug.setupvalue,[aV]=debug.getinfo,[aY]=function()end}if debug.upvaluejoin then aX[aU]=debug.upvaluejoin end;if debug.getfenv then aX[aO]=debug.getfenv end;if debug.setfenv then aX[aR]=debug.setfenv end;if _G.getfenv then aX[aM]=_G.getfenv end;if _G.setfenv then aX[aN]=_G.setfenv end;aL=keys(setmetatable({},{__mode="k"}),getfenv,setfenv,debug.getfenv,debug.setfenv,debug.getlocal,debug.setlocal,debug.getupvalue,debug.setupvalue,debug.upvaluejoin,debug.getinfo,aY,debug.protect)for h,i in pairs(aL)do aL[h]={}end end;fs=fs;mounts={}fifos={}fsevents={}filesystems={craftos={meta={meta={type="directory",owner="root",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}},metapath="/meta.ltn",lastDispatch=0},tmpfs={},drivefs={},tablefs={},bind={}}local function ba(process,bb)local E=fs.combine(process.root,bb:sub(1,1)=="/"and""or process.dir,bb)if"/"..E.."/"~=process.root and E:find(process.root:sub(2),1,true)~=1 then error(bb..": No such file or directory",4)end;return E end;local function bc(process,bb,bd)local be=split(ba(process,bb),"/\\")if#be==0 then return mounts[""],bb,""end;local bf;for h in pairs(mounts)do local bg=true;for v,a9 in ipairs(split(h,"/\\"))do if be[v]~=a9 then bg=false;break end end;if bg and(not bf or#h>#bf)then bf=h end end;if not bf then panic("Could not find mount for path "..bb..". Where is root?")end;local bh=split(bf,"/\\")local E=#be>=#bh+1 and fs.combine(table.unpack(be,#bh+1,#be))or""local mounts=mounts[bf]if bd then return mounts,E,bf end;local bi=mounts[1]if#mounts>1 then for z,i in ipairs(mounts)do local bg,u=pcall(i.stat,i,process,E,true)if bg and u then bi=i;break end end end;return bi,E,bf end;function filesystem.readhandle(process,bj,bk)if bj==""then local bl=false;local function bm()if bl then return nil end;bl=true;return""end;local bn={readLine=bm,readAll=bm,read=bm,close=function()end}if bk then function bn.seek()bl=false end;function bn.read(r)if not r then return nil end;return bm()end end;return bn end;local a7=1;local bo=false;local y={readLine=function(bp)if bo then error("attempt to use a closed file",2)end;if a7>#bj then return nil end;local bq;bq,a7=bj:match("([^\n]*"..(bp and"\n?)"or")\n?").."()",a7)return bq end,readAll=function()if bo then error("attempt to use a closed file",2)end;if a7>#bj then return nil end;local bq=bj:sub(a7)a7=#bq+1;return bq end,read=function(r)if bo then error("attempt to use a closed file",2)end;if r~=nil and type(r)~="number"then error("bad argument #1 (expected number, got "..type(r)..")",2)end;r=r or 1;if a7>#bj then return nil end;local bq=bj:sub(a7,a7+r-1)a7=a7+r;return bq end,close=function()if bo then error("attempt to use a closed file",2)end;bo=true end}if bk then y.read=function(r)if bo then error("attempt to use a closed file",2)end;if r~=nil and type(r)~="number"then error("bad argument #1 (expected number, got "..type(r)..")",2)end;if a7>#bj then return nil end;if r then local bq=bj:sub(a7,a7+r-1)a7=a7+r;return bq else local bq=bj:byte(a7)a7=a7+1;return bq end end;y.seek=function(br,U)if br~=nil and type(br)~="string"then error("bad argument #1 (expected string, got "..type(br)..")",2)end;if U~=nil and type(U)~="number"then error("bad argument #2 (expected number, got "..type(U)..")",2)end;br=br or"cur"U=U or 0;if bo then error("attempt to use closed file",2)end;if br=="set"then a7=U+1 elseif br=="cur"then a7=a7+U elseif br=="end"then a7=math.max(#bj-U,1)else error("Invalid whence",2)end;return a7-1 end else bj=bj:gsub("[\x80-\xFF]+",function(bs)local bt=""if not pcall(function()for z,bu in utf8.codes(bs)do bt=bt..(bu<256 and string.char(bu)or"?")end end)then return bs end;return bt end)end;for z,i in pairs(y)do setfenv(i,process.env)debug.protect(i)end;return setmetatable(y,{__name="file"})end;function filesystem.writehandle(process,bv,bk)setfenv(bv,process.env)local function bw(y)for z,i in pairs(y)do setfenv(i,process.env)debug.protect(i)end;return setmetatable(y,{__name="file"})end;local bo=false;if bk then local a7=1;local bx=""local by=""return bw{write=function(bq)if bo then error("attempt to use a closed file",2)end;if type(bq)=="number"then bx,a7=bx:sub(1,a7-1)..string.char(bq)..bx:sub(a7+1),a7+1;if by then by=by..string.char(bq)end elseif type(bq)=="string"then bx,a7=bx:sub(1,a7-1)..bq..bx:sub(a7+#bq),a7+#bq;if by then by=by..bq end else error("bad argument #1 (expected string or number, got "..type(bq)..")",2)end end,writeLine=function(bq)if bo then error("attempt to use a closed file",2)end;if type(bq)=="number"then bx,a7=bx:sub(1,a7-1)..string.char(bq).."\n"..bx:sub(a7+2),a7+2;if by then by=by..string.char(bq).."\n"end elseif type(bq)=="string"then bx,a7=bx:sub(1,a7-1)..bq.."\n"..bx:sub(a7+#bq+1),a7+#bq+1;if by then by=by..bq.."\n"end else error("bad argument #1 (expected string or number, got "..type(bq)..")",2)end end,seek=function(br,U)if br~=nil and type(br)~="string"then error("bad argument #1 (expected string, got "..type(br)..")",2)end;if U~=nil and type(U)~="number"then error("bad argument #2 (expected number, got "..type(U)..")",2)end;br=br or"cur"U=U or 0;if bo then error("attempt to use closed file",2)end;local bz=a7;if br=="set"then a7=U+1 elseif br=="cur"then a7=a7+U elseif br=="end"then a7=math.max(#bx-U,1)else error("Invalid whence",2)end;if bz~=a7 then by=nil end;return a7-1 end,flush=function()if bo then error("attempt to use a closed file",2)end;if by then bv(by,false)else bv(bx,true)end;by=""end,close=function()if bo then error("attempt to use a closed file",2)end;bo=true;if by then bv(by,false)else bv(bx,true)end;by=""end}else local bx=""return bw{write=function(bq)if bo then error("attempt to use a closed file",2)end;bx=bx..tostring(bq)end,writeLine=function(bq)if bo then error("attempt to use a closed file",2)end;bx=bx..tostring(bq).."\n"end,flush=function()if bo then error("attempt to use a closed file",2)end;bv(bx,false)bx=""end,close=function()if bo then error("attempt to use a closed file",2)end;bv(bx,false)bx=""bo=true end}end end;function filesystem.fifohandle(process,bA,n)local bo=false;local function bw(y)for z,i in pairs(y)do setfenv(i,process.env)debug.protect(i)end;return setmetatable(y,{__name="file"})end;if n=="r"then return bw{readLine=function(bp)if bo then error("attempt to use a closed file",2)end;if#bA.data==0 then return nil end;local bq;bq,bA.data=bA.data:match("([^\n]*"..(bp and"\n?)"or")\n?").."(.*)")return bq end,readAll=function()if bo then error("attempt to use a closed file",2)end;if#bA.data==0 then return nil end;local bq=bA.data;bA.data=""return bq end,read=function(r)if bo then error("attempt to use a closed file",2)end;if r~=nil and type(r)~="number"then error("bad argument #1 (expected number, got "..type(r)..")",2)end;r=r or 1;if#bA.data==0 then return nil end;local bq=bA.data:sub(1,r)bA.data=bA.data:sub(r+1)return bq end,close=function()if bo then error("attempt to use a closed file",2)end;bo=true end}elseif n=="w"or n=="a"then local bx=bA.data;return bw{write=function(bq)if bo then error("attempt to use a closed file",2)end;bx=bx..tostring(bq)end,writeLine=function(bq)if bo then error("attempt to use a closed file",2)end;bx=bx..tostring(bq).."\n"end,flush=function()if bo then error("attempt to use a closed file",2)end;bA.data=bx end,close=function()if bo then error("attempt to use a closed file",2)end;bA.data=bx;bo=true end}elseif n=="rb"then return bw{readLine=function(bp)if bo then error("attempt to use a closed file",2)end;if#bA.data==0 then return nil end;local bq;bq,bA.data=bA.data:match("([^\n]*"..(bp and"\n?)"or")\n?").."(.*)")return bq end,readAll=function()if bo then error("attempt to use a closed file",2)end;if#bA.data==0 then return nil end;local bq=bA.data;bA.data=""return bq end,read=function(r)if bo then error("attempt to use a closed file",2)end;if r~=nil and type(r)~="number"then error("bad argument #1 (expected number, got "..type(r)..")",2)end;if#bA.data==0 then return nil end;if r then local bq=bA.data:sub(1,r)bA.data=bA.data:sub(r+1)return bq else local bq=bA.data:byte()bA.data=bA.data:sub(2)return bq end end,seek=function(br,U)if br~=nil and type(br)~="string"then error("bad argument #1 (expected string, got "..type(br)..")",2)end;if U~=nil and type(U)~="number"then error("bad argument #2 (expected number, got "..type(U)..")",2)end;if bo then error("attempt to use closed file",2)end;return 0 end,close=function()if bo then error("attempt to use a closed file",2)end;bo=true end}elseif n=="wb"or n=="ab"then local bx=bA.data;return bw{write=function(bq)if bo then error("attempt to use a closed file",2)end;if type(bq)=="number"then bx=bx..string.char(bq)elseif type(bq)=="string"then bx=bx..bq else error("bad argument #1 (expected string or number, got "..type(bq)..")",2)end end,writeLine=function(bq)if bo then error("attempt to use a closed file",2)end;if type(bq)=="number"then bx=bx..string.char(bq).."\n"elseif type(bq)=="string"then bx=bx..bq.."\n"else error("bad argument #1 (expected string or number, got "..type(bq)..")",2)end end,seek=function(br,U)if br~=nil and type(br)~="string"then error("bad argument #1 (expected string, got "..type(br)..")",2)end;if U~=nil and type(U)~="number"then error("bad argument #2 (expected number, got "..type(U)..")",2)end;if bo then error("attempt to use closed file",2)end;return#bA.data+#bx end,flush=function()if bo then error("attempt to use a closed file",2)end;bA.data=bx end,close=function()if bo then error("attempt to use a closed file",2)end;bA.data=bx;bo=true end}else return nil,"Invalid mode"end end;filesystem.openfifo=filesystem.fifohandle;do local a=fs.open("/meta.ltn","r")if a then filesystems.craftos.meta=unserialize(a.readAll())or filesystems.craftos.meta;filesystems.craftos.lastDispatch=os.epoch"utc"a.close()end end;shutdownHooks[#shutdownHooks+1]=function()syslog.log("Syncing filesystem")local a=fs.open(filesystems.craftos.metapath,"w")if a then a.write(serialize(filesystems.craftos.meta,{compact=true}))a.close()end end;if args.fsmeta then local a=fs.open(args.fsmeta,"r")if a then local bB=unserialize(a.readAll())a.close()if bB then local function bC(bD,bE)for h,i in pairs(bD)do if bE[h]and type(bE[h])=="table"and type(i)=="table"then bC(i,bE[h])else bE[h]=i end end end;bC(bB,filesystems.craftos.meta)end end end;function filesystems.craftos:getmeta(user,bb,bF)local bG={}local y=self.meta;local bh=split(bb,"/\\")for v,E in ipairs(bh)do if E==".."then y=table.remove(bG)if not y then return nil end elseif not E:match"^%.*$"then if not y then return nil elseif y.meta.type~="directory"then error("Not a directory",2)elseif y.meta.permissions[user]then if not y.meta.permissions[user].execute then error("Permission denied",2)end elseif not y.meta.worldPermissions.execute then error("Permission denied",2)end;bG[#bG+1]=y;y=y.contents[E]if y and y.meta.type=="link"and not(bF and v==#bh)then syslog.debug("linking "..bb.." to "..filesystem.combine(y.meta.link,table.unpack(bh,v+1)))error{link=true,path=filesystem.combine(y.meta.link,table.unpack(bh,v+1)),orig=bb}end end end;return y and y.meta end;function filesystems.craftos:setmeta(user,bb,bB,bF)local bG={}local y=self.meta;local m;local bh=split(bb,"/\\")for v,E in ipairs(bh)do if E==".."then y=table.remove(bG)if not y then error("Not a directory",2)end elseif not E:match"^%.*$"then if y.meta.type~="directory"then error("Not a directory",2)elseif y.meta.permissions[user]then if not y.meta.permissions[user].execute then error("Permission denied",2)end elseif not y.meta.worldPermissions.execute then error("Permission denied",2)end;if not y.contents[E]then y.contents[E]={meta={type="directory",owner=y.meta.owner or"root",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}}end;bG[#bG+1]=y;y=y.contents[E]m=E;if y and y.meta.type=="link"and not(bF and v==#bh)then syslog.debug("linking "..bb.." to "..filesystem.combine(y.meta.link,table.unpack(bh,v+1)))error{link=true,path=filesystem.combine(y.meta.link,table.unpack(bh,v+1)),orig=bb}end end end;if bB~=nil then y.meta={type=bB.type,owner=bB.owner,permissions=deepcopy(bB.permissions),worldPermissions=deepcopy(bB.worldPermissions),setuser=bB.setuser,link=bB.link}if bB.type~="directory"then y.contents=nil end else bG[#bG].contents[m]=nil end;if os.epoch"utc"-self.lastDispatch>1000 then local a=assert(fs.open(self.metapath,"w"))a.write(serialize(self.meta,{compact=true}))a.close()self.lastDispatch=os.epoch"utc"end end;function filesystems.craftos:new(process,bb,bH)expect.field(bH,"ro","boolean","nil")if process.user~="root"then error("Could not mount "..bb..": Permission denied",3)elseif not fs.isDir(bb)then error("Could not mount "..bb..": No such directory",3)end;return setmetatable({path=bb,readOnly=bH.ro},{__index=self})end;function filesystems.craftos:open(process,bb,n)local bg,bI=pcall(self.stat,self,process,bb)if not bg then if type(bI)=="table"then error(bI)end;return nil,bI elseif not bI then if n:sub(1,1)=="w"or n:sub(1,1)=="a"then if self.readOnly then return nil,"Read-only filesystem"end;local bJ,bK=pcall(self.stat,self,process,fs.getDir(bb))if not bJ or not bK then if type(bK)=="table"then error(bK)end;local bL,o=pcall(self.mkdir,self,process,fs.getDir(bb))if not bL then if type(o)=="table"then error(o)end;return nil,o:gsub("kernel:%d: ","")end;bK=self:stat(process,fs.getDir(bb))if not bK then return nil,"Could not stat "..fs.getDir(bb)end end;if process.user~="root"then local bM=bK.permissions[process.user]or bK.worldPermissions;if not bM.write then return nil,"Permission denied"end end;local bB={type="file",owner=process.user,permissions=deepcopy(bK.permissions),worldPermissions=deepcopy(bK.worldPermissions),setuser=false}if bK.owner then local y=bB.permissions[bK.owner]bB.permissions[bK.owner]=nil;bB.permissions[process.user]=y end;self:setmeta(process.user,fs.combine(self.path,bb),bB)local a,o=fs.open(fs.combine(self.path,bb),n)if not a then return a,o end;return setmetatable(a,{__name="file"})else return nil,"File not found"end elseif bI.type=="directory"then return nil,"Is a directory"end;local bM=bI.permissions[process.user]or bI.worldPermissions;if process.user~="root"and(n:sub(1,1)=="r"and not bM.read or(n:sub(1,1)=="w"or n:sub(1,1)=="a")and not bM.write)then return nil,"Permission denied"end;if bI.type=="fifo"then local bB=self:getmeta(process.user,fs.combine(self.path,bb))local bN=fifos[bB]if not bN then bN={data=""}fifos[bB]=bN end;return filesystem.fifohandle(process,bN,n)end;return setmetatable(fs.open(fs.combine(self.path,bb),n),{__name="file"})end;function filesystems.craftos:list(process,bb)local bI=self:stat(process,bb)if not bI or bI.type~="directory"then error(bb..": Not a directory",2)end;if process.user~="root"then local bM=bI.permissions[process.user]or bI.worldPermissions;if not bM.read then error(bb..": Permission denied",2)end end;return fs.list(fs.combine(self.path,bb))end;function filesystems.craftos:stat(process,bb,bF)local E=fs.combine(self.path,bb)if E:find(self.path:gsub("^/",""):gsub("/$",""),1,false)~=1 then return nil end;local bg,bO=pcall(fs.attributes,E)if not bg or not bO then return nil end;bO.type=bO.isDir and"directory"or"file"bO.special={}bO.isDir=nil;if not bO.modified then bO.modified=bO.modification end;bO.modification=nil;bO.capacity=fs.getCapacity(E)or 0;bO.freeSpace=fs.getFreeSpace(E)local bP=bO.isReadOnly;bO.isReadOnly=nil;local bB=self:getmeta(process.user,fs.combine(self.path,bb),bF)if bB then bO.owner=bB.owner;bO.permissions=deepcopy(bB.permissions)bO.worldPermissions=deepcopy(bB.worldPermissions)bO.type=bB.type or bO.type;bO.setuser=bB.setuser;bO.link=bB.link else bO.owner="root"bO.permissions={root={read=true,write=true,execute=true}}bO.worldPermissions={read=true,write=false,execute=true}bO.setuser=false end;if bP then bO.worldPermissions.write=false;for z,i in pairs(bO.permissions)do i.write=false end end;return bO end;function filesystems.craftos:remove(process,bb)if self.readOnly then error(bb..": Read-only filesystem",2)end;local bI=self:stat(process,bb,true)if not bI then return end;local function bQ(E)local bs=self:stat(process,E,true)local bM=bs.permissions[process.user]or bs.worldPermissions;if process.user~="root"and not bM.write then error(E..": Permission denied",3)end;if bs.type=="directory"then if process.user~="root"and not bM.read then error(E..": Permission denied",3)end;for z,i in ipairs(fs.list(fs.combine(self.path,E)))do bQ(fs.combine(E,i))end end end;bQ(bb)fs.delete(fs.combine(self.path,bb))self:setmeta(process.user,fs.combine(self.path,bb),nil,true)end;function filesystems.craftos:rename(process,bR,bS)if self.readOnly then error("Read-only filesystem",2)end;local bT=self:stat(process,bR,true)local bU=self:stat(process,bS,true)if not bT then error(bR..": No such file or directory",2)elseif bU then error(bS..": "..bU.type:gsub("%w",string.upper,1).." already exists",2)end;bU=self:stat(process,fs.getDir(bS))if not bU then self:mkdir(process,fs.getDir(bS))bU=self:stat(process,fs.getDir(bS))end;if process.user~="root"then local bM=bU.permissions[process.user]or bU.worldPermissions;if not bM.write then error(bS..": Permission denied",2)end end;fs.move(fs.combine(self.path,bR),fs.combine(self.path,bS))self:setmeta(process.user,fs.combine(self.path,bS),self:getmeta(process.user,fs.combine(self.path,bR),true),true)self:setmeta(process.user,fs.combine(self.path,bR),nil,true)end;function filesystems.craftos:mkdir(process,bb)if self.readOnly then error(bb..": Read-only filesystem",2)end;local bI=self:stat(process,bb)if bI then if bI.type=="directory"then return else error(bb..": File already exists",2)end end;local bh=split(bb,"/\\")local v=#bh;repeat v=v-1;bI=self:stat(process,table.concat(bh,"/",1,v))if bI then if bI.type=="directory"then break else error(bb..": File already exists",2)end end until bI or v<=0;if not bI then if bb:match"^/"then bI=assert(self:stat(process,"/"))else bI=assert(filesystem.stat(process,process.dir))end end;if process.user~="root"then local bM=bI.permissions[process.user]or bI.worldPermissions;if not bM.write then error(bb..": Permission denied",2)end end;local bB={type="directory",owner=process.user,permissions=deepcopy(bI.permissions),worldPermissions=deepcopy(bI.worldPermissions)}if bI.owner then local y=bB.permissions[bI.owner]bB.permissions[bI.owner]=nil;bB.permissions[process.user]=y end;v=v+1;while v<=#bh do self:setmeta(process.user,fs.combine(self.path,table.concat(bh,"/",1,v)),deepcopy(bB))v=v+1 end;fs.makeDir(fs.combine(self.path,bb))end;function filesystems.craftos:link(process,bb,bV)local bI=self:stat(process,bb)if bI then error(bb..": File exists",2)end;assert(self:open(process,bb,"w")).close()local bB=self:getmeta(process.user,fs.combine(self.path,bb),true)bB.type,bB.link="link",bV;self:setmeta(process.user,fs.combine(self.path,bb),bB,true)end;function filesystems.craftos:mkfifo(process,bb)local bI=self:stat(process,bb)if bI then error(bb..": File exists",2)end;assert(self:open(process,bb,"w")).close()local bB=self:getmeta(process.user,fs.combine(self.path,bb),true)bB.type="fifo"self:setmeta(process.user,fs.combine(self.path,bb),bB,true)end;function filesystems.craftos:chmod(process,bb,user,n)if self.readOnly then error(bb..": Read-only filesystem",2)end;local bI=self:stat(process,bb,true)if not bI then error(bb..": No such file or directory",2)end;if not bI.owner or process.user~="root"and process.user~=bI.owner then error(bb..": Permission denied",2)end;local bM;if user==nil then bM=bI.worldPermissions else bM=bI.permissions[user]if not bM then bM=deepcopy(bI.worldPermissions)bI.permissions[user]=bM end end;if type(n)=="string"then if n:match"^[%+%-=][rwxs]+$"then local A=n:sub(1,1)local y={}for a9 in n:gmatch("[rwxs]")do if a9=="r"then y.read=true elseif a9=="w"then y.write=true elseif a9=="s"then y.setuser=true else y.execute=true end end;if A=="+"then if y.read then bM.read=true end;if y.write then bM.write=true end;if y.execute then bM.execute=true end;if y.setuser then bI.setuser=true end elseif A=="-"then if y.read then bM.read=false end;if y.write then bM.write=false end;if y.execute then bM.execute=false end;if y.setuser then bI.setuser=false end else bM.read=y.read or false;bM.write=y.write or false;bM.execute=y.execute or false;bI.setuser=y.setuser or false end else bM.read=n:sub(1,1)~="-"bM.write=n:sub(2,2)~="-"bM.execute=n:sub(3,3)~="-"bI.setuser=n:sub(3,3)=="s"end elseif type(n)=="number"then bI.setuser=bit32.btest(n,8)bM.read=bit32.btest(n,4)bM.write=bit32.btest(n,2)bM.execute=bit32.btest(n,1)else if n.read~=nil then bM.read=n.read end;if n.write~=nil then bM.write=n.write end;if n.execute~=nil then bM.execute=n.execute end;if n.setuser~=nil then bI.setuser=n.setuser end end;self:setmeta(process.user,fs.combine(self.path,bb),deepcopy(bI),true)end;function filesystems.craftos:chown(process,bb,bW)if self.readOnly then error(bb..": Read-only filesystem",2)end;local bI=self:stat(process,bb,true)if not bI then error(bb..": No such file or directory",2)end;if not bI.owner or process.user~="root"and process.user~=bI.owner then error(bb..": Permission denied",2)end;bI.owner=bW;bI.setuser=false;self:setmeta(process.user,fs.combine(self.path,bb),deepcopy(bI),true)end;function filesystems.craftos:info()return"craftos",self.path,{ro=self.readOnly}end;function filesystems.tmpfs:getpath(user,bb,bF)local y=self;local bh=split(bb,"/\\")for v,E in ipairs(bh)do if not y then return nil elseif y.type~="directory"then error("Not a directory",2)elseif y.permissions[user]then if not y.permissions[user].execute then error("Permission denied",2)end elseif not y.worldPermissions.execute then error("Permission denied",2)end;y=y.contents[E]if y and y.type=="link"and not(bF and v==#bh)then error{link=true,path=filesystem.combine(y.link,table.unpack(bh,v+1)),orig=bb}end end;return y end;function filesystems.tmpfs:setpath(user,bb,bj,bF)local y=self;local K=split(bb,"/\\")local bX=K[#K]K[#K]=nil;for v,E in ipairs(K)do if y.type~="directory"then error("Not a directory",2)elseif y.permissions[user]then if not y.permissions[user].execute then error("Permission denied",2)end elseif not y.worldPermissions.execute then error("Permission denied",2)end;if not y.contents[E]then y.contents[E]={type="directory",owner=y.owner,permissions=deepcopy(y.permissions),worldPermissions=deepcopy(y.worldPermissions),setuser=false,created=os.epoch"utc",modified=os.epoch"utc",contents={}}end;y=y.contents[E]if y and y.type=="link"then error{link=true,path=filesystem.combine(y.link,table.unpack(K,v+1)),orig=bb}end end;if y.type~="directory"then error("Not a directory",2)elseif user~="root"then if y.permissions[user]then if not y.permissions[user].execute then error("Permission denied",2)end elseif not y.worldPermissions.execute then error("Permission denied",2)end end;if not bF and y.contents[bX]and y.contents[bX].type=="link"then error{link=true,path=y.contents[bX].link,orig=bb}end;y.contents[bX]=bj end;function filesystems.tmpfs:new(process,bD,bH)return setmetatable({type="directory",owner=process.user,permissions={[process.user]={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false,created=os.epoch"utc",modified=os.epoch"utc",contents={}},{__index=self})end;function filesystems.tmpfs:_open_internal(process,bb,n)local bY=os.epoch;local bj=self:getpath(process.user,bb)if not bj then return nil,"No such file"end;if n=="r"or n=="rb"then return filesystem.readhandle(process,bj.data,n=="rb")elseif n=="w"or n=="wb"then bj.data=""bj.modified=bY"utc"return filesystem.writehandle(process,function(bx,bZ)if bZ then bj.data=bx else bj.data=bj.data..bx end;bj.modified=bY"utc"if self.__flush then self:__flush()end end,n=="wb")elseif n=="a"or n=="ab"then local b_=bj.data;return filesystem.writehandle(process,function(bx,bZ)if bZ then bj.data=b_..bx else bj.data=bj.data..bx end;bj.modified=bY"utc"if self.__flush then self:__flush()end end,n=="ab")else return nil,"Invalid mode"end end;function filesystems.tmpfs:open(process,bb,n)if self.readOnly and(n:sub(1,1)=="w"or n:sub(1,1)=="a")then return nil,"Read-only filesystem"end;local bg,bI=pcall(self.stat,self,process,bb)if not bg then if type(bI)=="table"then error(bI)end;return nil,bI elseif not bI then if n:sub(1,1)=="w"or n:sub(1,1)=="a"then local bJ,bK=pcall(self.stat,self,process,fs.getDir(bb))if not bJ or not bK then if type(bK)=="table"then error(bK)end;local bL,o=pcall(self.mkdir,self,process,fs.getDir(bb))if not bL then if type(o)=="table"then error(o)end;return nil,o:gsub("kernel:%d: ","")end;bK=self:stat(process,fs.getDir(bb))end;if process.user~="root"then local bM=bK.permissions[process.user]or bK.worldPermissions;if not bM.write then return nil,"Permission denied"end end;local bB={type="file",owner=process.user,permissions=deepcopy(bK.permissions),worldPermissions=deepcopy(bK.worldPermissions),setuser=false,created=os.epoch"utc",modified=os.epoch"utc",data=""}local y=bB.permissions[bK.owner]bB.permissions[bK.owner]=nil;bB.permissions[process.user]=y;self:setpath(process.user,bb,bB)return self:_open_internal(process,bb,n)else return nil,"File not found"end elseif bI.type=="directory"then return nil,"Is a directory"end;if process.user~="root"then local bM=bI.permissions[process.user]or bI.worldPermissions;if n:sub(1,1)=="r"and not bM.read or(n:sub(1,1)=="w"or n:sub(1,1)=="a")and not bM.write then return nil,"Permission denied"end end;if bI.type=="fifo"then local bB=self:getpath(process.user,bb)local bN=fifos[bB]if not bN then bN={data=""}fifos[bB]=bN end;return filesystem.fifohandle(process,bN,n)end;return self:_open_internal(process,bb,n)end;function filesystems.tmpfs:list(process,bb)local bj=self:getpath(process.user,bb)if not bj or bj.type~="directory"then error(bb..": Not a directory",2)end;if process.user~="root"then local bM=bj.permissions[process.user]or bj.worldPermissions;if not bM.read then error(bb..": Permission denied",2)end end;local a5={}for h in pairs(bj.contents)do a5[#a5+1]=h end;table.sort(a5)return a5 end;function filesystems.tmpfs:stat(process,bb,bF)local bj=self:getpath(process.user,bb,bF)if not bj then return nil end;return{size=bj.type=="file"and#bj.data or(bj.type=="directory"and#bj.contents or 0),type=bj.type,created=bj.created,modified=bj.modified,owner=bj.owner,permissions=deepcopy(bj.permissions),worldPermissions=deepcopy(bj.worldPermissions),setuser=bj.setuser,capacity=math.huge,freeSpace=math.huge,link=rawget(bj,"link"),special={}}end;function filesystems.tmpfs:remove(process,bb)if self.readOnly then error("Read-only filesystem",2)end;local c0=self:getpath(process.user,fs.getDir(bb))local m=fs.getName(bb)if not c0 or c0.type~="directory"or not c0.contents[m]then return end;if process.user~="root"and not(c0.permissions[process.user]or c0.worldPermissions).write then error(bb..": Permission denied",2)end;local bj=c0.contents[m]if process.user~="root"and not(bj.permissions[process.user]or bj.worldPermissions).write then error(bb..": Permission denied",2)end;local function bQ(bs)local bM=bs.permissions[process.user]or bs.worldPermissions;if process.user~="root"and not bM.write then error(bb..": Permission denied",3)end;if bs.type=="directory"then if process.user~="root"and not bM.read then error(bb..": Permission denied",3)end;for z,i in pairs(bs.contents)do bQ(i)end end end;bQ(bj)c0.contents[m]=nil;c0.modified=os.epoch"utc"end;function filesystems.tmpfs:rename(process,bR,bS)if self.readOnly then error("Read-only filesystem",2)end;local c1=self:getpath(process.user,fs.getDir(bR))local c2=fs.getName(bR)if not c1 or c1.type~="directory"or not c1.contents[c2]then error(bR..": No such file or directory",2)end;if process.user~="root"and not(c1.permissions[process.user]or c1.worldPermissions).write then error(bR..": Permission denied",2)end;local c3=c1.contents[c2]if process.user~="root"and not(c3.permissions[process.user]or c3.worldPermissions).write then error(bR..": Permission denied",2)end;local c4=self:getpath(process.user,fs.getDir(bS))local c5=fs.getName(bS)if not c4 or c4.type~="directory"then error(bS..": No such file or directory",2)end;if process.user~="root"and not(c4.permissions[process.user]or c4.worldPermissions).write then error(bS..": Permission denied",2)end;local c6=c4.contents[c5]if c6 then error(bS..": File already exists",2)end;c4.contents[c5],c1.contents[c2]=c3,nil;local c7=os.epoch"utc"c1.modified,c4.modified=c7,c7 end;function filesystems.tmpfs:mkdir(process,bb)if self.readOnly then error("Read-only filesystem",2)end;local y=self;for z,E in ipairs(split(bb,"/\\"))do local bM=y.permissions[process.user]or y.worldPermissions;if y.type~="directory"then error(bb..": File exists",2)elseif process.user~="root"and not bM.execute then error(bb..": Permission denied",2)end;if not y.contents[E]then if process.user~="root"and not bM.write then error(bb..": Permission denied",2)end;y.contents[E]={type="directory",owner=y.owner,permissions=deepcopy(y.permissions),worldPermissions=deepcopy(y.worldPermissions),created=os.epoch"utc",modified=os.epoch"utc",contents={}}y.modified=os.epoch"utc"end;y=y.contents[E]end end;function filesystems.tmpfs:link(process,bb,bV)if self.readOnly then error("Read-only filesystem",2)end;local bI=self:stat(process,bb)if bI then error(bb..": File exists",2)end;local bJ,bK=pcall(self.stat,self,process,fs.getDir(bb))if not bJ or not bK then if type(bK)=="table"then error(bK)end;local bL,o=pcall(self.mkdir,self,process,fs.getDir(bb))if not bL then if type(o)=="table"then error(o)end;return nil,type(o)=="string"and o:gsub("kernel:%d: ","")or o end;bK=self:stat(process,fs.getDir(bb))end;self:setpath(process.user,bb,{type="link",owner=process.user,permissions=deepcopy(bK.permissions),worldPermissions=deepcopy(bK.worldPermissions),setuser=false,created=os.epoch"utc",modified=os.epoch"utc",path=bV},true)end;function filesystems.tmpfs:mkfifo(process,bb)if self.readOnly then error("Read-only filesystem",2)end;local bI=self:stat(process,bb)if bI then error(bb..": File exists",2)end;local bJ,bK=pcall(self.stat,self,process,fs.getDir(bb))if not bJ or not bK then if type(bK)=="table"then error(bK)end;local bL,o=pcall(self.mkdir,self,process,fs.getDir(bb))if not bL then if type(o)=="table"then error(o)end;return nil,type(o)=="string"and o:gsub("kernel:%d: ","")or o end;bK=self:stat(process,fs.getDir(bb))end;self:setpath(process.user,bb,{type="fifo",owner=process.user,permissions=deepcopy(bK.permissions),worldPermissions=deepcopy(bK.worldPermissions),setuser=false,created=os.epoch"utc",modified=os.epoch"utc"},true)end;function filesystems.tmpfs:chmod(process,bb,user,n)if self.readOnly then error("Read-only filesystem",2)end;local bI=self:getpath(process.user,bb,true)if not bI then error(bb..": No such file or directory",2)end;if not bI.owner or process.user~="root"and process.user~=bI.owner then error(bb..": Permission denied",2)end;local bM;if user==nil then bM=bI.worldPermissions else bM=bI.permissions[user]if not bM then bM=deepcopy(bI.worldPermissions)bI.permissions[user]=bM end end;if type(n)=="string"then if n:match"^[%+%-=][rwxs]+$"then local A=n:sub(1,1)local y={}for a9 in n:gmatch("[rwxs]")do if a9=="r"then y.read=true elseif a9=="w"then y.write=true elseif a9=="s"then y.setuser=true else y.execute=true end end;if A=="+"then if y.read then bM.read=true end;if y.write then bM.write=true end;if y.execute then bM.execute=true end;if y.setuser then bI.setuser=true end elseif A=="-"then if y.read then bM.read=false end;if y.write then bM.write=false end;if y.execute then bM.execute=false end;if y.setuser then bI.setuser=false end else bM.read=y.read or false;bM.write=y.write or false;bM.execute=y.execute or false;bI.setuser=y.setuser or false end else bM.read=n:sub(1,1)~="-"bM.write=n:sub(2,2)~="-"bM.execute=n:sub(3,3)~="-"bI.setuser=n:sub(3,3)=="s"end elseif type(n)=="number"then bI.setuser=bit32.btest(n,8)bM.read=bit32.btest(n,4)bM.write=bit32.btest(n,2)bM.execute=bit32.btest(n,1)else if n.read~=nil then bM.read=n.read end;if n.write~=nil then bM.write=n.write end;if n.execute~=nil then bM.execute=n.execute end;if n.setuser~=nil then bI.setuser=n.setuser end end end;function filesystems.tmpfs:chown(process,bb,bW)if self.readOnly then error("Read-only filesystem",2)end;local bI=self:getpath(process.user,bb,true)if not bI then error(bb..": No such file or directory",2)end;if not bI.owner or process.user~="root"and process.user~=bI.owner then error(bb..": Permission denied",2)end;bI.owner=bW;bI.setuser=false end;function filesystems.tmpfs:info()return"tmpfs","memory",{ro=self.readOnly}end;setmetatable(filesystems.drivefs,{__index=filesystems.craftos})function filesystems.drivefs:stat(process,bb)local u,o=filesystems.craftos.stat(self,process,bb)if bb==""and u==nil then return{size=0,type="directory",created=0,modified=0,owner=self.owner,capacity=0,freeSpace=0,permissions={[self.owner]={read=false,write=true,execute=false}},worldPermissions={read=false,write=false,execute=false},setuser=false}end;return u,o end;function filesystems.drivefs:new(process,bD,bH)local c8=hardware.get(bD)if not c8 then error("Could not find drive at "..bD)end;local bb=hardware.call(process,c8,"getMountPath")local fs=filesystems.craftos:new(process,bb,bH)fs.drive=c8.uuid;fs.owner=process.user;fs.meta={meta={type="directory",owner="root",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}}fs.metapath=fs.combine(bb,".meta.ltn")local a=fs.open(fs.metapath,"r")if a then fs.meta=unserialize(a.readAll())or fs.meta;a.close()end;return setmetatable(fs,{__index=self})end;function filesystems.drivefs:info()return"drivefs",self.drive,{ro=self.readOnly}end;setmetatable(filesystems.tablefs,{__index=filesystems.tmpfs})function filesystems.tablefs:new(process,bD,bH)local y;local a,o;if process~=KERNEL and mounts[""]then a,o=filesystem.open(process,bD,"r")else a,o=fs.open(bD,"r")end;if a then local bj=a.readAll()or""a.close()local bg,u=pcall(unserialize,bj)if not bg then error("Could not mount "..bD..": "..u,3)elseif type(u)~="table"or u.type~="directory"or type(u.contents)~="table"then error("Could not mount "..bD..": Invalid table file",3)end;y=u else if not(bH.rw and not bH.ro)then error("Could not mount "..bD..": "..o,3)end;y={type="directory",owner=process.user,permissions={[process.user]={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false,created=os.epoch"utc",modified=os.epoch"utc",contents={}}end;y.src=bD;y.readOnly=bH.ro;if bH.rw and not bH.ro then function y:__flush()local f,bs=self.__flush,self.src;self.__flush,self.src=nil;local bg,u=pcall(serialize,self)self.__flush,self.src=f,bs;if not bg then error(u)end;local a,o=filesystem.open(process,bD,"w")if not a then syslog.log({level=4},"Could not save mount to "..bD..": "..o)return end;a.write(u)a.close()end end;return setmetatable(y,{__index=self})end;function filesystems.tablefs:info()return"tablefs",self.src,{rw=self.__flush~=nil,ro=self.readOnly}end;function filesystems.bind:new(process,bb,bH)local bI,o=filesystem.stat(process,bb)if not bI then error("Could not bind "..bb..": "..o,3)elseif bI.type~="directory"then error("Could not bind "..bb..": Not a directory",3)end;return setmetatable({path=bb},{__index=self})end;function filesystems.bind:open(process,bb,n)return filesystem.open(process,fs.combine(self.path,bb),n)end;function filesystems.bind:list(process,bb)return filesystem.list(process,fs.combine(self.path,bb))end;function filesystems.bind:stat(process,bb,bF)return filesystem.stat(process,fs.combine(self.path,bb),bF)end;function filesystems.bind:remove(process,bb)return filesystem.remove(process,fs.combine(self.path,bb))end;function filesystems.bind:rename(process,bR,bS)return filesystem.rename(process,fs.combine(self.path,bR),fs.combine(self.path,bS))end;function filesystems.bind:mkdir(process,bb)return filesystem.mkdir(process,fs.combine(self.path,bb))end;function filesystems.bind:link(process,bb,bV)return filesystem.link(process,fs.combine(self.path,bb),bV)end;function filesystems.bind:mkfifo(process,bb)return filesystem.mkfifo(process,fs.combine(self.path,bb))end;function filesystems.bind:chmod(process,bb,user,n)return filesystem.chmod(process,fs.combine(self.path,bb),user,n)end;function filesystems.bind:chown(process,bb,bW)return filesystem.chown(process,fs.combine(self.path,bb),bW)end;function filesystems.bind:info()return"bind",self.path,{}end;local function c9(process,bb,ca,cb)local cc=ba(process,bb)if cb then if cc==""then cc=nil else cc=fs.getDir(cc)end end;if cc and fsevents[cc]then for z,i in pairs(fsevents[cc])do local cd=cc;if cd:find(i.root,1,true)==1 then cd=cd:sub(#i.root+1)end;i.eventQueue[#i.eventQueue+1]={"fsevent",{path=cd,event=ca,name=cb and fs.getName(cc)or nil,process=process.id}}end end end;function filesystem.open(process,bb,n)expect(0,process,"table")expect(1,bb,"string")expect(2,n,"string")if not n:match"^[rwa]b?$"then error("Invalid mode",0)end;repeat local bg,bi,E=pcall(bc,process,bb)if not bg then return nil,bi end;local u=table.pack(pcall(bi.open,bi,process,E,n))if u[1]then if u[2]and n~="r"and n~="rb"then c9(process,bb,"open",false)c9(process,bb,"open_child",true)end;return table.unpack(u,2,u.n)elseif type(u[2])~="table"or type(u[2].path)~="string"then error(u[2],2)end;bb=u[2].path until u[1]end;local function ce(process,bb)local a5={}local mounts,E=bc(process,bb,true)for z,bi in ipairs(mounts)do local bg,u=pcall(bi.list,bi,process,E)if not bg then if type(u)~="table"or type(u.path)~="string"then error(u,2)else u=ce(process,u.path)end end;for z,i in ipairs(u)do a5[#a5+1]=i end end;return a5 end;function filesystem.list(process,bb)expect(0,process,"table")expect(1,bb,"string")local a5=ce(process,bb)table.sort(a5)return a5 end;function filesystem.stat(process,bb,bF)expect(0,process,"table")expect(1,bb,"string")repeat local bg,bi,E,cf=pcall(bc,process,bb)if not bg then return nil,bi end;local cg,u,o=pcall(bi.stat,bi,process,E,bF)if cg then if u then u.mountpoint="/"..cf end;return u,o elseif type(u)~="table"or type(u.path)~="string"then error(u,2)end;bb=u.path until cg end;function filesystem.remove(process,bb)expect(0,process,"table")expect(1,bb,"string")repeat local bi,E=bc(process,bb)local bg,u=pcall(bi.remove,bi,process,E)if bg then c9(process,bb,"remove",false)c9(process,bb,"remove_child",true)return elseif type(u)~="table"or type(u.path)~="string"then error(u,2)end;bb=u.path until bg end;function filesystem.rename(process,bR,bS)expect(0,process,"table")expect(1,bR,"string")expect(2,bS,"string")repeat local ch,ci=bc(process,bR)local cj,ck=bc(process,bS)if ch~=cj then error("Attempt to rename file across two filesystems",0)end;local bg,u=pcall(ch.rename,ch,process,ci,ck)if bg then c9(process,bR,"rename_from",false)c9(process,bR,"rename_from_child",true)c9(process,bS,"rename_to",false)c9(process,bS,"rename_to_child",true)return elseif type(u)~="table"or type(u.path)~="string"then error(u,2)end;if u.orig==bR then bR=u.path else bS=u.path end until bg end;function filesystem.mkdir(process,bb)expect(0,process,"table")expect(1,bb,"string")repeat local bi,E=bc(process,bb)local bg,u=pcall(bi.mkdir,bi,process,E)if bg then c9(process,bb,"mkdir",false)c9(process,bb,"mkdir_child",true)return elseif type(u)~="table"or type(u.path)~="string"then error(u,2)end;bb=u.path until bg end;function filesystem.link(process,bb,bV)expect(0,process,"table")expect(1,bb,"string")expect(2,bV,"string")if fs.combine(bb)==fs.combine(bV)then error("Cannot link file to itself",2)end;syslog.debug("Creating link",bb," => ",bV)repeat local bi,E=bc(process,bb)if not bi.link then error("Filesystem does not support links",2)end;local bg,u=pcall(bi.link,bi,process,E,bV)if bg then c9(process,bb,"link",false)c9(process,bb,"link_child",true)return elseif type(u)~="table"or type(u.path)~="string"then error(u,2)end;bb=u.path until bg end;function filesystem.mkfifo(process,bb)expect(0,process,"table")expect(1,bb,"string")repeat local bi,E=bc(process,bb)if not bi.mkfifo then error("Filesystem does not support FIFOs",2)end;local bg,u=pcall(bi.mkfifo,bi,process,E)if bg then c9(process,bb,"mkfifo",false)c9(process,bb,"mkfifo_child",true)return elseif type(u)~="table"or type(u.path)~="string"then error(u,2)end;bb=u.path until bg end;function filesystem.chmod(process,bb,user,n)expect(0,process,"table")expect(1,bb,"string")expect(2,user,"string","nil")expect(3,n,"number","string","table")if type(n)=="string"and not n:match"^[%+%-=][rwxs]+$"and not n:match"^[r%-][w%-][xs%-]$"then error("bad argument #3 (invalid mode)",2)elseif type(n)=="table"then expect.field(n,"read","boolean","nil")expect.field(n,"write","boolean","nil")expect.field(n,"execute","boolean","nil")end;repeat local bi,E=bc(process,bb)local bg,u=pcall(bi.chmod,bi,process,E,user,n)if bg then return elseif type(u)~="table"or type(u.path)~="string"then error(u,2)end;bb=u.path until bg end;function filesystem.chown(process,bb,user)expect(0,process,"table")expect(1,bb,"string")expect(2,user,"string")repeat local bi,E=bc(process,bb)local bg,u=pcall(bi.chown,bi,process,E,user)if bg then return elseif type(u)~="table"or type(u.path)~="string"then error(u,2)end;bb=u.path until bg end;function filesystem.chroot(process,bb)expect(0,process,"table")expect(1,bb,"string")if process.user~="root"then error("Could not change root: Permission denied",2)end;local cl=filesystem.combine(process.root,bb).."/"if cl:find(process.root,1,true)~=1 then error("Could not change root: No such file or directory",2)end;local bs=filesystem.stat(process,"/"..bb)if not bs then error(bb..": No such directory",2)end;if bs.type~="directory"then error(bb..": Not a directory",2)end;process.root=cl end;function filesystem.mount(process,type,bD,bE,bH)expect(0,process,"table")expect(1,type,"string")expect(2,bD,"string")expect(3,bE,"string")expect(4,bH,"table","nil")if not filesystems[type]then error("No such filesystem '"..type.."'",2)end;local E=ba(process,bE)if E==""then if process.user~="root"then error("Could not mount to "..bE..": Permission denied",2)end;if mounts[E]and not(bH and bH.overlay)then error("Could not mount to "..bE..": Mount already exists (use overlay to mount over)")end;if not mounts[E]and(bH and bH.overlay)then error("Could not mount to "..bE..": No base mount exists for overlay")end else local bI=filesystem.stat(process,bE)if not bI then error("Could not mount to "..bE..": No such directory",2)end;if bI.type~="directory"then error("Could not mount to "..bE..": Not a directory",2)end;if process.user~="root"and not(bI.permissions[process.user]or bI.worldPermissions).write then error("Could not mount to "..bE..": Permission denied",2)end;if mounts[E]and not(bH and bH.overlay)then error("Could not mount to "..bE..": Mount already exists (use overlay to mount over)")end;if not mounts[E]and(bH and bH.overlay)then error("Could not mount to "..bE..": No base mount exists for overlay")end end;local bi=filesystems[type]:new(process,bD,bH or{})if bH and bH.overlay then mounts[E][#mounts[E]+1]=bi else mounts[E]={bi}end end;function filesystem.unmount(process,bb)expect(0,process,"table")expect(1,bb,"string")bb=ba(process,bb)if not mounts[bb]then error(bb..": No such mount",2)end;local bI=mounts[bb]:stat(process,"")if not bI then error("Internal error in unmount: could not get stat for root! Please report this to the maintainer of the target filesystem.",2)elseif process.user~="root"and not(bI.permissions[process.user]or bI.worldPermissions).write then error(bb..": Permission denied",2)end;if mounts[bb].unmount then mounts[bb]:unmount(process)end;mounts[bb]=nil end;function filesystem.mountlist(process)expect(0,process,"table")local a5={}for h,i in pairs(mounts)do if"/"..h.."/"==process.root or h:find(process.root:sub(2),1,true)==1 then for z,bi in ipairs(i)do local type,bb,bH=bi:info()a5[#a5+1]={path="/"..h,type=type,source=bb,options=bH}end end end;return a5 end;function filesystem.combine(cm,...)expect(1,cm,"string")local a0=fs.combine(cm,...)if cm:match"^/"then a0="/"..a0 end;return a0 end;function syscalls.open(process,aq,...)return filesystem.open(process,...)end;function syscalls.list(process,aq,...)return filesystem.list(process,...)end;function syscalls.stat(process,aq,...)return filesystem.stat(process,...)end;function syscalls.remove(process,aq,...)return filesystem.remove(process,...)end;function syscalls.rename(process,aq,...)return filesystem.rename(process,...)end;function syscalls.mkdir(process,aq,...)return filesystem.mkdir(process,...)end;function syscalls.link(process,aq,...)return filesystem.link(process,...)end;function syscalls.mkfifo(process,aq,...)return filesystem.mkfifo(process,...)end;function syscalls.chmod(process,aq,...)return filesystem.chmod(process,...)end;function syscalls.chown(process,aq,...)return filesystem.chown(process,...)end;function syscalls.chroot(process,aq,...)return filesystem.chroot(process,...)end;function syscalls.mount(process,aq,...)return filesystem.mount(process,...)end;function syscalls.unmount(process,aq,...)return filesystem.unmount(process,...)end;function syscalls.mountlist(process,aq,...)return filesystem.mountlist(process,...)end;function syscalls.combine(process,aq,...)return filesystem.combine(...)end;function syscalls.loadCraftOSAPI(process,aq,cn)expect(1,cn,"string")local e;e=setmetatable({dofile=function(bb)local a,o=fs.open(bb,"rb")if not a then error("Could not open module: "..o,0)end;local g,o=load(a.readAll(),"@"..bb,nil,e)a.close()if not g then error("Could not load module: "..o,0)end;return g()end,require=function(m)return e.dofile("rom/modules/main/"..m:gsub("%.","/")..".lua")end},{__index=process.env})e._ENV=e;if cn:sub(1,3)=="cc."then local bb=fs.combine("rom/modules/main",cn:gsub("%.","/")..".lua")if not bb:match"^/?rom/modules/main/"then error("Invalid module path",0)end;return e.dofile(bb)else if not cn:match"^[a-z]+$"then error("Invalid API name",0)end;local bb=fs.combine("rom/apis",cn..".lua")local a,o=fs.open(bb,"rb")if not a then error("Could not open module: "..o,0)end;local g,o=load(a.readAll(),"@"..bb,nil,e)a.close()if not g then error("Could not load module: "..o,0)end;g()local y={}for h,i in pairs(e)do if h~="dofile"and h~="require"and h~="_ENV"then y[h]=i end end;return y end end;function syscalls.fsevent(process,aq,bb,co)expect(1,bb,"string")expect(2,co,"boolean","nil")if co==nil then co=true end;bb=ba(process,bb)syslog.debug("Registering fsevents for",bb)fsevents[bb]=fsevents[bb]or setmetatable({},{__mode="v"})fsevents[bb][#fsevents[bb]+1]=co and process or nil end;xpcall(function()if args.initrd then if args.initrd:match"^_G%.."then local cp=_G[args.initrd:match"^_G%.(.+)"]if type(cp)~="table"then error("Requested root filesystem in global '"..args.initrd.."' is not a table")end;cp.src=args.initrd;mounts[""]={setmetatable(cp,{__index=filesystems.tablefs})}else mounts[""]={filesystems.tablefs:new(KERNEL,args.initrd,{})}end else local bH={}if args.rootflags then for A in args.rootflags:gmatch"[^,]+"do local h,i=A:match("^([^=]+)=(.*)$")if h and i then if i=="true"then bH[h]=true elseif i=="false"then bH[h]=false else bH[h]=tonumber(i)or i end else bH[A]=true end end end;mounts[""]={filesystems[args.rootfstype]:new(KERNEL,args.root,bH)}end end,panic)local do_syscall=do_syscall;local expect=expect;local function cq(cr,cs,ct,cu)local cv={bit32.extract(cs,0,16),bit32.extract(cs,16,16),bit32.extract(cr,0,16),bit32.extract(cr,16,16)}local ab={bit32.extract(cu,0,16),bit32.extract(cu,16,16),bit32.extract(ct,0,16),bit32.extract(ct,16,16)}local by={{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0}}for cw=1,4 do for cx=1,4 do local r=cv[cx]*ab[cw]+by[cw][cx]by[cw][cx+1],by[cw][cx]=bit32.rshift(r,16),bit32.band(r,0xFFFF)end end;local cy={0,0,0,0,0,0,0,0}for cz=1,8 do for cA=1,4 do cy[cz]=cy[cz]+(by[cA][cz-cA+1]or 0)end;cy[cz+1],cy[cz]=bit32.rshift(cy[cz],16),bit32.band(cy[cz],0xFFFF)end;return cy[3]+cy[4]*0x10000,cy[1]+cy[2]*0x10000 end;local function cB(ab,cr,cs)return cr+math.floor((cs+ab)/0x100000000),bit32.band(cs+ab,0xFFFFFFFF)end;function makeRandom()local cC,cD=0,0;local function next(cE)cC,cD=cB(0xB,cq(cC,cD,0x5,0xDEECE66D))cC=bit32.band(cC,0xFFFF)return math.floor(cC/2^(16-cE))+math.floor(cD/2^(48-cE))end;local function cF(c,d)expect(1,c,"number","nil")expect(2,d,"number","nil")if c then expect.range(c,0,0x7FFFFFFF)if not d then c,d=0,c else expect.range(d,0,0x7FFFFFFF)end;local cG=d-c+1;local cH;if math.log(cG,2)%1==0 then cH=math.floor(cG*next(31)/0x80000000)else local cE;repeat cE=next(31)cH=cE%cG until cE-cH+cG-1>=0 end;return cH+c else return(next(26)*0x8000000+next(27))/0x20000000000000 end end;local function cI(cJ)expect(1,cJ,"number")cC,cD=bit32.band(bit32.bxor(0x5,math.floor(cJ/0x100000000)),0xFFFF),bit32.bxor(0xDEECE66D,math.floor(cJ))end;cI(os.epoch"utc"*tonumber(tostring(next):match("%x+")or"1",16))return cF,cI end;do math.random,math.randomseed=makeRandom()end;function createLuaLib(process)local cK={}for z,i in ipairs{"assert","error","getmetatable","ipairs","next","pairs","pcall","rawequal","rawget","rawset","select","setmetatable","tonumber","tostring","type","_VERSION","xpcall","collectgarbage"}do cK[i]=_G[i]end;function cK.dofile(bb)if bb~=nil and type(bb)~="string"then error("bad argument #1 (expected string, got "..type(bb)..")",2)end;local g,o=loadfile(bb or io.stdin:read("*a"))if not g then error(o,2)end;return g()end;do local load,getfenv,setfenv,make_ENV=load,getfenv,setfenv,make_ENV;if _VERSION=="Lua 5.1"then function cK.load(l,m,n,e)return load(l,m,n,make_ENV(e or process.env))end;function cK.getfenv(f)local i;if f==nil then i=getfenv(2)elseif tonumber(f)and tonumber(f)>0 then i=getfenv(f+1)elseif type(f)=="function"then i=getfenv(f)else i=getfenv(f)end;local aB=getmetatable(f)if aB and aB.__env then return aB.__env else return i end end;function cK.setfenv(f,K)return setfenv(f,make_ENV(K))end else cK.load,cK.getfenv,cK.setfenv=function(l,m,n,e)return load(l,m,n,e or process.env)end,getfenv,setfenv end end;function cK.loadfile(bb,n,e)if e==nil and type(n)=="table"then e,n=n,nil end;if type(bb)~="string"then error("bad argument #1 (expected string, got "..type(bb)..")",2)end;if n~=nil and type(n)~="string"then error("bad argument #2 (expected string, got "..type(n)..")",2)end;if e~=nil and type(e)~="table"then error("bad argument #3 (expected table, got "..type(e)..")",2)end;local a,o=do_syscall("open",bb,"rb")if not a then error(o,2)end;local bj=a.readAll()a.close()return load(bj,"@"..bb,n,e)end;function cK.print(...)local args=table.pack(...)if args.n==0 then args={"",n=1}end;args[args.n]=tostring(args[args.n]).."\n"return do_syscall("write",table.unpack(args,1,args.n))end;cK.coroutine=deepcopy(coroutine)cK.string=deepcopy(string)cK.table=deepcopy(table)cK.math=deepcopy(math)cK.bit32=deepcopy(bit32)cK.utf8=deepcopy(utf8)cK.math.random,cK.math.randomseed=makeRandom()local cL=cK.coroutine.resume;cK.coroutine.resume=function(cM,...)local a5=table.pack(cL(cM,...))while a5.n>=2 and a5[1]==true and(a5[2]=="preempt"or a5[2]=="secure_syscall"or a5[2]=="secure_event")do a5=table.pack(cL(cM,coroutine.yield(table.unpack(a5,2,a5.n))))end;return table.unpack(a5,1,a5.n)end;local cN=""local cO=setmetatable({close=function()end,lines=function(self,...)local args=table.pack(...)return function()return self:read(table.unpack(args,1,args.n))end end,read=function(self,a6,...)local bs,K;a6=a6 or"*l"if type(a6)=="number"then while#cN<a6 do cN=cN..do_syscall("read",a6)end elseif type(a6)=="string"then a6=a6:gsub("^%*","")if a6=="n"then while not cN:find("%d")do local bt=do_syscall("readline")if bt==nil then break end;cN=cN..bt.."\n"end elseif a6=="a"then while true do local bt=do_syscall("readline")if bt==nil then break end;cN=cN..bt.."\n"end elseif a6=="l"or a6=="L"then local bt=do_syscall("readline")if bt==nil then return nil end;cN=cN..bt.."\n"else error("bad argument (invalid format '"..a6 .."')",2)end else error("bad argument (expected string or number, got "..type(a6),2)end;if type(a6)=="number"then bs,K=cN:sub(1,a6),a6+1 elseif a6=="n"then bs,K=cN:match("(%d)()")elseif a6=="a"then bs,K=cN,#cN+1 elseif a6=="l"then bs,K=cN:match("(.*)\n()")else bs,K=cN:match("(.*\n)()")end;if not bs then return nil end;cN=cN:sub(K)if select("#",...)>0 then return bs,self:read(...)else return bs end end,seek=function()return nil,"Cannot seek default file"end,setvbuf=function()end},{__name="FILE*"})local cP=setmetatable({close=function()end,flush=function()end,seek=function()return nil,"Cannot seek default file"end,setvbuf=function()end,write=function(self,...)do_syscall("write",...)return self end},{__name="FILE*"})local cQ=setmetatable({close=function()end,flush=function()end,seek=function()return nil,"Cannot seek default file"end,setvbuf=function()end,write=function(self,...)do_syscall("writeerr",...)return self end},{__name="FILE*"})local cR,cS=cO,cP;local cT={close=function(self)self._file.close()self._closed=true end,lines=function(self,...)local args=table.pack(...)return function()return self:read(table.unpack(args,1,args.n))end end,read=function(self,a6,...)local i;if a6==nil then a6="l"end;if type(a6)=="number"then i=self._file.read(a6)elseif type(a6)=="string"then a6=a6:gsub("^%*","")if a6=="a"then i=self._file.readAll()elseif a6=="l"then i=self._file.readLine(false)elseif a6=="L"then i=self._file.readLine(true)elseif a6=="n"then local bs,a9=""repeat a9=self._file.read(1)until a9:match("%d")while a9:match("%d")do bs,a9=bs..a9,self._file.read(1)end;i=tonumber(bs)else error("bad argument (invalid format '"..a6 .."')",2)end else error("bad argument (expected string or number, got "..type(a6)..")",2)end;if select("#",...)>0 then return i,self:read(...)else return i end end,seek=function(self,br,U)if self._file.seek then return self._file.seek(br,U)else return nil,"Cannot seek text file"end end,setvbuf=function()end}local cU={close=function(self)self._file.close()self._closed=true end,flush=function(self)self._file:flush()end,seek=function(self,br,U)if self._file.seek then return self._file.seek(br,U)else return nil,"Cannot seek text file"end end,setvbuf=function()end,write=function(self,...)self._file.write(...)return self end}cK.io={close=function(a)if a==nil then cS:close()elseif type(a)=="table"and getmetatable(a)and getmetatable(a).__name=="FILE*"then a:close()else error("bad argument #1 (expected FILE*, got "..type(a)..")",2)end end,flush=function()return cS:flush()end,input=function(a)if a==nil then return cR elseif type(a)=="string"then local ag,o=io.open(a,"r")if not ag then error(o,2)end;cR=ag elseif type(a)=="table"and getmetatable(a)and getmetatable(a).__name=="FILE*"then cR=a else error("bad argument #1 (expected string or FILE*, got "..type(a)..")",2)end end,lines=function(cV,...)if cV==nil then return cR:lines(...)end;if type(cV)~="string"then error("bad argument #1 (expected string, got "..type(cV)..")",2)end;local ag,o=io.open(cV,"r")if not ag then error(o,2)end;local g=ag:lines(...)return function(...)local a5=table.pack(g(...))if a5.n==0 or a5[1]==nil then ag:close()end;return table.unpack(a5,1,a5.n)end end,open=function(cV,n)if type(cV)~="string"then error("bad argument #1 (expected string, got "..type(cV)..")",2)end;if n==nil then n="r"end;if type(n)~="string"then error("bad argument #2 (expected string, got "..type(n)..")",2)end;local a,o=do_syscall("open",cV,n)if not a then return nil,o elseif n:find("r")then return setmetatable({_file=a},{__index=cT,__name="FILE*"})else return setmetatable({_file=a},{__index=cU,__name="FILE*"})end end,output=function(a)if a==nil then return cS elseif type(a)=="string"then local ag,o=io.open(a,"w")if not ag then error(o,2)end;cS=ag elseif type(a)=="table"and getmetatable(a)and getmetatable(a).__name=="FILE*"then cS=a else error("bad argument #1 (expected string or FILE*, got "..type(a)..")",2)end end,popen=function(bb,n)expect(1,bb,"string")n=expect(2,n,"string","nil")or"r"if n~="r"and n~="w"and n~="rw"then error("bad argument #2 (invalid mode)",2)end;if n=="rw"then local cW,cX="",""local cY;local cZ={read=function(r)if cW==""then return nil elseif r then local bs=cW:sub(1,r)cW=cW:sub(r+1)return bs else local bs,K=cW:match"([^\n]*)\n*()"cW=cW:sub(K)return bs end end}local c_={write=function(bs)cW=cW..bs end,flush=function()end,close=function()local b3=do_syscall("getpinfo",cY)if not b3 then return end;repeat local ar,d0=coroutine.yield()until ar=="process_complete"and d0.pid==cY end}local d1={read=function(r)if cX==""then return nil elseif r then local bs=cX:sub(1,r)cX=cX:sub(r+1)return bs else local bs,K=cX:match"([^\n]*)\n*()"cX=cX:sub(K)return bs end end,readLine=function()local bs,K=cX:match"([^\n]*)\n*()"cX=cX:sub(K)return bs end,readAll=function()local bs=cX;cX=""return bs end,close=function()local b3=do_syscall("getpinfo",cY)if not b3 then return end;repeat local ar,d0=coroutine.yield()until ar=="process_complete"and d0.pid==cY end}local d2={write=function(bs)cX=cX..bs end}cY=do_syscall("fork",function()do_syscall("stdin",cZ)do_syscall("stdout",d2)do_syscall("exec","/bin/sh","-c",bb)end)return setmetatable({_file=d1},{__index=cT,__name="FILE*"}),setmetatable({_file=c_},{__index=cU,__name="FILE*"})else local d3=""local bo=false;local cY;local d4={read=function(r)if d3==""then if bo then return nil else return""end elseif r then local bs=d3:sub(1,r)d3=d3:sub(r+1)return bs else local bs,K=d3:match"([^\n]*\n?)()"d3=d3:sub(K)return bs end end,readLine=function()local bs,K=d3:match"([^\n]*\n?)()"d3=d3:sub(K)return bs end,readAll=function()local bs=d3;d3=""return bs end,close=function()bo=true;local b3=do_syscall("getpinfo",cY)if not b3 then return end;repeat local ar,d0=coroutine.yield()until ar=="process_complete"and d0.pid==cY end}local d5={write=function(bs)d3=d3 ..bs end,flush=function()end,close=function()bo=true;local b3=do_syscall("getpinfo",cY)if not b3 then return end;repeat local ar,d0=coroutine.yield()until ar=="process_complete"and d0.pid==cY end}cY=do_syscall("fork",function()do_syscall(n=="r"and"stdout"or"stdin",n=="r"and d5 or d4)do_syscall("exec","/bin/sh","-c",bb)end)return n=="r"and setmetatable({_file=d4},{__index=cT,__name="FILE*"})or setmetatable({_file=d5},{__index=cU,__name="FILE*"})end end,read=function(...)return cR:read(...)end,tmpfile=function()return io.open(os.tmpname(),"a")end,type=function(bA)if type(bA)=="table"and getmetatable(bA)and getmetatable(bA).__name=="FILE*"then if bA._closed then return"closed file"else return"file"end else return nil end end,write=function(...)return cS:write(...)end,stdin=cO,stdout=cP,stderr=cQ}local d6=os;cK.os={clock=function()return do_syscall("clock")end,date=function(a6,c7)if type(a6)=="string"and a6:sub(1,1)=="?"then local bq=d6.date("!"..a6:sub(2),c7 or d6.epoch"ingame"/1000)if type(bq)=="table"then bq.year=bq.year-1970 end;return bq else return d6.date(a6,c7)end end,difftime=function(cv,ab)return cv-ab end,execute=function(bb)do_syscall("exec","/bin/sh","-c",bb)end,exit=function(bu)do_syscall("exit",bu)end,getenv=function(m)expect(1,m,"string")local e=do_syscall("getenv")if not e then return nil end;return e[m]end,remove=function(bb)expect(1,bb,"string")local bg,o=do_syscall("remove",bb)if not bg then bg=nil end;return bg,o end,rename=function(bR,bS)expect(1,bR,"string")expect(2,bS,"string")local bg,o=do_syscall("rename",bR,bS)if not bg then bg=nil end;return bg,o end,setlocale=function(d7)if d7 then error("setlocale is not supported",2)else return"C"end end,time=function(y)if y=="ingame"then return d6.epoch"ingame"/1000 elseif y=="nano"then return ccemux and ccemux.nanoTime()or d6.epoch"nano"end;expect(1,y,"table","nil")if y then return d6.time(y)else return d6.epoch"utc"/1000 end end,tmpname=function()local m="/tmp/lua_"for v=1,6 do local r=math.random(1,64)m=m..("qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890._"):sub(r,r)end;return m end}cK.debug=deepcopy(debug)createRequire(process,cK)for h,i in pairs(cK)do if type(i)=="function"then pcall(setfenv,i,cK)pcall(debug.protect,i)elseif type(i)=="table"and h~="debug"then for z,af in pairs(i)do if type(af)=="function"then pcall(setfenv,af,cK)pcall(debug.protect,af)end end end end;return cK end;function loadfile(bb,n,e)if e==nil and type(n)=="table"then e,n=n,nil end;if type(bb)~="string"then error("bad argument #1 (expected string, got "..type(bb)..")",2)end;if n~=nil and type(n)~="string"then error("bad argument #2 (expected string, got "..type(n)..")",2)end;if e~=nil and type(e)~="table"then error("bad argument #3 (expected table, got "..type(e)..")",2)end;local a,o=filesystem.open(KERNEL,bb,"rb")if not a then error(o,2)end;local bj=a.readAll()a.close()return load(bj,"@"..bb,n,e)end;function dofile(bb)if bb~=nil and type(bb)~="string"then error("bad argument #1 (expected string, got "..type(bb)..")",2)end;local g,o=loadfile(bb or io.stdin:read("*a"))if not g then error(o,2)end;return g()end;function print(...)for v=1,select("#",...)do local i=tostring(select(v,...))terminal.write(TTY[1],i)end end;function terminal.makeTTY(term,t,d8)local a5={isTTY=true,flags={cbreak=false,delay=true,echo=true,keypad=false,nlcr=true,raw=false},cursor={x=1,y=1},cursorBlink=true,colors={fg='0',bg='f',bold=false},size={width=t,height=d8},dirtyLines={},palette={},dirtyPalette={},buffer="",preBuffer="",isLocked=false,isGraphics=false,textBuffer={},graphicsBuffer={},frontmostProcess=nil,processList={},eof=false,term=term}for q=1,d8 do a5[q]={(' '):rep(t),('0'):rep(t),('f'):rep(t)}a5.dirtyLines[q]=true end;for v=0,15 do a5.palette[v]={_G.term.nativePaletteColor(2^v)}a5.dirtyPalette[v]=true end;return a5 end;do local d9,da=term.getSize()TTY={terminal.makeTTY(term,d9,da),terminal.makeTTY(term,d9,da),terminal.makeTTY(term,d9,da),terminal.makeTTY(term,d9,da),terminal.makeTTY(term,d9,da),terminal.makeTTY(term,d9,da),terminal.makeTTY(term,d9,da),terminal.makeTTY(term,d9,da)}end;currentTTY=TTY[1]terminal.userTTYs={}do local r=args.console:match"^tty(%d+)$"if r then KERNEL.stdout,KERNEL.stderr,KERNEL.stdin=TTY[tonumber(r)],TTY[tonumber(r)],TTY[tonumber(r)]end end;keysHeld={ctrl=false,alt=false,shift=false}eventHooks.term_resize=eventHooks.term_resize or{}eventHooks.char=eventHooks.char or{}eventHooks.paste=eventHooks.paste or{}eventHooks.key=eventHooks.key or{}eventHooks.key_up=eventHooks.key_up or{}eventHooks.term_resize[#eventHooks.term_resize+1]=function()local af,ag=term.getSize()for v=1,8 do terminal.resize(TTY[v],af,ag)end end;eventHooks.char[#eventHooks.char+1]=function(ar)if not currentTTY.isLocked then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer..ar[2]else currentTTY.preBuffer=currentTTY.preBuffer..ar[2]end;if currentTTY.flags.echo then terminal.write(currentTTY,ar[2])terminal.redraw(currentTTY)end end end;eventHooks.paste[#eventHooks.paste+1]=function(ar)if not currentTTY.isLocked then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer..ar[2]else currentTTY.preBuffer=currentTTY.preBuffer..ar[2]end;if currentTTY.flags.echo then terminal.write(currentTTY,ar[2])terminal.redraw(currentTTY)end end end;eventHooks.key[#eventHooks.key+1]=function(ar)if not currentTTY.isLocked then if ar[2]==keys.enter then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer.."\n"else currentTTY.buffer=currentTTY.buffer..currentTTY.preBuffer.."\n"currentTTY.preBuffer=""end;if currentTTY.flags.echo then terminal.write(currentTTY,"\n")terminal.redraw(currentTTY)end elseif ar[2]==keys.backspace then if currentTTY.flags.cbreak then elseif#currentTTY.preBuffer>0 then currentTTY.preBuffer=currentTTY.preBuffer:sub(1,-2)if currentTTY.flags.echo then terminal.write(currentTTY,"\b \b")terminal.redraw(currentTTY)end end end end;if ar[2]==keys.leftCtrl or ar[2]==keys.rightCtrl then keysHeld.ctrl=true elseif ar[2]==keys.leftAlt or ar[2]==keys.rightAlt then keysHeld.alt=true elseif ar[2]==keys.leftShift or ar[2]==keys.rightShift then keysHeld.shift=true end;if not currentTTY.flags.raw and currentTTY.frontmostProcess and keysHeld.ctrl and not keysHeld.alt and not keysHeld.shift then if ar[2]==keys.c then killProcess(currentTTY.frontmostProcess.id,2)terminal.write(currentTTY,"^C")elseif ar[2]==keys.backslash then killProcess(currentTTY.frontmostProcess.id,3)terminal.write(currentTTY,"^\\")elseif ar[2]==keys.z then killProcess(currentTTY.frontmostProcess.id,19)terminal.write(currentTTY,"^Z")elseif ar[2]==keys.d then currentTTY.eof=true;terminal.write(currentTTY,"^D")end end;if keysHeld.ctrl and not keysHeld.alt and keysHeld.shift then local db=true;if ar[2]==keys.f1 then currentTTY=TTY[1]elseif ar[2]==keys.f2 then currentTTY=TTY[2]elseif ar[2]==keys.f3 then currentTTY=TTY[3]elseif ar[2]==keys.f4 then currentTTY=TTY[4]elseif ar[2]==keys.f5 then currentTTY=TTY[5]elseif ar[2]==keys.f6 then currentTTY=TTY[6]elseif ar[2]==keys.f7 then currentTTY=TTY[7]elseif ar[2]==keys.f8 then currentTTY=TTY[8]elseif ar[2]==keys.left then for v=1,8 do if currentTTY==TTY[v]then currentTTY=TTY[(v+7)%8]break end end elseif ar[2]==keys.right then for v=1,8 do if currentTTY==TTY[v]then currentTTY=TTY[(v+1)%8]break end end else db=false end;if db then terminal.redraw(currentTTY,true)end end end;eventHooks.key_up[#eventHooks.key_up+1]=function(ar)if ar[2]==keys.leftCtrl or ar[2]==keys.rightCtrl then keysHeld.ctrl=false elseif ar[2]==keys.leftAlt or ar[2]==keys.rightAlt then keysHeld.alt=false elseif ar[2]==keys.leftShift or ar[2]==keys.rightShift then keysHeld.shift=false end end;function terminal.redraw(dc,bZ)if dc.process then dc.process.eventQueue[#dc.process.eventQueue+1]={"tty_redraw",{id=dc.id}}return elseif currentTTY~=dc and not dc.isMonitor then return end;local term=dc.term;local d3=dc;if dc.isLocked then if dc.isGraphics then term.setGraphicsMode(2)if term.setFrozen then term.setFrozen(true)end;if bZ then term.clear()term.drawPixels(0,0,dc.graphicsBuffer)for v=0,255 do term.setPaletteColor(v,dc.graphicsBuffer.palette[v][1],dc.graphicsBuffer.palette[v][2],dc.graphicsBuffer.palette[v][3])end else if dc.graphicsBuffer.frozen then if term.setFrozen then term.setFrozen(false)end;return end;for z,i in ipairs(dc.graphicsBuffer.dirtyRects)do if i.color then term.setPixel(i.x,i.y,i.color,i.width,i.height)else term.drawPixels(i.x,i.y,i)end end;for v in pairs(dc.graphicsBuffer.dirtyPalette)do term.setPaletteColor(v,dc.graphicsBuffer.palette[v][1],dc.graphicsBuffer.palette[v][2],dc.graphicsBuffer.palette[v][3])end end;if term.setFrozen then term.setFrozen(false)end;d3.dirtyRects,d3.dirtyPalette={},{}return end;if term.setGraphicsMode then term.setGraphicsMode(false)end;d3=dc.textBuffer elseif dc.isGraphics then term.setGraphicsMode(false)dc.isGraphics=false end;term.setCursorBlink(false)if bZ then term.clear()for q=1,dc.size.height do term.setCursorPos(1,q)term.blit(d3[q][1],d3[q][2],d3[q][3])end;for v=0,15 do term.setPaletteColor(2^v,d3.palette[v][1],d3.palette[v][2],d3.palette[v][3])end else for q in pairs(d3.dirtyLines)do if not d3[q]then error(debug.traceback(q))end;term.setCursorPos(1,q)if#d3[q][1]~=#d3[q][2]or#d3[q][2]~=#d3[q][3]then syslog.log({level="critical"},"Bug in text writer! Inequal lengths: "..#d3[q][1]..", "..#d3[q][2]..", "..#d3[q][3])error("Invalid lengths")end;term.blit(d3[q][1],d3[q][2],d3[q][3])end;for v in pairs(d3.dirtyPalette)do term.setPaletteColor(2^v,d3.palette[v][1],d3.palette[v][2],d3.palette[v][3])end end;term.setCursorPos(d3.cursor.x,d3.cursor.y)term.setCursorBlink(d3.cursorBlink)term.setTextColor(2^tonumber(d3.colors.fg,16))d3.dirtyLines,d3.dirtyPalette={},{}end;function terminal.resize(dc,t,d8)if t>dc.size.width then for q=1,dc.size.height do dc[q][1]=dc[q][1]..(' '):rep(t-dc.size.width)dc[q][2]=dc[q][2]..dc.colors.fg:rep(t-dc.size.width)dc[q][3]=dc[q][3]..dc.colors.bg:rep(t-dc.size.width)dc.dirtyLines[q]=true end;if dc.isLocked then if dc.isGraphics then for q=1,dc.size.height*9 do dc.graphicsBuffer[q]=dc.graphicsBuffer[q]..('\15'):rep((t-dc.size.width)*6)end;dc.graphicsBuffer.dirtyRects[#dc.graphicsBuffer.dirtyRects+1]={x=dc.size.width*6+1,y=1,width=(t-dc.size.width)*6,height=dc.size.height*9}else for q=1,dc.size.height do dc.textBuffer[q][1]=dc.textBuffer[q][1]..(' '):rep(t-dc.size.width)dc.textBuffer[q][2]=dc.textBuffer[q][2]..dc.textBuffer.colors.fg:rep(t-dc.size.width)dc.textBuffer[q][3]=dc.textBuffer[q][3]..dc.textBuffer.colors.bg:rep(t-dc.size.width)dc.textBuffer.dirtyLines[q]=true end end end elseif t<dc.size.width then for q=1,dc.size.height do dc[q][1]=dc[q][1]:sub(1,t)dc[q][2]=dc[q][2]:sub(1,t)dc[q][3]=dc[q][3]:sub(1,t)dc.dirtyLines[q]=true end;if dc.isLocked then if dc.isGraphics then for q=1,dc.size.height*9 do dc.graphicsBuffer[q]=dc.graphicsBuffer[q]:sub(1,t*6)end else for q=1,dc.size.height do dc.textBuffer[q][1]=dc.textBuffer[q][1]:sub(1,t)dc.textBuffer[q][2]=dc.textBuffer[q][2]:sub(1,t)dc.textBuffer[q][3]=dc.textBuffer[q][3]:sub(1,t)end end end end;dc.size.width=t;if d8>dc.size.height then for q=dc.size.height+1,d8 do dc[q]={(' '):rep(t),dc.colors.fg:rep(t),dc.colors.bg:rep(t)}dc.dirtyLines[q]=true end;if dc.isLocked then if dc.isGraphics then for q=dc.size.height*9+1,d8*9 do dc.graphicsBuffer[q]=('\15'):rep(t*6)end;dc.graphicsBuffer.dirtyRects[#dc.graphicsBuffer.dirtyRects+1]={x=1,y=dc.size.height*9+1,width=dc.size.width*6,height=(d8-dc.size.height)*9}else for q=dc.size.height+1,d8 do dc.textBuffer[q]={(' '):rep(t),dc.textBuffer.colors.fg:rep(t),dc.textBuffer.colors.bg:rep(t)}dc.textBuffer.dirtyLines[q]=true end end end elseif d8<dc.size.height then for q=d8+1,dc.size.height do dc[q]=nil;dc.dirtyLines[q]=nil end;if dc.isLocked then if dc.isGraphics then for q=d8*9+1,dc.size.height*9 do dc.graphicsBuffer[q]=nil end else for q=d8+1,dc.size.height do dc.textBuffer[q]=nil;dc.textBuffer.dirtyLines[q]=nil end end end end;dc.size.height=d8 end;local function dd(dc)local de=dc.cursor;local q=de.y+1;de.y=q;local S=dc.size;local d8=S.height;if q>d8 then local df=dc.dirtyLines;for v=1,d8-1 do dc[v]=dc[v+1]df[v]=true end;local t=S.width;local dg=dc.colors;dc[d8]={(' '):rep(t),dg.fg:rep(t),dg.bg:rep(t)}df[d8]=true;de.y=d8 end end;local dh={['@']=function(dc,av)local E=av[1]or 1;if E==0 then E=1 end;local di,dj=E%dc.size.width,math.floor(E/dc.size.width)local r={dc[dc.cursor.y][1]:sub(dc.size.width-di+1),dc[dc.cursor.y][2]:sub(dc.size.width-di+1),dc[dc.cursor.y][3]:sub(dc.size.width-di+1)}dc[dc.cursor.y][1]=dc[dc.cursor.y][1]:sub(1,dc.cursor.x-1)..(" "):rep(E)..dc[dc.cursor.y+dj][1]:sub(dc.cursor.x,dc.size.width-di)dc[dc.cursor.y][2]=dc[dc.cursor.y][2]:sub(1,dc.cursor.x-1)..dc.colors.fg:rep(E)..dc[dc.cursor.y+dj][2]:sub(dc.cursor.x,dc.size.width-di)dc[dc.cursor.y][3]=dc[dc.cursor.y][3]:sub(1,dc.cursor.x-1)..dc.colors.bg:rep(E)..dc[dc.cursor.y+dj][3]:sub(dc.cursor.x,dc.size.width-di)dc.dirtyLines[dc.cursor.y]=true;for q=dc.cursor.y+dj+1,dc.size.height do local dk={dc[q-dj][1]:sub(dc.size.width-E+1),dc[q-dj][2]:sub(dc.size.width-E+1),dc[q-dj][3]:sub(dc.size.width-E+1)}dc[q][1]=r[1]..dc[q-dj][1]:sub(1,dc.size.width-di)dc[q][2]=r[2]..dc[q-dj][2]:sub(1,dc.size.width-di)dc[q][3]=r[3]..dc[q-dj][3]:sub(1,dc.size.width-di)dc.dirtyLines[q]=true;r=dk end;for q=dc.cursor.y+1,dc.cursor.y+dj do dc[q][1]=(" "):rep(dc.size.width)dc[q][2]=dc.colors.fg:rep(dc.size.width)dc[q][3]=dc.colors.bg:rep(dc.size.width)dc.dirtyLines[q]=true end end,A=function(dc,av)local E=av[1]or 1;if E==0 then E=1 end;dc.cursor.y=math.max(dc.cursor.y-E,1)end,B=function(dc,av)local E=av[1]or 1;if E==0 then E=1 end;dc.cursor.y=math.min(dc.cursor.y+E,dc.size.height)end,C=function(dc,av)local E=av[1]or 1;if E==0 then E=1 end;dc.cursor.y=dc.cursor.y+math.floor((dc.cursor.x-1+E)/dc.size.width)dc.cursor.x=(dc.cursor.x-1+E)%dc.size.width+1 end,D=function(dc,av)local E=av[1]or 1;if E==0 then E=1 end;dc.cursor.y=dc.cursor.y+math.floor((dc.cursor.x-1-E)/dc.size.width)dc.cursor.x=(dc.cursor.x-1-E)%dc.size.width+1 end,E=function(dc,av)local E=av[1]or 1;if E==0 then E=1 end;dc.cursor.y=math.min(dc.cursor.y+E,dc.size.height)dc.cursor.x=1 end,F=function(dc,av)local E=av[1]or 1;if E==0 then E=1 end;dc.cursor.y=math.max(dc.cursor.y-E,1)dc.cursor.x=1 end,G=function(dc,av)local E=av[1]or 1;if E==0 then E=1 end;dc.cursor.x=math.min(E,dc.size.width)end,H=function(dc,av)local bt,a9=av[1]or 1,av[2]or 1;if bt==0 then bt=1 end;if a9==0 then a9=1 end;dc.cursor.x,dc.cursor.y=math.min(a9,dc.size.width),math.min(bt,dc.size.height)end,I=function(dc,av)end,J=function(dc,av)local r=av[1]or 0;if r==0 then dc[dc.cursor.y][1]=dc[dc.cursor.y][1]:sub(1,dc.cursor.x-1)..(" "):rep(dc.size.width-dc.cursor.x)dc[dc.cursor.y][2]=dc[dc.cursor.y][2]:sub(1,dc.cursor.x-1)..dc.colors.fg:rep(dc.size.width-dc.cursor.x)dc[dc.cursor.y][3]=dc[dc.cursor.y][3]:sub(1,dc.cursor.x-1)..dc.colors.bg:rep(dc.size.width-dc.cursor.x)dc.dirtyLines[dc.cursor.y]=true;for q=dc.cursor.y+1,dc.size.height do dc[q][1]=(" "):rep(dc.size.width)dc[q][2]=dc.colors.fg:rep(dc.size.width)dc[q][3]=dc.colors.bg:rep(dc.size.width)dc.dirtyLines[q]=true end elseif r==1 then dc[dc.cursor.y][1]=(" "):rep(dc.cursor.x)..dc[dc.cursor.y][1]:sub(dc.cursor.x)dc[dc.cursor.y][2]=dc.colors.fg:rep(dc.cursor.x)..dc[dc.cursor.y][2]:sub(dc.cursor.x)dc[dc.cursor.y][3]=dc.colors.bg:rep(dc.cursor.x)..dc[dc.cursor.y][3]:sub(dc.cursor.x)dc.dirtyLines[dc.cursor.y]=true;for q=dc.cursor.y-1,1,-1 do dc[q][1]=(" "):rep(dc.size.width)dc[q][2]=dc.colors.fg:rep(dc.size.width)dc[q][3]=dc.colors.bg:rep(dc.size.width)dc.dirtyLines[q]=true end elseif r==2 then for q=1,dc.size.height do dc[q][1]=(" "):rep(dc.size.width)dc[q][2]=dc.colors.fg:rep(dc.size.width)dc[q][3]=dc.colors.bg:rep(dc.size.width)dc.dirtyLines[q]=true end end end,K=function(dc,av)local r=av[1]or 0;if r==0 then dc[dc.cursor.y][1]=dc[dc.cursor.y][1]:sub(1,dc.cursor.x-1)..(" "):rep(dc.size.width-dc.cursor.x)dc[dc.cursor.y][2]=dc[dc.cursor.y][2]:sub(1,dc.cursor.x-1)..dc.colors.fg:rep(dc.size.width-dc.cursor.x)dc[dc.cursor.y][3]=dc[dc.cursor.y][3]:sub(1,dc.cursor.x-1)..dc.colors.bg:rep(dc.size.width-dc.cursor.x)dc.dirtyLines[dc.cursor.y]=true elseif r==1 then dc[dc.cursor.y][1]=(" "):rep(dc.cursor.x)..dc[dc.cursor.y][1]:sub(dc.cursor.x)dc[dc.cursor.y][2]=dc.colors.fg:rep(dc.cursor.x)..dc[dc.cursor.y][2]:sub(dc.cursor.x)dc[dc.cursor.y][3]=dc.colors.bg:rep(dc.cursor.x)..dc[dc.cursor.y][3]:sub(dc.cursor.x)dc.dirtyLines[dc.cursor.y]=true elseif r==2 then dc[dc.cursor.y][1]=(" "):rep(dc.size.width)dc[dc.cursor.y][2]=dc.colors.fg:rep(dc.size.width)dc[dc.cursor.y][3]=dc.colors.bg:rep(dc.size.width)dc.dirtyLines[dc.cursor.y]=true end end,L=function(dc,av)end,M=function(dc,av)end,N=function(dc,av)end,O=function(dc,av)end,P=function(dc,av)local E=av[1]or 1;if E==0 then E=1 end;local di,dj=E%dc.size.width,math.floor(E/dc.size.width)local r={(" "):rep(di),dc.colors.fg:rep(di),dc.colors.bg:rep(di)}for q=dc.size.height-dj,dc.cursor.y+1,-1 do local dk={dc[q+dj][1]:sub(1,di),dc[q+dj][2]:sub(1,di),dc[q+dj][3]:sub(1,di)}dc[q][1]=dc[q+dj][1]:sub(di+1)..r[1]dc[q][2]=dc[q+dj][2]:sub(di+1)..r[2]dc[q][3]=dc[q+dj][3]:sub(di+1)..r[3]dc.dirtyLines[q]=true;r=dk end;for q=dc.size.height-dj+1,dc.size.height do dc[q][1]=(" "):rep(dc.size.width)dc[q][2]=dc.colors.fg:rep(dc.size.width)dc[q][3]=dc.colors.bg:rep(dc.size.width)dc.dirtyLines[q]=true end;dc[dc.cursor.y][1]=dc[dc.cursor.y][1]:sub(1,dc.cursor.x-1)..dc[dc.cursor.y+dj][1]:sub(dc.cursor.x+di,dc.size.width)..r[1]dc[dc.cursor.y][2]=dc[dc.cursor.y][2]:sub(1,dc.cursor.x-1)..dc[dc.cursor.y+dj][2]:sub(dc.cursor.x+di,dc.size.width)..r[2]dc[dc.cursor.y][3]=dc[dc.cursor.y][3]:sub(1,dc.cursor.x-1)..dc[dc.cursor.y+dj][3]:sub(dc.cursor.x+di,dc.size.width)..r[3]dc.dirtyLines[dc.cursor.y]=true end,Q=function(dc,av)end,R=function(dc,av)end,S=function(dc,av)local r=av[1]or 0;if r==0 then r=1 end;for z=1,r do table.insert(dc,1,{(' '):rep(dc.size.width),dc.colors.fg:rep(dc.size.width),dc.colors.bg:rep(dc.size.width)})dc[dc.size.height+1]=nil end end,T=function(dc,av)local r=av[1]or 0;if r==0 then r=1 end;for z=1,r do table.remove(dc,1)dc[dc.size.height]={(' '):rep(dc.size.width),dc.colors.fg:rep(dc.size.width),dc.colors.bg:rep(dc.size.width)}end end,U=function(dc,av)end,V=function(dc,av)end,W=function(dc,av)end,X=function(dc,av)end,Y=function(dc,av)end,Z=function(dc,av)end,['[']=function(dc,av)end,['\\']=function(dc,av)end,[']']=function(dc,av)end,['^']=function(dc,av)end,['_']=function(dc,av)end,['`']=function(dc,av)end,a=function(dc,av)end,b=function(dc,av)end,c=function(dc,av)end,d=function(dc,av)end,e=function(dc,av)end,f=function(dc,av)end,g=function(dc,av)end,h=function(dc,av)if av[1]==25 then dc.cursorBlink=true end end,i=function(dc,av)end,j=function(dc,av)end,k=function(dc,av)end,l=function(dc,av)if av[1]==25 then dc.cursorBlink=false end end,m=function(dc,av)local r,A=av[1]or 0,av[2]if r==0 then dc.colors.fg,dc.colors.bg,dc.colors.bold='0','f',false elseif r==1 then dc.colors.bold=true elseif r==7 or r==27 then dc.colors.fg,dc.colors.bg=dc.colors.bg,dc.colors.fg elseif r==22 then dc.colors.bold=false elseif r>=30 and r<=37 then dc.colors.fg=("%x"):format(15-(r-30)-(dc.colors.bold and 8 or 0))elseif r==39 then dc.colors.fg='0'elseif r>=40 and r<=47 then dc.colors.bg=("%x"):format(15-(r-40)-(dc.colors.bold and 8 or 0))elseif r==49 then dc.colors.bg='f'elseif r>=90 and r<=97 then dc.colors.fg=("%x"):format(15-(r-90)-8)elseif r>=100 and r<=107 then dc.colors.bg=("%x"):format(15-(r-100)-8)end;if A~=nil then if A==0 then dc.colors.fg,dc.colors.bg='0','f'elseif A==1 then dc.colors.bold=true elseif A==7 or A==27 then dc.colors.fg,dc.colors.bg=dc.colors.bg,dc.colors.fg elseif A==22 then dc.colors.bold=false elseif A>=30 and A<=37 then dc.colors.fg=("%x"):format(15-(A-30)-(dc.colors.bold and 8 or 0))elseif A==39 then dc.colors.fg='0'elseif A>=40 and A<=47 then dc.colors.bg=("%x"):format(15-(A-40)-(dc.colors.bold and 8 or 0))elseif A==49 then dc.colors.bg='f'elseif A>=90 and A<=97 then dc.colors.fg=("%x"):format(15-(A-90)-8)elseif A>=100 and A<=107 then dc.colors.bg=("%x"):format(15-(A-100)-8)end end end,n=function(dc,av)end,o=function(dc,av)end}for v=0x70,0x7F do dh[string.char(v)]=function(dc,av)end end;function terminal.write(dc,dl)local ax,S=1,0;local function dm(p)if S==0 then ax,S=p,0;return end;while dc.cursor.x+S>dc.size.width do dc[dc.cursor.y][1]=dc[dc.cursor.y][1]:sub(1,dc.cursor.x-1)..dl:sub(ax,ax+dc.size.width-dc.cursor.x)dc[dc.cursor.y][2]=dc[dc.cursor.y][2]:sub(1,dc.cursor.x-1)..dc.colors.fg:rep(dc.size.width-dc.cursor.x+1)dc[dc.cursor.y][3]=dc[dc.cursor.y][3]:sub(1,dc.cursor.x-1)..dc.colors.bg:rep(dc.size.width-dc.cursor.x+1)dc.dirtyLines[dc.cursor.y]=true;ax=ax+dc.size.width-dc.cursor.x+1;S=S-(dc.size.width-dc.cursor.x+1)dc.cursor.x=1;dd(dc)end;dc[dc.cursor.y][1]=dc[dc.cursor.y][1]:sub(1,dc.cursor.x-1)..dl:sub(ax,ax+S-1)..dc[dc.cursor.y][1]:sub(dc.cursor.x+S)dc[dc.cursor.y][2]=dc[dc.cursor.y][2]:sub(1,dc.cursor.x-1)..dc.colors.fg:rep(S)..dc[dc.cursor.y][2]:sub(dc.cursor.x+S)dc[dc.cursor.y][3]=dc[dc.cursor.y][3]:sub(1,dc.cursor.x-1)..dc.colors.bg:rep(S)..dc[dc.cursor.y][3]:sub(dc.cursor.x+S)dc.dirtyLines[dc.cursor.y]=true;dc.cursor.x=dc.cursor.x+S;ax,S=p,0 end;local dn=0;local av,dp;for p,a9,r in dl:gmatch"()(.)()"do if dn==0 then if a9=='\a'then dm(r)elseif a9=='\b'then dm(r)if dc.cursor.x==1 then if dc.cursor.y>1 then dc.cursor.x,dc.cursor.y=dc.size.width,dc.cursor.y-1 end else dc.cursor.x=dc.cursor.x-1 end elseif a9=='\t'then dm(r)dc.cursor.x=math.floor((dc.cursor.x-1)/8)*8+9;if dc.cursor.x>dc.size.width then dc.cursor.x=1;dd(dc)end elseif a9=='\n'then dm(r)dd(dc)if dc.flags.nlcr then dc.cursor.x=1 end elseif a9=='\f'then dm(r)dd(dc)elseif a9=='\r'then dm(r)dc.cursor.x=1 elseif a9=='\27'then dn=1 else S=S+1 end elseif dn==1 then if false then elseif a9=='['then dn=2;av,dp={},0 elseif a9==']'then if dl:byte(r)==0x50 then dn=4;av={}else dn=3;av,dp={},0 end else dm(r)dn=0 end elseif dn==2 then if a9>='@'and a9<='\127'then dm(r)av[#av+1]=dp;dh[a9](dc,av)dn=0 elseif a9>='0'and a9<='?'then if a9<='9'then dp=dp*10+tonumber(a9)elseif a9==';'then av[#av+1],dp=dp,0 end else dm(r)dn=0 end elseif dn==3 then if a9=='\\'and dl:byte(p-1)=='\27'then dm(r)dn=0 end elseif dn==4 then if#av==0 then av[1]=tonumber(a9,16)or 0 elseif#av==1 and not dp then dp=(tonumber(a9,16)or 0)*16 elseif#av==1 then av[2],dp=dp+(tonumber(a9,16)or 0),nil elseif#av==2 and not dp then dp=(tonumber(a9,16)or 0)*16 elseif#av==2 then av[3],dp=dp+(tonumber(a9,16)or 0),nil elseif#av==3 and not dp then dp=(tonumber(a9,16)or 0)*16 elseif#av==3 then dm(r)av[4],dp=dp+(tonumber(a9,16)or 0),nil;dc.palette[av[1]]={av[2]/255,av[3]/255,av[4]/255}dc.dirtyPalette[av[1]]=true;dn=0 end end end;dm()end;function syscalls.write(process,aq,...)if not process.stdout then return end;local function dq(y)if process.stdout.isTTY then terminal.write(process.stdout,y)else process.stdout.write(y)end end;local args=table.pack(...)for v=1,args.n do if v>1 then dq("\t")end;dq(tostring(args[v]))end;if process.stdout.isTTY then terminal.redraw(process.stdout)end end;function syscalls.writeerr(process,aq,...)if not process.stderr then return end;local function dq(y)if process.stderr.isTTY then terminal.write(process.stderr,y)else process.stderr.write(y)end end;local args=table.pack(...)for v=1,args.n do if v>1 then dq("\t")end;dq(tostring(args[v]))end;if process.stderr.isTTY then terminal.redraw(process.stderr)end end;function syscalls.read(process,aq,r)expect(1,r,"number")if process.stdin then if process.stdin.eof then process.stdin.eof=false;return nil end;while#process.stdin.buffer<r do if process.stdin.eof then process.stdin.eof=false;return nil end;if process.stdin.isTTY and not process.stdin.flags.delay then return nil end;if process.stdin.read then local bs=process.stdin.read(r-#process.stdin.buffer)if not bs then return nil end;process.stdin.buffer=process.stdin.buffer..bs else return kSyscallYield,"read",r end end;local bs=process.stdin.buffer:sub(1,r-1)process.stdin.buffer=process.stdin.buffer:sub(r)return bs else return nil end end;function syscalls.readline(process,aq)if process.stdin then if process.stdin.eof then process.stdin.eof=false;return nil end;while not process.stdin.buffer:find("\n")do if process.stdin.eof then process.stdin.eof=false;return nil end;if process.stdin.isTTY and not process.stdin.flags.delay then return nil end;if process.stdin.read then local bs=process.stdin.read()if not bs then return nil end;process.stdin.buffer=process.stdin.buffer..bs else return kSyscallYield,"readline"end end;local r=process.stdin.buffer:find("\n")local bs=process.stdin.buffer:sub(1,r-1)process.stdin.buffer=process.stdin.buffer:sub(r+1)return bs else return nil end end;function syscalls.termctl(process,aq,dr)expect(1,dr,"table","nil")if not process.stdout or not process.stdout.isTTY then return nil end;if dr then expect.field(dr,"cbreak","boolean","nil")expect.field(dr,"delay","boolean","nil")expect.field(dr,"echo","boolean","nil")expect.field(dr,"keypad","boolean","nil")expect.field(dr,"nlcr","boolean","nil")expect.field(dr,"raw","boolean","nil")for h,i in pairs(dr)do if process.stdout.flags[h]~=nil then process.stdout.flags[h]=i end end end;local y=deepcopy(process.stdout.flags)y.hasgfx=term.getGraphicsMode~=nil;return y end;function terminal.openterm(dc,process)if dc.isLocked then if not dc.isGraphics and dc.frontmostProcess==process then return dc.screenHandle end;return nil,"Terminal already in use"end;local S=dc.size;local d3={cursor={x=1,y=1},cursorBlink=false,colors={fg='0',bg='f'},palette={},dirtyLines={},dirtyPalette={}}dc.textBuffer=d3;dc.isLocked=true;dc.isGraphics=false;for q=1,S.height do d3[q]={(' '):rep(S.width),('0'):rep(S.width),('f'):rep(S.width)}d3.dirtyLines[q]=true end;for v=0,15 do d3.palette[v]={term.nativePaletteColor(2^v)}d3.dirtyPalette[v]=true end;dc.processList[#dc.processList+1]=dc.frontmostProcess;dc.frontmostProcess=process;local ds=setmetatable({},{__name="Terminal"})local dt=terminal.redraw;local expect=expect;dc.screenHandle=ds;function ds.close()if not ds then error("terminal is already closed",2)end;ds=nil;dc.isLocked=false;dc.frontmostProcess=table.remove(dc.processList)dc.screenHandle=nil;dt(dc,true)end;function ds.write(dl)if not ds then error("terminal is already closed",2)end;dl=tostring(dl)expect(1,dl,"string")if d3.cursor.y<1 or d3.cursor.y>S.height then return elseif d3.cursor.x>S.width or d3.cursor.x+#dl<1 then d3.cursor.x=d3.cursor.x+#dl;return elseif d3.cursor.x<1 then dl=dl:sub(-d3.cursor.x+2)d3.cursor.x=1 end;local du=#dl;if d3.cursor.x+#dl>S.width then dl=dl:sub(1,S.width-d3.cursor.x+1)end;d3[d3.cursor.y][1]=d3[d3.cursor.y][1]:sub(1,d3.cursor.x-1)..dl..d3[d3.cursor.y][1]:sub(d3.cursor.x+#dl)d3[d3.cursor.y][2]=d3[d3.cursor.y][2]:sub(1,d3.cursor.x-1)..d3.colors.fg:rep(#dl)..d3[d3.cursor.y][2]:sub(d3.cursor.x+#dl)d3[d3.cursor.y][3]=d3[d3.cursor.y][3]:sub(1,d3.cursor.x-1)..d3.colors.bg:rep(#dl)..d3[d3.cursor.y][3]:sub(d3.cursor.x+#dl)d3.cursor.x=d3.cursor.x+du;d3.dirtyLines[d3.cursor.y]=true end;function ds.blit(dl,dv,dw)if not ds then error("terminal is already closed",2)end;dl=tostring(dl)expect(1,dl,"string")expect(2,dv,"string")expect(3,dw,"string")if#dl~=#dv or#dv~=#dw then error("Arguments must be the same length",2)end;if d3.cursor.y<1 or d3.cursor.y>S.height then return elseif d3.cursor.x>S.width or d3.cursor.x<1-#dl then d3.cursor.x=d3.cursor.x+#dl;dt(dc)return elseif d3.cursor.x<1 then dl,dv,dw=dl:sub(-d3.cursor.x+2),dv:sub(-d3.cursor.x+2),dw:sub(-d3.cursor.x+2)d3.cursor.x=1 end;local du=#dl;if d3.cursor.x+#dl>S.width then dl,dv,dw=dl:sub(1,S.width-d3.cursor.x+1),dv:sub(1,S.width-d3.cursor.x+1),dw:sub(1,S.width-d3.cursor.x+1)end;d3[d3.cursor.y][1]=d3[d3.cursor.y][1]:sub(1,d3.cursor.x-1)..dl..d3[d3.cursor.y][1]:sub(d3.cursor.x+#dl)d3[d3.cursor.y][2]=d3[d3.cursor.y][2]:sub(1,d3.cursor.x-1)..dv..d3[d3.cursor.y][2]:sub(d3.cursor.x+#dv)d3[d3.cursor.y][3]=d3[d3.cursor.y][3]:sub(1,d3.cursor.x-1)..dw..d3[d3.cursor.y][3]:sub(d3.cursor.x+#dw)d3.cursor.x=d3.cursor.x+du;d3.dirtyLines[d3.cursor.y]=true end;function ds.clear()if not ds then error("terminal is already closed",2)end;for q=1,S.height do d3[q]={(' '):rep(S.width),d3.colors.fg:rep(S.width),d3.colors.bg:rep(S.width)}d3.dirtyLines[q]=true end end;function ds.clearLine()if not ds then error("terminal is already closed",2)end;if d3.cursor.y>=1 and d3.cursor.y<=S.height then d3[d3.cursor.y]={(' '):rep(S.width),d3.colors.fg:rep(S.width),d3.colors.bg:rep(S.width)}d3.dirtyLines[d3.cursor.y]=true end end;function ds.getCursorPos()if not ds then error("terminal is already closed",2)end;return d3.cursor.x,d3.cursor.y end;function ds.setCursorPos(dx,dy)if not ds then error("terminal is already closed",2)end;expect(1,dx,"number")expect(2,dy,"number")if dx==d3.cursor.x and dy==d3.cursor.y then return end;d3.cursor.x,d3.cursor.y=math.floor(dx),math.floor(dy)end;function ds.getCursorBlink()if not ds then error("terminal is already closed",2)end;return d3.cursorBlink end;function ds.setCursorBlink(ab)if not ds then error("terminal is already closed",2)end;expect(1,ab,"boolean")d3.cursorBlink=ab end;function ds.isColor()if not ds then error("terminal is already closed",2)end;return true end;function ds.getSize()if not ds then error("terminal is already closed",2)end;return S.width,S.height end;function ds.scroll(dz)if not ds then error("terminal is already closed",2)end;expect(1,dz,"number")if math.abs(dz)>=S.width then for q=1,S.height do d3[q]={(' '):rep(S.width),d3.colors.fg:rep(S.width),d3.colors.bg:rep(S.width)}end elseif dz>0 then for v=dz+1,S.height do d3[v-dz]=d3[v]end;for v=S.height-dz+1,S.height do d3[v]={(' '):rep(S.width),d3.colors.fg:rep(S.width),d3.colors.bg:rep(S.width)}end elseif dz<0 then for v=1,S.height+dz do d3[v-dz]=d3[v]end;for v=1,-dz do d3[v]={(' '):rep(S.width),d3.colors.fg:rep(S.width),d3.colors.bg:rep(S.width)}end else return end;for v=1,S.height do d3.dirtyLines[v]=true end end;function ds.getTextColor()if not ds then error("terminal is already closed",2)end;return tonumber(d3.colors.fg,16)end;function ds.setTextColor(dA)if not ds then error("terminal is already closed",2)end;expect(1,dA,"number")expect.range(dA,0,15)d3.colors.fg=("%x"):format(dA)end;function ds.getBackgroundColor()if not ds then error("terminal is already closed",2)end;return tonumber(d3.colors.bg,16)end;function ds.setBackgroundColor(dA)if not ds then error("terminal is already closed",2)end;expect(1,dA,"number")expect.range(dA,0,15)d3.colors.bg=("%x"):format(dA)end;function ds.getPaletteColor(dA)if not ds then error("terminal is already closed",2)end;expect(1,dA,"number")expect.range(dA,0,15)return table.unpack(d3.palette[math.floor(dA)])end;function ds.setPaletteColor(dA,bt,dB,ab)if not ds then error("terminal is already closed",2)end;expect(1,dA,"number")expect(2,bt,"number")if dB==nil and ab==nil then bt,dB,ab=bit32.band(bit32.rshift(bt,16),0xFF)/255,bit32.band(bit32.rshift(bt,8),0xFF)/255,bit32.band(bt,0xFF)/255 end;expect(3,dB,"number")expect(4,ab,"number")expect.range(dA,0,15)if bt<0 or bt>1 then error("bad argument #2 (value out of range)",2)end;if dB<0 or dB>1 then error("bad argument #3 (value out of range)",2)end;if ab<0 or ab>1 then error("bad argument #4 (value out of range)",2)end;d3.palette[math.floor(dA)]={bt,dB,ab}d3.dirtyPalette[math.floor(dA)]=true end;function ds.getLine(q)if not ds then error("terminal is already closed",2)end;expect(1,q,"number")local N=d3[q]if N then return table.unpack(N,1,3)end end;local dC=term.nativePaletteColor;function ds.nativePaletteColor(dA)expect(1,dA,"number")expect.range(dA,0,15)return dC(2^dA)end;for z,i in pairs(ds)do setfenv(i,process.env)debug.protect(i)end;ds.isColour=ds.isColor;ds.getTextColour=ds.getTextColor;ds.setTextColour=ds.setTextColor;ds.getBackgroundColour=ds.getBackgroundColor;ds.setBackgroundColour=ds.setBackgroundColor;ds.getPaletteColour=ds.getPaletteColor;ds.setPaletteColour=ds.setPaletteColor;ds.nativePaletteColour=ds.nativePaletteColor;process.dependents[#process.dependents+1]={gc=function()if ds then return ds.close()end end}dt(dc,true)return ds end;function syscalls.openterm(process,aq)if not process.stdout or not process.stdout.isTTY then return nil,"No valid TTY attached"end;if process~=process.stdout.frontmostProcess then syscalls.kill(KERNEL,nil,process.id,22)if process.paused then return kSyscallYield,"openterm"end end;return terminal.openterm(process.stdout,process)end;function terminal.opengfx(dc,process)if not term.drawPixels then return nil,"Graphics mode not supported"end;if dc.isLocked then if dc.isGraphics and dc.frontmostProcess==process then return dc.screenHandle end;return nil,"Terminal already in use"end;local S=dc.size;local d3={palette={},dirtyRects={},dirtyPalette={},frozen=false}dc.graphicsBuffer=d3;dc.isLocked=true;dc.isGraphics=true;for q=1,S.height*9 do d3[q]=('\15'):rep(S.width*6)end;for v=0,15 do d3.palette[v]={term.nativePaletteColor(2^v)}d3.dirtyPalette[v]=true end;for v=16,255 do d3.palette[v]={0,0,0}d3.dirtyPalette[v]=true end;dc.processList[#dc.processList+1]=dc.frontmostProcess;dc.frontmostProcess=process;local ds=setmetatable({},{__name="GFXTerminal"})local dt=terminal.redraw;local expect=expect;dc.screenHandle=ds;function ds.close()if not ds then error("terminal is already closed",2)end;ds=nil;dc.isLocked=false;dc.frontmostProcess=table.remove(dc.processList)dc.screenHandle=nil;dt(dc,true)end;function ds.getSize()return S.width*6,S.height*9 end;function ds.clear()if not ds then error("terminal is already closed",2)end;for q=1,S.height*9 do d3[q]=('\15'):rep(S.width*6)end;dt(dc,true)end;function ds.getPixel(p,q)if not ds then error("terminal is already closed",2)end;expect(1,p,"number")expect(2,q,"number")expect.range(p,0,S.width*6-1)expect.range(q,0,S.height*9-1)p,q=math.floor(p),math.floor(q)return d3[q+1]:byte(p+1)end;function ds.setPixel(p,q,dA)if not ds then error("terminal is already closed",2)end;expect(1,p,"number")expect(2,q,"number")expect(3,dA,"number")expect.range(p,0,S.width*6-1)expect.range(q,0,S.height*9-1)expect.range(dA,0,255)p,q=math.floor(p),math.floor(q)d3[q+1]=d3[q+1]:sub(1,p)..string.char(dA)..d3[q+1]:sub(p+2)d3.dirtyRects[#d3.dirtyRects+1]={x=p,y=q,color=dA}end;function ds.getPixels(p,q,t,d8,dD)if not ds then error("terminal is already closed",2)end;expect(1,p,"number")expect(2,q,"number")expect(3,t,"number")expect(4,d8,"number")expect(5,dD,"boolean","nil")expect.range(t,0)expect.range(d8,0)p,q=math.floor(p),math.floor(q)local y={}for dE=1,d8 do if dD then y[dE]=d3[q+dE]:sub(p+1,p+t)else y[dE]={d3[q+dE]:sub(p+1,p+t):byte(1,-1)}end end;return y end;function ds.drawPixels(p,q,bj,t,d8)if not ds then error("terminal is already closed",2)end;expect(1,p,"number")expect(2,q,"number")expect(3,bj,"table","number")local dF=type(bj)=="number"expect(4,t,"number",not dF and"nil"or nil)expect(5,d8,"number",not dF and"nil"or nil)expect.range(p,0,S.width*6-1)expect.range(q,0,S.height*9-1)if t then expect.range(t,0)end;if d8 then expect.range(d8,0)end;if dF then expect.range(bj,0,255)end;if t==0 or d8==0 then return end;p,q=math.floor(p),math.floor(q)if t and p+t>=S.width*6 then t=S.width*6-p end;d8=d8 or#bj;local dG={x=p,y=q,width=t,height=d8}for dE=1,d8 do if q+dE>S.height*9 then break end;if dF then local bs=string.char(bj):rep(t)d3[q+dE]=d3[q+dE]:sub(1,p)..bs..d3[q+dE]:sub(p+t+1)dG[dE]=bs elseif bj[dE]~=nil then if type(bj[dE])~="table"and type(bj[dE])~="string"then error("bad argument #3 to 'drawPixels' (invalid row "..dE..")",2)end;local t=t or#bj[dE]if p+t>=S.width*6 then t=S.width*6-p end;local bs;if type(bj[dE])=="string"then bs=bj[dE]if#bs<t then bs=bs..('\15'):rep(t-#bs)elseif#bs>t then bs=bs:sub(1,t)end else bs=""for dH=1,t do bs=bs..string.char(bj[dE][dH]or d3[q+dE]:byte(p+dH))end end;d3[q+dE]=d3[q+dE]:sub(1,p)..bs..d3[q+dE]:sub(p+t+1)dG[dE]=bs end end;d3.dirtyRects[#d3.dirtyRects+1]=dG end;function ds.getFrozen()if not ds then error("terminal is already closed",2)end;return d3.frozen end;function ds.setFrozen(f)if not ds then error("terminal is already closed",2)end;expect(1,f,"boolean")d3.frozen=f end;function ds.getPaletteColor(dA)if not ds then error("terminal is already closed",2)end;expect(1,dA,"number")expect.range(dA,0,255)return table.unpack(d3.palette[dA])end;function ds.setPaletteColor(dA,bt,dB,ab)if not ds then error("terminal is already closed",2)end;expect(1,dA,"number")expect(2,bt,"number")if dB==nil and ab==nil then bt,dB,ab=bit32.band(bit32.rshift(bt,16),0xFF)/255,bit32.band(bit32.rshift(bt,8),0xFF)/255,bit32.band(bt,0xFF)/255 end;expect(3,dB,"number")expect(4,ab,"number")expect.range(bt,0,1)expect.range(dB,0,1)expect.range(ab,0,1)expect.range(dA,0,255)d3.palette[dA]={bt,dB,ab}d3.dirtyPalette[dA]=true end;local dC=term.nativePaletteColor;function ds.nativePaletteColor(dA)expect(1,dA,"number")expect.range(dA,0,15)return dC(2^dA)end;for z,i in pairs(ds)do setfenv(i,process.env)debug.protect(i)end;ds.getPaletteColour=ds.getPaletteColor;ds.setPaletteColour=ds.setPaletteColor;ds.nativePaletteColour=ds.nativePaletteColor;process.dependents[#process.dependents+1]={gc=function()if ds then return ds.close()end end}dt(dc,true)return ds end;function syscalls.opengfx(process,aq)if not process.stdout or not process.stdout.isTTY then return nil,"No valid TTY attached"end;if process~=process.stdout.frontmostProcess then syscalls.kill(KERNEL,nil,process.id,22)if process.paused then return kSyscallYield,"openterm"end end;return terminal.opengfx(process.stdout,process)end;function syscalls.mktty(process,aq,t,d8)expect(1,t,"number")expect(2,d8,"number")expect.range(t,1)expect.range(d8,1)local dc=terminal.makeTTY(term,t,d8)dc.id=math.random(0,0x7FFFFFFF)dc.process=process;local aB={__index=dc,__metatable={__name="TTY"}}local a5=setmetatable({},aB)local do_syscall=do_syscall;function a5.sendEvent(ca,d0)return do_syscall("__ttyevent",a5,ca,d0)end;function a5.write(dl)dc.buffer=dc.buffer..tostring(dl)return do_syscall("__ttyevent",a5,"paste",tostring(dl))end;debug.protect(a5.sendEvent)debug.protect(a5.write)aB.__newindex=function()error("cannot modify TTY",2)end;terminal.userTTYs[a5]=dc;process.dependents[#process.dependents+1]={gc=function()terminal.userTTYs[a5]=nil end}return a5 end;function syscalls.__ttyevent(process,aq,dI,ca,d0)expect(1,dI,"table")expect(2,ca,"string")expect(3,d0,"table")local dc=terminal.userTTYs[dI]if not dc then error("Invalid TTY")end;if dc.process~=process then error("Invalid TTY")end;if not dc.frontmostProcess then return end;if ca=="key"then expect.field(d0,"keycode","number")expect.field(d0,"isRepeat","boolean")dc.frontmostProcess.eventQueue[#dc.frontmostProcess.eventQueue+1]={"key",{keycode=d0.keycode,isRepeat=d0.isRepeat,ctrlHeld=keysHeld.ctrl,altHeld=keysHeld.alt,shiftHeld=keysHeld.shift}}if not dc.isLocked then if d0.keycode==10 then if dc.flags.cbreak then dc.buffer=dc.buffer.."\n"else dc.buffer=dc.buffer..dc.preBuffer.."\n"dc.preBuffer=""end;if dc.flags.echo then terminal.write(dc,"\n")terminal.redraw(dc)end elseif d0.keycode==8 then if dc.flags.cbreak then elseif#dc.preBuffer>0 then dc.preBuffer=dc.preBuffer:sub(1,-2)if dc.flags.echo then terminal.write(dc,"\b \b")terminal.redraw(dc)end end end end elseif ca=="key_up"then expect.field(d0,"keycode","number")dc.frontmostProcess.eventQueue[#dc.frontmostProcess.eventQueue+1]={"key_up",{keycode=d0.keycode,ctrlHeld=keysHeld.ctrl,altHeld=keysHeld.alt,shiftHeld=keysHeld.shift}}elseif ca=="char"then expect.field(d0,"character","string")dc.frontmostProcess.eventQueue[#dc.frontmostProcess.eventQueue+1]={"char",{character=d0.character}}if not dc.isLocked then if dc.flags.cbreak then dc.buffer=dc.buffer..d0.character else dc.preBuffer=dc.preBuffer..d0.character end;if dc.flags.echo then terminal.write(dc,d0.character)terminal.redraw(dc)end end elseif ca=="paste"then expect.field(d0,"text","string")dc.frontmostProcess.eventQueue[#dc.frontmostProcess.eventQueue+1]={"paste",{text=d0.text}}if not dc.isLocked then if dc.flags.cbreak then dc.buffer=dc.buffer..d0.text else dc.preBuffer=dc.preBuffer..d0.text end;if dc.flags.echo then terminal.write(dc,d0.text)terminal.redraw(dc)end end elseif ca=="mouse_click"or ca=="mouse_up"or ca=="mouse_drag"then expect.field(d0,"x","number")expect.field(d0,"y","number")expect.field(d0,"button","number")dc.frontmostProcess.eventQueue[#dc.frontmostProcess.eventQueue+1]={ca,{x=d0.x,y=d0.y,button=d0.button,buttonMask=0}}elseif ca=="mouse_scroll"then expect.field(d0,"x","number")expect.field(d0,"y","number")expect.field(d0,"direction","number")dc.frontmostProcess.eventQueue[#dc.frontmostProcess.eventQueue+1]={ca,{x=d0.x,y=d0.y,button=d0.direction}}else error("Invalid event")end end;function syscalls.stdin(process,aq,bn)expect(1,bn,"number","table","string","nil")if process.stdin and process.stdin.isTTY and process.stdin.frontmostProcess==process then process.stdin.preBuffer=""end;if type(bn)=="number"then bn=TTY[bn]if bn and process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)bn.processList[#bn.processList+1]=bn.frontmostProcess;bn.frontmostProcess=process;if discord and process.stdin==currentTTY then discord("Phoenix","Executing "..process.name)end end;process.stdin=bn elseif type(bn)=="string"then local dJ=hardware.get(bn)if not dJ then error("bad argument #1 (no such device)",2)end;if not dJ.internalState.tty then error("bad argument #1 (no TTY available on device)",2)end;bn=dJ.internalState.tty;if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)bn.processList[#bn.processList+1]=bn.frontmostProcess;bn.frontmostProcess=process end;process.stdin=bn elseif bn==nil then if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)end;process.stdin=nil else if bn.isTTY then bn=terminal.userTTYs[bn]if not bn then error("bad argument #1 (invalid TTY)",2)end;if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)bn.processList[#bn.processList+1]=bn.frontmostProcess;bn.frontmostProcess=process;bn.preBuffer=""end else expect.field(bn,"read","function")local bm=bn.read;bn={buffer="",read=function(...)local bg,u=userModeCallback(process,bm,...)if bg then return u else error(u,2)end end}end;process.stdin=bn end end;function syscalls.stdout(process,aq,bn)expect(1,bn,"number","table","string","nil")if process.stdout and process.stdout.isTTY and process.stdout.frontmostProcess==process then if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.stdout.frontmostProcess.name)end end;if type(bn)=="number"then bn=TTY[bn]if bn and process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)bn.processList[#bn.processList+1]=bn.frontmostProcess;bn.frontmostProcess=process;if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.name)end end;process.stdout=bn elseif type(bn)=="string"then local dJ=hardware.get(bn)if not dJ then error("bad argument #1 (no such device)",2)end;if not dJ.internalState.tty then error("bad argument #1 (no TTY available on device)",2)end;bn=dJ.internalState.tty;if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)bn.processList[#bn.processList+1]=bn.frontmostProcess;bn.frontmostProcess=process;if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.name)end end;process.stdout=bn elseif bn==nil then if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.name)end end;process.stdout=nil else if bn.isTTY then bn=terminal.userTTYs[bn]if not bn then error("bad argument #1 (invalid TTY)",2)end;if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)bn.processList[#bn.processList+1]=bn.frontmostProcess;bn.frontmostProcess=process;if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.name)end end else expect.field(bn,"write","function")local dq=bn.write;bn={write=function(...)local bg,u=userModeCallback(process,dq,...)if bg then return u else error(u,2)end end}end;process.stdout=bn end end;function syscalls.stderr(process,aq,bn)expect(1,bn,"number","table","string","nil")if process.stderr and process.stderr.isTTY and process.stderr.frontmostProcess==process then end;if type(bn)=="number"then bn=TTY[bn]if bn and process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)bn.processList[#bn.processList+1]=bn.frontmostProcess;bn.frontmostProcess=process;if discord and process.stderr==currentTTY then discord("Phoenix","Executing "..process.name)end end;process.stderr=bn elseif type(bn)=="string"then local dJ=hardware.get(bn)if not dJ then error("bad argument #1 (no such device)",2)end;if not dJ.internalState.tty then error("bad argument #1 (no TTY available on device)",2)end;bn=dJ.internalState.tty;if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)bn.processList[#bn.processList+1]=bn.frontmostProcess;bn.frontmostProcess=process end;process.stderr=bn elseif bn==nil then if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)end;process.stderr=nil else if bn.isTTY then bn=terminal.userTTYs[bn]if not bn then error("bad argument #1 (invalid TTY)",2)end;if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)bn.processList[#bn.processList+1]=bn.frontmostProcess;bn.frontmostProcess=process end else expect.field(bn,"write","function")local dq=bn.write;bn={write=function(...)local bg,u=userModeCallback(process,dq,...)if bg then return u else error(u,2)end end}end;process.stderr=bn end end;function syscalls.istty(process,aq)return process.stdin and process.stdin.isTTY,process.stdout and process.stdout.isTTY end;function syscalls.termsize(process,aq)if not process.stdout or not process.stdout.isTTY then return nil,nil end;return process.stdout.size.width,process.stdout.size.height end;syslogs={default={stream={},tty=KERNEL.stdout,tty_level=args.loglevel,colorize=true}}local dK={[0]="Debug","Info","Notice","Warning","Error","Critical","Panic"}local dL={}for v=0,#dK do dL[dK[v]:lower()]=v end;local dM={[0]='\27[90m','\27[97m','\27[36m','\27[93m','\27[31m','\27[95m','\27[96m'}local function dN(y,am,v,aa)if v>=aa then return tostring(y[v])else return tostring(y[v])..am..dN(y,am,v+1,aa)end end;function syscalls.syslog(process,aq,bH,...)local args=table.pack(...)if type(bH)=="table"then expect.field(bH,"name","string","nil")expect.field(bH,"category","string","nil")expect.field(bH,"level","number","string","nil")expect.field(bH,"time","number","nil")expect.field(bH,"process","number","nil")expect.field(bH,"thread","number","nil")expect.field(bH,"module","string","nil")expect.field(bH,"traceback","boolean","nil")if type(bH.level)=="string"then bH.level=dL[bH.level:lower()]if not bH.level then error("bad field 'level' (invalid name)",0)end elseif bH.level and(bH.level<0 or bH.level>#dK)then error("bad field 'level' (level out of range)",0)end;bH.name=bH.name or"default"bH.process=bH.process or process.id;bH.thread=bH.thread or aq and aq.id;bH.level=bH.level or 1;bH.time=bH.time or os.epoch"utc"else local r=args.n;table.insert(args,1,bH)args.n=r+1;bH={process=process.id,thread=aq and aq.id,level=1,name="default",time=os.epoch"utc"}end;local dO=syslogs[bH.name]if dO==nil then error("No such log named "..bH.name,0)end;local ae;for v=1,args.n do ae=(v==1 and""or ae.." ")..serialize(args[v])end;if dO.file then dO.file.write(("[%s]%s %s[%d%s]%s [%s]: %s\n"):format(os.date("%b %d %X",bH.time/1000),bH.category and" <"..bH.category..">"or"",processes[bH.process]and processes[bH.process].name or"(unknown)",bH.process,bH.thread and":"..bH.thread or"",bH.module and" ("..bH.module..")"or"",dK[bH.level],dN(args," ",1,args.n)))dO.file.flush()end;if dO.stream then bH.message=ae;for z,i in pairs(dO.stream)do local bg=true;if i.filter then local m,dP,aD=""local v=1;local dQ,dR=false,false;while v<#i.filter do if dP==nil then m,v=i.filter:match("(%a+)%s*()",v)if bH[m]==nil then bg=false;break end;dP=""elseif aD==nil then local b5=i.filter:sub(v,v+1)if b5=="=="or b5=="!="or b5=="=%"or b5=="!%"or b5=="<="or b5==">="then dP=b5 elseif b5=="~="then dP="!="elseif b5=="~%"then dP="!%"elseif i.filter:sub(v,v)=='<'or i.filter:sub(v,v)=='>'then dP=i.filter:sub(v,v)else bg=false;break end;aD=""else local a9=i.filter:sub(v,v)if dQ then if a9==dQ and not dR then dQ,dR=false,false else aD=aD..a9;if not dR and a9=='\\'then dR=true else dR=false end end elseif a9=='"'or a9=="'"then dQ=a9 elseif a9=='|'or a9==';'then if dP=="=="and bH[m]==aD or dP=="!="and bH[m]~=aD or dP=="=%"and bH[m]:match(aD)or dP=="!%"and not bH[m]:match(aD)or dP=="<"and(tonumber(bH[m])or 0)<(tonumber(aD)or 0)or dP=="<="and(tonumber(bH[m])or 0)<=(tonumber(aD)or 0)or dP==">="and(tonumber(bH[m])or 0)>=(tonumber(aD)or 0)or dP==">"and(tonumber(bH[m])or 0)>(tonumber(aD)or 0)then if a9=='|'then v=i.filter:match("[^;]*;+()",v)if v==nil then break end;v=v-1 end;m,dP,aD=""dQ,dR=false,false else bg=a9=='|'aD=""if not bg then break end end elseif not(a9==' 'and aD=="")then aD=aD..a9 end;v=v+1 end end;if dQ then bg=false;break end end;if bg then local process=processes[i.pid]if process then process.eventQueue[#process.eventQueue+1]={"syslog",deepcopy(bH)}end end end end;if dO.tty and dO.tty_level<=bH.level then if dO.tty.isTTY then local a0=dN(args," ",1,args.n)if dO.colorize and bH.traceback then a0=a0:gsub("\t","  "):gsub("([^\n]+):(%d+):","\27[96m%1\27[37m:\27[95m%2\27[37m:"):gsub("'([^']+)'\n","\27[93m'%1'\27[37m\n")end;terminal.write(dO.tty,("%s[%s]%s %s[%d%s]%s [%s]: %s%s\n"):format(dO.colorize and dM[bH.level]or"",os.date("%b %d %X",bH.time/1000),bH.category and" <"..bH.category..">"or"",processes[bH.process]and processes[bH.process].name or"(unknown)",bH.process,bH.thread and":"..bH.thread or"",bH.module and" ("..bH.module..")"or"",dK[bH.level],a0,dO.colorize and"\27[0m"or""))terminal.redraw(dO.tty)else end end end;function syscalls.mklog(process,aq,m,dS,bb)expect(1,m,"string")expect(2,dS,"boolean","nil")expect(3,bb,"string","nil")if syslogs[m]then return end;syslogs[m]={}if bb then local o;syslogs[m].file,o=filesystem.open(process,bb,"a")if syslogs[m].file==nil then syslogs[m]=nil;return error("Could not open log file: "..o,0)end end;if dS then syslogs[m].stream={}end end;function syscalls.rmlog(process,aq,m)expect(1,m,"string")if m=="default"then error("Cannot delete default log",0)end;if not syslogs[m]then error("Log does not exist",0)end;if syslogs[m].stream then for z,i in pairs(syslogs[m].stream)do processes[i.pid].eventQueue[#processes[i.pid].eventQueue+1]={"syslog_close",{id=i.id}}processes[i.pid].dependents[i.id]=nil end end;syslogs[m]=nil end;function syscalls.openlog(process,aq,m,dT)expect(1,m,"string")expect(2,dT,"string","nil")if not syslogs[m]then error("Log does not exist",0)end;if not syslogs[m].stream then error("Log does not have streaming enabled",0)end;local aA=#process.dependents+1;local cY=process.id;process.dependents[aA]={type="log",name=m,filter=dT,gc=function()for v,i in pairs(syslogs[m].stream)do if i.id==aA and i.pid==cY then syslogs[m].stream[v]=nil end end end}syslogs[m].stream[#syslogs[m].stream+1]={pid=cY,id=aA,filter=dT}return aA end;function syscalls.closelog(process,aq,m)expect(1,m,"string","number")if type(m)=="string"then if not syslogs[m]then error("Log does not exist",0)end;if not syslogs[m].stream then error("Log does not have streaming enabled",0)end;for v,i in pairs(syslogs[m].stream)do if i.pid==process.id then process.dependents[i.id]=nil;syslogs[m].stream[v]=nil end end else if not process.dependents[m]then error("Log connection does not exist",0)end;local dO=syslogs[process.dependents[m].name].stream;for v,i in pairs(dO)do if i.pid==process.id and i.id==m then process.dependents[i.id]=nil;dO[v]=nil;break end end end end;function syscalls.logtty(process,aq,m,dc,b0)if process.user~="root"then error("Permission denied",0)end;expect(1,m,"string")expect(2,dc,"table","number","nil")expect(3,b0,"number","nil")if not syslogs[m]then error("Log does not exist",0)end;syslogs[m].tty=type(dc)=="table"and dc or TTY[dc]syslogs[m].tty_level=b0;return true end;function syslog.log(bH,...)return pcall(syscalls.syslog,KERNEL,nil,bH,...)end;function syslog.debug(...)return pcall(syscalls.syslog,KERNEL,nil,{level="debug",process=0},...)end;local dU=panic;function panic(ae)xpcall(function()TTY[1].isLocked=false;syslog.log({level="panic"},"Kernel panic:",ae)if debug then local ai=debug.traceback(nil,2)syslog.log({level="panic",traceback=true},ai)end;syslog.log({level="panic"},"We are hanging here...")terminal.redraw(TTY[1],true)term.setCursorBlink(false)mainThread=nil;while true do coroutine.yield()end end,function(A)dU(ae.."; and an error occurred while logging the error: "..A)end)end;xpcall(function()local o;syslogs.default.file,o=filesystem.open(KERNEL,"/var/log/default.log","a")shutdownHooks[#shutdownHooks+1]=function()if syslogs.default.file then syslogs.default.file.close()end end;syslog.log("Starting Phoenix version",PHOENIX_VERSION,PHOENIX_BUILD)syslog.log("Initialized system logger")syslog.log("System started at "..systemStartTime.." on computer "..os.computerID()..(os.computerLabel()and"('"..os.computerLabel().."')"or""))syslog.log("Computer host is ".._HOST)if syslogs.default.file==nil then syslog.log({level="notice"},"An error occurred while opening the log file at /var/log/default.log:",o,". System logs will not be saved to disk.")end end,panic)local function dV(bs)return string.match(bs,'^()%s*$')and''or string.match(bs,'^%s*(.*%S)')end;local expect,do_syscall=expect,do_syscall;local function dW(bj)local a7=1;local function bm(a9)if a7>#bj then return nil end;a9=a9 or 1;local bs=bj:sub(a7,a7+a9-1)a7=a7+a9;return bs end;if bm(8)~="!<arch>\n"then error("Not an ar archive",2)end;local a5={}local dX=nil;local dY={}while true do local bj={}local dZ=bm()while dZ=="\n"do dZ=bm()end;if dZ==nil then break end;local m=bm(15)if m==nil then break end;m=dZ..m;if string.find(m,"/")and string.find(m,"/")>1 then m=string.sub(m,1,string.find(m,"/")-1)else m=dV(m)end;bj.timestamp=tonumber(dV(bm(12)))bj.owner=tonumber(dV(bm(6)))bj.group=tonumber(dV(bm(6)))bj.mode=tonumber(dV(bm(8)),8)local S=tonumber(dV(bm(10)))if bm(2)~="`\n"then error("Invalid header for file "..m,2)end;if string.match(m,"^#1/%d+$")then m=bm(tonumber(string.match(m,"#1/(%d+)")))elseif string.match(m,"^/%d+$")then if dX then local r=tonumber(string.match(m,"/(%d+)"))m=dX:match("[^/]*",r+1)else table.insert(dY,m)end end;bj.name=m;bj.data=bm(S)if m=="//"then dX=bj.data elseif m~="/"and m~="/SYM64/"then table.insert(a5,bj)end end;if dX then for h,i in pairs(dY)do local r=tonumber(string.match(i,"/(%d+)"))for N,af in pairs(a5)do if af.name==i then af.name=dX:match("[^/]*",r+1)break end end end end;local d_={}for z,i in ipairs(a5)do d_[i.name]=i end;return d_ end;function createRequire(process,cK)local e0,e1={},{}cK.package={}local e2=processes[process.parent]and processes[process.parent].env;if e2 then cK.package.path=e2.package and e2.package.path;cK.package.libpath=e2.package and e2.package.libpath end;cK.package.path=cK.package.path or"/lib/?.lua;/lib/?/init.lua;/usr/lib/?.lua;/usr/lib/?/init.lua;./?.lua;./?/init.lua"if type(process.vars.PACKAGE_PATH)=="string"then cK.package.path=process.vars.PACKAGE_PATH..';'..cK.package.path end;cK.package.libpath=cK.package.libpath or"/lib/lib?.a;/usr/lib/lib?.a"if type(process.vars.PACKAGE_LIBPATH)=="string"then cK.package.libpath=process.vars.PACKAGE_LIBPATH..';'..cK.package.libpath end;cK.package.config="/\n;\n?\n!\n-"cK.package.loaded=e0;cK.package.preload=e1;cK.package.forceload=false;for h,i in pairs(cK)do if type(i)=="table"then e0[h]=i end end;local e3=setmetatable({},{__newindex=function()end,__metatable=false})local e4={}local function e5(m,bb)local a,o=do_syscall("open",bb,"rb")if not a then error(bb..": "..o,3)end;local bj=a.readAll()a.close()local g,o=load(bj,"@"..bb,nil,_ENV)if not g then error(bb..": "..o,3)end;local cb=bb:match("^(.*)/[^/]*$")or"/"e4[#e4+1]=function(e6)local bb,o=package.searchpath(e6,cb.."/?.lua;"..cb.."/?/init.lua")if not bb then return nil,o end;return e5,bb end;local bg,u=pcall(g,m)e4[#e4]=nil;if bg then return u else error(bb..": "..u,3)end end;local function e7(m,bb)local e8;if bb:find"%z"then bb,e8=bb:match"^([^%z]*)%z(.*)$"elseif m:find"%-"then e8=m:match("^([^%-]*)%-(.*)$")else e8="init"end;local a,o=do_syscall("open",bb,"rb")if not a then error(bb..": "..o,3)end;local bj=a.readAll()a.close()local cb=dW(bj)local function e9(m)local E=m..".lua"if not cb[E]then error(bb..":"..E..": File not found",0)end;local bj=cb[E].data;local g,o=load(bj,"@"..bb..":"..E,nil,_ENV)if not g then error(bb..":"..E..": "..o,3)end;local bg,u=pcall(g,m)if bg then return u else error(bb..":"..E..": "..u)end end;e4[#e4+1]=function(e6)return e9,e6 end;local u=e9(e8)e4[#e4]=nil;return u end;e4[1]=function(m)local cb=do_syscall("getname"):match("^(.*)/[^/]*$")or"/"local bb,o=package.searchpath(m,cb.."/?.lua;"..cb.."/?/init.lua")if not bb then return nil,o end;return e5,bb end;function cK.package.searchpath(m,bb,am,ea)expect(1,m,"string")expect(2,bb,"string")expect(3,am,"string","nil")expect(4,ea,"string","nil")am=(am or"."):gsub("([%^%$%(%)%%%.%[%]%*%+%-%?])","%%%1")ea=(ea or"/"):gsub("([%^%$%(%)%%%.%[%]%*%+%-%?])","%%%1")local eb=""for E in bb:gmatch"[^;]+"do local cd=E:gsub("%?",m:gsub(am,ea),nil)local a,o=do_syscall("open",cd,"r")if a then a.close()return cd else eb=eb.."\t"..cd..": "..o.."\n"end end;return nil,eb end;cK.package.searchers={function(m)local E=e1[m]if E then return E else return nil,"\tpackage.preload['"..m.."']: No such field\n"end end,function(m)local bb,o=package.searchpath(m,package.path)if not bb then return nil,o end;return e5,bb,bb end,function(m)local bb,o=package.searchpath(m:match("^[^%-]*"),package.libpath)if not bb then return nil,o end;local r=m:match("%-(.+)$")if r then return e7,bb,bb..":"..r else return e7,bb,bb..":init"end end,function(m)if not m:find"%."then return nil end;local bb,o=package.searchpath(m:match("^[^%.]*"),package.libpath)if not bb then return nil,o end;local r=m:match("^[^%.]*%.(.*)$")return e7,bb.."\0"..r,bb..":"..r end,function(m)if#e4>0 then return e4[#e4](m)end;return nil,"no local loaders found"end}setfenv(e5,cK)debug.protect(e5)setfenv(e7,cK)debug.protect(e7)setfenv(e4[1],cK)debug.protect(e4[1])for z,i in pairs(cK.package.searchers)do setfenv(i,cK)debug.protect(i)end;function cK.require(m)expect(1,m,"string")local o="module '"..m.."' not found:\n"local ec,ed,ee;for z,i in ipairs(package.searchers)do ec,ed,ee=i(m)if ec then break end;o=o..(ed or"")end;if not ec then error(o,2)end;if ee then if e0[ee]then if e0[ee]==e3 then error("loop detected loading '"..m.."'",3)elseif not package.forceload then return e0[ee]end end;e0[ee]=e3 else if e0[m]then if e0[m]==e3 then error("loop detected loading '"..m.."'",3)elseif not package.forceload then return e0[m]end end end;e0[m]=e3;local bg,u=pcall(ec,m,ed)if bg then if u~=nil then e0[m]=u elseif e0[m]==e3 then e0[m]=true end;if ee then if u~=nil then e0[ee]=u elseif e0[ee]==e3 then e0[ee]=true end end;return e0[m]else e0[m]=nil;if ee then e0[ee]=nil end;error(o.."\t"..u.."\n",2)end end;return cK end;do local e0,e1={},{}package={}package.path="/lib/?.lua;/lib/?/init.lua;/usr/lib/?.lua;/usr/lib/?/init.lua"package.libpath="/lib/lib?.a;/usr/lib/lib?.a"package.config="/\n;\n?\n!\n-"package.loaded=e0;package.preload=e1;package.forceload=false;for h,i in pairs(_G)do if type(i)=="table"then e0[h]=i end end;local e3=setmetatable({},{__newindex=function()end,__metatable=false})local e4={}local function e5(m,bb)local bI,o=filesystem.stat(KERNEL,bb)if not bI then error(bb..": "..o,3)end;if bI.owner~="root"or bI.worldPermissions.write then error(bb..": Insecure file permissions",3)end;for h,i in pairs(bI.permissions)do if h~="root"and i.write then error(bb..": Insecure file permissions",3)end end;local a,o=filesystem.open(KERNEL,bb,"rb")if not a then error(bb..": "..o,3)end;local bj=a.readAll()a.close()local g,o=load(bj,"@"..bb,nil,_G)if not g then error(bb..": "..o,3)end;local cb=bb:match("^(.*)/[^/]*$")or"/"e4[#e4+1]=function(e6)local bb,o=package.searchpath(e6,cb.."/?.lua;"..cb.."/?/init.lua")if not bb then return nil,o end;return e5,bb end;local bg,u=pcall(g,m)e4[#e4]=nil;if bg then return u else error(bb..": "..u,3)end end;local function e7(m,bb)local e8;if bb:find"%z"then bb,e8=bb:match"^([^%z]*)%z(.*)$"elseif m:find"%-"then e8=m:match("^([^%-]*)%-(.*)$")else e8="init"end;local bI,o=filesystem.stat(KERNEL,bb)if not bI then error(bb..": "..o,3)end;if bI.owner~="root"or bI.worldPermissions.write then error(bb..": Insecure file permissions",3)end;for h,i in pairs(bI.permissions)do if h~="root"and i.write then error(bb..": Insecure file permissions",3)end end;local a,o=filesystem.open(KERNEL,bb,"rb")if not a then error(bb..": "..o,3)end;local bj=a.readAll()a.close()local cb=dW(bj)local function e9(m)local E=m..".lua"if not cb[E]then error(bb..":"..E..": File not found",0)end;local bj=cb[E].data;local g,o=load(bj,"@"..bb..":"..E,nil,_ENV)if not g then error(bb..":"..E..": "..o,3)end;local bg,u=pcall(g,m)if bg then return u else error(bb..":"..E..": "..u)end end;e4[#e4+1]=function(e6)return e9,e6 end;local u=e9(e8)e4[#e4]=nil;return u end;function package.searchpath(m,bb,am,ea)expect(1,m,"string")expect(2,bb,"string")expect(3,am,"string","nil")expect(4,ea,"string","nil")am=(am or"."):gsub("([%^%$%(%)%%%.%[%]%*%+%-%?])","%%%1")ea=(ea or"/"):gsub("([%^%$%(%)%%%.%[%]%*%+%-%?])","%%%1")local eb=""for E in bb:gmatch"[^;]+"do local cd=E:gsub("%?",m:gsub(am,ea),nil)local a,o=filesystem.open(KERNEL,cd,"r")if a then a.close()return cd else eb=eb.."\t"..cd..": "..o.."\n"end end;return nil,eb end;package.searchers={function(m)local E=e1[m]if E then return E else return nil,"\tpackage.preload['"..m.."']: No such field\n"end end,function(m)local bb,o=package.searchpath(m,package.path)if not bb then return nil,o end;return e5,bb,bb end,function(m)local bb,o=package.searchpath(m:match("^[^%-]*"),package.libpath)if not bb then return nil,o end;local r=m:match("%-(.+)$")if r then return e7,bb,bb..":"..r else return e7,bb,bb..":init"end end,function(m)if not m:find"%."then return nil end;local bb,o=package.searchpath(m:match("^[^%.]*"),package.libpath)if not bb then return nil,o end;local r=m:match("^[^%.]*%.(.*)$")return e7,bb.."\0"..r,bb..":"..r end,function(m)if#e4>0 then return e4[#e4](m)end;return nil,"\tno local loaders found"end}function require(m)expect(1,m,"string")local o="module '"..m.."' not found:\n"local ec,ed,ee;for z,i in ipairs(package.searchers)do ec,ed,ee=i(m)if ec then break end;o=o..(ed or"")end;if not ec then error(o,2)end;if ee then if e0[ee]then if e0[ee]==e3 then error("loop detected loading '"..m.."'",3)elseif not package.forceload then return e0[ee]end end;e0[ee]=e3 else if e0[m]then if e0[m]==e3 then error("loop detected loading '"..m.."'",3)elseif not package.forceload then return e0[m]end end end;e0[m]=e3;local bg,u=pcall(ec,m,ed)if bg then if u~=nil then e0[m]=u elseif e0[m]==e3 then e0[m]=true end;if ee then if u~=nil then e0[ee]=u elseif e0[ee]==e3 then e0[ee]=true end end;return e0[m]else e0[m]=nil;if ee then e0[ee]=nil end;error(o.."\t"..u.."\n",2)end end end;timerMap={}alarmMap={}local ef={}function syscalls.kill(process,aq,cY,eg)expect(1,cY,"number")expect(2,eg,"number")local eh=processes[cY]if not eh then error("No such process",2)end;if process.user~="root"and process.user~=eh.user then error("Permission denied",2)end;if eg==9 then reap_process(eh)if processes[eh.parent]then syscalls.queueEvent(processes[eh.parent],nil,"process_complete",{id=cY,result=9})end;processes[cY]=nil elseif eh.signalHandlers[eg]then userModeCallback(eh,eh.signalHandlers[eg],eg)else syscalls.queueEvent(eh,nil,"signal",{signal=eg})end end;function killProcess(cY,eg)expect(1,cY,"number")expect(2,eg,"number")local eh=processes[cY]if not eh then return end;if eg==9 then reap_process(eh)if processes[eh.parent]then syscalls.queueEvent(processes[eh.parent],nil,"process_complete",{id=cY,result=9})end;processes[cY]=nil elseif eh.signalHandlers[eg]then syscalls.newthread(eh,nil,eh.signalHandlers[eg],eg)else syscalls.queueEvent(eh,nil,"signal",{signal=eg})end end;function syscalls.signal(process,aq,eg,ei)expect(1,eg,"number")expect(2,ei,"function","nil")process.signalHandlers[eg]=ei end;function syscalls.queueEvent(process,aq,m,av)expect(1,m,"string")expect(2,av,"table")process.eventQueue[#process.eventQueue+1]={m,av}end;function syscalls.sendEvent(process,aq,cY,m,av)expect(1,cY,"number")expect(2,m,"string")local eh=processes[cY]if not eh then return false end;eh.eventQueue[#eh.eventQueue+1]={"remote_event",{type=m,sender=process.id,data=av}}return true end;function syscalls.register(process,aq,m)expect(1,m,"string")if ef[m]then return false end;ef[m]=process.id;process.dependents[#process.dependents+1]={gc=function()ef[m]=nil end}return true end;function syscalls.lookup(process,aq,m)expect(1,m,"string")return ef[m]end;function syscalls.timer(process,aq,ej)expect(1,ej,"number")local ek=os.startTimer(ej)timerMap[ek]=process;return bit32.band(ek,0x7FFFFFFF)end;function syscalls.alarm(process,aq,ej)expect(1,ej,"number")local ek=os.setAlarm(ej)alarmMap[ek]=process;return bit32.bor(ek,0x80000000)end;function syscalls.cancel(process,aq,ek)expect(1,ek,"number")if bit32.btest(ek,0x80000000)then ek=bit32.band(ek,0x7FFFFFFF)if alarmMap[ek]~=process then error("No such alarm")end;os.cancelAlarm(ek)alarmMap[ek]=nil else if timerMap[ek]~=process then error("No such timer")end;os.cancelTimer(ek)timerMap[ek]=nil end end;eventHooks.terminate=eventHooks.terminate or{}eventHooks.terminate[#eventHooks.terminate+1]=function()if currentTTY.frontmostProcess then syscalls.kill(KERNEL,nil,currentTTY.frontmostProcess.id,2)terminal.write(currentTTY,"^T")end end;eventParameterMap={alarm={"id"},char={"character"},key={"keycode","isRepeat"},key_up={"keycode"},mouse_click={"button","x","y"},mouse_drag={"button","x","y"},mouse_up={"button","x","y"},mouse_scroll={"direction","x","y"},paste={"text"},redstone={},term_resize={},timer={"id"},turtle_inventory={}}do local el=0;for z,i in pairs(keys)do if type(i)=="number"then el=math.max(el,i)end end;local bu;local em,en=pcall(string.dump,function()end)if em then local eo=(function(p)if p<8 then return p end;local K=0;while p>=128 do p,K=bit32.rshift(p+0xf,4),K+4 end;while p>=16 do p,K=bit32.rshift(p+1,1),K+1 end;return bit32.bor((K+1)*8,p-8)end)(el)syslog.debug("Key table sizes:",el,eo)if _VERSION=="Lua 5.1"then bu=en:sub(1,12)..("I"..en:byte(9).."IIBBBBIIIIIIII"):pack(0,0,0,0,0,0,1,2,eo*0x800000+10,0x0100001E,0,0,0,0,0)elseif _VERSION=="Lua 5.2"then bu=en:sub(1,18)..("IIBBBIIIIIIIIII"):pack(0,0,0,0,1,2,eo*0x800000+11,0x0100001F,0,0,0,0,0,0,0)elseif _VERSION=="Lua 5.3"then bu=en:sub(1,17+("jn"):packsize())..("BBIIBBBIIIIIIIII"):pack(0,0,0,0,0,0,1,2,eo*0x800000+11,0x01000026,0,0,0,0,0,0)elseif _VERSION=="Lua 5.4"then bu=en:sub(1,15+("jn"):packsize())..("BBBBBBBBIIIBBBBBBB"):pack(0,0x80,0x80,0x80,0,0,1,0x83,0x00000013,el*0x80+82,0x00008048,0x80,0x80,0x80,0x80,0x80,0x80,0x80)end;if bu then local g,o=load(bu,nil,"b")if g then keymap=g()else syslog.debug("Could not load key table code:",o)end end end;if not keymap then keymap=load("return {"..("nil,"):rep(el).."}")()end;for v=0x61,0x7A do keymap[keys[string.char(v)]]=v end;for v=0x81,0x99 do if keys["f"..bit32.band(v,31)]then keymap[keys["f"..bit32.band(v,31)]]=v end end;for v=0xA0,0xA9 do keymap[keys["numPad"..bit32.band(v,15)]]=v end;keymap[keys.backspace]=0x08;keymap[keys.tab]=0x09;keymap[keys.enter or keys["return"]]=0x0A;keymap[keys.space]=0x20;keymap[keys.apostrophe]=0x27;keymap[keys.comma]=0x2C;keymap[keys.minus]=0x2D;keymap[keys.period]=0x2E;keymap[keys.slash]=0x2F;keymap[keys.zero]=0x30;keymap[keys.one]=0x31;keymap[keys.two]=0x32;keymap[keys.three]=0x33;keymap[keys.four]=0x34;keymap[keys.five]=0x35;keymap[keys.six]=0x36;keymap[keys.seven]=0x37;keymap[keys.eight]=0x38;keymap[keys.nine]=0x39;keymap[keys.semicolon or keys.semiColon]=0x3B;keymap[keys.equals]=0x3D;keymap[keys.leftBracket]=0x5B;keymap[keys.backslash]=0x5C;keymap[keys.rightBracket]=0x5D;keymap[keys.grave]=0x60;keymap[keys.delete]=0x7F;keymap[keys.insert]=0x80;if keys.convert then keymap[keys.convert]=0x9A end;if keys.noconvert then keymap[keys.noconvert]=0x9B end;if keys.kana then keymap[keys.kana]=0x9C end;if keys.kanji then keymap[keys.kanji]=0x9D end;if keys.yen then keymap[keys.yen]=0x9E end;keymap[keys.numPadDecimal]=0x9F;keymap[keys.numPadAdd]=0xAA;keymap[keys.numPadSubtract]=0xAB;if keys.numPadMultiply then keymap[keys.numPadMultiply]=0xAC end;keymap[keys.numPadDivide]=0xAD;keymap[keys.numPadEqual or keys.numPadEquals]=0xAE;keymap[keys.numPadEnter]=0xAF;keymap[keys.leftCtrl]=0xB0;keymap[keys.rightCtrl]=0xB1;keymap[keys.leftAlt]=0xB2;keymap[keys.rightAlt]=0xB3;keymap[keys.leftShift]=0xB4;keymap[keys.rightShift]=0xB5;if keys.leftSuper then keymap[keys.leftSuper]=0xB6 end;if keys.rightSuper then keymap[keys.rightSuper]=0xB7 end;keymap[keys.capsLock]=0xB8;keymap[keys.numLock]=0xB9;keymap[keys.scrollLock or keys.scollLock]=0xBA;if keys.printScreen then keymap[keys.printScreen]=0xBB end;keymap[keys.pause]=0xBC;if keys.menu then keymap[keys.menu]=0xBD end;if keys.stop then keymap[keys.stop]=0xBE end;if keys.ax then keymap[keys.ax]=0xBF end;keymap[keys.up]=0xC0;keymap[keys.down]=0xC1;keymap[keys.left]=0xC2;keymap[keys.right]=0xC3;keymap[keys.pageUp]=0xC4;keymap[keys.pageDown]=0xC5;keymap[keys.home]=0xC6;keymap[keys["end"]]=0xC7;if keys.circumflex or keys.cimcumflex then keymap[keys.circumflex or keys.cimcumflex]=0xC8 end;if keys.at then keymap[keys.at]=0xC9 end;if keys.colon then keymap[keys.colon]=0xCA end;if keys.underscore then keymap[keys.underscore]=0xCB end end;local ep={id=0,name="",coro=coroutine.create(function()end),status="starting",args={"a",n=1},filter=function(process,aq,ca)end}local eq={id=1,name="init",user="root",dependents={{gc=function()end}},parent=0,dir="/",stdin=TTY[1],stdout={},stderr=TTY[1],cputime=0.2,systime=0.1,env={},syscallyield=nil,eventQueue={},signalHandlers={},paused=false,nice=0,threads={[0]=ep}}local er=1;local function es(process)local e=createLuaLib(process)if _VERSION<"Lua 5.2"then e=make_ENV(e)end;e._G=e;return e end;local function et()coroutine.yield("preempt","test",7)end;local eu={load}function addProcessLoader(ec)table.insert(eu,1,ec)end;function removeProcessLoader(ec)for v,i in ipairs(eu)do if i==ec then table.remove(eu,v)return end end end;function reap_process(process)syslog.debug("Reaping process "..process.id.." ("..process.name..")")for z,i in ipairs(process.dependents)do i:gc()end;if process.stdin and process.stdin.isTTY then if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)process.stdin.preBuffer=""if discord and process.stdout==currentTTY and process.stdout.frontmostProcess then discord("Phoenix","Executing "..process.stdout.frontmostProcess.name)end else for v,i in ipairs(process.stdin.processList)do if i==process then table.remove(process.stdin.processList,v)break end end end end;if process.stdout and process.stdout.isTTY then if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)else for v,i in ipairs(process.stdout.processList)do if i==process then table.remove(process.stdout.processList,v)break end end end end;if process.stderr and process.stderr.isTTY then if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)else for v,i in ipairs(process.stderr.processList)do if i==process then table.remove(process.stderr.processList,v)break end end end end end;function syscalls.getpid(process,aq)return process.id end;function syscalls.getppid(process,aq)return process.parent end;function syscalls.clock(process,aq)return process.cputime end;function syscalls.getenv(process,aq)return process.vars end;function syscalls.getfenv(process,aq)return process.env end;function syscalls.getname(process,aq)return process.name end;function syscalls.getcwd(process,aq)return process.dir end;function syscalls.chdir(process,aq,cb)expect(1,cb,"string")local bI=filesystem.stat(process,cb)if not bI or bI.type~="directory"then return false,"No such file or directory"elseif not(bI.permissions[process.user]or bI.worldPermissions).execute then return false,"Permission denied"end;process.dir=cb:gsub("^([^/])","/"..process.dir.."/%1")return true end;function syscalls.getuser(process,aq)return process.user,process.realuser end;function syscalls.setuser(process,aq,user)expect(1,user,"string")if process.user~="root"then error("Permission denied")end;process.user=user;process.realuser=nil end;local function ev(cK)return{["nil"]={},["boolean"]={__unm=function()end},["number"]={},["string"]={__index=cK.string},["function"]={},["thread"]={__index=cK.coroutine,__call=cK.coroutine.resume},["userdata"]={}}end;function syscalls.fork(process,aq,az,m,...)expect(1,az,"function")expect(2,m,"string","nil")local aA=er;er=er+1;processes[aA]={id=aA,name=m or process.name,user=process.user,dependents={},parent=process.id,dir=process.dir,root=process.root,stdin=process.stdin,stdout=process.stdout,stderr=process.stderr,vars=deepcopy(process.vars),cputime=0,systime=0,syscallyield=nil,eventQueue={},signalHandlers={[1]=function()return coroutine.yield("syscall","exit",1)end,[2]=function()return coroutine.yield("syscall","exit",1)end,[3]=function()coroutine.yield("syscall","syslog",{level="error",category="Application Error",traceback=true},debug.traceback("Quit"))return coroutine.yield("syscall","exit",1)end,[6]=function(o)coroutine.yield("syscall","syslog",{level="error",category="Application Error",traceback=true},debug.traceback(o or"Aborted"))return coroutine.yield("syscall","exit",1)end,[13]=function()return coroutine.yield("syscall","exit",1)end,[15]=function()return coroutine.yield("syscall","exit",1)end,[19]=function()return coroutine.yield("syscall","suspend")end,[21]=function()return coroutine.yield("syscall","suspend")end,[22]=function()return coroutine.yield("syscall","suspend")end},paused=false,nice=0,threads={[0]={id=0,name="<main thread>",coro=coroutine.create(az),syscall=coroutine.create(function(...)local args=table.pack(...)while true do args=table.pack(coroutine.yield(kSyscallComplete,xpcall(syscalls[args[1]],debug.traceback,table.unpack(args,2,args.n))))end end),status="starting",args=table.pack(...),filter=nil}}}processes[aA].env=es(processes[aA])processes[aA].globalMetatables=ev(processes[aA].env)setfenv(az,processes[aA].env)if process.stdin and process.stdin.isTTY and not process.stdin.isLocked then process.stdin.processList[#process.stdin.processList+1]=process.stdin.frontmostProcess;process.stdin.frontmostProcess=processes[aA]process.stdin.preBuffer=""if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.name)end end;if process.stdout and process.stdout.isTTY and not process.stdout.isLocked and process.stdout.frontmostProcess~=processes[aA]then process.stdout.processList[#process.stdout.processList+1]=process.stdout.frontmostProcess;process.stdout.frontmostProcess=processes[aA]end;if process.stderr and process.stderr.isTTY and not process.stderr.isLocked and process.stderr.frontmostProcess~=processes[aA]then process.stderr.processList[#process.stderr.processList+1]=process.stderr.frontmostProcess;process.stderr.frontmostProcess=processes[aA]end;if args.preemptive then debug.sethook(processes[aA].threads[0].coro,et,"",args.quantum)end;return aA end;function syscalls.exec(process,aq,bb,...)expect(1,bb,"string")local a,o=filesystem.open(process,bb,"r")if not a then bb=bb..".lua"a,o=filesystem.open(process,bb,"r")if not a then error("Could not open file: "..o,0)end end;local ew=a.readAll()a.close()if ew:find("[%z\1-\31]")then a,o=filesystem.open(process,bb,"rb")if not a then error("Could not open file: "..o,0)end;ew=a.readAll()a.close()end;local bI=filesystem.stat(process,bb)if not(bI.permissions[bI.owner]or bI.worldPermissions).execute then error("Could not execute file: Permission denied",0)end;if bI.setuser then process.realuser,process.user=process.user,bI.owner end;if ew:sub(1,2)=="#!"then local ex=ew:sub(3,ew:find("\n")-1)local args,v={},0;for bs in ex:gmatch"%S+"do args[v]=bs;v=v+1 end;args[v],v=bb,v+1;for z,i in ipairs{...}do args[v]=i;v=v+1 end;if args[0]==bb then error("Recursive path detected while resolving shebang",0)end;syscalls.exec(process,aq,args[0],table.unpack(args,1,v))process.name="/"..fs.combine(bb:sub(1,1)=="/"and""or process.dir,bb)else local az,o;for z,ec in ipairs(eu)do az,o=ec(ew,"@"..bb,"bt",process.env)if az then break end end;if not az then error("Could not execute file: "..o,0)end;process.name="/"..fs.combine(bb:sub(1,1)=="/"and""or process.dir,bb)process.threads={[0]={id=0,name="<main thread>",coro=coroutine.create(az),syscall=coroutine.create(function(...)local args=table.pack(...)while true do args=table.pack(coroutine.yield(kSyscallComplete,xpcall(syscalls[args[1]],debug.traceback,table.unpack(args,2,args.n))))end end),status="starting",args=table.pack(...),filter=nil}}if args.preemptive then debug.sethook(process.threads[0].coro,et,"",args.quantum*10^(process.nice/-10))end end;if discord and process.stdin and process.stdin.isTTY and process.stdin.frontmostProcess==process then discord("Phoenix","Executing "..process.name)end end;function syscalls.newthread(process,aq,az,...)expect(1,az,"function")local aA=#process.threads+1;process.threads[aA]={id=aA,name="<thread:"..aA..">",coro=coroutine.create(az),syscall=coroutine.create(function(...)local args=table.pack(...)while true do args=table.pack(coroutine.yield(kSyscallComplete,xpcall(syscalls[args[1]],debug.traceback,table.unpack(args,2,args.n))))end end),status="starting",args=table.pack(...),filter=nil}setfenv(az,process.env)if args.preemptive then debug.sethook(process.threads[aA].coro,et,"",args.quantum*10^(process.nice/-10))end;return aA end;function syscalls.exit(process,aq,bu)process.lastReturnValue={pid=process.id,thread=aq.id,value=bu,n=1,bu}for z,aq in pairs(process.threads)do aq.status="dead"aq.return_value=bu end end;function syscalls.atexit(process,aq,g)expect(1,g,"function")process.dependents[#process.dependents+1]={gc=function()local aA=syscalls.newthread(process,nil,g)local v=0;while process.threads[aA]and process.threads[aA].coro:status()=="suspended"and v<100 do executeThread(process,process.threads[aA],{n=0},false,false)v=v+1 end end}end;function syscalls.getplist(process,aq)local ey={}for h in pairs(processes)do ey[#ey+1]=h end;table.sort(ey)return ey end;function syscalls.getpinfo(process,aq,cY)expect(1,cY,"number")local E=processes[cY]if not E then return nil,"No such process"end;local ez,eA,eB;for v,i in ipairs(TTY)do if E.stdin==i then ez=v end;if E.stdout==i then eA=v end;if E.stderr==i then eB=v end end;local eC={}if E.threads then for v,i in pairs(E.threads)do eC[v]={id=i.id,name=i.name,status=i.status}end end;return{id=E.id,name=E.name,user=E.user,realuser=E.realuser,parent=E.parent,dir=E.dir,stdin=ez,stdout=eA,stderr=eB,cputime=E.cputime or 0,systime=E.systime or 0,threads=eC}end;function syscalls.suspend(process,aq)process.paused=true end;function syscalls.nice(process,aq,b0,cY)expect(1,b0,"number")expect.range(b0,-20,20)expect(2,cY,"number","nil")if b0<0 and process.user~="root"then error("Permission denied",0)end;local eh=cY and assert(processes[cY],"Invalid process ID")or process;if eh.user~=process.user and process.user~="root"then error("Permission denied",0)end;eh.nice=b0;if args.preemptive then for z,y in pairs(eh.threads)do debug.sethook(y.coro,et,"",args.quantum*10^(b0/-10))end end end;local function eD(a0)a0=a0 .."\x80"..("\0"):rep(-(#a0+9)%64)..(">I8"):pack(#a0)local eE,eF,eG,eH,eI,af=0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476,0xC3D2E1F0,{}for eJ=1,#a0,64 do local eK=eJ;for v=0,15 do af[v]=a0:byte(eK)*0x1000000+a0:byte(eK+1)*0x10000+a0:byte(eK+2)*0x100+a0:byte(eK+3)eK=eK+4 end;for v=16,79 do af[v]=bit32.lrotate(bit32.bxor(af[v-3],af[v-8],af[v-14],af[v-16]),1)end;local cv,ab,a9,bq,K=eE,eF,eG,eH,eI;for v=0,79 do local f,h;if v<=19 then f,h=bit32.bxor(bq,bit32.band(ab,bit32.bxor(a9,bq))),0x5A827999 elseif v<=39 then f,h=bit32.bxor(ab,a9,bq),0x6ED9EBA1 elseif v<=59 then f,h=bit32.bor(bit32.band(ab,bit32.bor(a9,bq)),bit32.band(a9,bq)),0x8F1BBCDC else f,h=bit32.bxor(ab,a9,bq),0xCA62C1D6 end;local eL=bit32.band(bit32.lrotate(cv,5)+f+K+h+af[v],0xFFFFFFFF)K,bq,a9,ab,cv=bq,a9,bit32.lrotate(ab,30),cv,eL end;eE=bit32.band(eE+cv,0xFFFFFFFF)eF=bit32.band(eF+ab,0xFFFFFFFF)eG=bit32.band(eG+a9,0xFFFFFFFF)eH=bit32.band(eH+bq,0xFFFFFFFF)eI=bit32.band(eI+K,0xFFFFFFFF)end;return{eE,eF,eG,eH,eI}end;local function eM(eN,m)local eO=eD(eN:gsub("%X",""):gsub("%x%x",function(bs)return string.char(tonumber(bs,16))end)..m)local cv,ab,a9,bq=eO[1],bit32.bor(bit32.band(eO[2],0xFFFF0FFF),0x5000),bit32.bor(bit32.band(eO[3],0x3FFFFFFF),0x80000000),eO[4]return("%08x-%04x-%04x-%04x-%04x%08x"):format(cv,bit32.rshift(ab,16),bit32.band(ab,0xFFFF),bit32.rshift(a9,16),bit32.band(a9,0xFFFF),bq)end;local eP="a6f53b7d-50f3-4e51-adef-8728c83e3f3a"deviceTreeRoot={id=tostring(os.getComputerID()),uuid=eM(eP,tostring(os.getComputerID())),parent=nil,displayName=os.getComputerLabel()or"",drivers={},metadata={},internalState={},children={},listeners=setmetatable({},{__mode="k"})}local eQ={[deviceTreeRoot.uuid]=deviceTreeRoot}local eR={}function hardware.get(bb)expect(1,bb,"string")if bb:find("^%x+%-%x+%-%x+%-%x+%-%x+$")then return eQ[bb]elseif bb==""or bb:find("/")then local dJ=deviceTreeRoot;for m in bb:gmatch"[^/]+"do dJ=dJ.children[m]if dJ==nil then break end end;return dJ else local eS={}local function eT(dJ)if dJ.id==bb or dJ.alias==bb then eS[#eS+1]=dJ end;for z,i in pairs(dJ.children)do eT(i)end end;eT(deviceTreeRoot)return table.unpack(eS)end end;function hardware.find(type)expect(1,type,"string")local eU={}local function eV(dJ)for z,i in ipairs(dJ.drivers)do if i.type==type then eU[#eU+1]=dJ;break end end;for z,i in pairs(dJ.children)do eV(i)end end;eV(deviceTreeRoot)return table.unpack(eU)end;function hardware.path(dJ)expect(1,dJ,"table")expect.field(dJ,"uuid","string")if not eQ[dJ.uuid]then error("bad argument #1 (invalid node)",2)end;local bb=dJ.id;dJ=dJ.parent;while dJ do bb=dJ.id.."/"..bb;dJ=dJ.parent end;bb=bb:gsub("^[^/]+","")return bb==""and"/"or bb end;function hardware.add(c0,m)expect(1,c0,"table")expect(2,m,"string")expect.field(c0,"uuid","string")if not eQ[c0.uuid]then return nil,"Invalid parent node"end;if c0.children[m]then return nil,"Node already exists"end;local dJ={id=m,uuid=eM(c0.uuid,m),parent=c0,displayName="",drivers={},metadata={},internalState={},children={},listeners=setmetatable({},{__mode="k"})}c0.children[m]=dJ;eQ[dJ.uuid]=dJ;syslog.log({module="Hardware"},"Added new device at "..hardware.path(dJ))for z,i in ipairs(eR)do if(not i.parent or i.parent==c0)and(not i.pattern or m:match(i.pattern))then i.callback(dJ)end end;return dJ end;function hardware.remove(dJ)expect(1,dJ,"table")expect.field(dJ,"uuid","string")if not eQ[dJ.uuid]then return false,"Invalid node"end;if dJ==deviceTreeRoot or not dJ.parent then return false,"Cannot remove root node"end;for v=#dJ.drivers,1,-1 do hardware.deregister(dJ,dJ.drivers[v])end;for z,i in pairs(dJ.children)do hardware.remove(i)end;syslog.log({module="Hardware"},"Device at "..hardware.path(dJ).." has been removed")dJ.parent.children[dJ.id]=nil;eQ[dJ.uuid]=nil;dJ.parent=nil;return true end;function hardware.register(dJ,eW)expect(1,dJ,"table")expect(2,eW,"table")expect.field(dJ,"uuid","string")expect.field(eW,"name","string")expect.field(eW,"type","string")expect.field(eW,"properties","table")expect.field(eW,"methods","table")expect.field(eW,"init","function","nil")expect.field(eW,"deinit","function","nil")for h in pairs(eW.methods)do if type(h)~="string"then error("bad method name '"..tostring(h).."' (not a string)",2)end;expect.field(eW.methods,h,"function")end;for z,i in ipairs(eW.properties)do if type(i)~="string"then error("bad property name '"..tostring(i).."' (not a string)",2)end;if not eW.methods["get"..i:sub(1,1):upper()..i:sub(2)]then error("bad property '"..i.."' (no getter present)",2)end end;if not eQ[dJ.uuid]then error("bad argument #1 (invalid node)",2)end;for z,i in ipairs(dJ.drivers)do if i==eW then return false end end;dJ.drivers[#dJ.drivers+1]=eW;syslog.log({module="Hardware"},"Registered device with type "..eW.type.." on device "..hardware.path(dJ).." using driver "..eW.name)if eW.init then eW.init(dJ)end;return true end;function hardware.register_callback(eW)return function(dJ)return hardware.register(dJ,eW)end end;function hardware.deregister(dJ,eW)expect(1,dJ,"table")expect(2,eW,"table")expect.field(dJ,"uuid","string")if not eQ[dJ.uuid]then error("bad argument #1 (invalid node)",2)end;for v,i in ipairs(dJ.drivers)do if i==eW then if eW.deinit then eW.deinit(dJ)end;table.remove(dJ.drivers,v)syslog.log({module="Hardware"},"Driver "..eW.name.." has been deregistered from device "..hardware.path(dJ))return true end end;return false end;function hardware.listen(eX,c0,eY)expect(1,eX,"function")expect(2,c0,"table","nil")expect(3,eY,"string","nil")if c0 then expect.field(c0,"uuid","string")end;if eY and not pcall(string.match,"",eY)then error("bad argument #3 (invalid pattern)",2)end;eR[#eR+1]={callback=eX,parent=c0,pattern=eY}end;function hardware.unlisten(eX)expect(1,eX,"function")local v=1;while v<#eR do if eR[v].callback==eX then table.remove(eR,v)else v=v+1 end end end;function hardware.broadcast(dJ,ca,d0)expect(1,dJ,"table")expect(2,ca,"string")expect(3,d0,"table")expect.field(dJ,"uuid","string")if not eQ[dJ.uuid]then error("bad argument #1 (invalid node)",2)end;for i in pairs(dJ.listeners)do i.eventQueue[#i.eventQueue+1]={ca,d0}end end;function hardware.call(process,dJ,eZ,...)for z,eW in ipairs(dJ.drivers)do if eW.methods[eZ]then return eW.methods[eZ](dJ,process,...)end end;error("No such method",2)end;function syscalls.devlookup(process,aq,m)expect(1,m,"string")local e_={hardware.get(m)}for h,i in ipairs(e_)do e_[h]=hardware.path(i)end;return table.unpack(e_)end;function syscalls.devfind(process,aq,type)expect(1,type,"string")local e_={hardware.find(type)}for h,i in ipairs(e_)do e_[h]=hardware.path(i)end;return table.unpack(e_)end;function syscalls.devinfo(process,aq,f0)expect(1,f0,"string")local dJ=hardware.get(f0)if not dJ then return nil end;local f1={}for z,i in ipairs(dJ.drivers)do f1[i.type]=i.name end;return{id=dJ.id,uuid=dJ.uuid,alias=dJ.alias,parent=dJ.parent and hardware.path(dJ.parent)or"/",displayName=dJ.displayName,types=f1,metadata=deepcopy(dJ.metadata)}end;function syscalls.devalias(process,aq,f0,f2)expect(1,f0,"string")expect(2,f2,"string","nil")local dJ=hardware.get(f0)if not dJ then error("No such device",2)end;dJ.alias=f2 end;function syscalls.devmethods(process,aq,f0)expect(1,f0,"string")local dJ=hardware.get(f0)if not dJ then error("No such device",2)end;local f3={}for z,i in ipairs(dJ.drivers)do for h in pairs(i.methods)do f3[#f3+1]=h end end;return f3 end;function syscalls.devproperties(process,aq,f0)expect(1,f0,"string")local dJ=hardware.get(f0)if not dJ then error("No such device",2)end;local f4={}for z,i in ipairs(dJ.drivers)do for z,h in pairs(i.properties)do f4[#f4+1]=h end end;return f4 end;function syscalls.devchildren(process,aq,f0)expect(1,f0,"string")local dJ=hardware.get(f0)if not dJ then error("No such device",2)end;local f5={}for h in pairs(dJ.children)do f5[#f5+1]=h end;return f5 end;function syscalls.devcall(process,aq,f0,eZ,...)expect(1,f0,"string")expect(2,eZ,"string")local dJ=hardware.get(f0)if not dJ then error("No such device",2)end;if dJ.process and dJ.process~=process.id then error("Device is locked",2)end;return hardware.call(process,dJ,eZ,...)end;function syscalls.devlisten(process,aq,f0,dn)expect(1,f0,"string")expect(2,dn,"boolean","nil")if dn==nil then dn=true end;local dJ=hardware.get(f0)if not dJ then error("No such device",2)end;if dn then for z,i in ipairs(dJ.listeners)do if i==process then return end end;dJ.listeners[process]=true;process.dependents[#process.dependents+1]={type="hardware listen",node=dJ,gc=function()dJ.listeners[process]=nil end}else dJ.listeners[process]=nil;for v,i in ipairs(process.dependents)do if i.type=="hardware listen"and i.node==dJ then table.remove(process.dependents,v)break end end end end;function syscalls.devlock(process,aq,f0,f6)expect(1,f0,"string")expect(2,f6,"boolean","nil")if f6==nil then f6=true end;local dJ=hardware.get(f0)if not dJ then error("No such device",2)end;if dJ.process==nil then dJ.process=process.id;process.dependents[#process.dependents+1]={type="hardware lock",node=dJ,gc=function()dJ.process=nil end}return true elseif dJ.process==process.id then return true elseif f6 then aq.filter=function(process,aq)return dJ.process==nil or dJ.process==process.id end;return kSyscallYield,"devlock",f0,true else return false end end;function syscalls.devunlock(process,aq,f0)expect(1,f0,"string")local dJ=hardware.get(f0)if not dJ then error("No such device",2)end;if dJ.process and dJ.process~=process.id then error("Device is locked",2)end;dJ.process=nil;for v,i in ipairs(process.dependents)do if i.type=="hardware lock"and i.node==dJ then table.remove(process.dependents,v)break end end end;function syscalls.version(process,aq,f7)if f7 then return PHOENIX_BUILD else return PHOENIX_VERSION end end;function syscalls.cchost(process,aq)return _HOST end;function syscalls.uptime(process,aq)return(os.epoch"utc"-systemStartTime)/1000 end;function syscalls.attach(process,aq,f8,_type,...)if process.user~="root"then error("Permission denied")end;expect(1,f8,"string","number")expect(2,_type,"string")local bg,o;if periphemu then bg=periphemu.create(f8,_type,...)elseif ccemux then if type(f8)=="number"then f8=_type.."_"..f8 end;if _type=="drive"then _type="disk_drive"elseif _type=="modem"then _type="wireless_modem"end;if _type=="computer"then local aA=tonumber(f8:match("%d+"))if aA then bg,o=pcall(ccemux.openEmu,aA)else bg,o=false,"Invalid side"end else bg,o=pcall(ccemux.attach,f8,_type,...)end else bg,o=false,"Operation not supported"end;return bg,o end;function syscalls.detach(process,aq,f8)if process.user~="root"then error("Permission denied")end;expect(1,f8,"string","number")local bg,o;if periphemu then bg=periphemu.remove(f8)elseif ccemux then if type(f8)=="number"then f8=_type.."_"..f8 end;bg,o=pcall(ccemux.detach,f8)else bg,o=false,"Operation not supported"end;return bg,o end;function syscalls.kernargs(process,aq)return deepcopy(args)end;local f9=0;function syscalls.lockmutex(process,aq,fa)expect(1,fa,"table")while fa.owner~=nil and fa.owner~=aq.id or fa.pid~=nil and fa.pid~=process.id do coroutine.yield()end;if fa.owner then if type(fa.recursive)=="number"then fa.recursive=fa.recursive+1;return else error("cannot recursively lock mutex",0)end end;fa.owner=aq.id;fa.pid=process.id;if fa.recursive then fa.recursive=1 end end;function syscalls.__timeout_check(process,aq,b3)if b3.timeout then return false end;return syscalls[b3.call](process,aq,b3.object,0)end;function syscalls.timelockmutex(process,aq,fa,ej)expect(1,fa,"table")expect(2,ej,"number")if fa.owner then if fa.owner~=aq.id then local fb=os.startTimer(ej)local b3={object=fa,timeout=false,call="timelockmutex"}aq.filter=function(process,aq,ar)if ar[1]=="timer"and ar[2].id==fb then b3.timeout=true;return true end;return fa.owner==nil or fa.owner==aq.id end;return kSyscallYield,"__timeout_check",b3 elseif type(fa.recursive)=="number"then fa.recursive=fa.recursive+1 else error("cannot recursively lock mutex",0)end else fa.owner=aq.id;if fa.recursive then fa.recursive=1 end end;return true end;function syscalls.unlockmutex(process,aq,fa)expect(1,fa,"table")if fa.owner==aq.id and fa.pid==process.id then if type(fa.recursive)=="number"then fa.recursive=fa.recursive-1;if fa.recursive<=0 then fa.owner=nil end else fa.owner,fa.pid=nil end elseif fa.owner==nil then error("mutex already unlocked",0)else error("mutex not locked by current thread")end end;function syscalls.trylockmutex(process,aq,fa)expect(1,fa,"table")if fa.owner then if fa.owner~=aq.id or fa.pid~=process.id then return false elseif type(fa.recursive)=="number"then fa.recursive=fa.recursive+1;return true else error("cannot recursively lock mutex",0)end else fa.owner=aq.id;fa.pid=process.id;if fa.recursive then fa.recursive=1 end;return true end end;function syscalls.acquiresemaphore(process,aq,fc)expect(1,fc,"table")expect.field(fc,"count","number")while fc.count<=0 do coroutine.yield()end;fc.count=fc.count-1 end;function syscalls.timeacquiresemaphore(process,aq,fc,ej)expect(1,fc,"table")expect.field(fc,"count","number")expect(2,ej,"number")if fc.count<=0 then local fb=os.startTimer(ej)local b3={object=fc,timeout=false,call="timeacquiresemaphore"}aq.filter=function(process,aq,ar)if ar[1]=="timer"and ar[2].id==fb then b3.timeout=true;return true end;return type(fc.count)~="number"or fc.count>0 end;return kSyscallYield,"__timeout_check",b3 end;fc.count=fc.count-1;return true end;function syscalls.releasesemaphore(process,aq,fc)expect(1,fc,"table")expect.field(fc,"count","number")fc.count=fc.count+1 end;local fd={name="root",type="computer",properties={"label","id"},methods={getLabel=function()end,setLabel=function(fe)end,getId=function()end,shutdown=function()end,reboot=function()end},init=function(dJ)end,deinit=function(dJ)end}local ff={top=true,bottom=true,left=true,right=true,front=true,back=true}local fg={}function getNodeById(m)if ff[m]then if deviceTreeRoot.children[m]then return deviceTreeRoot.children[m]end else for h in pairs(ff)do if peripheral.getType(h)=="modem"and not peripheral.call(h,"isWireless")and deviceTreeRoot.children[h]and deviceTreeRoot.children[h].children[m]then return deviceTreeRoot.children[h].children[m]end end end end;local function fh(self)self.internalState.peripheral=self.internalState.peripheral or{}if not self.internalState.peripheral.call then self.internalState.peripheral.call=peripheral.call end;if self.internalState.peripheral.call==peripheral.call or not self.parent then self.internalState.peripheral.getMethods=peripheral.getMethods else self.internalState.peripheral.getMethods=function(aA)return peripheral.call(self.parent.id,"getMethodsRemote",aA)end end end;local function fi(process,aB)aB.__metatable={}for z,i in pairs(aB)do setfenv(i,process.env)debug.protect(i)end;return setmetatable({},aB)end;local function fj(eW,type)return function(dJ)local f1,g;if dJ.parent==deviceTreeRoot then f1,g={peripheral.getType(dJ.id)},peripheral.call else f1,g={peripheral.call(dJ.parent.id,"getTypeRemote",dJ.id)},function(...)return peripheral.call(dJ.parent.id,"callRemote",...)end end;for z,i in ipairs(f1)do if i==type then dJ.internalState.peripheral={call=g}return hardware.register(dJ,eW)end end end end;local function fk(type)return hardware.listen(fj(fg["peripheral_"..type],type),deviceTreeRoot)end;local function fl(eZ)return function(self)return self.internalState.peripheral.call(self.id,eZ)end end;local function fm(eZ)return function(self,process)if process.user~="root"then error("Permission denied",0)end;return self.internalState.peripheral.call(self.id,eZ)end end;local function fn(eZ)return function(...)local f1={...}return function(self,process,aF)expect(1,aF,table.unpack(f1))return self.internalState.peripheral.call(self.id,eZ,aF)end end end;local function fo(eZ)return function(...)local f1={...}return function(self,process,aF)expect(1,aF,table.unpack(f1))if process.user~="root"then error("Permission denied",0)end;return self.internalState.peripheral.call(self.id,eZ,aF)end end end;local function fp()syslog.log("Sending SIGTERM to all processes")local fq=false;for cY,process in pairs(processes)do if cY~=0 then killProcess(cY,15)local fr,ar=false,nil;local as=true;for ft,aq in pairs(process.threads)do if not fr and aq.status=="suspended"then ar=table.remove(process.eventQueue,1)fr=true end;if ar or aq.status~="suspended"then as=executeThread(process,aq,ar or{n=0},as,true)else as=false end end;if as then process.isDead=true;if process.parent~=0 and processes[process.parent]then processes[process.parent].eventQueue[#processes[process.parent].eventQueue+1]={"process_complete",process.lastReturnValue}end;reap_process(process)processes[cY]=nil else fq=true end end end;terminal.redraw(currentTTY)if fq then syslog.log("Sending SIGKILL to all processes")for cY in pairs(processes)do if cY~=0 then killProcess(cY,9)end end end end;fg.root={name="root",type="computer",properties={"isOn","label"},methods={}}function fg.root.methods:getIsOn(process)return true end;function fg.root.methods:getLabel(process)return os.getComputerLabel()end;function fg.root.methods:setLabel(process,fe)expect(1,fe,"string","nil")os.setComputerLabel(fe)end;function fg.root.methods:turnOn(process)end;function fg.root.methods:shutdown(process)if process.user~="root"then error("Permission denied",2)end;syslog.log("System is shutting down.")function postkill()hardware.deregister(deviceTreeRoot,fg.root)syslog.log("Halting system")for z,i in ipairs(shutdownHooks)do i()end;os.shutdown()mainThread=nil;while true do coroutine.yield()end end;fp()end;function fg.root.methods:reboot(process)if process.user~="root"then error("Permission denied",2)end;syslog.log("System is restarting.")function postkill()hardware.deregister(deviceTreeRoot,fg.root)syslog.log("Rebooting system")for z,i in ipairs(shutdownHooks)do i()end;os.reboot()mainThread=nil;while true do coroutine.yield()end end;fp()end;function fg.root:init()local fu=hardware.add(self,"redstone")for z,i in ipairs{"top","bottom","left","right","front","back"}do local bq=hardware.add(fu,i)bq.internalState.redstone={side=i}hardware.register(bq,fg.root_redstone)end;hardware.register(hardware.add(deviceTreeRoot,"lo"),fg.loopback_modem)registerLoopback()for i in pairs(ff)do if peripheral.isPresent(i)then hardware.add(self,i)end end;self.displayName=os.getComputerLabel()self.metadata.id=os.getComputerID()end;function fg.root:deinit()for i in pairs(ff)do if peripheral.isPresent(i)and self.children[i]then hardware.remove(self.children[i])end end;hardware.remove(hardware.get("/lo"))hardware.remove(hardware.get("/redstone"))end;eventHooks.peripheral=eventHooks.peripheral or{}eventHooks.peripheral[#eventHooks.peripheral+1]=function(ar)if ff[ar[2]]then local dJ,o=hardware.add(deviceTreeRoot,ar[2])if dJ then hardware.broadcast(deviceTreeRoot,"device_added",{device=hardware.path(dJ)})else syslog.log({level="error",module="Hardware"},"Could not create new device: "..o)end else for h in pairs(ff)do if peripheral.getType(h)=="modem"and not peripheral.call(h,"isWireless")and peripheral.call(h,"isPresentRemote",ar[2])then if not deviceTreeRoot.children[h]then hardware.add(deviceTreeRoot,h)end;local dJ,o=hardware.add(deviceTreeRoot.children[h],ar[2])if dJ then hardware.broadcast(deviceTreeRoot.children[h],"device_added",{device=hardware.path(dJ)})else syslog.log({level="error",module="Hardware"},"Could not create new device: "..o)end;break end end end end;eventHooks.peripheral_detach=eventHooks.peripheral_detach or{}eventHooks.peripheral_detach[#eventHooks.peripheral_detach+1]=function(ar)local dJ=getNodeById(ar[2])if not dJ then syslog.log({level="notice",module="Hardware"},"Received "..ar[1].." event for device ID "..ar[2]..", but no device node was found; ignoring")return end;local bb,c0=hardware.path(dJ),dJ.parent;hardware.remove(dJ)hardware.broadcast(c0,"device_removed",{device=bb})end;rootDriver=fg.root;fg.root_redstone={name="root_redstone",type="redstone",properties={"input","output","bundledInput","bundledOutput"},methods={}}local function fv(r)if r==0 then return nil else return r end end;function fg.root_redstone.methods:getInput()return fv(redstone.getAnalogInput(self.internalState.redstone.side))end;function fg.root_redstone.methods:getOutput()return fv(redstone.getAnalogOutput(self.internalState.redstone.side))end;function fg.root_redstone.methods:setOutput(process,r)r=expect(1,r,"number","boolean","nil")or 0;if r==false then r=0 elseif r==true then r=15 end;expect.range(r,0,15)redstone.setAnalogOutput(self.internalState.redstone.side,r)end;function fg.root_redstone.methods:getBundledInput()return redstone.getBundledInput(self.internalState.redstone.side)end;function fg.root_redstone.methods:getBundledOutput()return redstone.getBundledOutput(self.internalState.redstone.side)end;function fg.root_redstone.methods:setBundledOutput(process,r)expect(1,r,"number")expect.range(r,0,65535)redstone.setBundledOutput(self.internalState.redstone.side,r)end;function fg.root_redstone:init()if not self.internalState.redstone or not self.internalState.redstone.side then error("No assigned side on redstone device!",2)end;self.displayName="Redstone I/O on side "..self.internalState.redstone.side end;fg.peripheral_command={name="peripheral_command",type="command",properties={"command"},methods={}}fg.peripheral_command.methods.getCommand=fm"getCommand"fg.peripheral_command.methods.setCommand=fo"setCommand"("string")fg.peripheral_command.methods.run=fm"runCommand"function fg.peripheral_command:init()fh(self)self.displayName="Command block at "..self.id end;fk"command"fg.peripheral_computer={name="peripheral_computer",type="computer",properties={"isOn","label"},methods={}}fg.peripheral_computer.methods.getIsOn=fl"isOn"fg.peripheral_computer.methods.getLabel=fl"getLabel"fg.peripheral_computer.methods.turnOn=fm"turnOn"fg.peripheral_computer.methods.shutdown=fm"shutdown"fg.peripheral_computer.methods.reboot=fm"reboot"function fg.peripheral_command:init()fh(self)local fe=self.internalState.peripheral.call(self.id,"getLabel")self.metadata.id=self.internalState.peripheral.call(self.id,"getID")self.displayName=(fe or"Computer "..self.metadata.id).." at "..self.id end;fk"computer"hardware.listen(fj(fg["peripheral_computer"],"turtle"),deviceTreeRoot)fg.peripheral_drive={name="peripheral_drive",type="drive",properties={"state","label"},methods={}}function fg.peripheral_drive.methods:getState(process)if not self.internalState.peripheral.call(self.id,"isDiskPresent")then return nil end;return{audio=self.internalState.peripheral.call(self.id,"getAudioTitle")or nil,label=self.internalState.peripheral.call(self.id,"getDiskLabel"),id=self.internalState.peripheral.call(self.id,"getDiskID")}end;fg.peripheral_drive.methods.getLabel=fl"getDiskLabel"fg.peripheral_drive.methods.setLabel=fn"setDiskLabel"("string","nil")fg.peripheral_drive.methods.getMountPath=fl"getMountPath"function fg.peripheral_drive.methods:play(process)if not self.internalState.peripheral.call(self.id,"hasAudio")then error("Inserted disk is not an audio disc",2)end;return self.internalState.peripheral.call(self.id,"playAudio")end;fg.peripheral_drive.methods.stop=fl"stopAudio"fg.peripheral_drive.methods.eject=fl"ejectDisk"fg.peripheral_drive.methods.insert=fo"insertDisk"("string")function fg.peripheral_drive:init()fh(self)self.displayName=(self.internalState.peripheral.call(self.id,"getDiskLabel")or"No disk").." on drive "..self.id end;fk"drive"eventHooks.disk=eventHooks.disk or{}eventHooks.disk[#eventHooks.disk+1]=function(ar)local dJ=getNodeById(ar[2])if not dJ then syslog.log({level="notice",module="Hardware"},"Received "..ar[1].." event for device ID "..ar[2]..", but no device node was found; ignoring")return end;hardware.broadcast(dJ,"disk",{device=hardware.path(dJ)})end;eventHooks.disk_eject=eventHooks.disk_eject or{}eventHooks.disk_eject[#eventHooks.disk_eject+1]=function(ar)local dJ=getNodeById(ar[2])if not dJ then syslog.log({level="notice",module="Hardware"},"Received "..ar[1].." event for device ID "..ar[2]..", but no device node was found; ignoring")return end;hardware.broadcast(dJ,"disk_eject",{device=hardware.path(dJ)})end;fg.peripheral_energy_storage={name="peripheral_energy_storage",type="energy_storage",properties={"energy"},methods={}}fg.peripheral_energy_storage.methods.getEnergy=fl"getEnergy"function fg.peripheral_energy_storage:init()fh(self)self.displayName="Energy storage block at "..self.id;self.metadata.capacity=self.internalState.peripheral.call(self.id,"getEnergyCapacity")end;fk"energy_storage"fg.peripheral_fluid_storage={name="peripheral_fluid_storage",type="fluid_storage",properties={"tanks"},methods={}}fg.peripheral_fluid_storage.methods.getTanks=fl"tanks"function fg.peripheral_fluid_storage.methods:push(process,bS,fw,m)expect(1,bS,"string")expect(2,fw,"number","nil")expect(3,m,"string","nil")local eh;local fx={hardware.get(bS)}if#fx==1 then eh=fx[1]else for z,i in ipairs(fx)do if i.parent==self.parent then eh=i;break end end end;if not eh then error("No such device",0)elseif eh.parent~=self.parent then error("Devices must be on the same network",0)end;local bg=false;for z,i in ipairs(eh.drivers)do if i==fg.peripheral_fluid_storage then bg=true;break end end;if not bg then error("Target device is not a fluid storage block",0)end;return self.internalState.peripheral.call(self.id,"pushFluid",eh.id,fw,m)end;function fg.peripheral_fluid_storage.methods:pull(process,bR,fw,m)expect(1,bR,"string")expect(2,fw,"number","nil")expect(3,m,"string","nil")local eh;local fx={hardware.get(bR)}if#fx==1 then eh=fx[1]else for z,i in ipairs(fx)do if i.parent==self.parent then eh=i;break end end end;if not eh then error("No such device",0)elseif eh.parent~=self.parent then error("Devices must be on the same network",0)end;local bg=false;for z,i in ipairs(eh.drivers)do if i==fg.peripheral_fluid_storage then bg=true;break end end;if not bg then error("Target device is not a fluid storage block",0)end;return self.internalState.peripheral.call(self.id,"pullFluid",eh.id,fw,m)end;function fg.peripheral_fluid_storage:init()fh(self)self.displayName="Fluid storage block at "..self.id end;fk"fluid_storage"fg.peripheral_inventory={name="peripheral_inventory",type="inventory",properties={"items"},methods={}}fg.peripheral_inventory.methods.getItems=fl"list"fg.peripheral_inventory.methods.detail=fn"getItemDetail"("number")fg.peripheral_inventory.methods.limit=fn"getItemLimit"("number")function fg.peripheral_inventory.methods:push(process,bS,fy,fw,fz)expect(1,bS,"string")expect(2,fy,"number")expect(3,fw,"number","nil")expect(4,fz,"number","nil")local eh;local fx={hardware.get(bS)}if#fx==1 then eh=fx[1]else for z,i in ipairs(fx)do if i.parent==self.parent then eh=i;break end end end;if not eh then error("No such device",0)elseif eh.parent~=self.parent then error("Devices must be on the same network",0)end;local bg=false;for z,i in ipairs(eh.drivers)do if i==fg.peripheral_inventory then bg=true;break end end;if not bg then error("Target device is not an inventory block",0)end;return self.internalState.peripheral.call(self.id,"pushItems",eh.id,fy,fw,fz)end;function fg.peripheral_inventory.methods:pull(process,bR,fy,fw,fz)expect(1,bR,"string")expect(2,fy,"number")expect(3,fw,"number","nil")expect(4,fz,"number","nil")local eh;local fx={hardware.get(bR)}if#fx==1 then eh=fx[1]else for z,i in ipairs(fx)do if i.parent==self.parent then eh=i;break end end end;if not eh then error("No such device",0)elseif eh.parent~=self.parent then error("Devices must be on the same network",0)end;local bg=false;for z,i in ipairs(eh.drivers)do if i==fg.peripheral_inventory then bg=true;break end end;if not bg then error("Target device is not an inventory block",0)end;return self.internalState.peripheral.call(self.id,"pullItems",eh.id,fy,fw,fz)end;function fg.peripheral_inventory:init()fh(self)self.displayName="Inventory at "..self.id;self.metadata.size=self.internalState.peripheral.call(self.id,"size")end;fk"inventory"fg.peripheral_monitor={name="peripheral_monitor",type="monitor",properties={"scale","size"},methods={}}fg.peripheral_monitor.methods.getScale=fl"getTextScale"fg.peripheral_monitor.methods.setScale=fn"setTextScale"("number")function fg.peripheral_monitor.methods:getSize()local af,ag=self.internalState.peripheral.call(self.id,"getSize")return{width=af,height=ag}end;function fg.peripheral_monitor.methods:write(process,...)for v,i in ipairs{...}do if v>1 then terminal.write(self.internalState.tty,"\t")end;terminal.write(self.internalState.tty,i)end;terminal.redraw(self.internalState.tty)end;function fg.peripheral_monitor.methods:termctl(process,dr)expect(1,dr,"table","nil")if dr then expect.field(dr,"cbreak","boolean","nil")expect.field(dr,"delay","boolean","nil")expect.field(dr,"echo","boolean","nil")expect.field(dr,"keypad","boolean","nil")expect.field(dr,"nlcr","boolean","nil")expect.field(dr,"raw","boolean","nil")for h,i in pairs(dr)do if self.internalState.tty.flags[h]~=nil then self.internalState.tty.flags[h]=i end end end;local y=deepcopy(self.internalState.tty.flags)y.hasgfx=term.getGraphicsMode~=nil;return y end;function fg.peripheral_monitor.methods:openterm(process)return terminal.openterm(self.internalState.tty,process)end;function fg.peripheral_monitor.methods:opengfx(process)return terminal.opengfx(self.internalState.tty,process)end;function fg.peripheral_monitor:init()fh(self)local af,ag=self.internalState.peripheral.call(self.id,"getSize")local fA=self.internalState.peripheral.call(self.id,"getTextScale")self.displayName=af*fA.."x"..ag*fA.." monitor at "..self.id;local term={}for z,i in ipairs(self.internalState.peripheral.getMethods(self.id))do term[i]=function(...)return self.internalState.peripheral.call(self.id,i,...)end end;self.internalState.tty=terminal.makeTTY(term,af,ag)self.internalState.tty.isMonitor=true;terminal.redraw(self.internalState.tty,true)end;function fg.peripheral_monitor:deinit()local dc=self.internalState.tty;if dc.frontmostProcess then local i=dc.frontmostProcess;if i.stdin==dc then i.stdin=nil end;if i.stdout==dc then i.stdout=nil end;if i.stderr==dc then i.stderr=nil end end;for z,i in ipairs(dc.processList)do if i.stdin==dc then i.stdin=nil end;if i.stdout==dc then i.stdout=nil end;if i.stderr==dc then i.stderr=nil end end end;fk"monitor"eventHooks.monitor_resize=eventHooks.monitor_resize or{}eventHooks.monitor_resize[#eventHooks.monitor_resize+1]=function(ar)local dJ=getNodeById(ar[2])if not dJ then syslog.log({level="notice",module="Hardware"},"Received "..ar[1].." event for device ID "..ar[2]..", but no device node was found; ignoring")return end;local S=fg.peripheral_monitor.methods.getSize(dJ)terminal.resize(dJ.internalState.tty,S.width,S.height)hardware.broadcast(dJ,"monitor_resize",{device=hardware.path(dJ),width=S.width,height=S.height})end;fg.peripheral_printer={name="peripheral_printer",type="printer",properties={"inkLevel","paperLevel"},methods={}}fg.peripheral_printer.methods.getInkLevel=fl"getInkLevel"fg.peripheral_printer.methods.getPaperLevel=fl"getPaperLevel"function fg.peripheral_printer.methods:page(process)if self.internalState.printer.open then self.internalState.peripheral.call(self.id,"endPage")self.internalState.printer.open=false end;if not self.internalState.peripheral.call(self.id,"newPage")then return nil end;self.internalState.printer.open=true;local fB,p,q;local function dq(...)if not self.internalState.printer.open then error("attempt to use closed page",2)end;return self.internalState.peripheral.call(self.id,"write",...)end;local function fC()if not self.internalState.printer.open then return true end;if not self.internalState.peripheral.call(self.id,"endPage")then return false end;self.internalState.printer.open=false end;setfenv(dq,process.env)setfenv(fC,process.env)debug.protect(dq)debug.protect(fC)return fi(process,{__index=function(z,aC)if not self.internalState.printer.open then error("attempt to use closed page",2)end;if aC=="size"then local t,d8=self.internalState.peripheral.call(self.id,"getPageSize")return fi(process,{__index=function(z,aC)if aC=="width"then return t elseif aC=="height"then return d8 end end,__newindex=function()error("Cannot modify read-only table",2)end})elseif aC=="cursor"then p,q=self.internalState.peripheral.call(self.id,"getCursorPos")return fi(process,{__index=function(z,aC)if aC=="x"then return p elseif aC=="y"then return q end end,__newindex=function(z,aC,aD)if aC=="x"then p=aD;self.internalState.peripheral.call(self.id,"setCursorPos",p,q)elseif aC=="y"then q=aD;self.internalState.peripheral.call(self.id,"setCursorPos",p,q)else error("Cannot modify member '"..aC.."'",2)end end})elseif aC=="title"then return fB elseif aC=="isOpen"then return self.internalState.printer.open elseif aC=="write"then return dq elseif aC=="close"then return fC end end,__newindex=function(z,aC,aD)if not self.internalState.printer.open then error("attempt to use closed page",2)end;if aC=="cursor"then if type(aD)~="table"then error("bad value for 'cursor' (expected table, got "..type(aD)..")",2)end;expect.field(aD,"x","number")expect.field(aD,"y","number")p,q=aD.x,aD.y;self.internalState.peripheral.call(self.id,"setCursorPos",p,q)elseif aC=="title"then if type(aD)~="string"and aD~=nil then error("bad value for 'title' (expected string, got "..type(aD)..")",2)end;fB=aD;self.internalState.peripheral.call(self.id,"setPageTitle",fB)else error("Cannot modify member '"..aC.."'",2)end end})end;function fg.peripheral_printer:init()fh(self)self.displayName="Speaker at "..self.id;self.internalState.printer={open=false}end;fk"printer"fg.peripheral_speaker={name="peripheral_speaker",type="speaker",properties={},methods={}}function fg.peripheral_speaker.methods:playNote(process,fD,fE,fF)expect(1,fD,"string")expect(2,fE,"number","nil")expect(3,fF,"number","nil")if fE then expect.range(fE,0,3)end;if fF then expect.range(fF,0,24)end;return self.internalState.peripheral.call(self.id,"playNote",fD,fE,fF)end;function fg.peripheral_speaker.methods:playSound(process,m,fE,fG)expect(1,m,"string")expect(2,fE,"number","nil")expect(3,fG,"number","nil")if fE then expect.range(fE,0,3)end;if fG then expect.range(fG,0.5,2.0)end;return self.internalState.peripheral.call(self.id,"playNote",m,fE,fG)end;function fg.peripheral_speaker.methods:playAudio(fH,fE)expect(1,fH,"table")expect(2,fE,"number","nil")if fE then expect.range(fE,0,3)end;return self.internalState.peripheral.call(self.id,"playAudio",fH,fE)end;fg.peripheral_speaker.methods.stop=fl"stop"function fg.peripheral_speaker:init()fh(self)self.displayName="Speaker at "..self.id end;fk"speaker"eventHooks.speaker_audio_empty=eventHooks.speaker_audio_empty or{}eventHooks.speaker_audio_empty[#eventHooks.speaker_audio_empty+1]=function(ar)local dJ=getNodeById(ar[2])if not dJ then syslog.log({level="notice",module="Hardware"},"Received "..ar[1].." event for device ID "..ar[2]..", but no device node was found; ignoring")return end;hardware.broadcast(dJ,"speaker_audio_empty",{device=hardware.path(dJ)})end;local fI={fg.peripheral_command,fg.peripheral_computer,fg.peripheral_drive,fg.peripheral_energy_storage,fg.peripheral_fluid_storage,fg.peripheral_inventory,fg.peripheral_monitor,fg.peripheral_printer,fg.peripheral_speaker}function registerDriver(eW)local fJ=eW.init;eW.init=function(dJ)fh(dJ)if fJ then return fJ(dJ)end end;eW.__callback=fj(eW,eW.type)hardware.listen(eW.__callback,deviceTreeRoot)fI[#fI+1]=eW;for z,dJ in ipairs(hardware.find("modem"))do if not dJ.metadata.wireless then hardware.listen(eW.__callback,dJ)dJ.internalState.modem.callbacks[#dJ.internalState.modem.callbacks+1]=f end end end;function deregisterDriver(eW)if not eW.__callback then return end;hardware.unlisten(eW.__callback)for z,i in ipairs(hardware.find(eW.type))do hardware.deregister(i,eW)end;for v,i in ipairs(ff)do if i==eW then table.remove(ff,v)break end end;for z,dJ in ipairs(hardware.find("modem"))do if not dJ.metadata.wireless then hardware.unlisten(eW.__callback)for v,i in ipairs(dJ.internalState.modem.callbacks)do if i==eW.__callback then table.remove(dJ.internalState.modem.callbacks,v)break end end end end end;fg.peripheral_modem={name="peripheral_modem",type="modem",properties={"remainingChannels"},methods={}}function fg.peripheral_modem.methods:getRemainingChannels()local b=128;for z in pairs(self.internalState.modem)do b=b-1 end;return b end;function fg.peripheral_modem.methods:open(process,fK)if not self.internalState.modem[fK]then self.internalState.peripheral.call(self.id,"open",fK)self.internalState.modem[fK]={}end;self.internalState.modem[fK][process]=true end;function fg.peripheral_modem.methods:isOpen(process,fK)return self.internalState.modem[fK]and self.internalState.modem[fK][process]end;function fg.peripheral_modem.methods:close(process,fK)self.internalState.modem[fK][process]=nil;if not next(self.internalState.modem[fK])then self.internalState.peripheral.call(self.id,"close",fK)self.internalState.modem[fK]=nil end end;function fg.peripheral_modem.methods:closeAll(process)for fK=0,65535 do self.internalState.modem[fK][process]=nil;if not next(self.internalState.modem[fK])then self.internalState.peripheral.call(self.id,"close",fK)self.internalState.modem[fK]=nil end end end;function fg.peripheral_modem.methods:transmit(process,fK,fL,fM)expect(1,fK,"number")fL=expect(2,fL,"number","nil")or fK;return self.internalState.peripheral.call(self.id,"transmit",fK,fL,fM)end;function fg.peripheral_modem:init()fh(self)self.metadata.wireless=self.internalState.peripheral.call(self.id,"isWireless")self.displayName=(self.metadata.wireless and"Wireless"or"Wired").." modem at "..self.id;self.internalState.modem={}self.internalState.modem.channels={}self.internalState.peripheral.call(self.id,"closeAll")if not self.metadata.wireless then self.internalState.modem.callbacks={}for z,i in ipairs(fI)do local f=fj(i,i.type)hardware.listen(f,self)self.internalState.modem.callbacks[#self.internalState.modem.callbacks+1]=f end;local f=fj(fg["peripheral_computer"],"turtle")hardware.listen(f,self)self.internalState.modem.callbacks[#self.internalState.modem.callbacks+1]=f;for z,m in ipairs(self.internalState.peripheral.call(self.id,"getNamesRemote"))do hardware.add(self,m)end end end;function fg.peripheral_modem:deinit()if not self.metadata.wireless then for z,i in ipairs(self.internalState.modem.callbacks)do hardware.unlisten(i)end end end;fk"modem"eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(ar)local dJ=getNodeById(ar[2])or hardware.get(ar[2])if not dJ then syslog.log({level="notice",module="Hardware"},"Received "..ar[1].." event for device ID "..ar[2]..", but no device node was found; ignoring")return end;local a5=false;for i in pairs(dJ.listeners)do if(dJ.internalState.modem[ar[3]]or{})[i]then i.eventQueue[#i.eventQueue+1],a5={"modem_message",{device=hardware.path(dJ),channel=ar[3],replyChannel=ar[4],message=ar[5],distance=ar[6]}},true end end;return a5 end;fg.loopback_modem={name="loopback_modem",type="modem",properties={"remainingChannels"},methods={}}function fg.loopback_modem.methods:getRemainingChannels()local b=128;for z in pairs(self.internalState.modem)do b=b-1 end;return b end;function fg.loopback_modem.methods:open(process,fK)if not self.internalState.modem[fK]then self.internalState.modem[fK]={}end;self.internalState.modem[fK][process]=true end;function fg.loopback_modem.methods:isOpen(process,fK)return self.internalState.modem[fK]and self.internalState.modem[fK][process]end;function fg.loopback_modem.methods:close(process,fK)self.internalState.modem[fK][process]=nil;if not next(self.internalState.modem[fK])then self.internalState.modem[fK]=nil end end;function fg.loopback_modem.methods:closeAll(process)for fK=0,65535 do self.internalState.modem[fK][process]=nil;if not next(self.internalState.modem[fK])then self.internalState.modem[fK]=nil end end end;function fg.loopback_modem.methods:transmit(process,fK,fL,fM)expect(1,fK,"number")fL=expect(2,fL,"number","nil")or fK;os.queueEvent("modem_message",self.uuid,fK,fL,fM,0)end;function fg.loopback_modem:init()self.metadata.wireless=true;self.displayName="Loopback modem"self.internalState.modem={}self.internalState.modem.channels={}end;local function fN(fO)local b3={scheme=""}for a9 in fO:gmatch"."do if b3.fragment then if a9:match"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/?]"then b3.fragment=b3.fragment..a9 else error("Invalid URI",3)end elseif b3.query then if a9=="#"then b3.fragment=""elseif a9:match"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/?]"then b3.query=b3.query..a9 else error("Invalid URI",3)end elseif b3.path then if a9=="/"and b3.path=="/"and not b3.host then b3.path,b3.host=nil,""elseif a9=="?"then b3.query=""elseif a9=="#"then b3.fragment=""elseif a9:match"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/]"then b3.path=b3.path..a9 else error("Invalid URI",3)end elseif b3.port then if tonumber(a9)then b3.port=b3.port..a9 elseif a9=="/"then b3.path="/"else error("Invalid URI",3)end elseif b3.host then if a9=="@"and not b3.user then b3.user,b3.host=b3.host,""elseif a9==":"then b3.port=""elseif a9=="/"then b3.path="/"elseif a9:match"[%w%-%._~%%/!%$&'%(%)%*%+,;=]"then b3.host=b3.host..a9 else error("Invalid URI",3)end else if a9==":"then b3.path=""elseif a9:match(b3.scheme==""and"[%a%+%-%.]"or"[%w%+%-%.]")then b3.scheme=b3.scheme..a9 else error("Invalid URI",3)end end end;if b3.port then b3.port=tonumber(b3.port)end;return b3 end;local function fP(fQ)if fQ:match"^%d+$"then return tonumber(fQ)elseif fQ:match"^%d+%.%d+$"then return tonumber(fQ:match"^%d+")*0x1000000+tonumber(fQ:match"^%d+%.(%d+)")elseif fQ:match"^%d+%.%d+%.%d+$"then return tonumber(fQ:match"^(%d+)")*0x1000000+tonumber(fQ:match"^%d+%.(%d+)")*0x10000+tonumber(fQ:match"^%d+%.%d+%.(%d+)")elseif fQ:match"^%d+%.%d+%.%d+%.%d+$"then return tonumber(fQ:match"^(%d+)")*0x1000000+tonumber(fQ:match"^%d+%.(%d+)")*0x10000+tonumber(fQ:match"^%d+%.%d+%.(%d+)")*0x100+tonumber(fQ:match"^%d+%.%d+%.%d+%.(%d+)")else error("Invalid IP address",2)end end;local function fR(b)if not b then return nil end;return("%d.%d.%d.%d"):format(bit32.band(bit32.rshift(b,24),0xFF),bit32.band(bit32.rshift(b,16),0xFF),bit32.band(bit32.rshift(b,8),0xFF),bit32.band(b,0xFF))end;local function fS(fT)local bs=""for v=1,fT do bs=bs..string.char(math.random(0,255))end;return bs end;local function fU(b)return bit32.bnot(2^(32-b)-1)end;local function fV(w)local r=0;while bit32.btest(w,0x80000000)do w,r=bit32.lshift(w,1),r+1 end;return r end;local function fW(dJ)if not dJ then error("No such device")end;for z,i in pairs(dJ.drivers)do if i.type=="modem"then return dJ end end;error("Not a modem")end;local fX=0;local fY={}local fZ={maxn=0,[0]={}}local f_={}local g0={send={},recv={}}local g1={}local g2={}local g3=setmetatable({},{__mode="k"})local g4={arp={},socket={}}local g5={}function g0.send.link(b3,g6,ae)expect(2,g6,"number","nil")expect.field(b3,"device","table")local bA={PhoenixNetworking=true,type="link",source=os.computerID(),destination=g6,payload=ae}if g6==os.computerID()then os.queueEvent("modem_message",b3.device.id,b3.outPort or 0,b3.inPort or 0,bA,0)else hardware.call(b3.process or KERNEL,b3.device,"transmit",b3.outPort or 0,b3.inPort or 0,bA)end end;function g0.send.arp_request(b3,fQ)expect.field(b3,"device","table")expect(2,fQ,"string")hardware.call(b3.process or KERNEL,b3.device,"transmit",0,0,{PhoenixNetworking=true,type="arp",reply=false,source=os.computerID(),sourceIP=fY[b3.device.uuid]and fR(fY[b3.device.uuid].ip),destinationIP=fQ})end;function g0.send.arp_reply(b3,g6,g7)expect.field(b3,"device","table")expect(2,g6,"number")expect(3,g7,"string","nil")hardware.call(b3.process or KERNEL,b3.device,"transmit",0,0,{PhoenixNetworking=true,type="arp",reply=true,source=os.computerID(),sourceIP=fR(fY[b3.device.uuid].ip),destination=g6,destinationIP=g7})end;function g0.send.internet(b3,g6,ae)expect(2,g6,"number")local eb={PhoenixNetworking=true,type="internet",hopsLeft=15,payload=ae,destination=fR(g6)}local aA=fS(32)eb.messageID=aA;local i;for v=fZ.maxn,0,-1 do if fZ[v]then for z,g8 in ipairs(fZ[v])do if bit32.band(g8.source,g8.sourceNetmask)==bit32.band(g6,g8.sourceNetmask)and(not i or fV(g8.sourceNetmask)>fV(i.sourceNetmask))then i=g8 end end end end;if not i then return g0.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="No route to host",payload=eb})end;if i.action=="unicast"and fY[i.device.uuid]and fY[i.device.uuid].up then b3.device=i.device;eb.source=fR(fY[i.device.uuid].ip)if f_[i.device.uuid]and f_[i.device.uuid][i.destination]then return g0.send.link(b3,f_[i.device.uuid][i.destination],eb)end;local g9=false;local fb;local function ga(z,fQ,bE)if not g9 and fP(fQ)==i.destination then g9=true;g0.send.link(b3,bE,eb)end;if g9 then for v,f in ipairs(g4.arp)do if f==ga then table.remove(g4.arp,v)break end end end end;local function gb(ar)if ar[2]==fb then if not g9 then g0.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="No route to host",payload=eb})end;g9=true;for v,i in ipairs(eventHooks.timer)do if i==gb then table.remove(eventHooks.timer,v)break end end;for v,f in ipairs(g4.arp)do if f==ga then table.remove(g4.arp,v)break end end end end;g4.arp[#g4.arp+1]=ga;g0.send.arp_request(b3,fR(i.destination))eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=gb;fb=os.startTimer(2)return elseif i.action=="broadcast"and fY[i.device.uuid]and fY[i.device.uuid].up then b3.device=i.device;eb.source=fR(fY[i.device.uuid].ip)return g0.send.link(b3,nil,eb)elseif i.action=="local"and fY[i.device.uuid]and fY[i.device.uuid].up then b3.device=i.device;eb.source=fR(fY[i.device.uuid].ip)if f_[i.device.uuid]and f_[i.device.uuid][g6]then return g0.send.link(b3,f_[i.device.uuid][g6],eb)end;local g9=false;local fb;local function ga(z,fQ,bE)if not g9 and fP(fQ)==g6 then g9=true;g0.send.link(b3,bE,eb)end;if g9 then for v,f in ipairs(g4.arp)do if f==ga then table.remove(g4.arp,v)break end end end end;local function gb(ar)if ar[2]==fb then if not g9 then g0.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="No route to host",payload=eb})end;g9=true;for v,i in ipairs(eventHooks.timer)do if i==gb then table.remove(eventHooks.timer,v)break end end end end;g4.arp[#g4.arp+1]=ga;g0.send.arp_request(b3,fR(g6))eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=gb;fb=os.startTimer(2)return elseif i.action=="unreachable"then return g0.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="Destination unreachable",payload=eb})elseif i.action=="prohibit"then return g0.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="Prohibited",payload=eb})elseif i.action=="blackhole"then return end end;function g0.send.control(b3,g6,type,o,gc)expect(3,type,"string")expect(4,o,"string","nil")return g0.send.internet(b3,g6,{PhoenixNetworking=true,type="control",messageType=type,error=o,payload=gc})end;g0.send.socket={}function g0.send.socket.connect(b3,fQ,gd,ge)for v=1,16384 do local E=math.random(49152,65535)if not g1[E]or not g1[E][gd]then ge.localPort=E;break end end;if not ge.localPort then error("Too many open sockets")end;ge.id=fX;fX=fX+1;ge.ip=fQ;ge.port=gd;ge.sendSeq=math.floor(math.random()*0x10000000000)ge.sendSeqNext=ge.sendSeq+2;ge.sendSeqMax=ge.sendSeq+256;b3.outPort=gd;b3.inPort=ge.localPort;g3[ge]=function(E)if E.type=="control"and E.payload.destination==fR(fQ)then ge.status="error"ge.error=E.error;return true end;return false end;g0.send.internet(b3,fQ,{PhoenixNetworking=true,type="socket",sequence=ge.sendSeqNext-1,windowSize=256,synchronize=true})local bg,o=pcall(hardware.call,b3.process or KERNEL,b3.device,"open",ge.localPort)if not bg then g0.send.internet(b3,fQ,{PhoenixNetworking=true,type="socket",sequence=ge.sendSeqNext,windowSize=0,reset=true})ge.status="error"ge.error=o;return false end;ge.status="syn-sent"ge.nextUpdate=os.epoch"utc"+5000;ge.process=b3.process;ge.retryCount=0;g1[ge.localPort]=g1[ge.localPort]or{}g1[ge.localPort][gd]=ge;g2[ge.id]=ge end;function g0.send.socket.data(b3,ae,ge)b3.outPort=ge.port;b3.inPort=ge.localPort;ae.PhoenixNetworking=true;ae.type="socket"if not ae.sequence then ae.sequence=ge.sendSeqNext;ge.sendSeqNext=ge.sendSeqNext+1 end;ae.acknowledgement=ae.acknowledgement or ge.recvSeq-1;ge.nextAck=nil;if not ae.final then ae.windowSize=256 end;return g0.send.internet(b3,ge.ip,ae)end;function g0.send.socket.ack(b3,b,ge)return g0.send.socket.data(b3,{acknowledgement=b},ge)end;function g0.send.socket.reset(b3,fQ,gd,gf,gg,gh)b3.outPort=gd;b3.inPort=gh or gd;return g0.send.internet(b3,fQ,{PhoenixNetworking=true,type="socket",sequence=gf,acknowledgement=gg,reset=true})end;local function gi(ge,n,...)n=n or"*l"if type(n)~="string"and type(n)~="number"then error("bad argument (expected string or number, got "..type(n)..")",2)end;if ge.buffer==""then return nil end;n=n:gsub("^%*","")if n=="a"then local a0=ge.buffer;ge.buffer=""return a0 elseif n=="l"then local a0,a7=ge.buffer:match"^([^\n]*)\n?()"if a0 then ge.buffer=ge.buffer:sub(a7)if select("#",...)>0 then return a0,gi(ge,...)else return a0 end else return nil end elseif n=="L"then local a0,a7=ge.buffer:match"^([^\n]*\n?)()"if a0 then ge.buffer=ge.buffer:sub(a7)if select("#",...)>0 then return a0,gi(ge,...)else return a0 end else return nil end elseif n=="n"then local a0,a7=ge.buffer:match"(%d+)()"if a0 then ge.buffer=ge.buffer:sub(a7)if select("#",...)>0 then return tonumber(a0),gi(ge,...)else return tonumber(a0)end else return nil end elseif type(n)=="number"then local a0=ge.buffer:sub(1,n)ge.buffer=ge.buffer:sub(n+1)if select("#",...)>0 then return a0,gi(ge,...)else return a0 end else error("bad argument (invalid mode '"..n.."')",2)end end;local function gj(ge,bj,...)bj=tostring(bj)ge.outQueue[ge.sendSeqNext]=bj;g0.send.socket.data({},{payload=bj},ge)if select("#",...)>0 then return gj(ge,...)end end;function syscalls.__socketcall(process,aq,aA,eZ,...)local ge=g2[aA]if not ge then error("No such socket")end;local gk=process;while process~=ge.process do if process==nil then error("No such socket")end;process=processes[process.parent or-1]end;if eZ=="close"then ge.sendSeqMax=ge.sendSeqNext;g0.send.socket.data({},{final=true},ge)ge.status="fin-wait"elseif eZ=="read"then return gi(ge,...)elseif eZ=="write"then return gj(ge,...)elseif eZ=="transfer"then ge.process=gk else error("No such method")end end;local do_syscall=do_syscall;local function gl(ge)local bA=setmetatable({id=ge.id},{__name="socket"})function bA:localIP()return ge.localIP end;function bA:status()if ge.status=="listening"or ge.status=="syn-sent"or ge.status=="syn-received"then return"connecting"elseif ge.status=="connected"or ge.buffer~=""then return"open"elseif ge.status=="error"then return"error",ge.error else return"closed"end end;function bA:read(n,...)if ge.status~="connected"and ge.status~="close-wait"and ge.status~="closed"then error("attempt to read from a "..ge.status.." handle",2)end;return do_syscall("__socketcall",ge.id,"read",n,...)end;function bA:write(bj,...)if ge.status~="connected"then error("attempt to write to a "..ge.status.." handle",2)end;return do_syscall("__socketcall",ge.id,"write",bj,...)end;function bA:close()if ge.status=="closing"or ge.status=="fin-wait"or ge.status=="closed"then return end;if not(ge.status=="listening"or ge.status=="syn-sent"or ge.status=="syn-received"or ge.status=="connected")then error("attempt to close a "..ge.status.." handle",2)end;return do_syscall("__socketcall",ge.id,"close")end;function bA:transfer()return do_syscall("__socketcall",ge.id,"transfer")end;return bA end;function g0.recv.link(b3,ae)expect.field(ae,"source","number")expect.field(ae,"destination","number")expect.field(ae,"payload","table")syslog.debug("Received link message from",ae.source,"to",ae.destination)if ae.destination~=os.computerID()then return end;b3.sourceID=ae.source;assert(ae.payload.PhoenixNetworking)expect.field(ae.payload,"type","string")if not g0.recv[ae.payload.type]then error("Unknown protocol '"..ae.payload.type.."'")end;return g0.recv[ae.payload.type](b3,ae.payload)end;function g0.recv.arp(b3,ae)expect.field(ae,"source","number")expect.field(ae,"reply","boolean")syslog.debug("Received arp message from",ae.source)if not ae.reply and ae.destinationIP and ae.sourceIP~=ae.destinationIP then local fQ=fP(expect.field(ae,"destinationIP","string"))if fY[b3.device.uuid]and fY[b3.device.uuid].ip==fQ then g0.send.arp_reply(b3,ae.source,ae.sourceIP)end end;if ae.sourceIP then local fQ=fP(expect.field(ae,"sourceIP","string"))f_[b3.device.uuid]=f_[b3.device.uuid]or{}f_[b3.device.uuid][fQ]=ae.source;local gm={}for v,i in ipairs(g4.arp)do gm[v]=i end;for z,i in ipairs(gm)do i(i,ae.sourceIP,ae.source)end end end;function g0.recv.internet(b3,ae)b3.sourceIP=fP(expect.field(ae,"source","string"))local bE=fP(expect.field(ae,"destination","string"))b3.localIP=bE;syslog.debug("Received internet message from",ae.source,"to",ae.destination)expect.field(ae,"payload","table")if g5[expect.field(ae,"messageID","number","string")]then return end;g5[ae.messageID]=os.epoch"utc"if not fY[b3.device.uuid]or fY[b3.device.uuid].ip~=bE then return end;b3.ipPacket=ae;assert(ae.payload.PhoenixNetworking)expect.field(ae.payload,"type","string")if not g0.recv[ae.payload.type]then error("Unknown protocol '"..ae.payload.type.."'")end;return g0.recv[ae.payload.type](b3,ae.payload)end;function g0.recv.control(b3,ae)expect.field(ae,"messageType","string")syslog.debug("Received control message",ae.messageType)local a5=false;if ae.messageType=="ping"then g0.send.control({device=b3.device},b3.sourceIP,"pong",nil,b3.ipPacket)else for z,i in pairs(g3)do a5=i{type="control",messageType=ae.messageType,error=ae.error,payload=ae.payload,sender=fR(b3.sourceIP)}or a5 end end;return a5 end;function g0.recv.socket(b3,ae)expect.field(ae,"sequence","number")expect.field(ae,"acknowledgement","number","nil")expect.field(ae,"windowSize","number","nil")expect.field(ae,"payload","string","nil")if b3.channel==0 or b3.replyChannel==0 then syslog.debug("Received socket event on channel 0; discarding.")return end;local ge=(g1[b3.channel]or{})[b3.replyChannel]or(g1[b3.channel]or{}).listen;if not ge then if ae.acknowledgement then g0.send.socket.reset(b3,b3.sourceIP,b3.replyChannel,ae.acknowledgement,nil,b3.channel)else g0.send.socket.reset(b3,b3.sourceIP,b3.replyChannel,0,ae.sequence+(ae.windowSize or 0),b3.channel)end;return end;do local bs={}for h,i in pairs(ge)do if h~="process"then bs[h]=i end end;syslog.debug("Received socket message:",serialize(ae),"\nSocket info:",serialize(bs))end;if ge.status=="listening"then if ae.reset then return end;if ae.acknowledgement then g0.send.socket.reset(b3,b3.sourceIP,b3.replyChannel,ae.acknowledgement,nil,b3.channel)return end;if not ae.synchronize then return end;ge.ip=b3.sourceIP;ge.localIP=fR(b3.localIP)ge.port=b3.replyChannel;ge.recvSeq=ae.sequence+1;ge.recvSeqMax=ge.recvSeq+(ae.windowSize or 0)ge.sendSeq=math.floor(math.random()*0x10000000000)ge.sendSeqNext=ge.sendSeq+2;ge.sendSeqMax=ge.sendSeq+(ae.windowSize or 0)ge.status="syn-received"ge.nextUpdate=os.epoch"utc"+5000;ge.retryCount=0;g1[b3.channel][b3.replyChannel]=ge;g1[b3.channel].listen=nil;g0.send.internet({inPort=b3.channel,outPort=b3.replyChannel},ge.ip,{PhoenixNetworking=true,type="socket",sequence=ge.sendSeqNext-1,acknowledgement=ge.recvSeq,windowSize=256,synchronize=true})elseif ge.status=="syn-sent"then if ae.reset then ge.status="error"ge.error="Connection refused"g1[b3.channel][b3.replyChannel]=nil;if ge.process then ge.process.eventQueue[#ge.process.eventQueue+1]={"handle_status_change",{id=ge.id,status="error"}}end;return true end;if not ae.synchronize or not ae.acknowledgement or ae.acknowledgement<ge.sendSeq then g0.send.socket.reset(b3,b3.sourceIP,b3.replyChannel,ae.acknowledgement,nil,b3.channel)ge.status="error"ge.error="Connection refused"g1[b3.channel][b3.replyChannel]=nil;if ge.process then ge.process.eventQueue[#ge.process.eventQueue+1]={"handle_status_change",{id=ge.id,status="error"}}end;return true end;ge.localIP=fR(b3.localIP)ge.status="connected"ge.sendSeq=ae.acknowledgement;ge.sendSeqMax=ge.sendSeq+256;ge.recvSeq=ae.sequence+1;ge.recvSeqMax=ge.recvSeq+(ae.windowSize or 0)ge.outQueue={}ge.nextUpdate=os.epoch"utc"+2000;g0.send.socket.ack({},ge.recvSeq,ge)if ge.process then ge.process.eventQueue[#ge.process.eventQueue+1]={"handle_status_change",{id=ge.id,status="connected"}}end;return true else if ae.sequence<ge.recvSeq or ae.sequence>ge.recvSeqMax then syslog.debug("Sequence out of range")if ae.reset then ge.status="error"ge.error="Connection reset by peer"g1[b3.channel][b3.replyChannel]=nil;if ge.process then ge.process.eventQueue[#ge.process.eventQueue+1]={"handle_status_change",{id=ge.id,status="error"}}end;return true else g0.send.socket.ack({},ge.recvSeq,ge)return end end;if ae.reset then syslog.debug("Received reset")if ge.status=="syn-received"then ge.status="listening"return elseif ge.status=="connected"or ge.status=="fin-wait"then ge.status="error"ge.error="Connection reset by peer"g1[b3.channel][b3.replyChannel]=nil;if ge.process then ge.process.eventQueue[#ge.process.eventQueue+1]={"handle_status_change",{id=ge.id,status="error"}}end;return true else ge.status="closed"g1[b3.channel][b3.replyChannel]=nil;if ge.process then ge.process.eventQueue[#ge.process.eventQueue+1]={"handle_status_change",{id=ge.id,status="closed"}}end;return true end end;if ae.synchronize then g0.send.socket.reset(b3,b3.sourceIP,b3.replyChannel,ae.acknowledgement,nil,b3.channel)ge.status="error"ge.error="Connection reset by host"g1[b3.channel][b3.replyChannel]=nil;if ge.process then ge.process.eventQueue[#ge.process.eventQueue+1]={"handle_status_change",{id=ge.id,status="error"}}end;return true end;local a5;if not ae.acknowledgement then syslog.debug("No acknowledgement")return end;if ge.status=="syn-received"then if ae.acknowledgement>=ge.sendSeq and ae.acknowledgement<=ge.sendSeqNext then ge.status="connected"ge.outQueue={}ge.nextUpdate=os.epoch"utc"+2000;if ge.process then ge.process.eventQueue[#ge.process.eventQueue+1]={"network_request",{uri=ge.uri,ip=fR(b3.sourceIP),handle=gl(ge)}}end;a5=true else g0.send.socket.reset(b3,b3.sourceIP,b3.replyChannel,ae.acknowledgement,nil,b3.channel)ge.status="error"ge.error="Connection reset by host"g1[b3.channel][b3.replyChannel]=nil;if ge.process then ge.process.eventQueue[#ge.process.eventQueue+1]={"handle_status_change",{id=ge.id,status="error"}}end;return true end elseif ge.status=="close-wait"then if ae.acknowledgement==ge.sendSeqMax then syslog.debug("Socket closed")ge.status="closed"g1[b3.channel][b3.replyChannel]=nil;if ge.process then ge.process.eventQueue[#ge.process.eventQueue+1]={"handle_status_change",{id=ge.id,status="closed"}}end;return true end elseif ge.status=="time-wait"then if ae.final then g0.send.socket.ack({},ae.sequence,ge)ge.nextUpdate=os.epoch"utc"+10000;return end else if ae.acknowledgement>ge.sendSeq and ae.acknowledgement<=ge.sendSeqNext then for v=ge.sendSeq,ae.acknowledgement do ge.outQueue[v]=nil end;ge.sendSeq=ae.acknowledgement;if ae.windowSize then ge.sendSeqMax=ge.sendSeq+ae.windowSize end end;if ge.status=="fin-wait"then if ae.acknowledgement==ge.sendSeqMax then if not ae.final then g0.send.socket.reset(b3,b3.sourceIP,b3.replyChannel,ae.acknowledgement,nil,b3.channel)ge.status="error"ge.error="Connection reset by host"g1[b3.channel][b3.replyChannel]=nil;if ge.process then ge.process.eventQueue[#ge.process.eventQueue+1]={"handle_status_change",{id=ge.id,status="error"}}end;return true end;ge.status="time-wait"ge.nextUpdate=os.epoch"utc"+10000 end elseif ge.status=="closing"then if ae.acknowledgement==ge.sendSeqMax then ge.status="time-wait"ge.nextUpdate=os.epoch"utc"+10000 end end end;if ge.status=="connected"and ae.sequence==ge.recvSeq then if ae.payload then ge.buffer=ge.buffer..ae.payload;ge.nextAck=true;ge.nextUpdate=os.epoch"utc"+100;if ge.process then syslog.debug("Sending data event to PID "..ge.process.id)ge.process.eventQueue[#ge.process.eventQueue+1]={"handle_data_ready",{id=ge.id}}end;a5=true end;ge.recvSeq=ge.recvSeq+1 end;if ae.final then syslog.debug("Got final message")ge.recvSeq=ae.sequence+1;if ge.status=="syn-received"or ge.status=="connected"then ge.sendSeqMax=ge.sendSeqNext;g0.send.socket.data({},{final=true,acknowledgement=ae.sequence},ge)ge.status="close-wait"if ge.process then ge.process.eventQueue[#ge.process.eventQueue+1]={"handle_status_change",{id=ge.id,status="closed"}}end;return true elseif ge.status=="fin-wait"then g0.send.socket.ack({},ae.sequence,ge)if ae.acknowledgement~=ge.sendSeqMax then ge.status="closing"else ge.status="time-wait"ge.nextUpdate=os.epoch"utc"+10000 end else g0.send.socket.ack({},ae.sequence,ge)end;syslog.debug(ge.status)end;return a5 end end;local function gn()local c7=os.epoch"utc"local ca=false;for gd,bd in pairs(g1)do for go,ge in pairs(bd)do if c7>=ge.nextUpdate then if ge.status=="syn-sent"then ge.status="error"ge.error="Connection timed out (syn-sent)"g1[gd][go]=nil;if ge.process then ge.process.eventQueue[#ge.process.eventQueue+1]={"handle_status_change",{id=ge.id,status="error"}}ca=true end elseif ge.status=="syn-received"then ge.retryCount=ge.retryCount+1;if ge.retryCount>3 then ge.status="error"ge.error="Connection timed out (syn-received)"g1[gd][go]=nil;if ge.process then ge.process.eventQueue[#ge.process.eventQueue+1]={"handle_status_change",{id=ge.id,status="error"}}ca=true end else ge.nextUpdate=os.epoch"utc"+2000 end elseif ge.status=="connected"then for v=ge.sendSeq+1,ge.sendSeqNext-1 do if ge.outQueue[v]then g0.send.socket.data({},{sequence=v,payload=ge.outQueue[v]},ge)end end;if ge.nextAck then g0.send.socket.ack({},ge.recvSeq-1,ge)ge.nextAck=nil end;ge.nextUpdate=os.epoch"utc"+2000 elseif ge.status=="fin-wait"then elseif ge.status=="close-wait"then elseif ge.status=="time-wait"then syslog.debug("Time wait finished on port "..gd)ge.status="closed"g1[gd][go]=nil end end end end;return ca end;eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(ar)if type(ar[5])=="table"and ar[5].PhoenixNetworking and type(ar[5].type)=="string"and g0.recv[ar[5].type]then local dJ=getNodeById(ar[2])or hardware.get(ar[2])if not dJ then syslog.log({level="notice",module="Network"},"Received network event for device ID "..ar[2]..", but no device node was found; ignoring")return end;if not fY[dJ.uuid]or not fY[dJ.uuid].up then return end;syslog.debug(ar[2],serialize(ar[5]))local bg,o=pcall(g0.recv[ar[5].type],{channel=ar[3],replyChannel=ar[4],device=dJ},ar[5])if not bg then syslog.log({level="debug",module="Network"},"Network event errored while processing:",o)else return o end end end;local gp=os.startTimer(1)eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=function(ar)if ar[2]==gp then gp=os.startTimer(1)return gn()end end;local function gq(process,bH)local fO=fN(bH.url)if not fO.port then error("No port specified")end;local fQ=fP(fO.host)local gd=fO.port;local ge={process=process,buffer=""}g0.send.socket.connect({process=process},fQ,gd,ge)return gl(ge)end;local gr={}local gs={}local gt={}local gu=os.computerID()%65500;local gv={}eventHooks.http_success=eventHooks.http_success or{}eventHooks.http_success[#eventHooks.http_success+1]=function(ar)local b3=gr[ar[2]]if b3 then b3.handle,b3.status=ar[3],"open"b3.process.eventQueue[#b3.process.eventQueue+1]={"handle_status_change",{id=b3.id,status="open"}}gr[ar[2]]=nil;return true else syslog.log({level="notice"},"Received HTTP response for "..ar[2].." but nobody requested it; ignoring.")end end;eventHooks.http_failure=eventHooks.http_failure or{}eventHooks.http_failure[#eventHooks.http_failure+1]=function(ar)local b3=gr[ar[2]]if b3 then if ar[4]then b3.handle,b3.status=ar[4],"open"else b3.status,b3.error="error",ar[3]end;b3.process.eventQueue[#b3.process.eventQueue+1]={"handle_status_change",{id=b3.id,status=b3.status}}gr[ar[2]]=nil;return true else syslog.log({level="notice"},"Received HTTP response for "..ar[2].." but nobody requested it; ignoring.")end end;eventHooks.websocket_success=eventHooks.websocket_success or{}eventHooks.websocket_success[#eventHooks.websocket_success+1]=function(ar)local b3=gr[ar[2]]if b3 then b3.handle,b3.status=ar[3],"open"b3.process.eventQueue[#b3.process.eventQueue+1]={"handle_status_change",{id=b3.id,status="open"}}return true else syslog.log({level="notice"},"Received WebSocket response for "..ar[2].." but nobody requested it; ignoring.")end end;eventHooks.websocket_failure=eventHooks.websocket_failure or{}eventHooks.websocket_failure[#eventHooks.websocket_failure+1]=function(ar)local b3=gr[ar[2]]if b3 then b3.status,b3.error="error",ar[3]b3.process.eventQueue[#b3.process.eventQueue+1]={"handle_status_change",{id=b3.id,status=b3.status}}return true else syslog.log({level="notice"},"Received WebSocket response for "..ar[2].." but nobody requested it; ignoring.")end end;eventHooks.websocket_message=eventHooks.websocket_message or{}eventHooks.websocket_message[#eventHooks.websocket_message+1]=function(ar)local b3=gr[ar[2]]if b3 then b3.buffer=b3.buffer..ar[3]b3.process.eventQueue[#b3.process.eventQueue+1]={"handle_data_ready",{id=b3.id}}return true else syslog.log({level="notice"},"Received WebSocket message for "..ar[2].." but nobody requested it; ignoring.")end end;eventHooks.websocket_closed=eventHooks.websocket_closed or{}eventHooks.websocket_closed[#eventHooks.websocket_closed+1]=function(ar)local b3=gr[ar[2]]if b3 then b3.status="closed"b3.process.eventQueue[#b3.process.eventQueue+1]={"handle_status_change",{id=b3.id,status=b3.status}}gr[ar[2]]=nil;return true else syslog.log({level="notice"},"Received WebSocket message for "..ar[2].." but it's not open; ignoring.")end end;eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(ar)local a5=false;if gs[ar[2]]and(ar[3]==gu or ar[3]==65535)and type(ar[5])=="table"and type(ar[5].nMessageID)=="number"and ar[5].nMessageID==ar[5].nMessageID and not gv[ar[5].nMessageID]and(ar[5].nRecipient and ar[5].nRecipient==os.computerID()or ar[3]==65535)then if gt[ar[5].nSender]then for z,i in ipairs(gt[ar[5].nSender])do if not i.protocol or i.protocol==ar[5].sProtocol then i.buffer[#i.buffer+1]=deepcopy(ar[5].message)gv[ar[5].nMessageID]=os.clock()+9.5;i.process.eventQueue[#i.process.eventQueue+1]={"handle_data_ready",{id=i.id}}a5=true end end end;if gt[0xFFFFFFFF]then for z,i in ipairs(gt[0xFFFFFFFF])do if not i.protocol or i.protocol==ar[5].sProtocol then i.buffer[#i.buffer+1]=deepcopy(ar[5].message)gv[ar[5].nMessageID]=os.clock()+9.5;i.process.eventQueue[#i.process.eventQueue+1]={"handle_data_ready",{id=i.id}}a5=true end end end;for h,i in pairs(gv)do if i<os.clock()then gv[h]=nil end end end;return a5 end;local gw=http.request;local function gx(process,bH)expect.field(bH,"encoding","string","nil")expect.field(bH,"headers","table","nil")expect.field(bH,"method","string","nil")expect.field(bH,"redirect","boolean","nil")local b3={status="ready",process=process,id=fX}local bA=setmetatable({id=fX},{__name="socket"})fX=fX+1;function bA:status()return b3.status,b3.error end;function bA:read(n,...)if b3.status~="open"then error("attempt to read from a "..b3.status.." handle",2)end;n=n or"*l"if type(n)~="string"and type(n)~="number"then error("bad argument (expected string or number, got "..type(n)..")",2)end;n=n:gsub("^%*","")if n=="a"then if select("#",...)>0 then return b3.handle.readAll(),self:read(...)else return b3.handle.readAll()end elseif n=="l"then if select("#",...)>0 then return b3.handle.readLine(false),self:read(...)else return b3.handle.readLine(false)end elseif n=="L"then if select("#",...)>0 then return b3.handle.readLine(true),self:read(...)else return b3.handle.readLine(true)end elseif n=="n"then local a0;repeat a0=b3.handle.read(1)if not a0 then return nil end until tonumber(a0)while true do local a9=b3.handle.read(1)if not a9 or not a9:match"%d"then break end;a0=a0 ..a9 end;if select("#",...)>0 then return tonumber(a0),self:read(...)else return tonumber(a0)end elseif type(n)=="number"then if select("#",...)>0 then return b3.handle.read(n),self:read(...)else return b3.handle.read(n)end else error("bad argument (invalid mode '"..n.."')",2)end end;function bA:write(...)if b3.status~="ready"then error("attempt to write to a "..b3.status.." handle",2)end;local bj;if select("#",...)>0 then bj=""for z,i in ipairs{...}do bj=bj..tostring(i)end end;local gy=bH.url.."#"..b3.id;local bg,o=gw{url=gy,body=bj,headers=bH.headers,binary=bH.encoding=="binary"or bH.encoding==nil,method=bH.method,redirect=bH.redirect}if bg then gr[gy]=b3;b3.status="connecting"else b3.status,b3.error="error",o end end;function bA:close()if b3.status~="open"then error("attempt to close a "..b3.status.." handle",2)end;b3.handle.close()b3.status="closed"end;function bA:responseHeaders()if b3.status~="open"then error("attempt to read from a "..b3.status.." handle",2)end;return b3.handle.getResponseHeaders()end;function bA:responseCode()if b3.status~="open"then error("attempt to read from a "..b3.status.." handle",2)end;return b3.handle.getResponseCode()end;return bA end;local function gz(process,bH)expect.field(bH,"encoding","string","nil")expect.field(bH,"headers","table","nil")local b3={process=process,id=fX,buffer=""}local bA=setmetatable({id=fX},{__name="socket"})fX=fX+1;function bA:status()return b3.status,b3.error end;function bA:read(n,...)if b3.status~="open"then error("attempt to read from a "..b3.status.." handle",2)end;n=n or"*l"if type(n)~="string"and type(n)~="number"then error("bad argument (expected string or number, got "..type(n)..")",2)end;if b3.buffer==""then return nil end;n=n:gsub("^%*","")if n=="a"then local a0=b3.buffer;b3.buffer=""return a0 elseif n=="l"then local a0,a7=b3.buffer:match"^([^\n]*)\n?()"if a0 then b3.buffer=b3.buffer:sub(a7)if select("#",...)>0 then return a0,self:read(...)else return a0 end else return nil end elseif n=="L"then local a0,a7=b3.buffer:match"^([^\n]*\n?)()"if a0 then b3.buffer=b3.buffer:sub(a7)if select("#",...)>0 then return a0,self:read(...)else return a0 end else return nil end elseif n=="n"then local a0,a7=b3.buffer:match"(%d+)()"if a0 then b3.buffer=b3.buffer:sub(a7)if select("#",...)>0 then return tonumber(a0),self:read(...)else return tonumber(a0)end else return nil end elseif type(n)=="number"then local a0=b3.buffer:sub(1,n)b3.buffer=b3.buffer:sub(n+1)if select("#",...)>0 then return a0,self:read(...)else return a0 end else error("bad argument (invalid mode '"..n.."')",2)end end;function bA:write(bj,...)if b3.status~="open"then error("attempt to write to a "..b3.status.." handle",2)end;b3.handle.send(tostring(bj),bH.encoding=="binary")if select("#",...)>0 then return self:write(...)end end;function bA:close()if b3.status~="open"then error("attempt to close a "..b3.status.." handle",2)end;b3.handle.close()b3.status="closed"end;local gy=bH.url.."#"..b3.id;local bg,o=http.websocket(gy,bH.headers)if bg then gr[gy]=b3;b3.status="connecting"else return nil,o end;return bA end;local function gA(process,bH)expect.field(bH,"device","string","nil")local gB;if bH.device then gB={hardware.get(bH.device)}else gB={hardware.find("modem")}end;if#gB==0 then error("Could not find a modem",2)end;for z,i in ipairs(gB)do fW(i)if not gs[i]then hardware.call(process,i,"open",gu)hardware.call(process,i,"open",65535)gs[i]=1 else gs[i]=gs[i]+1 end end;local fO=fN(bH.url)if not fO.host then error("Missing host",2)end;local aA=fP(fO.host)local b3={process=process,id=fX,buffer={},protocol=fO.scheme:match"rednet%+(.+)"}local bA=setmetatable({id=fX},{__name="socket"})fX=fX+1;function bA:status()return b3.closed and"closed"or"open"end;function bA:read(n,...)if b3.closed then error("attempt to read from a "..b3.status.." handle",2)end;n=n or"*l"if type(n)~="string"and type(n)~="number"then error("bad argument (expected string or number, got "..type(n)..")",2)end;if#b3.buffer==0 then return nil end;n=n:gsub("^%*","")if n=="a"then return table.remove(b3.buffer,1)elseif n=="l"then b3.buffer[1]=tostring(b3.buffer[1])local a0,a7=b3.buffer[1]:match"^([^\n]*)\n?()"if a0 then b3.buffer[1]=b3.buffer[1]:sub(a7)if select("#",...)>0 then return a0,self:read(...)else return a0 end else table.remove(b3.buffer,1)return self:read(n,...)end elseif n=="L"then b3.buffer[1]=tostring(b3.buffer[1])local a0,a7=b3.buffer[1]:match"^([^\n]*\n?)()"if a0 then b3.buffer[1]=b3.buffer[1]:sub(a7)if select("#",...)>0 then return a0,self:read(...)else return a0 end else table.remove(b3.buffer,1)return self:read(n,...)end elseif n=="n"then b3.buffer[1]=tostring(b3.buffer[1])local a0,a7=b3.buffer[1]:match"(%d+)()"if a0 then b3.buffer[1]=b3.buffer[1]:sub(a7)if select("#",...)>0 then return tonumber(a0),self:read(...)else return tonumber(a0)end else table.remove(b3.buffer,1)return self:read(n,...)end elseif type(n)=="number"then local a0=""while#a0<n do b3.buffer[1]=tostring(b3.buffer[1])a0=a0 ..b3.buffer[1]:sub(1,n-#a0)b3.buffer[1]=b3.buffer[1]:sub(n-#a0+1)if b3.buffer[1]==""then table.remove(b3.buffer,1)end;if#b3.buffer==0 then break end end;if select("#",...)>0 then return a0,self:read(...)else return a0 end else error("bad argument (invalid mode '"..n.."')",2)end end;function bA:write(bj,...)if b3.closed then error("attempt to write to a "..b3.status.." handle",2)end;local gC=math.random(1,0x7FFFFFFF)local eb={nMessageID=gC,nRecipient=aA,nSender=os.computerID(),message=bj,sProtocol=b3.protocol}if aA==os.computerID()then for z,i in ipairs(gB)do os.queueEvent("modem_message",i.id,gu,gu,eb,0)end else gv[gC]=os.clock()+9.5;for z,i in ipairs(gB)do hardware.call(process,i,"transmit",aA==0xFFFFFFFF and 65535 or aA%65500,gu,eb)hardware.call(process,i,"transmit",65533,gu,eb)end end;if select("#",...)>0 then return self:write(...)end end;function bA:close()if b3.closed then error("attempt to close a "..b3.status.." handle",2)end;for z,i in ipairs(gB)do gs[i]=gs[i]-1;if gs[i]==0 then hardware.call(process,i,"close",gu)hardware.call(process,i,"close",65535)gs[i]=nil end end;b3.status="closed"end;return bA end;uriSchemes={["https?"]=gx,["wss?"]=gz,["rednet"]=gA,["rednet%+%a+"]=gA,["psp"]=gq}function syscalls.connect(process,aq,bH)if type(bH)=="string"then bH={url=bH}end;expect(1,bH,"table")expect.field(bH,"url","string")local fO=fN(bH.url)local bA,o;for h,i in pairs(uriSchemes)do if fO.scheme:match(h)then bA,o=i(process,bH)break end end;if not bA and not o then error("Invalid protocol "..fO.scheme)end;if bA then for z,i in pairs(bA)do if type(i)=="function"then setfenv(i,process.env)debug.protect(i)end end end;return bA,o end;function syscalls.listen(process,aq,fO)expect(1,fO,"string")local gD=fN(fO)if http.addListener then if gD.scheme=="http"then http.addListener(gD.port or 80)return elseif gD.scheme=="ws"then http.websocket(gD.port or 80)return end end;if gD.scheme=="psp"then if not gD.port then error("Missing port")end;local fQ=fP(gD.host)for h,i in pairs(fY)do if i.up and(fQ==0 or i.ip==fQ)then hardware.call(process,hardware.get(h),"open",gD.port)end end;local ge={localPort=gD.port,id=fX,status="listening",process=process,nextUpdate=math.huge,retryCount=0,uri=fO,buffer=""}fX=fX+1;g1[gD.port]=g1[gD.port]or{}g1[gD.port].listen=ge;g2[ge.id]=ge;return end;error("Invalid protocol "..gD.scheme)end;function syscalls.unlisten(process,aq,fO)end;function syscalls.ipconfig(process,aq,f0,b3)if b3 and process.user~="root"then error("Permission denied")end;expect(1,f0,"string")expect(2,b3,"table","nil")local dJ=fW(hardware.get(f0))local y=fY[dJ.uuid]if not y then if b3 then expect.field(b3,"ip","string","number")expect.field(b3,"netmask","string","number")y={up=true}fY[dJ.uuid]=y;hardware.call(KERNEL,dJ,"open",0)else return nil end end;if b3 then expect.field(b3,"ip","string","number","nil")expect.field(b3,"netmask","string","number","nil")expect.field(b3,"up","boolean","nil")local gE,gF;if y.ip then for z,i in ipairs(fZ[0])do if i.source==bit32.band(y.ip,y.netmask)and i.netmask==y.netmask then gE=i elseif i.source==bit32.bor(bit32.band(y.ip,y.netmask),bit32.bnot(y.netmask))and i.netmask==0xFFFFFFFF then gF=i end end end;if b3.ip then if f_[dJ.uuid]then f_[dJ.uuid][y.ip]=nil end;if type(b3.ip)=="number"then y.ip=bit32.band(b3.ip,0xFFFFFFFF)else y.ip=fP(b3.ip)end;if gE then gE.source=bit32.band(y.ip,y.netmask)end;if gF then gF.source=bit32.bor(bit32.band(y.ip,y.netmask),bit32.bnot(y.netmask))end;f_[dJ.uuid]=f_[dJ.uuid]or{}f_[dJ.uuid][y.ip]=os.computerID()end;if b3.netmask then if type(b3.netmask)=="number"then y.netmask=fU(b3.netmask)else y.netmask=fP(b3.netmask)end;if gE then gE.source=bit32.band(y.ip,y.netmask)end;if gF then gF.source=bit32.bor(bit32.band(y.ip,y.netmask),bit32.bnot(y.netmask))end end;if b3.up~=nil then y.up=b3.up;if y.up then hardware.call(KERNEL,dJ,"open",0)else hardware.call(KERNEL,dJ,"close",0)end end;if not gE then fZ[0][#fZ[0]+1]={source=bit32.band(y.ip,y.netmask),sourceNetmask=y.netmask,action="local",device=dJ}end;if not gF then fZ[0][#fZ[0]+1]={source=bit32.bor(bit32.band(y.ip,y.netmask),bit32.bnot(y.netmask)),sourceNetmask=0xFFFFFFFF,action="broadcast",device=dJ}end end;return{ip=fR(y.ip),netmask=fV(y.netmask),up=y.up}end;function syscalls.routelist(process,aq,b)b=expect(1,b,"number","nil")or 1;expect.range(b,0)if not fZ[b]then return nil end;local a5={}for v,y in ipairs(fZ[b])do a5[v]={source=fR(y.source),sourceNetmask=fV(y.sourceNetmask),action=y.action,device=y.device and hardware.path(y.device),destination=y.destination and fR(y.destination)}end;return a5 end;local gG={unicast=true,broadcast=true,["local"]=true,unreachable=true,prohibit=true,blackhole=true}function syscalls.routeadd(process,aq,bH)if process.user~="root"then error("Permission denied")end;expect(1,bH,"table")expect.field(bH,"source","string","number")expect.field(bH,"sourceNetmask","string","number")expect.field(bH,"action","string")expect.field(bH,"device","string",bH.action~="unicast"and bH.action~="broadcast"and bH.action~="local"and"nil"or nil)expect.field(bH,"destination","string",bH.action~="unicast"and"nil"or nil)expect.range(expect.field(bH,"table","number","nil")or 1,1)bH.table=bH.table or 1;if not gG[bH.action]then error("bad field 'action' (invalid option '"..bH.action.."')")end;local y={}if type(bH.source)=="number"then y.source=bit32.band(bH.source,0xFFFFFFFF)else y.source=fP(bH.source)end;if type(bH.sourceNetmask)=="number"then y.sourceNetmask=fU(bH.sourceNetmask)else y.sourceNetmask=fP(bH.sourceNetmask)end;y.source=bit32.band(y.source,y.sourceNetmask)y.action=bH.action;y.device=bH.device and fW(hardware.get(bH.device))y.destination=bH.destination and fP(bH.destination)fZ[bH.table]=fZ[bH.table]or{}for z,i in ipairs(fZ[bH.table])do if i.source==y.source and i.sourceNetmask==y.sourceNetmask then error("Route already exists")end end;fZ[bH.table][#fZ[bH.table]+1]=y;fZ.maxn=math.max(fZ.maxn,bH.table)end;function syscalls.routedel(process,aq,gH,w,b)if process.user~="root"then error("Permission denied")end;expect(1,gH,"string","number")expect(2,w,"string","number")b=expect(3,b,"number","nil")or 1;expect.range(b,1)if type(w)=="number"then w=fU(w)else w=fP(w)end;if type(gH)=="number"then gH=bit32.band(gH,w)else gH=bit32.band(fP(gH),w)end;if not fZ[b]then error("Route table does not exist")end;for v,i in ipairs(fZ[b])do if i.source==gH and i.sourceNetmask==w then table.remove(fZ[b],v)return end end end;function syscalls.arplist(process,aq,f0)expect(1,f0,"string")local dJ=fW(hardware.get(f0))local a5={}for h,i in pairs(f_[dJ.uuid]or{})do a5[fR(h)]=i end;return a5 end;function syscalls.arpset(process,aq,f0,fQ,aA)if process.user~="root"then error("Permission denied")end;expect(1,f0,"string")expect(2,fQ,"string","number")expect(3,aA,"number")local dJ=fW(hardware.get(f0))if type(fQ)=="string"then fQ=fP(fQ)else fQ=bit32.band(fQ,0xFFFFFFFF)end;f_[dJ.uuid]=f_[dJ.uuid]or{}f_[dJ.uuid][fQ]=aA end;local gI={ping=true,pong=true,unreachable=true,timeout=true}function syscalls.netcontrol(process,aq,fQ,gJ,o)if process.user~="root"then error("Permission denied")end;expect(1,fQ,"string","number")expect(2,gJ,"string")expect(3,o,"string","nil")if not gI[gJ]then error("bad argument #2 (invalid option '"..gJ.."')")end;if type(fQ)=="string"then fQ=fP(fQ)else fQ=bit32.band(fQ,0xFFFFFFFF)end;g0.send.control({process=process},fQ,gJ,o)end;function syscalls.netevent(process,aq,dn)if process.user~="root"then error("Permission denied")end;expect(1,dn,"boolean","nil")if dn==true then g3[process]=function(ae)process.eventQueue[#process.eventQueue+1]={"network_event",deepcopy(ae)}return true end elseif dn==false then g3[process]=nil end;return g3[process]~=nil end;function syscalls.checkuri(process,aq,fO)end;function registerLoopback()local dJ=hardware.get("/lo")if dJ then fY[dJ.uuid]={ip=0x7F000001,netmask=0xFF000000,up=true}fZ[0][#fZ[0]+1]={source=0x7F000000,sourceNetmask=0xFF000000,action="local",device=dJ}fZ[0][#fZ[0]+1]={source=0x7FFFFFFF,sourceNetmask=0xFFFFFFFF,action="broadcast",device=dJ}f_[dJ.uuid]=setmetatable({},{__index=function()return os.computerID()end})syslog.log("Configured IP for loopback device")end end;function syscalls.listmodules()local a5={}for h in pairs(modules)do a5[#a5+1]=h end;return a5 end;function syscalls.loadmodule(process,aq,bb)expect(1,bb,"string")if process.user~="root"then error("Could not load kernel module: Permission denied",2)end;local bI=filesystem.stat(process,bb)if bI.type=="directory"then error("Could not load kernel module: Is a directory",2)end;if bI.owner~="root"or bI.worldPermissions.write then error("Insecure permissions set on kernel module, refusing to load",2)end;local m=bb:match"([^%./]+)[^/]*$"syslog.log("Loading kernel module "..m.." from "..bb)local a,o=filesystem.open(process,bb,"rb")if a then local bj=a.readAll()or""a.close()local g,o=load(bj,"@"..bb)if g then local bg,u=pcall(g,bb)if bg then modules[m]=u or true else syslog.log({level="error"},"Kernel module "..m.." threw an error:",u)end else syslog.log({level="error"},"Could not load "..m..":",o)end else syslog.log({level="error"},"Could not open "..bb..":",o)end end;function syscalls.unloadmodule(process,aq,m)expect(1,m,"string")if process.user~="root"then error("Could not load kernel module: Permission denied",2)end;if type(modules[m])=="table"and modules[m].unload then modules[m].unload(process,aq)end;modules[m]=nil end;function syscalls.callmodule(process,aq,m,az,...)expect(1,m,"string")expect(2,az,"string")if not modules[m]then error("Module '"..m.."' does not exist",2)elseif type(modules[m])~="table"then error("Module '"..m.."' does not have a callable interface",2)elseif az=="unload"or type(modules[m][az])~="function"then error("Module '"..m.."' does not have a method '"..az.."'",2)end;return modules[m][az](process,aq,...)end;syslog.log("Loading kernel modules from /lib/modules")local bg,gK=pcall(filesystem.list,KERNEL,"/lib/modules")if bg then for z,i in ipairs(gK)do local E=filesystem.combine("/lib/modules",i)local bI=filesystem.stat(KERNEL,E)if bI.type~="directory"then local bg,o=pcall(syscalls.loadmodule,KERNEL,nil,E)if not bg then syslog.log({level="error"},"Could not load module from "..E..": "..o)end end end else syslog.log({level="notice"},"Could not open /lib/modules:",gK)end;xpcall(hardware.register,function(error)panic("An error occurred while registering devices: "..error)end,deviceTreeRoot,rootDriver)local ap={n=0}local gL=processes[syscalls.fork(KERNEL,nil,function()end,"init")]local gM=gL.id;local gN,gO;if args.init then gN,gO=pcall(syscalls.exec,gL,nil,args.initrd and"/init"or args.init)end;if not gN then syslog.log({level="error",process=0},"Could not load init:",gO)syslog.log("Could not find provided init, trying default locations")for z,i in ipairs{"/sbin/init","/etc/init","/bin/init","/bin/sh"}do syslog.log("Trying",i)gN,gO=pcall(syscalls.exec,gL,nil,i)if not gN then syslog.log({level="error",process=0},"Could not load init:",gO)end;if gN then break end end;if not gN then panic("No working init found")end end;syslog.log("Starting init from "..processes[gM].name)local at=false;local gP=coroutine.yield;function coroutine.yield(...)if coroutine.running()==mainThread then error("attempt to yield from kernel main thread",2)end;return gP(...)end;debug.protect(coroutine.yield)eventHooks.key=eventHooks.key or{}eventHooks.key[#eventHooks.key+1]=function(ar)if keysHeld.ctrl and keysHeld.shift and ar[2]==keys.f10 then term.clear()term.setCursorPos(1,1)term.write("Entering debug console.")local q=2;local aW=true;term.setCursorPos(1,q)while aW do local aj=""local af,ag=term.getSize()term.write("lua> ")term.setCursorBlink(true)while true do local ar={gP()}if ar[1]=="char"or ar[1]=="paste"then aj=aj..ar[2]term.write(ar[2])elseif ar[1]=="key"then if ar[2]==keys.backspace and#aj>0 then aj=aj:sub(1,-2)term.setCursorPos(term.getCursorPos()-1,q)term.write(" ")term.setCursorPos(term.getCursorPos()-1,q)elseif ar[2]==keys.enter then break end end end;q=q+1;if q>ag then q=q-1;term.scroll(1)end;term.setCursorPos(1,q)local g,o=load("return "..aj,"=lua","t",setmetatable({exit=function()aW=false end},{__index=_G}))if not g then g,o=load(aj,"=lua","t",setmetatable({exit=function()aW=false end},{__index=_G}))end;if g then local u=table.pack(pcall(g))if u[1]then for v=2,u.n do term.write(tostring(u[v]))q=q+1;if q>ag then q=q-1;term.scroll(1)end;term.setCursorPos(1,q)end else term.setTextColor(16384)term.write(u[2])term.setTextColor(1)q=q+1;if q>ag then q=q-1;term.scroll(1)end;term.setCursorPos(1,q)end else term.setTextColor(16384)term.write(o)term.setTextColor(1)q=q+1;if q>ag then q=q-1;term.scroll(1)end;term.setCursorPos(1,q)end end;term.setCursorBlink(false)term.clear()terminal.redraw(currentTTY,true)end end;local gQ={char=true,key=true,key_up=true,mouse_click=true,mouse_up=true,mouse_drag=true,mouse_scroll=true,paste=true}local bg,o=xpcall(function()while processes[gM]do if not at then os.queueEvent("__event_queue_back")end;while true do local ar=table.pack(gP())local m=ar[1]if m=="__event_queue_back"then break end;local gR=false;if eventHooks[m]then for z,i in ipairs(eventHooks[m])do gR=i(ar)or gR end end;if eventParameterMap[m]then local av={}for v=2,#eventParameterMap[m]+1 do av[eventParameterMap[m][v-1]]=ar[v]end;if m=="key"or m=="key_up"then av.keycode=keymap[av.keycode]av.ctrlHeld=keysHeld.ctrl;av.altHeld=keysHeld.alt;av.shiftHeld=keysHeld.shift end;if gQ[m]and currentTTY.frontmostProcess then currentTTY.frontmostProcess.eventQueue[#currentTTY.frontmostProcess.eventQueue+1]={m,av}gR=true elseif m=="timer"or m=="alarm"then local gS;if m=="timer"then gS=timerMap[ar[2]]else gS,av.id=alarmMap[ar[2]],bit32.bor(av.id,0x80000000)end;if gS then gS.eventQueue[#gS.eventQueue+1],gR={m,av},true end end end;if at and gR then break end end;at=true;for cY,process in pairs(processes)do if cY~=0 and not process.paused then local fr,ar=false,nil;local as=true;for ft,aq in pairs(process.threads)do if not fr and aq.status=="suspended"then ar=table.remove(process.eventQueue,1)fr=true end;if ar or aq.status~="suspended"then local gT;as,gT=executeThread(process,aq,ar or ap,as,at)at=gT and at else as=false end end;if as then process.isDead=true;if process.lastReturnValue then if cY==gM then init_retval=process.lastReturnValue.value or process.lastReturnValue.error elseif processes[process.parent]then process.lastReturnValue.id=cY;processes[process.parent].eventQueue[#processes[process.parent].eventQueue+1]={"process_complete",process.lastReturnValue}end end;reap_process(process)processes[cY]=nil;at=false end end end;terminal.redraw(currentTTY)end end,debug.traceback)if not bg then syslog.log({level="critical",traceback=true},o)end;if postkill then postkill()end;if init_retval~=nil then syslog.log({level=4},"init exited with result",init_retval)end;panic("init program exited")
