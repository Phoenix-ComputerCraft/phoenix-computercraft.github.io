PHOENIX_VERSION="0.0.7"PHOENIX_BUILD="PRERELEASE NONFREE Sat Aug 31 14:38:54 2024"systemStartTime=os.epoch"utc"args={init="/sbin/init.lua",root="/root",rootfstype="craftos",preemptive=true,quantum=20000,splitkernpath="/boot/kernel.lua.d",loglevel=1,console="tty1",traceback=true}syscalls={}processes={[0]={name="kernel",id=0,user="root",dir="/",root="/",env=_G,vars={},dependents={}}}KERNEL=processes[0]modules={}eventHooks={}shutdownHooks={}kSyscallYield={}kSyscallComplete={}process={}filesystem={}terminal={}user={}syslog={}hardware={}if discord then discord("Phoenix","Booting Phoenix "..PHOENIX_VERSION)end;do local a=fs.open("/rom/modules/main/cc/expect.lua","r")expect=(loadstring or load)(a.readAll(),"@/rom/modules/main/cc/expect.lua")()a.close()setmetatable(expect,{__call=function(self,...)return self.expect(...)end})if not expect.range then function expect.range(b,c,d)expect(1,b,"number")expect(2,c,"number","nil")expect(3,d,"number","nil")if d and c and d<c then error("bad argument #3 (min must be less than or equal to max)",2)end;if b~=b or b<(c or-math.huge)or b>(d or math.huge)then error(("number outside of range (expected %s to be within %s and %s)"):format(b,c or-math.huge,d or math.huge),3)end;return b end end end;do local a=fs.open("/rom/apis/textutils.lua","r")local e=setmetatable({dofile=function(g)if g=="rom/modules/main/cc/expect.lua"then return expect elseif g=="rom/modules/main/cc/require.lua"then return{make=function()return function(h)if h=="cc.expect"then return expect else return{}end end end}end end},{__index=_G})local i;if loadstring and setfenv then i=loadstring(a.readAll(),"@/rom/apis/textutils.lua")setfenv(i,e)else i=load(a.readAll(),"@/rom/apis/textutils.lua","t",e)end;a.close()i()serialize,unserialize=e.serialize,e.unserialize end;do local a=fs.open("/rom/apis/keys.lua","r")local e=setmetatable({dofile=function()return expect end},{__index=_G})if _VERSION<"Lua 5.2"then e._ENV=e end;local i;if loadstring and setfenv then i=loadstring(a.readAll(),"@/rom/apis/keys.lua")setfenv(i,e)else i=load(a.readAll(),"@/rom/apis/keys.lua","t",e)end;a.close()i()keys={}for j,k in pairs(e)do keys[j]=k end end;if not pcall(load,"return","=test","t",{})then local l,m,expect,setfenv=load,loadstring,expect,setfenv;function load(n,o,p,e)expect(1,n,"string","function")expect(2,o,"string","nil")expect(3,p,"string","nil")expect(4,e,"table","nil")if type(n)=="string"then if n:sub(1,4)=="\27Lua"then if p==nil or p:find"b"then local i,q=m(n,o)if i and e then setfenv(i,e)end;return i,q else return nil,"attempt to load a binary chunk (mode is '"..(p or"bt").."')"end else if p==nil or p:find"t"then local i,q=m(n,o)if i and e then setfenv(i,e)end;return i,q else return nil,"attempt to load a text chunk (mode is '"..(p or"bt").."')"end end else local i,q=l(n,o)if i then setfenv(i,e)end;return i,q end end end;loadstring=nil;if bit then if not bit32 then local bit=bit;bit32={bnot=bit.bnot,lshift=bit.blshift,rshift=bit.blogic_rshift,arshift=bit.brshift}function bit32.band(r,s,...)expect(1,r,"number")expect(2,s,"number","nil")if not s then return r end;return bit32.band(bit.band(r,s),...)end;function bit32.bor(r,s,...)expect(1,r,"number")expect(2,s,"number","nil")if not s then return r end;return bit32.bor(bit.bor(r,s),...)end;function bit32.bxor(r,s,...)expect(1,r,"number")expect(2,s,"number","nil")if not s then return r end;return bit32.bxor(bit.bxor(r,s),...)end;function bit32.btest(...)return bit32.band(...)~=0 end;function bit32.extract(t,u,v)expect(1,t,"number")expect(2,u,"number")expect(3,v,"number","nil")(expect.range or function()end)(u,0,31)(expect.range or function()end)(u+v-1,0,31)v=v or 1;local w=0;for x=u+v-1,u,-1 do w=w*2+bit.band(t,2^x)/2^x end;return w end;function bit32.replace(t,k,u,v)expect(1,t,"number")expect(2,k,"number")expect(3,u,"number")expect(4,v,"number","nil")(expect.range or function()end)(u,0,31)(expect.range or function()end)(u+v-1,0,31)v=v or 1;local y=2^v-1;return bit.bor(bit.band(t,bit.bnot(bit.blshift(y,u))),bit.blshift(bit.band(k,y),u))end;function bit32.lrotate(r,z)return bit.bor(bit.blshift(r,z),bit.blogic_rshift(r,32-z))end;function bit32.rrotate(r,z)return bit.bor(bit.blogic_rshift(r,z),bit.blshift(r,32-z))end end;bit=nil end;if _VERSION=="Lua 5.1"and load("::a:: goto a")then _VERSION="Lua 5.2"if load("return 1 >> 2 & 3")then _VERSION="Lua 5.3"if load("local <const> a = 2")then _VERSION="Lua 5.4"end end end;if _VERSION=="Lua 5.1"then if not table.pack then table.pack=function(...)local A={...}A.n=select("#",...)return A end end;if not table.unpack then table.unpack,unpack=unpack,nil end;local B,k=xpcall(function(C)return C end,function()end,true)if not k then local D=xpcall;xpcall=function(f,E,...)if select("#",...)>0 then local args=table.pack(...)return D(function()return f(table.unpack(args,1,args.n))end,E)else return D(f,E)end end end end;if tonumber(_HOST:match"ComputerCraft 1.(%d+)")<95 then local F=fs.combine;function fs.combine(G,...)if...~=nil then return F(G,fs.combine(...))else return G end end end;if not string.pack then local expect=expect.expect;local H={BIG_ENDIAN=1,LITTLE_ENDIAN=2}local I={b=1,B=1,h=1,H=1,l=1,L=1,j=1,J=1,T=1}local J={b=1,B=1,x=1,h=2,H=2,f=4,j=4,J=4,l=8,L=8,T=8,d=8,n=8}local function K(t)if t%1>=0.5 then return math.ceil(t)else return math.floor(t)end end;local function L(f)if f==0 then return 0 elseif f==-0 then return 0x80000000 elseif f==math.huge then return 0x7F800000 elseif f==-math.huge then return 0xFF800000 end;local C,M=math.frexp(f)if M>127 or M<-126 then error("number out of range",3)end;M,C=M+126,K((math.abs(C)-0.5)*0x1000000)if C>0x7FFFFF then M=M+1 end;return bit32.bor(f<0 and 0x80000000 or 0,bit32.lshift(bit32.band(M,0xFF),23),bit32.band(C,0x7FFFFF))end;local function N(f)if f==0 then return 0,0 elseif f==-0 then return 0x80000000,0 elseif f==math.huge then return 0x7FF00000,0 elseif f==-math.huge then return 0xFFF00000,0 end;local C,M=math.frexp(f)if M>1023 or M<-1022 then error("number out of range",3)end;M,C=M+1022,K((math.abs(C)-0.5)*0x20000000000000)if C>0xFFFFFFFFFFFFF then M=M+1 end;return bit32.bor(f<0 and 0x80000000 or 0,bit32.lshift(bit32.band(M,0x7FF),20),bit32.band(C/0x100000000,0xFFFFF)),bit32.band(C,0xFFFFFFFF)end;local function O(P)if P==0 then return 0 elseif P==0x80000000 then return-0 elseif P==0x7F800000 then return math.huge elseif P==0xFF800000 then return-math.huge end;local C,M=bit32.band(P,0x7FFFFF),bit32.band(bit32.rshift(P,23),0xFF)M,C=M-126,C/0x1000000+0.5;local t=math.ldexp(C,M)return bit32.btest(P,0x80000000)and-t or t end;local function Q(R,S)if R==0 and S==0 then return 0 elseif R==0x80000000 and S==0 then return-0 elseif R==0x7FF00000 and S==0 then return math.huge elseif R==0xFFF00000 and S==0 then return-math.huge end;local C,M=bit32.band(R,0xFFFFF)*0x100000000+bit32.band(S,0xFFFFFFFF),bit32.band(bit32.rshift(R,20),0x7FF)M,C=M-1022,C/0x20000000000000+0.5;local t=math.ldexp(C,M)return bit32.btest(R,0x80000000)and-t or t end;local function T(b,U,V,W,X,Y,Z)local _=0;if W%math.min(U,X)~=0 and X>1 then local x=0;while W%math.min(U,X)~=0 and x<X do V[W]=0;W=W+1;_=_+1;x=x+1 end end;if Y==H.BIG_ENDIAN then local a0=0;if U>8 then for x=0,U-9 do V[W+x]=Z and b>=2^(U*8-1)~=0 and 0xFF or 0;a0=a0+1;_=_+1 end end;for x=a0,U-1 do V[W+x]=bit32.band(bit32.rshift(b,(U-x-1)*8),0xFF)_=_+1 end else for x=0,math.min(U,8)-1 do V[W+x]=b/2^(x*8)%256;_=_+1 end;for x=8,U-1 do V[W+x]=Z and b>=2^(U*8-1)~=0 and 0xFF or 0;_=_+1 end end;return _ end;local function a1(a2,W,U,Y,X,Z)local a3,a4=0,0;if W%math.min(U,X)~=0 and X>1 then for x=0,X-1 do if W%math.min(U,X)==0 then break end;W=W+1;a4=a4+1 end end;for x=0,U-1 do a3=a3+a2:byte(W+x)*2^((Y==H.BIG_ENDIAN and U-x-1 or x)*8)a4=a4+1 end;if Z and a3>=2^(U*8-1)then a3=a3-2^(U*8)end;return a3,a4 end;local function a5(a6,X)local a7=J[a6]or 0;if X>1 and a7%X~=0 then a7=a7+X-a7%X end;return a7 end;function string.pack(...)local a8=expect(1,...,"string")local Y=H.LITTLE_ENDIAN;local X=1;local a9=1;local aa=2;local V={}local x=1;while x<=#a8 do local ab=a8:sub(x,x)x=x+1;if ab=='='or ab=='<'then Y=H.LITTLE_ENDIAN elseif ab=='>'then Y=H.BIG_ENDIAN elseif ab=='!'then local U=-1;while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=math.max(U,0)*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 or U==0 then error(string.format("integral size (%d) out of limits [1,16]",U),2)elseif U==-1 then X=4 else X=U end elseif I[ab]then local b=expect(aa,select(aa,...),"number")aa=aa+1;if b>=math.pow(2,a5(ab,0)*8-(ab:match("%l")and 1 or 0))or b<(ab:match("%l")and-math.pow(2,a5(ab,0)*8-1)or 0)then error(string.format("bad argument #%d to 'pack' (integer overflow)",aa-1),2)end;a9=a9+T(b,a5(ab,0),V,a9,X,Y,false)elseif ab:lower()=='i'then local Z=ab=='i'local U=-1;while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=math.max(U,0)*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 or U==0 then error(string.format("integral size (%d) out of limits [1,16]",U),2)elseif X>1 and(U~=1 and U~=2 and U~=4 and U~=8 and U~=16)then error("bad argument #1 to 'pack' (format asks for alignment not power of 2)",2)elseif U==-1 then U=4 end;local b=expect(aa,select(aa,...),"number")aa=aa+1;if b>=math.pow(2,U*8-(ab:match("%l")and 1 or 0))or b<(ab:match("%l")and-math.pow(2,U*8-1)or 0)then error(string.format("bad argument #%d to 'pack' (integer overflow)",aa-1),2)end;a9=a9+T(b,U,V,a9,X,Y,Z)elseif ab=='f'then local f=expect(aa,select(aa,...),"number")aa=aa+1;local P=L(f)if a9%math.min(4,X)~=0 and X>1 then for ac=0,X-1 do if a9%math.min(4,X)==0 then break end;V[a9]=0;a9=a9+1 end end;for ac=0,3 do V[a9+(Y==H.BIG_ENDIAN and 3-ac or ac)]=bit32.band(bit32.rshift(P,ac*8),0xFF)end;a9=a9+4 elseif ab=='d'or ab=='n'then local f=expect(aa,select(aa,...),"number")aa=aa+1;local R,S=N(f)if a9%math.min(8,X)~=0 and X>1 then for ac=0,X-1 do if a9%math.min(8,X)==0 then break end;V[a9]=0;a9=a9+1 end end;for ac=0,3 do V[a9+(Y==H.BIG_ENDIAN and 7-ac or ac)]=bit32.band(bit32.rshift(S,ac*8),0xFF)end;for ac=4,7 do V[a9+(Y==H.BIG_ENDIAN and 7-ac or ac)]=bit32.band(bit32.rshift(R,(ac-4)*8),0xFF)end;a9=a9+8 elseif ab=='c'then local U=0;if x>#a8 or not a8:sub(x,x):match("%d")then error("missing size for format option 'c'",2)end;while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if a9+U<a9 or a9+U>0xFFFFFFFF then error("bad argument #1 to 'pack' (format result too large)",2)end;local a2=expect(aa,select(aa,...),"string")aa=aa+1;if#a2>U then error(string.format("bad argument #%d to 'pack' (string longer than given size)",aa-1),2)end;if U>0 then for ac=0,U-1 do V[a9+ac]=a2:byte(ac+1)or 0 end;a9=a9+U end elseif ab=='z'then local a2=expect(aa,select(aa,...),"string")aa=aa+1;for ad in a2:gmatch"."do if ad=='\0'then error(string.format("bad argument #%d to 'pack' (string contains zeros)",aa-1),2)end end;for ac=0,#a2-1 do V[a9+ac]=a2:byte(ac+1)end;V[a9+#a2]=0;a9=a9+#a2+1 elseif ab=='s'then local U=0;while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 then error(string.format("integral size (%d) out of limits [1,16]",U),2)elseif U==0 then U=4 end;local a2=expect(aa,select(aa,...),"string")aa=aa+1;if#a2>=math.pow(2,U*8)then error(string.format("bad argument #%d to 'pack' (string length does not fit in given size)",aa-1),2)end;T(#a2,U,V,a9,1,Y,false)for ac=U,#a2+U-1 do V[a9+ac]=a2:byte(ac-U+1)or 0 end;a9=a9+#a2+U elseif ab=='x'then V[a9]=0;a9=a9+1 elseif ab=='X'then if x>=#a8 then error("invalid next option for option 'X'",2)end;local U=0;local ab=a8:sub(x,x)x=x+1;if ab:lower()=='i'then while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 or U==0 then error(string.format("integral size (%d) out of limits [1,16]",U),2)end else U=a5(ab,0)end;if U<1 then error("invalid next option for option 'X'",2)end;if a9%math.min(U,X)~=0 and X>1 then for ac=1,X do if a9%math.min(U,X)==0 then break end;V[a9]=0;a9=a9+1 end end elseif ab~=' 'then error(string.format("invalid format option '%s'",ab),2)end end;return string.char(table.unpack(V))end;function string.packsize(a8)local a9=0;local X=1;local x=1;while x<=#a8 do local ab=a8:sub(x,x)x=x+1;if ab=='!'then local U=0;while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 then error(string.format("integral size (%d) out of limits [1,16]",U),2)elseif U==0 then X=4 else X=U end elseif I[ab]then local U=a5(ab,0)if a9%math.min(U,X)~=0 and X>1 then for ac=1,X do if a9%math.min(U,X)==0 then break end;a9=a9+1 end end;a9=a9+U elseif ab:lower()=='i'then local U=0;while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 then error(string.format("integral size (%d) out of limits [1,16]",U))elseif X>1 and(U~=1 and U~=2 and U~=4 and U~=8 and U~=16)then error("bad argument #1 to 'pack' (format asks for alignment not power of 2)",2)elseif U==0 then U=4 end;if a9%math.min(U,X)~=0 and X>1 then for ac=1,X do if a9%math.min(U,X)==0 then break end;a9=a9+1 end end;a9=a9+U elseif ab=='f'then if a9%math.min(4,X)~=0 and X>1 then for ac=1,X do if a9%math.min(4,X)==0 then break end;a9=a9+1 end end;a9=a9+4 elseif ab=='d'or ab=='n'then if a9%math.min(8,X)~=0 and X>1 then for ac=1,X do if a9%math.min(8,X)==0 then break end;a9=a9+1 end end;a9=a9+8 elseif ab=='c'then local U=0;if x>#a8 or not a8:sub(x,x):match("%d")then error("missing size for format option 'c'",2)end;while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if a9+U<a9 or a9+U>0x7FFFFFFF then error("bad argument #1 to 'packsize' (format result too large)",2)end;a9=a9+U elseif ab=='x'then a9=a9+1 elseif ab=='X'then if x>=#a8 then error("invalid next option for option 'X'",2)end;local U=0;local ab=a8:sub(x,x)x=x+1;if ab:lower()=='i'then while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 or U==0 then error(string.format("integral size (%d) out of limits [1,16]",U),2)end else U=a5(ab,0)end;if U<1 then error("invalid next option for option 'X'",2)end;if a9%math.min(U,X)~=0 and X>1 then for ac=1,X do if a9%math.min(U,X)==0 then break end;a9=a9+1 end end elseif ab=='s'or ab=='z'then error("bad argument #1 to 'packsize' (variable-length format)",2)elseif ab~=' 'and ab~='<'and ab~='>'and ab~='='then error(string.format("invalid format option '%s'",ab),2)end end;return a9 end;function string.unpack(a8,a2,a9)expect(1,a8,"string")expect(2,a2,"string")expect(3,a9,"number","nil")if a9 then if a9<0 then a9=#a2+a9 elseif a9==0 then error("bad argument #3 to 'unpack' (initial position out of string)",2)end;if a9>#a2 or a9<0 then error("bad argument #3 to 'unpack' (initial position out of string)",2)end else a9=1 end;local Y=H.LITTLE_ENDIAN;local X=1;local a7={}local x=1;while x<=#a8 do local ab=a8:sub(x,x)x=x+1;if ab=='<'or ab=='='then Y=H.LITTLE_ENDIAN elseif ab=='>'then Y=H.BIG_ENDIAN elseif ab=='!'then local U=0;while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 then error(string.format("integral size (%d) out of limits [1,16]",U))elseif U==0 then X=4 else X=U end elseif I[ab]then if a9+a5(ab,0)>#a2+1 then error("data string too short",2)end;local w,ae=a1(a2,a9,a5(ab,0),Y,X,ab:match("%l")~=nil)a7[#a7+1]=w;a9=a9+ae elseif ab:lower()=='i'then local Z=ab=='i'local U=0;while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 then error(string.format("integral size (%d) out of limits [1,16]",U),2)elseif U>8 then error(string.format("%d-byte integer does not fit into Lua Integer",U),2)elseif U==0 then U=4 end;if a9+U>#a2+1 then error("data string too short",2)end;local w,ae=a1(a2,a9,U,Y,X,Z)a7[#a7+1]=w;a9=a9+ae elseif ab=='f'then if a9%math.min(4,X)~=0 and X>1 then for ac=1,X do if a9%math.min(4,X)==0 then break end;a9=a9+1 end end;if a9+4>#a2+1 then error("data string too short",2)end;local w=a1(a2,a9,4,Y,X,false)a7[#a7+1]=O(w)a9=a9+4 elseif ab=='d'or ab=='n'then if a9%math.min(8,X)~=0 and X>1 then for ac=1,X do if a9%math.min(8,X)==0 then break end;a9=a9+1 end end;if a9+8>#a2+1 then error("data string too short",2)end;local R,S=0,0;for ac=0,3 do R=bit32.bor(R,bit32.lshift(a2:byte(a9+ac),(Y==H.BIG_ENDIAN and 3-ac or ac)*8))end;for ac=0,3 do S=bit32.bor(S,bit32.lshift(a2:byte(a9+ac+4),(Y==H.BIG_ENDIAN and 3-ac or ac)*8))end;if Y==H.LITTLE_ENDIAN then R,S=S,R end;a7[#a7+1]=Q(R,S)a9=a9+8 elseif ab=='c'then local U=0;if x>#a8 or not a8:sub(x,x):match("%d")then error("missing size for format option 'c'",2)end;while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)")end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if a9+U>#a2+1 then error("data string too short",2)end;a7[#a7+1]=a2:sub(a9,a9+U-1)a9=a9+U elseif ab=='z'then local U=0;while a2:byte(a9+U)~=0 do U=U+1;if a9+U>#a2 then error("unfinished string for format 'z'",2)end end;a7[#a7+1]=a2:sub(a9,a9+U-1)a9=a9+U+1 elseif ab=='s'then local U=0;while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 then error(string.format("integral size (%d) out of limits [1,16]",U),2)elseif U==0 then U=4 end;if a9+U>#a2+1 then error("data string too short",2)end;local b,af=a1(a2,a9,U,Y,X,false)a9=a9+af;if a9+b>#a2+1 then error("data string too short",2)end;a7[#a7+1]=a2:sub(a9,a9+b-1)a9=a9+b elseif ab=='x'then a9=a9+1 elseif ab=='X'then if x>=#a8 then error("invalid next option for option 'X'",2)end;local U=0;local ab=a8:sub(x,x)x=x+1;if ab:lower()=='i'then while x<=#a8 and a8:sub(x,x):match("%d")do if U>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;U=U*10+tonumber(a8:sub(x,x))x=x+1 end;if U>16 or U==0 then error(string.format("integral size (%d) out of limits [1,16]",U),2)elseif U==-1 then U=4 end else U=a5(ab,0)end;if U<1 then error("invalid next option for option 'X'",2)end;if a9%math.min(U,X)~=0 and X>1 then for ac=1,X do if a9%math.min(U,X)==0 then break end;a9=a9+1 end end elseif ab~=' 'then error(string.format("invalid format option '%s'",ab),2)end end;a7[#a7+1]=a9;return table.unpack(a7)end end;function panic(ag)term.setBackgroundColor(32768)term.setTextColor(16384)term.setCursorBlink(false)local r,s=term.getCursorPos()r=1;local ah,ai=term.getSize()ag="panic: "..(ag or"unknown")for aj in ag:gmatch"%S+"do if r+#aj>=ah then r,s=1,s+1;if s>ai then term.scroll(1)s=s-1 end end;term.setCursorPos(r,s)if r==1 then term.clearLine()end;term.write(aj.." ")r=r+#aj+1 end;r,s=1,s+1;if s>ai then term.scroll(1)s=s-1 end;if debug then local ak=debug.traceback(nil,2)for al in ak:gmatch"[^\n]+"do term.setCursorPos(1,s)term.write(al)s=s+1;if s>ai then term.scroll(1)s=s-1 end end end;term.setCursorPos(1,s)term.setTextColor(2)term.write("panic: We are hanging here...")mainThread=nil;while true do coroutine.yield()end end;function do_syscall(am,...)local w=table.pack(coroutine.yield("syscall",am,...))if w[1]then return table.unpack(w,2,w.n)else error(w[2],3)end end;function deepcopy(an)if type(an)=="table"then local a7=setmetatable({},deepcopy(getmetatable(an)))for j,k in pairs(an)do a7[deepcopy(j)]=deepcopy(k)end;return a7 else return an end end;function split(a2,ao)local A={}for ap in a2:gmatch("[^"..(ao or"%s").."]+")do A[#A+1]=ap end;return A end;local aq=pcall(os.epoch,"nano")and function()return os.epoch"nano"/1000000 end or(ccemux and function()return ccemux.nanoTime()/1000000 end or function()return os.epoch"utc"end)local ar={n=0}function executeThread(process,as,at,au,av)local args;if as.status=="starting"then args=as.args elseif as.status=="syscall"then args=table.pack(table.unpack(as.syscall_return,3,as.syscall_return.n))elseif as.status=="preempt"then args=ar elseif as.status=="suspended"then args={at[1],{}}for j,k in pairs(at[2])do args[2][j]=k end elseif as.status=="paused"then return false,av end;if as.status~="dead"and(not as.filter or as.filter(process,as,at))then local aw=au;au=false;as.filter=nil;local ax;if as.yielding then ax={n=as.syscall_return.n,true,"syscall",as.yielding,table.unpack(as.syscall_return,4,as.syscall_return.n)}as.yielding=nil else local ay=globalMetatables;globalMetatables=process.globalMetatables;updateGlobalMetatables()local az=aq()ax=table.pack(coroutine.resume(as.coro,table.unpack(args,1,args.n)))process.cputime=process.cputime+(aq()-az)/1000;globalMetatables=ay;updateGlobalMetatables()end;if ax[2]=="secure_syscall"then ax[2]="syscall"elseif ax[2]=="secure_event"then ax[2]=nil end;if ax[2]=="syscall"then as.status="syscall"local aA=av;av=false;if ax[3]and syscalls[ax[3]]then local az=aq()as.syscall_return=table.pack(coroutine.resume(as.syscall,ax[3],process,as,table.unpack(ax,4,ax.n)))process.systime=process.systime+(aq()-az)/1000;if as.syscall_return[2]==kSyscallComplete then if not as.syscall_return[3]and type(as.syscall_return[4])=="string"then syslog.log({level="debug",category="Syscall Failure",process=0,module=ax[3]},as.syscall_return[4])as.syscall_return[4]=as.syscall_return[4]:gsub("kernel:%d+: ","")end;if as.syscall_return[4]==kSyscallYield then as.yielding=as.syscall_return[5]av=aA end else as.yielding=ax[3]end else as.syscall_return={false,"No such syscall",n=2}end elseif ax[2]=="preempt"then as.status="preempt"av=false elseif coroutine.status(as.coro)=="dead"then as.status="dead"as.return_value=ax[2]if ax[1]then process.lastReturnValue={pid=process.id,thread=as.id,value=ax[2],n=ax.n-1,table.unpack(ax,2,ax.n)}else process.lastReturnValue={pid=process.id,thread=as.id,error=ax[2],traceback=debug.traceback(as.coro)}end;if not ax[1]then as.did_error=true;syslog.log({level=_G.args.traceback and"error"or"debug",process=process.id,thread=as.id,category="Application Error",traceback=true},debug.traceback(as.coro,ax[2]))if ax[2]and process.stderr and process.stderr.isTTY then terminal.write(process.stderr,ax[2].."\n")end end;process.threads[as.id]=nil;au=aw else as.status="suspended"av=av and#process.eventQueue==0 end end;return au,av end;mainThread=coroutine.running()function userModeCallback(process,aB,...)local aC=syscalls.newthread(process,nil,aB,...)local as=process.threads[aC]while as.status~="dead"do if coroutine.running()==mainThread then error("userModeCallback not called from a yieldable context",2)end;coroutine.yield()end;return not as.did_error,as.return_value end;function make_ENV(e)if type(e)~="table"or _VERSION~="Lua 5.1"then return e end;repeat local aD=getmetatable(e)if aD and aD.__env then e=aD.__env end until not aD or not aD.__env;local A=setmetatable({},{__index=function(self,aE)if self==e then e=getmetatable(self).__env end;if aE=="_ENV"then return e else return e[aE]end end,__newindex=function(self,aE,aF)if self==e then e=getmetatable(self).__env end;if aE=="_ENV"then e=aF else e[aE]=aF end end,__pairs=function(self)if self==e then e=getmetatable(self).__env end;return next,e end,__len=function(self)if self==e then e=getmetatable(self).__env end;return#e end,__env=e})return A end;for B,k in ipairs({...})do local aG,aH=k:match("^([^=]+)=(.+)$")if aG and aH then if type(args[aG])=="boolean"then args[aG]=aH:lower()=="true"or aH=="1"elseif type(args[aG])=="number"then args[aG]=tonumber(aH)else args[aG]=aH end elseif aG=="silent"then args.loglevel=5 elseif aG=="quiet"then args.loglevel=3 end end;local function aI(aJ)local w;if _CC_VERSION then w=aJ<=_CC_VERSION elseif not _HOST then w=aJ<=os.version():gsub("CraftOS ","")elseif _HOST:match("ComputerCraft 1%.1%d+")~=aJ:match("1%.1%d+")then aJ=aJ:gsub("(1%.)([02-9])","%10%2")local aK=_HOST:gsub("(ComputerCraft 1%.)([02-9])","%10%2")w=aJ<=aK:match("ComputerCraft ([0-9%.]+)")else w=aJ<=_HOST:match("ComputerCraft ([0-9%.]+)")end;return w end;if not aI"1.87.0"then panic("Phoenix requires ComputerCraft 1.87.0 or later. Please upgrade your version of ComputerCraft.")end;if jit and args.preemptive then panic("Phoenix does not support preemption when running under LuaJIT. Please set preemptive to false in the kernel arguments.")end;if not debug and args.preemptive then panic("Phoenix does not support preemption without the debug API. Please set preemptive to false in the kernel arguments.")end;if args.preemptive then PHOENIX_BUILD=PHOENIX_BUILD.." PREEMPT"end;if not getfenv then if not debug then panic("Phoenix requires the debug API when running under Lua 5.2 and later.")end;function getfenv(i)local x=1;while true do local o,aF=debug.getupvalue(i,x)if o=="_ENV"then return aF elseif not o then break end;x=x+1 end end;function setfenv(i,e)local x=1;while true do local o=debug.getupvalue(i,x)if o=="_ENV"then debug.upvaluejoin(i,x,function()return e end,1)break elseif not o then break end;x=x+1 end;return i end end;globalMetatables={["nil"]={},["boolean"]={},["number"]={},["string"]={__index=string},["function"]={},["thread"]={__index=coroutine,__call=coroutine.resume},["userdata"]={}}local aL,aM=debug.getmetatable,debug.setmetatable;function updateGlobalMetatables()aM(nil,globalMetatables["nil"])aM(false,globalMetatables["boolean"])aM(0,globalMetatables["number"])aM("",globalMetatables["string"])aM(assert,globalMetatables["function"])aM(coroutine.running(),globalMetatables["thread"])if debug.upvalueid then aM(debug.upvalueid(executeThread,1),globalMetatables["userdata"])end end;local type=type;function debug.getmetatable(aF)if type(aF)=="table"then return aL(aF)else return globalMetatables[type(aF)]end end;function debug.setmetatable(aF,an)expect(2,an,"table")if type(aF)=="table"then return aM(aF,an)else globalMetatables[type(aF)]=an end end;do local aN;local aO,aP,aQ,aR,aS,aT,aU,aV,aW=getfenv,setfenv,debug.getfenv,debug.getlocal,debug.getupvalue,debug.setfenv,debug.setlocal,debug.setupvalue,debug.upvaluejoin;local error,aX,aY,select,setmetatable,type,tonumber=error,debug.getinfo,coroutine.running,select,setmetatable,type,tonumber;local aZ;local function keys(A,k,...)if k then A[k]=true end;if select("#",...)>0 then return keys(A,...)else return A end end;local function a_(k,...)if select("#",...)>0 then return aZ[k or""]or k,a_(...)else return aZ[k or""]or k end end;local function b0(t)t=bit32.band(tonumber(t),0xFFFFFFFF)if bit32.btest(t,0x80000000)then t=t-0x100000000 end;return t end;function debug.getinfo(as,aB,b1)if type(as)~="thread"then b1,aB,as=aB,as,aY()end;local a7;if tonumber(aB)then a7=aX(as,aB+1,b1)else a7=aX(as,aB,b1)end;if a7 and a7.func then a7.func=aZ[a7.func]or a7.func end;return a7 end;function debug.getlocal(as,b2,b3)if b3==nil then b3,b2,as=b2,as,aY()end;local j,k;if type(b2)=="function"then local b4=aX(2,"f")if aN[b2]and not(b4 and aN[b2][b4.func])then return nil end;j,k=a_(aR(b2,b3))elseif tonumber(b2)then local b5=aX(as,b2+1,"f")local b4=aX(2,"f")if b5 and aN[b5.func]and not(b4 and aN[b5.func][b4.func])then return nil end;j,k=a_(aR(as,b2+1,b3))else j,k=a_(aR(as,b2,b3))end;return j,k end;function debug.getupvalue(aB,b6)if type(aB)=="function"then local b4=aX(2,"f")if aN[aB]and not(b4 and aN[aB][b4.func])then return nil end end;local j,k=a_(aS(aB,b6))return j,k end;function debug.setlocal(as,b2,b3,aH)if b3==nil then b3,b2,as=b2,as,aY()end;if tonumber(b2)then local b5=aX(as,b2+1,"f")local b4=aX(2,"f")if b5 and aN[b5.func]and not(b4 and aN[b5.func][b4.func])then error("attempt to set local of protected function",2)end;aU(as,b2+1,b3,aH)else aU(as,b2,b3,aH)end end;function debug.setupvalue(aB,b6,aH)if type(aB)=="function"then local b4=aX(2,"f")if aN[aB]and not(b4 and aN[aB][b4.func])then error("attempt to set upvalue of protected function",2)end end;aV(aB,b6,aH)end;function _G.getfenv(f)local k;if f==nil then k=aO(2)elseif tonumber(f)and b0(f)>0 then local b5=aX(f+1,"f")local b4=aX(2,"f")if b5 and aN[b5.func]and not(b4 and aN[b5.func][b4.func])then return nil end;k=aO(f+1)elseif type(f)=="function"then local b4=aX(2,"f")if aN[f]and not(b4 and aN[f][b4.func])then return nil end;k=aO(f)else k=aO(f)end;return k end;function _G.setfenv(f,an)if tonumber(f)and b0(f)>0 then local b5=aX(f+1,"f")local b4=aX(2,"f")if b5 and aN[b5.func]and not(b4 and aN[b5.func][b4.func])then error("attempt to set environment of protected function",2)end;aP(f+1,an)elseif type(f)=="function"then local b4=aX(2,"f")if aN[f]and not(b4 and aN[f][b4.func])then error("attempt to set environment of protected function",2)end end;aP(f,an)end;if aQ then function debug.getfenv(b7)if type(b7)=="function"then local b4=aX(2,"f")if aN[b7]and not(b4 and aN[b7][b4.func])then return nil end end;local k=aQ(b7)return k end;function debug.setfenv(b7,an)if type(b7)=="function"then local b4=aX(2,"f")if aN[b7]and not(b4 and aN[b7][b4.func])then error("attempt to set environment of protected function",2)end end;aT(b7,an)end end;if aW then function debug.upvaluejoin(b8,b9,ba,bb)if type(b8)=="function"and type(ba)=="function"then local b4=aX(2,"f")if aN[b8]and not(b4 and aN[b8][b4.func])then error("attempt to get upvalue of protected function",2)end;if aN[ba]and not(b4 and aN[ba][b4.func])then error("attempt to set upvalue of protected function",2)end end;aW(b8,b9,ba,bb)end end;function debug.protect(aB)if type(aB)~="function"then error("bad argument #1 (expected function, got "..type(aB)..")",2)end;if aN[aB]then error("attempt to protect a protected function",2)end;aN[aB]=keys(setmetatable({},{__mode="k"}))end;aZ={[aR]=debug.getlocal,[aU]=debug.setlocal,[aS]=debug.getupvalue,[aV]=debug.setupvalue,[aX]=debug.getinfo,[a_]=function()end}if debug.upvaluejoin then aZ[aW]=debug.upvaluejoin end;if debug.getfenv then aZ[aQ]=debug.getfenv end;if debug.setfenv then aZ[aT]=debug.setfenv end;if _G.getfenv then aZ[aO]=_G.getfenv end;if _G.setfenv then aZ[aP]=_G.setfenv end;aN=keys(setmetatable({},{__mode="k"}),getfenv,setfenv,debug.getfenv,debug.setfenv,debug.getlocal,debug.setlocal,debug.getupvalue,debug.setupvalue,debug.upvaluejoin,debug.getinfo,a_,debug.protect)for j,k in pairs(aN)do aN[j]={}end end;fs=fs;mounts={}fifos={}fsevents={}filesystems={craftos={meta={meta={type="directory",owner="root",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}},metapath="/meta.ltn",lastDispatch=0},tmpfs={},drivefs={},tablefs={},bind={}}local function bc(process,g)local G=fs.combine(process.root,g:sub(1,1)=="/"and""or process.dir,g)if"/"..G.."/"~=process.root and G:find(process.root:sub(2),1,true)~=1 then error(g..": No such file or directory",4)end;return G end;local function bd(process,g,be)local bf=split(bc(process,g),"/\\")if#bf==0 then if be then return mounts[""],g,""end;return mounts[""][1],g,""end;local bg;for j in pairs(mounts)do local bh=true;for x,ab in ipairs(split(j,"/\\"))do if bf[x]~=ab then bh=false;break end end;if bh and(not bg or#j>#bg)then bg=j end end;if not bg then panic("Could not find mount for path "..g..". Where is root?")end;local bi=split(bg,"/\\")local G=#bf>=#bi+1 and fs.combine(table.unpack(bf,#bi+1,#bf))or""local mounts=mounts[bg]if be then return mounts,G,bg end;local bj=mounts[1]if#mounts>1 then for B,k in ipairs(mounts)do local bh,w=pcall(k.stat,k,process,G,true)if bh and w then bj=k;break end end end;return bj,G,bg end;function filesystem.readhandle(process,bk,bl)if bk==""then local bm=false;local function bn()if bm then return nil end;bm=true;return""end;local bo={readLine=bn,readAll=bn,read=bn,close=function()end}if bl then function bo.seek()bm=false end;function bo.read(t)if not t then return nil end;return bn()end end;return bo end;local a9=1;local bp=false;local A={readLine=function(bq)if bp then error("attempt to use a closed file",2)end;if a9>#bk then return nil end;local br;br,a9=bk:match("([^\n]*"..(bq and"\n?)"or")\n?").."()",a9)return br end,readAll=function()if bp then error("attempt to use a closed file",2)end;if a9>#bk then return nil end;local br=bk:sub(a9)a9=#br+1;return br end,read=function(t)if bp then error("attempt to use a closed file",2)end;if t~=nil and type(t)~="number"then error("bad argument #1 (expected number, got "..type(t)..")",2)end;t=t or 1;if a9>#bk then return nil end;local br=bk:sub(a9,a9+t-1)a9=a9+t;return br end,close=function()if bp then error("attempt to use a closed file",2)end;bp=true end}if bl then A.read=function(t)if bp then error("attempt to use a closed file",2)end;if t~=nil and type(t)~="number"then error("bad argument #1 (expected number, got "..type(t)..")",2)end;if a9>#bk then return nil end;if t then local br=bk:sub(a9,a9+t-1)a9=a9+t;return br else local br=bk:byte(a9)a9=a9+1;return br end end;A.seek=function(bs,W)if bs~=nil and type(bs)~="string"then error("bad argument #1 (expected string, got "..type(bs)..")",2)end;if W~=nil and type(W)~="number"then error("bad argument #2 (expected number, got "..type(W)..")",2)end;bs=bs or"cur"W=W or 0;if bp then error("attempt to use closed file",2)end;if bs=="set"then a9=W+1 elseif bs=="cur"then a9=a9+W elseif bs=="end"then a9=math.max(#bk-W,1)else error("Invalid whence",2)end;return a9-1 end else bk=bk:gsub("[\x80-\xFF]+",function(bt)local bu=""if not pcall(function()for B,bv in utf8.codes(bt)do bu=bu..(bv<256 and string.char(bv)or"?")end end)then return bt end;return bu end)end;for B,k in pairs(A)do setfenv(k,process.env)debug.protect(k)end;return setmetatable(A,{__name="file"})end;function filesystem.writehandle(process,bw,bl)setfenv(bw,process.env)local function bx(A)for B,k in pairs(A)do setfenv(k,process.env)debug.protect(k)end;return setmetatable(A,{__name="file"})end;local bp=false;if bl then local a9=1;local by=""local bz=""return bx{write=function(br)if bp then error("attempt to use a closed file",2)end;if type(br)=="number"then by,a9=by:sub(1,a9-1)..string.char(br)..by:sub(a9+1),a9+1;if bz then bz=bz..string.char(br)end elseif type(br)=="string"then by,a9=by:sub(1,a9-1)..br..by:sub(a9+#br),a9+#br;if bz then bz=bz..br end else error("bad argument #1 (expected string or number, got "..type(br)..")",2)end end,writeLine=function(br)if bp then error("attempt to use a closed file",2)end;if type(br)=="number"then by,a9=by:sub(1,a9-1)..string.char(br).."\n"..by:sub(a9+2),a9+2;if bz then bz=bz..string.char(br).."\n"end elseif type(br)=="string"then by,a9=by:sub(1,a9-1)..br.."\n"..by:sub(a9+#br+1),a9+#br+1;if bz then bz=bz..br.."\n"end else error("bad argument #1 (expected string or number, got "..type(br)..")",2)end end,seek=function(bs,W)if bs~=nil and type(bs)~="string"then error("bad argument #1 (expected string, got "..type(bs)..")",2)end;if W~=nil and type(W)~="number"then error("bad argument #2 (expected number, got "..type(W)..")",2)end;bs=bs or"cur"W=W or 0;if bp then error("attempt to use closed file",2)end;local bA=a9;if bs=="set"then a9=W+1 elseif bs=="cur"then a9=a9+W elseif bs=="end"then a9=math.max(#by-W,1)else error("Invalid whence",2)end;if bA~=a9 then bz=nil end;return a9-1 end,flush=function()if bp then error("attempt to use a closed file",2)end;if bz then bw(bz,false)else bw(by,true)end;bz=""end,close=function()if bp then error("attempt to use a closed file",2)end;bp=true;if bz then bw(bz,false)else bw(by,true)end;bz=""end}else local by=""return bx{write=function(br)if bp then error("attempt to use a closed file",2)end;by=by..tostring(br)end,writeLine=function(br)if bp then error("attempt to use a closed file",2)end;by=by..tostring(br).."\n"end,flush=function()if bp then error("attempt to use a closed file",2)end;bw(by,false)by=""end,close=function()if bp then error("attempt to use a closed file",2)end;bw(by,false)by=""bp=true end}end end;function filesystem.fifohandle(process,bB,p)local bp=false;local function bx(A)for B,k in pairs(A)do setfenv(k,process.env)debug.protect(k)end;return setmetatable(A,{__name="file"})end;if p=="r"then return bx{readLine=function(bq)if bp then error("attempt to use a closed file",2)end;if#bB.data==0 then return nil end;local br;br,bB.data=bB.data:match("([^\n]*"..(bq and"\n?)"or")\n?").."(.*)")return br end,readAll=function()if bp then error("attempt to use a closed file",2)end;if#bB.data==0 then return nil end;local br=bB.data;bB.data=""return br end,read=function(t)if bp then error("attempt to use a closed file",2)end;if t~=nil and type(t)~="number"then error("bad argument #1 (expected number, got "..type(t)..")",2)end;t=t or 1;if#bB.data==0 then return nil end;local br=bB.data:sub(1,t)bB.data=bB.data:sub(t+1)return br end,close=function()if bp then error("attempt to use a closed file",2)end;bp=true end}elseif p=="w"or p=="a"then local by=bB.data;return bx{write=function(br)if bp then error("attempt to use a closed file",2)end;by=by..tostring(br)end,writeLine=function(br)if bp then error("attempt to use a closed file",2)end;by=by..tostring(br).."\n"end,flush=function()if bp then error("attempt to use a closed file",2)end;bB.data=by end,close=function()if bp then error("attempt to use a closed file",2)end;bB.data=by;bp=true end}elseif p=="rb"then return bx{readLine=function(bq)if bp then error("attempt to use a closed file",2)end;if#bB.data==0 then return nil end;local br;br,bB.data=bB.data:match("([^\n]*"..(bq and"\n?)"or")\n?").."(.*)")return br end,readAll=function()if bp then error("attempt to use a closed file",2)end;if#bB.data==0 then return nil end;local br=bB.data;bB.data=""return br end,read=function(t)if bp then error("attempt to use a closed file",2)end;if t~=nil and type(t)~="number"then error("bad argument #1 (expected number, got "..type(t)..")",2)end;if#bB.data==0 then return nil end;if t then local br=bB.data:sub(1,t)bB.data=bB.data:sub(t+1)return br else local br=bB.data:byte()bB.data=bB.data:sub(2)return br end end,seek=function(bs,W)if bs~=nil and type(bs)~="string"then error("bad argument #1 (expected string, got "..type(bs)..")",2)end;if W~=nil and type(W)~="number"then error("bad argument #2 (expected number, got "..type(W)..")",2)end;if bp then error("attempt to use closed file",2)end;return 0 end,close=function()if bp then error("attempt to use a closed file",2)end;bp=true end}elseif p=="wb"or p=="ab"then local by=bB.data;return bx{write=function(br)if bp then error("attempt to use a closed file",2)end;if type(br)=="number"then by=by..string.char(br)elseif type(br)=="string"then by=by..br else error("bad argument #1 (expected string or number, got "..type(br)..")",2)end end,writeLine=function(br)if bp then error("attempt to use a closed file",2)end;if type(br)=="number"then by=by..string.char(br).."\n"elseif type(br)=="string"then by=by..br.."\n"else error("bad argument #1 (expected string or number, got "..type(br)..")",2)end end,seek=function(bs,W)if bs~=nil and type(bs)~="string"then error("bad argument #1 (expected string, got "..type(bs)..")",2)end;if W~=nil and type(W)~="number"then error("bad argument #2 (expected number, got "..type(W)..")",2)end;if bp then error("attempt to use closed file",2)end;return#bB.data+#by end,flush=function()if bp then error("attempt to use a closed file",2)end;bB.data=by end,close=function()if bp then error("attempt to use a closed file",2)end;bB.data=by;bp=true end}else return nil,"Invalid mode"end end;filesystem.openfifo=filesystem.fifohandle;do local a=fs.open("/meta.ltn","r")if a then filesystems.craftos.meta=unserialize(a.readAll())or filesystems.craftos.meta;filesystems.craftos.lastDispatch=os.epoch"utc"a.close()end end;shutdownHooks[#shutdownHooks+1]=function()syslog.log("Syncing filesystem")local a=fs.open(filesystems.craftos.metapath,"w")if a then a.write(serialize(filesystems.craftos.meta,{compact=true}))a.close()end end;if args.fsmeta then local a=fs.open(args.fsmeta,"r")if a then local bC=unserialize(a.readAll())a.close()if bC then local function bD(bE,bF)for j,k in pairs(bE)do if bF[j]and type(bF[j])=="table"and type(k)=="table"then bD(k,bF[j])else bF[j]=k end end end;bD(bC,filesystems.craftos.meta)end end end;function filesystems.craftos:getmeta(user,g,bG)local bH={}local A=self.meta;local bi=split(g,"/\\")for x,G in ipairs(bi)do if G==".."then A=table.remove(bH)if not A then return nil end elseif not G:match"^%.*$"then if not A then return nil elseif A.meta.type~="directory"then error("Not a directory",2)elseif A.meta.permissions[user]then if not A.meta.permissions[user].execute then error("Permission denied",2)end elseif not A.meta.worldPermissions.execute then error("Permission denied",2)end;bH[#bH+1]=A;A=A.contents[G]if A and A.meta.type=="link"and not bG then local bI=filesystem.combine(A.meta.link,table.unpack(bi,x+1))if fs.combine(bI)==fs.combine(g)then error("Loop in link",2)end;error{link=true,path=bI,orig=g}end end end;return A and A.meta end;function filesystems.craftos:setmeta(user,g,bC,bG)local bH={}local A=self.meta;local o;local bi=split(g,"/\\")for x,G in ipairs(bi)do if G==".."then A=table.remove(bH)if not A then error("Not a directory",2)end elseif not G:match"^%.*$"then if A.meta.type~="directory"then error("Not a directory",2)elseif A.meta.permissions[user]then if not A.meta.permissions[user].execute then error("Permission denied",2)end elseif not A.meta.worldPermissions.execute then error("Permission denied",2)end;if not A.contents[G]then A.contents[G]={meta={type="directory",owner=A.meta.owner or"root",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}}end;bH[#bH+1]=A;A=A.contents[G]o=G;if A and A.meta.type=="link"and not bG then local bI=filesystem.combine(A.meta.link,table.unpack(bi,x+1))if fs.combine(bI)==fs.combine(g)then error("Loop in link",2)end;error{link=true,path=bI,orig=g}end end end;if bC~=nil then A.meta={type=bC.type,owner=bC.owner,permissions=deepcopy(bC.permissions),worldPermissions=deepcopy(bC.worldPermissions),setuser=bC.setuser,link=bC.link}if bC.type~="directory"then A.contents=nil end else bH[#bH].contents[o]=nil end;if os.epoch"utc"-self.lastDispatch>1000 then local a=assert(fs.open(self.metapath,"w"))a.write(serialize(self.meta,{compact=true}))a.close()self.lastDispatch=os.epoch"utc"end end;function filesystems.craftos:new(process,g,bJ)expect.field(bJ,"ro","boolean","nil")if process.user~="root"then error("Could not mount "..g..": Permission denied",3)elseif not fs.isDir(g)then error("Could not mount "..g..": No such directory",3)end;return setmetatable({path=g,readOnly=bJ.ro},{__index=self})end;function filesystems.craftos:open(process,g,p)local bh,bK=pcall(self.stat,self,process,g)if not bh then if type(bK)=="table"then error(bK)end;return nil,bK elseif not bK then if p:sub(1,1)=="w"or p:sub(1,1)=="a"then if self.readOnly then return nil,"Read-only filesystem"end;local bL,bM=pcall(self.stat,self,process,fs.getDir(g))if not bL or not bM then if type(bM)=="table"then error(bM)end;local bN,q=pcall(self.mkdir,self,process,fs.getDir(g))if not bN then if type(q)=="table"then error(q)end;return nil,q:gsub("kernel:%d: ","")end;bM=self:stat(process,fs.getDir(g))if not bM then return nil,"Could not stat "..fs.getDir(g)end end;if process.user~="root"then local bO=bM.permissions[process.user]or bM.worldPermissions;if not bO.write then return nil,"Permission denied"end end;local bC={type="file",owner=process.user,permissions=deepcopy(bM.permissions),worldPermissions=deepcopy(bM.worldPermissions),setuser=false}if bM.owner then local A=bC.permissions[bM.owner]bC.permissions[bM.owner]=nil;bC.permissions[process.user]=A end;self:setmeta(process.user,fs.combine(self.path,g),bC)local a,q=fs.open(fs.combine(self.path,g),p)if not a then return a,q end;return setmetatable(a,{__name="file"})else return nil,"File not found"end elseif bK.type=="directory"then return nil,"Is a directory"end;local bO=bK.permissions[process.user]or bK.worldPermissions;if process.user~="root"and(p:sub(1,1)=="r"and not bO.read or(p:sub(1,1)=="w"or p:sub(1,1)=="a")and not bO.write)then return nil,"Permission denied"end;if bK.type=="fifo"then local bC=self:getmeta(process.user,fs.combine(self.path,g))local bP=fifos[bC]if not bP then bP={data=""}fifos[bC]=bP end;return filesystem.fifohandle(process,bP,p)end;local a,q=fs.open(fs.combine(self.path,g),p)if not a then return nil,q end;return setmetatable(a,{__name="file"})end;function filesystems.craftos:list(process,g)local bK=self:stat(process,g)if not bK or bK.type~="directory"then error(g..": Not a directory",2)end;if process.user~="root"then local bO=bK.permissions[process.user]or bK.worldPermissions;if not bO.read then error(g..": Permission denied",2)end end;return fs.list(fs.combine(self.path,g))end;function filesystems.craftos:stat(process,g,bG)local G=fs.combine(self.path,g)if G:find(self.path:gsub("^/",""):gsub("/$",""),1,false)~=1 then return nil end;local bh,bQ=pcall(fs.attributes,G)if not bh or not bQ then return nil end;bQ.type=bQ.isDir and"directory"or"file"bQ.special={}bQ.isDir=nil;if not bQ.modified then bQ.modified=bQ.modification end;bQ.modification=nil;bQ.capacity=fs.getCapacity(G)or 0;bQ.freeSpace=fs.getFreeSpace(G)local bR=bQ.isReadOnly;bQ.isReadOnly=nil;local bC=self:getmeta(process.user,fs.combine(self.path,g),bG)if bC then bQ.owner=bC.owner;bQ.permissions=deepcopy(bC.permissions)bQ.worldPermissions=deepcopy(bC.worldPermissions)bQ.type=bC.type or bQ.type;bQ.setuser=bC.setuser;bQ.link=bC.link else bQ.owner="root"bQ.permissions={root={read=true,write=true,execute=true}}bQ.worldPermissions={read=true,write=false,execute=true}bQ.setuser=false end;if bR then bQ.worldPermissions.write=false;for B,k in pairs(bQ.permissions)do k.write=false end end;return bQ end;function filesystems.craftos:remove(process,g)if self.readOnly then error(g..": Read-only filesystem",2)end;local bK=self:stat(process,g,true)if not bK then return end;local function bS(G)local bt=self:stat(process,G,true)local bO=bt.permissions[process.user]or bt.worldPermissions;if process.user~="root"and not bO.write then error(G..": Permission denied",3)end;if bt.type=="directory"then if process.user~="root"and not bO.read then error(G..": Permission denied",3)end;for B,k in ipairs(fs.list(fs.combine(self.path,G)))do bS(fs.combine(G,k))end end end;bS(g)fs.delete(fs.combine(self.path,g))self:setmeta(process.user,fs.combine(self.path,g),nil,true)end;function filesystems.craftos:rename(process,bT,bU)if self.readOnly then error("Read-only filesystem",2)end;local bV=self:stat(process,bT,true)local bW=self:stat(process,bU,true)if not bV then error(bT..": No such file or directory",2)elseif bW then error(bU..": "..bW.type:gsub("%w",string.upper,1).." already exists",2)end;bW=self:stat(process,fs.getDir(bU))if not bW then self:mkdir(process,fs.getDir(bU))bW=self:stat(process,fs.getDir(bU))end;if process.user~="root"then local bO=bW.permissions[process.user]or bW.worldPermissions;if not bO.write then error(bU..": Permission denied",2)end end;fs.move(fs.combine(self.path,bT),fs.combine(self.path,bU))self:setmeta(process.user,fs.combine(self.path,bU),self:getmeta(process.user,fs.combine(self.path,bT),true),true)self:setmeta(process.user,fs.combine(self.path,bT),nil,true)end;function filesystems.craftos:mkdir(process,g)if self.readOnly then error(g..": Read-only filesystem",2)end;local bK=self:stat(process,g)if bK then if bK.type=="directory"then return else error(g..": File already exists",2)end end;local bi=split(g,"/\\")local x=#bi;repeat x=x-1;bK=self:stat(process,table.concat(bi,"/",1,x))if bK then if bK.type=="directory"then break else error(g..": File already exists",2)end end until bK or x<=0;if not bK then if g:match"^/"then bK=assert(self:stat(process,"/"))else bK=assert(filesystem.stat(process,process.dir))end end;if process.user~="root"then local bO=bK.permissions[process.user]or bK.worldPermissions;if not bO.write then error(g..": Permission denied",2)end end;local bC={type="directory",owner=process.user,permissions=deepcopy(bK.permissions),worldPermissions=deepcopy(bK.worldPermissions)}if bK.owner then local A=bC.permissions[bK.owner]bC.permissions[bK.owner]=nil;bC.permissions[process.user]=A end;x=x+1;while x<=#bi do self:setmeta(process.user,fs.combine(self.path,table.concat(bi,"/",1,x)),deepcopy(bC))x=x+1 end;fs.makeDir(fs.combine(self.path,g))end;function filesystems.craftos:link(process,g,bX)local bK=self:stat(process,g,true)if bK then error(g..": File exists",2)end;self:setmeta(process.user,fs.combine(self.path,g),nil,true)assert(self:open(process,g,"w")).close()local bC=self:getmeta(process.user,fs.combine(self.path,g),true)bC.type,bC.link="link",bX;self:setmeta(process.user,fs.combine(self.path,g),bC,true)end;function filesystems.craftos:mkfifo(process,g)local bK=self:stat(process,g)if bK then error(g..": File exists",2)end;assert(self:open(process,g,"w")).close()local bC=self:getmeta(process.user,fs.combine(self.path,g),true)bC.type="fifo"self:setmeta(process.user,fs.combine(self.path,g),bC,true)end;function filesystems.craftos:chmod(process,g,user,p)if self.readOnly then error(g..": Read-only filesystem",2)end;local bK=self:stat(process,g,true)if not bK then error(g..": No such file or directory",2)end;if not bK.owner or process.user~="root"and process.user~=bK.owner then error(g..": Permission denied",2)end;local bO;if user==nil then bO=bK.worldPermissions else bO=bK.permissions[user]if not bO then bO=deepcopy(bK.worldPermissions)bK.permissions[user]=bO end end;if type(p)=="string"then if p:match"^[%+%-=][rwxs]+$"then local C=p:sub(1,1)local A={}for ab in p:gmatch("[rwxs]")do if ab=="r"then A.read=true elseif ab=="w"then A.write=true elseif ab=="s"then A.setuser=true else A.execute=true end end;if C=="+"then if A.read then bO.read=true end;if A.write then bO.write=true end;if A.execute then bO.execute=true end;if A.setuser then bK.setuser=true end elseif C=="-"then if A.read then bO.read=false end;if A.write then bO.write=false end;if A.execute then bO.execute=false end;if A.setuser then bK.setuser=false end else bO.read=A.read or false;bO.write=A.write or false;bO.execute=A.execute or false;bK.setuser=A.setuser or false end else bO.read=p:sub(1,1)~="-"bO.write=p:sub(2,2)~="-"bO.execute=p:sub(3,3)~="-"bK.setuser=p:sub(3,3)=="s"end elseif type(p)=="number"then bK.setuser=bit32.btest(p,8)bO.read=bit32.btest(p,4)bO.write=bit32.btest(p,2)bO.execute=bit32.btest(p,1)else if p.read~=nil then bO.read=p.read end;if p.write~=nil then bO.write=p.write end;if p.execute~=nil then bO.execute=p.execute end;if p.setuser~=nil then bK.setuser=p.setuser end end;self:setmeta(process.user,fs.combine(self.path,g),deepcopy(bK),true)end;function filesystems.craftos:chown(process,g,bY)if self.readOnly then error(g..": Read-only filesystem",2)end;local bK=self:stat(process,g,true)if not bK then error(g..": No such file or directory",2)end;if not bK.owner or process.user~="root"and process.user~=bK.owner then error(g..": Permission denied",2)end;bK.owner=bY;bK.setuser=false;self:setmeta(process.user,fs.combine(self.path,g),deepcopy(bK),true)end;function filesystems.craftos:info()return"craftos",self.path,{ro=self.readOnly}end;function filesystems.tmpfs:getpath(user,g,bG)local A=self;local bi=split(g,"/\\")for x,G in ipairs(bi)do if not A then return nil elseif A.type~="directory"then error("Not a directory",2)elseif A.permissions[user]then if not A.permissions[user].execute then error("Permission denied",2)end elseif not A.worldPermissions.execute then error("Permission denied",2)end;A=A.contents[G]if A and A.type=="link"and not(bG and x==#bi)then error{link=true,path=filesystem.combine(A.link,table.unpack(bi,x+1)),orig=g}end end;return A end;function filesystems.tmpfs:setpath(user,g,bk,bG)local A=self;local M=split(g,"/\\")local bZ=M[#M]M[#M]=nil;for x,G in ipairs(M)do if A.type~="directory"then error("Not a directory",2)elseif A.permissions[user]then if not A.permissions[user].execute then error("Permission denied",2)end elseif not A.worldPermissions.execute then error("Permission denied",2)end;if not A.contents[G]then A.contents[G]={type="directory",owner=A.owner,permissions=deepcopy(A.permissions),worldPermissions=deepcopy(A.worldPermissions),setuser=false,created=os.epoch"utc",modified=os.epoch"utc",contents={}}end;A=A.contents[G]if A and A.type=="link"then error{link=true,path=filesystem.combine(A.link,table.unpack(M,x+1)),orig=g}end end;if A.type~="directory"then error("Not a directory",2)elseif user~="root"then if A.permissions[user]then if not A.permissions[user].execute then error("Permission denied",2)end elseif not A.worldPermissions.execute then error("Permission denied",2)end end;if not bG and A.contents[bZ]and A.contents[bZ].type=="link"then error{link=true,path=A.contents[bZ].link,orig=g}end;A.contents[bZ]=bk end;function filesystems.tmpfs:new(process,bE,bJ)return setmetatable({type="directory",owner=process.user,permissions={[process.user]={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false,created=os.epoch"utc",modified=os.epoch"utc",contents={}},{__index=self})end;function filesystems.tmpfs:_open_internal(process,g,p)local b_=os.epoch;local bk=self:getpath(process.user,g)if not bk then return nil,"No such file"end;if p=="r"or p=="rb"then return filesystem.readhandle(process,bk.data,p=="rb")elseif p=="w"or p=="wb"then bk.data=""bk.modified=b_"utc"return filesystem.writehandle(process,function(by,c0)if c0 then bk.data=by else bk.data=bk.data..by end;bk.modified=b_"utc"if self.__flush then self:__flush()end end,p=="wb")elseif p=="a"or p=="ab"then local c1=bk.data;return filesystem.writehandle(process,function(by,c0)if c0 then bk.data=c1 ..by else bk.data=bk.data..by end;bk.modified=b_"utc"if self.__flush then self:__flush()end end,p=="ab")else return nil,"Invalid mode"end end;function filesystems.tmpfs:open(process,g,p)if self.readOnly and(p:sub(1,1)=="w"or p:sub(1,1)=="a")then return nil,"Read-only filesystem"end;local bh,bK=pcall(self.stat,self,process,g)if not bh then if type(bK)=="table"then error(bK)end;return nil,bK elseif not bK then if p:sub(1,1)=="w"or p:sub(1,1)=="a"then local bL,bM=pcall(self.stat,self,process,fs.getDir(g))if not bL or not bM then if type(bM)=="table"then error(bM)end;local bN,q=pcall(self.mkdir,self,process,fs.getDir(g))if not bN then if type(q)=="table"then error(q)end;return nil,q:gsub("kernel:%d: ","")end;bM=self:stat(process,fs.getDir(g))end;if process.user~="root"then local bO=bM.permissions[process.user]or bM.worldPermissions;if not bO.write then return nil,"Permission denied"end end;local bC={type="file",owner=process.user,permissions=deepcopy(bM.permissions),worldPermissions=deepcopy(bM.worldPermissions),setuser=false,created=os.epoch"utc",modified=os.epoch"utc",data=""}local A=bC.permissions[bM.owner]bC.permissions[bM.owner]=nil;bC.permissions[process.user]=A;self:setpath(process.user,g,bC)return self:_open_internal(process,g,p)else return nil,"File not found"end elseif bK.type=="directory"then return nil,"Is a directory"end;if process.user~="root"then local bO=bK.permissions[process.user]or bK.worldPermissions;if p:sub(1,1)=="r"and not bO.read or(p:sub(1,1)=="w"or p:sub(1,1)=="a")and not bO.write then return nil,"Permission denied"end end;if bK.type=="fifo"then local bC=self:getpath(process.user,g)local bP=fifos[bC]if not bP then bP={data=""}fifos[bC]=bP end;return filesystem.fifohandle(process,bP,p)end;return self:_open_internal(process,g,p)end;function filesystems.tmpfs:list(process,g)local bk=self:getpath(process.user,g)if not bk or bk.type~="directory"then error(g..": Not a directory",2)end;if process.user~="root"then local bO=bk.permissions[process.user]or bk.worldPermissions;if not bO.read then error(g..": Permission denied",2)end end;local a7={}for j in pairs(bk.contents)do a7[#a7+1]=j end;table.sort(a7)return a7 end;function filesystems.tmpfs:stat(process,g,bG)local bk=self:getpath(process.user,g,bG)if not bk then return nil end;return{size=bk.type=="file"and#bk.data or(bk.type=="directory"and#bk.contents or 0),type=bk.type,created=bk.created,modified=bk.modified,owner=bk.owner,permissions=deepcopy(bk.permissions),worldPermissions=deepcopy(bk.worldPermissions),setuser=bk.setuser,capacity=math.huge,freeSpace=math.huge,link=rawget(bk,"link"),special={}}end;function filesystems.tmpfs:remove(process,g)if self.readOnly then error("Read-only filesystem",2)end;local c2=self:getpath(process.user,fs.getDir(g))local o=fs.getName(g)if not c2 or c2.type~="directory"or not c2.contents[o]then return end;if process.user~="root"and not(c2.permissions[process.user]or c2.worldPermissions).write then error(g..": Permission denied",2)end;local bk=c2.contents[o]if process.user~="root"and not(bk.permissions[process.user]or bk.worldPermissions).write then error(g..": Permission denied",2)end;local function bS(bt)local bO=bt.permissions[process.user]or bt.worldPermissions;if process.user~="root"and not bO.write then error(g..": Permission denied",3)end;if bt.type=="directory"then if process.user~="root"and not bO.read then error(g..": Permission denied",3)end;for B,k in pairs(bt.contents)do bS(k)end end end;bS(bk)c2.contents[o]=nil;c2.modified=os.epoch"utc"end;function filesystems.tmpfs:rename(process,bT,bU)if self.readOnly then error("Read-only filesystem",2)end;local c3=self:getpath(process.user,fs.getDir(bT))local c4=fs.getName(bT)if not c3 or c3.type~="directory"or not c3.contents[c4]then error(bT..": No such file or directory",2)end;if process.user~="root"and not(c3.permissions[process.user]or c3.worldPermissions).write then error(bT..": Permission denied",2)end;local c5=c3.contents[c4]if process.user~="root"and not(c5.permissions[process.user]or c5.worldPermissions).write then error(bT..": Permission denied",2)end;local c6=self:getpath(process.user,fs.getDir(bU))local c7=fs.getName(bU)if not c6 or c6.type~="directory"then error(bU..": No such file or directory",2)end;if process.user~="root"and not(c6.permissions[process.user]or c6.worldPermissions).write then error(bU..": Permission denied",2)end;local c8=c6.contents[c7]if c8 then error(bU..": File already exists",2)end;c6.contents[c7],c3.contents[c4]=c5,nil;local c9=os.epoch"utc"c3.modified,c6.modified=c9,c9 end;function filesystems.tmpfs:mkdir(process,g)if self.readOnly then error("Read-only filesystem",2)end;local A=self;for B,G in ipairs(split(g,"/\\"))do local bO=A.permissions[process.user]or A.worldPermissions;if A.type~="directory"then error(g..": File exists",2)elseif process.user~="root"and not bO.execute then error(g..": Permission denied",2)end;if not A.contents[G]then if process.user~="root"and not bO.write then error(g..": Permission denied",2)end;A.contents[G]={type="directory",owner=A.owner,permissions=deepcopy(A.permissions),worldPermissions=deepcopy(A.worldPermissions),created=os.epoch"utc",modified=os.epoch"utc",contents={}}A.modified=os.epoch"utc"end;A=A.contents[G]end end;function filesystems.tmpfs:link(process,g,bX)if self.readOnly then error("Read-only filesystem",2)end;local bK=self:stat(process,g)if bK then error(g..": File exists",2)end;local bL,bM=pcall(self.stat,self,process,fs.getDir(g))if not bL or not bM then if type(bM)=="table"then error(bM)end;local bN,q=pcall(self.mkdir,self,process,fs.getDir(g))if not bN then if type(q)=="table"then error(q)end;return nil,type(q)=="string"and q:gsub("kernel:%d: ","")or q end;bM=self:stat(process,fs.getDir(g))end;self:setpath(process.user,g,{type="link",owner=process.user,permissions=deepcopy(bM.permissions),worldPermissions=deepcopy(bM.worldPermissions),setuser=false,created=os.epoch"utc",modified=os.epoch"utc",path=bX},true)end;function filesystems.tmpfs:mkfifo(process,g)if self.readOnly then error("Read-only filesystem",2)end;local bK=self:stat(process,g)if bK then error(g..": File exists",2)end;local bL,bM=pcall(self.stat,self,process,fs.getDir(g))if not bL or not bM then if type(bM)=="table"then error(bM)end;local bN,q=pcall(self.mkdir,self,process,fs.getDir(g))if not bN then if type(q)=="table"then error(q)end;return nil,type(q)=="string"and q:gsub("kernel:%d: ","")or q end;bM=self:stat(process,fs.getDir(g))end;self:setpath(process.user,g,{type="fifo",owner=process.user,permissions=deepcopy(bM.permissions),worldPermissions=deepcopy(bM.worldPermissions),setuser=false,created=os.epoch"utc",modified=os.epoch"utc"},true)end;function filesystems.tmpfs:chmod(process,g,user,p)if self.readOnly then error("Read-only filesystem",2)end;local bK=self:getpath(process.user,g,true)if not bK then error(g..": No such file or directory",2)end;if not bK.owner or process.user~="root"and process.user~=bK.owner then error(g..": Permission denied",2)end;local bO;if user==nil then bO=bK.worldPermissions else bO=bK.permissions[user]if not bO then bO=deepcopy(bK.worldPermissions)bK.permissions[user]=bO end end;if type(p)=="string"then if p:match"^[%+%-=][rwxs]+$"then local C=p:sub(1,1)local A={}for ab in p:gmatch("[rwxs]")do if ab=="r"then A.read=true elseif ab=="w"then A.write=true elseif ab=="s"then A.setuser=true else A.execute=true end end;if C=="+"then if A.read then bO.read=true end;if A.write then bO.write=true end;if A.execute then bO.execute=true end;if A.setuser then bK.setuser=true end elseif C=="-"then if A.read then bO.read=false end;if A.write then bO.write=false end;if A.execute then bO.execute=false end;if A.setuser then bK.setuser=false end else bO.read=A.read or false;bO.write=A.write or false;bO.execute=A.execute or false;bK.setuser=A.setuser or false end else bO.read=p:sub(1,1)~="-"bO.write=p:sub(2,2)~="-"bO.execute=p:sub(3,3)~="-"bK.setuser=p:sub(3,3)=="s"end elseif type(p)=="number"then bK.setuser=bit32.btest(p,8)bO.read=bit32.btest(p,4)bO.write=bit32.btest(p,2)bO.execute=bit32.btest(p,1)else if p.read~=nil then bO.read=p.read end;if p.write~=nil then bO.write=p.write end;if p.execute~=nil then bO.execute=p.execute end;if p.setuser~=nil then bK.setuser=p.setuser end end end;function filesystems.tmpfs:chown(process,g,bY)if self.readOnly then error("Read-only filesystem",2)end;local bK=self:getpath(process.user,g,true)if not bK then error(g..": No such file or directory",2)end;if not bK.owner or process.user~="root"and process.user~=bK.owner then error(g..": Permission denied",2)end;bK.owner=bY;bK.setuser=false end;function filesystems.tmpfs:info()return"tmpfs","memory",{ro=self.readOnly}end;setmetatable(filesystems.drivefs,{__index=filesystems.craftos})function filesystems.drivefs:stat(process,g)local w,q=filesystems.craftos.stat(self,process,g)if g==""and w==nil then return{size=0,type="directory",created=0,modified=0,owner=self.owner,capacity=0,freeSpace=0,permissions={[self.owner]={read=false,write=true,execute=false}},worldPermissions={read=false,write=false,execute=false},setuser=false}end;return w,q end;function filesystems.drivefs:new(process,bE,bJ)local ca=hardware.get(bE)if not ca then error("Could not find drive at "..bE)end;local g=hardware.call(process,ca,"getMountPath")local fs=filesystems.craftos:new(process,g,bJ)fs.drive=ca.uuid;fs.owner=process.user;fs.meta={meta={type="directory",owner="root",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}}fs.metapath=fs.combine(g,".meta.ltn")local a=fs.open(fs.metapath,"r")if a then fs.meta=unserialize(a.readAll())or fs.meta;a.close()end;return setmetatable(fs,{__index=self})end;function filesystems.drivefs:info()return"drivefs",self.drive,{ro=self.readOnly}end;setmetatable(filesystems.tablefs,{__index=filesystems.tmpfs})function filesystems.tablefs:new(process,bE,bJ)local A;local a,q;if process~=KERNEL and mounts[""]then a,q=filesystem.open(process,bE,"r")else a,q=fs.open(bE,"r")end;if a then local bk=a.readAll()or""a.close()local bh,w=pcall(unserialize,bk)if not bh then error("Could not mount "..bE..": "..w,3)elseif type(w)~="table"or w.type~="directory"or type(w.contents)~="table"then error("Could not mount "..bE..": Invalid table file",3)end;A=w else if not(bJ.rw and not bJ.ro)then error("Could not mount "..bE..": "..q,3)end;A={type="directory",owner=process.user,permissions={[process.user]={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false,created=os.epoch"utc",modified=os.epoch"utc",contents={}}end;A.src=bE;A.readOnly=bJ.ro;if bJ.rw and not bJ.ro then function A:__flush()local f,bt=self.__flush,self.src;self.__flush,self.src=nil;local bh,w=pcall(serialize,self)self.__flush,self.src=f,bt;if not bh then error(w)end;local a,q=filesystem.open(process,bE,"w")if not a then syslog.log({level=4},"Could not save mount to "..bE..": "..q)return end;a.write(w)a.close()end end;return setmetatable(A,{__index=self})end;function filesystems.tablefs:info()return"tablefs",self.src,{rw=self.__flush~=nil,ro=self.readOnly}end;function filesystems.bind:new(process,g,bJ)local bK,q=filesystem.stat(process,g)if not bK then error("Could not bind "..g..": "..q,3)elseif bK.type~="directory"then error("Could not bind "..g..": Not a directory",3)end;return setmetatable({path=g},{__index=self})end;function filesystems.bind:open(process,g,p)return filesystem.open(process,fs.combine(self.path,g),p)end;function filesystems.bind:list(process,g)return filesystem.list(process,fs.combine(self.path,g))end;function filesystems.bind:stat(process,g,bG)return filesystem.stat(process,fs.combine(self.path,g),bG)end;function filesystems.bind:remove(process,g)return filesystem.remove(process,fs.combine(self.path,g))end;function filesystems.bind:rename(process,bT,bU)return filesystem.rename(process,fs.combine(self.path,bT),fs.combine(self.path,bU))end;function filesystems.bind:mkdir(process,g)return filesystem.mkdir(process,fs.combine(self.path,g))end;function filesystems.bind:link(process,g,bX)return filesystem.link(process,fs.combine(self.path,g),bX)end;function filesystems.bind:mkfifo(process,g)return filesystem.mkfifo(process,fs.combine(self.path,g))end;function filesystems.bind:chmod(process,g,user,p)return filesystem.chmod(process,fs.combine(self.path,g),user,p)end;function filesystems.bind:chown(process,g,bY)return filesystem.chown(process,fs.combine(self.path,g),bY)end;function filesystems.bind:info()return"bind",self.path,{}end;local function cb(process,g,cc,cd)local ce=bc(process,g)if cd then if ce==""then ce=nil else ce=fs.getDir(ce)end end;if ce and fsevents[ce]then for B,k in pairs(fsevents[ce])do local cf=ce;if cf:find(k.root,1,true)==1 then cf=cf:sub(#k.root+1)end;k.eventQueue[#k.eventQueue+1]={"fsevent",{path=cf,event=cc,name=cd and fs.getName(ce)or nil,process=process.id}}end end end;function filesystem.open(process,g,p)expect(0,process,"table")expect(1,g,"string")expect(2,p,"string")if not p:match"^[rwa]b?$"then error("Invalid mode",0)end;for B=1,1000 do local bh,bj,G=pcall(bd,process,g)if not bh then return nil,bj end;local w=table.pack(pcall(bj.open,bj,process,G,p))if w[1]then if w[2]and p~="r"and p~="rb"then cb(process,g,"open",false)cb(process,g,"open_child",true)end;return table.unpack(w,2,w.n)elseif type(w[2])~="table"or type(w[2].path)~="string"then error(w[2],2)end;g=w[2].path end;error("Too many levels of symbolic links",2)end;local function cg(process,g,ch)local a7={}local mounts,G=bd(process,g,true)for B,bj in ipairs(mounts)do local bh,w=pcall(bj.list,bj,process,G)if not bh then if type(w)~="table"or type(w.path)~="string"then if#mounts==1 and ch then error(w,2)else w={}end else w=cg(process,w.path,false)end end;for B,k in ipairs(w)do a7[#a7+1]=k end end;return a7 end;function filesystem.list(process,g)expect(0,process,"table")expect(1,g,"string")local a7=cg(process,g,true)table.sort(a7)return a7 end;function filesystem.stat(process,g,bG)expect(0,process,"table")expect(1,g,"string")for B=1,1000 do local bh,bj,G,ci=pcall(bd,process,g)if not bh then return nil,bj end;local cj,w,q=pcall(bj.stat,bj,process,G,bG)if cj then if w then w.mountpoint="/"..ci end;return w,q elseif type(w)~="table"or type(w.path)~="string"then error(w,2)end;g=w.path end;error("Too many levels of symbolic links",2)end;function filesystem.remove(process,g)expect(0,process,"table")expect(1,g,"string")for B=1,1000 do local bj,G=bd(process,g)local bh,w=pcall(bj.remove,bj,process,G)if bh then cb(process,g,"remove",false)cb(process,g,"remove_child",true)return elseif type(w)~="table"or type(w.path)~="string"then error(w,2)end;g=w.path end;error("Too many levels of symbolic links",2)end;function filesystem.rename(process,bT,bU)expect(0,process,"table")expect(1,bT,"string")expect(2,bU,"string")for B=1,1000 do local ck,cl=bd(process,bT)local cm,cn=bd(process,bU)if ck~=cm then error("Attempt to rename file across two filesystems",0)end;local bh,w=pcall(ck.rename,ck,process,cl,cn)if bh then cb(process,bT,"rename_from",false)cb(process,bT,"rename_from_child",true)cb(process,bU,"rename_to",false)cb(process,bU,"rename_to_child",true)return elseif type(w)~="table"or type(w.path)~="string"then error(w,2)end;if w.orig==bT then bT=w.path else bU=w.path end end;error("Too many levels of symbolic links",2)end;function filesystem.mkdir(process,g)expect(0,process,"table")expect(1,g,"string")for B=1,1000 do local bj,G=bd(process,g)local bh,w=pcall(bj.mkdir,bj,process,G)if bh then cb(process,g,"mkdir",false)cb(process,g,"mkdir_child",true)return elseif type(w)~="table"or type(w.path)~="string"then error(w,2)end;g=w.path end;error("Too many levels of symbolic links",2)end;function filesystem.link(process,g,bX)expect(0,process,"table")expect(1,g,"string")expect(2,bX,"string")if fs.combine(g)==fs.combine(bX)then error("Cannot link file to itself",2)end;syslog.debug("Creating link",g," => ",bX)for B=1,1000 do local bj,G=bd(process,g)if not bj.link then error("Filesystem does not support links",2)end;local bh,w=pcall(bj.link,bj,process,G,bX)if bh then cb(process,g,"link",false)cb(process,g,"link_child",true)return elseif type(w)~="table"or type(w.path)~="string"then error(w,2)end;g=w.path end;error("Too many levels of symbolic links",2)end;function filesystem.mkfifo(process,g)expect(0,process,"table")expect(1,g,"string")for B=1,1000 do local bj,G=bd(process,g)if not bj.mkfifo then error("Filesystem does not support FIFOs",2)end;local bh,w=pcall(bj.mkfifo,bj,process,G)if bh then cb(process,g,"mkfifo",false)cb(process,g,"mkfifo_child",true)return elseif type(w)~="table"or type(w.path)~="string"then error(w,2)end;g=w.path end;error("Too many levels of symbolic links",2)end;function filesystem.chmod(process,g,user,p)expect(0,process,"table")expect(1,g,"string")expect(2,user,"string","nil")expect(3,p,"number","string","table")if type(p)=="string"and not p:match"^[%+%-=][rwxs]+$"and not p:match"^[r%-][w%-][xs%-]$"then error("bad argument #3 (invalid mode)",2)elseif type(p)=="table"then expect.field(p,"read","boolean","nil")expect.field(p,"write","boolean","nil")expect.field(p,"execute","boolean","nil")end;for B=1,1000 do local bj,G=bd(process,g)local bh,w=pcall(bj.chmod,bj,process,G,user,p)if bh then return elseif type(w)~="table"or type(w.path)~="string"then error(w,2)end;g=w.path end;error("Too many levels of symbolic links",2)end;function filesystem.chown(process,g,user)expect(0,process,"table")expect(1,g,"string")expect(2,user,"string")for B=1,1000 do local bj,G=bd(process,g)local bh,w=pcall(bj.chown,bj,process,G,user)if bh then return elseif type(w)~="table"or type(w.path)~="string"then error(w,2)end;g=w.path end;error("Too many levels of symbolic links",2)end;function filesystem.chroot(process,g)expect(0,process,"table")expect(1,g,"string")if process.user~="root"then error("Could not change root: Permission denied",2)end;local co=filesystem.combine(process.root,g).."/"if co:find(process.root,1,true)~=1 then error("Could not change root: No such file or directory",2)end;local bt=filesystem.stat(process,"/"..g)if not bt then error(g..": No such directory",2)end;if bt.type~="directory"then error(g..": Not a directory",2)end;process.root=co end;function filesystem.mount(process,type,bE,bF,bJ)expect(0,process,"table")expect(1,type,"string")expect(2,bE,"string")expect(3,bF,"string")expect(4,bJ,"table","nil")if not filesystems[type]then error("No such filesystem '"..type.."'",2)end;local G=bc(process,bF)if G==""then if process.user~="root"then error("Could not mount to "..bF..": Permission denied",2)end;if mounts[G]and not(bJ and bJ.overlay)then error("Could not mount to "..bF..": Mount already exists (use overlay to mount over)")end;if not mounts[G]and(bJ and bJ.overlay)then error("Could not mount to "..bF..": No base mount exists for overlay")end else local bK=filesystem.stat(process,bF)if not bK then error("Could not mount to "..bF..": No such directory",2)end;if bK.type~="directory"then error("Could not mount to "..bF..": Not a directory",2)end;if process.user~="root"and not(bK.permissions[process.user]or bK.worldPermissions).write then error("Could not mount to "..bF..": Permission denied",2)end;if mounts[G]and not(bJ and bJ.overlay)then error("Could not mount to "..bF..": Mount already exists (use overlay to mount over)")end;if not mounts[G]and(bJ and bJ.overlay)then error("Could not mount to "..bF..": No base mount exists for overlay")end end;local bj=filesystems[type]:new(process,bE,bJ or{})if bJ and bJ.overlay then mounts[G][#mounts[G]+1]=bj else mounts[G]={bj}end end;function filesystem.unmount(process,g)expect(0,process,"table")expect(1,g,"string")g=bc(process,g)if not mounts[g]then error(g..": No such mount",2)end;local bZ=#mounts[g]local bK=mounts[g][bZ]:stat(process,"")if not bK then error("Internal error in unmount: could not get stat for root! Please report this to the maintainer of the target filesystem.",2)elseif process.user~="root"and not(bK.permissions[process.user]or bK.worldPermissions).write then error(g..": Permission denied",2)end;if mounts[g][bZ].unmount then mounts[g][bZ]:unmount(process)end;mounts[g][bZ]=nil;if bZ==1 then mounts[g]=nil end end;function filesystem.mountlist(process)expect(0,process,"table")local a7={}for j,k in pairs(mounts)do if"/"..j.."/"==process.root or j:find(process.root:sub(2),1,true)==1 then for B,bj in ipairs(k)do local type,g,bJ=bj:info()a7[#a7+1]={path="/"..j,type=type,source=g,options=bJ}end end end;return a7 end;function filesystem.combine(cp,...)expect(1,cp,"string")local a2=fs.combine(cp,...)if cp:match"^/"then a2="/"..a2 end;return a2 end;function syscalls.open(process,as,...)return filesystem.open(process,...)end;function syscalls.list(process,as,...)return filesystem.list(process,...)end;function syscalls.stat(process,as,...)return filesystem.stat(process,...)end;function syscalls.remove(process,as,...)return filesystem.remove(process,...)end;function syscalls.rename(process,as,...)return filesystem.rename(process,...)end;function syscalls.mkdir(process,as,...)return filesystem.mkdir(process,...)end;function syscalls.link(process,as,...)return filesystem.link(process,...)end;function syscalls.mkfifo(process,as,...)return filesystem.mkfifo(process,...)end;function syscalls.chmod(process,as,...)return filesystem.chmod(process,...)end;function syscalls.chown(process,as,...)return filesystem.chown(process,...)end;function syscalls.chroot(process,as,...)return filesystem.chroot(process,...)end;function syscalls.mount(process,as,...)return filesystem.mount(process,...)end;function syscalls.unmount(process,as,...)return filesystem.unmount(process,...)end;function syscalls.mountlist(process,as,...)return filesystem.mountlist(process,...)end;function syscalls.combine(process,as,...)return filesystem.combine(...)end;function syscalls.loadCraftOSAPI(process,as,cq)expect(1,cq,"string")local e;e=setmetatable({dofile=function(g)local a,q=fs.open(g,"rb")if not a then error("Could not open module: "..q,0)end;local i,q=load(a.readAll(),"@"..g,nil,e)a.close()if not i then error("Could not load module: "..q,0)end;return i()end,require=function(o)return e.dofile("rom/modules/main/"..o:gsub("%.","/")..".lua")end},{__index=process.env})e._ENV=e;if cq:sub(1,3)=="cc."then local g=fs.combine("rom/modules/main",cq:gsub("%.","/")..".lua")if not g:match"^/?rom/modules/main/"then error("Invalid module path",0)end;return e.dofile(g)else if not cq:match"^[a-z]+$"then error("Invalid API name",0)end;local g=fs.combine("rom/apis",cq..".lua")local a,q=fs.open(g,"rb")if not a then error("Could not open module: "..q,0)end;local i,q=load(a.readAll(),"@"..g,nil,e)a.close()if not i then error("Could not load module: "..q,0)end;i()local A={}for j,k in pairs(e)do if j~="dofile"and j~="require"and j~="_ENV"then A[j]=k end end;return A end end;function syscalls.fsevent(process,as,g,cr)expect(1,g,"string")expect(2,cr,"boolean","nil")if cr==nil then cr=true end;g=bc(process,g)syslog.debug("Registering fsevents for",g)fsevents[g]=fsevents[g]or setmetatable({},{__mode="v"})fsevents[g][#fsevents[g]+1]=cr and process or nil end;xpcall(function()if args.initrd then if args.initrd:match"^_G%.."then local ch=_G[args.initrd:match"^_G%.(.+)"]if type(ch)~="table"then error("Requested root filesystem in global '"..args.initrd.."' is not a table")end;ch.src=args.initrd;mounts[""]={setmetatable(ch,{__index=filesystems.tablefs})}else mounts[""]={filesystems.tablefs:new(KERNEL,args.initrd,{})}end else local bJ={}if args.rootflags then for C in args.rootflags:gmatch"[^,]+"do local j,k=C:match("^([^=]+)=(.*)$")if j and k then if k=="true"then bJ[j]=true elseif k=="false"then bJ[j]=false else bJ[j]=tonumber(k)or k end else bJ[C]=true end end end;mounts[""]={filesystems[args.rootfstype]:new(KERNEL,args.root,bJ)}end end,panic)local do_syscall=do_syscall;local expect=expect;local function cs(ct,cu,cv,cw)local cx={bit32.extract(cu,0,16),bit32.extract(cu,16,16),bit32.extract(ct,0,16),bit32.extract(ct,16,16)}local ad={bit32.extract(cw,0,16),bit32.extract(cw,16,16),bit32.extract(cv,0,16),bit32.extract(cv,16,16)}local bz={{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0}}for cy=1,4 do for cz=1,4 do local t=cx[cz]*ad[cy]+bz[cy][cz]bz[cy][cz+1],bz[cy][cz]=bit32.rshift(t,16),bit32.band(t,0xFFFF)end end;local cA={0,0,0,0,0,0,0,0}for cB=1,8 do for cC=1,4 do cA[cB]=cA[cB]+(bz[cC][cB-cC+1]or 0)end;cA[cB+1],cA[cB]=bit32.rshift(cA[cB],16),bit32.band(cA[cB],0xFFFF)end;return cA[3]+cA[4]*0x10000,cA[1]+cA[2]*0x10000 end;local function cD(ad,ct,cu)return ct+math.floor((cu+ad)/0x100000000),bit32.band(cu+ad,0xFFFFFFFF)end;function makeRandom()local cE,cF=0,0;local function next(cG)cE,cF=cD(0xB,cs(cE,cF,0x5,0xDEECE66D))cE=bit32.band(cE,0xFFFF)return math.floor(cE/2^(16-cG))+math.floor(cF/2^(48-cG))end;local function cH(c,d)expect(1,c,"number","nil")expect(2,d,"number","nil")if c then expect.range(c,0,0x7FFFFFFF)if not d then c,d=0,c else expect.range(d,0,0x7FFFFFFF)end;local cI=d-c+1;local cJ;if math.log(cI,2)%1==0 then cJ=math.floor(cI*next(31)/0x80000000)else local cG;repeat cG=next(31)cJ=cG%cI until cG-cJ+cI-1>=0 end;return cJ+c else return(next(26)*0x8000000+next(27))/0x20000000000000 end end;local function cK(cL)expect(1,cL,"number")cE,cF=bit32.band(bit32.bxor(0x5,math.floor(cL/0x100000000)),0xFFFF),bit32.bxor(0xDEECE66D,math.floor(cL))end;cK(os.epoch"utc"*tonumber(tostring(next):match("%x+")or"1",16))return cH,cK end;do math.random,math.randomseed=makeRandom()end;function createLuaLib(process)local cM={}for B,k in ipairs{"assert","error","getmetatable","ipairs","next","pairs","pcall","rawequal","rawget","rawset","select","setmetatable","tonumber","tostring","type","_VERSION","xpcall","collectgarbage"}do cM[k]=_G[k]end;function cM.dofile(g)if g~=nil and type(g)~="string"then error("bad argument #1 (expected string, got "..type(g)..")",2)end;local i,q=loadfile(g or io.stdin:read("*a"))if not i then error(q,2)end;return i()end;do local load,getfenv,setfenv,make_ENV=load,getfenv,setfenv,make_ENV;if _VERSION=="Lua 5.1"then function cM.load(n,o,p,e)return load(n,o,p,make_ENV(e or process.env))end;function cM.getfenv(f)local k;if f==nil then k=getfenv(2)elseif tonumber(f)and tonumber(f)>0 then k=getfenv(f+1)elseif type(f)=="function"then k=getfenv(f)else k=getfenv(f)end;local aD=getmetatable(f)if aD and aD.__env then return aD.__env else return k end end;function cM.setfenv(f,M)return setfenv(f,make_ENV(M))end else cM.load,cM.getfenv,cM.setfenv=function(n,o,p,e)return load(n,o,p,e or process.env)end,getfenv,setfenv end end;function cM.loadfile(g,p,e)if e==nil and type(p)=="table"then e,p=p,nil end;if type(g)~="string"then error("bad argument #1 (expected string, got "..type(g)..")",2)end;if p~=nil and type(p)~="string"then error("bad argument #2 (expected string, got "..type(p)..")",2)end;if e~=nil and type(e)~="table"then error("bad argument #3 (expected table, got "..type(e)..")",2)end;local a,q=do_syscall("open",g,"rb")if not a then error(q,2)end;local bk=a.readAll()a.close()return load(bk,"@"..g,p,e)end;function cM.print(...)local args=table.pack(...)if args.n==0 then args={"",n=1}end;args[args.n]=tostring(args[args.n]).."\n"return do_syscall("write",table.unpack(args,1,args.n))end;cM.coroutine=deepcopy(coroutine)cM.string=deepcopy(string)cM.table=deepcopy(table)cM.math=deepcopy(math)cM.bit32=deepcopy(bit32)cM.utf8=deepcopy(utf8)cM.math.random,cM.math.randomseed=makeRandom()local cN=cM.coroutine.resume;cM.coroutine.resume=function(cO,...)local a7=table.pack(cN(cO,...))while a7.n>=2 and a7[1]==true and(a7[2]=="preempt"or a7[2]=="secure_syscall"or a7[2]=="secure_event")do a7=table.pack(cN(cO,coroutine.yield(table.unpack(a7,2,a7.n))))end;return table.unpack(a7,1,a7.n)end;local cP=""local cQ=setmetatable({close=function()end,lines=function(self,...)local args=table.pack(...)return function()return self:read(table.unpack(args,1,args.n))end end,read=function(self,a8,...)local bt,M;a8=a8 or"*l"if type(a8)=="number"then while#cP<a8 do cP=cP..do_syscall("read",a8)end elseif type(a8)=="string"then a8=a8:gsub("^%*","")if a8=="n"then while not cP:find("%d")do local bu=do_syscall("readline")if bu==nil then break end;cP=cP..bu.."\n"end elseif a8=="a"then while true do local bu=do_syscall("readline")if bu==nil then break end;cP=cP..bu.."\n"end elseif a8=="l"or a8=="L"then local bu=do_syscall("readline")if bu==nil then return nil end;cP=cP..bu.."\n"else error("bad argument (invalid format '"..a8 .."')",2)end else error("bad argument (expected string or number, got "..type(a8),2)end;if type(a8)=="number"then bt,M=cP:sub(1,a8),a8+1 elseif a8=="n"then bt,M=cP:match("(%d)()")elseif a8=="a"then bt,M=cP,#cP+1 elseif a8=="l"then bt,M=cP:match("(.*)\n()")else bt,M=cP:match("(.*\n)()")end;if not bt then return nil end;cP=cP:sub(M)if select("#",...)>0 then return bt,self:read(...)else return bt end end,seek=function()return nil,"Cannot seek default file"end,setvbuf=function()end},{__name="FILE*"})local cR=setmetatable({close=function()end,flush=function()end,seek=function()return nil,"Cannot seek default file"end,setvbuf=function()end,write=function(self,...)do_syscall("write",...)return self end},{__name="FILE*"})local cS=setmetatable({close=function()end,flush=function()end,seek=function()return nil,"Cannot seek default file"end,setvbuf=function()end,write=function(self,...)do_syscall("writeerr",...)return self end},{__name="FILE*"})local cT,cU=cQ,cR;local cV={close=function(self)self._file.close()self._closed=true end,lines=function(self,...)local args=table.pack(...)return function()return self:read(table.unpack(args,1,args.n))end end,read=function(self,a8,...)local k;if a8==nil then a8="l"end;if type(a8)=="number"then k=self._file.read(a8)elseif type(a8)=="string"then a8=a8:gsub("^%*","")if a8=="a"then k=self._file.readAll()elseif a8=="l"then k=self._file.readLine(false)elseif a8=="L"then k=self._file.readLine(true)elseif a8=="n"then local bt,ab=""repeat ab=self._file.read(1)until ab:match("%d")while ab:match("%d")do bt,ab=bt..ab,self._file.read(1)end;k=tonumber(bt)else error("bad argument (invalid format '"..a8 .."')",2)end else error("bad argument (expected string or number, got "..type(a8)..")",2)end;if select("#",...)>0 then return k,self:read(...)else return k end end,seek=function(self,bs,W)if self._file.seek then return self._file.seek(bs,W)else return nil,"Cannot seek text file"end end,setvbuf=function()end}local cW={close=function(self)self._file.close()self._closed=true end,flush=function(self)self._file:flush()end,seek=function(self,bs,W)if self._file.seek then return self._file.seek(bs,W)else return nil,"Cannot seek text file"end end,setvbuf=function()end,write=function(self,...)self._file.write(...)return self end}cM.io={close=function(a)if a==nil then cU:close()elseif type(a)=="table"and getmetatable(a)and getmetatable(a).__name=="FILE*"then a:close()else error("bad argument #1 (expected FILE*, got "..type(a)..")",2)end end,flush=function()return cU:flush()end,input=function(a)if a==nil then return cT elseif type(a)=="string"then local ai,q=io.open(a,"r")if not ai then error(q,2)end;cT=ai elseif type(a)=="table"and getmetatable(a)and getmetatable(a).__name=="FILE*"then cT=a else error("bad argument #1 (expected string or FILE*, got "..type(a)..")",2)end end,lines=function(cX,...)if cX==nil then return cT:lines(...)end;if type(cX)~="string"then error("bad argument #1 (expected string, got "..type(cX)..")",2)end;local ai,q=io.open(cX,"r")if not ai then error(q,2)end;local i=ai:lines(...)return function(...)local a7=table.pack(i(...))if a7.n==0 or a7[1]==nil then ai:close()end;return table.unpack(a7,1,a7.n)end end,open=function(cX,p)if type(cX)~="string"then error("bad argument #1 (expected string, got "..type(cX)..")",2)end;if p==nil then p="r"end;if type(p)~="string"then error("bad argument #2 (expected string, got "..type(p)..")",2)end;local a,q=do_syscall("open",cX,p)if not a then return nil,q elseif p:find("r")then return setmetatable({_file=a},{__index=cV,__name="FILE*"})else return setmetatable({_file=a},{__index=cW,__name="FILE*"})end end,output=function(a)if a==nil then return cU elseif type(a)=="string"then local ai,q=io.open(a,"w")if not ai then error(q,2)end;cU=ai elseif type(a)=="table"and getmetatable(a)and getmetatable(a).__name=="FILE*"then cU=a else error("bad argument #1 (expected string or FILE*, got "..type(a)..")",2)end end,popen=function(g,p)expect(1,g,"string")p=expect(2,p,"string","nil")or"r"if p~="r"and p~="w"and p~="rw"then error("bad argument #2 (invalid mode)",2)end;if p=="rw"then local cY,cZ="",""local c_;local d0={read=function(t)if cY==""then return nil elseif t then local bt=cY:sub(1,t)cY=cY:sub(t+1)return bt else local bt,M=cY:match"([^\n]*)\n*()"cY=cY:sub(M)return bt end end}local d1={write=function(bt)cY=cY..bt end,flush=function()end,close=function()local b5=do_syscall("getpinfo",c_)if not b5 then return end;repeat local at,d2=coroutine.yield()until at=="process_complete"and d2.pid==c_ end}local d3={read=function(t)if cZ==""then return nil elseif t then local bt=cZ:sub(1,t)cZ=cZ:sub(t+1)return bt else local bt,M=cZ:match"([^\n]*)\n*()"cZ=cZ:sub(M)return bt end end,readLine=function()local bt,M=cZ:match"([^\n]*)\n*()"cZ=cZ:sub(M)return bt end,readAll=function()local bt=cZ;cZ=""return bt end,close=function()local b5=do_syscall("getpinfo",c_)if not b5 then return end;repeat local at,d2=coroutine.yield()until at=="process_complete"and d2.pid==c_ end}local d4={write=function(bt)cZ=cZ..bt end}c_=do_syscall("fork",function()do_syscall("stdin",d0)do_syscall("stdout",d4)do_syscall("exec","/bin/sh","-c",g)end)return setmetatable({_file=d3},{__index=cV,__name="FILE*"}),setmetatable({_file=d1},{__index=cW,__name="FILE*"})else local d5=""local bp=false;local c_;local d6={read=function(t)if d5==""then if bp then return nil else return""end elseif t then local bt=d5:sub(1,t)d5=d5:sub(t+1)return bt else local bt,M=d5:match"([^\n]*\n?)()"d5=d5:sub(M)return bt end end,readLine=function()local bt,M=d5:match"([^\n]*\n?)()"d5=d5:sub(M)return bt end,readAll=function()local bt=d5;d5=""return bt end,close=function()bp=true;local b5=do_syscall("getpinfo",c_)if not b5 then return end;repeat local at,d2=coroutine.yield()until at=="process_complete"and d2.pid==c_ end}local d7={write=function(bt)d5=d5 ..bt end,flush=function()end,close=function()bp=true;local b5=do_syscall("getpinfo",c_)if not b5 then return end;repeat local at,d2=coroutine.yield()until at=="process_complete"and d2.pid==c_ end}c_=do_syscall("fork",function()do_syscall(p=="r"and"stdout"or"stdin",p=="r"and d7 or d6)do_syscall("exec","/bin/sh","-c",g)end)return p=="r"and setmetatable({_file=d6},{__index=cV,__name="FILE*"})or setmetatable({_file=d7},{__index=cW,__name="FILE*"})end end,read=function(...)return cT:read(...)end,tmpfile=function()return io.open(os.tmpname(),"a")end,type=function(bB)if type(bB)=="table"and getmetatable(bB)and getmetatable(bB).__name=="FILE*"then if bB._closed then return"closed file"else return"file"end else return nil end end,write=function(...)return cU:write(...)end,stdin=cQ,stdout=cR,stderr=cS}local d8=os;cM.os={clock=function()return do_syscall("clock")end,date=function(a8,c9)if type(a8)=="string"and a8:sub(1,1)=="?"then local br=d8.date("!"..a8:sub(2),c9 or d8.epoch"ingame"/1000)if type(br)=="table"then br.year=br.year-1970 end;return br else return d8.date(a8,c9)end end,difftime=function(cx,ad)return cx-ad end,execute=function(g)do_syscall("exec","/bin/sh","-c",g)end,exit=function(bv)do_syscall("exit",bv)end,getenv=function(o)expect(1,o,"string")local e=do_syscall("getenv")if not e then return nil end;return e[o]end,remove=function(g)expect(1,g,"string")local bh,q=do_syscall("remove",g)if not bh then bh=nil end;return bh,q end,rename=function(bT,bU)expect(1,bT,"string")expect(2,bU,"string")local bh,q=do_syscall("rename",bT,bU)if not bh then bh=nil end;return bh,q end,setlocale=function(d9)if d9 then error("setlocale is not supported",2)else return"C"end end,time=function(A)if A=="ingame"then return d8.epoch"ingame"/1000 elseif A=="nano"then return ccemux and ccemux.nanoTime()or d8.epoch"nano"end;expect(1,A,"table","nil")if A then return d8.time(A)else return d8.epoch"utc"/1000 end end,tmpname=function()local o="/tmp/lua_"for x=1,6 do local t=math.random(1,64)o=o..("qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890._"):sub(t,t)end;return o end}cM.debug=deepcopy(debug)createRequire(process,cM)for j,k in pairs(cM)do if type(k)=="function"then pcall(setfenv,k,cM)pcall(debug.protect,k)elseif type(k)=="table"and j~="debug"then for B,ah in pairs(k)do if type(ah)=="function"then pcall(setfenv,ah,cM)pcall(debug.protect,ah)end end end end;return cM end;function loadfile(g,p,e)if e==nil and type(p)=="table"then e,p=p,nil end;if type(g)~="string"then error("bad argument #1 (expected string, got "..type(g)..")",2)end;if p~=nil and type(p)~="string"then error("bad argument #2 (expected string, got "..type(p)..")",2)end;if e~=nil and type(e)~="table"then error("bad argument #3 (expected table, got "..type(e)..")",2)end;local a,q=filesystem.open(KERNEL,g,"rb")if not a then error(q,2)end;local bk=a.readAll()a.close()return load(bk,"@"..g,p,e)end;function dofile(g)if g~=nil and type(g)~="string"then error("bad argument #1 (expected string, got "..type(g)..")",2)end;local i,q=loadfile(g or io.stdin:read("*a"))if not i then error(q,2)end;return i()end;function print(...)for x=1,select("#",...)do local k=tostring(select(x,...))terminal.write(TTY[1],k)end end;function terminal.makeTTY(term,v,da)local a7={isTTY=true,flags={cbreak=false,delay=true,echo=true,keypad=false,nlcr=true,raw=false},cursor={x=1,y=1},cursorBlink=true,colors={fg='0',bg='f',bold=false},size={width=v,height=da},dirtyLines={},palette={},dirtyPalette={},buffer="",preBuffer="",isLocked=false,isGraphics=false,textBuffer={},graphicsBuffer={},frontmostProcess=nil,processList={},eof=false,term=term}for s=1,da do a7[s]={(' '):rep(v),('0'):rep(v),('f'):rep(v)}a7.dirtyLines[s]=true end;for x=0,15 do a7.palette[x]={_G.term.nativePaletteColor(2^x)}a7.dirtyPalette[x]=true end;return a7 end;do local db,dc=term.getSize()TTY={terminal.makeTTY(term,db,dc),terminal.makeTTY(term,db,dc),terminal.makeTTY(term,db,dc),terminal.makeTTY(term,db,dc),terminal.makeTTY(term,db,dc),terminal.makeTTY(term,db,dc),terminal.makeTTY(term,db,dc),terminal.makeTTY(term,db,dc)}end;currentTTY=TTY[1]terminal.userTTYs={}do local t=args.console:match"^tty(%d+)$"if t then KERNEL.stdout,KERNEL.stderr,KERNEL.stdin=TTY[tonumber(t)],TTY[tonumber(t)],TTY[tonumber(t)]end end;keysHeld={ctrl=false,alt=false,shift=false}eventHooks.term_resize=eventHooks.term_resize or{}eventHooks.char=eventHooks.char or{}eventHooks.paste=eventHooks.paste or{}eventHooks.key=eventHooks.key or{}eventHooks.key_up=eventHooks.key_up or{}eventHooks.term_resize[#eventHooks.term_resize+1]=function()local ah,ai=term.getSize()for x=1,8 do terminal.resize(TTY[x],ah,ai)end end;eventHooks.char[#eventHooks.char+1]=function(at)if not currentTTY.isLocked then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer..at[2]else currentTTY.preBuffer=currentTTY.preBuffer..at[2]end;if currentTTY.flags.echo then terminal.write(currentTTY,at[2])terminal.redraw(currentTTY)end end end;eventHooks.paste[#eventHooks.paste+1]=function(at)if not currentTTY.isLocked then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer..at[2]else currentTTY.preBuffer=currentTTY.preBuffer..at[2]end;if currentTTY.flags.echo then terminal.write(currentTTY,at[2])terminal.redraw(currentTTY)end end end;eventHooks.key[#eventHooks.key+1]=function(at)if not currentTTY.isLocked then if at[2]==keys.enter then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer.."\n"else currentTTY.buffer=currentTTY.buffer..currentTTY.preBuffer.."\n"currentTTY.preBuffer=""end;if currentTTY.flags.echo then terminal.write(currentTTY,"\n")terminal.redraw(currentTTY)end elseif at[2]==keys.backspace then if currentTTY.flags.cbreak then elseif#currentTTY.preBuffer>0 then currentTTY.preBuffer=currentTTY.preBuffer:sub(1,-2)if currentTTY.flags.echo then terminal.write(currentTTY,"\b \b")terminal.redraw(currentTTY)end end end end;if at[2]==keys.leftCtrl or at[2]==keys.rightCtrl then keysHeld.ctrl=true elseif at[2]==keys.leftAlt or at[2]==keys.rightAlt then keysHeld.alt=true elseif at[2]==keys.leftShift or at[2]==keys.rightShift then keysHeld.shift=true end;if not currentTTY.flags.raw and currentTTY.frontmostProcess and keysHeld.ctrl and not keysHeld.alt and not keysHeld.shift then if at[2]==keys.c then killProcess(currentTTY.frontmostProcess.id,2)terminal.write(currentTTY,"^C")elseif at[2]==keys.backslash then killProcess(currentTTY.frontmostProcess.id,3)terminal.write(currentTTY,"^\\")elseif at[2]==keys.z then killProcess(currentTTY.frontmostProcess.id,19)terminal.write(currentTTY,"^Z")elseif at[2]==keys.d then currentTTY.eof=true;terminal.write(currentTTY,"^D")elseif at[2]==keys.l and currentTTY.cursor.y>1 then local s=currentTTY.cursor.y-1;terminal.write(currentTTY,"\x1b["..s.."T\x1b[1;"..currentTTY.cursor.x.."H")end end;if keysHeld.ctrl and not keysHeld.alt and keysHeld.shift then local dd=true;if at[2]==keys.f1 then currentTTY=TTY[1]elseif at[2]==keys.f2 then currentTTY=TTY[2]elseif at[2]==keys.f3 then currentTTY=TTY[3]elseif at[2]==keys.f4 then currentTTY=TTY[4]elseif at[2]==keys.f5 then currentTTY=TTY[5]elseif at[2]==keys.f6 then currentTTY=TTY[6]elseif at[2]==keys.f7 then currentTTY=TTY[7]elseif at[2]==keys.f8 then currentTTY=TTY[8]elseif at[2]==keys.left then for x=1,8 do if currentTTY==TTY[x]then currentTTY=TTY[(x+7)%8]break end end elseif at[2]==keys.right then for x=1,8 do if currentTTY==TTY[x]then currentTTY=TTY[(x+1)%8]break end end else dd=false end;if dd then terminal.redraw(currentTTY,true)end end end;eventHooks.key_up[#eventHooks.key_up+1]=function(at)if at[2]==keys.leftCtrl or at[2]==keys.rightCtrl then keysHeld.ctrl=false elseif at[2]==keys.leftAlt or at[2]==keys.rightAlt then keysHeld.alt=false elseif at[2]==keys.leftShift or at[2]==keys.rightShift then keysHeld.shift=false end end;function terminal.redraw(de,c0)if de.process then de.process.eventQueue[#de.process.eventQueue+1]={"tty_redraw",{id=de.id}}return elseif currentTTY~=de and not de.isMonitor then return end;local term=de.term;local d5=de;if de.isLocked then if de.isGraphics then term.setGraphicsMode(2)if term.setFrozen then term.setFrozen(true)end;if c0 then term.clear()term.drawPixels(0,0,de.graphicsBuffer)for x=0,255 do term.setPaletteColor(x,de.graphicsBuffer.palette[x][1],de.graphicsBuffer.palette[x][2],de.graphicsBuffer.palette[x][3])end else if de.graphicsBuffer.frozen then if term.setFrozen then term.setFrozen(false)end;return end;for B,k in ipairs(de.graphicsBuffer.dirtyRects)do if k.color then term.setPixel(k.x,k.y,k.color,k.width,k.height)else term.drawPixels(k.x,k.y,k)end end;for x in pairs(de.graphicsBuffer.dirtyPalette)do term.setPaletteColor(x,de.graphicsBuffer.palette[x][1],de.graphicsBuffer.palette[x][2],de.graphicsBuffer.palette[x][3])end end;if term.setFrozen then term.setFrozen(false)end;d5.dirtyRects,d5.dirtyPalette={},{}return end;if term.setGraphicsMode then term.setGraphicsMode(false)end;d5=de.textBuffer elseif de.isGraphics then term.setGraphicsMode(false)de.isGraphics=false end;term.setCursorBlink(false)if c0 then term.clear()for s=1,de.size.height do term.setCursorPos(1,s)term.blit(d5[s][1],d5[s][2],d5[s][3])end;for x=0,15 do term.setPaletteColor(2^x,d5.palette[x][1],d5.palette[x][2],d5.palette[x][3])end else for s in pairs(d5.dirtyLines)do if not d5[s]then error(debug.traceback(s))end;term.setCursorPos(1,s)if#d5[s][1]~=#d5[s][2]or#d5[s][2]~=#d5[s][3]then syslog.log({level="critical"},"Bug in text writer! Inequal lengths: "..#d5[s][1]..", "..#d5[s][2]..", "..#d5[s][3])error("Invalid lengths")end;term.blit(d5[s][1],d5[s][2],d5[s][3])end;for x in pairs(d5.dirtyPalette)do term.setPaletteColor(2^x,d5.palette[x][1],d5.palette[x][2],d5.palette[x][3])end end;term.setCursorPos(d5.cursor.x,d5.cursor.y)term.setCursorBlink(d5.cursorBlink)term.setTextColor(2^tonumber(d5.colors.fg,16))d5.dirtyLines,d5.dirtyPalette={},{}end;function terminal.resize(de,v,da)if v>de.size.width then for s=1,de.size.height do de[s][1]=de[s][1]..(' '):rep(v-de.size.width)de[s][2]=de[s][2]..de.colors.fg:rep(v-de.size.width)de[s][3]=de[s][3]..de.colors.bg:rep(v-de.size.width)de.dirtyLines[s]=true end;if de.isLocked then if de.isGraphics then for s=1,de.size.height*9 do de.graphicsBuffer[s]=de.graphicsBuffer[s]..('\15'):rep((v-de.size.width)*6)end;de.graphicsBuffer.dirtyRects[#de.graphicsBuffer.dirtyRects+1]={x=de.size.width*6+1,y=1,width=(v-de.size.width)*6,height=de.size.height*9}else for s=1,de.size.height do de.textBuffer[s][1]=de.textBuffer[s][1]..(' '):rep(v-de.size.width)de.textBuffer[s][2]=de.textBuffer[s][2]..de.textBuffer.colors.fg:rep(v-de.size.width)de.textBuffer[s][3]=de.textBuffer[s][3]..de.textBuffer.colors.bg:rep(v-de.size.width)de.textBuffer.dirtyLines[s]=true end end end elseif v<de.size.width then for s=1,de.size.height do de[s][1]=de[s][1]:sub(1,v)de[s][2]=de[s][2]:sub(1,v)de[s][3]=de[s][3]:sub(1,v)de.dirtyLines[s]=true end;if de.isLocked then if de.isGraphics then for s=1,de.size.height*9 do de.graphicsBuffer[s]=de.graphicsBuffer[s]:sub(1,v*6)end else for s=1,de.size.height do de.textBuffer[s][1]=de.textBuffer[s][1]:sub(1,v)de.textBuffer[s][2]=de.textBuffer[s][2]:sub(1,v)de.textBuffer[s][3]=de.textBuffer[s][3]:sub(1,v)end end end end;de.size.width=v;if da>de.size.height then for s=de.size.height+1,da do de[s]={(' '):rep(v),de.colors.fg:rep(v),de.colors.bg:rep(v)}de.dirtyLines[s]=true end;if de.isLocked then if de.isGraphics then for s=de.size.height*9+1,da*9 do de.graphicsBuffer[s]=('\15'):rep(v*6)end;de.graphicsBuffer.dirtyRects[#de.graphicsBuffer.dirtyRects+1]={x=1,y=de.size.height*9+1,width=de.size.width*6,height=(da-de.size.height)*9}else for s=de.size.height+1,da do de.textBuffer[s]={(' '):rep(v),de.textBuffer.colors.fg:rep(v),de.textBuffer.colors.bg:rep(v)}de.textBuffer.dirtyLines[s]=true end end end elseif da<de.size.height then for s=da+1,de.size.height do de[s]=nil;de.dirtyLines[s]=nil end;if de.isLocked then if de.isGraphics then for s=da*9+1,de.size.height*9 do de.graphicsBuffer[s]=nil end else for s=da+1,de.size.height do de.textBuffer[s]=nil;de.textBuffer.dirtyLines[s]=nil end end end end;de.size.height=da end;local function df(de)local dg=de.cursor;local s=dg.y+1;dg.y=s;local U=de.size;local da=U.height;if s>da then local dh=de.dirtyLines;for x=1,da-1 do de[x]=de[x+1]dh[x]=true end;local v=U.width;local di=de.colors;de[da]={(' '):rep(v),di.fg:rep(v),di.bg:rep(v)}dh[da]=true;dg.y=da end end;local dj={['@']=function(de,ax)local G=ax[1]or 1;if G==0 then G=1 end;local dk,dl=G%de.size.width,math.floor(G/de.size.width)local t={de[de.cursor.y][1]:sub(de.size.width-dk+1),de[de.cursor.y][2]:sub(de.size.width-dk+1),de[de.cursor.y][3]:sub(de.size.width-dk+1)}de[de.cursor.y][1]=de[de.cursor.y][1]:sub(1,de.cursor.x-1)..(" "):rep(G)..de[de.cursor.y+dl][1]:sub(de.cursor.x,de.size.width-dk)de[de.cursor.y][2]=de[de.cursor.y][2]:sub(1,de.cursor.x-1)..de.colors.fg:rep(G)..de[de.cursor.y+dl][2]:sub(de.cursor.x,de.size.width-dk)de[de.cursor.y][3]=de[de.cursor.y][3]:sub(1,de.cursor.x-1)..de.colors.bg:rep(G)..de[de.cursor.y+dl][3]:sub(de.cursor.x,de.size.width-dk)de.dirtyLines[de.cursor.y]=true;for s=de.cursor.y+dl+1,de.size.height do local dm={de[s-dl][1]:sub(de.size.width-G+1),de[s-dl][2]:sub(de.size.width-G+1),de[s-dl][3]:sub(de.size.width-G+1)}de[s][1]=t[1]..de[s-dl][1]:sub(1,de.size.width-dk)de[s][2]=t[2]..de[s-dl][2]:sub(1,de.size.width-dk)de[s][3]=t[3]..de[s-dl][3]:sub(1,de.size.width-dk)de.dirtyLines[s]=true;t=dm end;for s=de.cursor.y+1,de.cursor.y+dl do de[s][1]=(" "):rep(de.size.width)de[s][2]=de.colors.fg:rep(de.size.width)de[s][3]=de.colors.bg:rep(de.size.width)de.dirtyLines[s]=true end end,A=function(de,ax)local G=ax[1]or 1;if G==0 then G=1 end;de.cursor.y=math.max(de.cursor.y-G,1)end,B=function(de,ax)local G=ax[1]or 1;if G==0 then G=1 end;de.cursor.y=math.min(de.cursor.y+G,de.size.height)end,C=function(de,ax)local G=ax[1]or 1;if G==0 then G=1 end;de.cursor.y=de.cursor.y+math.floor((de.cursor.x-1+G)/de.size.width)de.cursor.x=(de.cursor.x-1+G)%de.size.width+1 end,D=function(de,ax)local G=ax[1]or 1;if G==0 then G=1 end;de.cursor.y=de.cursor.y+math.floor((de.cursor.x-1-G)/de.size.width)de.cursor.x=(de.cursor.x-1-G)%de.size.width+1 end,E=function(de,ax)local G=ax[1]or 1;if G==0 then G=1 end;de.cursor.y=math.min(de.cursor.y+G,de.size.height)de.cursor.x=1 end,F=function(de,ax)local G=ax[1]or 1;if G==0 then G=1 end;de.cursor.y=math.max(de.cursor.y-G,1)de.cursor.x=1 end,G=function(de,ax)local G=ax[1]or 1;if G==0 then G=1 end;de.cursor.x=math.min(G,de.size.width)end,H=function(de,ax)local bu,ab=ax[1]or 1,ax[2]or 1;if bu==0 then bu=1 end;if ab==0 then ab=1 end;de.cursor.x,de.cursor.y=math.min(ab,de.size.width),math.min(bu,de.size.height)end,I=function(de,ax)end,J=function(de,ax)local t=ax[1]or 0;if t==0 then de[de.cursor.y][1]=de[de.cursor.y][1]:sub(1,de.cursor.x-1)..(" "):rep(de.size.width-de.cursor.x)de[de.cursor.y][2]=de[de.cursor.y][2]:sub(1,de.cursor.x-1)..de.colors.fg:rep(de.size.width-de.cursor.x)de[de.cursor.y][3]=de[de.cursor.y][3]:sub(1,de.cursor.x-1)..de.colors.bg:rep(de.size.width-de.cursor.x)de.dirtyLines[de.cursor.y]=true;for s=de.cursor.y+1,de.size.height do de[s][1]=(" "):rep(de.size.width)de[s][2]=de.colors.fg:rep(de.size.width)de[s][3]=de.colors.bg:rep(de.size.width)de.dirtyLines[s]=true end elseif t==1 then de[de.cursor.y][1]=(" "):rep(de.cursor.x)..de[de.cursor.y][1]:sub(de.cursor.x)de[de.cursor.y][2]=de.colors.fg:rep(de.cursor.x)..de[de.cursor.y][2]:sub(de.cursor.x)de[de.cursor.y][3]=de.colors.bg:rep(de.cursor.x)..de[de.cursor.y][3]:sub(de.cursor.x)de.dirtyLines[de.cursor.y]=true;for s=de.cursor.y-1,1,-1 do de[s][1]=(" "):rep(de.size.width)de[s][2]=de.colors.fg:rep(de.size.width)de[s][3]=de.colors.bg:rep(de.size.width)de.dirtyLines[s]=true end elseif t==2 then for s=1,de.size.height do de[s][1]=(" "):rep(de.size.width)de[s][2]=de.colors.fg:rep(de.size.width)de[s][3]=de.colors.bg:rep(de.size.width)de.dirtyLines[s]=true end end end,K=function(de,ax)local t=ax[1]or 0;if t==0 then de[de.cursor.y][1]=de[de.cursor.y][1]:sub(1,de.cursor.x-1)..(" "):rep(de.size.width-de.cursor.x)de[de.cursor.y][2]=de[de.cursor.y][2]:sub(1,de.cursor.x-1)..de.colors.fg:rep(de.size.width-de.cursor.x)de[de.cursor.y][3]=de[de.cursor.y][3]:sub(1,de.cursor.x-1)..de.colors.bg:rep(de.size.width-de.cursor.x)de.dirtyLines[de.cursor.y]=true elseif t==1 then de[de.cursor.y][1]=(" "):rep(de.cursor.x)..de[de.cursor.y][1]:sub(de.cursor.x)de[de.cursor.y][2]=de.colors.fg:rep(de.cursor.x)..de[de.cursor.y][2]:sub(de.cursor.x)de[de.cursor.y][3]=de.colors.bg:rep(de.cursor.x)..de[de.cursor.y][3]:sub(de.cursor.x)de.dirtyLines[de.cursor.y]=true elseif t==2 then de[de.cursor.y][1]=(" "):rep(de.size.width)de[de.cursor.y][2]=de.colors.fg:rep(de.size.width)de[de.cursor.y][3]=de.colors.bg:rep(de.size.width)de.dirtyLines[de.cursor.y]=true end end,L=function(de,ax)end,M=function(de,ax)end,N=function(de,ax)end,O=function(de,ax)end,P=function(de,ax)local G=ax[1]or 1;if G==0 then G=1 end;local dk,dl=G%de.size.width,math.floor(G/de.size.width)local t={(" "):rep(dk),de.colors.fg:rep(dk),de.colors.bg:rep(dk)}for s=de.size.height-dl,de.cursor.y+1,-1 do local dm={de[s+dl][1]:sub(1,dk),de[s+dl][2]:sub(1,dk),de[s+dl][3]:sub(1,dk)}de[s][1]=de[s+dl][1]:sub(dk+1)..t[1]de[s][2]=de[s+dl][2]:sub(dk+1)..t[2]de[s][3]=de[s+dl][3]:sub(dk+1)..t[3]de.dirtyLines[s]=true;t=dm end;for s=de.size.height-dl+1,de.size.height do de[s][1]=(" "):rep(de.size.width)de[s][2]=de.colors.fg:rep(de.size.width)de[s][3]=de.colors.bg:rep(de.size.width)de.dirtyLines[s]=true end;de[de.cursor.y][1]=de[de.cursor.y][1]:sub(1,de.cursor.x-1)..de[de.cursor.y+dl][1]:sub(de.cursor.x+dk,de.size.width)..t[1]de[de.cursor.y][2]=de[de.cursor.y][2]:sub(1,de.cursor.x-1)..de[de.cursor.y+dl][2]:sub(de.cursor.x+dk,de.size.width)..t[2]de[de.cursor.y][3]=de[de.cursor.y][3]:sub(1,de.cursor.x-1)..de[de.cursor.y+dl][3]:sub(de.cursor.x+dk,de.size.width)..t[3]de.dirtyLines[de.cursor.y]=true end,Q=function(de,ax)end,R=function(de,ax)end,S=function(de,ax)local t=ax[1]or 0;if t==0 then t=1 end;for B=1,t do table.insert(de,1,{(' '):rep(de.size.width),de.colors.fg:rep(de.size.width),de.colors.bg:rep(de.size.width)})de[de.size.height+1]=nil end;for s=1,de.size.height do de.dirtyLines[s]=true end end,T=function(de,ax)local t=ax[1]or 0;if t==0 then t=1 end;for B=1,t do table.remove(de,1)de[de.size.height]={(' '):rep(de.size.width),de.colors.fg:rep(de.size.width),de.colors.bg:rep(de.size.width)}end;for s=1,de.size.height do de.dirtyLines[s]=true end end,U=function(de,ax)end,V=function(de,ax)end,W=function(de,ax)end,X=function(de,ax)end,Y=function(de,ax)end,Z=function(de,ax)end,['[']=function(de,ax)end,['\\']=function(de,ax)end,[']']=function(de,ax)end,['^']=function(de,ax)end,['_']=function(de,ax)end,['`']=function(de,ax)end,a=function(de,ax)end,b=function(de,ax)end,c=function(de,ax)end,d=function(de,ax)end,e=function(de,ax)end,f=function(de,ax)end,g=function(de,ax)end,h=function(de,ax)if ax[1]==25 then de.cursorBlink=true end end,i=function(de,ax)end,j=function(de,ax)end,k=function(de,ax)end,l=function(de,ax)if ax[1]==25 then de.cursorBlink=false end end,m=function(de,ax)local t,C=ax[1]or 0,ax[2]if t==0 then de.colors.fg,de.colors.bg,de.colors.bold='0','f',false elseif t==1 then de.colors.bold=true elseif t==7 or t==27 then de.colors.fg,de.colors.bg=de.colors.bg,de.colors.fg elseif t==22 then de.colors.bold=false elseif t>=30 and t<=37 then de.colors.fg=("%x"):format(15-(t-30)-(de.colors.bold and 8 or 0))elseif t==39 then de.colors.fg='0'elseif t>=40 and t<=47 then de.colors.bg=("%x"):format(15-(t-40)-(de.colors.bold and 8 or 0))elseif t==49 then de.colors.bg='f'elseif t>=90 and t<=97 then de.colors.fg=("%x"):format(15-(t-90)-8)elseif t>=100 and t<=107 then de.colors.bg=("%x"):format(15-(t-100)-8)end;if C~=nil then if C==0 then de.colors.fg,de.colors.bg='0','f'elseif C==1 then de.colors.bold=true elseif C==7 or C==27 then de.colors.fg,de.colors.bg=de.colors.bg,de.colors.fg elseif C==22 then de.colors.bold=false elseif C>=30 and C<=37 then de.colors.fg=("%x"):format(15-(C-30)-(de.colors.bold and 8 or 0))elseif C==39 then de.colors.fg='0'elseif C>=40 and C<=47 then de.colors.bg=("%x"):format(15-(C-40)-(de.colors.bold and 8 or 0))elseif C==49 then de.colors.bg='f'elseif C>=90 and C<=97 then de.colors.fg=("%x"):format(15-(C-90)-8)elseif C>=100 and C<=107 then de.colors.bg=("%x"):format(15-(C-100)-8)end end end,n=function(de,ax)end,o=function(de,ax)end}for x=0x70,0x7F do dj[string.char(x)]=function(de,ax)end end;function terminal.write(de,dn)local az,U=1,0;local function dp(r)if U==0 then az,U=r,0;return end;while de.cursor.x+U>de.size.width do de[de.cursor.y][1]=de[de.cursor.y][1]:sub(1,de.cursor.x-1)..dn:sub(az,az+de.size.width-de.cursor.x)de[de.cursor.y][2]=de[de.cursor.y][2]:sub(1,de.cursor.x-1)..de.colors.fg:rep(de.size.width-de.cursor.x+1)de[de.cursor.y][3]=de[de.cursor.y][3]:sub(1,de.cursor.x-1)..de.colors.bg:rep(de.size.width-de.cursor.x+1)de.dirtyLines[de.cursor.y]=true;az=az+de.size.width-de.cursor.x+1;U=U-(de.size.width-de.cursor.x+1)de.cursor.x=1;df(de)end;de[de.cursor.y][1]=de[de.cursor.y][1]:sub(1,de.cursor.x-1)..dn:sub(az,az+U-1)..de[de.cursor.y][1]:sub(de.cursor.x+U)de[de.cursor.y][2]=de[de.cursor.y][2]:sub(1,de.cursor.x-1)..de.colors.fg:rep(U)..de[de.cursor.y][2]:sub(de.cursor.x+U)de[de.cursor.y][3]=de[de.cursor.y][3]:sub(1,de.cursor.x-1)..de.colors.bg:rep(U)..de[de.cursor.y][3]:sub(de.cursor.x+U)de.dirtyLines[de.cursor.y]=true;de.cursor.x=de.cursor.x+U;az,U=r,0 end;local dq=0;local ax,dr;for r,ab,t in dn:gmatch"()(.)()"do if dq==0 then if ab=='\a'then dp(t)elseif ab=='\b'then dp(t)if de.cursor.x==1 then if de.cursor.y>1 then de.cursor.x,de.cursor.y=de.size.width,de.cursor.y-1 end else de.cursor.x=de.cursor.x-1 end elseif ab=='\t'then dp(t)de.cursor.x=math.floor((de.cursor.x-1)/8)*8+9;if de.cursor.x>de.size.width then de.cursor.x=1;df(de)end elseif ab=='\n'then dp(t)df(de)if de.flags.nlcr then de.cursor.x=1 end elseif ab=='\f'then dp(t)df(de)elseif ab=='\r'then dp(t)de.cursor.x=1 elseif ab=='\27'then dq=1 else U=U+1 end elseif dq==1 then if false then elseif ab=='['then dq=2;ax,dr={},0 elseif ab==']'then if dn:byte(t)==0x50 then dq=4;ax={}else dq=3;ax,dr={},0 end else dp(t)dq=0 end elseif dq==2 then if ab>='@'and ab<='\127'then dp(t)ax[#ax+1]=dr;dj[ab](de,ax)dq=0 elseif ab>='0'and ab<='?'then if ab<='9'then dr=dr*10+tonumber(ab)elseif ab==';'then ax[#ax+1],dr=dr,0 end else dp(t)dq=0 end elseif dq==3 then if ab=='\\'and dn:byte(r-1)=='\27'then dp(t)dq=0 end elseif dq==4 then if#ax==0 then ax[1]=tonumber(ab,16)or 0 elseif#ax==1 and not dr then dr=(tonumber(ab,16)or 0)*16 elseif#ax==1 then ax[2],dr=dr+(tonumber(ab,16)or 0),nil elseif#ax==2 and not dr then dr=(tonumber(ab,16)or 0)*16 elseif#ax==2 then ax[3],dr=dr+(tonumber(ab,16)or 0),nil elseif#ax==3 and not dr then dr=(tonumber(ab,16)or 0)*16 elseif#ax==3 then dp(t)ax[4],dr=dr+(tonumber(ab,16)or 0),nil;de.palette[ax[1]]={ax[2]/255,ax[3]/255,ax[4]/255}de.dirtyPalette[ax[1]]=true;dq=0 end end end;dp()end;function syscalls.write(process,as,...)if not process.stdout then return end;local function ds(A)if process.stdout.isTTY then terminal.write(process.stdout,A)else process.stdout.write(A)end end;local args=table.pack(...)for x=1,args.n do if x>1 then ds("\t")end;ds(tostring(args[x]))end;if process.stdout.isTTY then terminal.redraw(process.stdout)end end;function syscalls.writeerr(process,as,...)if not process.stderr then return end;local function ds(A)if process.stderr.isTTY then terminal.write(process.stderr,A)else process.stderr.write(A)end end;local args=table.pack(...)for x=1,args.n do if x>1 then ds("\t")end;ds(tostring(args[x]))end;if process.stderr.isTTY then terminal.redraw(process.stderr)end end;function syscalls.read(process,as,t)expect(1,t,"number")if process.stdin then if process.stdin.eof then process.stdin.eof=false;return nil end;while#process.stdin.buffer<t do if process.stdin.eof then process.stdin.eof=false;return nil end;if process.stdin.isTTY and not process.stdin.flags.delay then return nil end;if process.stdin.read then local bt=process.stdin.read(t-#process.stdin.buffer)if not bt then return nil end;process.stdin.buffer=process.stdin.buffer..bt else return kSyscallYield,"read",t end end;local bt=process.stdin.buffer:sub(1,t-1)process.stdin.buffer=process.stdin.buffer:sub(t)return bt else return nil end end;function syscalls.readline(process,as)if process.stdin then if process.stdin.eof then process.stdin.eof=false;return nil end;while not process.stdin.buffer:find("\n")do if process.stdin.eof then process.stdin.eof=false;return nil end;if process.stdin.isTTY and not process.stdin.flags.delay then return nil end;if process.stdin.read then local bt=process.stdin.read()if not bt then return nil end;process.stdin.buffer=process.stdin.buffer..bt else return kSyscallYield,"readline"end end;local t=process.stdin.buffer:find("\n")local bt=process.stdin.buffer:sub(1,t-1)process.stdin.buffer=process.stdin.buffer:sub(t+1)return bt else return nil end end;function syscalls.termctl(process,as,dt)expect(1,dt,"table","nil")if not process.stdout or not process.stdout.isTTY then return nil end;if dt then expect.field(dt,"cbreak","boolean","nil")expect.field(dt,"delay","boolean","nil")expect.field(dt,"echo","boolean","nil")expect.field(dt,"keypad","boolean","nil")expect.field(dt,"nlcr","boolean","nil")expect.field(dt,"raw","boolean","nil")for j,k in pairs(dt)do if process.stdout.flags[j]~=nil then process.stdout.flags[j]=k end end end;local A=deepcopy(process.stdout.flags)A.hasgfx=term.getGraphicsMode~=nil;return A end;function terminal.openterm(de,process)if de.isLocked then if not de.isGraphics and de.frontmostProcess==process then return de.screenHandle end;return nil,"Terminal already in use"end;local U=de.size;local d5={cursor={x=1,y=1},cursorBlink=false,colors={fg='0',bg='f'},palette={},dirtyLines={},dirtyPalette={}}de.textBuffer=d5;de.isLocked=true;de.isGraphics=false;for s=1,U.height do d5[s]={(' '):rep(U.width),('0'):rep(U.width),('f'):rep(U.width)}d5.dirtyLines[s]=true end;for x=0,15 do d5.palette[x]={term.nativePaletteColor(2^x)}d5.dirtyPalette[x]=true end;de.processList[#de.processList+1]=de.frontmostProcess;de.frontmostProcess=process;local du=setmetatable({},{__name="Terminal"})local dv=terminal.redraw;local expect=expect;de.screenHandle=du;function du.close()if not du then error("terminal is already closed",2)end;du=nil;de.isLocked=false;de.frontmostProcess=table.remove(de.processList)de.screenHandle=nil;dv(de,true)end;function du.write(dn)if not du then error("terminal is already closed",2)end;dn=tostring(dn)expect(1,dn,"string")if d5.cursor.y<1 or d5.cursor.y>U.height then return elseif d5.cursor.x>U.width or d5.cursor.x+#dn<1 then d5.cursor.x=d5.cursor.x+#dn;return elseif d5.cursor.x<1 then dn=dn:sub(-d5.cursor.x+2)d5.cursor.x=1 end;local dw=#dn;if d5.cursor.x+#dn>U.width then dn=dn:sub(1,U.width-d5.cursor.x+1)end;d5[d5.cursor.y][1]=d5[d5.cursor.y][1]:sub(1,d5.cursor.x-1)..dn..d5[d5.cursor.y][1]:sub(d5.cursor.x+#dn)d5[d5.cursor.y][2]=d5[d5.cursor.y][2]:sub(1,d5.cursor.x-1)..d5.colors.fg:rep(#dn)..d5[d5.cursor.y][2]:sub(d5.cursor.x+#dn)d5[d5.cursor.y][3]=d5[d5.cursor.y][3]:sub(1,d5.cursor.x-1)..d5.colors.bg:rep(#dn)..d5[d5.cursor.y][3]:sub(d5.cursor.x+#dn)d5.cursor.x=d5.cursor.x+dw;d5.dirtyLines[d5.cursor.y]=true end;function du.blit(dn,dx,dy)if not du then error("terminal is already closed",2)end;dn=tostring(dn)expect(1,dn,"string")expect(2,dx,"string")expect(3,dy,"string")if#dn~=#dx or#dx~=#dy then error("Arguments must be the same length",2)end;if d5.cursor.y<1 or d5.cursor.y>U.height then return elseif d5.cursor.x>U.width or d5.cursor.x<1-#dn then d5.cursor.x=d5.cursor.x+#dn;dv(de)return elseif d5.cursor.x<1 then dn,dx,dy=dn:sub(-d5.cursor.x+2),dx:sub(-d5.cursor.x+2),dy:sub(-d5.cursor.x+2)d5.cursor.x=1 end;local dw=#dn;if d5.cursor.x+#dn>U.width then dn,dx,dy=dn:sub(1,U.width-d5.cursor.x+1),dx:sub(1,U.width-d5.cursor.x+1),dy:sub(1,U.width-d5.cursor.x+1)end;d5[d5.cursor.y][1]=d5[d5.cursor.y][1]:sub(1,d5.cursor.x-1)..dn..d5[d5.cursor.y][1]:sub(d5.cursor.x+#dn)d5[d5.cursor.y][2]=d5[d5.cursor.y][2]:sub(1,d5.cursor.x-1)..dx..d5[d5.cursor.y][2]:sub(d5.cursor.x+#dx)d5[d5.cursor.y][3]=d5[d5.cursor.y][3]:sub(1,d5.cursor.x-1)..dy..d5[d5.cursor.y][3]:sub(d5.cursor.x+#dy)d5.cursor.x=d5.cursor.x+dw;d5.dirtyLines[d5.cursor.y]=true end;function du.clear()if not du then error("terminal is already closed",2)end;for s=1,U.height do d5[s]={(' '):rep(U.width),d5.colors.fg:rep(U.width),d5.colors.bg:rep(U.width)}d5.dirtyLines[s]=true end end;function du.clearLine()if not du then error("terminal is already closed",2)end;if d5.cursor.y>=1 and d5.cursor.y<=U.height then d5[d5.cursor.y]={(' '):rep(U.width),d5.colors.fg:rep(U.width),d5.colors.bg:rep(U.width)}d5.dirtyLines[d5.cursor.y]=true end end;function du.getCursorPos()if not du then error("terminal is already closed",2)end;return d5.cursor.x,d5.cursor.y end;function du.setCursorPos(dz,dA)if not du then error("terminal is already closed",2)end;expect(1,dz,"number")expect(2,dA,"number")if dz==d5.cursor.x and dA==d5.cursor.y then return end;d5.cursor.x,d5.cursor.y=math.floor(dz),math.floor(dA)end;function du.getCursorBlink()if not du then error("terminal is already closed",2)end;return d5.cursorBlink end;function du.setCursorBlink(ad)if not du then error("terminal is already closed",2)end;expect(1,ad,"boolean")d5.cursorBlink=ad end;function du.isColor()if not du then error("terminal is already closed",2)end;return true end;function du.getSize()if not du then error("terminal is already closed",2)end;return U.width,U.height end;function du.scroll(dB)if not du then error("terminal is already closed",2)end;expect(1,dB,"number")if math.abs(dB)>=U.width then for s=1,U.height do d5[s]={(' '):rep(U.width),d5.colors.fg:rep(U.width),d5.colors.bg:rep(U.width)}end elseif dB>0 then for x=dB+1,U.height do d5[x-dB]=d5[x]end;for x=U.height-dB+1,U.height do d5[x]={(' '):rep(U.width),d5.colors.fg:rep(U.width),d5.colors.bg:rep(U.width)}end elseif dB<0 then for x=1,U.height+dB do d5[x-dB]=d5[x]end;for x=1,-dB do d5[x]={(' '):rep(U.width),d5.colors.fg:rep(U.width),d5.colors.bg:rep(U.width)}end else return end;for x=1,U.height do d5.dirtyLines[x]=true end end;function du.getTextColor()if not du then error("terminal is already closed",2)end;return tonumber(d5.colors.fg,16)end;function du.setTextColor(dC)if not du then error("terminal is already closed",2)end;expect(1,dC,"number")expect.range(dC,0,15)d5.colors.fg=("%x"):format(dC)end;function du.getBackgroundColor()if not du then error("terminal is already closed",2)end;return tonumber(d5.colors.bg,16)end;function du.setBackgroundColor(dC)if not du then error("terminal is already closed",2)end;expect(1,dC,"number")expect.range(dC,0,15)d5.colors.bg=("%x"):format(dC)end;function du.getPaletteColor(dC)if not du then error("terminal is already closed",2)end;expect(1,dC,"number")expect.range(dC,0,15)return table.unpack(d5.palette[math.floor(dC)])end;function du.setPaletteColor(dC,bu,dD,ad)if not du then error("terminal is already closed",2)end;expect(1,dC,"number")expect(2,bu,"number")if dD==nil and ad==nil then bu,dD,ad=bit32.band(bit32.rshift(bu,16),0xFF)/255,bit32.band(bit32.rshift(bu,8),0xFF)/255,bit32.band(bu,0xFF)/255 end;expect(3,dD,"number")expect(4,ad,"number")expect.range(dC,0,15)if bu<0 or bu>1 then error("bad argument #2 (value out of range)",2)end;if dD<0 or dD>1 then error("bad argument #3 (value out of range)",2)end;if ad<0 or ad>1 then error("bad argument #4 (value out of range)",2)end;d5.palette[math.floor(dC)]={bu,dD,ad}d5.dirtyPalette[math.floor(dC)]=true end;function du.getLine(s)if not du then error("terminal is already closed",2)end;expect(1,s,"number")local P=d5[s]if P then return table.unpack(P,1,3)end end;local dE=term.nativePaletteColor;function du.nativePaletteColor(dC)expect(1,dC,"number")expect.range(dC,0,15)return dE(2^dC)end;for B,k in pairs(du)do setfenv(k,process.env)debug.protect(k)end;du.isColour=du.isColor;du.getTextColour=du.getTextColor;du.setTextColour=du.setTextColor;du.getBackgroundColour=du.getBackgroundColor;du.setBackgroundColour=du.setBackgroundColor;du.getPaletteColour=du.getPaletteColor;du.setPaletteColour=du.setPaletteColor;du.nativePaletteColour=du.nativePaletteColor;process.dependents[#process.dependents+1]={gc=function()if du then return du.close()end end}dv(de,true)return du end;function syscalls.openterm(process,as)if not process.stdout or not process.stdout.isTTY then return nil,"No valid TTY attached"end;if process~=process.stdout.frontmostProcess then syscalls.kill(KERNEL,nil,process.id,22)if process.paused then return kSyscallYield,"openterm"end end;return terminal.openterm(process.stdout,process)end;function terminal.opengfx(de,process)if not term.drawPixels then return nil,"Graphics mode not supported"end;if de.isLocked then if de.isGraphics and de.frontmostProcess==process then return de.screenHandle end;return nil,"Terminal already in use"end;local U=de.size;local d5={palette={},dirtyRects={},dirtyPalette={},frozen=false}de.graphicsBuffer=d5;de.isLocked=true;de.isGraphics=true;for s=1,U.height*9 do d5[s]=('\15'):rep(U.width*6)end;for x=0,15 do d5.palette[x]={term.nativePaletteColor(2^x)}d5.dirtyPalette[x]=true end;for x=16,255 do d5.palette[x]={0,0,0}d5.dirtyPalette[x]=true end;de.processList[#de.processList+1]=de.frontmostProcess;de.frontmostProcess=process;local du=setmetatable({},{__name="GFXTerminal"})local dv=terminal.redraw;local expect=expect;de.screenHandle=du;function du.close()if not du then error("terminal is already closed",2)end;du=nil;de.isLocked=false;de.frontmostProcess=table.remove(de.processList)de.screenHandle=nil;dv(de,true)end;function du.getSize()return U.width*6,U.height*9 end;function du.clear()if not du then error("terminal is already closed",2)end;for s=1,U.height*9 do d5[s]=('\15'):rep(U.width*6)end;dv(de,true)end;function du.getPixel(r,s)if not du then error("terminal is already closed",2)end;expect(1,r,"number")expect(2,s,"number")expect.range(r,0,U.width*6-1)expect.range(s,0,U.height*9-1)r,s=math.floor(r),math.floor(s)return d5[s+1]:byte(r+1)end;function du.setPixel(r,s,dC)if not du then error("terminal is already closed",2)end;expect(1,r,"number")expect(2,s,"number")expect(3,dC,"number")expect.range(r,0,U.width*6-1)expect.range(s,0,U.height*9-1)expect.range(dC,0,255)r,s=math.floor(r),math.floor(s)d5[s+1]=d5[s+1]:sub(1,r)..string.char(dC)..d5[s+1]:sub(r+2)d5.dirtyRects[#d5.dirtyRects+1]={x=r,y=s,color=dC}end;function du.getPixels(r,s,v,da,dF)if not du then error("terminal is already closed",2)end;expect(1,r,"number")expect(2,s,"number")expect(3,v,"number")expect(4,da,"number")expect(5,dF,"boolean","nil")expect.range(v,0)expect.range(da,0)r,s=math.floor(r),math.floor(s)local A={}for dG=1,da do if dF then A[dG]=d5[s+dG]:sub(r+1,r+v)else A[dG]={d5[s+dG]:sub(r+1,r+v):byte(1,-1)}end end;return A end;function du.drawPixels(r,s,bk,v,da)if not du then error("terminal is already closed",2)end;expect(1,r,"number")expect(2,s,"number")expect(3,bk,"table","number")local dH=type(bk)=="number"expect(4,v,"number",not dH and"nil"or nil)expect(5,da,"number",not dH and"nil"or nil)expect.range(r,0,U.width*6-1)expect.range(s,0,U.height*9-1)if v then expect.range(v,0)end;if da then expect.range(da,0)end;if dH then expect.range(bk,0,255)end;if v==0 or da==0 then return end;r,s=math.floor(r),math.floor(s)if v and r+v>=U.width*6 then v=U.width*6-r end;da=da or#bk;local dI={x=r,y=s,width=v,height=da}for dG=1,da do if s+dG>U.height*9 then break end;if dH then local bt=string.char(bk):rep(v)d5[s+dG]=d5[s+dG]:sub(1,r)..bt..d5[s+dG]:sub(r+v+1)dI[dG]=bt elseif bk[dG]~=nil then if type(bk[dG])~="table"and type(bk[dG])~="string"then error("bad argument #3 to 'drawPixels' (invalid row "..dG..")",2)end;local v=v or#bk[dG]if r+v>=U.width*6 then v=U.width*6-r end;local bt;if type(bk[dG])=="string"then bt=bk[dG]if#bt<v then bt=bt..('\15'):rep(v-#bt)elseif#bt>v then bt=bt:sub(1,v)end else bt=""for dJ=1,v do bt=bt..string.char(bk[dG][dJ]or d5[s+dG]:byte(r+dJ))end end;d5[s+dG]=d5[s+dG]:sub(1,r)..bt..d5[s+dG]:sub(r+v+1)dI[dG]=bt end end;d5.dirtyRects[#d5.dirtyRects+1]=dI end;function du.getFrozen()if not du then error("terminal is already closed",2)end;return d5.frozen end;function du.setFrozen(f)if not du then error("terminal is already closed",2)end;expect(1,f,"boolean")d5.frozen=f end;function du.getPaletteColor(dC)if not du then error("terminal is already closed",2)end;expect(1,dC,"number")expect.range(dC,0,255)return table.unpack(d5.palette[dC])end;function du.setPaletteColor(dC,bu,dD,ad)if not du then error("terminal is already closed",2)end;expect(1,dC,"number")expect(2,bu,"number")if dD==nil and ad==nil then bu,dD,ad=bit32.band(bit32.rshift(bu,16),0xFF)/255,bit32.band(bit32.rshift(bu,8),0xFF)/255,bit32.band(bu,0xFF)/255 end;expect(3,dD,"number")expect(4,ad,"number")expect.range(bu,0,1)expect.range(dD,0,1)expect.range(ad,0,1)expect.range(dC,0,255)d5.palette[dC]={bu,dD,ad}d5.dirtyPalette[dC]=true end;local dE=term.nativePaletteColor;function du.nativePaletteColor(dC)expect(1,dC,"number")expect.range(dC,0,15)return dE(2^dC)end;for B,k in pairs(du)do setfenv(k,process.env)debug.protect(k)end;du.getPaletteColour=du.getPaletteColor;du.setPaletteColour=du.setPaletteColor;du.nativePaletteColour=du.nativePaletteColor;process.dependents[#process.dependents+1]={gc=function()if du then return du.close()end end}dv(de,true)return du end;function syscalls.opengfx(process,as)if not process.stdout or not process.stdout.isTTY then return nil,"No valid TTY attached"end;if process~=process.stdout.frontmostProcess then syscalls.kill(KERNEL,nil,process.id,22)if process.paused then return kSyscallYield,"openterm"end end;return terminal.opengfx(process.stdout,process)end;function syscalls.mktty(process,as,v,da)expect(1,v,"number")expect(2,da,"number")expect.range(v,1)expect.range(da,1)local de=terminal.makeTTY(term,v,da)de.id=math.random(0,0x7FFFFFFF)de.process=process;local aD={__index=de,__metatable={__name="TTY"}}local a7=setmetatable({},aD)local do_syscall=do_syscall;function a7.sendEvent(cc,d2)return do_syscall("__ttyevent",a7,cc,d2)end;function a7.write(dn)de.buffer=de.buffer..tostring(dn)return do_syscall("__ttyevent",a7,"paste",tostring(dn))end;debug.protect(a7.sendEvent)debug.protect(a7.write)aD.__newindex=function()error("cannot modify TTY",2)end;terminal.userTTYs[a7]=de;process.dependents[#process.dependents+1]={gc=function()terminal.userTTYs[a7]=nil end}return a7 end;function syscalls.__ttyevent(process,as,dK,cc,d2)expect(1,dK,"table")expect(2,cc,"string")expect(3,d2,"table")local de=terminal.userTTYs[dK]if not de then error("Invalid TTY")end;if de.process~=process then error("Invalid TTY")end;if not de.frontmostProcess then return end;if cc=="key"then expect.field(d2,"keycode","number")expect.field(d2,"isRepeat","boolean")de.frontmostProcess.eventQueue[#de.frontmostProcess.eventQueue+1]={"key",{keycode=d2.keycode,isRepeat=d2.isRepeat,ctrlHeld=keysHeld.ctrl,altHeld=keysHeld.alt,shiftHeld=keysHeld.shift}}if not de.isLocked then if d2.keycode==10 then if de.flags.cbreak then de.buffer=de.buffer.."\n"else de.buffer=de.buffer..de.preBuffer.."\n"de.preBuffer=""end;if de.flags.echo then terminal.write(de,"\n")terminal.redraw(de)end elseif d2.keycode==8 then if de.flags.cbreak then elseif#de.preBuffer>0 then de.preBuffer=de.preBuffer:sub(1,-2)if de.flags.echo then terminal.write(de,"\b \b")terminal.redraw(de)end end end end elseif cc=="key_up"then expect.field(d2,"keycode","number")de.frontmostProcess.eventQueue[#de.frontmostProcess.eventQueue+1]={"key_up",{keycode=d2.keycode,ctrlHeld=keysHeld.ctrl,altHeld=keysHeld.alt,shiftHeld=keysHeld.shift}}elseif cc=="char"then expect.field(d2,"character","string")de.frontmostProcess.eventQueue[#de.frontmostProcess.eventQueue+1]={"char",{character=d2.character}}if not de.isLocked then if de.flags.cbreak then de.buffer=de.buffer..d2.character else de.preBuffer=de.preBuffer..d2.character end;if de.flags.echo then terminal.write(de,d2.character)terminal.redraw(de)end end elseif cc=="paste"then expect.field(d2,"text","string")de.frontmostProcess.eventQueue[#de.frontmostProcess.eventQueue+1]={"paste",{text=d2.text}}if not de.isLocked then if de.flags.cbreak then de.buffer=de.buffer..d2.text else de.preBuffer=de.preBuffer..d2.text end;if de.flags.echo then terminal.write(de,d2.text)terminal.redraw(de)end end elseif cc=="mouse_click"or cc=="mouse_up"or cc=="mouse_drag"then expect.field(d2,"x","number")expect.field(d2,"y","number")expect.field(d2,"button","number")de.frontmostProcess.eventQueue[#de.frontmostProcess.eventQueue+1]={cc,{x=d2.x,y=d2.y,button=d2.button,buttonMask=0}}elseif cc=="mouse_scroll"then expect.field(d2,"x","number")expect.field(d2,"y","number")expect.field(d2,"direction","number")de.frontmostProcess.eventQueue[#de.frontmostProcess.eventQueue+1]={cc,{x=d2.x,y=d2.y,button=d2.direction}}else error("Invalid event")end end;function syscalls.stdin(process,as,bo)expect(1,bo,"number","table","string","nil")if process.stdin and process.stdin.isTTY and process.stdin.frontmostProcess==process then process.stdin.preBuffer=""end;if type(bo)=="number"then bo=TTY[bo]if bo and process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process;if discord and process.stdin==currentTTY then discord("Phoenix","Executing "..process.name)end end;process.stdin=bo elseif type(bo)=="string"then local dL=hardware.get(bo)if not dL then error("bad argument #1 (no such device)",2)end;if not dL.internalState.tty then error("bad argument #1 (no TTY available on device)",2)end;bo=dL.internalState.tty;if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process end;process.stdin=bo elseif bo==nil then if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)end;process.stdin=nil else if bo.isTTY then bo=terminal.userTTYs[bo]if not bo then error("bad argument #1 (invalid TTY)",2)end;if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process;bo.preBuffer=""end else expect.field(bo,"read","function")local bn=bo.read;bo={buffer="",read=function(...)local bh,w=userModeCallback(process,bn,...)if bh then return w else error(w,2)end end}end;process.stdin=bo end end;function syscalls.stdout(process,as,bo)expect(1,bo,"number","table","string","nil")if process.stdout and process.stdout.isTTY and process.stdout.frontmostProcess==process then if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.stdout.frontmostProcess.name)end end;if type(bo)=="number"then bo=TTY[bo]if bo and process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process;if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.name)end end;process.stdout=bo elseif type(bo)=="string"then local dL=hardware.get(bo)if not dL then error("bad argument #1 (no such device)",2)end;if not dL.internalState.tty then error("bad argument #1 (no TTY available on device)",2)end;bo=dL.internalState.tty;if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process;if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.name)end end;process.stdout=bo elseif bo==nil then if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.name)end end;process.stdout=nil else if bo.isTTY then bo=terminal.userTTYs[bo]if not bo then error("bad argument #1 (invalid TTY)",2)end;if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process;if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.name)end end else expect.field(bo,"write","function")local ds=bo.write;bo={write=function(...)local bh,w=userModeCallback(process,ds,...)if bh then return w else error(w,2)end end}end;process.stdout=bo end end;function syscalls.stderr(process,as,bo)expect(1,bo,"number","table","string","nil")if process.stderr and process.stderr.isTTY and process.stderr.frontmostProcess==process then end;if type(bo)=="number"then bo=TTY[bo]if bo and process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process;if discord and process.stderr==currentTTY then discord("Phoenix","Executing "..process.name)end end;process.stderr=bo elseif type(bo)=="string"then local dL=hardware.get(bo)if not dL then error("bad argument #1 (no such device)",2)end;if not dL.internalState.tty then error("bad argument #1 (no TTY available on device)",2)end;bo=dL.internalState.tty;if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process end;process.stderr=bo elseif bo==nil then if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)end;process.stderr=nil else if bo.isTTY then bo=terminal.userTTYs[bo]if not bo then error("bad argument #1 (invalid TTY)",2)end;if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)bo.processList[#bo.processList+1]=bo.frontmostProcess;bo.frontmostProcess=process end else expect.field(bo,"write","function")local ds=bo.write;bo={write=function(...)local bh,w=userModeCallback(process,ds,...)if bh then return w else error(w,2)end end}end;process.stderr=bo end end;function syscalls.istty(process,as)return process.stdin and process.stdin.isTTY,process.stdout and process.stdout.isTTY end;function syscalls.termsize(process,as)if not process.stdout or not process.stdout.isTTY then return nil,nil end;return process.stdout.size.width,process.stdout.size.height end;syslogs={default={stream={},tty=KERNEL.stdout,tty_level=args.loglevel,colorize=true}}local dM={[0]="Debug","Info","Notice","Warning","Error","Critical","Panic"}local dN={}for x=0,#dM do dN[dM[x]:lower()]=x end;local dO={[0]='\27[90m','\27[97m','\27[36m','\27[93m','\27[31m','\27[95m','\27[96m'}local function dP(A,ao,x,ac)if x>=ac then return tostring(A[x])else return tostring(A[x])..ao..dP(A,ao,x+1,ac)end end;function syscalls.syslog(process,as,bJ,...)local args=table.pack(...)if type(bJ)=="table"then expect.field(bJ,"name","string","nil")expect.field(bJ,"category","string","nil")expect.field(bJ,"level","number","string","nil")expect.field(bJ,"time","number","nil")expect.field(bJ,"process","number","nil")expect.field(bJ,"thread","number","nil")expect.field(bJ,"module","string","nil")expect.field(bJ,"traceback","boolean","nil")if type(bJ.level)=="string"then bJ.level=dN[bJ.level:lower()]if not bJ.level then error("bad field 'level' (invalid name)",0)end elseif bJ.level and(bJ.level<0 or bJ.level>#dM)then error("bad field 'level' (level out of range)",0)end;bJ.name=bJ.name or"default"bJ.process=bJ.process or process.id;bJ.thread=bJ.thread or as and as.id;bJ.level=bJ.level or 1;bJ.time=bJ.time or os.epoch"utc"else local t=args.n;table.insert(args,1,bJ)args.n=t+1;bJ={process=process.id,thread=as and as.id,level=1,name="default",time=os.epoch"utc"}end;local dQ=syslogs[bJ.name]if dQ==nil then error("No such log named "..bJ.name,0)end;local ag;for x=1,args.n do ag=(x==1 and""or ag.." ")..serialize(args[x])end;if dQ.file then dQ.file.write(("[%s]%s %s[%d%s]%s [%s]: %s\n"):format(os.date("%b %d %X",bJ.time/1000),bJ.category and" <"..bJ.category..">"or"",processes[bJ.process]and processes[bJ.process].name or"(unknown)",bJ.process,bJ.thread and":"..bJ.thread or"",bJ.module and" ("..bJ.module..")"or"",dM[bJ.level],dP(args," ",1,args.n)))dQ.file.flush()end;if dQ.stream then bJ.message=ag;for B,k in pairs(dQ.stream)do local bh=true;if k.filter then local o,dR,aF=""local x=1;local dS,dT=false,false;while x<#k.filter do if dR==nil then o,x=k.filter:match("(%a+)%s*()",x)if bJ[o]==nil then bh=false;break end;dR=""elseif aF==nil then local b7=k.filter:sub(x,x+1)if b7=="=="or b7=="!="or b7=="=%"or b7=="!%"or b7=="<="or b7==">="then dR=b7 elseif b7=="~="then dR="!="elseif b7=="~%"then dR="!%"elseif k.filter:sub(x,x)=='<'or k.filter:sub(x,x)=='>'then dR=k.filter:sub(x,x)else bh=false;break end;aF=""else local ab=k.filter:sub(x,x)if dS then if ab==dS and not dT then dS,dT=false,false else aF=aF..ab;if not dT and ab=='\\'then dT=true else dT=false end end elseif ab=='"'or ab=="'"then dS=ab elseif ab=='|'or ab==';'then if dR=="=="and bJ[o]==aF or dR=="!="and bJ[o]~=aF or dR=="=%"and bJ[o]:match(aF)or dR=="!%"and not bJ[o]:match(aF)or dR=="<"and(tonumber(bJ[o])or 0)<(tonumber(aF)or 0)or dR=="<="and(tonumber(bJ[o])or 0)<=(tonumber(aF)or 0)or dR==">="and(tonumber(bJ[o])or 0)>=(tonumber(aF)or 0)or dR==">"and(tonumber(bJ[o])or 0)>(tonumber(aF)or 0)then if ab=='|'then x=k.filter:match("[^;]*;+()",x)if x==nil then break end;x=x-1 end;o,dR,aF=""dS,dT=false,false else bh=ab=='|'aF=""if not bh then break end end elseif not(ab==' 'and aF=="")then aF=aF..ab end;x=x+1 end end;if dS then bh=false;break end end;if bh then local process=processes[k.pid]if process then process.eventQueue[#process.eventQueue+1]={"syslog",deepcopy(bJ)}end end end end;if dQ.tty and dQ.tty_level<=bJ.level then if dQ.tty.isTTY then local a2=dP(args," ",1,args.n)if dQ.colorize and bJ.traceback then a2=a2:gsub("\t","  "):gsub("([^\n]+):(%d+):","\27[96m%1\27[37m:\27[95m%2\27[37m:"):gsub("'([^']+)'\n","\27[93m'%1'\27[37m\n")end;terminal.write(dQ.tty,("%s[%s]%s %s[%d%s]%s [%s]: %s%s\n"):format(dQ.colorize and dO[bJ.level]or"",os.date("%b %d %X",bJ.time/1000),bJ.category and" <"..bJ.category..">"or"",processes[bJ.process]and processes[bJ.process].name or"(unknown)",bJ.process,bJ.thread and":"..bJ.thread or"",bJ.module and" ("..bJ.module..")"or"",dM[bJ.level],a2,dQ.colorize and"\27[0m"or""))terminal.redraw(dQ.tty)else end end end;function syscalls.mklog(process,as,o,dU,g)expect(1,o,"string")expect(2,dU,"boolean","nil")expect(3,g,"string","nil")if syslogs[o]then return end;syslogs[o]={}if g then local q;syslogs[o].file,q=filesystem.open(process,g,"a")if syslogs[o].file==nil then syslogs[o]=nil;return error("Could not open log file: "..q,0)end end;if dU then syslogs[o].stream={}end end;function syscalls.rmlog(process,as,o)expect(1,o,"string")if o=="default"then error("Cannot delete default log",0)end;if not syslogs[o]then error("Log does not exist",0)end;if syslogs[o].stream then for B,k in pairs(syslogs[o].stream)do processes[k.pid].eventQueue[#processes[k.pid].eventQueue+1]={"syslog_close",{id=k.id}}processes[k.pid].dependents[k.id]=nil end end;syslogs[o]=nil end;function syscalls.openlog(process,as,o,dV)expect(1,o,"string")expect(2,dV,"string","nil")if not syslogs[o]then error("Log does not exist",0)end;if not syslogs[o].stream then error("Log does not have streaming enabled",0)end;local aC=#process.dependents+1;local c_=process.id;process.dependents[aC]={type="log",name=o,filter=dV,gc=function()for x,k in pairs(syslogs[o].stream)do if k.id==aC and k.pid==c_ then syslogs[o].stream[x]=nil end end end}syslogs[o].stream[#syslogs[o].stream+1]={pid=c_,id=aC,filter=dV}return aC end;function syscalls.closelog(process,as,o)expect(1,o,"string","number")if type(o)=="string"then if not syslogs[o]then error("Log does not exist",0)end;if not syslogs[o].stream then error("Log does not have streaming enabled",0)end;for x,k in pairs(syslogs[o].stream)do if k.pid==process.id then process.dependents[k.id]=nil;syslogs[o].stream[x]=nil end end else if not process.dependents[o]then error("Log connection does not exist",0)end;local dQ=syslogs[process.dependents[o].name].stream;for x,k in pairs(dQ)do if k.pid==process.id and k.id==o then process.dependents[k.id]=nil;dQ[x]=nil;break end end end end;function syscalls.logtty(process,as,o,de,b2)if process.user~="root"then error("Permission denied",0)end;expect(1,o,"string")expect(2,de,"table","number","nil")expect(3,b2,"number","nil")if not syslogs[o]then error("Log does not exist",0)end;syslogs[o].tty=type(de)=="table"and de or TTY[de]syslogs[o].tty_level=b2;return true end;function syslog.log(bJ,...)return pcall(syscalls.syslog,KERNEL,nil,bJ,...)end;function syslog.debug(...)return pcall(syscalls.syslog,KERNEL,nil,{level="debug",process=0},...)end;local dW=panic;function panic(ag)xpcall(function()TTY[1].isLocked=false;syslog.log({level="panic"},"Kernel panic:",ag)if debug then local ak=debug.traceback(nil,2)syslog.log({level="panic",traceback=true},ak)end;syslog.log({level="panic"},"We are hanging here...")terminal.redraw(TTY[1],true)term.setCursorBlink(false)mainThread=nil;while true do coroutine.yield()end end,function(C)dW(ag.."; and an error occurred while logging the error: "..C)end)end;xpcall(function()local q;syslogs.default.file,q=filesystem.open(KERNEL,"/var/log/default.log","a")shutdownHooks[#shutdownHooks+1]=function()if syslogs.default.file then syslogs.default.file.close()end end;syslog.log("Starting Phoenix version",PHOENIX_VERSION,PHOENIX_BUILD)syslog.log("Initialized system logger")syslog.log("System started at "..systemStartTime.." on computer "..os.computerID()..(os.computerLabel()and"('"..os.computerLabel().."')"or""))syslog.log("Computer host is ".._HOST)if syslogs.default.file==nil then syslog.log({level="notice"},"An error occurred while opening the log file at /var/log/default.log:",q,". System logs will not be saved to disk.")end end,panic)local function dX(bt)return string.match(bt,'^()%s*$')and''or string.match(bt,'^%s*(.*%S)')end;local expect,do_syscall=expect,do_syscall;local function dY(bk)local a9=1;local function bn(ab)if a9>#bk then return nil end;ab=ab or 1;local bt=bk:sub(a9,a9+ab-1)a9=a9+ab;return bt end;if bn(8)~="!<arch>\n"then error("Not an ar archive",2)end;local a7={}local dZ=nil;local d_={}while true do local bk={}local e0=bn()while e0=="\n"do e0=bn()end;if e0==nil then break end;local o=bn(15)if o==nil then break end;o=e0 ..o;if string.find(o,"/")and string.find(o,"/")>1 then o=string.sub(o,1,string.find(o,"/")-1)else o=dX(o)end;bk.timestamp=tonumber(dX(bn(12)))bk.owner=tonumber(dX(bn(6)))bk.group=tonumber(dX(bn(6)))bk.mode=tonumber(dX(bn(8)),8)local U=tonumber(dX(bn(10)))if bn(2)~="`\n"then error("Invalid header for file "..o,2)end;if string.match(o,"^#1/%d+$")then o=bn(tonumber(string.match(o,"#1/(%d+)")))elseif string.match(o,"^/%d+$")then if dZ then local t=tonumber(string.match(o,"/(%d+)"))o=dZ:match("[^/]*",t+1)else table.insert(d_,o)end end;bk.name=o;bk.data=bn(U)if o=="//"then dZ=bk.data elseif o~="/"and o~="/SYM64/"then table.insert(a7,bk)end end;if dZ then for j,k in pairs(d_)do local t=tonumber(string.match(k,"/(%d+)"))for P,ah in pairs(a7)do if ah.name==k then ah.name=dZ:match("[^/]*",t+1)break end end end end;local e1={}for B,k in ipairs(a7)do e1[k.name]=k end;return e1 end;function createRequire(process,cM)local e2,e3={},{}cM.package={}local e4=processes[process.parent]and processes[process.parent].env;if e4 then cM.package.path=e4.package and e4.package.path;cM.package.libpath=e4.package and e4.package.libpath end;cM.package.path=cM.package.path or"/lib/?.lua;/lib/?/init.lua;/usr/lib/?.lua;/usr/lib/?/init.lua;./?.lua;./?/init.lua"if type(process.vars.PACKAGE_PATH)=="string"then cM.package.path=process.vars.PACKAGE_PATH..';'..cM.package.path end;cM.package.libpath=cM.package.libpath or"/lib/lib?.a;/usr/lib/lib?.a"if type(process.vars.PACKAGE_LIBPATH)=="string"then cM.package.libpath=process.vars.PACKAGE_LIBPATH..';'..cM.package.libpath end;cM.package.config="/\n;\n?\n!\n-"cM.package.loaded=e2;cM.package.preload=e3;cM.package.forceload=false;for j,k in pairs(cM)do if type(k)=="table"then e2[j]=k end end;local e5=setmetatable({},{__newindex=function()end,__metatable=false})local e6={}local function e7(o,g)local a,q=do_syscall("open",g,"rb")if not a then error(g..": "..q,3)end;local bk=a.readAll()a.close()local i,q=load(bk,"@"..g,nil,_ENV)if not i then error(g..": "..q,3)end;local cd=g:match("^(.*)/[^/]*$")or"/"e6[#e6+1]=function(e8)local g,q=package.searchpath(e8,cd.."/?.lua;"..cd.."/?/init.lua")if not g then return nil,q end;return e7,g end;local bh,w=pcall(i,o)e6[#e6]=nil;if bh then return w else error(g..": "..w,3)end end;local function e9(o,g)local ea;if g:find"%z"then g,ea=g:match"^([^%z]*)%z(.*)$"elseif o:find"%-"then ea=o:match("^([^%-]*)%-(.*)$")else ea="init"end;local a,q=do_syscall("open",g,"rb")if not a then error(g..": "..q,3)end;local bk=a.readAll()a.close()local cd=dY(bk)local function eb(o)local G=o..".lua"if not cd[G]then error(g..":"..G..": File not found",0)end;local bk=cd[G].data;local i,q=load(bk,"@"..g..":"..G,nil,_ENV)if not i then error(g..":"..G..": "..q,3)end;local bh,w=pcall(i,o)if bh then return w else error(g..":"..G..": "..w)end end;e6[#e6+1]=function(e8)return eb,e8 end;local w=eb(ea)e6[#e6]=nil;return w end;e6[1]=function(o)local cd=do_syscall("getname"):match("^(.*)/[^/]*$")or"/"local g,q=package.searchpath(o,cd.."/?.lua;"..cd.."/?/init.lua")if not g then return nil,q end;return e7,g end;function cM.package.searchpath(o,g,ao,ec)expect(1,o,"string")expect(2,g,"string")expect(3,ao,"string","nil")expect(4,ec,"string","nil")ao=(ao or"."):gsub("([%^%$%(%)%%%.%[%]%*%+%-%?])","%%%1")ec=(ec or"/"):gsub("([%^%$%(%)%%%.%[%]%*%+%-%?])","%%%1")local ed=""for G in g:gmatch"[^;]+"do local cf=G:gsub("%?",o:gsub(ao,ec),nil)local a,q=do_syscall("open",cf,"r")if a then a.close()return cf else ed=ed.."\t"..cf..": "..q.."\n"end end;return nil,ed end;cM.package.searchers={function(o)local G=e3[o]if G then return G else return nil,"\tpackage.preload['"..o.."']: No such field\n"end end,function(o)local g,q=package.searchpath(o,package.path)if not g then return nil,q end;return e7,g,g end,function(o)local g,q=package.searchpath(o:match("^[^%-]*"),package.libpath)if not g then return nil,q end;local t=o:match("%-(.+)$")if t then return e9,g,g..":"..t else return e9,g,g..":init"end end,function(o)if not o:find"%."then return nil end;local g,q=package.searchpath(o:match("^[^%.]*"),package.libpath)if not g then return nil,q end;local t=o:match("^[^%.]*%.(.*)$")return e9,g.."\0"..t,g..":"..t end,function(o)if#e6>0 then return e6[#e6](o)end;return nil,"no local loaders found"end}setfenv(e7,cM)debug.protect(e7)setfenv(e9,cM)debug.protect(e9)setfenv(e6[1],cM)debug.protect(e6[1])for B,k in pairs(cM.package.searchers)do setfenv(k,cM)debug.protect(k)end;function cM.require(o)expect(1,o,"string")local q="module '"..o.."' not found:\n"local ee,ef,eg;for B,k in ipairs(package.searchers)do ee,ef,eg=k(o)if ee then break end;q=q..(ef or"")end;if not ee then error(q,2)end;if eg then if e2[eg]then if e2[eg]==e5 then error("loop detected loading '"..o.."'",3)elseif not package.forceload then return e2[eg]end end;e2[eg]=e5 else if e2[o]then if e2[o]==e5 then error("loop detected loading '"..o.."'",3)elseif not package.forceload then return e2[o]end end end;e2[o]=e5;local bh,w=pcall(ee,o,ef)if bh then if w~=nil then e2[o]=w elseif e2[o]==e5 then e2[o]=true end;if eg then if w~=nil then e2[eg]=w elseif e2[eg]==e5 then e2[eg]=true end end;return e2[o]else e2[o]=nil;if eg then e2[eg]=nil end;error(q.."\t"..w.."\n",2)end end;return cM end;do local e2,e3={},{}package={}package.path="/lib/?.lua;/lib/?/init.lua;/usr/lib/?.lua;/usr/lib/?/init.lua"package.libpath="/lib/lib?.a;/usr/lib/lib?.a"package.config="/\n;\n?\n!\n-"package.loaded=e2;package.preload=e3;package.forceload=false;for j,k in pairs(_G)do if type(k)=="table"then e2[j]=k end end;local e5=setmetatable({},{__newindex=function()end,__metatable=false})local e6={}local function e7(o,g)local bK,q=filesystem.stat(KERNEL,g)if not bK then error(g..": "..q,3)end;if bK.owner~="root"or bK.worldPermissions.write then error(g..": Insecure file permissions",3)end;for j,k in pairs(bK.permissions)do if j~="root"and k.write then error(g..": Insecure file permissions",3)end end;local a,q=filesystem.open(KERNEL,g,"rb")if not a then error(g..": "..q,3)end;local bk=a.readAll()a.close()local i,q=load(bk,"@"..g,nil,_G)if not i then error(g..": "..q,3)end;local cd=g:match("^(.*)/[^/]*$")or"/"e6[#e6+1]=function(e8)local g,q=package.searchpath(e8,cd.."/?.lua;"..cd.."/?/init.lua")if not g then return nil,q end;return e7,g end;local bh,w=pcall(i,o)e6[#e6]=nil;if bh then return w else error(g..": "..w,3)end end;local function e9(o,g)local ea;if g:find"%z"then g,ea=g:match"^([^%z]*)%z(.*)$"elseif o:find"%-"then ea=o:match("^([^%-]*)%-(.*)$")else ea="init"end;local bK,q=filesystem.stat(KERNEL,g)if not bK then error(g..": "..q,3)end;if bK.owner~="root"or bK.worldPermissions.write then error(g..": Insecure file permissions",3)end;for j,k in pairs(bK.permissions)do if j~="root"and k.write then error(g..": Insecure file permissions",3)end end;local a,q=filesystem.open(KERNEL,g,"rb")if not a then error(g..": "..q,3)end;local bk=a.readAll()a.close()local cd=dY(bk)local function eb(o)local G=o..".lua"if not cd[G]then error(g..":"..G..": File not found",0)end;local bk=cd[G].data;local i,q=load(bk,"@"..g..":"..G,nil,_ENV)if not i then error(g..":"..G..": "..q,3)end;local bh,w=pcall(i,o)if bh then return w else error(g..":"..G..": "..w)end end;e6[#e6+1]=function(e8)return eb,e8 end;local w=eb(ea)e6[#e6]=nil;return w end;function package.searchpath(o,g,ao,ec)expect(1,o,"string")expect(2,g,"string")expect(3,ao,"string","nil")expect(4,ec,"string","nil")ao=(ao or"."):gsub("([%^%$%(%)%%%.%[%]%*%+%-%?])","%%%1")ec=(ec or"/"):gsub("([%^%$%(%)%%%.%[%]%*%+%-%?])","%%%1")local ed=""for G in g:gmatch"[^;]+"do local cf=G:gsub("%?",o:gsub(ao,ec),nil)local a,q=filesystem.open(KERNEL,cf,"r")if a then a.close()return cf else ed=ed.."\t"..cf..": "..q.."\n"end end;return nil,ed end;package.searchers={function(o)local G=e3[o]if G then return G else return nil,"\tpackage.preload['"..o.."']: No such field\n"end end,function(o)local g,q=package.searchpath(o,package.path)if not g then return nil,q end;return e7,g,g end,function(o)local g,q=package.searchpath(o:match("^[^%-]*"),package.libpath)if not g then return nil,q end;local t=o:match("%-(.+)$")if t then return e9,g,g..":"..t else return e9,g,g..":init"end end,function(o)if not o:find"%."then return nil end;local g,q=package.searchpath(o:match("^[^%.]*"),package.libpath)if not g then return nil,q end;local t=o:match("^[^%.]*%.(.*)$")return e9,g.."\0"..t,g..":"..t end,function(o)if#e6>0 then return e6[#e6](o)end;return nil,"\tno local loaders found"end}function require(o)expect(1,o,"string")local q="module '"..o.."' not found:\n"local ee,ef,eg;for B,k in ipairs(package.searchers)do ee,ef,eg=k(o)if ee then break end;q=q..(ef or"")end;if not ee then error(q,2)end;if eg then if e2[eg]then if e2[eg]==e5 then error("loop detected loading '"..o.."'",3)elseif not package.forceload then return e2[eg]end end;e2[eg]=e5 else if e2[o]then if e2[o]==e5 then error("loop detected loading '"..o.."'",3)elseif not package.forceload then return e2[o]end end end;e2[o]=e5;local bh,w=pcall(ee,o,ef)if bh then if w~=nil then e2[o]=w elseif e2[o]==e5 then e2[o]=true end;if eg then if w~=nil then e2[eg]=w elseif e2[eg]==e5 then e2[eg]=true end end;return e2[o]else e2[o]=nil;if eg then e2[eg]=nil end;error(q.."\t"..w.."\n",2)end end end;timerMap={}alarmMap={}local eh={}function syscalls.kill(process,as,c_,ei)expect(1,c_,"number")expect(2,ei,"number")local ej=processes[c_]if not ej then error("No such process",2)end;if process.user~="root"and process.user~=ej.user then error("Permission denied",2)end;if ei==9 then reap_process(ej)if processes[ej.parent]then syscalls.queueEvent(processes[ej.parent],nil,"process_complete",{id=c_,result=9})end;processes[c_]=nil elseif ej.signalHandlers[ei]then userModeCallback(ej,ej.signalHandlers[ei],ei)else syscalls.queueEvent(ej,nil,"signal",{signal=ei})end end;function killProcess(c_,ei)expect(1,c_,"number")expect(2,ei,"number")local ej=processes[c_]if not ej then return end;if ei==9 then reap_process(ej)if processes[ej.parent]then syscalls.queueEvent(processes[ej.parent],nil,"process_complete",{id=c_,result=9})end;processes[c_]=nil elseif ej.signalHandlers[ei]then syscalls.newthread(ej,nil,ej.signalHandlers[ei],ei)else syscalls.queueEvent(ej,nil,"signal",{signal=ei})end end;function syscalls.signal(process,as,ei,ek)expect(1,ei,"number")expect(2,ek,"function","nil")process.signalHandlers[ei]=ek end;function syscalls.queueEvent(process,as,o,ax)expect(1,o,"string")expect(2,ax,"table")process.eventQueue[#process.eventQueue+1]={o,ax}end;function syscalls.sendEvent(process,as,c_,o,ax)expect(1,c_,"number")expect(2,o,"string")local ej=processes[c_]if not ej then return false end;ej.eventQueue[#ej.eventQueue+1]={"remote_event",{type=o,sender=process.id,data=ax}}return true end;function syscalls.register(process,as,o)expect(1,o,"string")if eh[o]then return false end;eh[o]=process.id;process.dependents[#process.dependents+1]={gc=function()eh[o]=nil end}return true end;function syscalls.lookup(process,as,o)expect(1,o,"string")return eh[o]end;function syscalls.timer(process,as,el)expect(1,el,"number")local em=os.startTimer(el)timerMap[em]=process;return bit32.band(em,0x7FFFFFFF)end;function syscalls.alarm(process,as,el)expect(1,el,"number")local em=os.setAlarm(el)alarmMap[em]=process;return bit32.bor(em,0x80000000)end;function syscalls.cancel(process,as,em)expect(1,em,"number")if bit32.btest(em,0x80000000)then em=bit32.band(em,0x7FFFFFFF)if alarmMap[em]~=process then error("No such alarm")end;os.cancelAlarm(em)alarmMap[em]=nil else if timerMap[em]~=process then error("No such timer")end;os.cancelTimer(em)timerMap[em]=nil end end;eventHooks.terminate=eventHooks.terminate or{}eventHooks.terminate[#eventHooks.terminate+1]=function()if currentTTY.frontmostProcess then syscalls.kill(KERNEL,nil,currentTTY.frontmostProcess.id,2)terminal.write(currentTTY,"^T")end end;eventParameterMap={alarm={"id"},char={"character"},key={"keycode","isRepeat"},key_up={"keycode"},mouse_click={"button","x","y"},mouse_drag={"button","x","y"},mouse_up={"button","x","y"},mouse_scroll={"direction","x","y"},paste={"text"},redstone={},term_resize={},timer={"id"},turtle_inventory={}}do local en=0;for B,k in pairs(keys)do if type(k)=="number"then en=math.max(en,k)end end;local bv;local eo,ep=pcall(string.dump,function()end)if eo then local eq=(function(r)if r<8 then return r end;local M=0;while r>=128 do r,M=bit32.rshift(r+0xf,4),M+4 end;while r>=16 do r,M=bit32.rshift(r+1,1),M+1 end;return bit32.bor((M+1)*8,r-8)end)(en)syslog.debug("Key table sizes:",en,eq)if _VERSION=="Lua 5.1"then bv=ep:sub(1,12)..("I"..ep:byte(9).."IIBBBBIIIIIIII"):pack(0,0,0,0,0,0,1,2,eq*0x800000+10,0x0100001E,0,0,0,0,0)elseif _VERSION=="Lua 5.2"then bv=ep:sub(1,18)..("IIBBBIIIIIIIIII"):pack(0,0,0,0,1,2,eq*0x800000+11,0x0100001F,0,0,0,0,0,0,0)elseif _VERSION=="Lua 5.3"then bv=ep:sub(1,17+("jn"):packsize())..("BBIIBBBIIIIIIIII"):pack(0,0,0,0,0,0,1,2,eq*0x800000+11,0x01000026,0,0,0,0,0,0)elseif _VERSION=="Lua 5.4"then bv=ep:sub(1,15+("jn"):packsize())..("BBBBBBBBIIIBBBBBBB"):pack(0,0x80,0x80,0x80,0,0,1,0x83,0x00000013,en*0x80+82,0x00008048,0x80,0x80,0x80,0x80,0x80,0x80,0x80)end;if bv then local i,q=load(bv,nil,"b")if i then keymap=i()else syslog.debug("Could not load key table code:",q)end end end;if not keymap then keymap=load("return {"..("nil,"):rep(en).."}")()end;for x=0x61,0x7A do keymap[keys[string.char(x)]]=x end;for x=0x81,0x99 do if keys["f"..bit32.band(x,31)]then keymap[keys["f"..bit32.band(x,31)]]=x end end;for x=0xA0,0xA9 do keymap[keys["numPad"..bit32.band(x,15)]]=x end;keymap[keys.backspace]=0x08;keymap[keys.tab]=0x09;keymap[keys.enter or keys["return"]]=0x0A;keymap[keys.space]=0x20;keymap[keys.apostrophe]=0x27;keymap[keys.comma]=0x2C;keymap[keys.minus]=0x2D;keymap[keys.period]=0x2E;keymap[keys.slash]=0x2F;keymap[keys.zero]=0x30;keymap[keys.one]=0x31;keymap[keys.two]=0x32;keymap[keys.three]=0x33;keymap[keys.four]=0x34;keymap[keys.five]=0x35;keymap[keys.six]=0x36;keymap[keys.seven]=0x37;keymap[keys.eight]=0x38;keymap[keys.nine]=0x39;keymap[keys.semicolon or keys.semiColon]=0x3B;keymap[keys.equals]=0x3D;keymap[keys.leftBracket]=0x5B;keymap[keys.backslash]=0x5C;keymap[keys.rightBracket]=0x5D;keymap[keys.grave]=0x60;keymap[keys.delete]=0x7F;keymap[keys.insert]=0x80;if keys.convert then keymap[keys.convert]=0x9A end;if keys.noconvert then keymap[keys.noconvert]=0x9B end;if keys.kana then keymap[keys.kana]=0x9C end;if keys.kanji then keymap[keys.kanji]=0x9D end;if keys.yen then keymap[keys.yen]=0x9E end;keymap[keys.numPadDecimal]=0x9F;keymap[keys.numPadAdd]=0xAA;keymap[keys.numPadSubtract]=0xAB;if keys.numPadMultiply then keymap[keys.numPadMultiply]=0xAC end;keymap[keys.numPadDivide]=0xAD;keymap[keys.numPadEqual or keys.numPadEquals]=0xAE;keymap[keys.numPadEnter]=0xAF;keymap[keys.leftCtrl]=0xB0;keymap[keys.rightCtrl]=0xB1;keymap[keys.leftAlt]=0xB2;keymap[keys.rightAlt]=0xB3;keymap[keys.leftShift]=0xB4;keymap[keys.rightShift]=0xB5;if keys.leftSuper then keymap[keys.leftSuper]=0xB6 end;if keys.rightSuper then keymap[keys.rightSuper]=0xB7 end;keymap[keys.capsLock]=0xB8;keymap[keys.numLock]=0xB9;keymap[keys.scrollLock or keys.scollLock]=0xBA;if keys.printScreen then keymap[keys.printScreen]=0xBB end;keymap[keys.pause]=0xBC;if keys.menu then keymap[keys.menu]=0xBD end;if keys.stop then keymap[keys.stop]=0xBE end;if keys.ax then keymap[keys.ax]=0xBF end;keymap[keys.up]=0xC0;keymap[keys.down]=0xC1;keymap[keys.left]=0xC2;keymap[keys.right]=0xC3;keymap[keys.pageUp]=0xC4;keymap[keys.pageDown]=0xC5;keymap[keys.home]=0xC6;keymap[keys["end"]]=0xC7;if keys.circumflex or keys.cimcumflex then keymap[keys.circumflex or keys.cimcumflex]=0xC8 end;if keys.at then keymap[keys.at]=0xC9 end;if keys.colon then keymap[keys.colon]=0xCA end;if keys.underscore then keymap[keys.underscore]=0xCB end end;local er={id=0,name="",coro=coroutine.create(function()end),status="starting",args={"a",n=1},filter=function(process,as,cc)end}local es={id=1,name="init",user="root",dependents={{gc=function()end}},parent=0,dir="/",stdin=TTY[1],stdout={},stderr=TTY[1],cputime=0.2,systime=0.1,env={},syscallyield=nil,eventQueue={},signalHandlers={},paused=false,nice=0,threads={[0]=er}}local et=1;local function eu(process)local e=createLuaLib(process)if _VERSION<"Lua 5.2"then e=make_ENV(e)end;e._G=e;return e end;local function ev()coroutine.yield("preempt","test",7)end;local ew={load}function addProcessLoader(ee)table.insert(ew,1,ee)end;function removeProcessLoader(ee)for x,k in ipairs(ew)do if k==ee then table.remove(ew,x)return end end end;function reap_process(process)syslog.debug("Reaping process "..process.id.." ("..process.name..")")for B,k in ipairs(process.dependents)do k:gc()end;if process.stdin and process.stdin.isTTY then if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)process.stdin.preBuffer=""if discord and process.stdout==currentTTY and process.stdout.frontmostProcess then discord("Phoenix","Executing "..process.stdout.frontmostProcess.name)end else for x,k in ipairs(process.stdin.processList)do if k==process then table.remove(process.stdin.processList,x)break end end end end;if process.stdout and process.stdout.isTTY then if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)else for x,k in ipairs(process.stdout.processList)do if k==process then table.remove(process.stdout.processList,x)break end end end end;if process.stderr and process.stderr.isTTY then if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)else for x,k in ipairs(process.stderr.processList)do if k==process then table.remove(process.stderr.processList,x)break end end end end end;function syscalls.getpid(process,as)return process.id end;function syscalls.getppid(process,as)return process.parent end;function syscalls.clock(process,as)return process.cputime end;function syscalls.getenv(process,as)return process.vars end;function syscalls.getfenv(process,as)return process.env end;function syscalls.getname(process,as)return process.name end;function syscalls.getcwd(process,as)return process.dir end;function syscalls.chdir(process,as,cd)expect(1,cd,"string")local bK=filesystem.stat(process,cd)if not bK or bK.type~="directory"then return false,"No such file or directory"elseif not(bK.permissions[process.user]or bK.worldPermissions).execute then return false,"Permission denied"end;process.dir=cd:gsub("^([^/])","/"..process.dir.."/%1")return true end;function syscalls.getuser(process,as)return process.user,process.realuser end;function syscalls.setuser(process,as,user)expect(1,user,"string")if process.user~="root"then error("Permission denied")end;process.user=user;process.realuser=nil end;local function ex(cM)return{["nil"]={},["boolean"]={__unm=function()end},["number"]={},["string"]={__index=cM.string},["function"]={},["thread"]={__index=cM.coroutine,__call=cM.coroutine.resume},["userdata"]={}}end;function syscalls.fork(process,as,aB,o,...)expect(1,aB,"function")expect(2,o,"string","nil")local aC=et;et=et+1;processes[aC]={id=aC,name=o or process.name,user=process.user,dependents={},parent=process.id,dir=process.dir,root=process.root,stdin=process.stdin,stdout=process.stdout,stderr=process.stderr,vars=deepcopy(process.vars),cputime=0,systime=0,syscallyield=nil,eventQueue={},signalHandlers={[1]=function()return coroutine.yield("syscall","exit",1)end,[2]=function()return coroutine.yield("syscall","exit",1)end,[3]=function()coroutine.yield("syscall","syslog",{level="error",category="Application Error",traceback=true},debug.traceback("Quit"))return coroutine.yield("syscall","exit",1)end,[6]=function(q)coroutine.yield("syscall","syslog",{level="error",category="Application Error",traceback=true},debug.traceback(q or"Aborted"))return coroutine.yield("syscall","exit",1)end,[13]=function()return coroutine.yield("syscall","exit",1)end,[15]=function()return coroutine.yield("syscall","exit",1)end,[19]=function()return coroutine.yield("syscall","suspend")end,[21]=function()return coroutine.yield("syscall","suspend")end,[22]=function()return coroutine.yield("syscall","suspend")end},paused=false,nice=0,threads={[0]={id=0,name="<main thread>",coro=coroutine.create(aB),syscall=coroutine.create(function(...)local args=table.pack(...)while true do args=table.pack(coroutine.yield(kSyscallComplete,xpcall(syscalls[args[1]],debug.traceback,table.unpack(args,2,args.n))))end end),status="starting",args=table.pack(...),filter=nil}}}processes[aC].env=eu(processes[aC])processes[aC].globalMetatables=ex(processes[aC].env)setfenv(aB,processes[aC].env)if process.stdin and process.stdin.isTTY and not process.stdin.isLocked then process.stdin.processList[#process.stdin.processList+1]=process.stdin.frontmostProcess;process.stdin.frontmostProcess=processes[aC]process.stdin.preBuffer=""if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.name)end end;if process.stdout and process.stdout.isTTY and not process.stdout.isLocked and process.stdout.frontmostProcess~=processes[aC]then process.stdout.processList[#process.stdout.processList+1]=process.stdout.frontmostProcess;process.stdout.frontmostProcess=processes[aC]end;if process.stderr and process.stderr.isTTY and not process.stderr.isLocked and process.stderr.frontmostProcess~=processes[aC]then process.stderr.processList[#process.stderr.processList+1]=process.stderr.frontmostProcess;process.stderr.frontmostProcess=processes[aC]end;if args.preemptive then debug.sethook(processes[aC].threads[0].coro,ev,"",args.quantum)end;return aC end;function syscalls.exec(process,as,g,...)expect(1,g,"string")local a,q=filesystem.open(process,g,"r")if not a then g=g..".lua"a,q=filesystem.open(process,g,"r")if not a then error("Could not open file: "..q,0)end end;local ey=a.readAll()a.close()if ey:find("[%z\1-\31]")then a,q=filesystem.open(process,g,"rb")if not a then error("Could not open file: "..q,0)end;ey=a.readAll()a.close()end;local bK=filesystem.stat(process,g)if not(bK.permissions[bK.owner]or bK.worldPermissions).execute then error("Could not execute file: Permission denied",0)end;if bK.setuser then process.realuser,process.user=process.user,bK.owner end;if ey:sub(1,2)=="#!"then local ez=ey:sub(3,ey:find("\n")-1)local args,x={},0;for bt in ez:gmatch"%S+"do args[x]=bt;x=x+1 end;args[x],x=g,x+1;for B,k in ipairs{...}do args[x]=k;x=x+1 end;if args[0]==g then error("Recursive path detected while resolving shebang",0)end;syscalls.exec(process,as,args[0],table.unpack(args,1,x))process.name="/"..fs.combine(g:sub(1,1)=="/"and""or process.dir,g)else local aB,q;for B,ee in ipairs(ew)do aB,q=ee(ey,"@"..g,"bt",process.env)if aB then break end end;if not aB then error("Could not execute file: "..q,0)end;process.name="/"..fs.combine(g:sub(1,1)=="/"and""or process.dir,g)process.threads={[0]={id=0,name="<main thread>",coro=coroutine.create(aB),syscall=coroutine.create(function(...)local args=table.pack(...)while true do args=table.pack(coroutine.yield(kSyscallComplete,xpcall(syscalls[args[1]],debug.traceback,table.unpack(args,2,args.n))))end end),status="starting",args=table.pack(...),filter=nil}}if args.preemptive then debug.sethook(process.threads[0].coro,ev,"",args.quantum*10^(process.nice/-10))end end;if discord and process.stdin and process.stdin.isTTY and process.stdin.frontmostProcess==process then discord("Phoenix","Executing "..process.name)end end;function syscalls.newthread(process,as,aB,...)expect(1,aB,"function")local aC=#process.threads+1;process.threads[aC]={id=aC,name="<thread:"..aC..">",coro=coroutine.create(aB),syscall=coroutine.create(function(...)local args=table.pack(...)while true do args=table.pack(coroutine.yield(kSyscallComplete,xpcall(syscalls[args[1]],debug.traceback,table.unpack(args,2,args.n))))end end),status="starting",args=table.pack(...),filter=nil}setfenv(aB,process.env)if args.preemptive then debug.sethook(process.threads[aC].coro,ev,"",args.quantum*10^(process.nice/-10))end;return aC end;function syscalls.exit(process,as,bv)process.lastReturnValue={pid=process.id,thread=as.id,value=bv,n=1,bv}for B,as in pairs(process.threads)do as.status="dead"as.return_value=bv end end;function syscalls.atexit(process,as,i)expect(1,i,"function")process.dependents[#process.dependents+1]={gc=function()local aC=syscalls.newthread(process,nil,i)local x=0;while process.threads[aC]and process.threads[aC].coro:status()=="suspended"and x<100 do executeThread(process,process.threads[aC],{n=0},false,false)x=x+1 end end}end;function syscalls.getplist(process,as)local eA={}for j in pairs(processes)do eA[#eA+1]=j end;table.sort(eA)return eA end;function syscalls.getpinfo(process,as,c_)expect(1,c_,"number")local G=processes[c_]if not G then return nil,"No such process"end;local eB,eC,eD;for x,k in ipairs(TTY)do if G.stdin==k then eB=x end;if G.stdout==k then eC=x end;if G.stderr==k then eD=x end end;local eE={}if G.threads then for x,k in pairs(G.threads)do eE[x]={id=k.id,name=k.name,status=k.status}end end;return{id=G.id,name=G.name,user=G.user,realuser=G.realuser,parent=G.parent,dir=G.dir,stdin=eB,stdout=eC,stderr=eD,cputime=G.cputime or 0,systime=G.systime or 0,threads=eE}end;function syscalls.suspend(process,as)process.paused=true end;function syscalls.nice(process,as,b2,c_)expect(1,b2,"number")expect.range(b2,-20,20)expect(2,c_,"number","nil")if b2<0 and process.user~="root"then error("Permission denied",0)end;local ej=c_ and assert(processes[c_],"Invalid process ID")or process;if ej.user~=process.user and process.user~="root"then error("Permission denied",0)end;ej.nice=b2;if args.preemptive then for B,A in pairs(ej.threads)do debug.sethook(A.coro,ev,"",args.quantum*10^(b2/-10))end end end;local function eF(a2)a2=a2 .."\x80"..("\0"):rep(-(#a2+9)%64)..(">I8"):pack(#a2)local eG,eH,eI,eJ,eK,ah=0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476,0xC3D2E1F0,{}for eL=1,#a2,64 do local eM=eL;for x=0,15 do ah[x]=a2:byte(eM)*0x1000000+a2:byte(eM+1)*0x10000+a2:byte(eM+2)*0x100+a2:byte(eM+3)eM=eM+4 end;for x=16,79 do ah[x]=bit32.lrotate(bit32.bxor(ah[x-3],ah[x-8],ah[x-14],ah[x-16]),1)end;local cx,ad,ab,br,M=eG,eH,eI,eJ,eK;for x=0,79 do local f,j;if x<=19 then f,j=bit32.bxor(br,bit32.band(ad,bit32.bxor(ab,br))),0x5A827999 elseif x<=39 then f,j=bit32.bxor(ad,ab,br),0x6ED9EBA1 elseif x<=59 then f,j=bit32.bor(bit32.band(ad,bit32.bor(ab,br)),bit32.band(ab,br)),0x8F1BBCDC else f,j=bit32.bxor(ad,ab,br),0xCA62C1D6 end;local eN=bit32.band(bit32.lrotate(cx,5)+f+M+j+ah[x],0xFFFFFFFF)M,br,ab,ad,cx=br,ab,bit32.lrotate(ad,30),cx,eN end;eG=bit32.band(eG+cx,0xFFFFFFFF)eH=bit32.band(eH+ad,0xFFFFFFFF)eI=bit32.band(eI+ab,0xFFFFFFFF)eJ=bit32.band(eJ+br,0xFFFFFFFF)eK=bit32.band(eK+M,0xFFFFFFFF)end;return{eG,eH,eI,eJ,eK}end;local function eO(eP,o)local eQ=eF(eP:gsub("%X",""):gsub("%x%x",function(bt)return string.char(tonumber(bt,16))end)..o)local cx,ad,ab,br=eQ[1],bit32.bor(bit32.band(eQ[2],0xFFFF0FFF),0x5000),bit32.bor(bit32.band(eQ[3],0x3FFFFFFF),0x80000000),eQ[4]return("%08x-%04x-%04x-%04x-%04x%08x"):format(cx,bit32.rshift(ad,16),bit32.band(ad,0xFFFF),bit32.rshift(ab,16),bit32.band(ab,0xFFFF),br)end;local eR="a6f53b7d-50f3-4e51-adef-8728c83e3f3a"deviceTreeRoot={id=tostring(os.getComputerID()),uuid=eO(eR,tostring(os.getComputerID())),parent=nil,displayName=os.getComputerLabel()or"",drivers={},metadata={},internalState={},children={},listeners=setmetatable({},{__mode="k"})}local eS={[deviceTreeRoot.uuid]=deviceTreeRoot}local eT={}function hardware.get(g)expect(1,g,"string")if g:find("^%x+%-%x+%-%x+%-%x+%-%x+$")then return eS[g]elseif g==""or g:find("/")then local dL=deviceTreeRoot;for o in g:gmatch"[^/]+"do dL=dL.children[o]if dL==nil then break end end;return dL else local eU={}local function eV(dL)if dL.id==g or dL.alias==g then eU[#eU+1]=dL end;for B,k in pairs(dL.children)do eV(k)end end;eV(deviceTreeRoot)return table.unpack(eU)end end;function hardware.find(type)expect(1,type,"string")local eW={}local function eX(dL)for B,k in ipairs(dL.drivers)do if k.type==type then eW[#eW+1]=dL;break end end;for B,k in pairs(dL.children)do eX(k)end end;eX(deviceTreeRoot)return table.unpack(eW)end;function hardware.path(dL)expect(1,dL,"table")expect.field(dL,"uuid","string")if not eS[dL.uuid]then error("bad argument #1 (invalid node)",2)end;local g=dL.id;dL=dL.parent;while dL do g=dL.id.."/"..g;dL=dL.parent end;g=g:gsub("^[^/]+","")return g==""and"/"or g end;function hardware.add(c2,o)expect(1,c2,"table")expect(2,o,"string")expect.field(c2,"uuid","string")if not eS[c2.uuid]then return nil,"Invalid parent node"end;if c2.children[o]then return nil,"Node already exists"end;local dL={id=o,uuid=eO(c2.uuid,o),parent=c2,displayName="",drivers={},metadata={},internalState={},children={},listeners=setmetatable({},{__mode="k"})}c2.children[o]=dL;eS[dL.uuid]=dL;syslog.log({module="Hardware"},"Added new device at "..hardware.path(dL))for B,k in ipairs(eT)do if(not k.parent or k.parent==c2)and(not k.pattern or o:match(k.pattern))then k.callback(dL)end end;return dL end;function hardware.remove(dL)expect(1,dL,"table")expect.field(dL,"uuid","string")if not eS[dL.uuid]then return false,"Invalid node"end;if dL==deviceTreeRoot or not dL.parent then return false,"Cannot remove root node"end;for x=#dL.drivers,1,-1 do hardware.deregister(dL,dL.drivers[x])end;for B,k in pairs(dL.children)do hardware.remove(k)end;syslog.log({module="Hardware"},"Device at "..hardware.path(dL).." has been removed")dL.parent.children[dL.id]=nil;eS[dL.uuid]=nil;dL.parent=nil;return true end;function hardware.register(dL,eY)expect(1,dL,"table")expect(2,eY,"table")expect.field(dL,"uuid","string")expect.field(eY,"name","string")expect.field(eY,"type","string")expect.field(eY,"properties","table")expect.field(eY,"methods","table")expect.field(eY,"init","function","nil")expect.field(eY,"deinit","function","nil")for j in pairs(eY.methods)do if type(j)~="string"then error("bad method name '"..tostring(j).."' (not a string)",2)end;expect.field(eY.methods,j,"function")end;for B,k in ipairs(eY.properties)do if type(k)~="string"then error("bad property name '"..tostring(k).."' (not a string)",2)end;if not eY.methods["get"..k:sub(1,1):upper()..k:sub(2)]then error("bad property '"..k.."' (no getter present)",2)end end;if not eS[dL.uuid]then error("bad argument #1 (invalid node)",2)end;for B,k in ipairs(dL.drivers)do if k==eY then return false end end;dL.drivers[#dL.drivers+1]=eY;syslog.log({module="Hardware"},"Registered device with type "..eY.type.." on device "..hardware.path(dL).." using driver "..eY.name)if eY.init then eY.init(dL)end;return true end;function hardware.register_callback(eY)return function(dL)return hardware.register(dL,eY)end end;function hardware.deregister(dL,eY)expect(1,dL,"table")expect(2,eY,"table")expect.field(dL,"uuid","string")if not eS[dL.uuid]then error("bad argument #1 (invalid node)",2)end;for x,k in ipairs(dL.drivers)do if k==eY then if eY.deinit then eY.deinit(dL)end;table.remove(dL.drivers,x)syslog.log({module="Hardware"},"Driver "..eY.name.." has been deregistered from device "..hardware.path(dL))return true end end;return false end;function hardware.listen(eZ,c2,e_)expect(1,eZ,"function")expect(2,c2,"table","nil")expect(3,e_,"string","nil")if c2 then expect.field(c2,"uuid","string")end;if e_ and not pcall(string.match,"",e_)then error("bad argument #3 (invalid pattern)",2)end;eT[#eT+1]={callback=eZ,parent=c2,pattern=e_}end;function hardware.unlisten(eZ)expect(1,eZ,"function")local x=1;while x<#eT do if eT[x].callback==eZ then table.remove(eT,x)else x=x+1 end end end;function hardware.broadcast(dL,cc,d2)expect(1,dL,"table")expect(2,cc,"string")expect(3,d2,"table")expect.field(dL,"uuid","string")if not eS[dL.uuid]then error("bad argument #1 (invalid node)",2)end;for k in pairs(dL.listeners)do k.eventQueue[#k.eventQueue+1]={cc,d2}end end;function hardware.call(process,dL,f0,...)for B,eY in ipairs(dL.drivers)do if eY.methods[f0]then return eY.methods[f0](dL,process,...)end end;error("No such method",2)end;function syscalls.devlookup(process,as,o)expect(1,o,"string")local f1={hardware.get(o)}for j,k in ipairs(f1)do f1[j]=hardware.path(k)end;return table.unpack(f1)end;function syscalls.devfind(process,as,type)expect(1,type,"string")local f1={hardware.find(type)}for j,k in ipairs(f1)do f1[j]=hardware.path(k)end;return table.unpack(f1)end;function syscalls.devinfo(process,as,f2)expect(1,f2,"string")local dL=hardware.get(f2)if not dL then return nil end;local f3={}for B,k in ipairs(dL.drivers)do f3[k.type]=k.name end;return{id=dL.id,uuid=dL.uuid,alias=dL.alias,parent=dL.parent and hardware.path(dL.parent)or"/",displayName=dL.displayName,types=f3,metadata=deepcopy(dL.metadata)}end;function syscalls.devalias(process,as,f2,f4)expect(1,f2,"string")expect(2,f4,"string","nil")local dL=hardware.get(f2)if not dL then error("No such device",2)end;dL.alias=f4 end;function syscalls.devmethods(process,as,f2)expect(1,f2,"string")local dL=hardware.get(f2)if not dL then error("No such device",2)end;local f5={}for B,k in ipairs(dL.drivers)do for j in pairs(k.methods)do f5[#f5+1]=j end end;return f5 end;function syscalls.devproperties(process,as,f2)expect(1,f2,"string")local dL=hardware.get(f2)if not dL then error("No such device",2)end;local f6={}for B,k in ipairs(dL.drivers)do for B,j in pairs(k.properties)do f6[#f6+1]=j end end;return f6 end;function syscalls.devchildren(process,as,f2)expect(1,f2,"string")local dL=hardware.get(f2)if not dL then error("No such device",2)end;local f7={}for j in pairs(dL.children)do f7[#f7+1]=j end;return f7 end;function syscalls.devcall(process,as,f2,f0,...)expect(1,f2,"string")expect(2,f0,"string")local dL=hardware.get(f2)if not dL then error("No such device",2)end;if dL.process and dL.process~=process.id then error("Device is locked",2)end;return hardware.call(process,dL,f0,...)end;function syscalls.devlisten(process,as,f2,dq)expect(1,f2,"string")expect(2,dq,"boolean","nil")if dq==nil then dq=true end;local dL=hardware.get(f2)if not dL then error("No such device",2)end;if dq then for B,k in ipairs(dL.listeners)do if k==process then return end end;dL.listeners[process]=true;process.dependents[#process.dependents+1]={type="hardware listen",node=dL,gc=function()dL.listeners[process]=nil end}else dL.listeners[process]=nil;for x,k in ipairs(process.dependents)do if k.type=="hardware listen"and k.node==dL then table.remove(process.dependents,x)break end end end end;function syscalls.devlock(process,as,f2,f8)expect(1,f2,"string")expect(2,f8,"boolean","nil")if f8==nil then f8=true end;local dL=hardware.get(f2)if not dL then error("No such device",2)end;if dL.process==nil then dL.process=process.id;process.dependents[#process.dependents+1]={type="hardware lock",node=dL,gc=function()dL.process=nil end}return true elseif dL.process==process.id then return true elseif f8 then as.filter=function(process,as)return dL.process==nil or dL.process==process.id end;return kSyscallYield,"devlock",f2,true else return false end end;function syscalls.devunlock(process,as,f2)expect(1,f2,"string")local dL=hardware.get(f2)if not dL then error("No such device",2)end;if dL.process and dL.process~=process.id then error("Device is locked",2)end;dL.process=nil;for x,k in ipairs(process.dependents)do if k.type=="hardware lock"and k.node==dL then table.remove(process.dependents,x)break end end end;function syscalls.version(process,as,f9)if f9 then return PHOENIX_BUILD else return PHOENIX_VERSION end end;function syscalls.cchost(process,as)return _HOST end;function syscalls.uptime(process,as)return(os.epoch"utc"-systemStartTime)/1000 end;function syscalls.attach(process,as,fa,_type,...)if process.user~="root"then error("Permission denied")end;expect(1,fa,"string","number")expect(2,_type,"string")local bh,q;if periphemu then bh=periphemu.create(fa,_type,...)elseif ccemux then if type(fa)=="number"then fa=_type.."_"..fa end;if _type=="drive"then _type="disk_drive"elseif _type=="modem"then _type="wireless_modem"end;if _type=="computer"then local aC=tonumber(fa:match("%d+"))if aC then bh,q=pcall(ccemux.openEmu,aC)else bh,q=false,"Invalid side"end else bh,q=pcall(ccemux.attach,fa,_type,...)end else bh,q=false,"Operation not supported"end;return bh,q end;function syscalls.detach(process,as,fa)if process.user~="root"then error("Permission denied")end;expect(1,fa,"string","number")local bh,q;if periphemu then bh=periphemu.remove(fa)elseif ccemux then if type(fa)=="number"then fa=_type.."_"..fa end;bh,q=pcall(ccemux.detach,fa)else bh,q=false,"Operation not supported"end;return bh,q end;function syscalls.kernargs(process,as)return deepcopy(args)end;local fb=0;function syscalls.lockmutex(process,as,fc)expect(1,fc,"table")while fc.owner~=nil and fc.owner~=as.id or fc.pid~=nil and fc.pid~=process.id do coroutine.yield()end;if fc.owner then if type(fc.recursive)=="number"then fc.recursive=fc.recursive+1;return else error("cannot recursively lock mutex",0)end end;fc.owner=as.id;fc.pid=process.id;if fc.recursive then fc.recursive=1 end end;function syscalls.__timeout_check(process,as,b5)if b5.timeout then return false end;return syscalls[b5.call](process,as,b5.object,0)end;function syscalls.timelockmutex(process,as,fc,el)expect(1,fc,"table")expect(2,el,"number")if fc.owner then if fc.owner~=as.id then local fd=os.startTimer(el)local b5={object=fc,timeout=false,call="timelockmutex"}as.filter=function(process,as,at)if at[1]=="timer"and at[2].id==fd then b5.timeout=true;return true end;return fc.owner==nil or fc.owner==as.id end;return kSyscallYield,"__timeout_check",b5 elseif type(fc.recursive)=="number"then fc.recursive=fc.recursive+1 else error("cannot recursively lock mutex",0)end else fc.owner=as.id;if fc.recursive then fc.recursive=1 end end;return true end;function syscalls.unlockmutex(process,as,fc)expect(1,fc,"table")if fc.owner==as.id and fc.pid==process.id then if type(fc.recursive)=="number"then fc.recursive=fc.recursive-1;if fc.recursive<=0 then fc.owner=nil end else fc.owner,fc.pid=nil end elseif fc.owner==nil then error("mutex already unlocked",0)else error("mutex not locked by current thread")end end;function syscalls.trylockmutex(process,as,fc)expect(1,fc,"table")if fc.owner then if fc.owner~=as.id or fc.pid~=process.id then return false elseif type(fc.recursive)=="number"then fc.recursive=fc.recursive+1;return true else error("cannot recursively lock mutex",0)end else fc.owner=as.id;fc.pid=process.id;if fc.recursive then fc.recursive=1 end;return true end end;function syscalls.acquiresemaphore(process,as,fe)expect(1,fe,"table")expect.field(fe,"count","number")while fe.count<=0 do coroutine.yield()end;fe.count=fe.count-1 end;function syscalls.timeacquiresemaphore(process,as,fe,el)expect(1,fe,"table")expect.field(fe,"count","number")expect(2,el,"number")if fe.count<=0 then local fd=os.startTimer(el)local b5={object=fe,timeout=false,call="timeacquiresemaphore"}as.filter=function(process,as,at)if at[1]=="timer"and at[2].id==fd then b5.timeout=true;return true end;return type(fe.count)~="number"or fe.count>0 end;return kSyscallYield,"__timeout_check",b5 end;fe.count=fe.count-1;return true end;function syscalls.releasesemaphore(process,as,fe)expect(1,fe,"table")expect.field(fe,"count","number")fe.count=fe.count+1 end;local ff={name="root",type="computer",properties={"label","id"},methods={getLabel=function()end,setLabel=function(fg)end,getId=function()end,shutdown=function()end,reboot=function()end},init=function(dL)end,deinit=function(dL)end}local fh={top=true,bottom=true,left=true,right=true,front=true,back=true}local fi={}function getNodeById(o)if fh[o]then if deviceTreeRoot.children[o]then return deviceTreeRoot.children[o]end else for j in pairs(fh)do if peripheral.getType(j)=="modem"and not peripheral.call(j,"isWireless")and deviceTreeRoot.children[j]and deviceTreeRoot.children[j].children[o]then return deviceTreeRoot.children[j].children[o]end end end end;local function fj(self)self.internalState.peripheral=self.internalState.peripheral or{}if not self.internalState.peripheral.call then self.internalState.peripheral.call=peripheral.call end;if self.internalState.peripheral.call==peripheral.call or not self.parent then self.internalState.peripheral.getMethods=peripheral.getMethods else self.internalState.peripheral.getMethods=function(aC)return peripheral.call(self.parent.id,"getMethodsRemote",aC)end end end;local function fk(process,aD)aD.__metatable={}for B,k in pairs(aD)do setfenv(k,process.env)debug.protect(k)end;return setmetatable({},aD)end;local function fl(eY,type)return function(dL)local f3,i;if dL.parent==deviceTreeRoot then f3,i={peripheral.getType(dL.id)},peripheral.call else f3,i={peripheral.call(dL.parent.id,"getTypeRemote",dL.id)},function(...)return peripheral.call(dL.parent.id,"callRemote",...)end end;for B,k in ipairs(f3)do if k==type then dL.internalState.peripheral={call=i}return hardware.register(dL,eY)end end end end;local function fm(type)return hardware.listen(fl(fi["peripheral_"..type],type),deviceTreeRoot)end;local function fn(f0)return function(self)return self.internalState.peripheral.call(self.id,f0)end end;local function fo(f0)return function(self,process)if process.user~="root"then error("Permission denied",0)end;return self.internalState.peripheral.call(self.id,f0)end end;local function fp(f0)return function(...)local f3={...}return function(self,process,aH)expect(1,aH,table.unpack(f3))return self.internalState.peripheral.call(self.id,f0,aH)end end end;local function fq(f0)return function(...)local f3={...}return function(self,process,aH)expect(1,aH,table.unpack(f3))if process.user~="root"then error("Permission denied",0)end;return self.internalState.peripheral.call(self.id,f0,aH)end end end;local function fr()syslog.log("Sending SIGTERM to all processes")local ft=false;for c_,process in pairs(processes)do if c_~=0 then killProcess(c_,15)local fu,at=false,nil;local au=true;for fv,as in pairs(process.threads)do if not fu and as.status=="suspended"then at=table.remove(process.eventQueue,1)fu=true end;if at or as.status~="suspended"then au=executeThread(process,as,at or{n=0},au,true)else au=false end end;if au then process.isDead=true;if process.parent~=0 and processes[process.parent]then processes[process.parent].eventQueue[#processes[process.parent].eventQueue+1]={"process_complete",process.lastReturnValue}end;reap_process(process)processes[c_]=nil else ft=true end end end;terminal.redraw(currentTTY)if ft then syslog.log("Sending SIGKILL to all processes")for c_ in pairs(processes)do if c_~=0 then killProcess(c_,9)end end end end;fi.root={name="root",type="computer",properties={"isOn","label"},methods={}}function fi.root.methods:getIsOn(process)return true end;function fi.root.methods:getLabel(process)return os.getComputerLabel()end;function fi.root.methods:setLabel(process,fg)expect(1,fg,"string","nil")os.setComputerLabel(fg)end;function fi.root.methods:turnOn(process)end;function fi.root.methods:shutdown(process)if process.user~="root"then error("Permission denied",2)end;syslog.log("System is shutting down.")function postkill()hardware.deregister(deviceTreeRoot,fi.root)syslog.log("Halting system")for B,k in ipairs(shutdownHooks)do k()end;os.shutdown()mainThread=nil;while true do coroutine.yield()end end;fr()end;function fi.root.methods:reboot(process)if process.user~="root"then error("Permission denied",2)end;syslog.log("System is restarting.")function postkill()hardware.deregister(deviceTreeRoot,fi.root)syslog.log("Rebooting system")for B,k in ipairs(shutdownHooks)do k()end;os.reboot()mainThread=nil;while true do coroutine.yield()end end;fr()end;function fi.root:init()local fw=hardware.add(self,"redstone")for B,k in ipairs{"top","bottom","left","right","front","back"}do local br=hardware.add(fw,k)br.internalState.redstone={side=k}hardware.register(br,fi.root_redstone)end;hardware.register(hardware.add(deviceTreeRoot,"lo"),fi.loopback_modem)registerLoopback()for k in pairs(fh)do if peripheral.isPresent(k)then hardware.add(self,k)end end;self.displayName=os.getComputerLabel()self.metadata.id=os.getComputerID()end;function fi.root:deinit()for k in pairs(fh)do if peripheral.isPresent(k)and self.children[k]then hardware.remove(self.children[k])end end;hardware.remove(hardware.get("/lo"))hardware.remove(hardware.get("/redstone"))end;eventHooks.peripheral=eventHooks.peripheral or{}eventHooks.peripheral[#eventHooks.peripheral+1]=function(at)if fh[at[2]]then local dL,q=hardware.add(deviceTreeRoot,at[2])if dL then hardware.broadcast(deviceTreeRoot,"device_added",{device=hardware.path(dL)})else syslog.log({level="error",module="Hardware"},"Could not create new device: "..q)end else for j in pairs(fh)do if peripheral.getType(j)=="modem"and not peripheral.call(j,"isWireless")and peripheral.call(j,"isPresentRemote",at[2])then if not deviceTreeRoot.children[j]then hardware.add(deviceTreeRoot,j)end;local dL,q=hardware.add(deviceTreeRoot.children[j],at[2])if dL then hardware.broadcast(deviceTreeRoot.children[j],"device_added",{device=hardware.path(dL)})else syslog.log({level="error",module="Hardware"},"Could not create new device: "..q)end;break end end end end;eventHooks.peripheral_detach=eventHooks.peripheral_detach or{}eventHooks.peripheral_detach[#eventHooks.peripheral_detach+1]=function(at)local dL=getNodeById(at[2])if not dL then syslog.log({level="notice",module="Hardware"},"Received "..at[1].." event for device ID "..at[2]..", but no device node was found; ignoring")return end;local g,c2=hardware.path(dL),dL.parent;hardware.remove(dL)hardware.broadcast(c2,"device_removed",{device=g})end;rootDriver=fi.root;fi.root_redstone={name="root_redstone",type="redstone",properties={"input","output","bundledInput","bundledOutput"},methods={}}local function fx(t)if t==0 then return nil else return t end end;function fi.root_redstone.methods:getInput()return fx(redstone.getAnalogInput(self.internalState.redstone.side))end;function fi.root_redstone.methods:getOutput()return fx(redstone.getAnalogOutput(self.internalState.redstone.side))end;function fi.root_redstone.methods:setOutput(process,t)t=expect(1,t,"number","boolean","nil")or 0;if t==false then t=0 elseif t==true then t=15 end;expect.range(t,0,15)redstone.setAnalogOutput(self.internalState.redstone.side,t)end;function fi.root_redstone.methods:getBundledInput()return redstone.getBundledInput(self.internalState.redstone.side)end;function fi.root_redstone.methods:getBundledOutput()return redstone.getBundledOutput(self.internalState.redstone.side)end;function fi.root_redstone.methods:setBundledOutput(process,t)expect(1,t,"number")expect.range(t,0,65535)redstone.setBundledOutput(self.internalState.redstone.side,t)end;function fi.root_redstone:init()if not self.internalState.redstone or not self.internalState.redstone.side then error("No assigned side on redstone device!",2)end;self.displayName="Redstone I/O on side "..self.internalState.redstone.side end;fi.peripheral_command={name="peripheral_command",type="command",properties={"command"},methods={}}fi.peripheral_command.methods.getCommand=fo"getCommand"fi.peripheral_command.methods.setCommand=fq"setCommand"("string")fi.peripheral_command.methods.run=fo"runCommand"function fi.peripheral_command:init()fj(self)self.displayName="Command block at "..self.id end;fm"command"fi.peripheral_computer={name="peripheral_computer",type="computer",properties={"isOn","label"},methods={}}fi.peripheral_computer.methods.getIsOn=fn"isOn"fi.peripheral_computer.methods.getLabel=fn"getLabel"fi.peripheral_computer.methods.turnOn=fo"turnOn"fi.peripheral_computer.methods.shutdown=fo"shutdown"fi.peripheral_computer.methods.reboot=fo"reboot"function fi.peripheral_command:init()fj(self)local fg=self.internalState.peripheral.call(self.id,"getLabel")self.metadata.id=self.internalState.peripheral.call(self.id,"getID")self.displayName=(fg or"Computer "..self.metadata.id).." at "..self.id end;fm"computer"hardware.listen(fl(fi["peripheral_computer"],"turtle"),deviceTreeRoot)fi.peripheral_drive={name="peripheral_drive",type="drive",properties={"state","label"},methods={}}function fi.peripheral_drive.methods:getState(process)if not self.internalState.peripheral.call(self.id,"isDiskPresent")then return nil end;return{audio=self.internalState.peripheral.call(self.id,"getAudioTitle")or nil,label=self.internalState.peripheral.call(self.id,"getDiskLabel"),id=self.internalState.peripheral.call(self.id,"getDiskID")}end;fi.peripheral_drive.methods.getLabel=fn"getDiskLabel"fi.peripheral_drive.methods.setLabel=fp"setDiskLabel"("string","nil")fi.peripheral_drive.methods.getMountPath=fn"getMountPath"function fi.peripheral_drive.methods:play(process)if not self.internalState.peripheral.call(self.id,"hasAudio")then error("Inserted disk is not an audio disc",2)end;return self.internalState.peripheral.call(self.id,"playAudio")end;fi.peripheral_drive.methods.stop=fn"stopAudio"fi.peripheral_drive.methods.eject=fn"ejectDisk"fi.peripheral_drive.methods.insert=fq"insertDisk"("string")function fi.peripheral_drive:init()fj(self)self.displayName=(self.internalState.peripheral.call(self.id,"getDiskLabel")or"No disk").." on drive "..self.id end;fm"drive"eventHooks.disk=eventHooks.disk or{}eventHooks.disk[#eventHooks.disk+1]=function(at)local dL=getNodeById(at[2])if not dL then syslog.log({level="notice",module="Hardware"},"Received "..at[1].." event for device ID "..at[2]..", but no device node was found; ignoring")return end;hardware.broadcast(dL,"disk",{device=hardware.path(dL)})end;eventHooks.disk_eject=eventHooks.disk_eject or{}eventHooks.disk_eject[#eventHooks.disk_eject+1]=function(at)local dL=getNodeById(at[2])if not dL then syslog.log({level="notice",module="Hardware"},"Received "..at[1].." event for device ID "..at[2]..", but no device node was found; ignoring")return end;hardware.broadcast(dL,"disk_eject",{device=hardware.path(dL)})end;fi.peripheral_energy_storage={name="peripheral_energy_storage",type="energy_storage",properties={"energy"},methods={}}fi.peripheral_energy_storage.methods.getEnergy=fn"getEnergy"function fi.peripheral_energy_storage:init()fj(self)self.displayName="Energy storage block at "..self.id;self.metadata.capacity=self.internalState.peripheral.call(self.id,"getEnergyCapacity")end;fm"energy_storage"fi.peripheral_fluid_storage={name="peripheral_fluid_storage",type="fluid_storage",properties={"tanks"},methods={}}fi.peripheral_fluid_storage.methods.getTanks=fn"tanks"function fi.peripheral_fluid_storage.methods:push(process,bU,fy,o)expect(1,bU,"string")expect(2,fy,"number","nil")expect(3,o,"string","nil")local ej;local fz={hardware.get(bU)}if#fz==1 then ej=fz[1]else for B,k in ipairs(fz)do if k.parent==self.parent then ej=k;break end end end;if not ej then error("No such device",0)elseif ej.parent~=self.parent then error("Devices must be on the same network",0)end;local bh=false;for B,k in ipairs(ej.drivers)do if k==fi.peripheral_fluid_storage then bh=true;break end end;if not bh then error("Target device is not a fluid storage block",0)end;return self.internalState.peripheral.call(self.id,"pushFluid",ej.id,fy,o)end;function fi.peripheral_fluid_storage.methods:pull(process,bT,fy,o)expect(1,bT,"string")expect(2,fy,"number","nil")expect(3,o,"string","nil")local ej;local fz={hardware.get(bT)}if#fz==1 then ej=fz[1]else for B,k in ipairs(fz)do if k.parent==self.parent then ej=k;break end end end;if not ej then error("No such device",0)elseif ej.parent~=self.parent then error("Devices must be on the same network",0)end;local bh=false;for B,k in ipairs(ej.drivers)do if k==fi.peripheral_fluid_storage then bh=true;break end end;if not bh then error("Target device is not a fluid storage block",0)end;return self.internalState.peripheral.call(self.id,"pullFluid",ej.id,fy,o)end;function fi.peripheral_fluid_storage:init()fj(self)self.displayName="Fluid storage block at "..self.id end;fm"fluid_storage"fi.peripheral_inventory={name="peripheral_inventory",type="inventory",properties={"items"},methods={}}fi.peripheral_inventory.methods.getItems=fn"list"fi.peripheral_inventory.methods.detail=fp"getItemDetail"("number")fi.peripheral_inventory.methods.limit=fp"getItemLimit"("number")function fi.peripheral_inventory.methods:push(process,bU,fA,fy,fB)expect(1,bU,"string")expect(2,fA,"number")expect(3,fy,"number","nil")expect(4,fB,"number","nil")local ej;local fz={hardware.get(bU)}if#fz==1 then ej=fz[1]else for B,k in ipairs(fz)do if k.parent==self.parent then ej=k;break end end end;if not ej then error("No such device",0)elseif ej.parent~=self.parent then error("Devices must be on the same network",0)end;local bh=false;for B,k in ipairs(ej.drivers)do if k==fi.peripheral_inventory then bh=true;break end end;if not bh then error("Target device is not an inventory block",0)end;return self.internalState.peripheral.call(self.id,"pushItems",ej.id,fA,fy,fB)end;function fi.peripheral_inventory.methods:pull(process,bT,fA,fy,fB)expect(1,bT,"string")expect(2,fA,"number")expect(3,fy,"number","nil")expect(4,fB,"number","nil")local ej;local fz={hardware.get(bT)}if#fz==1 then ej=fz[1]else for B,k in ipairs(fz)do if k.parent==self.parent then ej=k;break end end end;if not ej then error("No such device",0)elseif ej.parent~=self.parent then error("Devices must be on the same network",0)end;local bh=false;for B,k in ipairs(ej.drivers)do if k==fi.peripheral_inventory then bh=true;break end end;if not bh then error("Target device is not an inventory block",0)end;return self.internalState.peripheral.call(self.id,"pullItems",ej.id,fA,fy,fB)end;function fi.peripheral_inventory:init()fj(self)self.displayName="Inventory at "..self.id;self.metadata.size=self.internalState.peripheral.call(self.id,"size")end;fm"inventory"fi.peripheral_monitor={name="peripheral_monitor",type="monitor",properties={"scale","size"},methods={}}fi.peripheral_monitor.methods.getScale=fn"getTextScale"fi.peripheral_monitor.methods.setScale=fp"setTextScale"("number")function fi.peripheral_monitor.methods:getSize()local ah,ai=self.internalState.peripheral.call(self.id,"getSize")return{width=ah,height=ai}end;function fi.peripheral_monitor.methods:write(process,...)for x,k in ipairs{...}do if x>1 then terminal.write(self.internalState.tty,"\t")end;terminal.write(self.internalState.tty,k)end;terminal.redraw(self.internalState.tty)end;function fi.peripheral_monitor.methods:termctl(process,dt)expect(1,dt,"table","nil")if dt then expect.field(dt,"cbreak","boolean","nil")expect.field(dt,"delay","boolean","nil")expect.field(dt,"echo","boolean","nil")expect.field(dt,"keypad","boolean","nil")expect.field(dt,"nlcr","boolean","nil")expect.field(dt,"raw","boolean","nil")for j,k in pairs(dt)do if self.internalState.tty.flags[j]~=nil then self.internalState.tty.flags[j]=k end end end;local A=deepcopy(self.internalState.tty.flags)A.hasgfx=term.getGraphicsMode~=nil;return A end;function fi.peripheral_monitor.methods:openterm(process)return terminal.openterm(self.internalState.tty,process)end;function fi.peripheral_monitor.methods:opengfx(process)return terminal.opengfx(self.internalState.tty,process)end;function fi.peripheral_monitor:init()fj(self)local ah,ai=self.internalState.peripheral.call(self.id,"getSize")local fC=self.internalState.peripheral.call(self.id,"getTextScale")self.displayName=ah*fC.."x"..ai*fC.." monitor at "..self.id;local term={}for B,k in ipairs(self.internalState.peripheral.getMethods(self.id))do term[k]=function(...)return self.internalState.peripheral.call(self.id,k,...)end end;self.internalState.tty=terminal.makeTTY(term,ah,ai)self.internalState.tty.isMonitor=true;terminal.redraw(self.internalState.tty,true)end;function fi.peripheral_monitor:deinit()local de=self.internalState.tty;if de.frontmostProcess then local k=de.frontmostProcess;if k.stdin==de then k.stdin=nil end;if k.stdout==de then k.stdout=nil end;if k.stderr==de then k.stderr=nil end end;for B,k in ipairs(de.processList)do if k.stdin==de then k.stdin=nil end;if k.stdout==de then k.stdout=nil end;if k.stderr==de then k.stderr=nil end end end;fm"monitor"eventHooks.monitor_resize=eventHooks.monitor_resize or{}eventHooks.monitor_resize[#eventHooks.monitor_resize+1]=function(at)local dL=getNodeById(at[2])if not dL then syslog.log({level="notice",module="Hardware"},"Received "..at[1].." event for device ID "..at[2]..", but no device node was found; ignoring")return end;local U=fi.peripheral_monitor.methods.getSize(dL)terminal.resize(dL.internalState.tty,U.width,U.height)hardware.broadcast(dL,"monitor_resize",{device=hardware.path(dL),width=U.width,height=U.height})end;fi.peripheral_printer={name="peripheral_printer",type="printer",properties={"inkLevel","paperLevel"},methods={}}fi.peripheral_printer.methods.getInkLevel=fn"getInkLevel"fi.peripheral_printer.methods.getPaperLevel=fn"getPaperLevel"function fi.peripheral_printer.methods:page(process)if self.internalState.printer.open then self.internalState.peripheral.call(self.id,"endPage")self.internalState.printer.open=false end;if not self.internalState.peripheral.call(self.id,"newPage")then return nil end;self.internalState.printer.open=true;local fD,r,s;local function ds(...)if not self.internalState.printer.open then error("attempt to use closed page",2)end;return self.internalState.peripheral.call(self.id,"write",...)end;local function fE()if not self.internalState.printer.open then return true end;if not self.internalState.peripheral.call(self.id,"endPage")then return false end;self.internalState.printer.open=false end;setfenv(ds,process.env)setfenv(fE,process.env)debug.protect(ds)debug.protect(fE)return fk(process,{__index=function(B,aE)if not self.internalState.printer.open then error("attempt to use closed page",2)end;if aE=="size"then local v,da=self.internalState.peripheral.call(self.id,"getPageSize")return fk(process,{__index=function(B,aE)if aE=="width"then return v elseif aE=="height"then return da end end,__newindex=function()error("Cannot modify read-only table",2)end})elseif aE=="cursor"then r,s=self.internalState.peripheral.call(self.id,"getCursorPos")return fk(process,{__index=function(B,aE)if aE=="x"then return r elseif aE=="y"then return s end end,__newindex=function(B,aE,aF)if aE=="x"then r=aF;self.internalState.peripheral.call(self.id,"setCursorPos",r,s)elseif aE=="y"then s=aF;self.internalState.peripheral.call(self.id,"setCursorPos",r,s)else error("Cannot modify member '"..aE.."'",2)end end})elseif aE=="title"then return fD elseif aE=="isOpen"then return self.internalState.printer.open elseif aE=="write"then return ds elseif aE=="close"then return fE end end,__newindex=function(B,aE,aF)if not self.internalState.printer.open then error("attempt to use closed page",2)end;if aE=="cursor"then if type(aF)~="table"then error("bad value for 'cursor' (expected table, got "..type(aF)..")",2)end;expect.field(aF,"x","number")expect.field(aF,"y","number")r,s=aF.x,aF.y;self.internalState.peripheral.call(self.id,"setCursorPos",r,s)elseif aE=="title"then if type(aF)~="string"and aF~=nil then error("bad value for 'title' (expected string, got "..type(aF)..")",2)end;fD=aF;self.internalState.peripheral.call(self.id,"setPageTitle",fD)else error("Cannot modify member '"..aE.."'",2)end end})end;function fi.peripheral_printer:init()fj(self)self.displayName="Speaker at "..self.id;self.internalState.printer={open=false}end;fm"printer"fi.peripheral_speaker={name="peripheral_speaker",type="speaker",properties={},methods={}}function fi.peripheral_speaker.methods:playNote(process,fF,fG,fH)expect(1,fF,"string")expect(2,fG,"number","nil")expect(3,fH,"number","nil")if fG then expect.range(fG,0,3)end;if fH then expect.range(fH,0,24)end;return self.internalState.peripheral.call(self.id,"playNote",fF,fG,fH)end;function fi.peripheral_speaker.methods:playSound(process,o,fG,fI)expect(1,o,"string")expect(2,fG,"number","nil")expect(3,fI,"number","nil")if fG then expect.range(fG,0,3)end;if fI then expect.range(fI,0.5,2.0)end;return self.internalState.peripheral.call(self.id,"playNote",o,fG,fI)end;function fi.peripheral_speaker.methods:playAudio(fJ,fG)expect(1,fJ,"table")expect(2,fG,"number","nil")if fG then expect.range(fG,0,3)end;return self.internalState.peripheral.call(self.id,"playAudio",fJ,fG)end;fi.peripheral_speaker.methods.stop=fn"stop"function fi.peripheral_speaker:init()fj(self)self.displayName="Speaker at "..self.id end;fm"speaker"eventHooks.speaker_audio_empty=eventHooks.speaker_audio_empty or{}eventHooks.speaker_audio_empty[#eventHooks.speaker_audio_empty+1]=function(at)local dL=getNodeById(at[2])if not dL then syslog.log({level="notice",module="Hardware"},"Received "..at[1].." event for device ID "..at[2]..", but no device node was found; ignoring")return end;hardware.broadcast(dL,"speaker_audio_empty",{device=hardware.path(dL)})end;local fK={fi.peripheral_command,fi.peripheral_computer,fi.peripheral_drive,fi.peripheral_energy_storage,fi.peripheral_fluid_storage,fi.peripheral_inventory,fi.peripheral_monitor,fi.peripheral_printer,fi.peripheral_speaker}function registerDriver(eY)local fL=eY.init;eY.init=function(dL)fj(dL)if fL then return fL(dL)end end;eY.__callback=fl(eY,eY.type)hardware.listen(eY.__callback,deviceTreeRoot)fK[#fK+1]=eY;for B,dL in ipairs(hardware.find("modem"))do if not dL.metadata.wireless then hardware.listen(eY.__callback,dL)dL.internalState.modem.callbacks[#dL.internalState.modem.callbacks+1]=f end end end;function deregisterDriver(eY)if not eY.__callback then return end;hardware.unlisten(eY.__callback)for B,k in ipairs(hardware.find(eY.type))do hardware.deregister(k,eY)end;for x,k in ipairs(fh)do if k==eY then table.remove(fh,x)break end end;for B,dL in ipairs(hardware.find("modem"))do if not dL.metadata.wireless then hardware.unlisten(eY.__callback)for x,k in ipairs(dL.internalState.modem.callbacks)do if k==eY.__callback then table.remove(dL.internalState.modem.callbacks,x)break end end end end end;fi.peripheral_modem={name="peripheral_modem",type="modem",properties={"remainingChannels"},methods={}}function fi.peripheral_modem.methods:getRemainingChannels()local b=128;for B in pairs(self.internalState.modem)do b=b-1 end;return b end;function fi.peripheral_modem.methods:open(process,fM)if not self.internalState.modem[fM]then self.internalState.peripheral.call(self.id,"open",fM)self.internalState.modem[fM]={}end;self.internalState.modem[fM][process]=true end;function fi.peripheral_modem.methods:isOpen(process,fM)return self.internalState.modem[fM]and self.internalState.modem[fM][process]end;function fi.peripheral_modem.methods:close(process,fM)self.internalState.modem[fM][process]=nil;if not next(self.internalState.modem[fM])then self.internalState.peripheral.call(self.id,"close",fM)self.internalState.modem[fM]=nil end end;function fi.peripheral_modem.methods:closeAll(process)for fM=0,65535 do self.internalState.modem[fM][process]=nil;if not next(self.internalState.modem[fM])then self.internalState.peripheral.call(self.id,"close",fM)self.internalState.modem[fM]=nil end end end;function fi.peripheral_modem.methods:transmit(process,fM,fN,fO)expect(1,fM,"number")fN=expect(2,fN,"number","nil")or fM;return self.internalState.peripheral.call(self.id,"transmit",fM,fN,fO)end;function fi.peripheral_modem:init()fj(self)self.metadata.wireless=self.internalState.peripheral.call(self.id,"isWireless")self.displayName=(self.metadata.wireless and"Wireless"or"Wired").." modem at "..self.id;self.internalState.modem={}self.internalState.modem.channels={}self.internalState.peripheral.call(self.id,"closeAll")if not self.metadata.wireless then self.internalState.modem.callbacks={}for B,k in ipairs(fK)do local f=fl(k,k.type)hardware.listen(f,self)self.internalState.modem.callbacks[#self.internalState.modem.callbacks+1]=f end;local f=fl(fi["peripheral_computer"],"turtle")hardware.listen(f,self)self.internalState.modem.callbacks[#self.internalState.modem.callbacks+1]=f;for B,o in ipairs(self.internalState.peripheral.call(self.id,"getNamesRemote"))do hardware.add(self,o)end end end;function fi.peripheral_modem:deinit()if not self.metadata.wireless then for B,k in ipairs(self.internalState.modem.callbacks)do hardware.unlisten(k)end end end;fm"modem"eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(at)local dL=getNodeById(at[2])or hardware.get(at[2])if not dL then syslog.log({level="notice",module="Hardware"},"Received "..at[1].." event for device ID "..at[2]..", but no device node was found; ignoring")return end;local a7=false;for k in pairs(dL.listeners)do if(dL.internalState.modem[at[3]]or{})[k]then k.eventQueue[#k.eventQueue+1],a7={"modem_message",{device=hardware.path(dL),channel=at[3],replyChannel=at[4],message=at[5],distance=at[6]}},true end end;return a7 end;fi.loopback_modem={name="loopback_modem",type="modem",properties={"remainingChannels"},methods={}}function fi.loopback_modem.methods:getRemainingChannels()local b=128;for B in pairs(self.internalState.modem)do b=b-1 end;return b end;function fi.loopback_modem.methods:open(process,fM)if not self.internalState.modem[fM]then self.internalState.modem[fM]={}end;self.internalState.modem[fM][process]=true end;function fi.loopback_modem.methods:isOpen(process,fM)return self.internalState.modem[fM]and self.internalState.modem[fM][process]end;function fi.loopback_modem.methods:close(process,fM)self.internalState.modem[fM][process]=nil;if not next(self.internalState.modem[fM])then self.internalState.modem[fM]=nil end end;function fi.loopback_modem.methods:closeAll(process)for fM=0,65535 do self.internalState.modem[fM][process]=nil;if not next(self.internalState.modem[fM])then self.internalState.modem[fM]=nil end end end;function fi.loopback_modem.methods:transmit(process,fM,fN,fO)expect(1,fM,"number")fN=expect(2,fN,"number","nil")or fM;os.queueEvent("modem_message",self.uuid,fM,fN,fO,0)end;function fi.loopback_modem:init()self.metadata.wireless=true;self.displayName="Loopback modem"self.internalState.modem={}self.internalState.modem.channels={}end;local function fP(fQ)local b5={scheme=""}for ab in fQ:gmatch"."do if b5.fragment then if ab:match"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/?]"then b5.fragment=b5.fragment..ab else error("Invalid URI",3)end elseif b5.query then if ab=="#"then b5.fragment=""elseif ab:match"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/?]"then b5.query=b5.query..ab else error("Invalid URI",3)end elseif b5.path then if ab=="/"and b5.path=="/"and not b5.host then b5.path,b5.host=nil,""elseif ab=="?"then b5.query=""elseif ab=="#"then b5.fragment=""elseif ab:match"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/]"then b5.path=b5.path..ab else error("Invalid URI",3)end elseif b5.port then if tonumber(ab)then b5.port=b5.port..ab elseif ab=="/"then b5.path="/"else error("Invalid URI",3)end elseif b5.host then if ab=="@"and not b5.user then b5.user,b5.host=b5.host,""elseif ab==":"then b5.port=""elseif ab=="/"then b5.path="/"elseif ab:match"[%w%-%._~%%/!%$&'%(%)%*%+,;=]"then b5.host=b5.host..ab else error("Invalid URI",3)end else if ab==":"then b5.path=""elseif ab:match(b5.scheme==""and"[%a%+%-%.]"or"[%w%+%-%.]")then b5.scheme=b5.scheme..ab else error("Invalid URI",3)end end end;if b5.port then b5.port=tonumber(b5.port)end;return b5 end;local function fR(fS)if fS:match"^%d+$"then return tonumber(fS)elseif fS:match"^%d+%.%d+$"then return tonumber(fS:match"^%d+")*0x1000000+tonumber(fS:match"^%d+%.(%d+)")elseif fS:match"^%d+%.%d+%.%d+$"then return tonumber(fS:match"^(%d+)")*0x1000000+tonumber(fS:match"^%d+%.(%d+)")*0x10000+tonumber(fS:match"^%d+%.%d+%.(%d+)")elseif fS:match"^%d+%.%d+%.%d+%.%d+$"then return tonumber(fS:match"^(%d+)")*0x1000000+tonumber(fS:match"^%d+%.(%d+)")*0x10000+tonumber(fS:match"^%d+%.%d+%.(%d+)")*0x100+tonumber(fS:match"^%d+%.%d+%.%d+%.(%d+)")else error("Invalid IP address",2)end end;local function fT(b)if not b then return nil end;return("%d.%d.%d.%d"):format(bit32.band(bit32.rshift(b,24),0xFF),bit32.band(bit32.rshift(b,16),0xFF),bit32.band(bit32.rshift(b,8),0xFF),bit32.band(b,0xFF))end;local function fU(fV)local bt=""for x=1,fV do bt=bt..string.char(math.random(0,255))end;return bt end;local function fW(b)return bit32.bnot(2^(32-b)-1)end;local function fX(y)local t=0;while bit32.btest(y,0x80000000)do y,t=bit32.lshift(y,1),t+1 end;return t end;local function fY(dL)if not dL then error("No such device")end;for B,k in pairs(dL.drivers)do if k.type=="modem"then return dL end end;error("Not a modem")end;local fZ=0;local f_={}local g0={maxn=0,[0]={}}local g1={}local g2={send={},recv={}}local g3={}local g4={}local g5=setmetatable({},{__mode="k"})local g6={arp={},socket={}}local g7={}function g2.send.link(b5,g8,ag)expect(2,g8,"number","nil")expect.field(b5,"device","table")local bB={PhoenixNetworking=true,type="link",source=os.computerID(),destination=g8,payload=ag}if g8==os.computerID()then os.queueEvent("modem_message",b5.device.id,b5.outPort or 0,b5.inPort or 0,bB,0)else hardware.call(b5.process or KERNEL,b5.device,"transmit",b5.outPort or 0,b5.inPort or 0,bB)end end;function g2.send.arp_request(b5,fS)expect.field(b5,"device","table")expect(2,fS,"string")hardware.call(b5.process or KERNEL,b5.device,"transmit",0,0,{PhoenixNetworking=true,type="arp",reply=false,source=os.computerID(),sourceIP=f_[b5.device.uuid]and fT(f_[b5.device.uuid].ip),destinationIP=fS})end;function g2.send.arp_reply(b5,g8,g9)expect.field(b5,"device","table")expect(2,g8,"number")expect(3,g9,"string","nil")hardware.call(b5.process or KERNEL,b5.device,"transmit",0,0,{PhoenixNetworking=true,type="arp",reply=true,source=os.computerID(),sourceIP=fT(f_[b5.device.uuid].ip),destination=g8,destinationIP=g9})end;function g2.send.internet(b5,g8,ag)expect(2,g8,"number")local ed={PhoenixNetworking=true,type="internet",hopsLeft=15,payload=ag,destination=fT(g8)}local aC=fU(32)ed.messageID=aC;local k;for x=g0.maxn,0,-1 do if g0[x]then for B,ga in ipairs(g0[x])do if bit32.band(ga.source,ga.sourceNetmask)==bit32.band(g8,ga.sourceNetmask)and(not k or fX(ga.sourceNetmask)>fX(k.sourceNetmask))then k=ga end end end end;if not k then return g2.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="No route to host",payload=ed})end;if k.action=="unicast"and f_[k.device.uuid]and f_[k.device.uuid].up then b5.device=k.device;ed.source=fT(f_[k.device.uuid].ip)if g1[k.device.uuid]and g1[k.device.uuid][k.destination]then return g2.send.link(b5,g1[k.device.uuid][k.destination],ed)end;local gb=false;local fd;local function gc(B,fS,bF)if not gb and fR(fS)==k.destination then gb=true;g2.send.link(b5,bF,ed)end;if gb then for x,f in ipairs(g6.arp)do if f==gc then table.remove(g6.arp,x)break end end end end;local function gd(at)if at[2]==fd then if not gb then g2.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="No route to host",payload=ed})end;gb=true;for x,k in ipairs(eventHooks.timer)do if k==gd then table.remove(eventHooks.timer,x)break end end;for x,f in ipairs(g6.arp)do if f==gc then table.remove(g6.arp,x)break end end end end;g6.arp[#g6.arp+1]=gc;g2.send.arp_request(b5,fT(k.destination))eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=gd;fd=os.startTimer(2)return elseif k.action=="broadcast"and f_[k.device.uuid]and f_[k.device.uuid].up then b5.device=k.device;ed.source=fT(f_[k.device.uuid].ip)return g2.send.link(b5,nil,ed)elseif k.action=="local"and f_[k.device.uuid]and f_[k.device.uuid].up then b5.device=k.device;ed.source=fT(f_[k.device.uuid].ip)if g1[k.device.uuid]and g1[k.device.uuid][g8]then return g2.send.link(b5,g1[k.device.uuid][g8],ed)end;local gb=false;local fd;local function gc(B,fS,bF)if not gb and fR(fS)==g8 then gb=true;g2.send.link(b5,bF,ed)end;if gb then for x,f in ipairs(g6.arp)do if f==gc then table.remove(g6.arp,x)break end end end end;local function gd(at)if at[2]==fd then if not gb then g2.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="No route to host",payload=ed})end;gb=true;for x,k in ipairs(eventHooks.timer)do if k==gd then table.remove(eventHooks.timer,x)break end end end end;g6.arp[#g6.arp+1]=gc;g2.send.arp_request(b5,fT(g8))eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=gd;fd=os.startTimer(2)return elseif k.action=="unreachable"then return g2.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="Destination unreachable",payload=ed})elseif k.action=="prohibit"then return g2.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="Prohibited",payload=ed})elseif k.action=="blackhole"then return end end;function g2.send.control(b5,g8,type,q,ge)expect(3,type,"string")expect(4,q,"string","nil")return g2.send.internet(b5,g8,{PhoenixNetworking=true,type="control",messageType=type,error=q,payload=ge})end;g2.send.socket={}function g2.send.socket.connect(b5,fS,gf,gg)for x=1,16384 do local G=math.random(49152,65535)if not g3[G]or not g3[G][gf]then gg.localPort=G;break end end;if not gg.localPort then error("Too many open sockets")end;gg.id=fZ;fZ=fZ+1;gg.ip=fS;gg.port=gf;gg.sendSeq=math.floor(math.random()*0x10000000000)gg.sendSeqNext=gg.sendSeq+2;gg.sendSeqMax=gg.sendSeq+256;b5.outPort=gf;b5.inPort=gg.localPort;g5[gg]=function(G)if G.type=="control"and G.payload.destination==fT(fS)then gg.status="error"gg.error=G.error;return true end;return false end;g2.send.internet(b5,fS,{PhoenixNetworking=true,type="socket",sequence=gg.sendSeqNext-1,windowSize=256,synchronize=true})local bh,q=pcall(hardware.call,b5.process or KERNEL,b5.device,"open",gg.localPort)if not bh then g2.send.internet(b5,fS,{PhoenixNetworking=true,type="socket",sequence=gg.sendSeqNext,windowSize=0,reset=true})gg.status="error"gg.error=q;return false end;gg.status="syn-sent"gg.nextUpdate=os.epoch"utc"+5000;gg.process=b5.process;gg.retryCount=0;g3[gg.localPort]=g3[gg.localPort]or{}g3[gg.localPort][gf]=gg;g4[gg.id]=gg end;function g2.send.socket.data(b5,ag,gg)b5.outPort=gg.port;b5.inPort=gg.localPort;ag.PhoenixNetworking=true;ag.type="socket"if not ag.sequence then ag.sequence=gg.sendSeqNext;gg.sendSeqNext=gg.sendSeqNext+1 end;ag.acknowledgement=ag.acknowledgement or gg.recvSeq-1;gg.nextAck=nil;if not ag.final then ag.windowSize=256 end;return g2.send.internet(b5,gg.ip,ag)end;function g2.send.socket.ack(b5,b,gg)return g2.send.socket.data(b5,{acknowledgement=b},gg)end;function g2.send.socket.reset(b5,fS,gf,gh,gi,gj)b5.outPort=gf;b5.inPort=gj or gf;return g2.send.internet(b5,fS,{PhoenixNetworking=true,type="socket",sequence=gh,acknowledgement=gi,reset=true})end;local function gk(gg,p,...)p=p or"*l"if type(p)~="string"and type(p)~="number"then error("bad argument (expected string or number, got "..type(p)..")",2)end;if gg.buffer==""then return nil end;p=p:gsub("^%*","")if p=="a"then local a2=gg.buffer;gg.buffer=""return a2 elseif p=="l"then local a2,a9=gg.buffer:match"^([^\n]*)\n?()"if a2 then gg.buffer=gg.buffer:sub(a9)if select("#",...)>0 then return a2,gk(gg,...)else return a2 end else return nil end elseif p=="L"then local a2,a9=gg.buffer:match"^([^\n]*\n?)()"if a2 then gg.buffer=gg.buffer:sub(a9)if select("#",...)>0 then return a2,gk(gg,...)else return a2 end else return nil end elseif p=="n"then local a2,a9=gg.buffer:match"(%d+)()"if a2 then gg.buffer=gg.buffer:sub(a9)if select("#",...)>0 then return tonumber(a2),gk(gg,...)else return tonumber(a2)end else return nil end elseif type(p)=="number"then local a2=gg.buffer:sub(1,p)gg.buffer=gg.buffer:sub(p+1)if select("#",...)>0 then return a2,gk(gg,...)else return a2 end else error("bad argument (invalid mode '"..p.."')",2)end end;local function gl(gg,bk,...)bk=tostring(bk)gg.outQueue[gg.sendSeqNext]=bk;g2.send.socket.data({},{payload=bk},gg)if select("#",...)>0 then return gl(gg,...)end end;function syscalls.__socketcall(process,as,aC,f0,...)local gg=g4[aC]if not gg then error("No such socket")end;local gm=process;while process~=gg.process do if process==nil then error("No such socket")end;process=processes[process.parent or-1]end;if f0=="close"then gg.sendSeqMax=gg.sendSeqNext;g2.send.socket.data({},{final=true},gg)gg.status="fin-wait"elseif f0=="read"then return gk(gg,...)elseif f0=="write"then return gl(gg,...)elseif f0=="transfer"then gg.process=gm else error("No such method")end end;local do_syscall=do_syscall;local function gn(gg)local bB=setmetatable({id=gg.id},{__name="socket"})function bB:localIP()return gg.localIP end;function bB:status()if gg.status=="listening"or gg.status=="syn-sent"or gg.status=="syn-received"then return"connecting"elseif gg.status=="connected"or gg.buffer~=""then return"open"elseif gg.status=="error"then return"error",gg.error else return"closed"end end;function bB:read(p,...)if gg.status~="connected"and gg.status~="close-wait"and gg.status~="closed"then error("attempt to read from a "..gg.status.." handle",2)end;return do_syscall("__socketcall",gg.id,"read",p,...)end;function bB:write(bk,...)if gg.status~="connected"then error("attempt to write to a "..gg.status.." handle",2)end;return do_syscall("__socketcall",gg.id,"write",bk,...)end;function bB:close()if gg.status=="closing"or gg.status=="fin-wait"or gg.status=="closed"then return end;if not(gg.status=="listening"or gg.status=="syn-sent"or gg.status=="syn-received"or gg.status=="connected")then error("attempt to close a "..gg.status.." handle",2)end;return do_syscall("__socketcall",gg.id,"close")end;function bB:transfer()return do_syscall("__socketcall",gg.id,"transfer")end;return bB end;function g2.recv.link(b5,ag)expect.field(ag,"source","number")expect.field(ag,"destination","number")expect.field(ag,"payload","table")syslog.debug("Received link message from",ag.source,"to",ag.destination)if ag.destination~=os.computerID()then return end;b5.sourceID=ag.source;assert(ag.payload.PhoenixNetworking)expect.field(ag.payload,"type","string")if not g2.recv[ag.payload.type]then error("Unknown protocol '"..ag.payload.type.."'")end;return g2.recv[ag.payload.type](b5,ag.payload)end;function g2.recv.arp(b5,ag)expect.field(ag,"source","number")expect.field(ag,"reply","boolean")syslog.debug("Received arp message from",ag.source)if not ag.reply and ag.destinationIP and ag.sourceIP~=ag.destinationIP then local fS=fR(expect.field(ag,"destinationIP","string"))if f_[b5.device.uuid]and f_[b5.device.uuid].ip==fS then g2.send.arp_reply(b5,ag.source,ag.sourceIP)end end;if ag.sourceIP then local fS=fR(expect.field(ag,"sourceIP","string"))g1[b5.device.uuid]=g1[b5.device.uuid]or{}g1[b5.device.uuid][fS]=ag.source;local go={}for x,k in ipairs(g6.arp)do go[x]=k end;for B,k in ipairs(go)do k(k,ag.sourceIP,ag.source)end end end;function g2.recv.internet(b5,ag)b5.sourceIP=fR(expect.field(ag,"source","string"))local bF=fR(expect.field(ag,"destination","string"))b5.localIP=bF;syslog.debug("Received internet message from",ag.source,"to",ag.destination)expect.field(ag,"payload","table")if g7[expect.field(ag,"messageID","number","string")]then return end;g7[ag.messageID]=os.epoch"utc"if not f_[b5.device.uuid]or f_[b5.device.uuid].ip~=bF then return end;b5.ipPacket=ag;assert(ag.payload.PhoenixNetworking)expect.field(ag.payload,"type","string")if not g2.recv[ag.payload.type]then error("Unknown protocol '"..ag.payload.type.."'")end;return g2.recv[ag.payload.type](b5,ag.payload)end;function g2.recv.control(b5,ag)expect.field(ag,"messageType","string")syslog.debug("Received control message",ag.messageType)local a7=false;if ag.messageType=="ping"then g2.send.control({device=b5.device},b5.sourceIP,"pong",nil,b5.ipPacket)else for B,k in pairs(g5)do a7=k{type="control",messageType=ag.messageType,error=ag.error,payload=ag.payload,sender=fT(b5.sourceIP)}or a7 end end;return a7 end;function g2.recv.socket(b5,ag)expect.field(ag,"sequence","number")expect.field(ag,"acknowledgement","number","nil")expect.field(ag,"windowSize","number","nil")expect.field(ag,"payload","string","nil")if b5.channel==0 or b5.replyChannel==0 then syslog.debug("Received socket event on channel 0; discarding.")return end;local gg=(g3[b5.channel]or{})[b5.replyChannel]or(g3[b5.channel]or{}).listen;if not gg then if ag.acknowledgement then g2.send.socket.reset(b5,b5.sourceIP,b5.replyChannel,ag.acknowledgement,nil,b5.channel)else g2.send.socket.reset(b5,b5.sourceIP,b5.replyChannel,0,ag.sequence+(ag.windowSize or 0),b5.channel)end;return end;do local bt={}for j,k in pairs(gg)do if j~="process"then bt[j]=k end end;syslog.debug("Received socket message:",serialize(ag),"\nSocket info:",serialize(bt))end;if gg.status=="listening"then if ag.reset then return end;if ag.acknowledgement then g2.send.socket.reset(b5,b5.sourceIP,b5.replyChannel,ag.acknowledgement,nil,b5.channel)return end;if not ag.synchronize then return end;gg.ip=b5.sourceIP;gg.localIP=fT(b5.localIP)gg.port=b5.replyChannel;gg.recvSeq=ag.sequence+1;gg.recvSeqMax=gg.recvSeq+(ag.windowSize or 0)gg.sendSeq=math.floor(math.random()*0x10000000000)gg.sendSeqNext=gg.sendSeq+2;gg.sendSeqMax=gg.sendSeq+(ag.windowSize or 0)gg.status="syn-received"gg.nextUpdate=os.epoch"utc"+5000;gg.retryCount=0;g3[b5.channel][b5.replyChannel]=gg;g3[b5.channel].listen=nil;g2.send.internet({inPort=b5.channel,outPort=b5.replyChannel},gg.ip,{PhoenixNetworking=true,type="socket",sequence=gg.sendSeqNext-1,acknowledgement=gg.recvSeq,windowSize=256,synchronize=true})elseif gg.status=="syn-sent"then if ag.reset then gg.status="error"gg.error="Connection refused"g3[b5.channel][b5.replyChannel]=nil;if gg.process then gg.process.eventQueue[#gg.process.eventQueue+1]={"handle_status_change",{id=gg.id,status="error"}}end;return true end;if not ag.synchronize or not ag.acknowledgement or ag.acknowledgement<gg.sendSeq then g2.send.socket.reset(b5,b5.sourceIP,b5.replyChannel,ag.acknowledgement,nil,b5.channel)gg.status="error"gg.error="Connection refused"g3[b5.channel][b5.replyChannel]=nil;if gg.process then gg.process.eventQueue[#gg.process.eventQueue+1]={"handle_status_change",{id=gg.id,status="error"}}end;return true end;gg.localIP=fT(b5.localIP)gg.status="connected"gg.sendSeq=ag.acknowledgement;gg.sendSeqMax=gg.sendSeq+256;gg.recvSeq=ag.sequence+1;gg.recvSeqMax=gg.recvSeq+(ag.windowSize or 0)gg.outQueue={}gg.nextUpdate=os.epoch"utc"+2000;g2.send.socket.ack({},gg.recvSeq,gg)if gg.process then gg.process.eventQueue[#gg.process.eventQueue+1]={"handle_status_change",{id=gg.id,status="connected"}}end;return true else if ag.sequence<gg.recvSeq or ag.sequence>gg.recvSeqMax then syslog.debug("Sequence out of range")if ag.reset then gg.status="error"gg.error="Connection reset by peer"g3[b5.channel][b5.replyChannel]=nil;if gg.process then gg.process.eventQueue[#gg.process.eventQueue+1]={"handle_status_change",{id=gg.id,status="error"}}end;return true else g2.send.socket.ack({},gg.recvSeq,gg)return end end;if ag.reset then syslog.debug("Received reset")if gg.status=="syn-received"then gg.status="listening"return elseif gg.status=="connected"or gg.status=="fin-wait"then gg.status="error"gg.error="Connection reset by peer"g3[b5.channel][b5.replyChannel]=nil;if gg.process then gg.process.eventQueue[#gg.process.eventQueue+1]={"handle_status_change",{id=gg.id,status="error"}}end;return true else gg.status="closed"g3[b5.channel][b5.replyChannel]=nil;if gg.process then gg.process.eventQueue[#gg.process.eventQueue+1]={"handle_status_change",{id=gg.id,status="closed"}}end;return true end end;if ag.synchronize then g2.send.socket.reset(b5,b5.sourceIP,b5.replyChannel,ag.acknowledgement,nil,b5.channel)gg.status="error"gg.error="Connection reset by host"g3[b5.channel][b5.replyChannel]=nil;if gg.process then gg.process.eventQueue[#gg.process.eventQueue+1]={"handle_status_change",{id=gg.id,status="error"}}end;return true end;local a7;if not ag.acknowledgement then syslog.debug("No acknowledgement")return end;if gg.status=="syn-received"then if ag.acknowledgement>=gg.sendSeq and ag.acknowledgement<=gg.sendSeqNext then gg.status="connected"gg.outQueue={}gg.nextUpdate=os.epoch"utc"+2000;if gg.process then gg.process.eventQueue[#gg.process.eventQueue+1]={"network_request",{uri=gg.uri,ip=fT(b5.sourceIP),handle=gn(gg)}}end;a7=true else g2.send.socket.reset(b5,b5.sourceIP,b5.replyChannel,ag.acknowledgement,nil,b5.channel)gg.status="error"gg.error="Connection reset by host"g3[b5.channel][b5.replyChannel]=nil;if gg.process then gg.process.eventQueue[#gg.process.eventQueue+1]={"handle_status_change",{id=gg.id,status="error"}}end;return true end elseif gg.status=="close-wait"then if ag.acknowledgement==gg.sendSeqMax then syslog.debug("Socket closed")gg.status="closed"g3[b5.channel][b5.replyChannel]=nil;if gg.process then gg.process.eventQueue[#gg.process.eventQueue+1]={"handle_status_change",{id=gg.id,status="closed"}}end;return true end elseif gg.status=="time-wait"then if ag.final then g2.send.socket.ack({},ag.sequence,gg)gg.nextUpdate=os.epoch"utc"+10000;return end else if ag.acknowledgement>gg.sendSeq and ag.acknowledgement<=gg.sendSeqNext then for x=gg.sendSeq,ag.acknowledgement do gg.outQueue[x]=nil end;gg.sendSeq=ag.acknowledgement;if ag.windowSize then gg.sendSeqMax=gg.sendSeq+ag.windowSize end end;if gg.status=="fin-wait"then if ag.acknowledgement==gg.sendSeqMax then if not ag.final then g2.send.socket.reset(b5,b5.sourceIP,b5.replyChannel,ag.acknowledgement,nil,b5.channel)gg.status="error"gg.error="Connection reset by host"g3[b5.channel][b5.replyChannel]=nil;if gg.process then gg.process.eventQueue[#gg.process.eventQueue+1]={"handle_status_change",{id=gg.id,status="error"}}end;return true end;gg.status="time-wait"gg.nextUpdate=os.epoch"utc"+10000 end elseif gg.status=="closing"then if ag.acknowledgement==gg.sendSeqMax then gg.status="time-wait"gg.nextUpdate=os.epoch"utc"+10000 end end end;if gg.status=="connected"and ag.sequence==gg.recvSeq then if ag.payload then gg.buffer=gg.buffer..ag.payload;gg.nextAck=true;gg.nextUpdate=os.epoch"utc"+100;if gg.process then syslog.debug("Sending data event to PID "..gg.process.id)gg.process.eventQueue[#gg.process.eventQueue+1]={"handle_data_ready",{id=gg.id}}end;a7=true end;gg.recvSeq=gg.recvSeq+1 end;if ag.final then syslog.debug("Got final message")gg.recvSeq=ag.sequence+1;if gg.status=="syn-received"or gg.status=="connected"then gg.sendSeqMax=gg.sendSeqNext;g2.send.socket.data({},{final=true,acknowledgement=ag.sequence},gg)gg.status="close-wait"if gg.process then gg.process.eventQueue[#gg.process.eventQueue+1]={"handle_status_change",{id=gg.id,status="closed"}}end;return true elseif gg.status=="fin-wait"then g2.send.socket.ack({},ag.sequence,gg)if ag.acknowledgement~=gg.sendSeqMax then gg.status="closing"else gg.status="time-wait"gg.nextUpdate=os.epoch"utc"+10000 end else g2.send.socket.ack({},ag.sequence,gg)end;syslog.debug(gg.status)end;return a7 end end;local function gp()local c9=os.epoch"utc"local cc=false;for gf,be in pairs(g3)do for gq,gg in pairs(be)do if c9>=gg.nextUpdate then if gg.status=="syn-sent"then gg.status="error"gg.error="Connection timed out (syn-sent)"g3[gf][gq]=nil;if gg.process then gg.process.eventQueue[#gg.process.eventQueue+1]={"handle_status_change",{id=gg.id,status="error"}}cc=true end elseif gg.status=="syn-received"then gg.retryCount=gg.retryCount+1;if gg.retryCount>3 then gg.status="error"gg.error="Connection timed out (syn-received)"g3[gf][gq]=nil;if gg.process then gg.process.eventQueue[#gg.process.eventQueue+1]={"handle_status_change",{id=gg.id,status="error"}}cc=true end else gg.nextUpdate=os.epoch"utc"+2000 end elseif gg.status=="connected"then for x=gg.sendSeq+1,gg.sendSeqNext-1 do if gg.outQueue[x]then g2.send.socket.data({},{sequence=x,payload=gg.outQueue[x]},gg)end end;if gg.nextAck then g2.send.socket.ack({},gg.recvSeq-1,gg)gg.nextAck=nil end;gg.nextUpdate=os.epoch"utc"+2000 elseif gg.status=="fin-wait"then elseif gg.status=="close-wait"then elseif gg.status=="time-wait"then syslog.debug("Time wait finished on port "..gf)gg.status="closed"g3[gf][gq]=nil end end end end;return cc end;eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(at)if type(at[5])=="table"and at[5].PhoenixNetworking and type(at[5].type)=="string"and g2.recv[at[5].type]then local dL=getNodeById(at[2])or hardware.get(at[2])if not dL then syslog.log({level="notice",module="Network"},"Received network event for device ID "..at[2]..", but no device node was found; ignoring")return end;if not f_[dL.uuid]or not f_[dL.uuid].up then return end;syslog.debug(at[2],serialize(at[5]))local bh,q=pcall(g2.recv[at[5].type],{channel=at[3],replyChannel=at[4],device=dL},at[5])if not bh then syslog.log({level="debug",module="Network"},"Network event errored while processing:",q)else return q end end end;local gr=os.startTimer(1)eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=function(at)if at[2]==gr then gr=os.startTimer(1)return gp()end end;local function gs(process,bJ)local fQ=fP(bJ.url)if not fQ.port then error("No port specified")end;local fS=fR(fQ.host)local gf=fQ.port;local gg={process=process,buffer=""}g2.send.socket.connect({process=process},fS,gf,gg)return gn(gg)end;local gt={}local gu={}local gv={}local gw=os.computerID()%65500;local gx={}eventHooks.http_success=eventHooks.http_success or{}eventHooks.http_success[#eventHooks.http_success+1]=function(at)local b5=gt[at[2]]if b5 then b5.handle,b5.status=at[3],"open"b5.process.eventQueue[#b5.process.eventQueue+1]={"handle_status_change",{id=b5.id,status="open"}}gt[at[2]]=nil;return true else syslog.log({level="notice"},"Received HTTP response for "..at[2].." but nobody requested it; ignoring.")end end;eventHooks.http_failure=eventHooks.http_failure or{}eventHooks.http_failure[#eventHooks.http_failure+1]=function(at)local b5=gt[at[2]]if b5 then if at[4]then b5.handle,b5.status=at[4],"open"else b5.status,b5.error="error",at[3]end;b5.process.eventQueue[#b5.process.eventQueue+1]={"handle_status_change",{id=b5.id,status=b5.status}}gt[at[2]]=nil;return true else syslog.log({level="notice"},"Received HTTP response for "..at[2].." but nobody requested it; ignoring.")end end;eventHooks.websocket_success=eventHooks.websocket_success or{}eventHooks.websocket_success[#eventHooks.websocket_success+1]=function(at)local b5=gt[at[2]]if b5 then b5.handle,b5.status=at[3],"open"b5.process.eventQueue[#b5.process.eventQueue+1]={"handle_status_change",{id=b5.id,status="open"}}return true else syslog.log({level="notice"},"Received WebSocket response for "..at[2].." but nobody requested it; ignoring.")end end;eventHooks.websocket_failure=eventHooks.websocket_failure or{}eventHooks.websocket_failure[#eventHooks.websocket_failure+1]=function(at)local b5=gt[at[2]]if b5 then b5.status,b5.error="error",at[3]b5.process.eventQueue[#b5.process.eventQueue+1]={"handle_status_change",{id=b5.id,status=b5.status}}return true else syslog.log({level="notice"},"Received WebSocket response for "..at[2].." but nobody requested it; ignoring.")end end;eventHooks.websocket_message=eventHooks.websocket_message or{}eventHooks.websocket_message[#eventHooks.websocket_message+1]=function(at)local b5=gt[at[2]]if b5 then b5.buffer=b5.buffer..at[3]b5.process.eventQueue[#b5.process.eventQueue+1]={"handle_data_ready",{id=b5.id}}return true else syslog.log({level="notice"},"Received WebSocket message for "..at[2].." but nobody requested it; ignoring.")end end;eventHooks.websocket_closed=eventHooks.websocket_closed or{}eventHooks.websocket_closed[#eventHooks.websocket_closed+1]=function(at)local b5=gt[at[2]]if b5 then b5.status="closed"b5.process.eventQueue[#b5.process.eventQueue+1]={"handle_status_change",{id=b5.id,status=b5.status}}gt[at[2]]=nil;return true else syslog.log({level="notice"},"Received WebSocket message for "..at[2].." but it's not open; ignoring.")end end;eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(at)local a7=false;if gu[at[2]]and(at[3]==gw or at[3]==65535)and type(at[5])=="table"and type(at[5].nMessageID)=="number"and at[5].nMessageID==at[5].nMessageID and not gx[at[5].nMessageID]and(at[5].nRecipient and at[5].nRecipient==os.computerID()or at[3]==65535)then if gv[at[5].nSender]then for B,k in ipairs(gv[at[5].nSender])do if not k.protocol or k.protocol==at[5].sProtocol then k.buffer[#k.buffer+1]=deepcopy(at[5].message)gx[at[5].nMessageID]=os.clock()+9.5;k.process.eventQueue[#k.process.eventQueue+1]={"handle_data_ready",{id=k.id}}a7=true end end end;if gv[0xFFFFFFFF]then for B,k in ipairs(gv[0xFFFFFFFF])do if not k.protocol or k.protocol==at[5].sProtocol then k.buffer[#k.buffer+1]=deepcopy(at[5].message)gx[at[5].nMessageID]=os.clock()+9.5;k.process.eventQueue[#k.process.eventQueue+1]={"handle_data_ready",{id=k.id}}a7=true end end end;for j,k in pairs(gx)do if k<os.clock()then gx[j]=nil end end end;return a7 end;local gy=http.request;local function gz(process,bJ)expect.field(bJ,"encoding","string","nil")expect.field(bJ,"headers","table","nil")expect.field(bJ,"method","string","nil")expect.field(bJ,"redirect","boolean","nil")local b5={status="ready",process=process,id=fZ}local bB=setmetatable({id=fZ},{__name="socket"})fZ=fZ+1;function bB:status()return b5.status,b5.error end;function bB:read(p,...)if b5.status~="open"then error("attempt to read from a "..b5.status.." handle",2)end;p=p or"*l"if type(p)~="string"and type(p)~="number"then error("bad argument (expected string or number, got "..type(p)..")",2)end;p=p:gsub("^%*","")if p=="a"then if select("#",...)>0 then return b5.handle.readAll(),self:read(...)else return b5.handle.readAll()end elseif p=="l"then if select("#",...)>0 then return b5.handle.readLine(false),self:read(...)else return b5.handle.readLine(false)end elseif p=="L"then if select("#",...)>0 then return b5.handle.readLine(true),self:read(...)else return b5.handle.readLine(true)end elseif p=="n"then local a2;repeat a2=b5.handle.read(1)if not a2 then return nil end until tonumber(a2)while true do local ab=b5.handle.read(1)if not ab or not ab:match"%d"then break end;a2=a2 ..ab end;if select("#",...)>0 then return tonumber(a2),self:read(...)else return tonumber(a2)end elseif type(p)=="number"then if select("#",...)>0 then return b5.handle.read(p),self:read(...)else return b5.handle.read(p)end else error("bad argument (invalid mode '"..p.."')",2)end end;function bB:write(...)if b5.status~="ready"then error("attempt to write to a "..b5.status.." handle",2)end;local bk;if select("#",...)>0 then bk=""for B,k in ipairs{...}do bk=bk..tostring(k)end end;local gA=bJ.url.."#"..b5.id;local bh,q=gy{url=gA,body=bk,headers=bJ.headers,binary=bJ.encoding=="binary"or bJ.encoding==nil,method=bJ.method,redirect=bJ.redirect}if bh then gt[gA]=b5;b5.status="connecting"else b5.status,b5.error="error",q end end;function bB:close()if b5.status~="open"then error("attempt to close a "..b5.status.." handle",2)end;b5.handle.close()b5.status="closed"end;function bB:responseHeaders()if b5.status~="open"then error("attempt to read from a "..b5.status.." handle",2)end;return b5.handle.getResponseHeaders()end;function bB:responseCode()if b5.status~="open"then error("attempt to read from a "..b5.status.." handle",2)end;return b5.handle.getResponseCode()end;return bB end;local function gB(process,bJ)expect.field(bJ,"encoding","string","nil")expect.field(bJ,"headers","table","nil")local b5={process=process,id=fZ,buffer=""}local bB=setmetatable({id=fZ},{__name="socket"})fZ=fZ+1;function bB:status()return b5.status,b5.error end;function bB:read(p,...)if b5.status~="open"then error("attempt to read from a "..b5.status.." handle",2)end;p=p or"*l"if type(p)~="string"and type(p)~="number"then error("bad argument (expected string or number, got "..type(p)..")",2)end;if b5.buffer==""then return nil end;p=p:gsub("^%*","")if p=="a"then local a2=b5.buffer;b5.buffer=""return a2 elseif p=="l"then local a2,a9=b5.buffer:match"^([^\n]*)\n?()"if a2 then b5.buffer=b5.buffer:sub(a9)if select("#",...)>0 then return a2,self:read(...)else return a2 end else return nil end elseif p=="L"then local a2,a9=b5.buffer:match"^([^\n]*\n?)()"if a2 then b5.buffer=b5.buffer:sub(a9)if select("#",...)>0 then return a2,self:read(...)else return a2 end else return nil end elseif p=="n"then local a2,a9=b5.buffer:match"(%d+)()"if a2 then b5.buffer=b5.buffer:sub(a9)if select("#",...)>0 then return tonumber(a2),self:read(...)else return tonumber(a2)end else return nil end elseif type(p)=="number"then local a2=b5.buffer:sub(1,p)b5.buffer=b5.buffer:sub(p+1)if select("#",...)>0 then return a2,self:read(...)else return a2 end else error("bad argument (invalid mode '"..p.."')",2)end end;function bB:write(bk,...)if b5.status~="open"then error("attempt to write to a "..b5.status.." handle",2)end;b5.handle.send(tostring(bk),bJ.encoding=="binary")if select("#",...)>0 then return self:write(...)end end;function bB:close()if b5.status~="open"then error("attempt to close a "..b5.status.." handle",2)end;b5.handle.close()b5.status="closed"end;local gA=bJ.url.."#"..b5.id;local bh,q=http.websocket(gA,bJ.headers)if bh then gt[gA]=b5;b5.status="connecting"else return nil,q end;return bB end;local function gC(process,bJ)expect.field(bJ,"device","string","nil")local gD;if bJ.device then gD={hardware.get(bJ.device)}else gD={hardware.find("modem")}end;if#gD==0 then error("Could not find a modem",2)end;for B,k in ipairs(gD)do fY(k)if not gu[k]then hardware.call(process,k,"open",gw)hardware.call(process,k,"open",65535)gu[k]=1 else gu[k]=gu[k]+1 end end;local fQ=fP(bJ.url)if not fQ.host then error("Missing host",2)end;local aC=fR(fQ.host)local b5={process=process,id=fZ,buffer={},protocol=fQ.scheme:match"rednet%+(.+)"}local bB=setmetatable({id=fZ},{__name="socket"})fZ=fZ+1;function bB:status()return b5.closed and"closed"or"open"end;function bB:read(p,...)if b5.closed then error("attempt to read from a "..b5.status.." handle",2)end;p=p or"*l"if type(p)~="string"and type(p)~="number"then error("bad argument (expected string or number, got "..type(p)..")",2)end;if#b5.buffer==0 then return nil end;p=p:gsub("^%*","")if p=="a"then return table.remove(b5.buffer,1)elseif p=="l"then b5.buffer[1]=tostring(b5.buffer[1])local a2,a9=b5.buffer[1]:match"^([^\n]*)\n?()"if a2 then b5.buffer[1]=b5.buffer[1]:sub(a9)if select("#",...)>0 then return a2,self:read(...)else return a2 end else table.remove(b5.buffer,1)return self:read(p,...)end elseif p=="L"then b5.buffer[1]=tostring(b5.buffer[1])local a2,a9=b5.buffer[1]:match"^([^\n]*\n?)()"if a2 then b5.buffer[1]=b5.buffer[1]:sub(a9)if select("#",...)>0 then return a2,self:read(...)else return a2 end else table.remove(b5.buffer,1)return self:read(p,...)end elseif p=="n"then b5.buffer[1]=tostring(b5.buffer[1])local a2,a9=b5.buffer[1]:match"(%d+)()"if a2 then b5.buffer[1]=b5.buffer[1]:sub(a9)if select("#",...)>0 then return tonumber(a2),self:read(...)else return tonumber(a2)end else table.remove(b5.buffer,1)return self:read(p,...)end elseif type(p)=="number"then local a2=""while#a2<p do b5.buffer[1]=tostring(b5.buffer[1])a2=a2 ..b5.buffer[1]:sub(1,p-#a2)b5.buffer[1]=b5.buffer[1]:sub(p-#a2+1)if b5.buffer[1]==""then table.remove(b5.buffer,1)end;if#b5.buffer==0 then break end end;if select("#",...)>0 then return a2,self:read(...)else return a2 end else error("bad argument (invalid mode '"..p.."')",2)end end;function bB:write(bk,...)if b5.closed then error("attempt to write to a "..b5.status.." handle",2)end;local gE=math.random(1,0x7FFFFFFF)local ed={nMessageID=gE,nRecipient=aC,nSender=os.computerID(),message=bk,sProtocol=b5.protocol}if aC==os.computerID()then for B,k in ipairs(gD)do os.queueEvent("modem_message",k.id,gw,gw,ed,0)end else gx[gE]=os.clock()+9.5;for B,k in ipairs(gD)do hardware.call(process,k,"transmit",aC==0xFFFFFFFF and 65535 or aC%65500,gw,ed)hardware.call(process,k,"transmit",65533,gw,ed)end end;if select("#",...)>0 then return self:write(...)end end;function bB:close()if b5.closed then error("attempt to close a "..b5.status.." handle",2)end;for B,k in ipairs(gD)do gu[k]=gu[k]-1;if gu[k]==0 then hardware.call(process,k,"close",gw)hardware.call(process,k,"close",65535)gu[k]=nil end end;b5.status="closed"end;return bB end;uriSchemes={["https?"]=gz,["wss?"]=gB,["rednet"]=gC,["rednet%+%a+"]=gC,["psp"]=gs}function syscalls.connect(process,as,bJ)if type(bJ)=="string"then bJ={url=bJ}end;expect(1,bJ,"table")expect.field(bJ,"url","string")local fQ=fP(bJ.url)local bB,q;for j,k in pairs(uriSchemes)do if fQ.scheme:match(j)then bB,q=k(process,bJ)break end end;if not bB and not q then error("Invalid protocol "..fQ.scheme)end;if bB then for B,k in pairs(bB)do if type(k)=="function"then setfenv(k,process.env)debug.protect(k)end end end;return bB,q end;function syscalls.listen(process,as,fQ)expect(1,fQ,"string")local gF=fP(fQ)if http.addListener then if gF.scheme=="http"then http.addListener(gF.port or 80)return elseif gF.scheme=="ws"then http.websocket(gF.port or 80)return end end;if gF.scheme=="psp"then if not gF.port then error("Missing port")end;local fS=fR(gF.host)for j,k in pairs(f_)do if k.up and(fS==0 or k.ip==fS)then hardware.call(process,hardware.get(j),"open",gF.port)end end;local gg={localPort=gF.port,id=fZ,status="listening",process=process,nextUpdate=math.huge,retryCount=0,uri=fQ,buffer=""}fZ=fZ+1;g3[gF.port]=g3[gF.port]or{}g3[gF.port].listen=gg;g4[gg.id]=gg;return end;error("Invalid protocol "..gF.scheme)end;function syscalls.unlisten(process,as,fQ)end;function syscalls.ipconfig(process,as,f2,b5)if b5 and process.user~="root"then error("Permission denied")end;expect(1,f2,"string")expect(2,b5,"table","nil")local dL=fY(hardware.get(f2))local A=f_[dL.uuid]if not A then if b5 then expect.field(b5,"ip","string","number")expect.field(b5,"netmask","string","number")A={up=true}f_[dL.uuid]=A;hardware.call(KERNEL,dL,"open",0)else return nil end end;if b5 then expect.field(b5,"ip","string","number","nil")expect.field(b5,"netmask","string","number","nil")expect.field(b5,"up","boolean","nil")local gG,gH;if A.ip then for B,k in ipairs(g0[0])do if k.source==bit32.band(A.ip,A.netmask)and k.netmask==A.netmask then gG=k elseif k.source==bit32.bor(bit32.band(A.ip,A.netmask),bit32.bnot(A.netmask))and k.netmask==0xFFFFFFFF then gH=k end end end;if b5.ip then if g1[dL.uuid]then g1[dL.uuid][A.ip]=nil end;if type(b5.ip)=="number"then A.ip=bit32.band(b5.ip,0xFFFFFFFF)else A.ip=fR(b5.ip)end;if gG then gG.source=bit32.band(A.ip,A.netmask)end;if gH then gH.source=bit32.bor(bit32.band(A.ip,A.netmask),bit32.bnot(A.netmask))end;g1[dL.uuid]=g1[dL.uuid]or{}g1[dL.uuid][A.ip]=os.computerID()end;if b5.netmask then if type(b5.netmask)=="number"then A.netmask=fW(b5.netmask)else A.netmask=fR(b5.netmask)end;if gG then gG.source=bit32.band(A.ip,A.netmask)end;if gH then gH.source=bit32.bor(bit32.band(A.ip,A.netmask),bit32.bnot(A.netmask))end end;if b5.up~=nil then A.up=b5.up;if A.up then hardware.call(KERNEL,dL,"open",0)else hardware.call(KERNEL,dL,"close",0)end end;if not gG then g0[0][#g0[0]+1]={source=bit32.band(A.ip,A.netmask),sourceNetmask=A.netmask,action="local",device=dL}end;if not gH then g0[0][#g0[0]+1]={source=bit32.bor(bit32.band(A.ip,A.netmask),bit32.bnot(A.netmask)),sourceNetmask=0xFFFFFFFF,action="broadcast",device=dL}end end;return{ip=fT(A.ip),netmask=fX(A.netmask),up=A.up}end;function syscalls.routelist(process,as,b)b=expect(1,b,"number","nil")or 1;expect.range(b,0)if not g0[b]then return nil end;local a7={}for x,A in ipairs(g0[b])do a7[x]={source=fT(A.source),sourceNetmask=fX(A.sourceNetmask),action=A.action,device=A.device and hardware.path(A.device),destination=A.destination and fT(A.destination)}end;return a7 end;local gI={unicast=true,broadcast=true,["local"]=true,unreachable=true,prohibit=true,blackhole=true}function syscalls.routeadd(process,as,bJ)if process.user~="root"then error("Permission denied")end;expect(1,bJ,"table")expect.field(bJ,"source","string","number")expect.field(bJ,"sourceNetmask","string","number")expect.field(bJ,"action","string")expect.field(bJ,"device","string",bJ.action~="unicast"and bJ.action~="broadcast"and bJ.action~="local"and"nil"or nil)expect.field(bJ,"destination","string",bJ.action~="unicast"and"nil"or nil)expect.range(expect.field(bJ,"table","number","nil")or 1,1)bJ.table=bJ.table or 1;if not gI[bJ.action]then error("bad field 'action' (invalid option '"..bJ.action.."')")end;local A={}if type(bJ.source)=="number"then A.source=bit32.band(bJ.source,0xFFFFFFFF)else A.source=fR(bJ.source)end;if type(bJ.sourceNetmask)=="number"then A.sourceNetmask=fW(bJ.sourceNetmask)else A.sourceNetmask=fR(bJ.sourceNetmask)end;A.source=bit32.band(A.source,A.sourceNetmask)A.action=bJ.action;A.device=bJ.device and fY(hardware.get(bJ.device))A.destination=bJ.destination and fR(bJ.destination)g0[bJ.table]=g0[bJ.table]or{}for B,k in ipairs(g0[bJ.table])do if k.source==A.source and k.sourceNetmask==A.sourceNetmask then error("Route already exists")end end;g0[bJ.table][#g0[bJ.table]+1]=A;g0.maxn=math.max(g0.maxn,bJ.table)end;function syscalls.routedel(process,as,gJ,y,b)if process.user~="root"then error("Permission denied")end;expect(1,gJ,"string","number")expect(2,y,"string","number")b=expect(3,b,"number","nil")or 1;expect.range(b,1)if type(y)=="number"then y=fW(y)else y=fR(y)end;if type(gJ)=="number"then gJ=bit32.band(gJ,y)else gJ=bit32.band(fR(gJ),y)end;if not g0[b]then error("Route table does not exist")end;for x,k in ipairs(g0[b])do if k.source==gJ and k.sourceNetmask==y then table.remove(g0[b],x)return end end end;function syscalls.arplist(process,as,f2)expect(1,f2,"string")local dL=fY(hardware.get(f2))local a7={}for j,k in pairs(g1[dL.uuid]or{})do a7[fT(j)]=k end;return a7 end;function syscalls.arpset(process,as,f2,fS,aC)if process.user~="root"then error("Permission denied")end;expect(1,f2,"string")expect(2,fS,"string","number")expect(3,aC,"number")local dL=fY(hardware.get(f2))if type(fS)=="string"then fS=fR(fS)else fS=bit32.band(fS,0xFFFFFFFF)end;g1[dL.uuid]=g1[dL.uuid]or{}g1[dL.uuid][fS]=aC end;local gK={ping=true,pong=true,unreachable=true,timeout=true}function syscalls.netcontrol(process,as,fS,gL,q)if process.user~="root"then error("Permission denied")end;expect(1,fS,"string","number")expect(2,gL,"string")expect(3,q,"string","nil")if not gK[gL]then error("bad argument #2 (invalid option '"..gL.."')")end;if type(fS)=="string"then fS=fR(fS)else fS=bit32.band(fS,0xFFFFFFFF)end;g2.send.control({process=process},fS,gL,q)end;function syscalls.netevent(process,as,dq)if process.user~="root"then error("Permission denied")end;expect(1,dq,"boolean","nil")if dq==true then g5[process]=function(ag)process.eventQueue[#process.eventQueue+1]={"network_event",deepcopy(ag)}return true end elseif dq==false then g5[process]=nil end;return g5[process]~=nil end;function syscalls.checkuri(process,as,fQ)end;function registerLoopback()local dL=hardware.get("/lo")if dL then f_[dL.uuid]={ip=0x7F000001,netmask=0xFF000000,up=true}g0[0][#g0[0]+1]={source=0x7F000000,sourceNetmask=0xFF000000,action="local",device=dL}g0[0][#g0[0]+1]={source=0x7FFFFFFF,sourceNetmask=0xFFFFFFFF,action="broadcast",device=dL}g1[dL.uuid]=setmetatable({},{__index=function()return os.computerID()end})syslog.log("Configured IP for loopback device")end end;function syscalls.listmodules()local a7={}for j in pairs(modules)do a7[#a7+1]=j end;return a7 end;function syscalls.loadmodule(process,as,g)expect(1,g,"string")if process.user~="root"then error("Could not load kernel module: Permission denied",2)end;local bK=filesystem.stat(process,g)if bK.type=="directory"then error("Could not load kernel module: Is a directory",2)end;if bK.owner~="root"or bK.worldPermissions.write then error("Insecure permissions set on kernel module, refusing to load",2)end;local o=g:match"([^%./]+)[^/]*$"syslog.log("Loading kernel module "..o.." from "..g)local a,q=filesystem.open(process,g,"rb")if a then local bk=a.readAll()or""a.close()local i,q=load(bk,"@"..g)if i then local bh,w=pcall(i,g)if bh then modules[o]=w or true else syslog.log({level="error"},"Kernel module "..o.." threw an error:",w)end else syslog.log({level="error"},"Could not load "..o..":",q)end else syslog.log({level="error"},"Could not open "..g..":",q)end end;function syscalls.unloadmodule(process,as,o)expect(1,o,"string")if process.user~="root"then error("Could not load kernel module: Permission denied",2)end;if type(modules[o])=="table"and modules[o].unload then modules[o].unload(process,as)end;modules[o]=nil end;function syscalls.callmodule(process,as,o,aB,...)expect(1,o,"string")expect(2,aB,"string")if not modules[o]then error("Module '"..o.."' does not exist",2)elseif type(modules[o])~="table"then error("Module '"..o.."' does not have a callable interface",2)elseif aB=="unload"or type(modules[o][aB])~="function"then error("Module '"..o.."' does not have a method '"..aB.."'",2)end;return modules[o][aB](process,as,...)end;syslog.log("Loading kernel modules from /lib/modules")local bh,gM=pcall(filesystem.list,KERNEL,"/lib/modules")if bh then for B,k in ipairs(gM)do local G=filesystem.combine("/lib/modules",k)local bK=filesystem.stat(KERNEL,G)if bK.type~="directory"then local bh,q=pcall(syscalls.loadmodule,KERNEL,nil,G)if not bh then syslog.log({level="error"},"Could not load module from "..G..": "..q)end end end else syslog.log({level="notice"},"Could not open /lib/modules:",gM)end;xpcall(hardware.register,function(error)panic("An error occurred while registering devices: "..error)end,deviceTreeRoot,rootDriver)local ar={n=0}local gN=processes[syscalls.fork(KERNEL,nil,function()end,"init")]local gO=gN.id;local gP,gQ;if args.init then gP,gQ=pcall(syscalls.exec,gN,nil,args.initrd and"/init"or args.init)end;if not gP then syslog.log({level="error",process=0},"Could not load init:",gQ)syslog.log("Could not find provided init, trying default locations")for B,k in ipairs{"/sbin/init","/etc/init","/bin/init","/bin/sh"}do syslog.log("Trying",k)gP,gQ=pcall(syscalls.exec,gN,nil,k)if not gP then syslog.log({level="error",process=0},"Could not load init:",gQ)end;if gP then break end end;if not gP then panic("No working init found")end end;syslog.log("Starting init from "..processes[gO].name)local av=false;local gR=coroutine.yield;function coroutine.yield(...)if coroutine.running()==mainThread then error("attempt to yield from kernel main thread",2)end;return gR(...)end;debug.protect(coroutine.yield)eventHooks.key=eventHooks.key or{}eventHooks.key[#eventHooks.key+1]=function(at)if keysHeld.ctrl and keysHeld.shift and at[2]==keys.f10 then term.clear()term.setCursorPos(1,1)term.write("Entering debug console.")local s=2;local aY=true;term.setCursorPos(1,s)while aY do local al=""local ah,ai=term.getSize()term.write("lua> ")term.setCursorBlink(true)while true do local at={gR()}if at[1]=="char"or at[1]=="paste"then al=al..at[2]term.write(at[2])elseif at[1]=="key"then if at[2]==keys.backspace and#al>0 then al=al:sub(1,-2)term.setCursorPos(term.getCursorPos()-1,s)term.write(" ")term.setCursorPos(term.getCursorPos()-1,s)elseif at[2]==keys.enter then break end end end;s=s+1;if s>ai then s=s-1;term.scroll(1)end;term.setCursorPos(1,s)local i,q=load("return "..al,"=lua","t",setmetatable({exit=function()aY=false end},{__index=_G}))if not i then i,q=load(al,"=lua","t",setmetatable({exit=function()aY=false end},{__index=_G}))end;if i then local w=table.pack(pcall(i))if w[1]then for x=2,w.n do term.write(tostring(w[x]))s=s+1;if s>ai then s=s-1;term.scroll(1)end;term.setCursorPos(1,s)end else term.setTextColor(16384)term.write(w[2])term.setTextColor(1)s=s+1;if s>ai then s=s-1;term.scroll(1)end;term.setCursorPos(1,s)end else term.setTextColor(16384)term.write(q)term.setTextColor(1)s=s+1;if s>ai then s=s-1;term.scroll(1)end;term.setCursorPos(1,s)end end;term.setCursorBlink(false)term.clear()terminal.redraw(currentTTY,true)end end;local gS={char=true,key=true,key_up=true,mouse_click=true,mouse_up=true,mouse_drag=true,mouse_scroll=true,paste=true}local bh,q=xpcall(function()while processes[gO]do if not av then os.queueEvent("__event_queue_back")end;while true do local at=table.pack(gR())local o=at[1]if o=="__event_queue_back"then break end;local gT=false;if eventHooks[o]then for B,k in ipairs(eventHooks[o])do gT=k(at)or gT end end;if eventParameterMap[o]then local ax={}for x=2,#eventParameterMap[o]+1 do ax[eventParameterMap[o][x-1]]=at[x]end;if o=="key"or o=="key_up"then ax.keycode=keymap[ax.keycode]ax.ctrlHeld=keysHeld.ctrl;ax.altHeld=keysHeld.alt;ax.shiftHeld=keysHeld.shift end;if gS[o]and currentTTY.frontmostProcess then currentTTY.frontmostProcess.eventQueue[#currentTTY.frontmostProcess.eventQueue+1]={o,ax}gT=true elseif o=="timer"or o=="alarm"then local gU;if o=="timer"then gU=timerMap[at[2]]else gU,ax.id=alarmMap[at[2]],bit32.bor(ax.id,0x80000000)end;if gU then gU.eventQueue[#gU.eventQueue+1],gT={o,ax},true end end end;if av and gT then break end end;av=true;for c_,process in pairs(processes)do if c_~=0 and not process.paused then local fu,at=false,nil;local au=true;for fv,as in pairs(process.threads)do if not fu and as.status=="suspended"then at=table.remove(process.eventQueue,1)fu=true end;if at or as.status~="suspended"then local gV;au,gV=executeThread(process,as,at or ar,au,av)av=gV and av else au=false end end;if au then process.isDead=true;if process.lastReturnValue then if c_==gO then init_retval=process.lastReturnValue.value or process.lastReturnValue.error elseif processes[process.parent]then process.lastReturnValue.id=c_;processes[process.parent].eventQueue[#processes[process.parent].eventQueue+1]={"process_complete",process.lastReturnValue}end end;reap_process(process)processes[c_]=nil;av=false end end end;terminal.redraw(currentTTY)end end,debug.traceback)if not bh then syslog.log({level="critical",traceback=true},q)end;if postkill then postkill()end;if init_retval~=nil then syslog.log({level=4},"init exited with result",init_retval)end;panic("init program exited")
