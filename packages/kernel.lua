PHOENIX_VERSION="0.0.5"PHOENIX_BUILD="PRERELEASE NONFREE Tue Jan 16 17:49:48 2024"systemStartTime=os.epoch"utc"args={init="/sbin/init.lua",root="/root",rootfstype="craftos",preemptive=true,quantum=2000000,splitkernpath="/boot/kernel.lua.d",loglevel=1,console="tty1",traceback=true}syscalls={}processes={[0]={name="kernel",id=0,user="root",dir="/",root="/",env=_G,vars={},dependents={}}}KERNEL=processes[0]modules={}eventHooks={}shutdownHooks={}kSyscallYield={}kSyscallComplete={}process={}filesystem={}terminal={}user={}syslog={}hardware={}if discord then discord("Phoenix","Booting Phoenix "..PHOENIX_VERSION)end;do local a=fs.open("/rom/modules/main/cc/expect.lua","r")expect=(loadstring or load)(a.readAll(),"@/rom/modules/main/cc/expect.lua")()a.close()setmetatable(expect,{__call=function(self,...)return self.expect(...)end})if not expect.range then function expect.range(b,c,d)expect(1,b,"number")expect(2,c,"number","nil")expect(3,d,"number","nil")if d and c and d<c then error("bad argument #3 (min must be less than or equal to max)",2)end;if b~=b or b<(c or-math.huge)or b>(d or math.huge)then error(("number outside of range (expected %s to be within %s and %s)"):format(b,c or-math.huge,d or math.huge),3)end;return b end end end;do local a=fs.open("/rom/apis/textutils.lua","r")local e=setmetatable({dofile=function()return expect end},{__index=_G})local g;if loadstring and setfenv then g=loadstring(a.readAll(),"@/rom/apis/textutils.lua")setfenv(g,e)else g=load(a.readAll(),"@/rom/apis/textutils.lua","t",e)end;a.close()g()serialize,unserialize=e.serialize,e.unserialize end;do local a=fs.open("/rom/apis/keys.lua","r")local e=setmetatable({dofile=function()return expect end},{__index=_G})if _VERSION<"Lua 5.2"then e._ENV=e end;local g;if loadstring and setfenv then g=loadstring(a.readAll(),"@/rom/apis/keys.lua")setfenv(g,e)else g=load(a.readAll(),"@/rom/apis/keys.lua","t",e)end;a.close()g()keys={}for h,i in pairs(e)do keys[h]=i end end;if not pcall(load,"return","=test","t",{})then local j,k,expect,setfenv=load,loadstring,expect,setfenv;function load(l,m,n,e)expect(1,l,"string","function")expect(2,m,"string","nil")expect(3,n,"string","nil")expect(4,e,"table","nil")if type(l)=="string"then if l:sub(1,4)=="\27Lua"then if n==nil or n:find"b"then local g,o=k(l,m)if g and e then setfenv(g,e)end;return g,o else return nil,"attempt to load a binary chunk (mode is '"..(n or"bt").."')"end else if n==nil or n:find"t"then local g,o=k(l,m)if g and e then setfenv(g,e)end;return g,o else return nil,"attempt to load a text chunk (mode is '"..(n or"bt").."')"end end else local g,o=j(l,m)if g then setfenv(g,e)end;return g,o end end end;loadstring=nil;if bit then if not bit32 then local bit=bit;bit32={bnot=bit.bnot,lshift=bit.blshift,rshift=bit.blogic_rshift,arshift=bit.brshift}function bit32.band(p,q,...)expect(1,p,"number")expect(2,q,"number","nil")if not q then return p end;return bit32.band(bit.band(p,q),...)end;function bit32.bor(p,q,...)expect(1,p,"number")expect(2,q,"number","nil")if not q then return p end;return bit32.bor(bit.bor(p,q),...)end;function bit32.bxor(p,q,...)expect(1,p,"number")expect(2,q,"number","nil")if not q then return p end;return bit32.bxor(bit.bxor(p,q),...)end;function bit32.btest(...)return bit32.band(...)~=0 end;function bit32.extract(r,s,t)expect(1,r,"number")expect(2,s,"number")expect(3,t,"number","nil")(expect.range or function()end)(s,0,31)(expect.range or function()end)(s+t-1,0,31)t=t or 1;local u=0;for v=s+t-1,s,-1 do u=u*2+bit.band(r,2^v)/2^v end;return u end;function bit32.replace(r,i,s,t)expect(1,r,"number")expect(2,i,"number")expect(3,s,"number")expect(4,t,"number","nil")(expect.range or function()end)(s,0,31)(expect.range or function()end)(s+t-1,0,31)t=t or 1;local w=2^t-1;return bit.bor(bit.band(r,bit.bnot(bit.blshift(w,s))),bit.blshift(bit.band(i,w),s))end;function bit32.lrotate(p,x)return bit.bor(bit.blshift(p,x),bit.blogic_rshift(p,32-x))end;function bit32.rrotate(p,x)return bit.bor(bit.blogic_rshift(p,x),bit.blshift(p,32-x))end end;bit=nil end;if _VERSION=="Lua 5.1"and load("::a:: goto a")then _VERSION="Lua 5.2"if load("return 1 >> 2 & 3")then _VERSION="Lua 5.3"if load("local <const> a = 2")then _VERSION="Lua 5.4"end end end;if _VERSION=="Lua 5.1"then if not table.pack then table.pack=function(...)local y={...}y.n=select("#",...)return y end end;if not table.unpack then table.unpack,unpack=unpack,nil end;local z,i=xpcall(function(A)return A end,function()end,true)if not i then local B=xpcall;xpcall=function(f,C,...)if select("#",...)>0 then local args=table.pack(...)return B(function()return f(table.unpack(args,1,args.n))end,C)else return B(f,C)end end end end;if tonumber(_HOST:match"ComputerCraft 1.(%d+)")<95 then local D=fs.combine;function fs.combine(E,...)if...~=nil then return D(E,fs.combine(...))else return E end end end;if not string.pack then local F={BIG_ENDIAN=1,LITTLE_ENDIAN=2}local G={b=1,B=1,h=1,H=1,l=1,L=1,j=1,J=1,T=1}local H={b=1,B=1,x=1,h=2,H=2,f=4,j=4,J=4,l=8,L=8,T=8,d=8,n=8}local function I(r)if r%1>=0.5 then return math.ceil(r)else return math.floor(r)end end;local function J(f)if f==0 then return 0 elseif f==-0 then return 0x80000000 elseif f==math.huge then return 0x7F800000 elseif f==-math.huge then return 0xFF800000 end;local A,K=math.frexp(f)if K>127 or K<-126 then error("number out of range",3)end;K,A=K+126,I((math.abs(A)-0.5)*0x1000000)if A>0x7FFFFF then K=K+1 end;return bit32.bor(f<0 and 0x80000000 or 0,bit32.lshift(bit32.band(K,0xFF),23),bit32.band(A,0x7FFFFF))end;local function L(f)if f==0 then return 0,0 elseif f==-0 then return 0x80000000,0 elseif f==math.huge then return 0x7FF00000,0 elseif f==-math.huge then return 0xFFF00000,0 end;local A,K=math.frexp(f)if K>1023 or K<-1022 then error("number out of range",3)end;K,A=K+1022,I((math.abs(A)-0.5)*0x20000000000000)if A>0xFFFFFFFFFFFFF then K=K+1 end;return bit32.bor(f<0 and 0x80000000 or 0,bit32.lshift(bit32.band(K,0x7FF),20),bit32.band(A/0x100000000,0xFFFFF)),bit32.band(A,0xFFFFFFFF)end;local function M(N)if N==0 then return 0 elseif N==0x80000000 then return-0 elseif N==0x7F800000 then return math.huge elseif N==0xFF800000 then return-math.huge end;local A,K=bit32.band(N,0x7FFFFF),bit32.band(bit32.rshift(N,23),0xFF)K,A=K-126,A/0x1000000+0.5;local r=math.ldexp(A,K)return bit32.btest(N,0x80000000)and-r or r end;local function O(P,Q)if P==0 and Q==0 then return 0 elseif P==0x80000000 and Q==0 then return-0 elseif P==0x7FF00000 and Q==0 then return math.huge elseif P==0xFFF00000 and Q==0 then return-math.huge end;local A,K=bit32.band(P,0xFFFFF)*0x100000000+bit32.band(Q,0xFFFFFFFF),bit32.band(bit32.rshift(P,20),0x7FF)K,A=K-1022,A/0x20000000000000+0.5;local r=math.ldexp(A,K)return bit32.btest(P,0x80000000)and-r or r end;local function R(b,S,T,U,V,W,X)local Y=0;if U%math.min(S,V)~=0 and V>1 then local v=0;while U%math.min(S,V)~=0 and v<V do T[U]=0;U=U+1;Y=Y+1;v=v+1 end end;if W==F.BIG_ENDIAN then local Z=0;if S>8 then for v=0,S-9 do T[U+v]=X and b>=2^(S*8-1)~=0 and 0xFF or 0;Z=Z+1;Y=Y+1 end end;for v=Z,S-1 do T[U+v]=bit32.band(bit32.rshift(b,(S-v-1)*8),0xFF)Y=Y+1 end else for v=0,math.min(S,8)-1 do T[U+v]=b/2^(v*8)%256;Y=Y+1 end;for v=8,S-1 do T[U+v]=X and b>=2^(S*8-1)~=0 and 0xFF or 0;Y=Y+1 end end;return Y end;local function _(a0,U,S,W,V,X)local a1,a2=0,0;if U%math.min(S,V)~=0 and V>1 then for v=0,V-1 do if U%math.min(S,V)==0 then break end;U=U+1;a2=a2+1 end end;for v=0,S-1 do a1=a1+a0:byte(U+v)*2^((W==F.BIG_ENDIAN and S-v-1 or v)*8)a2=a2+1 end;if X and a1>=2^(S*8-1)then a1=a1-2^(S*8)end;return a1,a2 end;local function a3(a4,V)local a5=H[a4]or 0;if V>1 and a5%V~=0 then a5=a5+V-a5%V end;return a5 end;function string.pack(...)local a6=expect(1,...,"string")local W=F.LITTLE_ENDIAN;local V=1;local a7=1;local a8=2;local T={}local v=1;while v<=#a6 do local a9=a6:sub(v,v)v=v+1;if a9=='='or a9=='<'then W=F.LITTLE_ENDIAN elseif a9=='>'then W=F.BIG_ENDIAN elseif a9=='!'then local S=-1;while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=math.max(S,0)*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 or S==0 then error(string.format("integral size (%d) out of limits [1,16]",S),2)elseif S==-1 then V=4 else V=S end elseif G[a9]then local b=expect(a8,select(a8,...),"number")a8=a8+1;if b>=math.pow(2,a3(a9,0)*8-(a9:match("%l")and 1 or 0))or b<(a9:match("%l")and-math.pow(2,a3(a9,0)*8-1)or 0)then error(string.format("bad argument #%d to 'pack' (integer overflow)",a8-1),2)end;a7=a7+R(b,a3(a9,0),T,a7,V,W,false)elseif a9:lower()=='i'then local X=a9=='i'local S=-1;while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=math.max(S,0)*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 or S==0 then error(string.format("integral size (%d) out of limits [1,16]",S),2)elseif V>1 and(S~=1 and S~=2 and S~=4 and S~=8 and S~=16)then error("bad argument #1 to 'pack' (format asks for alignment not power of 2)",2)elseif S==-1 then S=4 end;local b=expect(a8,select(a8,...),"number")a8=a8+1;if b>=math.pow(2,S*8-(a9:match("%l")and 1 or 0))or b<(a9:match("%l")and-math.pow(2,S*8-1)or 0)then error(string.format("bad argument #%d to 'pack' (integer overflow)",a8-1),2)end;a7=a7+R(b,S,T,a7,V,W,X)elseif a9=='f'then local f=expect(a8,select(a8,...),"number")a8=a8+1;local N=J(f)if a7%math.min(4,V)~=0 and V>1 then for aa=0,V-1 do if a7%math.min(4,V)==0 then break end;T[a7]=0;a7=a7+1 end end;for aa=0,3 do T[a7+(W==F.BIG_ENDIAN and 3-aa or aa)]=bit32.band(bit32.rshift(N,aa*8),0xFF)end;a7=a7+4 elseif a9=='d'or a9=='n'then local f=expect(a8,select(a8,...),"number")a8=a8+1;local P,Q=L(f)if a7%math.min(8,V)~=0 and V>1 then for aa=0,V-1 do if a7%math.min(8,V)==0 then break end;T[a7]=0;a7=a7+1 end end;for aa=0,3 do T[a7+(W==F.BIG_ENDIAN and 7-aa or aa)]=bit32.band(bit32.rshift(Q,aa*8),0xFF)end;for aa=4,7 do T[a7+(W==F.BIG_ENDIAN and 7-aa or aa)]=bit32.band(bit32.rshift(P,(aa-4)*8),0xFF)end;a7=a7+8 elseif a9=='c'then local S=0;if v>#a6 or not a6:sub(v,v):match("%d")then error("missing size for format option 'c'",2)end;while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if a7+S<a7 or a7+S>0xFFFFFFFF then error("bad argument #1 to 'pack' (format result too large)",2)end;local a0=expect(a8,select(a8,...),"string")a8=a8+1;if#a0>S then error(string.format("bad argument #%d to 'pack' (string longer than given size)",a8-1),2)end;if S>0 then for aa=0,S-1 do T[a7+aa]=a0:byte(aa+1)or 0 end;a7=a7+S end elseif a9=='z'then local a0=expect(a8,select(a8,...),"string")a8=a8+1;for ab in a0:gmatch"."do if ab=='\0'then error(string.format("bad argument #%d to 'pack' (string contains zeros)",a8-1),2)end end;for aa=0,#a0-1 do T[a7+aa]=a0:byte(aa+1)end;T[a7+#a0]=0;a7=a7+#a0+1 elseif a9=='s'then local S=0;while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 then error(string.format("integral size (%d) out of limits [1,16]",S),2)elseif S==0 then S=4 end;local a0=expect(a8,select(a8,...),"string")a8=a8+1;if#a0>=math.pow(2,S*8)then error(string.format("bad argument #%d to 'pack' (string length does not fit in given size)",a8-1),2)end;R(#a0,S,T,a7,1,W,false)for aa=S,#a0+S-1 do T[a7+aa]=a0:byte(aa-S+1)or 0 end;a7=a7+#a0+S elseif a9=='x'then T[a7]=0;a7=a7+1 elseif a9=='X'then if v>=#a6 then error("invalid next option for option 'X'",2)end;local S=0;local a9=a6:sub(v,v)v=v+1;if a9:lower()=='i'then while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 or S==0 then error(string.format("integral size (%d) out of limits [1,16]",S),2)end else S=a3(a9,0)end;if S<1 then error("invalid next option for option 'X'",2)end;if a7%math.min(S,V)~=0 and V>1 then for aa=1,V do if a7%math.min(S,V)==0 then break end;T[a7]=0;a7=a7+1 end end elseif a9~=' 'then error(string.format("invalid format option '%s'",a9),2)end end;return string.char(table.unpack(T))end;function string.packsize(a6)local a7=0;local V=1;local v=1;while v<=#a6 do local a9=a6:sub(v,v)v=v+1;if a9=='!'then local S=0;while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 then error(string.format("integral size (%d) out of limits [1,16]",S),2)elseif S==0 then V=4 else V=S end elseif G[a9]then local S=a3(a9,0)if a7%math.min(S,V)~=0 and V>1 then for aa=1,V do if a7%math.min(S,V)==0 then break end;a7=a7+1 end end;a7=a7+S elseif a9:lower()=='i'then local S=0;while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 then error(string.format("integral size (%d) out of limits [1,16]",S))elseif V>1 and(S~=1 and S~=2 and S~=4 and S~=8 and S~=16)then error("bad argument #1 to 'pack' (format asks for alignment not power of 2)",2)elseif S==0 then S=4 end;if a7%math.min(S,V)~=0 and V>1 then for aa=1,V do if a7%math.min(S,V)==0 then break end;a7=a7+1 end end;a7=a7+S elseif a9=='f'then if a7%math.min(4,V)~=0 and V>1 then for aa=1,V do if a7%math.min(4,V)==0 then break end;a7=a7+1 end end;a7=a7+4 elseif a9=='d'or a9=='n'then if a7%math.min(8,V)~=0 and V>1 then for aa=1,V do if a7%math.min(8,V)==0 then break end;a7=a7+1 end end;a7=a7+8 elseif a9=='c'then local S=0;if v>#a6 or not a6:sub(v,v):match("%d")then error("missing size for format option 'c'",2)end;while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if a7+S<a7 or a7+S>0x7FFFFFFF then error("bad argument #1 to 'packsize' (format result too large)",2)end;a7=a7+S elseif a9=='x'then a7=a7+1 elseif a9=='X'then if v>=#a6 then error("invalid next option for option 'X'",2)end;local S=0;local a9=a6:sub(v,v)v=v+1;if a9:lower()=='i'then while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 or S==0 then error(string.format("integral size (%d) out of limits [1,16]",S),2)end else S=a3(a9,0)end;if S<1 then error("invalid next option for option 'X'",2)end;if a7%math.min(S,V)~=0 and V>1 then for aa=1,V do if a7%math.min(S,V)==0 then break end;a7=a7+1 end end elseif a9=='s'or a9=='z'then error("bad argument #1 to 'packsize' (variable-length format)",2)elseif a9~=' 'and a9~='<'and a9~='>'and a9~='='then error(string.format("invalid format option '%s'",a9),2)end end;return a7 end;function string.unpack(a6,a0,a7)expect(1,a6,"string")expect(2,a0,"string")expect(3,a7,"number","nil")if a7 then if a7<0 then a7=#a0+a7 elseif a7==0 then error("bad argument #3 to 'unpack' (initial position out of string)",2)end;if a7>#a0 or a7<0 then error("bad argument #3 to 'unpack' (initial position out of string)",2)end else a7=1 end;local W=F.LITTLE_ENDIAN;local V=1;local a5={}local v=1;while v<=#a6 do local a9=a6:sub(v,v)v=v+1;if a9=='<'or a9=='='then W=F.LITTLE_ENDIAN elseif a9=='>'then W=F.BIG_ENDIAN elseif a9=='!'then local S=0;while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 then error(string.format("integral size (%d) out of limits [1,16]",S))elseif S==0 then V=4 else V=S end elseif G[a9]then if a7+a3(a9,0)>#a0+1 then error("data string too short",2)end;local u,ac=_(a0,a7,a3(a9,0),W,V,a9:match("%l")~=nil)a5[#a5+1]=u;a7=a7+ac elseif a9:lower()=='i'then local X=a9=='i'local S=0;while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 then error(string.format("integral size (%d) out of limits [1,16]",S),2)elseif S>8 then error(string.format("%d-byte integer does not fit into Lua Integer",S),2)elseif S==0 then S=4 end;if a7+S>#a0+1 then error("data string too short",2)end;local u,ac=_(a0,a7,S,W,V,X)a5[#a5+1]=u;a7=a7+ac elseif a9=='f'then if a7%math.min(4,V)~=0 and V>1 then for aa=1,V do if a7%math.min(4,V)==0 then break end;a7=a7+1 end end;if a7+4>#a0+1 then error("data string too short",2)end;local u=_(a0,a7,4,W,V,false)a5[#a5+1]=M(u)a7=a7+4 elseif a9=='d'or a9=='n'then if a7%math.min(8,V)~=0 and V>1 then for aa=1,V do if a7%math.min(8,V)==0 then break end;a7=a7+1 end end;if a7+8>#a0+1 then error("data string too short",2)end;local P,Q=0,0;for aa=0,3 do P=bit32.bor(P,bit32.lshift(a0:byte(a7+aa),(W==F.BIG_ENDIAN and 3-aa or aa)*8))end;for aa=0,3 do Q=bit32.bor(Q,bit32.lshift(a0:byte(a7+aa+4),(W==F.BIG_ENDIAN and 3-aa or aa)*8))end;if W==F.LITTLE_ENDIAN then P,Q=Q,P end;a5[#a5+1]=O(P,Q)a7=a7+8 elseif a9=='c'then local S=0;if v>#a6 or not a6:sub(v,v):match("%d")then error("missing size for format option 'c'",2)end;while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)")end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if a7+S>#a0+1 then error("data string too short",2)end;a5[#a5+1]=a0:sub(a7,a7+S-1)a7=a7+S elseif a9=='z'then local S=0;while a0:byte(a7+S)~=0 do S=S+1;if a7+S>#a0 then error("unfinished string for format 'z'",2)end end;a5[#a5+1]=a0:sub(a7,a7+S-1)a7=a7+S+1 elseif a9=='s'then local S=0;while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 then error(string.format("integral size (%d) out of limits [1,16]",S),2)elseif S==0 then S=4 end;if a7+S>#a0+1 then error("data string too short",2)end;local b,ad=_(a0,a7,S,W,V,false)a7=a7+ad;if a7+b>#a0+1 then error("data string too short",2)end;a5[#a5+1]=a0:sub(a7,a7+b-1)a7=a7+b elseif a9=='x'then a7=a7+1 elseif a9=='X'then if v>=#a6 then error("invalid next option for option 'X'",2)end;local S=0;local a9=a6:sub(v,v)v=v+1;if a9:lower()=='i'then while v<=#a6 and a6:sub(v,v):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(v,v))v=v+1 end;if S>16 or S==0 then error(string.format("integral size (%d) out of limits [1,16]",S),2)elseif S==-1 then S=4 end else S=a3(a9,0)end;if S<1 then error("invalid next option for option 'X'",2)end;if a7%math.min(S,V)~=0 and V>1 then for aa=1,V do if a7%math.min(S,V)==0 then break end;a7=a7+1 end end elseif a9~=' 'then error(string.format("invalid format option '%s'",a9),2)end end;a5[#a5+1]=a7;return table.unpack(a5)end end;function panic(ae)term.setBackgroundColor(32768)term.setTextColor(16384)term.setCursorBlink(false)local p,q=term.getCursorPos()p=1;local af,ag=term.getSize()ae="panic: "..(ae or"unknown")for ah in ae:gmatch"%S+"do if p+#ah>=af then p,q=1,q+1;if q>ag then term.scroll(1)q=q-1 end end;term.setCursorPos(p,q)if p==1 then term.clearLine()end;term.write(ah.." ")p=p+#ah+1 end;p,q=1,q+1;if q>ag then term.scroll(1)q=q-1 end;if debug then local ai=debug.traceback(nil,2)for aj in ai:gmatch"[^\n]+"do term.setCursorPos(1,q)term.write(aj)q=q+1;if q>ag then term.scroll(1)q=q-1 end end end;term.setCursorPos(1,q)term.setTextColor(2)term.write("panic: We are hanging here...")mainThread=nil;while true do coroutine.yield()end end;function do_syscall(ak,...)local u=table.pack(coroutine.yield("syscall",ak,...))if u[1]then return table.unpack(u,2,u.n)else error(u[2],3)end end;function deepcopy(al)if type(al)=="table"then local a5=setmetatable({},deepcopy(getmetatable(al)))for h,i in pairs(al)do a5[deepcopy(h)]=deepcopy(i)end;return a5 else return al end end;function split(a0,am)local y={}for an in a0:gmatch("[^"..(am or"%s").."]+")do y[#y+1]=an end;return y end;local ao=pcall(os.epoch,"nano")and function()return os.epoch"nano"/1000000 end or(ccemux and function()return ccemux.nanoTime()/1000000 end or function()return os.epoch"utc"end)local ap={n=0}function executeThread(process,aq,ar,as,at)local args;if aq.status=="starting"then args=aq.args elseif aq.status=="syscall"then args=table.pack(table.unpack(aq.syscall_return,3,aq.syscall_return.n))elseif aq.status=="preempt"then args=ap elseif aq.status=="suspended"then args={ar[1],deepcopy(ar[2])}elseif aq.status=="paused"then return false,at end;if aq.status~="dead"and(not aq.filter or aq.filter(process,aq,ar))then local au=as;as=false;aq.filter=nil;local av;if aq.yielding then av={n=aq.syscall_return.n,true,"syscall",aq.yielding,table.unpack(aq.syscall_return,4,aq.syscall_return.n)}aq.yielding=nil else local aw=globalMetatables;globalMetatables=process.globalMetatables;updateGlobalMetatables()local ax=ao()av=table.pack(coroutine.resume(aq.coro,table.unpack(args,1,args.n)))process.cputime=process.cputime+(ao()-ax)/1000;globalMetatables=aw;updateGlobalMetatables()end;if av[2]=="syscall"then aq.status="syscall"local ay=at;at=false;if av[3]and syscalls[av[3]]then local ax=ao()aq.syscall_return=table.pack(coroutine.resume(aq.syscall,av[3],process,aq,table.unpack(av,4,av.n)))process.systime=process.systime+(ao()-ax)/1000;if aq.syscall_return[2]==kSyscallComplete then if not aq.syscall_return[3]and type(aq.syscall_return[4])=="string"then syslog.log({level="debug",category="Syscall Failure",process=0,module=av[3]},aq.syscall_return[4])aq.syscall_return[4]=aq.syscall_return[4]:gsub("kernel:%d+: ","")end;if aq.syscall_return[4]==kSyscallYield then aq.yielding=aq.syscall_return[5]at=ay end else aq.yielding=av[3]end else aq.syscall_return={false,"No such syscall",n=2}end elseif av[2]=="preempt"then aq.status="preempt"at=false elseif coroutine.status(aq.coro)=="dead"then aq.status="dead"aq.return_value=av[2]if av[1]then process.lastReturnValue={pid=process.id,thread=aq.id,value=av[2],n=av.n-1,table.unpack(av,2,av.n)}else process.lastReturnValue={pid=process.id,thread=aq.id,error=av[2],traceback=debug.traceback(aq.coro)}end;if not av[1]then aq.did_error=true;syslog.log({level=_G.args.traceback and"error"or"debug",process=process.id,thread=aq.id,category="Application Error",traceback=true},debug.traceback(aq.coro,av[2]))if av[2]and process.stderr and process.stderr.isTTY then terminal.write(process.stderr,av[2].."\n")end end;process.threads[aq.id]=nil;as=au else aq.status="suspended"at=at and#process.eventQueue==0 end end;return as,at end;mainThread=coroutine.running()function userModeCallback(process,az,...)local aA=syscalls.newthread(process,nil,az,...)local aq=process.threads[aA]while aq.status~="dead"do if coroutine.running()==mainThread then error("userModeCallback not called from a yieldable context",2)end;coroutine.yield()end;syslog.log({level="debug",process=process.id,thread=aA},"Usermode callback completed")return not aq.did_error,aq.return_value end;function make_ENV(e)if type(e)~="table"or _VERSION~="Lua 5.1"then return e end;repeat local aB=getmetatable(e)if aB and aB.__env then e=aB.__env end until not aB or not aB.__env;local y=setmetatable({},{__index=function(self,aC)if self==e then e=getmetatable(self).__env end;if aC=="_ENV"then return e else return e[aC]end end,__newindex=function(self,aC,aD)if self==e then e=getmetatable(self).__env end;if aC=="_ENV"then e=aD else e[aC]=aD end end,__pairs=function(self)if self==e then e=getmetatable(self).__env end;return next,e end,__len=function(self)if self==e then e=getmetatable(self).__env end;return#e end,__env=e})return y end;for z,i in ipairs({...})do local aE,aF=i:match("^([^=]+)=(.+)$")if aE and aF then if type(args[aE])=="boolean"then args[aE]=aF:lower()=="true"or aF=="1"elseif type(args[aE])=="number"then args[aE]=tonumber(aF)else args[aE]=aF end elseif aE=="silent"then args.loglevel=5 elseif aE=="quiet"then args.loglevel=3 end end;local function aG(aH)local u;if _CC_VERSION then u=aH<=_CC_VERSION elseif not _HOST then u=aH<=os.version():gsub("CraftOS ","")elseif _HOST:match("ComputerCraft 1%.1%d+")~=aH:match("1%.1%d+")then aH=aH:gsub("(1%.)([02-9])","%10%2")local aI=_HOST:gsub("(ComputerCraft 1%.)([02-9])","%10%2")u=aH<=aI:match("ComputerCraft ([0-9%.]+)")else u=aH<=_HOST:match("ComputerCraft ([0-9%.]+)")end;return u end;if not aG"1.87.0"then panic("Phoenix requires ComputerCraft 1.87.0 or later. Please upgrade your version of ComputerCraft.")end;if jit and args.preemptive then panic("Phoenix does not support preemption when running under LuaJIT. Please set preemptive to false in the kernel arguments.")end;if not debug and args.preemptive then panic("Phoenix does not support preemption without the debug API. Please set preemptive to false in the kernel arguments.")end;if args.preemptive then PHOENIX_BUILD=PHOENIX_BUILD.." PREEMPT"end;if not getfenv then if not debug then panic("Phoenix requires the debug API when running under Lua 5.2 and later.")end;function getfenv(g)local v=1;while true do local m,aD=debug.getupvalue(g,v)if m=="_ENV"then return aD elseif not m then break end;v=v+1 end end;function setfenv(g,e)local v=1;while true do local m=debug.getupvalue(g,v)if m=="_ENV"then debug.upvaluejoin(g,v,function()return e end,1)break elseif not m then break end;v=v+1 end;return g end end;globalMetatables={["nil"]={},["boolean"]={},["number"]={},["string"]={__index=string},["function"]={},["thread"]={__index=coroutine,__call=coroutine.resume},["userdata"]={}}local aJ,aK=debug.getmetatable,debug.setmetatable;function updateGlobalMetatables()aK(nil,globalMetatables["nil"])aK(false,globalMetatables["boolean"])aK(0,globalMetatables["number"])aK("",globalMetatables["string"])aK(assert,globalMetatables["function"])aK(coroutine.running(),globalMetatables["thread"])if debug.upvalueid then aK(debug.upvalueid(executeThread,1),globalMetatables["userdata"])end end;local type=type;function debug.getmetatable(aD)if type(aD)=="table"then return aJ(aD)else return globalMetatables[type(aD)]end end;function debug.setmetatable(aD,al)expect(2,al,"table")if type(aD)=="table"then return aK(aD,al)else globalMetatables[type(aD)]=al end end;do local aL;local aM,aN,aO,aP,aQ,aR,aS,aT,aU=getfenv,setfenv,debug.getfenv,debug.getlocal,debug.getupvalue,debug.setfenv,debug.setlocal,debug.setupvalue,debug.upvaluejoin;local error,aV,aW,select,setmetatable,type,tonumber=error,debug.getinfo,coroutine.running,select,setmetatable,type,tonumber;local aX;local function keys(y,i,...)if i then y[i]=true end;if select("#",...)>0 then return keys(y,...)else return y end end;local function aY(i,...)if select("#",...)>0 then return aX[i or""]or i,aY(...)else return aX[i or""]or i end end;local function aZ(r)r=bit32.band(tonumber(r),0xFFFFFFFF)if bit32.btest(r,0x80000000)then r=r-0x100000000 end;return r end;function debug.getinfo(aq,az,a_)if type(aq)~="thread"then a_,az,aq=az,aq,aW()end;local a5;if tonumber(az)then a5=aV(aq,az+1,a_)else a5=aV(aq,az,a_)end;if a5 and a5.func then a5.func=aX[a5.func]or a5.func end;return a5 end;function debug.getlocal(aq,b0,b1)if b1==nil then b1,b0,aq=b0,aq,aW()end;local h,i;if type(b0)=="function"then local b2=aV(2,"f")if aL[b0]and not(b2 and aL[b0][b2.func])then return nil end;h,i=aY(aP(b0,b1))elseif tonumber(b0)then local b3=aV(aq,b0+1,"f")local b2=aV(2,"f")if b3 and aL[b3.func]and not(b2 and aL[b3.func][b2.func])then return nil end;h,i=aY(aP(aq,b0+1,b1))else h,i=aY(aP(aq,b0,b1))end;return h,i end;function debug.getupvalue(az,b4)if type(az)=="function"then local b2=aV(2,"f")if aL[az]and not(b2 and aL[az][b2.func])then return nil end end;local h,i=aY(aQ(az,b4))return h,i end;function debug.setlocal(aq,b0,b1,aF)if b1==nil then b1,b0,aq=b0,aq,aW()end;if tonumber(b0)then local b3=aV(aq,b0+1,"f")local b2=aV(2,"f")if b3 and aL[b3.func]and not(b2 and aL[b3.func][b2.func])then error("attempt to set local of protected function",2)end;aS(aq,b0+1,b1,aF)else aS(aq,b0,b1,aF)end end;function debug.setupvalue(az,b4,aF)if type(az)=="function"then local b2=aV(2,"f")if aL[az]and not(b2 and aL[az][b2.func])then error("attempt to set upvalue of protected function",2)end end;aT(az,b4,aF)end;function _G.getfenv(f)local i;if f==nil then i=aM(2)elseif tonumber(f)and aZ(f)>0 then local b3=aV(f+1,"f")local b2=aV(2,"f")if b3 and aL[b3.func]and not(b2 and aL[b3.func][b2.func])then return nil end;i=aM(f+1)elseif type(f)=="function"then local b2=aV(2,"f")if aL[f]and not(b2 and aL[f][b2.func])then return nil end;i=aM(f)else i=aM(f)end;return i end;function _G.setfenv(f,al)if tonumber(f)and aZ(f)>0 then local b3=aV(f+1,"f")local b2=aV(2,"f")if b3 and aL[b3.func]and not(b2 and aL[b3.func][b2.func])then error("attempt to set environment of protected function",2)end;aN(f+1,al)elseif type(f)=="function"then local b2=aV(2,"f")if aL[f]and not(b2 and aL[f][b2.func])then error("attempt to set environment of protected function",2)end end;aN(f,al)end;if aO then function debug.getfenv(b5)if type(b5)=="function"then local b2=aV(2,"f")if aL[b5]and not(b2 and aL[b5][b2.func])then return nil end end;local i=aO(b5)return i end;function debug.setfenv(b5,al)if type(b5)=="function"then local b2=aV(2,"f")if aL[b5]and not(b2 and aL[b5][b2.func])then error("attempt to set environment of protected function",2)end end;aR(b5,al)end end;if aU then function debug.upvaluejoin(b6,b7,b8,b9)if type(b6)=="function"and type(b8)=="function"then local b2=aV(2,"f")if aL[b6]and not(b2 and aL[b6][b2.func])then error("attempt to get upvalue of protected function",2)end;if aL[b8]and not(b2 and aL[b8][b2.func])then error("attempt to set upvalue of protected function",2)end end;aU(b6,b7,b8,b9)end end;function debug.protect(az)if type(az)~="function"then error("bad argument #1 (expected function, got "..type(az)..")",2)end;if aL[az]then error("attempt to protect a protected function",2)end;aL[az]=keys(setmetatable({},{__mode="k"}))end;aX={[aP]=debug.getlocal,[aS]=debug.setlocal,[aQ]=debug.getupvalue,[aT]=debug.setupvalue,[aV]=debug.getinfo,[aY]=function()end}if debug.upvaluejoin then aX[aU]=debug.upvaluejoin end;if debug.getfenv then aX[aO]=debug.getfenv end;if debug.setfenv then aX[aR]=debug.setfenv end;if _G.getfenv then aX[aM]=_G.getfenv end;if _G.setfenv then aX[aN]=_G.setfenv end;aL=keys(setmetatable({},{__mode="k"}),getfenv,setfenv,debug.getfenv,debug.setfenv,debug.getlocal,debug.setlocal,debug.getupvalue,debug.setupvalue,debug.upvaluejoin,debug.getinfo,aY,debug.protect)for h,i in pairs(aL)do aL[h]={}end end;fs=fs;mounts={}fifos={}filesystems={craftos={meta={meta={type="directory",owner="root",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}},metapath="/meta.ltn",lastDispatch=0},tmpfs={},drivefs={},tablefs={},bind={}}local function ba(process,bb)local E=fs.combine(process.root,bb:sub(1,1)=="/"and""or process.dir,bb)if"/"..E.."/"~=process.root and E:find(process.root:sub(2),1,true)~=1 then error(bb..": No such file or directory",4)end;return E end;local function bc(process,bb)local bd=split(ba(process,bb),"/\\")if#bd==0 then return mounts[""],bb,""end;local be;for h in pairs(mounts)do local bf=true;for v,a9 in ipairs(split(h,"/\\"))do if bd[v]~=a9 then bf=false;break end end;if bf and(not be or#h>#be)then be=h end end;if not be then panic("Could not find mount for path "..bb..". Where is root?")end;local bg=split(be,"/\\")local E=#bd>=#bg+1 and fs.combine(table.unpack(bd,#bg+1,#bd))or""return mounts[be],E,be end;function filesystem.readhandle(process,bh,bi)local a7=1;local bj=false;local y={readLine=function(bk)if bj then error("attempt to use a closed file",2)end;if a7>#bh then return nil end;local bl;bl,a7=bh:match("([^\n]*"..(bk and"\n?)"or")\n?").."()",a7)return bl end,readAll=function()if bj then error("attempt to use a closed file",2)end;if a7>#bh then return nil end;local bl=bh:sub(a7)a7=#bl+1;return bl end,read=function(r)if bj then error("attempt to use a closed file",2)end;if r~=nil and type(r)~="number"then error("bad argument #1 (expected number, got "..type(r)..")",2)end;r=r or 1;if a7>#bh then return nil end;local bl=bh:sub(a7,a7+r-1)a7=a7+r;return bl end,close=function()if bj then error("attempt to use a closed file",2)end;bj=true end}if bi then y.read=function(r)if bj then error("attempt to use a closed file",2)end;if r~=nil and type(r)~="number"then error("bad argument #1 (expected number, got "..type(r)..")",2)end;if a7>#bh then return nil end;if r then local bl=bh:sub(a7,a7+r-1)a7=a7+r;return bl else local bl=bh:byte(a7)a7=a7+1;return bl end end;y.seek=function(bm,U)if bm~=nil and type(bm)~="string"then error("bad argument #1 (expected string, got "..type(bm)..")",2)end;if U~=nil and type(U)~="number"then error("bad argument #2 (expected number, got "..type(U)..")",2)end;bm=bm or"cur"U=U or 0;if bj then error("attempt to use closed file",2)end;if bm=="set"then a7=U+1 elseif bm=="cur"then a7=a7+U elseif bm=="end"then a7=math.max(#bh-U,1)else error("Invalid whence",2)end;return a7-1 end else bh=bh:gsub("[\x80-\xFF]+",function(bn)local bo=""if not pcall(function()for z,bp in utf8.codes(bn)do bo=bo..(bp<256 and string.char(bp)or"?")end end)then return bn end;return bo end)end;for z,i in pairs(y)do setfenv(i,process.env)debug.protect(i)end;return setmetatable(y,{__name="file"})end;function filesystem.writehandle(process,bq,bi)local function br(y)for z,i in pairs(y)do setfenv(i,process.env)debug.protect(i)end;return setmetatable(y,{__name="file"})end;local bj=false;if bi then local a7=1;local bs=""local bt=""return br{write=function(bl)if bj then error("attempt to use a closed file",2)end;if type(bl)=="number"then bs,a7=bs:sub(1,a7-1)..string.char(bl)..bs:sub(a7+1),a7+1;if bt then bt=bt..string.char(bl)end elseif type(bl)=="string"then bs,a7=bs:sub(1,a7-1)..bl..bs:sub(a7+#bl),a7+#bl;if bt then bt=bt..bl end else error("bad argument #1 (expected string or number, got "..type(bl)..")",2)end end,writeLine=function(bl)if bj then error("attempt to use a closed file",2)end;if type(bl)=="number"then bs,a7=bs:sub(1,a7-1)..string.char(bl).."\n"..bs:sub(a7+2),a7+2;if bt then bt=bt..string.char(bl).."\n"end elseif type(bl)=="string"then bs,a7=bs:sub(1,a7-1)..bl.."\n"..bs:sub(a7+#bl+1),a7+#bl+1;if bt then bt=bt..bl.."\n"end else error("bad argument #1 (expected string or number, got "..type(bl)..")",2)end end,seek=function(bm,U)if bm~=nil and type(bm)~="string"then error("bad argument #1 (expected string, got "..type(bm)..")",2)end;if U~=nil and type(U)~="number"then error("bad argument #2 (expected number, got "..type(U)..")",2)end;bm=bm or"cur"U=U or 0;if bj then error("attempt to use closed file",2)end;local bu=a7;if bm=="set"then a7=U+1 elseif bm=="cur"then a7=a7+U elseif bm=="end"then a7=math.max(#bs-U,1)else error("Invalid whence",2)end;if bu~=a7 then bt=nil end;return a7-1 end,flush=function()if bj then error("attempt to use a closed file",2)end;if bt then bq(bt,false)else bq(bs,true)end;bt=""end,close=function()if bj then error("attempt to use a closed file",2)end;bj=true;if bt then bq(bt,false)else bq(bs,true)end;bt=""end}else local bs=""return br{write=function(bl)if bj then error("attempt to use a closed file",2)end;bs=bs..tostring(bl)end,writeLine=function(bl)if bj then error("attempt to use a closed file",2)end;bs=bs..tostring(bl).."\n"end,flush=function()if bj then error("attempt to use a closed file",2)end;bq(bs,false)bs=""end,close=function()if bj then error("attempt to use a closed file",2)end;bq(bs,false)bs=""bj=true end}end end;function filesystem.fifohandle(process,bv,n)local bj=false;local function br(y)for z,i in pairs(y)do setfenv(i,process.env)debug.protect(i)end;return setmetatable(y,{__name="file"})end;if n=="r"then return br{readLine=function(bk)if bj then error("attempt to use a closed file",2)end;if#bv.data==0 then return nil end;local bl;bl,bv.data=bv.data:match("([^\n]*"..(bk and"\n?)"or")\n?").."(.*)")return bl end,readAll=function()if bj then error("attempt to use a closed file",2)end;if#bv.data==0 then return nil end;local bl=bv.data;bv.data=""return bl end,read=function(r)if bj then error("attempt to use a closed file",2)end;if r~=nil and type(r)~="number"then error("bad argument #1 (expected number, got "..type(r)..")",2)end;r=r or 1;if#bv.data==0 then return nil end;local bl=bv.data:sub(1,r)bv.data=bv.data:sub(r+1)return bl end,close=function()if bj then error("attempt to use a closed file",2)end;bj=true end}elseif n=="w"or n=="a"then local bs=bv.data;return br{write=function(bl)if bj then error("attempt to use a closed file",2)end;bs=bs..tostring(bl)end,writeLine=function(bl)if bj then error("attempt to use a closed file",2)end;bs=bs..tostring(bl).."\n"end,flush=function()if bj then error("attempt to use a closed file",2)end;bv.data=bs end,close=function()if bj then error("attempt to use a closed file",2)end;bv.data=bs;bj=true end}elseif n=="rb"then return br{readLine=function(bk)if bj then error("attempt to use a closed file",2)end;if#bv.data==0 then return nil end;local bl;bl,bv.data=bv.data:match("([^\n]*"..(bk and"\n?)"or")\n?").."(.*)")return bl end,readAll=function()if bj then error("attempt to use a closed file",2)end;if#bv.data==0 then return nil end;local bl=bv.data;bv.data=""return bl end,read=function(r)if bj then error("attempt to use a closed file",2)end;if r~=nil and type(r)~="number"then error("bad argument #1 (expected number, got "..type(r)..")",2)end;if#bv.data==0 then return nil end;if r then local bl=bv.data:sub(1,r)bv.data=bv.data:sub(r+1)return bl else local bl=bv.data:byte()bv.data=bv.data:sub(2)return bl end end,seek=function(bm,U)if bm~=nil and type(bm)~="string"then error("bad argument #1 (expected string, got "..type(bm)..")",2)end;if U~=nil and type(U)~="number"then error("bad argument #2 (expected number, got "..type(U)..")",2)end;if bj then error("attempt to use closed file",2)end;return 0 end,close=function()if bj then error("attempt to use a closed file",2)end;bj=true end}elseif n=="wb"or n=="ab"then local bs=bv.data;return br{write=function(bl)if bj then error("attempt to use a closed file",2)end;if type(bl)=="number"then bs=bs..string.char(bl)elseif type(bl)=="string"then bs=bs..bl else error("bad argument #1 (expected string or number, got "..type(bl)..")",2)end end,writeLine=function(bl)if bj then error("attempt to use a closed file",2)end;if type(bl)=="number"then bs=bs..string.char(bl).."\n"elseif type(bl)=="string"then bs=bs..bl.."\n"else error("bad argument #1 (expected string or number, got "..type(bl)..")",2)end end,seek=function(bm,U)if bm~=nil and type(bm)~="string"then error("bad argument #1 (expected string, got "..type(bm)..")",2)end;if U~=nil and type(U)~="number"then error("bad argument #2 (expected number, got "..type(U)..")",2)end;if bj then error("attempt to use closed file",2)end;return#bv.data+#bs end,flush=function()if bj then error("attempt to use a closed file",2)end;bv.data=bs end,close=function()if bj then error("attempt to use a closed file",2)end;bv.data=bs;bj=true end}else return nil,"Invalid mode"end end;filesystem.openfifo=filesystem.fifohandle;do local a=fs.open("/meta.ltn","r")if a then filesystems.craftos.meta=unserialize(a.readAll())or filesystems.craftos.meta;filesystems.craftos.lastDispatch=os.epoch"utc"a.close()end end;shutdownHooks[#shutdownHooks+1]=function()syslog.log("Syncing filesystem")local a=fs.open(filesystems.craftos.metapath,"w")if a then a.write(serialize(filesystems.craftos.meta,{compact=true}))a.close()end end;if args.fsmeta then local a=fs.open(args.fsmeta,"r")if a then local bw=unserialize(a.readAll())a.close()if bw then local function bx(by,bz)for h,i in pairs(by)do if bz[h]and type(bz[h])=="table"and type(i)=="table"then bx(i,bz[h])else bz[h]=i end end end;bx(bw,filesystems.craftos.meta)end end end;function filesystems.craftos:getmeta(user,bb,bA)local bB={}local y=self.meta;local bg=split(bb,"/\\")for v,E in ipairs(bg)do if E==".."then y=table.remove(bB)if not y then return nil end elseif not E:match"^%.*$"then if not y then return nil elseif y.meta.type~="directory"then error("Not a directory",2)elseif y.meta.permissions[user]then if not y.meta.permissions[user].execute then error("Permission denied",2)end elseif not y.meta.worldPermissions.execute then error("Permission denied",2)end;bB[#bB+1]=y;y=y.contents[E]if y and y.meta.type=="link"and not(bA and v==#bg)then syslog.debug("linking "..bb.." to "..filesystem.combine(y.meta.link,table.unpack(bg,v+1)))error{link=true,path=filesystem.combine(y.meta.link,table.unpack(bg,v+1)),orig=bb}end end end;return y and y.meta end;function filesystems.craftos:setmeta(user,bb,bw,bA)local bB={}local y=self.meta;local m;local bg=split(bb,"/\\")for v,E in ipairs(bg)do if E==".."then y=table.remove(bB)if not y then error("Not a directory",2)end elseif not E:match"^%.*$"then if y.meta.type~="directory"then error("Not a directory",2)elseif y.meta.permissions[user]then if not y.meta.permissions[user].execute then error("Permission denied",2)end elseif not y.meta.worldPermissions.execute then error("Permission denied",2)end;if not y.contents[E]then y.contents[E]={meta={type="directory",owner=y.meta.owner or"root",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}}end;bB[#bB+1]=y;y=y.contents[E]m=E;if y and y.meta.type=="link"and not(bA and v==#bg)then syslog.debug("linking "..bb.." to "..filesystem.combine(y.meta.link,table.unpack(bg,v+1)))error{link=true,path=filesystem.combine(y.meta.link,table.unpack(bg,v+1)),orig=bb}end end end;if bw~=nil then y.meta={type=bw.type,owner=bw.owner,permissions=deepcopy(bw.permissions),worldPermissions=deepcopy(bw.worldPermissions),setuser=bw.setuser,link=bw.link}if bw.type~="directory"then y.contents=nil end else bB[#bB].contents[m]=nil end;if os.epoch"utc"-self.lastDispatch>1000 then local a=assert(fs.open(self.metapath,"w"))a.write(serialize(self.meta,{compact=true}))a.close()self.lastDispatch=os.epoch"utc"end end;function filesystems.craftos:new(process,bb,bC)expect.field(bC,"ro","boolean","nil")if process.user~="root"then error("Could not mount "..bb..": Permission denied",3)elseif not fs.isDir(bb)then error("Could not mount "..bb..": No such directory",3)end;return setmetatable({path=bb,readOnly=bC.ro},{__index=self})end;function filesystems.craftos:open(process,bb,n)local bf,bD=pcall(self.stat,self,process,bb)if not bf then if type(bD)=="table"then error(bD)end;return nil,bD elseif not bD then if n:sub(1,1)=="w"or n:sub(1,1)=="a"then if self.readOnly then return nil,"Read-only filesystem"end;local bE,bF=pcall(self.stat,self,process,fs.getDir(bb))if not bE or not bF then if type(bF)=="table"then error(bF)end;local bG,o=pcall(self.mkdir,self,process,fs.getDir(bb))if not bG then if type(o)=="table"then error(o)end;return nil,o:gsub("kernel:%d: ","")end;bF=self:stat(process,fs.getDir(bb))if not bF then return nil,"Could not stat "..fs.getDir(bb)end end;if process.user~="root"then local bH=bF.permissions[process.user]or bF.worldPermissions;if not bH.write then return nil,"Permission denied"end end;local bw={type="file",owner=process.user,permissions=deepcopy(bF.permissions),worldPermissions=deepcopy(bF.worldPermissions),setuser=false}if bF.owner then local y=bw.permissions[bF.owner]bw.permissions[bF.owner]=nil;bw.permissions[process.user]=y end;self:setmeta(process.user,fs.combine(self.path,bb),bw)local a,o=fs.open(fs.combine(self.path,bb),n)if not a then return a,o end;return setmetatable(a,{__name="file"})else return nil,"File not found"end elseif bD.type=="directory"then return nil,"Is a directory"end;local bH=bD.permissions[process.user]or bD.worldPermissions;if n:sub(1,1)=="r"and not bH.read or(n:sub(1,1)=="w"or n:sub(1,1)=="a")and not bH.write then return nil,"Permission denied"end;if bD.type=="fifo"then local bw=self:getmeta(process.user,fs.combine(self.path,bb))local bI=fifos[bw]if not bI then bI={data=""}fifos[bw]=bI end;return filesystem.fifohandle(process,bI,n)end;return setmetatable(fs.open(fs.combine(self.path,bb),n),{__name="file"})end;function filesystems.craftos:list(process,bb)local bD=self:stat(process,bb)if not bD or bD.type~="directory"then error(bb..": Not a directory",2)end;if process.user~="root"then local bH=bD.permissions[process.user]or bD.worldPermissions;if not bH.read then error(bb..": Permission denied",2)end end;return fs.list(fs.combine(self.path,bb))end;function filesystems.craftos:stat(process,bb,bA)local E=fs.combine(self.path,bb)if E:find(self.path:gsub("^/",""):gsub("/$",""),1,false)~=1 then return nil end;local bf,bJ=pcall(fs.attributes,E)if not bf or not bJ then return nil end;bJ.type=bJ.isDir and"directory"or"file"bJ.special={}bJ.isDir=nil;if not bJ.modified then bJ.modified=bJ.modification end;bJ.modification=nil;bJ.capacity=fs.getCapacity(E)or 0;bJ.freeSpace=fs.getFreeSpace(E)local bK=bJ.isReadOnly;bJ.isReadOnly=nil;local bw=self:getmeta(process.user,fs.combine(self.path,bb),bA)if bw then bJ.owner=bw.owner;bJ.permissions=deepcopy(bw.permissions)bJ.worldPermissions=deepcopy(bw.worldPermissions)bJ.type=bw.type or bJ.type;bJ.setuser=bw.setuser;bJ.link=bw.link else bJ.owner="root"bJ.permissions={root={read=true,write=true,execute=true}}bJ.worldPermissions={read=true,write=false,execute=true}bJ.setuser=false end;if bK then bJ.worldPermissions.write=false;for z,i in pairs(bJ.permissions)do i.write=false end end;return bJ end;function filesystems.craftos:remove(process,bb)if self.readOnly then error(bb..": Read-only filesystem",2)end;local bD=self:stat(process,bb,true)if not bD then return end;local function bL(E)local bn=self:stat(process,E,true)local bH=bn.permissions[process.user]or bn.worldPermissions;if process.user~="root"and not bH.write then error(E..": Permission denied",3)end;if bn.type=="directory"then if process.user~="root"and not bH.read then error(E..": Permission denied",3)end;for z,i in ipairs(fs.list(fs.combine(self.path,E)))do bL(fs.combine(E,i))end end end;bL(bb)fs.delete(fs.combine(self.path,bb))self:setmeta(process.user,fs.combine(self.path,bb),nil,true)end;function filesystems.craftos:rename(process,bM,bN)if self.readOnly then error("Read-only filesystem",2)end;local bO=self:stat(process,bM,true)local bP=self:stat(process,bN,true)if not bO then error(bM..": No such file or directory",2)elseif bP then error(bN..": "..bP.type:gsub("%w",string.upper,1).." already exists",2)end;bP=self:stat(process,fs.getDir(bN))if not bP then self:mkdir(process,fs.getDir(bN))bP=self:stat(process,fs.getDir(bN))end;if process.user~="root"then local bH=bP.permissions[process.user]or bP.worldPermissions;if not bH.write then error(bN..": Permission denied",2)end end;fs.move(fs.combine(self.path,bM),fs.combine(self.path,bN))self:setmeta(process.user,fs.combine(self.path,bN),self:getmeta(process.user,fs.combine(self.path,bM),true),true)self:setmeta(process.user,fs.combine(self.path,bM),nil,true)end;function filesystems.craftos:mkdir(process,bb)if self.readOnly then error(bb..": Read-only filesystem",2)end;local bD=self:stat(process,bb)if bD then if bD.type=="directory"then return else error(bb..": File already exists",2)end end;local bg=split(bb,"/\\")local v=#bg;repeat v=v-1;bD=self:stat(process,table.concat(bg,"/",1,v))if bD then if bD.type=="directory"then break else error(bb..": File already exists",2)end end until bD or v<=0;if not bD then if bb:match"^/"then bD=assert(self:stat(process,"/"))else bD=assert(filesystem.stat(process,process.dir))end end;if process.user~="root"then local bH=bD.permissions[process.user]or bD.worldPermissions;if not bH.write then error(bb..": Permission denied",2)end end;local bw={type="directory",owner=process.user,permissions=deepcopy(bD.permissions),worldPermissions=deepcopy(bD.worldPermissions)}if bD.owner then local y=bw.permissions[bD.owner]bw.permissions[bD.owner]=nil;bw.permissions[process.user]=y end;v=v+1;while v<=#bg do self:setmeta(process.user,fs.combine(self.path,table.concat(bg,"/",1,v)),deepcopy(bw))v=v+1 end;fs.makeDir(fs.combine(self.path,bb))end;function filesystems.craftos:link(process,bb,bQ)local bD=self:stat(process,bb)if bD then error(bb..": File exists",2)end;assert(self:open(process,bb,"w")).close()local bw=self:getmeta(process.user,fs.combine(self.path,bb),true)bw.type,bw.link="link",bQ;self:setmeta(process.user,fs.combine(self.path,bb),bw,true)end;function filesystems.craftos:mkfifo(process,bb)local bD=self:stat(process,bb)if bD then error(bb..": File exists",2)end;assert(self:open(process,bb,"w")).close()local bw=self:getmeta(process.user,fs.combine(self.path,bb),true)bw.type="fifo"self:setmeta(process.user,fs.combine(self.path,bb),bw,true)end;function filesystems.craftos:chmod(process,bb,user,n)if self.readOnly then error(bb..": Read-only filesystem",2)end;local bD=self:stat(process,bb,true)if not bD then error(bb..": No such file or directory",2)end;if not bD.owner or process.user~="root"and process.user~=bD.owner then error(bb..": Permission denied",2)end;local bH;if user==nil then bH=bD.worldPermissions else bH=bD.permissions[user]if not bH then bH=deepcopy(bD.worldPermissions)bD.permissions[user]=bH end end;if type(n)=="string"then if n:match"^[%+%-=][rwxs]+$"then local A=n:sub(1,1)local y={}for a9 in n:gmatch("[rwxs]")do if a9=="r"then y.read=true elseif a9=="w"then y.write=true elseif a9=="s"then y.setuser=true else y.execute=true end end;if A=="+"then if y.read then bH.read=true end;if y.write then bH.write=true end;if y.execute then bH.execute=true end;if y.setuser then bD.setuser=true end elseif A=="-"then if y.read then bH.read=false end;if y.write then bH.write=false end;if y.execute then bH.execute=false end;if y.setuser then bD.setuser=false end else bH.read=y.read or false;bH.write=y.write or false;bH.execute=y.execute or false;bD.setuser=y.setuser or false end else bH.read=n:sub(1,1)~="-"bH.write=n:sub(2,2)~="-"bH.execute=n:sub(3,3)~="-"bD.setuser=n:sub(3,3)=="s"end elseif type(n)=="number"then bD.setuser=bit32.btest(n,8)bH.read=bit32.btest(n,4)bH.write=bit32.btest(n,2)bH.execute=bit32.btest(n,1)else if n.read~=nil then bH.read=n.read end;if n.write~=nil then bH.write=n.write end;if n.execute~=nil then bH.execute=n.execute end;if n.setuser~=nil then bD.setuser=n.setuser end end;self:setmeta(process.user,fs.combine(self.path,bb),deepcopy(bD),true)end;function filesystems.craftos:chown(process,bb,bR)if self.readOnly then error(bb..": Read-only filesystem",2)end;local bD=self:stat(process,bb,true)if not bD then error(bb..": No such file or directory",2)end;if not bD.owner or process.user~="root"and process.user~=bD.owner then error(bb..": Permission denied",2)end;bD.owner=bR;bD.setuser=false;self:setmeta(process.user,fs.combine(self.path,bb),deepcopy(bD),true)end;function filesystems.craftos:info()return"craftos",self.path,{ro=self.readOnly}end;function filesystems.tmpfs:getpath(user,bb,bA)local y=self;local bg=split(bb,"/\\")for v,E in ipairs(bg)do if not y then return nil elseif y.type~="directory"then error("Not a directory",2)elseif y.permissions[user]then if not y.permissions[user].execute then error("Permission denied",2)end elseif not y.worldPermissions.execute then error("Permission denied",2)end;y=y.contents[E]if y and y.type=="link"and not(bA and v==#bg)then error{link=true,path=filesystem.combine(y.link,table.unpack(bg,v+1)),orig=bb}end end;return y end;function filesystems.tmpfs:setpath(user,bb,bh,bA)local y=self;local K=split(bb,"/\\")local bS=K[#K]K[#K]=nil;for v,E in ipairs(K)do if y.type~="directory"then error("Not a directory",2)elseif y.permissions[user]then if not y.permissions[user].execute then error("Permission denied",2)end elseif not y.worldPermissions.execute then error("Permission denied",2)end;if not y.contents[E]then y.contents[E]={type="directory",owner=y.owner,permissions=deepcopy(y.permissions),worldPermissions=deepcopy(y.worldPermissions),setuser=false,created=os.epoch"utc",modified=os.epoch"utc",contents={}}end;y=y.contents[E]if y and y.type=="link"then error{link=true,path=filesystem.combine(y.link,table.unpack(K,v+1)),orig=bb}end end;if y.type~="directory"then error("Not a directory",2)elseif user~="root"then if y.permissions[user]then if not y.permissions[user].execute then error("Permission denied",2)end elseif not y.worldPermissions.execute then error("Permission denied",2)end end;if not bA and y.contents[bS]and y.contents[bS].type=="link"then error{link=true,path=y.contents[bS].link,orig=bb}end;y.contents[bS]=bh end;function filesystems.tmpfs:new(process,by,bC)return setmetatable({type="directory",owner=process.user,permissions={[process.user]={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false,created=os.epoch"utc",modified=os.epoch"utc",contents={}},{__index=self})end;function filesystems.tmpfs:_open_internal(process,bb,n)local bT=os.epoch;local bh=self:getpath(process.user,bb)if not bh then return nil,"No such file"end;if n=="r"or n=="rb"then return filesystem.readhandle(process,bh.data,n=="rb")elseif n=="w"or n=="wb"then bh.data=""bh.modified=bT"utc"return filesystem.writehandle(process,function(bs,bU)if bU then bh.data=bs else bh.data=bh.data..bs end;bh.modified=bT"utc"if self.__flush then self:__flush()end end,n=="wb")elseif n=="a"or n=="ab"then local bV=bh.data;return filesystem.writehandle(process,function(bs,bU)if bU then bh.data=bV..bs else bh.data=bh.data..bs end;bh.modified=bT"utc"if self.__flush then self:__flush()end end,n=="ab")else return nil,"Invalid mode"end end;function filesystems.tmpfs:open(process,bb,n)if self.readOnly and(n:sub(1,1)=="w"or n:sub(1,1)=="a")then return nil,"Read-only filesystem"end;local bf,bD=pcall(self.stat,self,process,bb)if not bf then if type(bD)=="table"then error(bD)end;return nil,bD elseif not bD then if n:sub(1,1)=="w"or n:sub(1,1)=="a"then local bE,bF=pcall(self.stat,self,process,fs.getDir(bb))if not bE or not bF then if type(bF)=="table"then error(bF)end;local bG,o=pcall(self.mkdir,self,process,fs.getDir(bb))if not bG then if type(o)=="table"then error(o)end;return nil,o:gsub("kernel:%d: ","")end;bF=self:stat(process,fs.getDir(bb))end;if process.user~="root"then local bH=bF.permissions[process.user]or bF.worldPermissions;if not bH.write then return nil,"Permission denied"end end;local bw={type="file",owner=process.user,permissions=deepcopy(bF.permissions),worldPermissions=deepcopy(bF.worldPermissions),setuser=false,created=os.epoch"utc",modified=os.epoch"utc",data=""}local y=bw.permissions[bF.owner]bw.permissions[bF.owner]=nil;bw.permissions[process.user]=y;self:setpath(process.user,bb,bw)return self:_open_internal(process,bb,n)else return nil,"File not found"end elseif bD.type=="directory"then return nil,"Is a directory"end;if process.user~="root"then local bH=bD.permissions[process.user]or bD.worldPermissions;if n:sub(1,1)=="r"and not bH.read or(n:sub(1,1)=="w"or n:sub(1,1)=="a")and not bH.write then return nil,"Permission denied"end end;if bD.type=="fifo"then local bw=self:getpath(process.user,bb)local bI=fifos[bw]if not bI then bI={data=""}fifos[bw]=bI end;return filesystem.fifohandle(process,bI,n)end;return self:_open_internal(process,bb,n)end;function filesystems.tmpfs:list(process,bb)local bh=self:getpath(process.user,bb)if not bh or bh.type~="directory"then error(bb..": Not a directory",2)end;if process.user~="root"then local bH=bh.permissions[process.user]or bh.worldPermissions;if not bH.read then error(bb..": Permission denied",2)end end;local a5={}for h in pairs(bh.contents)do a5[#a5+1]=h end;table.sort(a5)return a5 end;function filesystems.tmpfs:stat(process,bb,bA)local bh=self:getpath(process.user,bb,bA)if not bh then return nil end;return{size=bh.type=="file"and#bh.data or(bh.type=="directory"and#bh.contents or 0),type=bh.type,created=bh.created,modified=bh.modified,owner=bh.owner,permissions=deepcopy(bh.permissions),worldPermissions=deepcopy(bh.worldPermissions),setuser=bh.setuser,capacity=math.huge,freeSpace=math.huge,link=rawget(bh,"link"),special={}}end;function filesystems.tmpfs:remove(process,bb)if self.readOnly then error("Read-only filesystem",2)end;local bW=self:getpath(process.user,fs.getDir(bb))local m=fs.getName(bb)if not bW or bW.type~="directory"or not bW.contents[m]then return end;if process.user~="root"and not(bW.permissions[process.user]or bW.worldPermissions).write then error(bb..": Permission denied",2)end;local bh=bW.contents[m]if process.user~="root"and not(bh.permissions[process.user]or bh.worldPermissions).write then error(bb..": Permission denied",2)end;local function bL(bn)local bH=bn.permissions[process.user]or bn.worldPermissions;if process.user~="root"and not bH.write then error(bb..": Permission denied",3)end;if bn.type=="directory"then if process.user~="root"and not bH.read then error(bb..": Permission denied",3)end;for z,i in pairs(bn.contents)do bL(i)end end end;bL(bh)bW.contents[m]=nil;bW.modified=os.epoch"utc"end;function filesystems.tmpfs:rename(process,bM,bN)if self.readOnly then error("Read-only filesystem",2)end;local bX=self:getpath(process.user,fs.getDir(bM))local bY=fs.getName(bM)if not bX or bX.type~="directory"or not bX.contents[bY]then error(bM..": No such file or directory",2)end;if process.user~="root"and not(bX.permissions[process.user]or bX.worldPermissions).write then error(bM..": Permission denied",2)end;local bZ=bX.contents[bY]if process.user~="root"and not(bZ.permissions[process.user]or bZ.worldPermissions).write then error(bM..": Permission denied",2)end;local b_=self:getpath(process.user,fs.getDir(bN))local c0=fs.getName(bN)if not b_ or b_.type~="directory"then error(bN..": No such file or directory",2)end;if process.user~="root"and not(b_.permissions[process.user]or b_.worldPermissions).write then error(bN..": Permission denied",2)end;local c1=b_.contents[c0]if c1 then error(bN..": File already exists",2)end;b_.contents[c0],bX.contents[bY]=bZ,nil;local c2=os.epoch"utc"bX.modified,b_.modified=c2,c2 end;function filesystems.tmpfs:mkdir(process,bb)if self.readOnly then error("Read-only filesystem",2)end;local y=self;for z,E in ipairs(split(bb,"/\\"))do local bH=y.permissions[process.user]or y.worldPermissions;if y.type~="directory"then error(bb..": File exists",2)elseif process.user~="root"and not bH.execute then error(bb..": Permission denied",2)end;if not y.contents[E]then if process.user~="root"and not bH.write then error(bb..": Permission denied",2)end;y.contents[E]={type="directory",owner=y.owner,permissions=deepcopy(y.permissions),worldPermissions=deepcopy(y.worldPermissions),created=os.epoch"utc",modified=os.epoch"utc",contents={}}y.modified=os.epoch"utc"end;y=y.contents[E]end end;function filesystems.tmpfs:link(process,bb,bQ)if self.readOnly then error("Read-only filesystem",2)end;local bD=self:stat(process,bb)if bD then error(bb..": File exists",2)end;local bE,bF=pcall(self.stat,self,process,fs.getDir(bb))if not bE or not bF then if type(bF)=="table"then error(bF)end;local bG,o=pcall(self.mkdir,self,process,fs.getDir(bb))if not bG then if type(o)=="table"then error(o)end;return nil,type(o)=="string"and o:gsub("kernel:%d: ","")or o end;bF=self:stat(process,fs.getDir(bb))end;self:setpath(process.user,bb,{type="link",owner=process.user,permissions=deepcopy(bF.permissions),worldPermissions=deepcopy(bF.worldPermissions),setuser=false,created=os.epoch"utc",modified=os.epoch"utc",path=bQ},true)end;function filesystems.tmpfs:mkfifo(process,bb)if self.readOnly then error("Read-only filesystem",2)end;local bD=self:stat(process,bb)if bD then error(bb..": File exists",2)end;local bE,bF=pcall(self.stat,self,process,fs.getDir(bb))if not bE or not bF then if type(bF)=="table"then error(bF)end;local bG,o=pcall(self.mkdir,self,process,fs.getDir(bb))if not bG then if type(o)=="table"then error(o)end;return nil,type(o)=="string"and o:gsub("kernel:%d: ","")or o end;bF=self:stat(process,fs.getDir(bb))end;self:setpath(process.user,bb,{type="fifo",owner=process.user,permissions=deepcopy(bF.permissions),worldPermissions=deepcopy(bF.worldPermissions),setuser=false,created=os.epoch"utc",modified=os.epoch"utc"},true)end;function filesystems.tmpfs:chmod(process,bb,user,n)if self.readOnly then error("Read-only filesystem",2)end;local bD=self:getpath(process.user,bb,true)if not bD then error(bb..": No such file or directory",2)end;if not bD.owner or process.user~="root"and process.user~=bD.owner then error(bb..": Permission denied",2)end;local bH;if user==nil then bH=bD.worldPermissions else bH=bD.permissions[user]if not bH then bH=deepcopy(bD.worldPermissions)bD.permissions[user]=bH end end;if type(n)=="string"then if n:match"^[%+%-=][rwxs]+$"then local A=n:sub(1,1)local y={}for a9 in n:gmatch("[rwxs]")do if a9=="r"then y.read=true elseif a9=="w"then y.write=true elseif a9=="s"then y.setuser=true else y.execute=true end end;if A=="+"then if y.read then bH.read=true end;if y.write then bH.write=true end;if y.execute then bH.execute=true end;if y.setuser then bD.setuser=true end elseif A=="-"then if y.read then bH.read=false end;if y.write then bH.write=false end;if y.execute then bH.execute=false end;if y.setuser then bD.setuser=false end else bH.read=y.read or false;bH.write=y.write or false;bH.execute=y.execute or false;bD.setuser=y.setuser or false end else bH.read=n:sub(1,1)~="-"bH.write=n:sub(2,2)~="-"bH.execute=n:sub(3,3)~="-"bD.setuser=n:sub(3,3)=="s"end elseif type(n)=="number"then bD.setuser=bit32.btest(n,8)bH.read=bit32.btest(n,4)bH.write=bit32.btest(n,2)bH.execute=bit32.btest(n,1)else if n.read~=nil then bH.read=n.read end;if n.write~=nil then bH.write=n.write end;if n.execute~=nil then bH.execute=n.execute end;if n.setuser~=nil then bD.setuser=n.setuser end end end;function filesystems.tmpfs:chown(process,bb,bR)if self.readOnly then error("Read-only filesystem",2)end;local bD=self:getpath(process.user,bb,true)if not bD then error(bb..": No such file or directory",2)end;if not bD.owner or process.user~="root"and process.user~=bD.owner then error(bb..": Permission denied",2)end;bD.owner=bR;bD.setuser=false end;function filesystems.tmpfs:info()return"tmpfs","memory",{ro=self.readOnly}end;setmetatable(filesystems.drivefs,{__index=filesystems.craftos})function filesystems.drivefs:stat(process,bb)local u,o=filesystems.craftos.stat(self,process,bb)if bb==""and u==nil then return{size=0,type="directory",created=0,modified=0,owner=self.owner,capacity=0,freeSpace=0,permissions={[self.owner]={read=false,write=true,execute=false}},worldPermissions={read=false,write=false,execute=false},setuser=false}end;return u,o end;function filesystems.drivefs:new(process,by,bC)local c3=hardware.get(by)if not c3 then error("Could not find drive at "..by)end;local bb=hardware.call(process,c3,"getMountPath")local fs=filesystems.craftos:new(process,bb,bC)fs.drive=c3.uuid;fs.owner=process.user;fs.meta={meta={type="directory",owner="root",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}}fs.metapath=fs.combine(bb,".meta.ltn")local a=fs.open(fs.metapath,"r")if a then fs.meta=unserialize(a.readAll())or fs.meta;a.close()end;return setmetatable(fs,{__index=self})end;function filesystems.drivefs:info()return"drivefs",self.drive,{ro=self.readOnly}end;setmetatable(filesystems.tablefs,{__index=filesystems.tmpfs})function filesystems.tablefs:new(process,by,bC)local y;local a,o;if process==KERNEL and mounts[""]then a,o=filesystem.open(process,by,"r")else a,o=fs.open(by,"r")end;if a then local bh=a.readAll()or""a.close()local bf,u=pcall(unserialize,bh)if not bf then error("Could not mount "..by..": "..u,3)elseif type(u)~="table"or u.type~="directory"or type(u.contents)~="table"then error("Could not mount "..by..": Invalid table file",3)end;y=u else if not(bC.rw and not bC.ro)then error("Could not mount "..by..": "..o,3)end;y={type="directory",owner=process.user,permissions={[process.user]={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false,created=os.epoch"utc",modified=os.epoch"utc",contents={}}end;y.src=by;y.readOnly=bC.ro;if bC.rw and not bC.ro then function y:__flush()local f,bn=self.__flush,self.src;self.__flush,self.src=nil;local bf,u=pcall(serialize,self)self.__flush,self.src=f,bn;if not bf then error(u)end;local a,o=filesystem.open(process,by,"w")if not a then syslog.log({level=4},"Could not save mount to "..by..": "..o)return end;a.write(u)a.close()end end;return setmetatable(y,{__index=self})end;function filesystems.tablefs:info()return"tablefs",self.src,{rw=self.__flush~=nil,ro=self.readOnly}end;function filesystems.bind:new(process,bb,bC)local bD,o=filesystem.stat(process,bb)if not bD then error("Could not bind "..bb..": "..o,3)elseif bD.type~="directory"then error("Could not bind "..bb..": Not a directory",3)end;return setmetatable({path=bb},{__index=self})end;function filesystems.bind:open(process,bb,n)return filesystem.open(process,fs.combine(self.path,bb),n)end;function filesystems.bind:list(process,bb)return filesystem.list(process,fs.combine(self.path,bb))end;function filesystems.bind:stat(process,bb,bA)return filesystem.stat(process,fs.combine(self.path,bb),bA)end;function filesystems.bind:remove(process,bb)return filesystem.remove(process,fs.combine(self.path,bb))end;function filesystems.bind:rename(process,bM,bN)return filesystem.rename(process,fs.combine(self.path,bM),fs.combine(self.path,bN))end;function filesystems.bind:mkdir(process,bb)return filesystem.mkdir(process,fs.combine(self.path,bb))end;function filesystems.bind:link(process,bb,bQ)return filesystem.link(process,fs.combine(self.path,bb),bQ)end;function filesystems.bind:mkfifo(process,bb)return filesystem.mkfifo(process,fs.combine(self.path,bb))end;function filesystems.bind:chmod(process,bb,user,n)return filesystem.chmod(process,fs.combine(self.path,bb),user,n)end;function filesystems.bind:chown(process,bb,bR)return filesystem.chown(process,fs.combine(self.path,bb),bR)end;function filesystems.bind:info()return"bind",self.path,{}end;function filesystem.open(process,bb,n)expect(0,process,"table")expect(1,bb,"string")expect(2,n,"string")if not n:match"^[rwa]b?$"then error("Invalid mode",0)end;repeat local bf,c4,E=pcall(bc,process,bb)if not bf then return nil,c4 end;local u=table.pack(pcall(c4.open,c4,process,E,n))if u[1]then return table.unpack(u,2,u.n)elseif type(u[2])~="table"or type(u[2].path)~="string"then error(u[2],2)end;bb=u[2].path until u[1]end;function filesystem.list(process,bb)expect(0,process,"table")expect(1,bb,"string")repeat local c4,E=bc(process,bb)local bf,u=pcall(c4.list,c4,process,E)if bf then return u elseif type(u)~="table"or type(u.path)~="string"then error(u,2)end;bb=u.path until bf end;function filesystem.stat(process,bb,bA)expect(0,process,"table")expect(1,bb,"string")repeat local bf,c4,E,c5=pcall(bc,process,bb)if not bf then return nil,c4 end;local c6,u,o=pcall(c4.stat,c4,process,E,bA)if c6 then if u then u.mountpoint="/"..c5 end;return u,o elseif type(u)~="table"or type(u.path)~="string"then error(u,2)end;bb=u.path until c6 end;function filesystem.remove(process,bb)expect(0,process,"table")expect(1,bb,"string")repeat local c4,E=bc(process,bb)local bf,u=pcall(c4.remove,c4,process,E)if bf then return elseif type(u)~="table"or type(u.path)~="string"then error(u,2)end;bb=u.path until bf end;function filesystem.rename(process,bM,bN)expect(0,process,"table")expect(1,bM,"string")expect(2,bN,"string")repeat local c7,c8=bc(process,bM)local c9,ca=bc(process,bN)if c7~=c9 then error("Attempt to rename file across two filesystems",0)end;local bf,u=pcall(c7.rename,c7,process,c8,ca)if bf then return elseif type(u)~="table"or type(u.path)~="string"then error(u,2)end;if u.orig==bM then bM=u.path else bN=u.path end until bf end;function filesystem.mkdir(process,bb)expect(0,process,"table")expect(1,bb,"string")repeat local c4,E=bc(process,bb)local bf,u=pcall(c4.mkdir,c4,process,E)if bf then return elseif type(u)~="table"or type(u.path)~="string"then error(u,2)end;bb=u.path until bf end;function filesystem.link(process,bb,bQ)expect(0,process,"table")expect(1,bb,"string")expect(2,bQ,"string")if fs.combine(bb)==fs.combine(bQ)then error("Cannot link file to itself",2)end;syslog.debug("Creating link",bb," => ",bQ)repeat local c4,E=bc(process,bb)if not c4.link then error("Filesystem does not support links",2)end;local bf,u=pcall(c4.link,c4,process,E,bQ)if bf then return elseif type(u)~="table"or type(u.path)~="string"then error(u,2)end;bb=u.path until bf end;function filesystem.mkfifo(process,bb)expect(0,process,"table")expect(1,bb,"string")repeat local c4,E=bc(process,bb)if not c4.mkfifo then error("Filesystem does not support FIFOs",2)end;local bf,u=pcall(c4.mkfifo,c4,process,E)if bf then return elseif type(u)~="table"or type(u.path)~="string"then error(u,2)end;bb=u.path until bf end;function filesystem.chmod(process,bb,user,n)expect(0,process,"table")expect(1,bb,"string")expect(2,user,"string","nil")expect(3,n,"number","string","table")if type(n)=="string"and not n:match"^[%+%-=][rwxs]+$"and not n:match"^[r%-][w%-][xs%-]$"then error("bad argument #3 (invalid mode)",2)elseif type(n)=="table"then expect.field(n,"read","boolean","nil")expect.field(n,"write","boolean","nil")expect.field(n,"execute","boolean","nil")end;repeat local c4,E=bc(process,bb)local bf,u=pcall(c4.chmod,c4,process,E,user,n)if bf then return elseif type(u)~="table"or type(u.path)~="string"then error(u,2)end;bb=u.path until bf end;function filesystem.chown(process,bb,user)expect(0,process,"table")expect(1,bb,"string")expect(2,user,"string")repeat local c4,E=bc(process,bb)local bf,u=pcall(c4.chown,c4,process,E,user)if bf then return elseif type(u)~="table"or type(u.path)~="string"then error(u,2)end;bb=u.path until bf end;function filesystem.chroot(process,bb)expect(0,process,"table")expect(1,bb,"string")if process.user~="root"then error("Could not change root: Permission denied",2)end;local cb=filesystem.combine(process.root,bb).."/"if cb:find(process.root,1,true)~=1 then error("Could not change root: No such file or directory",2)end;local bn=filesystem.stat(process,"/"..bb)if not bn then error(bb..": No such directory",2)end;if bn.type~="directory"then error(bb..": Not a directory",2)end;process.root=cb end;function filesystem.mount(process,type,by,bz,bC)expect(0,process,"table")expect(1,type,"string")expect(2,by,"string")expect(3,bz,"string")expect(4,bC,"table","nil")if not filesystems[type]then error("No such filesystem '"..type.."'",2)end;local E=ba(process,bz)if E==""then if process.user~="root"then error("Could not mount to "..bz..": Permission denied",2)elseif mounts[E]then error("Could not mount to "..bz..": Mount already exists")end else local bD=filesystem.stat(process,bz)if not bD then error("Could not mount to "..bz..": No such directory",2)elseif bD.type~="directory"then error("Could not mount to "..bz..": Not a directory",2)elseif process.user~="root"and not(bD.permissions[process.user]or bD.worldPermissions).write then error("Could not mount to "..bz..": Permission denied",2)elseif mounts[E]then error("Could not mount to "..bz..": Mount already exists")end end;local c4=filesystems[type]:new(process,by,bC or{})mounts[E]=c4 end;function filesystem.unmount(process,bb)expect(0,process,"table")expect(1,bb,"string")bb=ba(process,bb)if not mounts[bb]then error(bb..": No such mount",2)end;local bD=mounts[bb]:stat(process,"")if not bD then error("Internal error in unmount: could not get stat for root! Please report this to the maintainer of the target filesystem.",2)elseif process.user~="root"and not(bD.permissions[process.user]or bD.worldPermissions).write then error(bb..": Permission denied",2)end;if mounts[bb].unmount then mounts[bb]:unmount(process)end;mounts[bb]=nil end;function filesystem.mountlist(process)expect(0,process,"table")local a5={}for h,i in pairs(mounts)do if"/"..h.."/"==process.root or h:find(process.root:sub(2),1,true)==1 then local type,bb,bC=i:info()a5[#a5+1]={path="/"..h,type=type,source=bb,options=bC}end end;return a5 end;function filesystem.combine(cc,...)local a0=fs.combine(cc,...)if cc:match"^/"then a0="/"..a0 end;return a0 end;function syscalls.open(process,aq,...)return filesystem.open(process,...)end;function syscalls.list(process,aq,...)return filesystem.list(process,...)end;function syscalls.stat(process,aq,...)return filesystem.stat(process,...)end;function syscalls.remove(process,aq,...)return filesystem.remove(process,...)end;function syscalls.rename(process,aq,...)return filesystem.rename(process,...)end;function syscalls.mkdir(process,aq,...)return filesystem.mkdir(process,...)end;function syscalls.link(process,aq,...)return filesystem.link(process,...)end;function syscalls.mkfifo(process,aq,...)return filesystem.mkfifo(process,...)end;function syscalls.chmod(process,aq,...)return filesystem.chmod(process,...)end;function syscalls.chown(process,aq,...)return filesystem.chown(process,...)end;function syscalls.chroot(process,aq,...)return filesystem.chroot(process,...)end;function syscalls.mount(process,aq,...)return filesystem.mount(process,...)end;function syscalls.unmount(process,aq,...)return filesystem.unmount(process,...)end;function syscalls.mountlist(process,aq,...)return filesystem.mountlist(process,...)end;function syscalls.combine(process,aq,...)return filesystem.combine(...)end;function syscalls.loadCraftOSAPI(process,aq,cd)expect(1,cd,"string")local e;e=setmetatable({dofile=function(bb)local a,o=fs.open(bb,"rb")if not a then error("Could not open module: "..o,0)end;local g,o=load(a.readAll(),"@"..bb,nil,e)a.close()if not g then error("Could not load module: "..o,0)end;return g()end,require=function(m)return e.dofile("rom/modules/main/"..m:gsub("%.","/")..".lua")end},{__index=process.env})if cd:sub(1,3)=="cc."then local bb=fs.combine("rom/modules/main",cd:gsub("%.","/")..".lua")if not bb:match"^/?rom/modules/main/"then error("Invalid module path",0)end;return e.dofile(bb)else if not cd:match"^[a-z]+$"then error("Invalid API name",0)end;local bb=fs.combine("rom/apis",cd..".lua")local a,o=fs.open(bb,"rb")if not a then error("Could not open module: "..o,0)end;local g,o=load(a.readAll(),"@"..bb,nil,e)a.close()if not g then error("Could not load module: "..o,0)end;g()local y={}for h,i in pairs(e)do if h~="dofile"then y[h]=i end end;return y end end;xpcall(function()if args.initrd then if args.initrd:match"^_G%.."then local ce=_G[args.initrd:match"^_G%.(.+)"]if type(ce)~="table"then error("Requested root filesystem in global '"..args.initrd.."' is not a table")end;ce.src=args.initrd;mounts[""]=setmetatable(ce,{__index=filesystems.tablefs})else mounts[""]=filesystems.tablefs:new(KERNEL,args.initrd,{})end else local bC={}if args.rootflags then for A in args.rootflags:gmatch"[^,]+"do local h,i=A:match("^([^=]+)=(.*)$")if h and i then if i=="true"then bC[h]=true elseif i=="false"then bC[h]=false else bC[h]=tonumber(i)or i end else bC[A]=true end end end;mounts[""]=filesystems[args.rootfstype]:new(KERNEL,args.root,bC)end end,panic)local do_syscall=do_syscall;local expect=expect;local function cf(cg,ch,ci,cj)local ck={bit32.extract(ch,0,16),bit32.extract(ch,16,16),bit32.extract(cg,0,16),bit32.extract(cg,16,16)}local ab={bit32.extract(cj,0,16),bit32.extract(cj,16,16),bit32.extract(ci,0,16),bit32.extract(ci,16,16)}local bt={{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0}}for cl=1,4 do for cm=1,4 do local r=ck[cm]*ab[cl]+bt[cl][cm]bt[cl][cm+1],bt[cl][cm]=bit32.rshift(r,16),bit32.band(r,0xFFFF)end end;local cn={0,0,0,0,0,0,0,0}for co=1,8 do for cp=1,4 do cn[co]=cn[co]+(bt[cp][co-cp+1]or 0)end;cn[co+1],cn[co]=bit32.rshift(cn[co],16),bit32.band(cn[co],0xFFFF)end;return cn[3]+cn[4]*0x10000,cn[1]+cn[2]*0x10000 end;local function cq(ab,cg,ch)return cg+math.floor((ch+ab)/0x100000000),bit32.band(ch+ab,0xFFFFFFFF)end;function makeRandom()local cr,cs=0,0;local function next(ct)cr,cs=cq(0xB,cf(cr,cs,0x5,0xDEECE66D))cr=bit32.band(cr,0xFFFF)return math.floor(cr/2^(16-ct))+math.floor(cs/2^(48-ct))end;local function cu(c,d)expect(1,c,"number","nil")expect(2,d,"number","nil")if c then expect.range(c,0,0x7FFFFFFF)if not d then c,d=0,c else expect.range(d,0,0x7FFFFFFF)end;local cv=d-c+1;local cw;if math.log(cv,2)%1==0 then cw=math.floor(cv*next(31)/0x80000000)else local ct;repeat ct=next(31)cw=ct%cv until ct-cw+cv-1>=0 end;return cw+c else return(next(26)*0x8000000+next(27))/0x20000000000000 end end;local function cx(cy)expect(1,cy,"number")cr,cs=bit32.band(bit32.bxor(0x5,math.floor(cy/0x100000000)),0xFFFF),bit32.bxor(0xDEECE66D,math.floor(cy))end;cx(os.epoch"utc"*tonumber(tostring(next):match("%x+")or"1",16))return cu,cx end;do math.random,math.randomseed=makeRandom()end;function createLuaLib(process)local cz={}for z,i in ipairs{"assert","error","getmetatable","ipairs","next","pairs","pcall","rawequal","rawget","rawset","select","setmetatable","tonumber","tostring","type","_VERSION","xpcall","collectgarbage"}do cz[i]=_G[i]end;function cz.dofile(bb)if bb~=nil and type(bb)~="string"then error("bad argument #1 (expected string, got "..type(bb)..")",2)end;local g,o=loadfile(bb or io.stdin:read("*a"))if not g then error(o,2)end;return g()end;do local load,getfenv,setfenv,make_ENV=load,getfenv,setfenv,make_ENV;if _VERSION=="Lua 5.1"then function cz.load(l,m,n,e)return load(l,m,n,make_ENV(e or process.env))end;function cz.getfenv(f)local i;if f==nil then i=getfenv(2)elseif tonumber(f)and tonumber(f)>0 then i=getfenv(f+1)elseif type(f)=="function"then i=getfenv(f)else i=getfenv(f)end;local aB=getmetatable(f)if aB and aB.__env then return aB.__env else return i end end;function cz.setfenv(f,K)return setfenv(f,make_ENV(K))end else cz.load,cz.getfenv,cz.setfenv=function(l,m,n,e)return load(l,m,n,e or process.env)end,getfenv,setfenv end end;function cz.loadfile(bb,n,e)if e==nil and type(n)=="table"then e,n=n,nil end;if type(bb)~="string"then error("bad argument #1 (expected string, got "..type(bb)..")",2)end;if n~=nil and type(n)~="string"then error("bad argument #2 (expected string, got "..type(n)..")",2)end;if e~=nil and type(e)~="table"then error("bad argument #3 (expected table, got "..type(e)..")",2)end;local a,o=do_syscall("open",bb,"rb")if not a then error(o,2)end;local bh=a.readAll()a.close()return load(bh,"@"..bb,n,e)end;function cz.print(...)local args=table.pack(...)if args.n==0 then args={"",n=1}end;args[args.n]=tostring(args[args.n]).."\n"return do_syscall("write",table.unpack(args,1,args.n))end;cz.coroutine=deepcopy(coroutine)cz.string=deepcopy(string)cz.table=deepcopy(table)cz.math=deepcopy(math)cz.bit32=deepcopy(bit32)cz.math.random,cz.math.randomseed=makeRandom()local cA=cz.coroutine.resume;cz.coroutine.resume=function(...)local a5=table.pack(cA(...))while a5.n==2 and a5[1]==true and a5[2]=="preempt"do a5=table.pack(cA(coroutine.yield("preempt")))end;return table.unpack(a5,1,a5.n)end;local cB=""local cC=setmetatable({close=function()end,lines=function(self,...)local args=table.pack(...)return function()return self:read(table.unpack(args,1,args.n))end end,read=function(self,a6,...)local bn,K;a6=a6 or"*l"if type(a6)=="number"then while#cB<a6 do cB=cB..do_syscall("read",a6)end elseif type(a6)=="string"then a6=a6:gsub("^%*","")if a6=="n"then while not cB:find("%d")do local bo=do_syscall("readline")if bo==nil then break end;cB=cB..bo.."\n"end elseif a6=="a"then while true do local bo=do_syscall("readline")if bo==nil then break end;cB=cB..bo.."\n"end elseif a6=="l"or a6=="L"then local bo=do_syscall("readline")if bo==nil then return nil end;cB=cB..bo.."\n"else error("bad argument (invalid format '"..a6 .."')",2)end else error("bad argument (expected string or number, got "..type(a6),2)end;if type(a6)=="number"then bn,K=cB:sub(1,a6),a6+1 elseif a6=="n"then bn,K=cB:match("(%d)()")elseif a6=="a"then bn,K=cB,#cB+1 elseif a6=="l"then bn,K=cB:match("(.*)\n()")else bn,K=cB:match("(.*\n)()")end;if not bn then return nil end;cB=cB:sub(K)if select("#",...)>0 then return bn,self:read(...)else return bn end end,seek=function()return nil,"Cannot seek default file"end,setvbuf=function()end},{__name="FILE*"})local cD=setmetatable({close=function()end,flush=function()end,seek=function()return nil,"Cannot seek default file"end,setvbuf=function()end,write=function(self,...)do_syscall("write",...)return self end},{__name="FILE*"})local cE=setmetatable({close=function()end,flush=function()end,seek=function()return nil,"Cannot seek default file"end,setvbuf=function()end,write=function(self,...)do_syscall("writeerr",...)return self end},{__name="FILE*"})local cF,cG=cC,cD;local cH={close=function(self)self._file.close()self._closed=true end,lines=function(self,...)local args=table.pack(...)return function()return self:read(table.unpack(args,1,args.n))end end,read=function(self,a6,...)local i;if a6==nil then a6="l"end;if type(a6)=="number"then i=self._file.read(a6)elseif type(a6)=="string"then a6=a6:gsub("^%*","")if a6=="a"then i=self._file.readAll()elseif a6=="l"then i=self._file.readLine(false)elseif a6=="L"then i=self._file.readLine(true)elseif a6=="n"then local bn,a9=""repeat a9=self._file.read(1)until a9:match("%d")while a9:match("%d")do bn,a9=bn..a9,self._file.read(1)end;i=tonumber(bn)else error("bad argument (invalid format '"..a6 .."')",2)end else error("bad argument (expected string or number, got "..type(a6)..")",2)end;if select("#",...)>0 then return i,self:read(...)else return i end end,seek=function(self,bm,U)if self._file.seek then return self._file.seek(bm,U)else return nil,"Cannot seek text file"end end,setvbuf=function()end}local cI={close=function(self)self._file.close()self._closed=true end,flush=function(self)self._file:flush()end,seek=function(self,bm,U)if self._file.seek then return self._file.seek(bm,U)else return nil,"Cannot seek text file"end end,setvbuf=function()end,write=function(self,...)self._file.write(...)return self end}cz.io={close=function(a)if a==nil then cG:close()elseif type(a)=="table"and getmetatable(a)and getmetatable(a).__name=="FILE*"then a:close()else error("bad argument #1 (expected FILE*, got "..type(a)..")",2)end end,flush=function()return cG:flush()end,input=function(a)if a==nil then return cF elseif type(a)=="string"then local ag,o=io.open(a,"r")if not ag then error(o,2)end;cF=ag elseif type(a)=="table"and getmetatable(a)and getmetatable(a).__name=="FILE*"then cF=a else error("bad argument #1 (expected string or FILE*, got "..type(a)..")",2)end end,lines=function(cJ,...)if cJ==nil then return cF:lines(...)end;if type(cJ)~="string"then error("bad argument #1 (expected string, got "..type(cJ)..")",2)end;local ag,o=io.open(cJ,"r")if not ag then error(o,2)end;local g=ag:lines(...)return function(...)local a5=table.pack(g(...))if a5.n==0 or a5[1]==nil then ag:close()end;return table.unpack(a5,1,a5.n)end end,open=function(cJ,n)if type(cJ)~="string"then error("bad argument #1 (expected string, got "..type(cJ)..")",2)end;if n==nil then n="r"end;if type(n)~="string"then error("bad argument #2 (expected string, got "..type(n)..")",2)end;local a,o=do_syscall("open",cJ,n)if not a then return nil,o elseif n:find("r")then return setmetatable({_file=a},{__index=cH,__name="FILE*"})else return setmetatable({_file=a},{__index=cI,__name="FILE*"})end end,output=function(a)if a==nil then return cG elseif type(a)=="string"then local ag,o=io.open(a,"w")if not ag then error(o,2)end;cG=ag elseif type(a)=="table"and getmetatable(a)and getmetatable(a).__name=="FILE*"then cG=a else error("bad argument #1 (expected string or FILE*, got "..type(a)..")",2)end end,popen=function(bb,n)expect(1,bb,"string")n=expect(2,n,"string","nil")or"r"if n~="r"and n~="w"and n~="rw"then error("bad argument #2 (invalid mode)",2)end;if n=="rw"then local cK,cL="",""local cM;local cN={read=function(r)if cK==""then return nil elseif r then local bn=cK:sub(1,r)cK=cK:sub(r+1)return bn else local bn,K=cK:match"([^\n]*)\n*()"cK=cK:sub(K)return bn end end}local cO={write=function(bn)cK=cK..bn end,flush=function()end,close=function()local b3=do_syscall("getpinfo",cM)if not b3 then return end;repeat local ar,cP=coroutine.yield()until ar=="process_complete"and cP.pid==cM end}local cQ={read=function(r)if cL==""then return nil elseif r then local bn=cL:sub(1,r)cL=cL:sub(r+1)return bn else local bn,K=cL:match"([^\n]*)\n*()"cL=cL:sub(K)return bn end end,readLine=function()local bn,K=cL:match"([^\n]*)\n*()"cL=cL:sub(K)return bn end,readAll=function()local bn=cL;cL=""return bn end,close=function()local b3=do_syscall("getpinfo",cM)if not b3 then return end;repeat local ar,cP=coroutine.yield()until ar=="process_complete"and cP.pid==cM end}local cR={write=function(bn)cL=cL..bn end}cM=do_syscall("fork",function()do_syscall("stdin",cN)do_syscall("stdout",cR)do_syscall("exec","/bin/sh","-c",bb)end)return setmetatable({_file=cQ},{__index=cH,__name="FILE*"}),setmetatable({_file=cO},{__index=cI,__name="FILE*"})else local cS=""local bj=false;local cM;local cT={read=function(r)if cS==""then if bj then return nil else return""end elseif r then local bn=cS:sub(1,r)cS=cS:sub(r+1)return bn else local bn,K=cS:match"([^\n]*\n?)()"cS=cS:sub(K)return bn end end,readLine=function()local bn,K=cS:match"([^\n]*\n?)()"cS=cS:sub(K)return bn end,readAll=function()local bn=cS;cS=""return bn end,close=function()bj=true;local b3=do_syscall("getpinfo",cM)if not b3 then return end;repeat local ar,cP=coroutine.yield()until ar=="process_complete"and cP.pid==cM end}local cU={write=function(bn)cS=cS..bn end,flush=function()end,close=function()bj=true;local b3=do_syscall("getpinfo",cM)if not b3 then return end;repeat local ar,cP=coroutine.yield()until ar=="process_complete"and cP.pid==cM end}cM=do_syscall("fork",function()do_syscall(n=="r"and"stdout"or"stdin",n=="r"and cU or cT)do_syscall("exec","/bin/sh","-c",bb)end)return n=="r"and setmetatable({_file=cT},{__index=cH,__name="FILE*"})or setmetatable({_file=cU},{__index=cI,__name="FILE*"})end end,read=function(...)return cF:read(...)end,tmpfile=function()return io.open(os.tmpname(),"a")end,type=function(bv)if type(bv)=="table"and getmetatable(bv)and getmetatable(bv).__name=="FILE*"then if bv._closed then return"closed file"else return"file"end else return nil end end,write=function(...)return cG:write(...)end,stdin=cC,stdout=cD,stderr=cE}local cV=os;cz.os={clock=function()return do_syscall("clock")end,date=function(a6,c2)if type(a6)=="string"and a6:sub(1,1)=="?"then local bl=cV.date("!"..a6:sub(2),c2 or cV.epoch"ingame"/1000)if type(bl)=="table"then bl.year=bl.year-1970 end;return bl else return cV.date(a6,c2)end end,difftime=function(ck,ab)return ck-ab end,execute=function(bb)do_syscall("exec","/bin/sh","-c",bb)end,exit=function(bp)do_syscall("exit",bp)end,getenv=function(m)expect(1,m,"string")local e=do_syscall("getenv")if not e then return nil end;return e[m]end,remove=function(bb)expect(1,bb,"string")local bf,o=do_syscall("remove",bb)if not bf then bf=nil end;return bf,o end,rename=function(bM,bN)expect(1,bM,"string")expect(2,bN,"string")local bf,o=do_syscall("rename",bM,bN)if not bf then bf=nil end;return bf,o end,setlocale=function(cW)if cW then error("setlocale is not supported",2)else return"C"end end,time=function(y)if y=="ingame"then return cV.epoch"ingame"/1000 elseif y=="nano"then return ccemux and ccemux.nanoTime()or cV.epoch"nano"end;expect(1,y,"table","nil")if y then return cV.time(y)else return cV.epoch"utc"/1000 end end,tmpname=function()local m="/tmp/lua_"for v=1,6 do local r=math.random(1,64)m=m..("qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890._"):sub(r,r)end;return m end}cz.debug=deepcopy(debug)createRequire(process,cz)for h,i in pairs(cz)do if type(i)=="function"then pcall(setfenv,i,cz)pcall(debug.protect,i)elseif type(i)=="table"and h~="debug"then for z,af in pairs(i)do if type(af)=="function"then pcall(setfenv,af,cz)pcall(debug.protect,af)end end end end;return cz end;function loadfile(bb,n,e)if e==nil and type(n)=="table"then e,n=n,nil end;if type(bb)~="string"then error("bad argument #1 (expected string, got "..type(bb)..")",2)end;if n~=nil and type(n)~="string"then error("bad argument #2 (expected string, got "..type(n)..")",2)end;if e~=nil and type(e)~="table"then error("bad argument #3 (expected table, got "..type(e)..")",2)end;local a,o=filesystem.open(KERNEL,bb,"rb")if not a then error(o,2)end;local bh=a.readAll()a.close()return load(bh,"@"..bb,n,e)end;function dofile(bb)if bb~=nil and type(bb)~="string"then error("bad argument #1 (expected string, got "..type(bb)..")",2)end;local g,o=loadfile(bb or io.stdin:read("*a"))if not g then error(o,2)end;return g()end;function print(...)for v=1,select("#",...)do local i=tostring(select(v,...))terminal.write(TTY[1],i)end end;function terminal.makeTTY(term,t,cX)local a5={isTTY=true,flags={cbreak=false,delay=true,echo=true,keypad=false,nlcr=true,raw=false},cursor={x=1,y=1},cursorBlink=true,colors={fg='0',bg='f',bold=false},size={width=t,height=cX},dirtyLines={},palette={},dirtyPalette={},buffer="",preBuffer="",isLocked=false,isGraphics=false,textBuffer={},graphicsBuffer={},frontmostProcess=nil,processList={},eof=false,term=term}for q=1,cX do a5[q]={(' '):rep(t),('0'):rep(t),('f'):rep(t)}a5.dirtyLines[q]=true end;for v=0,15 do a5.palette[v]={_G.term.nativePaletteColor(2^v)}a5.dirtyPalette[v]=true end;return a5 end;do local cY,cZ=term.getSize()TTY={terminal.makeTTY(term,cY,cZ),terminal.makeTTY(term,cY,cZ),terminal.makeTTY(term,cY,cZ),terminal.makeTTY(term,cY,cZ),terminal.makeTTY(term,cY,cZ),terminal.makeTTY(term,cY,cZ),terminal.makeTTY(term,cY,cZ),terminal.makeTTY(term,cY,cZ)}end;currentTTY=TTY[1]terminal.userTTYs={}do local r=args.console:match"^tty(%d+)$"if r then KERNEL.stdout,KERNEL.stderr,KERNEL.stdin=TTY[tonumber(r)],TTY[tonumber(r)],TTY[tonumber(r)]end end;keysHeld={ctrl=false,alt=false,shift=false}eventHooks.term_resize=eventHooks.term_resize or{}eventHooks.char=eventHooks.char or{}eventHooks.paste=eventHooks.paste or{}eventHooks.key=eventHooks.key or{}eventHooks.key_up=eventHooks.key_up or{}eventHooks.term_resize[#eventHooks.term_resize+1]=function()local af,ag=term.getSize()for v=1,8 do terminal.resize(TTY[v],af,ag)end end;eventHooks.char[#eventHooks.char+1]=function(ar)if not currentTTY.isLocked then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer..ar[2]else currentTTY.preBuffer=currentTTY.preBuffer..ar[2]end;if currentTTY.flags.echo then terminal.write(currentTTY,ar[2])terminal.redraw(currentTTY)end end end;eventHooks.paste[#eventHooks.paste+1]=function(ar)if not currentTTY.isLocked then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer..ar[2]else currentTTY.preBuffer=currentTTY.preBuffer..ar[2]end;if currentTTY.flags.echo then terminal.write(currentTTY,ar[2])terminal.redraw(currentTTY)end end end;eventHooks.key[#eventHooks.key+1]=function(ar)if not currentTTY.isLocked then if ar[2]==keys.enter then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer.."\n"else currentTTY.buffer=currentTTY.buffer..currentTTY.preBuffer.."\n"currentTTY.preBuffer=""end;if currentTTY.flags.echo then terminal.write(currentTTY,"\n")terminal.redraw(currentTTY)end elseif ar[2]==keys.backspace then if currentTTY.flags.cbreak then elseif#currentTTY.preBuffer>0 then currentTTY.preBuffer=currentTTY.preBuffer:sub(1,-2)if currentTTY.flags.echo then terminal.write(currentTTY,"\b \b")terminal.redraw(currentTTY)end end end end;if ar[2]==keys.leftCtrl or ar[2]==keys.rightCtrl then keysHeld.ctrl=true elseif ar[2]==keys.leftAlt or ar[2]==keys.rightAlt then keysHeld.alt=true elseif ar[2]==keys.leftShift or ar[2]==keys.rightShift then keysHeld.shift=true end;if not currentTTY.flags.raw and currentTTY.frontmostProcess and keysHeld.ctrl and not keysHeld.alt and not keysHeld.shift then if ar[2]==keys.c then killProcess(currentTTY.frontmostProcess.id,2)terminal.write(currentTTY,"^C")elseif ar[2]==keys.backslash then killProcess(currentTTY.frontmostProcess.id,3)terminal.write(currentTTY,"^\\")elseif ar[2]==keys.z then killProcess(currentTTY.frontmostProcess.id,19)terminal.write(currentTTY,"^Z")elseif ar[2]==keys.d then currentTTY.eof=true;terminal.write(currentTTY,"^D")end end;if keysHeld.ctrl and keysHeld.alt and not keysHeld.shift then local c_=true;if ar[2]==keys.one then currentTTY=TTY[1]elseif ar[2]==keys.two then currentTTY=TTY[2]elseif ar[2]==keys.three then currentTTY=TTY[3]elseif ar[2]==keys.four then currentTTY=TTY[4]elseif ar[2]==keys.five then currentTTY=TTY[5]elseif ar[2]==keys.six then currentTTY=TTY[6]elseif ar[2]==keys.seven then currentTTY=TTY[7]elseif ar[2]==keys.eight then currentTTY=TTY[8]elseif ar[2]==keys.left then for v=1,8 do if currentTTY==TTY[v]then currentTTY=TTY[(v+7)%8]break end end elseif ar[2]==keys.right then for v=1,8 do if currentTTY==TTY[v]then currentTTY=TTY[(v+1)%8]break end end else c_=false end;if c_ then terminal.redraw(currentTTY,true)end end end;eventHooks.key_up[#eventHooks.key_up+1]=function(ar)if ar[2]==keys.leftCtrl or ar[2]==keys.rightCtrl then keysHeld.ctrl=false elseif ar[2]==keys.leftAlt or ar[2]==keys.rightAlt then keysHeld.alt=false elseif ar[2]==keys.leftShift or ar[2]==keys.rightShift then keysHeld.shift=false end end;function terminal.redraw(d0,bU)if d0.process then d0.process.eventQueue[#d0.process.eventQueue+1]={"tty_redraw",{id=d0.id}}return elseif currentTTY~=d0 and not d0.isMonitor then return end;local term=d0.term;local cS=d0;if d0.isLocked then if d0.isGraphics then term.setGraphicsMode(2)if term.setFrozen then term.setFrozen(true)end;if bU then term.clear()term.drawPixels(0,0,d0.graphicsBuffer)for v=0,255 do term.setPaletteColor(v,d0.graphicsBuffer.palette[v][1],d0.graphicsBuffer.palette[v][2],d0.graphicsBuffer.palette[v][3])end else if d0.graphicsBuffer.frozen then if term.setFrozen then term.setFrozen(false)end;return end;for z,i in ipairs(d0.graphicsBuffer.dirtyRects)do if i.color then term.setPixel(i.x,i.y,i.color,i.width,i.height)else term.drawPixels(i.x,i.y,i)end end;for v in pairs(d0.graphicsBuffer.dirtyPalette)do term.setPaletteColor(v,d0.graphicsBuffer.palette[v][1],d0.graphicsBuffer.palette[v][2],d0.graphicsBuffer.palette[v][3])end end;if term.setFrozen then term.setFrozen(false)end;cS.dirtyRects,cS.dirtyPalette={},{}return end;if term.setGraphicsMode then term.setGraphicsMode(false)end;cS=d0.textBuffer elseif d0.isGraphics then term.setGraphicsMode(false)d0.isGraphics=false end;term.setCursorBlink(false)if bU then term.clear()for q=1,d0.size.height do term.setCursorPos(1,q)term.blit(cS[q][1],cS[q][2],cS[q][3])end;for v=0,15 do term.setPaletteColor(2^v,cS.palette[v][1],cS.palette[v][2],cS.palette[v][3])end else for q in pairs(cS.dirtyLines)do if not cS[q]then error(debug.traceback(q))end;term.setCursorPos(1,q)if#cS[q][1]~=#cS[q][2]or#cS[q][2]~=#cS[q][3]then syslog.log({level="critical"},"Bug in text writer! Inequal lengths: "..#cS[q][1]..", "..#cS[q][2]..", "..#cS[q][3])error("Invalid lengths")end;term.blit(cS[q][1],cS[q][2],cS[q][3])end;for v in pairs(cS.dirtyPalette)do term.setPaletteColor(2^v,cS.palette[v][1],cS.palette[v][2],cS.palette[v][3])end end;term.setCursorPos(cS.cursor.x,cS.cursor.y)term.setCursorBlink(cS.cursorBlink)cS.dirtyLines,cS.dirtyPalette={},{}end;function terminal.resize(d0,t,cX)if t>d0.size.width then for q=1,d0.size.height do d0[q][1]=d0[q][1]..(' '):rep(t-d0.size.width)d0[q][2]=d0[q][2]..d0.colors.fg:rep(t-d0.size.width)d0[q][3]=d0[q][3]..d0.colors.bg:rep(t-d0.size.width)d0.dirtyLines[q]=true end;if d0.isLocked then if d0.isGraphics then for q=1,d0.size.height*9 do d0.graphicsBuffer[q]=d0.graphicsBuffer[q]..('\15'):rep((t-d0.size.width)*6)end;d0.graphicsBuffer.dirtyRects[#d0.graphicsBuffer.dirtyRects+1]={x=d0.size.width*6+1,y=1,width=(t-d0.size.width)*6,height=d0.size.height*9}else for q=1,d0.size.height do d0.textBuffer[q][1]=d0.textBuffer[q][1]..(' '):rep(t-d0.size.width)d0.textBuffer[q][2]=d0.textBuffer[q][2]..d0.textBuffer.colors.fg:rep(t-d0.size.width)d0.textBuffer[q][3]=d0.textBuffer[q][3]..d0.textBuffer.colors.bg:rep(t-d0.size.width)d0.textBuffer.dirtyLines[q]=true end end end elseif t<d0.size.width then for q=1,d0.size.height do d0[q][1]=d0[q][1]:sub(1,t)d0[q][2]=d0[q][2]:sub(1,t)d0[q][3]=d0[q][3]:sub(1,t)d0.dirtyLines[q]=true end;if d0.isLocked then if d0.isGraphics then for q=1,d0.size.height*9 do d0.graphicsBuffer[q]=d0.graphicsBuffer[q]:sub(1,t*6)end else for q=1,d0.size.height do d0.textBuffer[q][1]=d0.textBuffer[q][1]:sub(1,t)d0.textBuffer[q][2]=d0.textBuffer[q][2]:sub(1,t)d0.textBuffer[q][3]=d0.textBuffer[q][3]:sub(1,t)end end end end;d0.size.width=t;if cX>d0.size.height then for q=d0.size.height+1,cX do d0[q]={(' '):rep(t),d0.colors.fg:rep(t),d0.colors.bg:rep(t)}d0.dirtyLines[q]=true end;if d0.isLocked then if d0.isGraphics then for q=d0.size.height*9+1,cX*9 do d0.graphicsBuffer[q]=('\15'):rep(t*6)end;d0.graphicsBuffer.dirtyRects[#d0.graphicsBuffer.dirtyRects+1]={x=1,y=d0.size.height*9+1,width=d0.size.width*6,height=(cX-d0.size.height)*9}else for q=d0.size.height+1,cX do d0.textBuffer[q]={(' '):rep(t),d0.textBuffer.colors.fg:rep(t),d0.textBuffer.colors.bg:rep(t)}d0.textBuffer.dirtyLines[q]=true end end end elseif cX<d0.size.height then for q=cX+1,d0.size.height do d0[q]=nil;d0.dirtyLines[q]=nil end;if d0.isLocked then if d0.isGraphics then for q=cX*9+1,d0.size.height*9 do d0.graphicsBuffer[q]=nil end else for q=cX+1,d0.size.height do d0.textBuffer[q]=nil;d0.textBuffer.dirtyLines[q]=nil end end end end;d0.size.height=cX end;local function d1(d0)local d2=d0.cursor;local q=d2.y+1;d2.y=q;local S=d0.size;local cX=S.height;if q>cX then local d3=d0.dirtyLines;for v=1,cX-1 do d0[v]=d0[v+1]d3[v]=true end;local t=S.width;local d4=d0.colors;d0[cX]={(' '):rep(t),d4.fg:rep(t),d4.bg:rep(t)}d3[cX]=true;d2.y=cX end end;local d5={['@']=function(d0,av)local E=av[1]or 1;if E==0 then E=1 end;local d6,d7=E%d0.size.width,math.floor(E/d0.size.width)local r={d0[d0.cursor.y][1]:sub(d0.size.width-d6+1),d0[d0.cursor.y][2]:sub(d0.size.width-d6+1),d0[d0.cursor.y][3]:sub(d0.size.width-d6+1)}d0[d0.cursor.y][1]=d0[d0.cursor.y][1]:sub(1,d0.cursor.x-1)..(" "):rep(E)..d0[d0.cursor.y+d7][1]:sub(d0.cursor.x,d0.size.width-d6)d0[d0.cursor.y][2]=d0[d0.cursor.y][2]:sub(1,d0.cursor.x-1)..d0.colors.fg:rep(E)..d0[d0.cursor.y+d7][2]:sub(d0.cursor.x,d0.size.width-d6)d0[d0.cursor.y][3]=d0[d0.cursor.y][3]:sub(1,d0.cursor.x-1)..d0.colors.bg:rep(E)..d0[d0.cursor.y+d7][3]:sub(d0.cursor.x,d0.size.width-d6)d0.dirtyLines[d0.cursor.y]=true;for q=d0.cursor.y+d7+1,d0.size.height do local d8={d0[q-d7][1]:sub(d0.size.width-E+1),d0[q-d7][2]:sub(d0.size.width-E+1),d0[q-d7][3]:sub(d0.size.width-E+1)}d0[q][1]=r[1]..d0[q-d7][1]:sub(1,d0.size.width-d6)d0[q][2]=r[2]..d0[q-d7][2]:sub(1,d0.size.width-d6)d0[q][3]=r[3]..d0[q-d7][3]:sub(1,d0.size.width-d6)d0.dirtyLines[q]=true;r=d8 end;for q=d0.cursor.y+1,d0.cursor.y+d7 do d0[q][1]=(" "):rep(d0.size.width)d0[q][2]=d0.colors.fg:rep(d0.size.width)d0[q][3]=d0.colors.bg:rep(d0.size.width)d0.dirtyLines[q]=true end end,A=function(d0,av)local E=av[1]or 1;if E==0 then E=1 end;d0.cursor.y=math.max(d0.cursor.y-E,1)end,B=function(d0,av)local E=av[1]or 1;if E==0 then E=1 end;d0.cursor.y=math.min(d0.cursor.y+E,d0.size.height)end,C=function(d0,av)local E=av[1]or 1;if E==0 then E=1 end;d0.cursor.y=d0.cursor.y+math.floor((d0.cursor.x-1+E)/d0.size.width)d0.cursor.x=(d0.cursor.x-1+E)%d0.size.width+1 end,D=function(d0,av)local E=av[1]or 1;if E==0 then E=1 end;d0.cursor.y=d0.cursor.y+math.floor((d0.cursor.x-1-E)/d0.size.width)d0.cursor.x=(d0.cursor.x-1-E)%d0.size.width+1 end,E=function(d0,av)local E=av[1]or 1;if E==0 then E=1 end;d0.cursor.y=math.min(d0.cursor.y+E,d0.size.height)d0.cursor.x=1 end,F=function(d0,av)local E=av[1]or 1;if E==0 then E=1 end;d0.cursor.y=math.max(d0.cursor.y-E,1)d0.cursor.x=1 end,G=function(d0,av)local E=av[1]or 1;if E==0 then E=1 end;d0.cursor.x=math.min(E,d0.size.width)end,H=function(d0,av)local bo,a9=av[1]or 1,av[2]or 1;if bo==0 then bo=1 end;if a9==0 then a9=1 end;d0.cursor.x,d0.cursor.y=math.min(a9,d0.size.width),math.min(bo,d0.size.height)end,I=function(d0,av)end,J=function(d0,av)local r=av[1]or 0;if r==0 then d0[d0.cursor.y][1]=d0[d0.cursor.y][1]:sub(1,d0.cursor.x-1)..(" "):rep(d0.size.width-d0.cursor.x)d0[d0.cursor.y][2]=d0[d0.cursor.y][2]:sub(1,d0.cursor.x-1)..d0.colors.fg:rep(d0.size.width-d0.cursor.x)d0[d0.cursor.y][3]=d0[d0.cursor.y][3]:sub(1,d0.cursor.x-1)..d0.colors.bg:rep(d0.size.width-d0.cursor.x)d0.dirtyLines[d0.cursor.y]=true;for q=d0.cursor.y+1,d0.size.height do d0[q][1]=(" "):rep(d0.size.width)d0[q][2]=d0.colors.fg:rep(d0.size.width)d0[q][3]=d0.colors.bg:rep(d0.size.width)d0.dirtyLines[q]=true end elseif r==1 then d0[d0.cursor.y][1]=(" "):rep(d0.cursor.x)..d0[d0.cursor.y][1]:sub(d0.cursor.x)d0[d0.cursor.y][2]=d0.colors.fg:rep(d0.cursor.x)..d0[d0.cursor.y][2]:sub(d0.cursor.x)d0[d0.cursor.y][3]=d0.colors.bg:rep(d0.cursor.x)..d0[d0.cursor.y][3]:sub(d0.cursor.x)d0.dirtyLines[d0.cursor.y]=true;for q=d0.cursor.y-1,1,-1 do d0[q][1]=(" "):rep(d0.size.width)d0[q][2]=d0.colors.fg:rep(d0.size.width)d0[q][3]=d0.colors.bg:rep(d0.size.width)d0.dirtyLines[q]=true end elseif r==2 then for q=1,d0.size.height do d0[q][1]=(" "):rep(d0.size.width)d0[q][2]=d0.colors.fg:rep(d0.size.width)d0[q][3]=d0.colors.bg:rep(d0.size.width)d0.dirtyLines[q]=true end end end,K=function(d0,av)local r=av[1]or 0;if r==0 then d0[d0.cursor.y][1]=d0[d0.cursor.y][1]:sub(1,d0.cursor.x-1)..(" "):rep(d0.size.width-d0.cursor.x)d0[d0.cursor.y][2]=d0[d0.cursor.y][2]:sub(1,d0.cursor.x-1)..d0.colors.fg:rep(d0.size.width-d0.cursor.x)d0[d0.cursor.y][3]=d0[d0.cursor.y][3]:sub(1,d0.cursor.x-1)..d0.colors.bg:rep(d0.size.width-d0.cursor.x)d0.dirtyLines[d0.cursor.y]=true elseif r==1 then d0[d0.cursor.y][1]=(" "):rep(d0.cursor.x)..d0[d0.cursor.y][1]:sub(d0.cursor.x)d0[d0.cursor.y][2]=d0.colors.fg:rep(d0.cursor.x)..d0[d0.cursor.y][2]:sub(d0.cursor.x)d0[d0.cursor.y][3]=d0.colors.bg:rep(d0.cursor.x)..d0[d0.cursor.y][3]:sub(d0.cursor.x)d0.dirtyLines[d0.cursor.y]=true elseif r==2 then d0[d0.cursor.y][1]=(" "):rep(d0.size.width)d0[d0.cursor.y][2]=d0.colors.fg:rep(d0.size.width)d0[d0.cursor.y][3]=d0.colors.bg:rep(d0.size.width)d0.dirtyLines[d0.cursor.y]=true end end,L=function(d0,av)end,M=function(d0,av)end,N=function(d0,av)end,O=function(d0,av)end,P=function(d0,av)local E=av[1]or 1;if E==0 then E=1 end;local d6,d7=E%d0.size.width,math.floor(E/d0.size.width)local r={(" "):rep(d6),d0.colors.fg:rep(d6),d0.colors.bg:rep(d6)}for q=d0.size.height-d7,d0.cursor.y+1,-1 do local d8={d0[q+d7][1]:sub(1,d6),d0[q+d7][2]:sub(1,d6),d0[q+d7][3]:sub(1,d6)}d0[q][1]=d0[q+d7][1]:sub(d6+1)..r[1]d0[q][2]=d0[q+d7][2]:sub(d6+1)..r[2]d0[q][3]=d0[q+d7][3]:sub(d6+1)..r[3]d0.dirtyLines[q]=true;r=d8 end;for q=d0.size.height-d7+1,d0.size.height do d0[q][1]=(" "):rep(d0.size.width)d0[q][2]=d0.colors.fg:rep(d0.size.width)d0[q][3]=d0.colors.bg:rep(d0.size.width)d0.dirtyLines[q]=true end;d0[d0.cursor.y][1]=d0[d0.cursor.y][1]:sub(1,d0.cursor.x-1)..d0[d0.cursor.y+d7][1]:sub(d0.cursor.x+d6,d0.size.width)..r[1]d0[d0.cursor.y][2]=d0[d0.cursor.y][2]:sub(1,d0.cursor.x-1)..d0[d0.cursor.y+d7][2]:sub(d0.cursor.x+d6,d0.size.width)..r[2]d0[d0.cursor.y][3]=d0[d0.cursor.y][3]:sub(1,d0.cursor.x-1)..d0[d0.cursor.y+d7][3]:sub(d0.cursor.x+d6,d0.size.width)..r[3]d0.dirtyLines[d0.cursor.y]=true end,Q=function(d0,av)end,R=function(d0,av)end,S=function(d0,av)local r=av[1]or 0;if r==0 then r=1 end;for z=1,r do table.insert(d0,1,{(' '):rep(d0.size.width),d0.colors.fg:rep(d0.size.width),d0.colors.bg:rep(d0.size.width)})d0[d0.size.height+1]=nil end end,T=function(d0,av)local r=av[1]or 0;if r==0 then r=1 end;for z=1,r do table.remove(d0,1)d0[d0.size.height]={(' '):rep(d0.size.width),d0.colors.fg:rep(d0.size.width),d0.colors.bg:rep(d0.size.width)}end end,U=function(d0,av)end,V=function(d0,av)end,W=function(d0,av)end,X=function(d0,av)end,Y=function(d0,av)end,Z=function(d0,av)end,['[']=function(d0,av)end,['\\']=function(d0,av)end,[']']=function(d0,av)end,['^']=function(d0,av)end,['_']=function(d0,av)end,['`']=function(d0,av)end,a=function(d0,av)end,b=function(d0,av)end,c=function(d0,av)end,d=function(d0,av)end,e=function(d0,av)end,f=function(d0,av)end,g=function(d0,av)end,h=function(d0,av)if av[1]==25 then d0.cursorBlink=true end end,i=function(d0,av)end,j=function(d0,av)end,k=function(d0,av)end,l=function(d0,av)if av[1]==25 then d0.cursorBlink=false end end,m=function(d0,av)local r,A=av[1]or 0,av[2]if r==0 then d0.colors.fg,d0.colors.bg,d0.colors.bold='0','f',false elseif r==1 then d0.colors.bold=true elseif r==7 or r==27 then d0.colors.fg,d0.colors.bg=d0.colors.bg,d0.colors.fg elseif r==22 then d0.colors.bold=false elseif r>=30 and r<=37 then d0.colors.fg=("%x"):format(15-(r-30)-(d0.colors.bold and 8 or 0))elseif r==39 then d0.colors.fg='0'elseif r>=40 and r<=47 then d0.colors.bg=("%x"):format(15-(r-40)-(d0.colors.bold and 8 or 0))elseif r==49 then d0.colors.bg='f'elseif r>=90 and r<=97 then d0.colors.fg=("%x"):format(15-(r-90)-8)elseif r>=100 and r<=107 then d0.colors.bg=("%x"):format(15-(r-100)-8)end;if A~=nil then if A==0 then d0.colors.fg,d0.colors.bg='0','f'elseif A==1 then d0.colors.bold=true elseif A==7 or A==27 then d0.colors.fg,d0.colors.bg=d0.colors.bg,d0.colors.fg elseif A==22 then d0.colors.bold=false elseif A>=30 and A<=37 then d0.colors.fg=("%x"):format(15-(A-30)-(d0.colors.bold and 8 or 0))elseif A==39 then d0.colors.fg='0'elseif A>=40 and A<=47 then d0.colors.bg=("%x"):format(15-(A-40)-(d0.colors.bold and 8 or 0))elseif A==49 then d0.colors.bg='f'elseif A>=90 and A<=97 then d0.colors.fg=("%x"):format(15-(A-90)-8)elseif A>=100 and A<=107 then d0.colors.bg=("%x"):format(15-(A-100)-8)end end end,n=function(d0,av)end,o=function(d0,av)end}for v=0x70,0x7F do d5[string.char(v)]=function(d0,av)end end;function terminal.write(d0,d9)local ax,S=1,0;local function da(p)if S==0 then ax,S=p,0;return end;while d0.cursor.x+S>d0.size.width do d0[d0.cursor.y][1]=d0[d0.cursor.y][1]:sub(1,d0.cursor.x-1)..d9:sub(ax,ax+d0.size.width-d0.cursor.x)d0[d0.cursor.y][2]=d0[d0.cursor.y][2]:sub(1,d0.cursor.x-1)..d0.colors.fg:rep(d0.size.width-d0.cursor.x+1)d0[d0.cursor.y][3]=d0[d0.cursor.y][3]:sub(1,d0.cursor.x-1)..d0.colors.bg:rep(d0.size.width-d0.cursor.x+1)d0.dirtyLines[d0.cursor.y]=true;ax=ax+d0.size.width-d0.cursor.x+1;S=S-(d0.size.width-d0.cursor.x+1)d0.cursor.x=1;d1(d0)end;d0[d0.cursor.y][1]=d0[d0.cursor.y][1]:sub(1,d0.cursor.x-1)..d9:sub(ax,ax+S-1)..d0[d0.cursor.y][1]:sub(d0.cursor.x+S)d0[d0.cursor.y][2]=d0[d0.cursor.y][2]:sub(1,d0.cursor.x-1)..d0.colors.fg:rep(S)..d0[d0.cursor.y][2]:sub(d0.cursor.x+S)d0[d0.cursor.y][3]=d0[d0.cursor.y][3]:sub(1,d0.cursor.x-1)..d0.colors.bg:rep(S)..d0[d0.cursor.y][3]:sub(d0.cursor.x+S)d0.dirtyLines[d0.cursor.y]=true;d0.cursor.x=d0.cursor.x+S;ax,S=p,0 end;local db=0;local av,dc;for p,a9,r in d9:gmatch"()(.)()"do if db==0 then if a9=='\a'then da(r)elseif a9=='\b'then da(r)if d0.cursor.x==1 then if d0.cursor.y>1 then d0.cursor.x,d0.cursor.y=d0.size.width,d0.cursor.y-1 end else d0.cursor.x=d0.cursor.x-1 end elseif a9=='\t'then da(r)d0.cursor.x=math.floor((d0.cursor.x-1)/8)*8+9;if d0.cursor.x>d0.size.width then d0.cursor.x=1;d1(d0)end elseif a9=='\n'then da(r)d1(d0)if d0.flags.nlcr then d0.cursor.x=1 end elseif a9=='\f'then da(r)d1(d0)elseif a9=='\r'then da(r)d0.cursor.x=1 elseif a9=='\27'then db=1 else S=S+1 end elseif db==1 then if false then elseif a9=='['then db=2;av,dc={},0 elseif a9==']'then if d9:byte(r)==0x50 then db=4;av={}else db=3;av,dc={},0 end else da(r)db=0 end elseif db==2 then if a9>='@'and a9<='\127'then da(r)av[#av+1]=dc;d5[a9](d0,av)db=0 elseif a9>='0'and a9<='?'then if a9<='9'then dc=dc*10+tonumber(a9)elseif a9==';'then av[#av+1],dc=dc,0 end else da(r)db=0 end elseif db==3 then if a9=='\\'and d9:byte(p-1)=='\27'then da(r)db=0 end elseif db==4 then if#av==0 then av[1]=tonumber(a9,16)or 0 elseif#av==1 and not dc then dc=(tonumber(a9,16)or 0)*16 elseif#av==1 then av[2],dc=dc+(tonumber(a9,16)or 0),nil elseif#av==2 and not dc then dc=(tonumber(a9,16)or 0)*16 elseif#av==2 then av[3],dc=dc+(tonumber(a9,16)or 0),nil elseif#av==3 and not dc then dc=(tonumber(a9,16)or 0)*16 elseif#av==3 then da(r)av[4],dc=dc+(tonumber(a9,16)or 0),nil;d0.palette[av[1]]={av[2]/255,av[3]/255,av[4]/255}d0.dirtyPalette[av[1]]=true;db=0 end end end;da()end;function syscalls.write(process,aq,...)if not process.stdout then return end;local function dd(y)if process.stdout.isTTY then terminal.write(process.stdout,y)else process.stdout.write(y)end end;local args=table.pack(...)for v=1,args.n do if v>1 then dd("\t")end;dd(tostring(args[v]))end;if process.stdout.isTTY then terminal.redraw(process.stdout)end end;function syscalls.writeerr(process,aq,...)if not process.stderr then return end;local function dd(y)if process.stderr.isTTY then terminal.write(process.stderr,y)else process.stderr.write(y)end end;local args=table.pack(...)for v=1,args.n do if v>1 then dd("\t")end;dd(tostring(args[v]))end;if process.stderr.isTTY then terminal.redraw(process.stderr)end end;function syscalls.read(process,aq,r)expect(1,r,"number")if process.stdin then if process.stdin.eof then process.stdin.eof=false;return nil end;while#process.stdin.buffer<r do if process.stdin.eof then process.stdin.eof=false;return nil end;if process.stdin.isTTY and not process.stdin.flags.delay then return nil end;if process.stdin.read then local bn=process.stdin.read(r-#process.stdin.buffer)if not bn then return nil end;process.stdin.buffer=process.stdin.buffer..bn else return kSyscallYield,"read",r end end;local bn=process.stdin.buffer:sub(1,r-1)process.stdin.buffer=process.stdin.buffer:sub(r)return bn else return nil end end;function syscalls.readline(process,aq)if process.stdin then if process.stdin.eof then process.stdin.eof=false;return nil end;while not process.stdin.buffer:find("\n")do if process.stdin.eof then process.stdin.eof=false;return nil end;if process.stdin.isTTY and not process.stdin.flags.delay then return nil end;if process.stdin.read then local bn=process.stdin.read()if not bn then return nil end;process.stdin.buffer=process.stdin.buffer..bn else return kSyscallYield,"readline"end end;local r=process.stdin.buffer:find("\n")local bn=process.stdin.buffer:sub(1,r-1)process.stdin.buffer=process.stdin.buffer:sub(r+1)return bn else return nil end end;function syscalls.termctl(process,aq,de)expect(1,de,"table","nil")if not process.stdout or not process.stdout.isTTY then return nil end;if de then expect.field(de,"cbreak","boolean","nil")expect.field(de,"delay","boolean","nil")expect.field(de,"echo","boolean","nil")expect.field(de,"keypad","boolean","nil")expect.field(de,"nlcr","boolean","nil")expect.field(de,"raw","boolean","nil")for h,i in pairs(de)do if process.stdout.flags[h]~=nil then process.stdout.flags[h]=i end end end;local y=deepcopy(process.stdout.flags)y.hasgfx=term.getGraphicsMode~=nil;return y end;function terminal.openterm(d0,process)if d0.isLocked then if not d0.isGraphics and d0.frontmostProcess==process then return d0.screenHandle end;return nil,"Terminal already in use"end;local S=d0.size;local cS={cursor={x=1,y=1},cursorBlink=false,colors={fg='0',bg='f'},palette={},dirtyLines={},dirtyPalette={}}d0.textBuffer=cS;d0.isLocked=true;d0.isGraphics=false;for q=1,S.height do cS[q]={(' '):rep(S.width),('0'):rep(S.width),('f'):rep(S.width)}cS.dirtyLines[q]=true end;for v=0,15 do cS.palette[v]={term.nativePaletteColor(2^v)}cS.dirtyPalette[v]=true end;d0.processList[#d0.processList+1]=d0.frontmostProcess;d0.frontmostProcess=process;local df=setmetatable({},{__name="Terminal"})local dg=terminal.redraw;local expect=expect;d0.screenHandle=df;function df.close()if not df then error("terminal is already closed",2)end;df=nil;d0.isLocked=false;d0.frontmostProcess=table.remove(d0.processList)d0.screenHandle=nil;dg(d0,true)end;function df.write(d9)if not df then error("terminal is already closed",2)end;d9=tostring(d9)expect(1,d9,"string")if cS.cursor.y<1 or cS.cursor.y>S.height then return elseif cS.cursor.x>S.width or cS.cursor.x+#d9<1 then cS.cursor.x=cS.cursor.x+#d9;return elseif cS.cursor.x<1 then d9=d9:sub(-cS.cursor.x+2)cS.cursor.x=1 end;local dh=#d9;if cS.cursor.x+#d9>S.width then d9=d9:sub(1,S.width-cS.cursor.x+1)end;cS[cS.cursor.y][1]=cS[cS.cursor.y][1]:sub(1,cS.cursor.x-1)..d9 ..cS[cS.cursor.y][1]:sub(cS.cursor.x+#d9)cS[cS.cursor.y][2]=cS[cS.cursor.y][2]:sub(1,cS.cursor.x-1)..cS.colors.fg:rep(#d9)..cS[cS.cursor.y][2]:sub(cS.cursor.x+#d9)cS[cS.cursor.y][3]=cS[cS.cursor.y][3]:sub(1,cS.cursor.x-1)..cS.colors.bg:rep(#d9)..cS[cS.cursor.y][3]:sub(cS.cursor.x+#d9)cS.cursor.x=cS.cursor.x+dh;cS.dirtyLines[cS.cursor.y]=true end;function df.blit(d9,di,dj)if not df then error("terminal is already closed",2)end;d9=tostring(d9)expect(1,d9,"string")expect(2,di,"string")expect(3,dj,"string")if#d9~=#di or#di~=#dj then error("Arguments must be the same length",2)end;if cS.cursor.y<1 or cS.cursor.y>S.height then return elseif cS.cursor.x>S.width or cS.cursor.x<1-#d9 then cS.cursor.x=cS.cursor.x+#d9;dg(d0)return elseif cS.cursor.x<1 then d9,di,dj=d9:sub(-cS.cursor.x+2),di:sub(-cS.cursor.x+2),dj:sub(-cS.cursor.x+2)cS.cursor.x=1 end;local dh=#d9;if cS.cursor.x+#d9>S.width then d9,di,dj=d9:sub(1,S.width-cS.cursor.x+1),di:sub(1,S.width-cS.cursor.x+1),dj:sub(1,S.width-cS.cursor.x+1)end;cS[cS.cursor.y][1]=cS[cS.cursor.y][1]:sub(1,cS.cursor.x-1)..d9 ..cS[cS.cursor.y][1]:sub(cS.cursor.x+#d9)cS[cS.cursor.y][2]=cS[cS.cursor.y][2]:sub(1,cS.cursor.x-1)..di..cS[cS.cursor.y][2]:sub(cS.cursor.x+#di)cS[cS.cursor.y][3]=cS[cS.cursor.y][3]:sub(1,cS.cursor.x-1)..dj..cS[cS.cursor.y][3]:sub(cS.cursor.x+#dj)cS.cursor.x=cS.cursor.x+dh;cS.dirtyLines[cS.cursor.y]=true end;function df.clear()if not df then error("terminal is already closed",2)end;for q=1,S.height do cS[q]={(' '):rep(S.width),cS.colors.fg:rep(S.width),cS.colors.bg:rep(S.width)}cS.dirtyLines[q]=true end end;function df.clearLine()if not df then error("terminal is already closed",2)end;if cS.cursor.y>=1 and cS.cursor.y<=S.height then cS[cS.cursor.y]={(' '):rep(S.width),cS.colors.fg:rep(S.width),cS.colors.bg:rep(S.width)}cS.dirtyLines[cS.cursor.y]=true end end;function df.getCursorPos()if not df then error("terminal is already closed",2)end;return cS.cursor.x,cS.cursor.y end;function df.setCursorPos(dk,dl)if not df then error("terminal is already closed",2)end;expect(1,dk,"number")expect(2,dl,"number")if dk==cS.cursor.x and dl==cS.cursor.y then return end;cS.cursor.x,cS.cursor.y=math.floor(dk),math.floor(dl)end;function df.getCursorBlink()if not df then error("terminal is already closed",2)end;return cS.cursorBlink end;function df.setCursorBlink(ab)if not df then error("terminal is already closed",2)end;expect(1,ab,"boolean")cS.cursorBlink=ab end;function df.isColor()if not df then error("terminal is already closed",2)end;return true end;function df.getSize()if not df then error("terminal is already closed",2)end;return S.width,S.height end;function df.scroll(dm)if not df then error("terminal is already closed",2)end;expect(1,dm,"number")if math.abs(dm)>=S.width then for q=1,S.height do cS[q]={(' '):rep(S.width),cS.colors.fg:rep(S.width),cS.colors.bg:rep(S.width)}end elseif dm>0 then for v=dm+1,S.height do cS[v-dm]=cS[v]end;for v=S.height-dm+1,S.height do cS[v]={(' '):rep(S.width),cS.colors.fg:rep(S.width),cS.colors.bg:rep(S.width)}end elseif dm<0 then for v=1,S.height+dm do cS[v-dm]=cS[v]end;for v=1,-dm do cS[v]={(' '):rep(S.width),cS.colors.fg:rep(S.width),cS.colors.bg:rep(S.width)}end else return end;for v=1,S.height do cS.dirtyLines[v]=true end end;function df.getTextColor()if not df then error("terminal is already closed",2)end;return tonumber(cS.colors.fg,16)end;function df.setTextColor(dn)if not df then error("terminal is already closed",2)end;expect(1,dn,"number")expect.range(dn,0,15)cS.colors.fg=("%x"):format(dn)end;function df.getBackgroundColor()if not df then error("terminal is already closed",2)end;return tonumber(cS.colors.bg,16)end;function df.setBackgroundColor(dn)if not df then error("terminal is already closed",2)end;expect(1,dn,"number")expect.range(dn,0,15)cS.colors.bg=("%x"):format(dn)end;function df.getPaletteColor(dn)if not df then error("terminal is already closed",2)end;expect(1,dn,"number")expect.range(dn,0,15)return table.unpack(cS.palette[math.floor(dn)])end;function df.setPaletteColor(dn,bo,dp,ab)if not df then error("terminal is already closed",2)end;expect(1,dn,"number")expect(2,bo,"number")if dp==nil and ab==nil then bo,dp,ab=bit32.band(bit32.rshift(bo,16),0xFF)/255,bit32.band(bit32.rshift(bo,8),0xFF)/255,bit32.band(bo,0xFF)/255 end;expect(3,dp,"number")expect(4,ab,"number")expect.range(dn,0,15)if bo<0 or bo>1 then error("bad argument #2 (value out of range)",2)end;if dp<0 or dp>1 then error("bad argument #3 (value out of range)",2)end;if ab<0 or ab>1 then error("bad argument #4 (value out of range)",2)end;cS.palette[math.floor(dn)]={bo,dp,ab}cS.dirtyPalette[math.floor(dn)]=true end;function df.getLine(q)if not df then error("terminal is already closed",2)end;expect(1,q,"number")local N=cS[q]return N and table.unpack(N,1,3)end;for z,i in pairs(df)do setfenv(i,process.env)debug.protect(i)end;df.isColour=df.isColor;df.getTextColour=df.getTextColor;df.setTextColour=df.setTextColor;df.getBackgroundColour=df.getBackgroundColor;df.setBackgroundColour=df.setBackgroundColor;df.getPaletteColour=df.getPaletteColor;df.setPaletteColour=df.setPaletteColor;process.dependents[#process.dependents+1]={gc=function()if df then return df.close()end end}dg(d0,true)return df end;function syscalls.openterm(process,aq)if not process.stdout or not process.stdout.isTTY then return nil,"No valid TTY attached"end;if process~=process.stdout.frontmostProcess then syscalls.kill(KERNEL,nil,process.id,22)if process.paused then return kSyscallYield,"openterm"end end;return terminal.openterm(process.stdout,process)end;function terminal.opengfx(d0,process)if not term.drawPixels then return nil,"Graphics mode not supported"end;if d0.isLocked then if d0.isGraphics and d0.frontmostProcess==process then return d0.screenHandle end;return nil,"Terminal already in use"end;local S=d0.size;local cS={palette={},dirtyRects={},dirtyPalette={},frozen=false}d0.graphicsBuffer=cS;d0.isLocked=true;d0.isGraphics=true;for q=1,S.height*9 do cS[q]=('\15'):rep(S.width*6)end;for v=0,15 do cS.palette[v]={term.nativePaletteColor(2^v)}cS.dirtyPalette[v]=true end;for v=16,255 do cS.palette[v]={0,0,0}cS.dirtyPalette[v]=true end;d0.processList[#d0.processList+1]=d0.frontmostProcess;d0.frontmostProcess=process;local df=setmetatable({},{__name="GFXTerminal"})local dg=terminal.redraw;local expect=expect;d0.screenHandle=df;function df.close()if not df then error("terminal is already closed",2)end;df=nil;d0.isLocked=false;d0.frontmostProcess=table.remove(d0.processList)d0.screenHandle=nil;dg(d0,true)end;function df.getSize()return S.width*6,S.height*9 end;function df.clear()if not df then error("terminal is already closed",2)end;for q=1,S.height*9 do cS[q]=('\15'):rep(S.width*6)end;dg(d0,true)end;function df.getPixel(p,q)if not df then error("terminal is already closed",2)end;expect(1,p,"number")expect(2,q,"number")expect.range(p,0,S.width*6-1)expect.range(q,0,S.height*9-1)p,q=math.floor(p),math.floor(q)return cS[q+1]:byte(p+1)end;function df.setPixel(p,q,dn)if not df then error("terminal is already closed",2)end;expect(1,p,"number")expect(2,q,"number")expect(3,dn,"number")expect.range(p,0,S.width*6-1)expect.range(q,0,S.height*9-1)expect.range(dn,0,255)p,q=math.floor(p),math.floor(q)cS[q+1]=cS[q+1]:sub(1,p)..string.char(dn)..cS[q+1]:sub(p+2)cS.dirtyRects[#cS.dirtyRects+1]={x=p,y=q,color=dn}end;function df.getPixels(p,q,t,cX,dq)if not df then error("terminal is already closed",2)end;expect(1,p,"number")expect(2,q,"number")expect(3,t,"number")expect(4,cX,"number")expect(5,dq,"boolean","nil")expect.range(t,0)expect.range(cX,0)p,q=math.floor(p),math.floor(q)local y={}for dr=1,cX do if dq then y[dr]=cS[q+dr]:sub(p+1,p+t)else y[dr]={cS[q+dr]:sub(p+1,p+t):byte(1,-1)}end end;return y end;function df.drawPixels(p,q,bh,t,cX)if not df then error("terminal is already closed",2)end;expect(1,p,"number")expect(2,q,"number")expect(3,bh,"table","number")local ds=type(bh)=="number"expect(4,t,"number",not ds and"nil"or nil)expect(5,cX,"number",not ds and"nil"or nil)expect.range(p,0,S.width*6-1)expect.range(q,0,S.height*9-1)if t then expect.range(t,0)end;if cX then expect.range(cX,0)end;if ds then expect.range(bh,0,255)end;if t==0 or cX==0 then return end;p,q=math.floor(p),math.floor(q)if t and p+t>=S.width*6 then t=S.width*6-p end;cX=cX or#bh;local dt={x=p,y=q,width=t,height=cX}for dr=1,cX do if q+dr>S.height*9 then break end;if ds then local bn=string.char(bh):rep(t)cS[q+dr]=cS[q+dr]:sub(1,p)..bn..cS[q+dr]:sub(p+t+1)dt[dr]=bn elseif bh[dr]~=nil then if type(bh[dr])~="table"and type(bh[dr])~="string"then error("bad argument #3 to 'drawPixels' (invalid row "..dr..")",2)end;local t=t or#bh[dr]if p+t>=S.width*6 then t=S.width*6-p end;local bn;if type(bh[dr])=="string"then bn=bh[dr]if#bn<t then bn=bn..('\15'):rep(t-#bn)elseif#bn>t then bn=bn:sub(1,t)end else bn=""for du=1,t do bn=bn..string.char(bh[dr][du]or cS[q+dr]:byte(p+du))end end;cS[q+dr]=cS[q+dr]:sub(1,p)..bn..cS[q+dr]:sub(p+t+1)dt[dr]=bn end end;cS.dirtyRects[#cS.dirtyRects+1]=dt end;function df.getFrozen()if not df then error("terminal is already closed",2)end;return cS.frozen end;function df.setFrozen(f)if not df then error("terminal is already closed",2)end;expect(1,f,"boolean")cS.frozen=f end;function df.getPaletteColor(dn)if not df then error("terminal is already closed",2)end;expect(1,dn,"number")expect.range(dn,0,255)return table.unpack(cS.palette[dn])end;function df.setPaletteColor(dn,bo,dp,ab)if not df then error("terminal is already closed",2)end;expect(1,dn,"number")expect(2,bo,"number")if dp==nil and ab==nil then bo,dp,ab=bit32.band(bit32.rshift(bo,16),0xFF)/255,bit32.band(bit32.rshift(bo,8),0xFF)/255,bit32.band(bo,0xFF)/255 end;expect(3,dp,"number")expect(4,ab,"number")expect.range(bo,0,1)expect.range(dp,0,1)expect.range(ab,0,1)expect.range(dn,0,255)cS.palette[dn]={bo,dp,ab}cS.dirtyPalette[dn]=true end;for z,i in pairs(df)do setfenv(i,process.env)debug.protect(i)end;df.getPaletteColour=df.getPaletteColor;df.setPaletteColour=df.setPaletteColor;process.dependents[#process.dependents+1]={gc=function()if df then return df.close()end end}dg(d0,true)return df end;function syscalls.opengfx(process,aq)if not process.stdout or not process.stdout.isTTY then return nil,"No valid TTY attached"end;if process~=process.stdout.frontmostProcess then syscalls.kill(KERNEL,nil,process.id,22)if process.paused then return kSyscallYield,"openterm"end end;return terminal.opengfx(process.stdout,process)end;function syscalls.mktty(process,aq,t,cX)expect(1,t,"number")expect(2,cX,"number")expect.range(t,1)expect.range(cX,1)local d0=terminal.makeTTY(term,t,cX)d0.id=math.random(0,0x7FFFFFFF)d0.process=process;local a5=setmetatable({},{__index=d0,__metatable={}})terminal.userTTYs[a5]=d0;process.dependents[#process.dependents+1]={gc=function()terminal.userTTYs[a5]=nil end}return a5 end;function syscalls.stdin(process,aq,dv)expect(1,dv,"number","table","string","nil")if process.stdin and process.stdin.isTTY and process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)process.stdin.preBuffer=""end;if type(dv)=="number"then process.stdin=TTY[dv]elseif type(dv)=="string"then local dw=hardware.get(dv)if not dw then error("bad argument #1 (no such device)",2)end;if not dw.internalState.tty then error("bad argument #1 (no TTY available on device)",2)end;dv=dw.internalState.tty;if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)dv.processList[#dv.processList+1]=dv.frontmostProcess;dv.frontmostProcess=process end;process.stdin=dv elseif dv==nil then process.stdin=nil else if dv.isTTY then dv=terminal.userTTYs[dv]if not dv then error("bad argument #1 (invalid TTY)",2)end;if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)dv.processList[#dv.processList+1]=dv.frontmostProcess;dv.frontmostProcess=process;dv.preBuffer=""end else expect.field(dv,"read","function")local dx=dv.read;dv={buffer="",read=function(...)local bf,u=userModeCallback(process,dx,...)if bf then return u else error(u,2)end end}end;process.stdin=dv end end;function syscalls.stdout(process,aq,dv)expect(1,dv,"number","table","string","nil")if process.stdout and process.stdout.isTTY and process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.stdout.frontmostProcess.name)end end;if type(dv)=="number"then process.stdout=TTY[dv]elseif type(dv)=="string"then local dw=hardware.get(dv)if not dw then error("bad argument #1 (no such device)",2)end;if not dw.internalState.tty then error("bad argument #1 (no TTY available on device)",2)end;dv=dw.internalState.tty;if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)dv.processList[#dv.processList+1]=dv.frontmostProcess;dv.frontmostProcess=process;if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.name)end end;process.stdout=dv elseif dv==nil then process.stdout=nil else if dv.isTTY then dv=terminal.userTTYs[dv]if not dv then error("bad argument #1 (invalid TTY)",2)end;if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)dv.processList[#dv.processList+1]=dv.frontmostProcess;dv.frontmostProcess=process;if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.name)end end else expect.field(dv,"write","function")local dd=dv.write;dv={write=function(...)local bf,u=userModeCallback(process,dd,...)if bf then return u else error(u,2)end end}end;process.stdout=dv end end;function syscalls.stderr(process,aq,dv)expect(1,dv,"number","table","string","nil")if process.stderr and process.stderr.isTTY and process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)end;if type(dv)=="number"then process.stderr=TTY[dv]elseif type(dv)=="string"then local dw=hardware.get(dv)if not dw then error("bad argument #1 (no such device)",2)end;if not dw.internalState.tty then error("bad argument #1 (no TTY available on device)",2)end;dv=dw.internalState.tty;if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)dv.processList[#dv.processList+1]=dv.frontmostProcess;dv.frontmostProcess=process end;process.stderr=dv elseif dv==nil then process.stderr=nil else if dv.isTTY then dv=terminal.userTTYs[dv]if not dv then error("bad argument #1 (invalid TTY)",2)end;if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)dv.processList[#dv.processList+1]=dv.frontmostProcess;dv.frontmostProcess=process end else expect.field(dv,"write","function")local dd=dv.write;dv={write=function(...)local bf,u=userModeCallback(process,dd,...)if bf then return u else error(u,2)end end}end;process.stderr=dv end end;function syscalls.istty(process,aq)return process.stdin and process.stdin.isTTY,process.stdout and process.stdout.isTTY end;function syscalls.termsize(process,aq)if not process.stdout or not process.stdout.isTTY then return nil,nil end;return process.stdout.size.width,process.stdout.size.height end;syslogs={default={stream={},tty=KERNEL.stdout,tty_level=args.loglevel,colorize=true}}local dy={[0]="Debug","Info","Notice","Warning","Error","Critical","Panic"}local dz={}for v=0,#dy do dz[dy[v]:lower()]=v end;local dA={[0]='\27[90m','\27[97m','\27[36m','\27[93m','\27[31m','\27[95m','\27[96m'}local function dB(y,am,v,aa)if v>=aa then return tostring(y[v])else return tostring(y[v])..am..dB(y,am,v+1,aa)end end;function syscalls.syslog(process,aq,bC,...)local args=table.pack(...)if type(bC)=="table"then expect.field(bC,"name","string","nil")expect.field(bC,"category","string","nil")expect.field(bC,"level","number","string","nil")expect.field(bC,"time","number","nil")expect.field(bC,"process","number","nil")expect.field(bC,"thread","number","nil")expect.field(bC,"module","string","nil")expect.field(bC,"traceback","boolean","nil")if type(bC.level)=="string"then bC.level=dz[bC.level:lower()]if not bC.level then error("bad field 'level' (invalid name)",0)end elseif bC.level and(bC.level<0 or bC.level>#dy)then error("bad field 'level' (level out of range)",0)end;bC.name=bC.name or"default"bC.process=bC.process or process.id;bC.thread=bC.thread or aq and aq.id;bC.level=bC.level or 1;bC.time=bC.time or os.epoch"utc"else local r=args.n;table.insert(args,1,bC)args.n=r+1;bC={process=process.id,thread=aq and aq.id,level=1,name="default",time=os.epoch"utc"}end;local dC=syslogs[bC.name]if dC==nil then error("No such log named "..bC.name,0)end;local ae;for v=1,args.n do ae=(v==1 and""or ae.." ")..serialize(args[v])end;if dC.file then dC.file.write(("[%s]%s %s[%d%s]%s [%s]: %s\n"):format(os.date("%b %d %X",bC.time/1000),bC.category and" <"..bC.category..">"or"",processes[bC.process]and processes[bC.process].name or"(unknown)",bC.process,bC.thread and":"..bC.thread or"",bC.module and" ("..bC.module..")"or"",dy[bC.level],dB(args," ",1,args.n)))dC.file.flush()end;if dC.stream then bC.message=ae;for z,i in pairs(dC.stream)do local bf=true;if i.filter then local m,dD,aD=""local v=1;local dE,dF=false,false;while v<#i.filter do if dD==nil then m,v=i.filter:match("(%a+)%s*()",v)if bC[m]==nil then bf=false;break end;dD=""elseif aD==nil then local b5=i.filter:sub(v,v+1)if b5=="=="or b5=="!="or b5=="=%"or b5=="!%"or b5=="<="or b5==">="then dD=b5 elseif b5=="~="then dD="!="elseif b5=="~%"then dD="!%"elseif i.filter:sub(v,v)=='<'or i.filter:sub(v,v)=='>'then dD=i.filter:sub(v,v)else bf=false;break end;aD=""else local a9=i.filter:sub(v,v)if dE then if a9==dE and not dF then dE,dF=false,false else aD=aD..a9;if not dF and a9=='\\'then dF=true else dF=false end end elseif a9=='"'or a9=="'"then dE=a9 elseif a9=='|'or a9==';'then if dD=="=="and bC[m]==aD or dD=="!="and bC[m]~=aD or dD=="=%"and bC[m]:match(aD)or dD=="!%"and not bC[m]:match(aD)or dD=="<"and(tonumber(bC[m])or 0)<(tonumber(aD)or 0)or dD=="<="and(tonumber(bC[m])or 0)<=(tonumber(aD)or 0)or dD==">="and(tonumber(bC[m])or 0)>=(tonumber(aD)or 0)or dD==">"and(tonumber(bC[m])or 0)>(tonumber(aD)or 0)then if a9=='|'then v=i.filter:match("[^;]*;+()",v)if v==nil then break end;v=v-1 end;m,dD,aD=""dE,dF=false,false else bf=a9=='|'aD=""if not bf then break end end elseif not(a9==' 'and aD=="")then aD=aD..a9 end;v=v+1 end end;if dE then bf=false;break end end;if bf then local process=processes[i.pid]if process then process.eventQueue[#process.eventQueue+1]={"syslog",deepcopy(bC)}end end end end;if dC.tty and dC.tty_level<=bC.level then if dC.tty.isTTY then local a0=dB(args," ",1,args.n)if dC.colorize and bC.traceback then a0=a0:gsub("\t","  "):gsub("([^\n]+):(%d+):","\27[96m%1\27[37m:\27[95m%2\27[37m:"):gsub("'([^']+)'\n","\27[93m'%1'\27[37m\n")end;terminal.write(dC.tty,("%s[%s]%s %s[%d%s]%s [%s]: %s%s\n"):format(dC.colorize and dA[bC.level]or"",os.date("%b %d %X",bC.time/1000),bC.category and" <"..bC.category..">"or"",processes[bC.process]and processes[bC.process].name or"(unknown)",bC.process,bC.thread and":"..bC.thread or"",bC.module and" ("..bC.module..")"or"",dy[bC.level],a0,dC.colorize and"\27[0m"or""))terminal.redraw(dC.tty)else end end end;function syscalls.mklog(process,aq,m,dG,bb)expect(1,m,"string")expect(2,dG,"boolean","nil")expect(3,bb,"string","nil")if syslogs[m]then return end;syslogs[m]={}if bb then local o;syslogs[m].file,o=filesystem.open(process,bb,"a")if syslogs[m].file==nil then syslogs[m]=nil;return error("Could not open log file: "..o,0)end end;if dG then syslogs[m].stream={}end end;function syscalls.rmlog(process,aq,m)expect(1,m,"string")if m=="default"then error("Cannot delete default log",0)end;if not syslogs[m]then error("Log does not exist",0)end;if syslogs[m].stream then for z,i in pairs(syslogs[m].stream)do processes[i.pid].eventQueue[#processes[i.pid].eventQueue+1]={"syslog_close",{id=i.id}}processes[i.pid].dependents[i.id]=nil end end;syslogs[m]=nil end;function syscalls.openlog(process,aq,m,dH)expect(1,m,"string")expect(2,dH,"string","nil")if not syslogs[m]then error("Log does not exist",0)end;if not syslogs[m].stream then error("Log does not have streaming enabled",0)end;local aA=#process.dependents+1;local cM=process.id;process.dependents[aA]={type="log",name=m,filter=dH,gc=function()for v,i in pairs(syslogs[m].stream)do if i.id==aA and i.pid==cM then syslogs[m].stream[v]=nil end end end}syslogs[m].stream[#syslogs[m].stream+1]={pid=cM,id=aA,filter=dH}return aA end;function syscalls.closelog(process,aq,m)expect(1,m,"string","number")if type(m)=="string"then if not syslogs[m]then error("Log does not exist",0)end;if not syslogs[m].stream then error("Log does not have streaming enabled",0)end;for v,i in pairs(syslogs[m].stream)do if i.pid==process.id then process.dependents[i.id]=nil;syslogs[m].stream[v]=nil end end else if not process.dependents[m]then error("Log connection does not exist",0)end;local dC=syslogs[process.dependents[m].name].stream;for v,i in pairs(dC)do if i.pid==process.id and i.id==m then process.dependents[i.id]=nil;dC[v]=nil;break end end end end;function syscalls.logtty(process,aq,m,d0,b0)if process.user~="root"then error("Permission denied",0)end;expect(1,m,"string")expect(2,d0,"table","number","nil")expect(3,b0,"number","nil")if not syslogs[m]then error("Log does not exist",0)end;syslogs[m].tty=type(d0)=="table"and d0 or TTY[d0]syslogs[m].tty_level=b0;return true end;function syslog.log(bC,...)return pcall(syscalls.syslog,KERNEL,nil,bC,...)end;function syslog.debug(...)return pcall(syscalls.syslog,KERNEL,nil,{level="debug",process=0},...)end;local dI=panic;function panic(ae)xpcall(function()syslog.log({level="panic"},"Kernel panic:",ae)if debug then local ai=debug.traceback(nil,2)syslog.log({level="panic",traceback=true},ai)end;syslog.log({level="panic"},"We are hanging here...")term.setCursorBlink(false)mainThread=nil;while true do coroutine.yield()end end,function(A)dI(ae.."; and an error occurred while logging the error: "..A)end)end;xpcall(function()local o;syslogs.default.file,o=filesystem.open(KERNEL,"/var/log/default.log","a")shutdownHooks[#shutdownHooks+1]=function()if syslogs.default.file then syslogs.default.file.close()end end;syslog.log("Starting Phoenix version",PHOENIX_VERSION,PHOENIX_BUILD)syslog.log("Initialized system logger")syslog.log("System started at "..systemStartTime.." on computer "..os.computerID()..(os.computerLabel()and"('"..os.computerLabel().."')"or""))syslog.log("Computer host is ".._HOST)if syslogs.default.file==nil then syslog.log({level="notice"},"An error occurred while opening the log file at /var/log/default.log:",o,". System logs will not be saved to disk.")end end,panic)local function dJ(bn)return string.match(bn,'^()%s*$')and''or string.match(bn,'^%s*(.*%S)')end;local expect,do_syscall=expect,do_syscall;local function dK(bh)local a7=1;local function dx(a9)if a7>#bh then return nil end;a9=a9 or 1;local bn=bh:sub(a7,a7+a9-1)a7=a7+a9;return bn end;if dx(8)~="!<arch>\n"then error("Not an ar archive",2)end;local a5={}local dL=nil;local dM={}while true do local bh={}local dN=dx()while dN=="\n"do dN=dx()end;if dN==nil then break end;local m=dx(15)if m==nil then break end;m=dN..m;if string.find(m,"/")and string.find(m,"/")>1 then m=string.sub(m,1,string.find(m,"/")-1)else m=dJ(m)end;bh.timestamp=tonumber(dJ(dx(12)))bh.owner=tonumber(dJ(dx(6)))bh.group=tonumber(dJ(dx(6)))bh.mode=tonumber(dJ(dx(8)),8)local S=tonumber(dJ(dx(10)))if dx(2)~="`\n"then error("Invalid header for file "..m,2)end;if string.match(m,"^#1/%d+$")then m=dx(tonumber(string.match(m,"#1/(%d+)")))elseif string.match(m,"^/%d+$")then if dL then local r=tonumber(string.match(m,"/(%d+)"))m=dL:match("[^/]*",r+1)else table.insert(dM,m)end end;bh.name=m;bh.data=dx(S)if m=="//"then dL=bh.data elseif m~="/"and m~="/SYM64/"then table.insert(a5,bh)end end;if dL then for h,i in pairs(dM)do local r=tonumber(string.match(i,"/(%d+)"))for N,af in pairs(a5)do if af.name==i then af.name=dL:match("[^/]*",r+1)break end end end end;local dO={}for z,i in ipairs(a5)do dO[i.name]=i end;return dO end;function createRequire(process,cz)local dP,dQ={},{}cz.package={}local dR=processes[process.parent]and processes[process.parent].env;if dR then cz.package.path=dR.package and dR.package.path;cz.package.libpath=dR.package and dR.package.libpath end;cz.package.path=cz.package.path or"/lib/?.lua;/lib/?/init.lua;/usr/lib/?.lua;/usr/lib/?/init.lua;./?.lua;./?/init.lua"if type(process.vars.PACKAGE_PATH)=="string"then cz.package.path=process.vars.PACKAGE_PATH..';'..cz.package.path end;cz.package.libpath=cz.package.libpath or"/lib/lib?.a;/usr/lib/lib?.a"if type(process.vars.PACKAGE_LIBPATH)=="string"then cz.package.libpath=process.vars.PACKAGE_LIBPATH..';'..cz.package.libpath end;cz.package.config="/\n;\n?\n!\n-"cz.package.loaded=dP;cz.package.preload=dQ;cz.package.forceload=false;for h,i in pairs(cz)do if type(i)=="table"then dP[h]=i end end;local dS=setmetatable({},{__newindex=function()end,__metatable=false})local dT={}local function dU(m,bb)local a,o=do_syscall("open",bb,"rb")if not a then error(bb..": "..o,3)end;local bh=a.readAll()a.close()local g,o=load(bh,"@"..bb,nil,_ENV)if not g then error(bb..": "..o,3)end;local dV=bb:match("^(.*)/[^/]*$")or"/"dT[#dT+1]=function(dW)local bb,o=package.searchpath(dW,dV.."/?.lua;"..dV.."/?/init.lua")if not bb then return nil,o end;return dU,bb end;local bf,u=pcall(g,m)dT[#dT]=nil;if bf then return u else error(bb..": "..u,3)end end;local function dX(m,bb)local dY;if bb:find"%z"then bb,dY=bb:match"^([^%z]*)%z(.*)$"elseif m:find"%-"then dY=m:match("^([^%-]*)%-(.*)$")else dY="init"end;local a,o=do_syscall("open",bb,"rb")if not a then error(bb..": "..o,3)end;local bh=a.readAll()a.close()local dV=dK(bh)local function dZ(m)local E=m..".lua"if not dV[E]then error(bb..":"..E..": File not found",0)end;local bh=dV[E].data;local g,o=load(bh,"@"..bb..":"..E,nil,_ENV)if not g then error(bb..":"..E..": "..o,3)end;local bf,u=pcall(g,m)if bf then return u else error(bb..":"..E..": "..u)end end;dT[#dT+1]=function(dW)return dZ,dW end;local u=dZ(dY)dT[#dT]=nil;return u end;dT[1]=function(m)local dV=do_syscall("getname"):match("^(.*)/[^/]*$")or"/"local bb,o=package.searchpath(m,dV.."/?.lua;"..dV.."/?/init.lua")if not bb then return nil,o end;return dU,bb end;function cz.package.searchpath(m,bb,am,d_)expect(1,m,"string")expect(2,bb,"string")expect(3,am,"string","nil")expect(4,d_,"string","nil")am=(am or"."):gsub("([%^%$%(%)%%%.%[%]%*%+%-%?])","%%%1")d_=(d_ or"/"):gsub("([%^%$%(%)%%%.%[%]%*%+%-%?])","%%%1")local e0=""for E in bb:gmatch"[^;]+"do local e1=E:gsub("%?",m:gsub(am,d_),nil)local a,o=do_syscall("open",e1,"r")if a then a.close()return e1 else e0=e0 .."\t"..e1 ..": "..o.."\n"end end;return nil,e0 end;cz.package.searchers={function(m)local E=dQ[m]if E then return E else return nil,"\tpackage.preload['"..m.."']: No such field\n"end end,function(m)local bb,o=package.searchpath(m,package.path)if not bb then return nil,o end;return dU,bb,bb end,function(m)local bb,o=package.searchpath(m:match("^[^%-]*"),package.libpath)if not bb then return nil,o end;local r=m:match("%-(.+)$")if r then return dX,bb,bb..":"..r else return dX,bb,bb..":init"end end,function(m)if not m:find"%."then return nil end;local bb,o=package.searchpath(m:match("^[^%.]*"),package.libpath)if not bb then return nil,o end;local r=m:match("^[^%.]*%.(.*)$")return dX,bb.."\0"..r,bb..":"..r end,function(m)if#dT>0 then return dT[#dT](m)end;return nil,"no local loaders found"end}setfenv(dU,cz)debug.protect(dU)setfenv(dX,cz)debug.protect(dX)setfenv(dT[1],cz)debug.protect(dT[1])for z,i in pairs(cz.package.searchers)do setfenv(i,cz)debug.protect(i)end;function cz.require(m)expect(1,m,"string")local o="module '"..m.."' not found:\n"local e2,e3,e4;for z,i in ipairs(package.searchers)do e2,e3,e4=i(m)if e2 then break end;o=o..(e3 or"")end;if not e2 then error(o,2)end;if e4 then if dP[e4]then if dP[e4]==dS then error("loop detected loading '"..m.."'",3)elseif not package.forceload then return dP[e4]end end;dP[e4]=dS else if dP[m]then if dP[m]==dS then error("loop detected loading '"..m.."'",3)elseif not package.forceload then return dP[m]end end end;dP[m]=dS;local bf,u=pcall(e2,m,e3)if bf then if u~=nil then dP[m]=u elseif dP[m]==dS then dP[m]=true end;if e4 then if u~=nil then dP[e4]=u elseif dP[e4]==dS then dP[e4]=true end end;return dP[m]else dP[m]=nil;if e4 then dP[e4]=nil end;error(o.."\t"..u.."\n",2)end end;return cz end;timerMap={}alarmMap={}local e5={}function syscalls.kill(process,aq,cM,e6)expect(1,cM,"number")expect(2,e6,"number")local e7=processes[cM]if not e7 then error("No such process",2)end;if process.user~="root"and process.user~=e7.user then error("Permission denied",2)end;if e6==9 then reap_process(e7)if processes[e7.parent]then syscalls.queueEvent(processes[e7.parent],nil,"process_complete",{id=cM,result=9})end;processes[cM]=nil elseif e7.signalHandlers[e6]then userModeCallback(e7,e7.signalHandlers[e6],e6)else syscalls.queueEvent(e7,nil,"signal",{signal=e6})end end;function killProcess(cM,e6)expect(1,cM,"number")expect(2,e6,"number")local e7=processes[cM]if not e7 then return end;if e6==9 then reap_process(e7)if processes[e7.parent]then syscalls.queueEvent(processes[e7.parent],nil,"process_complete",{id=cM,result=9})end;processes[cM]=nil elseif e7.signalHandlers[e6]then syscalls.newthread(e7,nil,e7.signalHandlers[e6],e6)else syscalls.queueEvent(e7,nil,"signal",{signal=e6})end end;function syscalls.signal(process,aq,e6,e8)expect(1,e6,"number")expect(2,e8,"function","nil")process.signalHandlers[e6]=e8 end;function syscalls.queueEvent(process,aq,m,av)expect(1,m,"string")expect(2,av,"table")process.eventQueue[#process.eventQueue+1]={m,av}end;function syscalls.sendEvent(process,aq,cM,m,av)expect(1,cM,"number")expect(2,m,"string")local e7=processes[cM]if not e7 then return false end;e7.eventQueue[#e7.eventQueue+1]={"remote_event",{type=m,sender=process.id,data=av}}return true end;function syscalls.register(process,aq,m)expect(1,m,"string")if e5[m]then return false end;e5[m]=process.id;process.dependents[#process.dependents+1]={gc=function()e5[m]=nil end}return true end;function syscalls.lookup(process,aq,m)expect(1,m,"string")return e5[m]end;function syscalls.timer(process,aq,e9)expect(1,e9,"number")local ea=os.startTimer(e9)timerMap[ea]=process;return bit32.band(ea,0x7FFFFFFF)end;function syscalls.alarm(process,aq,e9)expect(1,e9,"number")local ea=os.setAlarm(e9)alarmMap[ea]=process;return bit32.bor(ea,0x80000000)end;function syscalls.cancel(process,aq,ea)expect(1,ea,"number")if bit32.btest(ea,0x80000000)then ea=bit32.band(ea,0x7FFFFFFF)if alarmMap[ea]~=process then error("No such alarm")end;os.cancelAlarm(ea)alarmMap[ea]=nil else if timerMap[ea]~=process then error("No such timer")end;os.cancelTimer(ea)timerMap[ea]=nil end end;eventHooks.terminate=eventHooks.terminate or{}eventHooks.terminate[#eventHooks.terminate+1]=function()if currentTTY.frontmostProcess then syscalls.kill(KERNEL,nil,currentTTY.frontmostProcess.id,2)terminal.write(currentTTY,"^T")end end;eventParameterMap={alarm={"id"},char={"character"},key={"keycode","isRepeat"},key_up={"keycode"},mouse_click={"button","x","y"},mouse_drag={"button","x","y"},mouse_up={"button","x","y"},mouse_scroll={"direction","x","y"},paste={"text"},redstone={},term_resize={},timer={"id"},turtle_inventory={}}do local eb=0;for z,i in pairs(keys)do if type(i)=="number"then eb=math.max(eb,i)end end;local bp;local ec,ed=pcall(string.dump,function()end)if ec then local ee=(function(p)if p<8 then return p end;local K=0;while p>=128 do p,K=bit32.rshift(p+0xf,4),K+4 end;while p>=16 do p,K=bit32.rshift(p+1,1),K+1 end;return bit32.bor((K+1)*8,p-8)end)(eb)syslog.debug("Key table sizes:",eb,ee)if _VERSION=="Lua 5.1"then bp=ed:sub(1,12)..("I"..ed:byte(9).."IIBBBBIIIIIIII"):pack(0,0,0,0,0,0,1,2,ee*0x800000+10,0x0100001E,0,0,0,0,0)elseif _VERSION=="Lua 5.2"then bp=ed:sub(1,18)..("IIBBBIIIIIIIIII"):pack(0,0,0,0,1,2,ee*0x800000+11,0x0100001F,0,0,0,0,0,0,0)elseif _VERSION=="Lua 5.3"then bp=ed:sub(1,17+("jn"):packsize())..("BBIIBBBIIIIIIIII"):pack(0,0,0,0,0,0,1,2,ee*0x800000+11,0x01000026,0,0,0,0,0,0)elseif _VERSION=="Lua 5.4"then bp=ed:sub(1,15+("jn"):packsize())..("BBBBBBBBIIIBBBBBBB"):pack(0,0x80,0x80,0x80,0,0,1,0x83,0x00000013,eb*0x80+82,0x00008048,0x80,0x80,0x80,0x80,0x80,0x80,0x80)end;if bp then local g,o=load(bp,nil,"b")if g then keymap=g()else syslog.debug("Could not load key table code:",o)end end end;if not keymap then keymap=load("return {"..("nil,"):rep(eb).."}")()end;for v=0x61,0x7A do keymap[keys[string.char(v)]]=v end;for v=0x81,0x99 do if keys["f"..bit32.band(v,31)]then keymap[keys["f"..bit32.band(v,31)]]=v end end;for v=0xA0,0xA9 do keymap[keys["numPad"..bit32.band(v,15)]]=v end;keymap[keys.backspace]=0x08;keymap[keys.tab]=0x09;keymap[keys.enter or keys["return"]]=0x0A;keymap[keys.space]=0x20;keymap[keys.apostrophe]=0x27;keymap[keys.comma]=0x2C;keymap[keys.minus]=0x2D;keymap[keys.period]=0x2E;keymap[keys.slash]=0x2F;keymap[keys.zero]=0x30;keymap[keys.one]=0x31;keymap[keys.two]=0x32;keymap[keys.three]=0x33;keymap[keys.four]=0x34;keymap[keys.five]=0x35;keymap[keys.six]=0x36;keymap[keys.seven]=0x37;keymap[keys.eight]=0x38;keymap[keys.nine]=0x39;keymap[keys.semicolon or keys.semiColon]=0x3B;keymap[keys.equals]=0x3D;keymap[keys.leftBracket]=0x5B;keymap[keys.backslash]=0x5C;keymap[keys.rightBracket]=0x5D;keymap[keys.grave]=0x60;keymap[keys.delete]=0x7F;keymap[keys.insert]=0x80;if keys.convert then keymap[keys.convert]=0x9A end;if keys.noconvert then keymap[keys.noconvert]=0x9B end;if keys.kana then keymap[keys.kana]=0x9C end;if keys.kanji then keymap[keys.kanji]=0x9D end;if keys.yen then keymap[keys.yen]=0x9E end;keymap[keys.numPadDecimal]=0x9F;keymap[keys.numPadAdd]=0xAA;keymap[keys.numPadSubtract]=0xAB;if keys.numPadMultiply then keymap[keys.numPadMultiply]=0xAC end;keymap[keys.numPadDivide]=0xAD;keymap[keys.numPadEqual or keys.numPadEquals]=0xAE;keymap[keys.numPadEnter]=0xAF;keymap[keys.leftCtrl]=0xB0;keymap[keys.rightCtrl]=0xB1;keymap[keys.leftAlt]=0xB2;keymap[keys.rightAlt]=0xB3;keymap[keys.leftShift]=0xB4;keymap[keys.rightShift]=0xB5;if keys.leftSuper then keymap[keys.leftSuper]=0xB6 end;if keys.rightSuper then keymap[keys.rightSuper]=0xB7 end;keymap[keys.capsLock]=0xB8;keymap[keys.numLock]=0xB9;keymap[keys.scrollLock or keys.scollLock]=0xBA;if keys.printScreen then keymap[keys.printScreen]=0xBB end;keymap[keys.pause]=0xBC;if keys.menu then keymap[keys.menu]=0xBD end;if keys.stop then keymap[keys.stop]=0xBE end;if keys.ax then keymap[keys.ax]=0xBF end;keymap[keys.up]=0xC0;keymap[keys.down]=0xC1;keymap[keys.left]=0xC2;keymap[keys.right]=0xC3;keymap[keys.pageUp]=0xC4;keymap[keys.pageDown]=0xC5;keymap[keys.home]=0xC6;keymap[keys["end"]]=0xC7;if keys.circumflex or keys.cimcumflex then keymap[keys.circumflex or keys.cimcumflex]=0xC8 end;if keys.at then keymap[keys.at]=0xC9 end;if keys.colon then keymap[keys.colon]=0xCA end;if keys.underscore then keymap[keys.underscore]=0xCB end end;local ef={id=0,name="",coro=coroutine.create(function()end),status="starting",args={"a",n=1},filter=function(process,aq,eg)end}local eh={id=1,name="init",user="root",dependents={{gc=function()end}},parent=0,dir="/",stdin=TTY[1],stdout={},stderr=TTY[1],cputime=0.2,systime=0.1,env={},syscallyield=nil,eventQueue={},signalHandlers={},paused=false,nice=0,threads={[0]=ef}}local ei=1;local function ej(process)local e=createLuaLib(process)if _VERSION<"Lua 5.2"then e=make_ENV(e)end;e._G=e;return e end;local function ek()coroutine.yield("preempt","test",7)end;local el={load}function addProcessLoader(e2)table.insert(el,1,e2)end;function removeProcessLoader(e2)for v,i in ipairs(el)do if i==e2 then table.remove(el,v)return end end end;function reap_process(process)syslog.debug("Reaping process "..process.id.." ("..process.name..")")for z,i in ipairs(process.dependents)do i:gc()end;if process.stdin and process.stdin.isTTY then if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)process.stdin.preBuffer=""if discord and process.stdout==currentTTY and process.stdout.frontmostProcess then discord("Phoenix","Executing "..process.stdout.frontmostProcess.name)end else for v,i in ipairs(process.stdin.processList)do if i==process then table.remove(process.stdin.processList,v)break end end end end;if process.stdout and process.stdout.isTTY then if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)else for v,i in ipairs(process.stdout.processList)do if i==process then table.remove(process.stdout.processList,v)break end end end end;if process.stderr and process.stderr.isTTY then if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)else for v,i in ipairs(process.stderr.processList)do if i==process then table.remove(process.stderr.processList,v)break end end end end end;function syscalls.getpid(process,aq)return process.id end;function syscalls.getppid(process,aq)return process.parent end;function syscalls.clock(process,aq)return process.cputime end;function syscalls.getenv(process,aq)return process.vars end;function syscalls.getname(process,aq)return process.name end;function syscalls.getcwd(process,aq)return process.dir end;function syscalls.chdir(process,aq,dV)expect(1,dV,"string")local bD=filesystem.stat(process,dV)if not bD or bD.type~="directory"then return false,"No such file or directory"elseif not(bD.permissions[process.user]or bD.worldPermissions).execute then return false,"Permission denied"end;process.dir=dV:gsub("^([^/])","/"..process.dir.."/%1")return true end;function syscalls.getuser(process,aq)return process.user,process.realuser end;function syscalls.setuser(process,aq,user)expect(1,user,"string")if process.user~="root"then error("Permission denied")end;process.user=user;process.realuser=nil end;function syscalls.fork(process,aq,az,m,...)expect(1,az,"function")expect(2,m,"string","nil")local aA=ei;ei=ei+1;processes[aA]={id=aA,name=m or process.name,user=process.user,dependents={},parent=process.id,dir=process.dir,root=process.root,stdin=process.stdin,stdout=process.stdout,stderr=process.stderr,vars=deepcopy(process.vars),globalMetatables=deepcopy(globalMetatables),cputime=0,systime=0,syscallyield=nil,eventQueue={},signalHandlers={[1]=function()return coroutine.yield("syscall","exit",1)end,[2]=function()return coroutine.yield("syscall","exit",1)end,[3]=function()coroutine.yield("syscall","syslog",{level="error",category="Application Error",traceback=true},debug.traceback("Quit"))return coroutine.yield("syscall","exit",1)end,[6]=function(o)coroutine.yield("syscall","syslog",{level="error",category="Application Error",traceback=true},debug.traceback(o or"Aborted"))return coroutine.yield("syscall","exit",1)end,[13]=function()return coroutine.yield("syscall","exit",1)end,[15]=function()return coroutine.yield("syscall","exit",1)end,[19]=function()return coroutine.yield("syscall","suspend")end,[21]=function()return coroutine.yield("syscall","suspend")end,[22]=function()return coroutine.yield("syscall","suspend")end},paused=false,nice=0,threads={[0]={id=0,name="<main thread>",coro=coroutine.create(az),syscall=coroutine.create(function(...)local args=table.pack(...)while true do args=table.pack(coroutine.yield(kSyscallComplete,xpcall(syscalls[args[1]],debug.traceback,table.unpack(args,2,args.n))))end end),status="starting",args=table.pack(...),filter=nil}}}processes[aA].env=ej(processes[aA])setfenv(az,processes[aA].env)if process.stdin and process.stdin.isTTY and not process.stdin.isLocked then process.stdin.processList[#process.stdin.processList+1]=process.stdin.frontmostProcess;process.stdin.frontmostProcess=processes[aA]process.stdin.preBuffer=""if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.name)end end;if process.stdout and process.stdout.isTTY and not process.stdout.isLocked and process.stdout.frontmostProcess~=processes[aA]then process.stdout.processList[#process.stdout.processList+1]=process.stdout.frontmostProcess;process.stdout.frontmostProcess=processes[aA]end;if process.stderr and process.stderr.isTTY and not process.stderr.isLocked and process.stderr.frontmostProcess~=processes[aA]then process.stderr.processList[#process.stderr.processList+1]=process.stderr.frontmostProcess;process.stderr.frontmostProcess=processes[aA]end;if args.preemptive then debug.sethook(processes[aA].threads[0].coro,ek,"",args.quantum)end;return aA end;function syscalls.exec(process,aq,bb,...)expect(1,bb,"string")local a,o=filesystem.open(process,bb,"r")if not a then bb=bb..".lua"a,o=filesystem.open(process,bb,"r")if not a then error("Could not open file: "..o,0)end end;local em=a.readAll()a.close()if em:find("[%z\1-\31]")then a,o=filesystem.open(process,bb,"rb")if not a then error("Could not open file: "..o,0)end;em=a.readAll()a.close()end;local bD=filesystem.stat(process,bb)if not(bD.permissions[bD.owner]or bD.worldPermissions).execute then error("Could not execute file: Permission denied",0)end;if bD.setuser then process.realuser,process.user=process.user,bD.owner end;if em:sub(1,2)=="#!"then local en=em:sub(3,em:find("\n")-1)local args,v={},0;for bn in en:gmatch"%S+"do args[v]=bn;v=v+1 end;args[v],v=bb,v+1;for z,i in ipairs{...}do args[v]=i;v=v+1 end;if args[0]==bb then error("Recursive path detected while resolving shebang",0)end;syscalls.exec(process,aq,args[0],table.unpack(args,1,v))process.name="/"..fs.combine(bb:sub(1,1)=="/"and""or process.dir,bb)else local az,o;for z,e2 in ipairs(el)do az,o=e2(em,"@"..bb,"bt",process.env)if az then break end end;if not az then error("Could not execute file: "..o,0)end;process.name="/"..fs.combine(bb:sub(1,1)=="/"and""or process.dir,bb)process.threads={[0]={id=0,name="<main thread>",coro=coroutine.create(az),syscall=coroutine.create(function(...)local args=table.pack(...)while true do args=table.pack(coroutine.yield(kSyscallComplete,xpcall(syscalls[args[1]],debug.traceback,table.unpack(args,2,args.n))))end end),status="starting",args=table.pack(...),filter=nil}}if args.preemptive then debug.sethook(process.threads[0].coro,ek,"",args.quantum*10^(process.nice/-10))end end;if discord and process.stdin and process.stdin.isTTY and process.stdin.frontmostProcess==process then discord("Phoenix","Executing "..process.name)end end;function syscalls.newthread(process,aq,az,...)expect(1,az,"function")local aA=#process.threads+1;process.threads[aA]={id=aA,name="<thread:"..aA..">",coro=coroutine.create(az),syscall=coroutine.create(function(...)local args=table.pack(...)while true do args=table.pack(coroutine.yield(kSyscallComplete,xpcall(syscalls[args[1]],debug.traceback,table.unpack(args,2,args.n))))end end),status="starting",args=table.pack(...),filter=nil}setfenv(az,process.env)if args.preemptive then debug.sethook(process.threads[aA].coro,ek,"",args.quantum*10^(process.nice/-10))end;return aA end;function syscalls.exit(process,aq,bp)process.lastReturnValue={pid=process.id,thread=aq.id,value=bp,n=1,bp}for z,aq in pairs(process.threads)do aq.status="dead"aq.return_value=bp end end;function syscalls.getplist(process,aq)local eo={}for h in pairs(processes)do eo[#eo+1]=h end;table.sort(eo)return eo end;function syscalls.getpinfo(process,aq,cM)expect(1,cM,"number")local E=processes[cM]if not E then return nil,"No such process"end;local ep,eq,er;for v,i in ipairs(TTY)do if E.stdin==i then ep=v end;if E.stdout==i then eq=v end;if E.stderr==i then er=v end end;local es={}if E.threads then for v,i in pairs(E.threads)do es[v]={id=i.id,name=i.name,status=i.status}end end;return{id=E.id,name=E.name,user=E.user,realuser=E.realuser,parent=E.parent,dir=E.dir,stdin=ep,stdout=eq,stderr=er,cputime=E.cputime or 0,systime=E.systime or 0,threads=es}end;function syscalls.suspend(process,aq)process.paused=true end;function syscalls.nice(process,aq,b0,cM)expect(1,b0,"number")expect.range(b0,-20,20)expect(2,cM,"number","nil")if b0<0 and process.user~="root"then error("Permission denied",0)end;local e7=cM and assert(processes[cM],"Invalid process ID")or process;if e7.user~=process.user and process.user~="root"then error("Permission denied",0)end;e7.nice=b0;if args.preemptive then for z,y in pairs(e7.threads)do debug.sethook(y.coro,ek,"",args.quantum*10^(b0/-10))end end end;local function et(a0)a0=a0 .."\x80"..("\0"):rep(-(#a0+9)%64)..(">I8"):pack(#a0)local eu,ev,ew,ex,ey,af=0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476,0xC3D2E1F0,{}for ez=1,#a0,64 do local eA=ez;for v=0,15 do af[v]=a0:byte(eA)*0x1000000+a0:byte(eA+1)*0x10000+a0:byte(eA+2)*0x100+a0:byte(eA+3)eA=eA+4 end;for v=16,79 do af[v]=bit32.lrotate(bit32.bxor(af[v-3],af[v-8],af[v-14],af[v-16]),1)end;local ck,ab,a9,bl,K=eu,ev,ew,ex,ey;for v=0,79 do local f,h;if v<=19 then f,h=bit32.bxor(bl,bit32.band(ab,bit32.bxor(a9,bl))),0x5A827999 elseif v<=39 then f,h=bit32.bxor(ab,a9,bl),0x6ED9EBA1 elseif v<=59 then f,h=bit32.bor(bit32.band(ab,bit32.bor(a9,bl)),bit32.band(a9,bl)),0x8F1BBCDC else f,h=bit32.bxor(ab,a9,bl),0xCA62C1D6 end;local eB=bit32.band(bit32.lrotate(ck,5)+f+K+h+af[v],0xFFFFFFFF)K,bl,a9,ab,ck=bl,a9,bit32.lrotate(ab,30),ck,eB end;eu=bit32.band(eu+ck,0xFFFFFFFF)ev=bit32.band(ev+ab,0xFFFFFFFF)ew=bit32.band(ew+a9,0xFFFFFFFF)ex=bit32.band(ex+bl,0xFFFFFFFF)ey=bit32.band(ey+K,0xFFFFFFFF)end;return{eu,ev,ew,ex,ey}end;local function eC(eD,m)local eE=et(eD:gsub("%X",""):gsub("%x%x",function(bn)return string.char(tonumber(bn,16))end)..m)local ck,ab,a9,bl=eE[1],bit32.bor(bit32.band(eE[2],0xFFFF0FFF),0x5000),bit32.bor(bit32.band(eE[3],0x3FFFFFFF),0x80000000),eE[4]return("%08x-%04x-%04x-%04x-%04x%08x"):format(ck,bit32.rshift(ab,16),bit32.band(ab,0xFFFF),bit32.rshift(a9,16),bit32.band(a9,0xFFFF),bl)end;local eF="a6f53b7d-50f3-4e51-adef-8728c83e3f3a"deviceTreeRoot={id=tostring(os.getComputerID()),uuid=eC(eF,tostring(os.getComputerID())),parent=nil,displayName=os.getComputerLabel()or"",drivers={},metadata={},internalState={},children={},listeners=setmetatable({},{__mode="k"})}local eG={[deviceTreeRoot.uuid]=deviceTreeRoot}local eH={}function hardware.get(bb)expect(1,bb,"string")if bb:find("^%x+%-%x+%-%x+%-%x+%-%x+$")then return eG[bb]elseif bb==""or bb:find("/")then local dw=deviceTreeRoot;for m in bb:gmatch"[^/]+"do dw=dw.children[m]if dw==nil then break end end;return dw else local eI={}local function eJ(dw)if dw.id==bb or dw.alias==bb then eI[#eI+1]=dw end;for z,i in pairs(dw.children)do eJ(i)end end;eJ(deviceTreeRoot)return table.unpack(eI)end end;function hardware.find(type)expect(1,type,"string")local eK={}local function eL(dw)for z,i in ipairs(dw.drivers)do if i.type==type then eK[#eK+1]=dw;break end end;for z,i in pairs(dw.children)do eL(i)end end;eL(deviceTreeRoot)return table.unpack(eK)end;function hardware.path(dw)expect(1,dw,"table")expect.field(dw,"uuid","string")if not eG[dw.uuid]then error("bad argument #1 (invalid node)",2)end;local bb=dw.id;dw=dw.parent;while dw do bb=dw.id.."/"..bb;dw=dw.parent end;bb=bb:gsub("^[^/]+","")return bb==""and"/"or bb end;function hardware.add(bW,m)expect(1,bW,"table")expect(2,m,"string")expect.field(bW,"uuid","string")if not eG[bW.uuid]then return nil,"Invalid parent node"end;if bW.children[m]then return nil,"Node already exists"end;local dw={id=m,uuid=eC(bW.uuid,m),parent=bW,displayName="",drivers={},metadata={},internalState={},children={},listeners=setmetatable({},{__mode="k"})}bW.children[m]=dw;eG[dw.uuid]=dw;syslog.log({module="Hardware"},"Added new device at "..hardware.path(dw))for z,i in ipairs(eH)do if(not i.parent or i.parent==bW)and(not i.pattern or m:match(i.pattern))then i.callback(dw)end end;return dw end;function hardware.remove(dw)expect(1,dw,"table")expect.field(dw,"uuid","string")if not eG[dw.uuid]then return false,"Invalid node"end;if dw==deviceTreeRoot or not dw.parent then return false,"Cannot remove root node"end;for v=#dw.drivers,1,-1 do hardware.deregister(dw,dw.drivers[v])end;for z,i in pairs(dw.children)do hardware.remove(i)end;syslog.log({module="Hardware"},"Device at "..hardware.path(dw).." has been removed")dw.parent.children[dw.id]=nil;eG[dw.uuid]=nil;dw.parent=nil;return true end;function hardware.register(dw,eM)expect(1,dw,"table")expect(2,eM,"table")expect.field(dw,"uuid","string")expect.field(eM,"name","string")expect.field(eM,"type","string")expect.field(eM,"properties","table")expect.field(eM,"methods","table")expect.field(eM,"init","function","nil")expect.field(eM,"deinit","function","nil")for h in pairs(eM.methods)do if type(h)~="string"then error("bad method name '"..tostring(h).."' (not a string)",2)end;expect.field(eM.methods,h,"function")end;for z,i in ipairs(eM.properties)do if type(i)~="string"then error("bad property name '"..tostring(i).."' (not a string)",2)end;if not eM.methods["get"..i:sub(1,1):upper()..i:sub(2)]then error("bad property '"..i.."' (no getter present)",2)end end;if not eG[dw.uuid]then error("bad argument #1 (invalid node)",2)end;for z,i in ipairs(dw.drivers)do if i==eM then return false end end;dw.drivers[#dw.drivers+1]=eM;syslog.log({module="Hardware"},"Registered device with type "..eM.type.." on device "..hardware.path(dw).." using driver "..eM.name)if eM.init then eM.init(dw)end;return true end;function hardware.register_callback(eM)return function(dw)return hardware.register(dw,eM)end end;function hardware.deregister(dw,eM)expect(1,dw,"table")expect(2,eM,"table")expect.field(dw,"uuid","string")if not eG[dw.uuid]then error("bad argument #1 (invalid node)",2)end;for v,i in ipairs(dw.drivers)do if i==eM then if eM.deinit then eM.deinit(dw)end;table.remove(dw.drivers,v)syslog.log({module="Hardware"},"Driver "..eM.name.." has been deregistered from device "..hardware.path(dw))return true end end;return false end;function hardware.listen(eN,bW,eO)expect(1,eN,"function")expect(2,bW,"table","nil")expect(3,eO,"string","nil")if bW then expect.field(bW,"uuid","string")end;if eO and not pcall(string.match,"",eO)then error("bad argument #3 (invalid pattern)",2)end;eH[#eH+1]={callback=eN,parent=bW,pattern=eO}end;function hardware.unlisten(eN)expect(1,eN,"function")local v=1;while v<#eH do if eH[v].callback==eN then table.remove(eH,v)else v=v+1 end end end;function hardware.broadcast(dw,eg,cP)expect(1,dw,"table")expect(2,eg,"string")expect(3,cP,"table")expect.field(dw,"uuid","string")if not eG[dw.uuid]then error("bad argument #1 (invalid node)",2)end;for i in pairs(dw.listeners)do i.eventQueue[#i.eventQueue+1]={eg,cP}end end;function hardware.call(process,dw,eP,...)for z,eM in ipairs(dw.drivers)do if eM.methods[eP]then return eM.methods[eP](dw,process,...)end end;error("No such method",2)end;function syscalls.devlookup(process,aq,m)expect(1,m,"string")local eQ={hardware.get(m)}for h,i in ipairs(eQ)do eQ[h]=hardware.path(i)end;return table.unpack(eQ)end;function syscalls.devfind(process,aq,type)expect(1,type,"string")local eQ={hardware.find(type)}for h,i in ipairs(eQ)do eQ[h]=hardware.path(i)end;return table.unpack(eQ)end;function syscalls.devinfo(process,aq,eR)expect(1,eR,"string")local dw=hardware.get(eR)if not dw then return nil end;local eS={}for z,i in ipairs(dw.drivers)do eS[i.type]=i.name end;return{id=dw.id,uuid=dw.uuid,alias=dw.alias,parent=dw.parent and hardware.path(dw.parent)or"/",displayName=dw.displayName,types=eS,metadata=deepcopy(dw.metadata)}end;function syscalls.devalias(process,aq,eR,eT)expect(1,eR,"string")expect(2,eT,"string","nil")local dw=hardware.get(eR)if not dw then error("No such device",2)end;dw.alias=eT end;function syscalls.devmethods(process,aq,eR)expect(1,eR,"string")local dw=hardware.get(eR)if not dw then error("No such device",2)end;local eU={}for z,i in ipairs(dw.drivers)do for h in pairs(i.methods)do eU[#eU+1]=h end end;return eU end;function syscalls.devproperties(process,aq,eR)expect(1,eR,"string")local dw=hardware.get(eR)if not dw then error("No such device",2)end;local eV={}for z,i in ipairs(dw.drivers)do for z,h in pairs(i.properties)do eV[#eV+1]=h end end;return eV end;function syscalls.devchildren(process,aq,eR)expect(1,eR,"string")local dw=hardware.get(eR)if not dw then error("No such device",2)end;local eW={}for h in pairs(dw.children)do eW[#eW+1]=h end;return eW end;function syscalls.devcall(process,aq,eR,eP,...)expect(1,eR,"string")expect(2,eP,"string")local dw=hardware.get(eR)if not dw then error("No such device",2)end;if dw.process and dw.process~=process.id then error("Device is locked",2)end;return hardware.call(process,dw,eP,...)end;function syscalls.devlisten(process,aq,eR,db)expect(1,eR,"string")expect(2,db,"boolean","nil")if db==nil then db=true end;local dw=hardware.get(eR)if not dw then error("No such device",2)end;if db then for z,i in ipairs(dw.listeners)do if i==process then return end end;dw.listeners[process]=true;process.dependents[#process.dependents+1]={type="hardware listen",node=dw,gc=function()dw.listeners[process]=nil end}else dw.listeners[process]=nil;for v,i in ipairs(process.dependents)do if i.type=="hardware listen"and i.node==dw then table.remove(process.dependents,v)break end end end end;function syscalls.devlock(process,aq,eR,eX)expect(1,eR,"string")expect(2,eX,"boolean","nil")if eX==nil then eX=true end;local dw=hardware.get(eR)if not dw then error("No such device",2)end;if dw.process==nil then dw.process=process.id;process.dependents[#process.dependents+1]={type="hardware lock",node=dw,gc=function()dw.process=nil end}return true elseif dw.process==process.id then return true elseif eX then aq.filter=function(process,aq)return dw.process==nil or dw.process==process.id end;return kSyscallYield,"devlock",eR,true else return false end end;function syscalls.devunlock(process,aq,eR)expect(1,eR,"string")local dw=hardware.get(eR)if not dw then error("No such device",2)end;if dw.process and dw.process~=process.id then error("Device is locked",2)end;dw.process=nil;for v,i in ipairs(process.dependents)do if i.type=="hardware lock"and i.node==dw then table.remove(process.dependents,v)break end end end;function syscalls.version(process,aq,eY)if eY then return PHOENIX_BUILD else return PHOENIX_VERSION end end;function syscalls.cchost(process,aq)return _HOST end;function syscalls.uptime(process,aq)return(os.epoch"utc"-systemStartTime)/1000 end;function syscalls.attach(process,aq,eZ,_type,...)if process.user~="root"then error("Permission denied")end;expect(1,eZ,"string","number")expect(2,_type,"string")local bf,o;if periphemu then bf=periphemu.create(eZ,_type,...)elseif ccemux then if type(eZ)=="number"then eZ=_type.."_"..eZ end;if _type=="drive"then _type="disk_drive"elseif _type=="modem"then _type="wireless_modem"end;if _type=="computer"then local aA=tonumber(eZ:match("%d+"))if aA then bf,o=pcall(ccemux.openEmu,aA)else bf,o=false,"Invalid side"end else bf,o=pcall(ccemux.attach,eZ,_type,...)end else bf,o=false,"Operation not supported"end;return bf,o end;function syscalls.detach(process,aq,eZ)if process.user~="root"then error("Permission denied")end;expect(1,eZ,"string","number")local bf,o;if periphemu then bf=periphemu.remove(eZ)elseif ccemux then if type(eZ)=="number"then eZ=_type.."_"..eZ end;bf,o=pcall(ccemux.detach,eZ)else bf,o=false,"Operation not supported"end;return bf,o end;function syscalls.kernargs(process,aq)return deepcopy(args)end;local e_=0;function syscalls.lockmutex(process,aq,f0)expect(1,f0,"table")while f0.owner~=nil and f0.owner~=aq.id do coroutine.yield()end;if f0.owner then if type(f0.recursive)=="number"then f0.recursive=f0.recursive+1;return else error("cannot recursively lock mutex",0)end end;f0.owner=aq.id;if f0.recursive then f0.recursive=1 end end;function syscalls.__timeout_check(process,aq,b3)if b3.timeout then return false end;return syscalls[b3.call](process,aq,b3.object,0)end;function syscalls.timelockmutex(process,aq,f0,e9)expect(1,f0,"table")expect(2,e9,"number")if f0.owner then if f0.owner~=aq.id then local f1=os.startTimer(e9)local b3={object=f0,timeout=false,call="timelockmutex"}aq.filter=function(process,aq,ar)if ar[1]=="timer"and ar[2].id==f1 then b3.timeout=true;return true end;return f0.owner==nil or f0.owner==aq.id end;return kSyscallYield,"__timeout_check",b3 elseif type(f0.recursive)=="number"then f0.recursive=f0.recursive+1 else error("cannot recursively lock mutex",0)end else f0.owner=aq.id;if f0.recursive then f0.recursive=1 end end;return true end;function syscalls.unlockmutex(process,aq,f0)expect(1,f0,"table")if f0.owner==aq.id then if type(f0.recursive)=="number"then f0.recursive=f0.recursive-1;if f0.recursive<=0 then f0.owner=nil end else f0.owner=nil end elseif f0.owner==nil then error("mutex already unlocked",0)else error("mutex not locked by current thread")end end;function syscalls.trylockmutex(process,aq,f0)expect(1,f0,"table")if f0.owner then if f0.owner~=process.id then return false elseif type(f0.recursive)=="number"then f0.recursive=f0.recursive+1;return true else error("cannot recursively lock mutex",0)end else f0.owner=process.id;if f0.recursive then f0.recursive=1 end;return true end end;function syscalls.acquiresemaphore(process,aq,f2)expect(1,f2,"table")expect.field(f2,"count","number")while f2.count<=0 do coroutine.yield()end;f2.count=f2.count-1 end;function syscalls.timeacquiresemaphore(process,aq,f2,e9)expect(1,f2,"table")expect.field(f2,"count","number")expect(2,e9,"number")if f2.count<=0 then local f1=os.startTimer(e9)local b3={object=f2,timeout=false,call="timeacquiresemaphore"}aq.filter=function(process,aq,ar)if ar[1]=="timer"and ar[2].id==f1 then b3.timeout=true;return true end;return type(f2.count)~="number"or f2.count>0 end;return kSyscallYield,"__timeout_check",b3 end;f2.count=f2.count-1;return true end;function syscalls.releasesemaphore(process,aq,f2)expect(1,f2,"table")expect.field(f2,"count","number")f2.count=f2.count+1 end;local f3={name="root",type="computer",properties={"label","id"},methods={getLabel=function()end,setLabel=function(f4)end,getId=function()end,shutdown=function()end,reboot=function()end},init=function(dw)end,deinit=function(dw)end}local f5={top=true,bottom=true,left=true,right=true,front=true,back=true}local f6={}function getNodeById(m)if f5[m]then if deviceTreeRoot.children[m]then return deviceTreeRoot.children[m]end else for h in pairs(f5)do if peripheral.getType(h)=="modem"and not peripheral.call(h,"isWireless")and deviceTreeRoot.children[h]and deviceTreeRoot.children[h].children[m]then return deviceTreeRoot.children[h].children[m]end end end end;local function f7(self)self.internalState.peripheral=self.internalState.peripheral or{}if not self.internalState.peripheral.call then self.internalState.peripheral.call=peripheral.call end;if self.internalState.peripheral.call==peripheral.call or not self.parent then self.internalState.peripheral.getMethods=peripheral.getMethods else self.internalState.peripheral.getMethods=function(aA)return peripheral.call(self.parent.id,"getMethodsRemote",aA)end end end;local function f8(process,aB)aB.__metatable={}for z,i in pairs(aB)do setfenv(i,process.env)debug.protect(i)end;return setmetatable({},aB)end;local function f9(eM,type)return function(dw)local eS,g;if dw.parent==deviceTreeRoot then eS,g={peripheral.getType(dw.id)},peripheral.call else eS,g={peripheral.call(dw.parent.id,"getTypeRemote",dw.id)},function(...)return peripheral.call(dw.parent.id,"callRemote",...)end end;for z,i in ipairs(eS)do if i==type then dw.internalState.peripheral={call=g}return hardware.register(dw,eM)end end end end;local function fa(type)return hardware.listen(f9(f6["peripheral_"..type],type),deviceTreeRoot)end;local function fb(eP)return function(self)return self.internalState.peripheral.call(self.id,eP)end end;local function fc(eP)return function(self,process)if process.user~="root"then error("Permission denied",0)end;return self.internalState.peripheral.call(self.id,eP)end end;local function fd(eP)return function(...)local eS={...}return function(self,process,aF)expect(1,aF,table.unpack(eS))return self.internalState.peripheral.call(self.id,eP,aF)end end end;local function fe(eP)return function(...)local eS={...}return function(self,process,aF)expect(1,aF,table.unpack(eS))if process.user~="root"then error("Permission denied",0)end;return self.internalState.peripheral.call(self.id,eP,aF)end end end;local function ff()syslog.log("Sending SIGTERM to all processes")local fg=false;for cM,process in pairs(processes)do if cM~=0 then killProcess(cM,15)local fh,ar=false,nil;local as=true;for fi,aq in pairs(process.threads)do if not fh and aq.status=="suspended"then ar=table.remove(process.eventQueue,1)fh=true end;if ar or aq.status~="suspended"then as=executeThread(process,aq,ar or{n=0},as,true)else as=false end end;if as then process.isDead=true;if process.parent~=0 and processes[process.parent]then processes[process.parent].eventQueue[#processes[process.parent].eventQueue+1]={"process_complete",process.lastReturnValue}end;reap_process(process)processes[cM]=nil else fg=true end end end;terminal.redraw(currentTTY)if fg then syslog.log("Sending SIGKILL to all processes")for cM in pairs(processes)do if cM~=0 then killProcess(cM,9)end end end end;f6.root={name="root",type="computer",properties={"isOn","label"},methods={}}function f6.root.methods:getIsOn(process)return true end;function f6.root.methods:getLabel(process)return os.getComputerLabel()end;function f6.root.methods:setLabel(process,f4)expect(1,f4,"string","nil")os.setComputerLabel(f4)end;function f6.root.methods:turnOn(process)end;function f6.root.methods:shutdown(process)if process.user~="root"then error("Permission denied",2)end;syslog.log("System is shutting down.")function postkill()hardware.deregister(deviceTreeRoot,f6.root)syslog.log("Halting system")for z,i in ipairs(shutdownHooks)do i()end;os.shutdown()mainThread=nil;while true do coroutine.yield()end end;ff()end;function f6.root.methods:reboot(process)if process.user~="root"then error("Permission denied",2)end;syslog.log("System is restarting.")function postkill()hardware.deregister(deviceTreeRoot,f6.root)syslog.log("Rebooting system")for z,i in ipairs(shutdownHooks)do i()end;os.reboot()mainThread=nil;while true do coroutine.yield()end end;ff()end;function f6.root:init()local fj=hardware.add(self,"redstone")for z,i in ipairs{"top","bottom","left","right","front","back"}do local bl=hardware.add(fj,i)bl.internalState.redstone={side=i}hardware.register(bl,f6.root_redstone)end;hardware.register(hardware.add(deviceTreeRoot,"lo"),f6.loopback_modem)registerLoopback()for i in pairs(f5)do if peripheral.isPresent(i)then hardware.add(self,i)end end;self.displayName=os.getComputerLabel()self.metadata.id=os.getComputerID()end;function f6.root:deinit()for i in pairs(f5)do if peripheral.isPresent(i)and self.children[i]then hardware.remove(self.children[i])end end;hardware.remove(hardware.get("/lo"))hardware.remove(hardware.get("/redstone"))end;eventHooks.peripheral=eventHooks.peripheral or{}eventHooks.peripheral[#eventHooks.peripheral+1]=function(ar)if f5[ar[2]]then local dw,o=hardware.add(deviceTreeRoot,ar[2])if dw then hardware.broadcast(deviceTreeRoot,"device_added",{device=hardware.path(dw)})else syslog.log({level="error",module="Hardware"},"Could not create new device: "..o)end else for h in pairs(f5)do if peripheral.getType(h)=="modem"and not peripheral.call(h,"isWireless")and peripheral.call(h,"isPresentRemote",ar[2])then if not deviceTreeRoot.children[h]then hardware.add(deviceTreeRoot,h)end;local dw,o=hardware.add(deviceTreeRoot.children[h],ar[2])if dw then hardware.broadcast(deviceTreeRoot.children[h],"device_added",{device=hardware.path(dw)})else syslog.log({level="error",module="Hardware"},"Could not create new device: "..o)end;break end end end end;eventHooks.peripheral_detach=eventHooks.peripheral_detach or{}eventHooks.peripheral_detach[#eventHooks.peripheral_detach+1]=function(ar)local dw=getNodeById(ar[2])if not dw then syslog.log({level="notice",module="Hardware"},"Received "..ar[1].." event for device ID "..ar[2]..", but no device node was found; ignoring")return end;local bb,bW=hardware.path(dw),dw.parent;hardware.remove(dw)hardware.broadcast(bW,"device_removed",{device=bb})end;rootDriver=f6.root;f6.root_redstone={name="root_redstone",type="redstone",properties={"input","output","bundledInput","bundledOutput"},methods={}}local function fk(r)if r==0 then return nil else return r end end;function f6.root_redstone.methods:getInput()return fk(redstone.getAnalogInput(self.internalState.redstone.side))end;function f6.root_redstone.methods:getOutput()return fk(redstone.getAnalogOutput(self.internalState.redstone.side))end;function f6.root_redstone.methods:setOutput(process,r)r=expect(1,r,"number","boolean","nil")or 0;if r==false then r=0 elseif r==true then r=15 end;expect.range(r,0,15)redstone.setAnalogOutput(self.internalState.redstone.side,r)end;function f6.root_redstone.methods:getBundledInput()return redstone.getBundledInput(self.internalState.redstone.side)end;function f6.root_redstone.methods:getBundledOutput()return redstone.getBundledOutput(self.internalState.redstone.side)end;function f6.root_redstone.methods:setBundledOutput(process,r)expect(1,r,"number")expect.range(r,0,65535)redstone.setBundledOutput(self.internalState.redstone.side,r)end;function f6.root_redstone:init()if not self.internalState.redstone or not self.internalState.redstone.side then error("No assigned side on redstone device!",2)end;self.displayName="Redstone I/O on side "..self.internalState.redstone.side end;f6.peripheral_command={name="peripheral_command",type="command",properties={"command"},methods={}}f6.peripheral_command.methods.getCommand=fc"getCommand"f6.peripheral_command.methods.setCommand=fe"setCommand"("string")f6.peripheral_command.methods.run=fc"runCommand"function f6.peripheral_command:init()f7(self)self.displayName="Command block at "..self.id end;fa"command"f6.peripheral_computer={name="peripheral_computer",type="computer",properties={"isOn","label"},methods={}}f6.peripheral_computer.methods.getIsOn=fb"isOn"f6.peripheral_computer.methods.getLabel=fb"getLabel"f6.peripheral_computer.methods.turnOn=fc"turnOn"f6.peripheral_computer.methods.shutdown=fc"shutdown"f6.peripheral_computer.methods.reboot=fc"reboot"function f6.peripheral_command:init()f7(self)local f4=self.internalState.peripheral.call(self.id,"getLabel")self.metadata.id=self.internalState.peripheral.call(self.id,"getID")self.displayName=(f4 or"Computer "..self.metadata.id).." at "..self.id end;fa"computer"hardware.listen(f9(f6["peripheral_computer"],"turtle"),deviceTreeRoot)f6.peripheral_drive={name="peripheral_drive",type="drive",properties={"state","label"},methods={}}function f6.peripheral_drive.methods:getState(process)if not self.internalState.peripheral.call(self.id,"isDiskPresent")then return nil end;return{audio=self.internalState.peripheral.call(self.id,"getAudioTitle")or nil,label=self.internalState.peripheral.call(self.id,"getDiskLabel"),id=self.internalState.peripheral.call(self.id,"getDiskID")}end;f6.peripheral_drive.methods.getLabel=fb"getDiskLabel"f6.peripheral_drive.methods.setLabel=fd"setDiskLabel"("string","nil")f6.peripheral_drive.methods.getMountPath=fb"getMountPath"function f6.peripheral_drive.methods:play(process)if not self.internalState.peripheral.call(self.id,"hasAudio")then error("Inserted disk is not an audio disc",2)end;return self.internalState.peripheral.call(self.id,"playAudio")end;f6.peripheral_drive.methods.stop=fb"stopAudio"f6.peripheral_drive.methods.eject=fb"ejectDisk"f6.peripheral_drive.methods.insert=fe"insertDisk"("string")function f6.peripheral_drive:init()f7(self)self.displayName=(self.internalState.peripheral.call(self.id,"getDiskLabel")or"No disk").." on drive "..self.id end;fa"drive"eventHooks.disk=eventHooks.disk or{}eventHooks.disk[#eventHooks.disk+1]=function(ar)local dw=getNodeById(ar[2])if not dw then syslog.log({level="notice",module="Hardware"},"Received "..ar[1].." event for device ID "..ar[2]..", but no device node was found; ignoring")return end;hardware.broadcast(dw,"disk",{device=hardware.path(dw)})end;eventHooks.disk_eject=eventHooks.disk_eject or{}eventHooks.disk_eject[#eventHooks.disk_eject+1]=function(ar)local dw=getNodeById(ar[2])if not dw then syslog.log({level="notice",module="Hardware"},"Received "..ar[1].." event for device ID "..ar[2]..", but no device node was found; ignoring")return end;hardware.broadcast(dw,"disk_eject",{device=hardware.path(dw)})end;f6.peripheral_energy_storage={name="peripheral_energy_storage",type="energy_storage",properties={"energy"},methods={}}f6.peripheral_energy_storage.methods.getEnergy=fb"getEnergy"function f6.peripheral_energy_storage:init()f7(self)self.displayName="Energy storage block at "..self.id;self.metadata.capacity=self.internalState.peripheral.call(self.id,"getEnergyCapacity")end;fa"energy_storage"f6.peripheral_fluid_storage={name="peripheral_fluid_storage",type="fluid_storage",properties={"tanks"},methods={}}f6.peripheral_fluid_storage.methods.getTanks=fb"tanks"function f6.peripheral_fluid_storage.methods:push(process,bN,fl,m)expect(1,bN,"string")expect(2,fl,"number","nil")expect(3,m,"string","nil")local e7;local fm={hardware.get(bN)}if#fm==1 then e7=fm[1]else for z,i in ipairs(fm)do if i.parent==self.parent then e7=i;break end end end;if not e7 then error("No such device",0)elseif e7.parent~=self.parent then error("Devices must be on the same network",0)end;local bf=false;for z,i in ipairs(e7.drivers)do if i==f6.peripheral_fluid_storage then bf=true;break end end;if not bf then error("Target device is not a fluid storage block",0)end;return self.internalState.peripheral.call(self.id,"pushFluid",e7.id,fl,m)end;function f6.peripheral_fluid_storage.methods:pull(process,bM,fl,m)expect(1,bM,"string")expect(2,fl,"number","nil")expect(3,m,"string","nil")local e7;local fm={hardware.get(bM)}if#fm==1 then e7=fm[1]else for z,i in ipairs(fm)do if i.parent==self.parent then e7=i;break end end end;if not e7 then error("No such device",0)elseif e7.parent~=self.parent then error("Devices must be on the same network",0)end;local bf=false;for z,i in ipairs(e7.drivers)do if i==f6.peripheral_fluid_storage then bf=true;break end end;if not bf then error("Target device is not a fluid storage block",0)end;return self.internalState.peripheral.call(self.id,"pullFluid",e7.id,fl,m)end;function f6.peripheral_fluid_storage:init()f7(self)self.displayName="Fluid storage block at "..self.id end;fa"fluid_storage"f6.peripheral_inventory={name="peripheral_inventory",type="inventory",properties={"items"},methods={}}f6.peripheral_inventory.methods.getItems=fb"list"f6.peripheral_inventory.methods.detail=fd"getItemDetail"("number")f6.peripheral_inventory.methods.limit=fd"getItemLimit"("number")function f6.peripheral_inventory.methods:push(process,bN,fn,fl,fo)expect(1,bN,"string")expect(2,fn,"number")expect(3,fl,"number","nil")expect(4,fo,"number","nil")local e7;local fm={hardware.get(bN)}if#fm==1 then e7=fm[1]else for z,i in ipairs(fm)do if i.parent==self.parent then e7=i;break end end end;if not e7 then error("No such device",0)elseif e7.parent~=self.parent then error("Devices must be on the same network",0)end;local bf=false;for z,i in ipairs(e7.drivers)do if i==f6.peripheral_inventory then bf=true;break end end;if not bf then error("Target device is not an inventory block",0)end;return self.internalState.peripheral.call(self.id,"pushItems",e7.id,fn,fl,fo)end;function f6.peripheral_inventory.methods:pull(process,bM,fn,fl,fo)expect(1,bM,"string")expect(2,fn,"number")expect(3,fl,"number","nil")expect(4,fo,"number","nil")local e7;local fm={hardware.get(bM)}if#fm==1 then e7=fm[1]else for z,i in ipairs(fm)do if i.parent==self.parent then e7=i;break end end end;if not e7 then error("No such device",0)elseif e7.parent~=self.parent then error("Devices must be on the same network",0)end;local bf=false;for z,i in ipairs(e7.drivers)do if i==f6.peripheral_inventory then bf=true;break end end;if not bf then error("Target device is not an inventory block",0)end;return self.internalState.peripheral.call(self.id,"pullItems",e7.id,fn,fl,fo)end;function f6.peripheral_inventory:init()f7(self)self.displayName="Inventory at "..self.id;self.metadata.size=self.internalState.peripheral.call(self.id,"size")end;fa"inventory"f6.peripheral_monitor={name="peripheral_monitor",type="monitor",properties={"scale","size"},methods={}}f6.peripheral_monitor.methods.getScale=fb"getTextScale"f6.peripheral_monitor.methods.setScale=fd"setTextScale"("number")function f6.peripheral_monitor.methods:getSize()local af,ag=self.internalState.peripheral.call(self.id,"getSize")return{width=af,height=ag}end;function f6.peripheral_monitor.methods:write(process,...)for v,i in ipairs{...}do if v>1 then terminal.write(self.internalState.tty,"\t")end;terminal.write(self.internalState.tty,i)end;terminal.redraw(self.internalState.tty)end;function f6.peripheral_monitor.methods:termctl(process,de)expect(1,de,"table","nil")if de then expect.field(de,"cbreak","boolean","nil")expect.field(de,"delay","boolean","nil")expect.field(de,"echo","boolean","nil")expect.field(de,"keypad","boolean","nil")expect.field(de,"nlcr","boolean","nil")expect.field(de,"raw","boolean","nil")for h,i in pairs(de)do if self.internalState.tty.flags[h]~=nil then self.internalState.tty.flags[h]=i end end end;local y=deepcopy(self.internalState.tty.flags)y.hasgfx=term.getGraphicsMode~=nil;return y end;function f6.peripheral_monitor.methods:openterm(process)return terminal.openterm(self.internalState.tty,process)end;function f6.peripheral_monitor.methods:opengfx(process)return terminal.opengfx(self.internalState.tty,process)end;function f6.peripheral_monitor:init()f7(self)local af,ag=self.internalState.peripheral.call(self.id,"getSize")local fp=self.internalState.peripheral.call(self.id,"getTextScale")self.displayName=af*fp.."x"..ag*fp.." monitor at "..self.id;local term={}for z,i in ipairs(self.internalState.peripheral.getMethods(self.id))do term[i]=function(...)return self.internalState.peripheral.call(self.id,i,...)end end;self.internalState.tty=terminal.makeTTY(term,af,ag)self.internalState.tty.isMonitor=true;terminal.redraw(self.internalState.tty,true)end;function f6.peripheral_monitor:deinit()local d0=self.internalState.tty;if d0.frontmostProcess then local i=d0.frontmostProcess;if i.stdin==d0 then i.stdin=nil end;if i.stdout==d0 then i.stdout=nil end;if i.stderr==d0 then i.stderr=nil end end;for z,i in ipairs(d0.processList)do if i.stdin==d0 then i.stdin=nil end;if i.stdout==d0 then i.stdout=nil end;if i.stderr==d0 then i.stderr=nil end end end;fa"monitor"eventHooks.monitor_resize=eventHooks.monitor_resize or{}eventHooks.monitor_resize[#eventHooks.monitor_resize+1]=function(ar)local dw=getNodeById(ar[2])if not dw then syslog.log({level="notice",module="Hardware"},"Received "..ar[1].." event for device ID "..ar[2]..", but no device node was found; ignoring")return end;local af,ag=f6.peripheral_monitor.methods.getSize(dw)terminal.resize(dw.internalState.tty,af,ag)hardware.broadcast(dw,"monitor_resize",{device=hardware.path(dw),width=af,height=ag})end;f6.peripheral_printer={name="peripheral_printer",type="printer",properties={"inkLevel","paperLevel"},methods={}}f6.peripheral_printer.methods.getInkLevel=fb"getInkLevel"f6.peripheral_printer.methods.getPaperLevel=fb"getPaperLevel"function f6.peripheral_printer.methods:page(process)if self.internalState.printer.open then self.internalState.peripheral.call(self.id,"endPage")self.internalState.printer.open=false end;if not self.internalState.peripheral.call(self.id,"newPage")then return nil end;self.internalState.printer.open=true;local fq,p,q;local function dd(...)if not self.internalState.printer.open then error("attempt to use closed page",2)end;return self.internalState.peripheral.call(self.id,"write",...)end;local function fr()if not self.internalState.printer.open then return true end;if not self.internalState.peripheral.call(self.id,"endPage")then return false end;self.internalState.printer.open=false end;setfenv(dd,process.env)setfenv(fr,process.env)debug.protect(dd)debug.protect(fr)return f8(process,{__index=function(z,aC)if not self.internalState.printer.open then error("attempt to use closed page",2)end;if aC=="size"then local t,cX=self.internalState.peripheral.call(self.id,"getPageSize")return f8(process,{__index=function(z,aC)if aC=="width"then return t elseif aC=="height"then return cX end end,__newindex=function()error("Cannot modify read-only table",2)end})elseif aC=="cursor"then p,q=self.internalState.peripheral.call(self.id,"getCursorPos")return f8(process,{__index=function(z,aC)if aC=="x"then return p elseif aC=="y"then return q end end,__newindex=function(z,aC,aD)if aC=="x"then p=aD;self.internalState.peripheral.call(self.id,"setCursorPos",p,q)elseif aC=="y"then q=aD;self.internalState.peripheral.call(self.id,"setCursorPos",p,q)else error("Cannot modify member '"..aC.."'",2)end end})elseif aC=="title"then return fq elseif aC=="isOpen"then return self.internalState.printer.open elseif aC=="write"then return dd elseif aC=="close"then return fr end end,__newindex=function(z,aC,aD)if not self.internalState.printer.open then error("attempt to use closed page",2)end;if aC=="cursor"then if type(aD)~="table"then error("bad value for 'cursor' (expected table, got "..type(aD)..")",2)end;expect.field(aD,"x","number")expect.field(aD,"y","number")p,q=aD.x,aD.y;self.internalState.peripheral.call(self.id,"setCursorPos",p,q)elseif aC=="title"then if type(aD)~="string"and aD~=nil then error("bad value for 'title' (expected string, got "..type(aD)..")",2)end;fq=aD;self.internalState.peripheral.call(self.id,"setPageTitle",fq)else error("Cannot modify member '"..aC.."'",2)end end})end;function f6.peripheral_printer:init()f7(self)self.displayName="Speaker at "..self.id;self.internalState.printer={open=false}end;fa"printer"f6.peripheral_speaker={name="peripheral_speaker",type="speaker",properties={},methods={}}function f6.peripheral_speaker.methods:playNote(process,ft,fu,fv)expect(1,ft,"string")expect(2,fu,"number","nil")expect(3,fv,"number","nil")if fu then expect.range(fu,0,3)end;if fv then expect.range(fv,0,24)end;return self.internalState.peripheral.call(self.id,"playNote",ft,fu,fv)end;function f6.peripheral_speaker.methods:playSound(process,m,fu,fw)expect(1,m,"string")expect(2,fu,"number","nil")expect(3,fw,"number","nil")if fu then expect.range(fu,0,3)end;if fw then expect.range(fw,0.5,2.0)end;return self.internalState.peripheral.call(self.id,"playNote",m,fu,fw)end;function f6.peripheral_speaker.methods:playAudio(fx,fu)expect(1,fx,"table")expect(2,fu,"number","nil")if fu then expect.range(fu,0,3)end;return self.internalState.peripheral.call(self.id,"playAudio",fx,fu)end;f6.peripheral_speaker.methods.stop=fb"stop"function f6.peripheral_command:init()f7(self)self.displayName="Speaker at "..self.id end;fa"speaker"eventHooks.speaker_audio_empty=eventHooks.speaker_audio_empty or{}eventHooks.speaker_audio_empty[#eventHooks.speaker_audio_empty+1]=function(ar)local dw=getNodeById(ar[2])if not dw then syslog.log({level="notice",module="Hardware"},"Received "..ar[1].." event for device ID "..ar[2]..", but no device node was found; ignoring")return end;hardware.broadcast(dw,"speaker_audio_empty",{device=hardware.path(dw)})end;local fy={f6.peripheral_command,f6.peripheral_computer,f6.peripheral_drive,f6.peripheral_energy_storage,f6.peripheral_fluid_storage,f6.peripheral_inventory,f6.peripheral_monitor,f6.peripheral_printer,f6.peripheral_speaker}function registerDriver(eM)local fz=eM.init;eM.init=function(dw)f7(dw)if fz then return fz(dw)end end;eM.__callback=f9(eM,eM.type)hardware.listen(eM.__callback,deviceTreeRoot)fy[#fy+1]=eM;for z,dw in ipairs(hardware.find("modem"))do if not dw.metadata.wireless then hardware.listen(eM.__callback,dw)dw.internalState.modem.callbacks[#dw.internalState.modem.callbacks+1]=f end end end;function deregisterDriver(eM)if not eM.__callback then return end;hardware.unlisten(eM.__callback)for z,i in ipairs(hardware.find(eM.type))do hardware.deregister(i,eM)end;for v,i in ipairs(f5)do if i==eM then table.remove(f5,v)break end end;for z,dw in ipairs(hardware.find("modem"))do if not dw.metadata.wireless then hardware.unlisten(eM.__callback)for v,i in ipairs(dw.internalState.modem.callbacks)do if i==eM.__callback then table.remove(dw.internalState.modem.callbacks,v)break end end end end end;f6.peripheral_modem={name="peripheral_modem",type="modem",properties={"remainingChannels"},methods={}}function f6.peripheral_modem.methods:getRemainingChannels()local b=128;for z in pairs(self.internalState.modem)do b=b-1 end;return b end;function f6.peripheral_modem.methods:open(process,fA)if not self.internalState.modem[fA]then self.internalState.peripheral.call(self.id,"open",fA)self.internalState.modem[fA]={}end;self.internalState.modem[fA][process]=true end;function f6.peripheral_modem.methods:isOpen(process,fA)return self.internalState.modem[fA]and self.internalState.modem[fA][process]end;function f6.peripheral_modem.methods:close(process,fA)self.internalState.modem[fA][process]=nil;if not next(self.internalState.modem[fA])then self.internalState.peripheral.call(self.id,"close",fA)self.internalState.modem[fA]=nil end end;function f6.peripheral_modem.methods:closeAll(process)for fA=0,65535 do self.internalState.modem[fA][process]=nil;if not next(self.internalState.modem[fA])then self.internalState.peripheral.call(self.id,"close",fA)self.internalState.modem[fA]=nil end end end;function f6.peripheral_modem.methods:transmit(process,fA,fB,fC)expect(1,fA,"number")fB=expect(2,fB,"number","nil")or fA;return self.internalState.peripheral.call(self.id,"transmit",fA,fB,fC)end;function f6.peripheral_modem:init()f7(self)self.metadata.wireless=self.internalState.peripheral.call(self.id,"isWireless")self.displayName=(self.metadata.wireless and"Wireless"or"Wired").." modem at "..self.id;self.internalState.modem={}self.internalState.modem.channels={}self.internalState.peripheral.call(self.id,"closeAll")if not self.metadata.wireless then self.internalState.modem.callbacks={}for z,i in ipairs(fy)do local f=f9(i,i.type)hardware.listen(f,self)self.internalState.modem.callbacks[#self.internalState.modem.callbacks+1]=f end;local f=f9(f6["peripheral_computer"],"turtle")hardware.listen(f,self)self.internalState.modem.callbacks[#self.internalState.modem.callbacks+1]=f;for z,m in ipairs(self.internalState.peripheral.call(self.id,"getNamesRemote"))do hardware.add(self,m)end end end;function f6.peripheral_modem:deinit()if not self.metadata.wireless then for z,i in ipairs(self.internalState.modem.callbacks)do hardware.unlisten(i)end end end;fa"modem"eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(ar)local dw=getNodeById(ar[2])or hardware.get(ar[2])if not dw then syslog.log({level="notice",module="Hardware"},"Received "..ar[1].." event for device ID "..ar[2]..", but no device node was found; ignoring")return end;local a5=false;for i in pairs(dw.listeners)do if(dw.internalState.modem[ar[3]]or{})[i]then i.eventQueue[#i.eventQueue+1],a5={"modem_message",{device=hardware.path(dw),channel=ar[3],replyChannel=ar[4],message=ar[5],distance=ar[6]}},true end end;return a5 end;f6.loopback_modem={name="loopback_modem",type="modem",properties={"remainingChannels"},methods={}}function f6.loopback_modem.methods:getRemainingChannels()local b=128;for z in pairs(self.internalState.modem)do b=b-1 end;return b end;function f6.loopback_modem.methods:open(process,fA)if not self.internalState.modem[fA]then self.internalState.modem[fA]={}end;self.internalState.modem[fA][process]=true end;function f6.loopback_modem.methods:isOpen(process,fA)return self.internalState.modem[fA]and self.internalState.modem[fA][process]end;function f6.loopback_modem.methods:close(process,fA)self.internalState.modem[fA][process]=nil;if not next(self.internalState.modem[fA])then self.internalState.modem[fA]=nil end end;function f6.loopback_modem.methods:closeAll(process)for fA=0,65535 do self.internalState.modem[fA][process]=nil;if not next(self.internalState.modem[fA])then self.internalState.modem[fA]=nil end end end;function f6.loopback_modem.methods:transmit(process,fA,fB,fC)expect(1,fA,"number")fB=expect(2,fB,"number","nil")or fA;os.queueEvent("modem_message",self.uuid,fA,fB,fC,0)end;function f6.loopback_modem:init()self.metadata.wireless=true;self.displayName="Loopback modem"self.internalState.modem={}self.internalState.modem.channels={}end;local function fD(fE)local b3={scheme=""}for a9 in fE:gmatch"."do if b3.fragment then if a9:match"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/?]"then b3.fragment=b3.fragment..a9 else error("Invalid URI",3)end elseif b3.query then if a9=="#"then b3.fragment=""elseif a9:match"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/?]"then b3.query=b3.query..a9 else error("Invalid URI",3)end elseif b3.path then if a9=="/"and b3.path=="/"and not b3.host then b3.path,b3.host=nil,""elseif a9=="?"then b3.query=""elseif a9=="#"then b3.fragment=""elseif a9:match"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/]"then b3.path=b3.path..a9 else error("Invalid URI",3)end elseif b3.port then if tonumber(a9)then b3.port=b3.port..a9 elseif a9=="/"then b3.path="/"else error("Invalid URI",3)end elseif b3.host then if a9=="@"and not b3.user then b3.user,b3.host=b3.host,""elseif a9==":"then b3.port=""elseif a9=="/"then b3.path="/"elseif a9:match"[%w%-%._~%%/!%$&'%(%)%*%+,;=]"then b3.host=b3.host..a9 else error("Invalid URI",3)end else if a9==":"then b3.path=""elseif a9:match(b3.scheme==""and"[%a%+%-%.]"or"[%w%+%-%.]")then b3.scheme=b3.scheme..a9 else error("Invalid URI",3)end end end;if b3.port then b3.port=tonumber(b3.port)end;return b3 end;local function fF(fG)if fG:match"^%d+$"then return tonumber(fG)elseif fG:match"^%d+%.%d+$"then return tonumber(fG:match"^%d+")*0x1000000+tonumber(fG:match"^%d+%.(%d+)")elseif fG:match"^%d+%.%d+%.%d+$"then return tonumber(fG:match"^(%d+)")*0x1000000+tonumber(fG:match"^%d+%.(%d+)")*0x10000+tonumber(fG:match"^%d+%.%d+%.(%d+)")elseif fG:match"^%d+%.%d+%.%d+%.%d+$"then return tonumber(fG:match"^(%d+)")*0x1000000+tonumber(fG:match"^%d+%.(%d+)")*0x10000+tonumber(fG:match"^%d+%.%d+%.(%d+)")*0x100+tonumber(fG:match"^%d+%.%d+%.%d+%.(%d+)")else error("Invalid IP address",2)end end;local function fH(b)if not b then return nil end;return("%d.%d.%d.%d"):format(bit32.band(bit32.rshift(b,24),0xFF),bit32.band(bit32.rshift(b,16),0xFF),bit32.band(bit32.rshift(b,8),0xFF),bit32.band(b,0xFF))end;local function fI(fJ)local bn=""for v=1,fJ do bn=bn..string.char(math.random(0,255))end;return bn end;local function fK(b)return bit32.bnot(2^(32-b)-1)end;local function fL(w)local r=0;while bit32.btest(w,0x80000000)do w,r=bit32.lshift(w,1),r+1 end;return r end;local function fM(dw)if not dw then error("No such device")end;for z,i in pairs(dw.drivers)do if i.type=="modem"then return dw end end;error("Not a modem")end;local fN=0;local fO={}local fP={maxn=0,[0]={}}local fQ={}local fR={send={},recv={}}local fS={}local fT={}local fU=setmetatable({},{__mode="k"})local fV={arp={},socket={}}local fW={}function fR.send.link(b3,fX,ae)expect(2,fX,"number","nil")expect.field(b3,"device","table")local bv={PhoenixNetworking=true,type="link",source=os.computerID(),destination=fX,payload=ae}if fX==os.computerID()then os.queueEvent("modem_message",b3.device.id,b3.outPort or 0,b3.inPort or 0,bv,0)else hardware.call(b3.process or KERNEL,b3.device,"transmit",b3.outPort or 0,b3.inPort or 0,bv)end end;function fR.send.arp_request(b3,fG)expect.field(b3,"device","table")expect(2,fG,"string")hardware.call(b3.process or KERNEL,b3.device,"transmit",0,0,{PhoenixNetworking=true,type="arp",reply=false,source=os.computerID(),sourceIP=fO[b3.device.uuid]and fH(fO[b3.device.uuid].ip),destinationIP=fG})end;function fR.send.arp_reply(b3,fX,fY)expect.field(b3,"device","table")expect(2,fX,"number")expect(3,fY,"string","nil")hardware.call(b3.process or KERNEL,b3.device,"transmit",0,0,{PhoenixNetworking=true,type="arp",reply=true,source=os.computerID(),sourceIP=fH(fO[b3.device.uuid].ip),destination=fX,destinationIP=fY})end;function fR.send.internet(b3,fX,ae)expect(2,fX,"number")local e0={PhoenixNetworking=true,type="internet",hopsLeft=15,payload=ae,destination=fH(fX)}local aA=fI(32)e0.messageID=aA;local i;for v=fP.maxn,0,-1 do if fP[v]then for z,fZ in ipairs(fP[v])do if bit32.band(fZ.source,fZ.sourceNetmask)==bit32.band(fX,fZ.sourceNetmask)and(not i or fL(fZ.sourceNetmask)>fL(i.sourceNetmask))then i=fZ end end end end;if not i then return fR.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="No route to host",payload=e0})end;if i.action=="unicast"and fO[i.device.uuid]and fO[i.device.uuid].up then b3.device=i.device;e0.source=fH(fO[i.device.uuid].ip)if fQ[i.device.uuid]and fQ[i.device.uuid][i.destination]then return fR.send.link(b3,fQ[i.device.uuid][i.destination],e0)end;local f_=false;local f1;local function g0(z,fG,bz)if not f_ and fF(fG)==i.destination then f_=true;fR.send.link(b3,bz,e0)end;if f_ then for v,f in ipairs(fV.arp)do if f==g0 then table.remove(fV.arp,v)break end end end end;local function g1(ar)if ar[2]==f1 then if not f_ then fR.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="No route to host",payload=e0})end;f_=true;for v,i in ipairs(eventHooks.timer)do if i==g1 then table.remove(eventHooks.timer,v)break end end;for v,f in ipairs(fV.arp)do if f==g0 then table.remove(fV.arp,v)break end end end end;fV.arp[#fV.arp+1]=g0;fR.send.arp_request(b3,fH(i.destination))eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=g1;f1=os.startTimer(2)return elseif i.action=="broadcast"and fO[i.device.uuid]and fO[i.device.uuid].up then b3.device=i.device;e0.source=fH(fO[i.device.uuid].ip)return fR.send.link(b3,nil,e0)elseif i.action=="local"and fO[i.device.uuid]and fO[i.device.uuid].up then b3.device=i.device;e0.source=fH(fO[i.device.uuid].ip)if fQ[i.device.uuid]and fQ[i.device.uuid][fX]then return fR.send.link(b3,fQ[i.device.uuid][fX],e0)end;local f_=false;local f1;local function g0(z,fG,bz)if not f_ and fF(fG)==fX then f_=true;fR.send.link(b3,bz,e0)end;if f_ then for v,f in ipairs(fV.arp)do if f==g0 then table.remove(fV.arp,v)break end end end end;local function g1(ar)if ar[2]==f1 then if not f_ then fR.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="No route to host",payload=e0})end;f_=true;for v,i in ipairs(eventHooks.timer)do if i==g1 then table.remove(eventHooks.timer,v)break end end end end;fV.arp[#fV.arp+1]=g0;fR.send.arp_request(b3,fH(fX))eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=g1;f1=os.startTimer(2)return elseif i.action=="unreachable"then return fR.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="Destination unreachable",payload=e0})elseif i.action=="prohibit"then return fR.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="Prohibited",payload=e0})elseif i.action=="blackhole"then return end end;function fR.send.control(b3,fX,type,o,g2)expect(3,type,"string")expect(4,o,"string","nil")return fR.send.internet(b3,fX,{PhoenixNetworking=true,type="control",messageType=type,error=o,payload=g2})end;fR.send.socket={}function fR.send.socket.connect(b3,fG,g3,g4)for v=1,16384 do local E=math.random(49152,65535)if not fS[E]or not fS[E][g3]then g4.localPort=E;break end end;if not g4.localPort then error("Too many open sockets")end;g4.id=fN;fN=fN+1;g4.ip=fG;g4.port=g3;g4.sendSeq=math.floor(math.random()*0x10000000000)g4.sendSeqNext=g4.sendSeq+2;g4.sendSeqMax=g4.sendSeq+256;b3.outPort=g3;b3.inPort=g4.localPort;fU[g4]=function(E)if E.type=="control"and E.payload.destination==fH(fG)then g4.status="error"g4.error=E.error;return true end;return false end;fR.send.internet(b3,fG,{PhoenixNetworking=true,type="socket",sequence=g4.sendSeqNext-1,windowSize=256,synchronize=true})local bf,o=pcall(hardware.call,b3.process or KERNEL,b3.device,"open",g4.localPort)if not bf then fR.send.internet(b3,fG,{PhoenixNetworking=true,type="socket",sequence=g4.sendSeqNext,windowSize=0,reset=true})g4.status="error"g4.error=o;return false end;g4.status="syn-sent"g4.nextUpdate=os.epoch"utc"+5000;g4.process=b3.process;g4.retryCount=0;fS[g4.localPort]=fS[g4.localPort]or{}fS[g4.localPort][g3]=g4;fT[g4.id]=g4 end;function fR.send.socket.data(b3,ae,g4)b3.outPort=g4.port;b3.inPort=g4.localPort;ae.PhoenixNetworking=true;ae.type="socket"if not ae.sequence then ae.sequence=g4.sendSeqNext;g4.sendSeqNext=g4.sendSeqNext+1 end;ae.acknowledgement=ae.acknowledgement or g4.recvSeq-1;g4.nextAck=nil;if not ae.final then ae.windowSize=256 end;return fR.send.internet(b3,g4.ip,ae)end;function fR.send.socket.ack(b3,b,g4)return fR.send.socket.data(b3,{acknowledgement=b},g4)end;function fR.send.socket.reset(b3,fG,g3,g5,g6,g7)b3.outPort=g3;b3.inPort=g7 or g3;return fR.send.internet(b3,fG,{PhoenixNetworking=true,type="socket",sequence=g5,acknowledgement=g6,reset=true})end;local function g8(g4,n,...)n=n or"*l"if type(n)~="string"and type(n)~="number"then error("bad argument (expected string or number, got "..type(n)..")",2)end;if g4.buffer==""then return nil end;n=n:gsub("^%*","")if n=="a"then local a0=g4.buffer;g4.buffer=""return a0 elseif n=="l"then local a0,a7=g4.buffer:match"^([^\n]*)\n?()"if a0 then g4.buffer=g4.buffer:sub(a7)if select("#",...)>0 then return a0,g8(g4,...)else return a0 end else return nil end elseif n=="L"then local a0,a7=g4.buffer:match"^([^\n]*\n?)()"if a0 then g4.buffer=g4.buffer:sub(a7)if select("#",...)>0 then return a0,g8(g4,...)else return a0 end else return nil end elseif n=="n"then local a0,a7=g4.buffer:match"(%d+)()"if a0 then g4.buffer=g4.buffer:sub(a7)if select("#",...)>0 then return tonumber(a0),g8(g4,...)else return tonumber(a0)end else return nil end elseif type(n)=="number"then local a0=g4.buffer:sub(1,n)g4.buffer=g4.buffer:sub(n+1)if select("#",...)>0 then return a0,g8(g4,...)else return a0 end else error("bad argument (invalid mode '"..n.."')",2)end end;local function g9(g4,bh,...)bh=tostring(bh)g4.outQueue[g4.sendSeqNext]=bh;fR.send.socket.data({},{payload=bh},g4)if select("#",...)>0 then return g9(g4,...)end end;function syscalls.__socketcall(process,aq,aA,eP,...)local g4=fT[aA]if not g4 then error("No such socket")end;local ga=process;while process~=g4.process do if process==nil then error("No such socket")end;process=processes[process.parent or-1]end;if eP=="close"then g4.sendSeqMax=g4.sendSeqNext;fR.send.socket.data({},{final=true},g4)g4.status="fin-wait"elseif eP=="read"then return g8(g4,...)elseif eP=="write"then return g9(g4,...)elseif eP=="transfer"then g4.process=ga else error("No such method")end end;local do_syscall=do_syscall;local function gb(g4)local bv=setmetatable({id=g4.id},{__name="socket"})function bv:localIP()return g4.localIP end;function bv:status()if g4.status=="listening"or g4.status=="syn-sent"or g4.status=="syn-received"then return"connecting"elseif g4.status=="connected"or g4.buffer~=""then return"open"elseif g4.status=="error"then return"error",g4.error else return"closed"end end;function bv:read(n,...)if g4.status~="connected"and g4.status~="close-wait"and g4.status~="closed"then error("attempt to read from a "..g4.status.." handle",2)end;return do_syscall("__socketcall",g4.id,"read",n,...)end;function bv:write(bh,...)if g4.status~="connected"then error("attempt to write to a "..g4.status.." handle",2)end;return do_syscall("__socketcall",g4.id,"write",bh,...)end;function bv:close()if g4.status=="closing"or g4.status=="fin-wait"or g4.status=="closed"then return end;if not(g4.status=="listening"or g4.status=="syn-sent"or g4.status=="syn-received"or g4.status=="connected")then error("attempt to close a "..g4.status.." handle",2)end;return do_syscall("__socketcall",g4.id,"close")end;function bv:transfer()return do_syscall("__socketcall",g4.id,"transfer")end;return bv end;function fR.recv.link(b3,ae)expect.field(ae,"source","number")expect.field(ae,"destination","number")expect.field(ae,"payload","table")syslog.debug("Received link message from",ae.source,"to",ae.destination)if ae.destination~=os.computerID()then return end;b3.sourceID=ae.source;assert(ae.payload.PhoenixNetworking)expect.field(ae.payload,"type","string")if not fR.recv[ae.payload.type]then error("Unknown protocol '"..ae.payload.type.."'")end;return fR.recv[ae.payload.type](b3,ae.payload)end;function fR.recv.arp(b3,ae)expect.field(ae,"source","number")expect.field(ae,"reply","boolean")syslog.debug("Received arp message from",ae.source)if not ae.reply and ae.destinationIP and ae.sourceIP~=ae.destinationIP then local fG=fF(expect.field(ae,"destinationIP","string"))if fO[b3.device.uuid]and fO[b3.device.uuid].ip==fG then fR.send.arp_reply(b3,ae.source,ae.sourceIP)end end;if ae.sourceIP then local fG=fF(expect.field(ae,"sourceIP","string"))fQ[b3.device.uuid]=fQ[b3.device.uuid]or{}fQ[b3.device.uuid][fG]=ae.source;local gc={}for v,i in ipairs(fV.arp)do gc[v]=i end;for z,i in ipairs(gc)do i(i,ae.sourceIP,ae.source)end end end;function fR.recv.internet(b3,ae)b3.sourceIP=fF(expect.field(ae,"source","string"))local bz=fF(expect.field(ae,"destination","string"))b3.localIP=bz;syslog.debug("Received internet message from",ae.source,"to",ae.destination)expect.field(ae,"payload","table")if fW[expect.field(ae,"messageID","number","string")]then return end;fW[ae.messageID]=os.epoch"utc"if not fO[b3.device.uuid]or fO[b3.device.uuid].ip~=bz then return end;b3.ipPacket=ae;assert(ae.payload.PhoenixNetworking)expect.field(ae.payload,"type","string")if not fR.recv[ae.payload.type]then error("Unknown protocol '"..ae.payload.type.."'")end;return fR.recv[ae.payload.type](b3,ae.payload)end;function fR.recv.control(b3,ae)expect.field(ae,"messageType","string")syslog.debug("Received control message",ae.messageType)local a5=false;if ae.messageType=="ping"then fR.send.control({device=b3.device},b3.sourceIP,"pong",nil,b3.ipPacket)else for z,i in pairs(fU)do a5=i{type="control",messageType=ae.messageType,error=ae.error,payload=ae.payload,sender=fH(b3.sourceIP)}or a5 end end;return a5 end;function fR.recv.socket(b3,ae)expect.field(ae,"sequence","number")expect.field(ae,"acknowledgement","number","nil")expect.field(ae,"windowSize","number","nil")expect.field(ae,"payload","string","nil")if b3.channel==0 or b3.replyChannel==0 then syslog.debug("Received socket event on channel 0; discarding.")return end;local g4=(fS[b3.channel]or{})[b3.replyChannel]or(fS[b3.channel]or{}).listen;if not g4 then if ae.acknowledgement then fR.send.socket.reset(b3,b3.sourceIP,b3.replyChannel,ae.acknowledgement,nil,b3.channel)else fR.send.socket.reset(b3,b3.sourceIP,b3.replyChannel,0,ae.sequence+(ae.windowSize or 0),b3.channel)end;return end;do local bn={}for h,i in pairs(g4)do if h~="process"then bn[h]=i end end;syslog.debug("Received socket message:",serialize(ae),"\nSocket info:",serialize(bn))end;if g4.status=="listening"then if ae.reset then return end;if ae.acknowledgement then fR.send.socket.reset(b3,b3.sourceIP,b3.replyChannel,ae.acknowledgement,nil,b3.channel)return end;if not ae.synchronize then return end;g4.ip=b3.sourceIP;g4.localIP=fH(b3.localIP)g4.port=b3.replyChannel;g4.recvSeq=ae.sequence+1;g4.recvSeqMax=g4.recvSeq+(ae.windowSize or 0)g4.sendSeq=math.floor(math.random()*0x10000000000)g4.sendSeqNext=g4.sendSeq+2;g4.sendSeqMax=g4.sendSeq+(ae.windowSize or 0)g4.status="syn-received"g4.nextUpdate=os.epoch"utc"+5000;g4.retryCount=0;fS[b3.channel][b3.replyChannel]=g4;fS[b3.channel].listen=nil;fR.send.internet({inPort=b3.channel,outPort=b3.replyChannel},g4.ip,{PhoenixNetworking=true,type="socket",sequence=g4.sendSeqNext-1,acknowledgement=g4.recvSeq,windowSize=256,synchronize=true})elseif g4.status=="syn-sent"then if ae.reset then g4.status="error"g4.error="Connection refused"fS[b3.channel][b3.replyChannel]=nil;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={"handle_status_change",{id=g4.id,status="error"}}end;return true end;if not ae.synchronize or not ae.acknowledgement or ae.acknowledgement<g4.sendSeq then fR.send.socket.reset(b3,b3.sourceIP,b3.replyChannel,ae.acknowledgement,nil,b3.channel)g4.status="error"g4.error="Connection refused"fS[b3.channel][b3.replyChannel]=nil;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={"handle_status_change",{id=g4.id,status="error"}}end;return true end;g4.localIP=fH(b3.localIP)g4.status="connected"g4.sendSeq=ae.acknowledgement;g4.sendSeqMax=g4.sendSeq+256;g4.recvSeq=ae.sequence+1;g4.recvSeqMax=g4.recvSeq+(ae.windowSize or 0)g4.outQueue={}g4.nextUpdate=os.epoch"utc"+2000;fR.send.socket.ack({},g4.recvSeq,g4)if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={"handle_status_change",{id=g4.id,status="connected"}}end;return true else if ae.sequence<g4.recvSeq or ae.sequence>g4.recvSeqMax then syslog.debug("Sequence out of range")if ae.reset then g4.status="error"g4.error="Connection reset by peer"fS[b3.channel][b3.replyChannel]=nil;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={"handle_status_change",{id=g4.id,status="error"}}end;return true else fR.send.socket.ack({},g4.recvSeq,g4)return end end;if ae.reset then syslog.debug("Received reset")if g4.status=="syn-received"then g4.status="listening"return elseif g4.status=="connected"or g4.status=="fin-wait"then g4.status="error"g4.error="Connection reset by peer"fS[b3.channel][b3.replyChannel]=nil;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={"handle_status_change",{id=g4.id,status="error"}}end;return true else g4.status="closed"fS[b3.channel][b3.replyChannel]=nil;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={"handle_status_change",{id=g4.id,status="closed"}}end;return true end end;if ae.synchronize then fR.send.socket.reset(b3,b3.sourceIP,b3.replyChannel,ae.acknowledgement,nil,b3.channel)g4.status="error"g4.error="Connection reset by host"fS[b3.channel][b3.replyChannel]=nil;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={"handle_status_change",{id=g4.id,status="error"}}end;return true end;local a5;if not ae.acknowledgement then syslog.debug("No acknowledgement")return end;if g4.status=="syn-received"then if ae.acknowledgement>=g4.sendSeq and ae.acknowledgement<=g4.sendSeqNext then g4.status="connected"g4.outQueue={}g4.nextUpdate=os.epoch"utc"+2000;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={"network_request",{uri=g4.uri,ip=fH(b3.sourceIP),handle=gb(g4)}}end;a5=true else fR.send.socket.reset(b3,b3.sourceIP,b3.replyChannel,ae.acknowledgement,nil,b3.channel)g4.status="error"g4.error="Connection reset by host"fS[b3.channel][b3.replyChannel]=nil;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={"handle_status_change",{id=g4.id,status="error"}}end;return true end elseif g4.status=="close-wait"then if ae.acknowledgement==g4.sendSeqMax then syslog.debug("Socket closed")g4.status="closed"fS[b3.channel][b3.replyChannel]=nil;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={"handle_status_change",{id=g4.id,status="closed"}}end;return true end elseif g4.status=="time-wait"then if ae.final then fR.send.socket.ack({},ae.sequence,g4)g4.nextUpdate=os.epoch"utc"+10000;return end else if ae.acknowledgement>g4.sendSeq and ae.acknowledgement<=g4.sendSeqNext then for v=g4.sendSeq,ae.acknowledgement do g4.outQueue[v]=nil end;g4.sendSeq=ae.acknowledgement;if ae.windowSize then g4.sendSeqMax=g4.sendSeq+ae.windowSize end end;if g4.status=="fin-wait"then if ae.acknowledgement==g4.sendSeqMax then if not ae.final then fR.send.socket.reset(b3,b3.sourceIP,b3.replyChannel,ae.acknowledgement,nil,b3.channel)g4.status="error"g4.error="Connection reset by host"fS[b3.channel][b3.replyChannel]=nil;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={"handle_status_change",{id=g4.id,status="error"}}end;return true end;g4.status="time-wait"g4.nextUpdate=os.epoch"utc"+10000 end elseif g4.status=="closing"then if ae.acknowledgement==g4.sendSeqMax then g4.status="time-wait"g4.nextUpdate=os.epoch"utc"+10000 end end end;if g4.status=="connected"and ae.sequence==g4.recvSeq then if ae.payload then g4.buffer=g4.buffer..ae.payload;g4.nextAck=true;g4.nextUpdate=os.epoch"utc"+100;if g4.process then syslog.debug("Sending data event to PID "..g4.process.id)g4.process.eventQueue[#g4.process.eventQueue+1]={"handle_data_ready",{id=g4.id}}end;a5=true end;g4.recvSeq=g4.recvSeq+1 end;if ae.final then syslog.debug("Got final message")g4.recvSeq=ae.sequence+1;if g4.status=="syn-received"or g4.status=="connected"then g4.sendSeqMax=g4.sendSeqNext;fR.send.socket.data({},{final=true,acknowledgement=ae.sequence},g4)g4.status="close-wait"if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={"handle_status_change",{id=g4.id,status="closed"}}end;return true elseif g4.status=="fin-wait"then fR.send.socket.ack({},ae.sequence,g4)if ae.acknowledgement~=g4.sendSeqMax then g4.status="closing"else g4.status="time-wait"g4.nextUpdate=os.epoch"utc"+10000 end else fR.send.socket.ack({},ae.sequence,g4)end;syslog.debug(g4.status)end;return a5 end end;local function gd()local c2=os.epoch"utc"local eg=false;for g3,ge in pairs(fS)do for gf,g4 in pairs(ge)do if c2>=g4.nextUpdate then if g4.status=="syn-sent"then g4.status="error"g4.error="Connection timed out (syn-sent)"fS[g3][gf]=nil;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={"handle_status_change",{id=g4.id,status="error"}}eg=true end elseif g4.status=="syn-received"then g4.retryCount=g4.retryCount+1;if g4.retryCount>3 then g4.status="error"g4.error="Connection timed out (syn-received)"fS[g3][gf]=nil;if g4.process then g4.process.eventQueue[#g4.process.eventQueue+1]={"handle_status_change",{id=g4.id,status="error"}}eg=true end else g4.nextUpdate=os.epoch"utc"+2000 end elseif g4.status=="connected"then for v=g4.sendSeq+1,g4.sendSeqNext-1 do if g4.outQueue[v]then fR.send.socket.data({},{sequence=v,payload=g4.outQueue[v]},g4)end end;if g4.nextAck then fR.send.socket.ack({},g4.recvSeq-1,g4)g4.nextAck=nil end;g4.nextUpdate=os.epoch"utc"+2000 elseif g4.status=="fin-wait"then elseif g4.status=="close-wait"then elseif g4.status=="time-wait"then syslog.debug("Time wait finished on port "..g3)g4.status="closed"fS[g3][gf]=nil end end end end;return eg end;eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(ar)if type(ar[5])=="table"and ar[5].PhoenixNetworking and type(ar[5].type)=="string"and fR.recv[ar[5].type]then local dw=getNodeById(ar[2])or hardware.get(ar[2])if not dw then syslog.log({level="notice",module="Network"},"Received network event for device ID "..ar[2]..", but no device node was found; ignoring")return end;if not fO[dw.uuid]or not fO[dw.uuid].up then return end;syslog.debug(ar[2],serialize(ar[5]))local bf,o=pcall(fR.recv[ar[5].type],{channel=ar[3],replyChannel=ar[4],device=dw},ar[5])if not bf then syslog.log({level="debug",module="Network"},"Network event errored while processing:",o)else return o end end end;local gg=os.startTimer(1)eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=function(ar)if ar[2]==gg then gg=os.startTimer(1)return gd()end end;local function gh(process,bC)local fE=fD(bC.url)if not fE.port then error("No port specified")end;local fG=fF(fE.host)local g3=fE.port;local g4={process=process,buffer=""}fR.send.socket.connect({process=process},fG,g3,g4)return gb(g4)end;local gi={}local gj={}local gk={}local gl=os.computerID()%65500;local gm={}eventHooks.http_success=eventHooks.http_success or{}eventHooks.http_success[#eventHooks.http_success+1]=function(ar)local b3=gi[ar[2]]if b3 then b3.handle,b3.status=ar[3],"open"b3.process.eventQueue[#b3.process.eventQueue+1]={"handle_status_change",{id=b3.id,status="open"}}gi[ar[2]]=nil;return true else syslog.log({level="notice"},"Received HTTP response for "..ar[2].." but nobody requested it; ignoring.")end end;eventHooks.http_failure=eventHooks.http_failure or{}eventHooks.http_failure[#eventHooks.http_failure+1]=function(ar)local b3=gi[ar[2]]if b3 then if ar[4]then b3.handle,b3.status=ar[3],"open"else b3.status,b3.error="error",ar[3]end;b3.process.eventQueue[#b3.process.eventQueue+1]={"handle_status_change",{id=b3.id,status=b3.status}}gi[ar[2]]=nil;return true else syslog.log({level="notice"},"Received HTTP response for "..ar[2].." but nobody requested it; ignoring.")end end;eventHooks.websocket_success=eventHooks.websocket_success or{}eventHooks.websocket_success[#eventHooks.websocket_success+1]=function(ar)local b3=gi[ar[2]]if b3 then b3.handle,b3.status=ar[3],"open"b3.process.eventQueue[#b3.process.eventQueue+1]={"handle_status_change",{id=b3.id,status="open"}}return true else syslog.log({level="notice"},"Received WebSocket response for "..ar[2].." but nobody requested it; ignoring.")end end;eventHooks.websocket_failure=eventHooks.websocket_failure or{}eventHooks.websocket_failure[#eventHooks.websocket_failure+1]=function(ar)local b3=gi[ar[2]]if b3 then b3.status,b3.error="error",ar[3]b3.process.eventQueue[#b3.process.eventQueue+1]={"handle_status_change",{id=b3.id,status=b3.status}}return true else syslog.log({level="notice"},"Received WebSocket response for "..ar[2].." but nobody requested it; ignoring.")end end;eventHooks.websocket_message=eventHooks.websocket_message or{}eventHooks.websocket_message[#eventHooks.websocket_message+1]=function(ar)local b3=gi[ar[2]]if b3 then b3.buffer=b3.buffer..ar[3]b3.process.eventQueue[#b3.process.eventQueue+1]={"handle_data_ready",{id=b3.id}}return true else syslog.log({level="notice"},"Received WebSocket message for "..ar[2].." but nobody requested it; ignoring.")end end;eventHooks.websocket_closed=eventHooks.websocket_closed or{}eventHooks.websocket_closed[#eventHooks.websocket_closed+1]=function(ar)local b3=gi[ar[2]]if b3 then b3.status="closed"b3.process.eventQueue[#b3.process.eventQueue+1]={"handle_status_change",{id=b3.id,status=b3.status}}gi[ar[2]]=nil;return true else syslog.log({level="notice"},"Received WebSocket message for "..ar[2].." but it's not open; ignoring.")end end;eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(ar)local a5=false;if gj[ar[2]]and(ar[3]==gl or ar[3]==65535)and type(ar[5])=="table"and type(ar[5].nMessageID)=="number"and ar[5].nMessageID==ar[5].nMessageID and not gm[ar[5].nMessageID]and(ar[5].nRecipient and ar[5].nRecipient==os.computerID()or ar[3]==65535)then if gk[ar[5].nSender]then for z,i in ipairs(gk[ar[5].nSender])do if not i.protocol or i.protocol==ar[5].sProtocol then i.buffer[#i.buffer+1]=deepcopy(ar[5].message)gm[ar[5].nMessageID]=os.clock()+9.5;i.process.eventQueue[#i.process.eventQueue+1]={"handle_data_ready",{id=i.id}}a5=true end end end;if gk[0xFFFFFFFF]then for z,i in ipairs(gk[0xFFFFFFFF])do if not i.protocol or i.protocol==ar[5].sProtocol then i.buffer[#i.buffer+1]=deepcopy(ar[5].message)gm[ar[5].nMessageID]=os.clock()+9.5;i.process.eventQueue[#i.process.eventQueue+1]={"handle_data_ready",{id=i.id}}a5=true end end end;for h,i in pairs(gm)do if i<os.clock()then gm[h]=nil end end end;return a5 end;local gn=http.request;local function go(process,bC)expect.field(bC,"encoding","string","nil")expect.field(bC,"headers","table","nil")expect.field(bC,"method","string","nil")expect.field(bC,"redirect","boolean","nil")local b3={status="ready",process=process,id=fN}local bv=setmetatable({id=fN},{__name="socket"})fN=fN+1;function bv:status()return b3.status,b3.error end;function bv:read(n,...)if b3.status~="open"then error("attempt to read from a "..b3.status.." handle",2)end;n=n or"*l"if type(n)~="string"and type(n)~="number"then error("bad argument (expected string or number, got "..type(n)..")",2)end;n=n:gsub("^%*","")if n=="a"then if select("#",...)>0 then return b3.handle.readAll(),self:read(...)else return b3.handle.readAll()end elseif n=="l"then if select("#",...)>0 then return b3.handle.readLine(false),self:read(...)else return b3.handle.readLine(false)end elseif n=="L"then if select("#",...)>0 then return b3.handle.readLine(true),self:read(...)else return b3.handle.readLine(true)end elseif n=="n"then local a0;repeat a0=b3.handle.read(1)if not a0 then return nil end until tonumber(a0)while true do local a9=b3.handle.read(1)if not a9 or not a9:match"%d"then break end;a0=a0 ..a9 end;if select("#",...)>0 then return tonumber(a0),self:read(...)else return tonumber(a0)end elseif type(n)=="number"then if select("#",...)>0 then return b3.handle.read(n),self:read(...)else return b3.handle.read(n)end else error("bad argument (invalid mode '"..n.."')",2)end end;function bv:write(...)if b3.status~="ready"then error("attempt to write to a "..b3.status.." handle",2)end;local bh;if select("#",...)>0 then bh=""for z,i in ipairs{...}do bh=bh..tostring(i)end end;local gp=bC.url.."#"..b3.id;local bf,o=gn{url=gp,body=bh,headers=bC.headers,binary=bC.encoding=="binary"or bC.encoding==nil,method=bC.method,redirect=bC.redirect}if bf then gi[gp]=b3;b3.status="connecting"else b3.status,b3.error="error",o end end;function bv:close()if b3.status~="open"then error("attempt to close a "..b3.status.." handle",2)end;b3.handle.close()b3.status="closed"end;function bv:responseHeaders()if b3.status~="open"then error("attempt to read from a "..b3.status.." handle",2)end;return b3.handle.getResponseHeaders()end;function bv:responseCode()if b3.status~="open"then error("attempt to read from a "..b3.status.." handle",2)end;return b3.handle.getResponseCode()end;return bv end;local function gq(process,bC)expect.field(bC,"encoding","string","nil")expect.field(bC,"headers","table","nil")local b3={process=process,id=fN,buffer=""}local bv=setmetatable({id=fN},{__name="socket"})fN=fN+1;function bv:status()return b3.status,b3.error end;function bv:read(n,...)if b3.status~="open"then error("attempt to read from a "..b3.status.." handle",2)end;n=n or"*l"if type(n)~="string"and type(n)~="number"then error("bad argument (expected string or number, got "..type(n)..")",2)end;if b3.buffer==""then return nil end;n=n:gsub("^%*","")if n=="a"then local a0=b3.buffer;b3.buffer=""return a0 elseif n=="l"then local a0,a7=b3.buffer:match"^([^\n]*)\n?()"if a0 then b3.buffer=b3.buffer:sub(a7)if select("#",...)>0 then return a0,self:read(...)else return a0 end else return nil end elseif n=="L"then local a0,a7=b3.buffer:match"^([^\n]*\n?)()"if a0 then b3.buffer=b3.buffer:sub(a7)if select("#",...)>0 then return a0,self:read(...)else return a0 end else return nil end elseif n=="n"then local a0,a7=b3.buffer:match"(%d+)()"if a0 then b3.buffer=b3.buffer:sub(a7)if select("#",...)>0 then return tonumber(a0),self:read(...)else return tonumber(a0)end else return nil end elseif type(n)=="number"then local a0=b3.buffer:sub(1,n)b3.buffer=b3.buffer:sub(n+1)if select("#",...)>0 then return a0,self:read(...)else return a0 end else error("bad argument (invalid mode '"..n.."')",2)end end;function bv:write(bh,...)if b3.status~="open"then error("attempt to write to a "..b3.status.." handle",2)end;b3.handle.send(tostring(bh),bC.encoding=="binary")if select("#",...)>0 then return self:write(...)end end;function bv:close()if b3.status~="open"then error("attempt to close a "..b3.status.." handle",2)end;b3.handle.close()b3.status="closed"end;local gp=bC.url.."#"..b3.id;local bf,o=http.websocket(gp,bC.headers)if bf then gi[gp]=b3;b3.status="connecting"else return nil,o end;return bv end;local function gr(process,bC)expect.field(bC,"device","string","nil")local gs;if bC.device then gs={hardware.get(bC.device)}else gs={hardware.find("modem")}end;if#gs==0 then error("Could not find a modem",2)end;for z,i in ipairs(gs)do fM(i)if not gj[i]then hardware.call(process,i,"open",gl)hardware.call(process,i,"open",65535)gj[i]=1 else gj[i]=gj[i]+1 end end;local fE=fD(bC.url)if not fE.host then error("Missing host",2)end;local aA=fF(fE.host)local b3={process=process,id=fN,buffer={},protocol=fE.scheme:match"rednet%+(.+)"}local bv=setmetatable({id=fN},{__name="socket"})fN=fN+1;function bv:status()return b3.closed and"closed"or"open"end;function bv:read(n,...)if b3.closed then error("attempt to read from a "..b3.status.." handle",2)end;n=n or"*l"if type(n)~="string"and type(n)~="number"then error("bad argument (expected string or number, got "..type(n)..")",2)end;if#b3.buffer==0 then return nil end;n=n:gsub("^%*","")if n=="a"then return table.remove(b3.buffer,1)elseif n=="l"then b3.buffer[1]=tostring(b3.buffer[1])local a0,a7=b3.buffer[1]:match"^([^\n]*)\n?()"if a0 then b3.buffer[1]=b3.buffer[1]:sub(a7)if select("#",...)>0 then return a0,self:read(...)else return a0 end else table.remove(b3.buffer,1)return self:read(n,...)end elseif n=="L"then b3.buffer[1]=tostring(b3.buffer[1])local a0,a7=b3.buffer[1]:match"^([^\n]*\n?)()"if a0 then b3.buffer[1]=b3.buffer[1]:sub(a7)if select("#",...)>0 then return a0,self:read(...)else return a0 end else table.remove(b3.buffer,1)return self:read(n,...)end elseif n=="n"then b3.buffer[1]=tostring(b3.buffer[1])local a0,a7=b3.buffer[1]:match"(%d+)()"if a0 then b3.buffer[1]=b3.buffer[1]:sub(a7)if select("#",...)>0 then return tonumber(a0),self:read(...)else return tonumber(a0)end else table.remove(b3.buffer,1)return self:read(n,...)end elseif type(n)=="number"then local a0=""while#a0<n do b3.buffer[1]=tostring(b3.buffer[1])a0=a0 ..b3.buffer[1]:sub(1,n-#a0)b3.buffer[1]=b3.buffer[1]:sub(n-#a0+1)if b3.buffer[1]==""then table.remove(b3.buffer,1)end;if#b3.buffer==0 then break end end;if select("#",...)>0 then return a0,self:read(...)else return a0 end else error("bad argument (invalid mode '"..n.."')",2)end end;function bv:write(bh,...)if b3.closed then error("attempt to write to a "..b3.status.." handle",2)end;local gt=math.random(1,0x7FFFFFFF)local e0={nMessageID=gt,nRecipient=aA,nSender=os.computerID(),message=bh,sProtocol=b3.protocol}if aA==os.computerID()then for z,i in ipairs(gs)do os.queueEvent("modem_message",i.id,gl,gl,e0,0)end else gm[gt]=os.clock()+9.5;for z,i in ipairs(gs)do hardware.call(process,i,"transmit",aA==0xFFFFFFFF and 65535 or aA%65500,gl,e0)hardware.call(process,i,"transmit",65533,gl,e0)end end;if select("#",...)>0 then return self:write(...)end end;function bv:close()if b3.closed then error("attempt to close a "..b3.status.." handle",2)end;for z,i in ipairs(gs)do gj[i]=gj[i]-1;if gj[i]==0 then hardware.call(process,i,"close",gl)hardware.call(process,i,"close",65535)gj[i]=nil end end;b3.status="closed"end;return bv end;uriSchemes={["https?"]=go,["wss?"]=gq,["rednet"]=gr,["rednet%+%a+"]=gr,["psp"]=gh}function syscalls.connect(process,aq,bC)if type(bC)=="string"then bC={url=bC}end;expect(1,bC,"table")expect.field(bC,"url","string")local fE=fD(bC.url)local bv,o;for h,i in pairs(uriSchemes)do if fE.scheme:match(h)then bv,o=i(process,bC)break end end;if not bv and not o then error("Invalid protocol "..fE.scheme)end;if bv then for z,i in pairs(bv)do if type(i)=="function"then setfenv(i,process.env)debug.protect(i)end end end;return bv,o end;function syscalls.listen(process,aq,fE)expect(1,fE,"string")local gu=fD(fE)if http.addListener then if gu.scheme=="http"then http.addListener(gu.port or 80)return elseif gu.scheme=="ws"then http.websocket(gu.port or 80)return end end;if gu.scheme=="psp"then if not gu.port then error("Missing port")end;local fG=fF(gu.host)for h,i in pairs(fO)do if i.up and(fG==0 or i.ip==fG)then hardware.call(process,hardware.get(h),"open",gu.port)end end;local g4={localPort=gu.port,id=fN,status="listening",process=process,nextUpdate=math.huge,retryCount=0,uri=fE,buffer=""}fN=fN+1;fS[gu.port]=fS[gu.port]or{}fS[gu.port].listen=g4;fT[g4.id]=g4;return end;error("Invalid protocol "..gu.scheme)end;function syscalls.unlisten(process,aq,fE)end;function syscalls.ipconfig(process,aq,eR,b3)if b3 and process.user~="root"then error("Permission denied")end;expect(1,eR,"string")expect(2,b3,"table","nil")local dw=fM(hardware.get(eR))local y=fO[dw.uuid]if not y then if b3 then expect.field(b3,"ip","string","number")expect.field(b3,"netmask","string","number")y={up=true}fO[dw.uuid]=y;hardware.call(KERNEL,dw,"open",0)else return nil end end;if b3 then expect.field(b3,"ip","string","number","nil")expect.field(b3,"netmask","string","number","nil")expect.field(b3,"up","boolean","nil")local gv,gw;if y.ip then for z,i in ipairs(fP[0])do if i.source==bit32.band(y.ip,y.netmask)and i.netmask==y.netmask then gv=i elseif i.source==bit32.bor(bit32.band(y.ip,y.netmask),bit32.bnot(y.netmask))and i.netmask==0xFFFFFFFF then gw=i end end end;if b3.ip then if fQ[dw.uuid]then fQ[dw.uuid][y.ip]=nil end;if type(b3.ip)=="number"then y.ip=bit32.band(b3.ip,0xFFFFFFFF)else y.ip=fF(b3.ip)end;if gv then gv.source=bit32.band(y.ip,y.netmask)end;if gw then gw.source=bit32.bor(bit32.band(y.ip,y.netmask),bit32.bnot(y.netmask))end;fQ[dw.uuid]=fQ[dw.uuid]or{}fQ[dw.uuid][y.ip]=os.computerID()end;if b3.netmask then if type(b3.netmask)=="number"then y.netmask=fK(b3.netmask)else y.netmask=fF(b3.netmask)end;if gv then gv.source=bit32.band(y.ip,y.netmask)end;if gw then gw.source=bit32.bor(bit32.band(y.ip,y.netmask),bit32.bnot(y.netmask))end end;if b3.up~=nil then y.up=b3.up;if y.up then hardware.call(KERNEL,dw,"open",0)else hardware.call(KERNEL,dw,"close",0)end end;if not gv then fP[0][#fP[0]+1]={source=bit32.band(y.ip,y.netmask),sourceNetmask=y.netmask,action="local",device=dw}end;if not gw then fP[0][#fP[0]+1]={source=bit32.bor(bit32.band(y.ip,y.netmask),bit32.bnot(y.netmask)),sourceNetmask=0xFFFFFFFF,action="broadcast",device=dw}end end;return{ip=fH(y.ip),netmask=fL(y.netmask),up=y.up}end;function syscalls.routelist(process,aq,b)b=expect(1,b,"number","nil")or 1;expect.range(b,0)if not fP[b]then return nil end;local a5={}for v,y in ipairs(fP[b])do a5[v]={source=fH(y.source),sourceNetmask=fL(y.sourceNetmask),action=y.action,device=y.device and hardware.path(y.device),destination=y.destination and fH(y.destination)}end;return a5 end;local gx={unicast=true,broadcast=true,["local"]=true,unreachable=true,prohibit=true,blackhole=true}function syscalls.routeadd(process,aq,bC)if process.user~="root"then error("Permission denied")end;expect(1,bC,"table")expect.field(bC,"source","string","number")expect.field(bC,"sourceNetmask","string","number")expect.field(bC,"action","string")expect.field(bC,"device","string",bC.action~="unicast"and bC.action~="broadcast"and bC.action~="local"and"nil"or nil)expect.field(bC,"destination","string",bC.action~="unicast"and"nil"or nil)expect.range(expect.field(bC,"table","number","nil")or 1,1)bC.table=bC.table or 1;if not gx[bC.action]then error("bad field 'action' (invalid option '"..bC.action.."')")end;local y={}if type(bC.source)=="number"then y.source=bit32.band(bC.source,0xFFFFFFFF)else y.source=fF(bC.source)end;if type(bC.sourceNetmask)=="number"then y.sourceNetmask=fK(bC.sourceNetmask)else y.sourceNetmask=fF(bC.sourceNetmask)end;y.source=bit32.band(y.source,y.sourceNetmask)y.action=bC.action;y.device=bC.device and fM(hardware.get(bC.device))y.destination=bC.destination and fF(bC.destination)fP[bC.table]=fP[bC.table]or{}for z,i in ipairs(fP[bC.table])do if i.source==y.source and i.sourceNetmask==y.sourceNetmask then error("Route already exists")end end;fP[bC.table][#fP[bC.table]+1]=y;fP.maxn=math.max(fP.maxn,bC.table)end;function syscalls.routedel(process,aq,gy,w,b)if process.user~="root"then error("Permission denied")end;expect(1,gy,"string","number")expect(2,w,"string","number")b=expect(3,b,"number","nil")or 1;expect.range(b,1)if type(w)=="number"then w=fK(w)else w=fF(w)end;if type(gy)=="number"then gy=bit32.band(gy,w)else gy=bit32.band(fF(gy),w)end;if not fP[b]then error("Route table does not exist")end;for v,i in ipairs(fP[b])do if i.source==gy and i.sourceNetmask==w then table.remove(fP[b],v)return end end end;function syscalls.arplist(process,aq,eR)expect(1,eR,"string")local dw=fM(hardware.get(eR))local a5={}for h,i in pairs(fQ[dw.uuid]or{})do a5[fH(h)]=i end;return a5 end;function syscalls.arpset(process,aq,eR,fG,aA)if process.user~="root"then error("Permission denied")end;expect(1,eR,"string")expect(2,fG,"string","number")expect(3,aA,"number")local dw=fM(hardware.get(eR))if type(fG)=="string"then fG=fF(fG)else fG=bit32.band(fG,0xFFFFFFFF)end;fQ[dw.uuid]=fQ[dw.uuid]or{}fQ[dw.uuid][fG]=aA end;local gz={ping=true,pong=true,unreachable=true,timeout=true}function syscalls.netcontrol(process,aq,fG,gA,o)if process.user~="root"then error("Permission denied")end;expect(1,fG,"string","number")expect(2,gA,"string")expect(3,o,"string","nil")if not gz[gA]then error("bad argument #2 (invalid option '"..gA.."')")end;if type(fG)=="string"then fG=fF(fG)else fG=bit32.band(fG,0xFFFFFFFF)end;fR.send.control({process=process},fG,gA,o)end;function syscalls.netevent(process,aq,db)if process.user~="root"then error("Permission denied")end;expect(1,db,"boolean","nil")if db==true then fU[process]=function(ae)process.eventQueue[#process.eventQueue+1]={"network_event",deepcopy(ae)}return true end elseif db==false then fU[process]=nil end;return fU[process]~=nil end;function syscalls.checkuri(process,aq,fE)end;function registerLoopback()local dw=hardware.get("/lo")if dw then fO[dw.uuid]={ip=0x7F000001,netmask=0xFF000000,up=true}fP[0][#fP[0]+1]={source=0x7F000000,sourceNetmask=0xFF000000,action="local",device=dw}fP[0][#fP[0]+1]={source=0x7FFFFFFF,sourceNetmask=0xFFFFFFFF,action="broadcast",device=dw}fQ[dw.uuid]=setmetatable({},{__index=function()return os.computerID()end})syslog.log("Configured IP for loopback device")end end;function syscalls.listmodules()local a5={}for h in pairs(modules)do a5[#a5+1]=h end;return a5 end;function syscalls.loadmodule(process,aq,bb)expect(1,bb,"string")if process.user~="root"then error("Could not load kernel module: Permission denied",2)end;local bD=filesystem.stat(process,bb)if bD.type=="directory"then error("Could not load kernel module: Is a directory",2)end;if bD.owner~="root"or bD.worldPermissions.write then error("Insecure permissions set on kernel module, refusing to load",2)end;local m=bb:match"([^%./]+)[^/]*$"syslog.log("Loading kernel module "..m.." from "..bb)local a,o=filesystem.open(process,bb,"rb")if a then local bh=a.readAll()or""a.close()local g,o=load(bh,"@"..bb)if g then local bf,u=pcall(g,bb)if bf then modules[m]=u or true else syslog.log({level="error"},"Kernel module "..m.." threw an error:",u)end else syslog.log({level="error"},"Could not load "..m..":",o)end else syslog.log({level="error"},"Could not open "..bb..":",o)end end;function syscalls.unloadmodule(process,aq,m)expect(1,m,"string")if process.user~="root"then error("Could not load kernel module: Permission denied",2)end;if type(modules[m])=="table"and modules[m].unload then modules[m].unload(process,aq)end;modules[m]=nil end;function syscalls.callmodule(process,aq,m,az,...)expect(1,m,"string")expect(2,az,"string")if not modules[m]then error("Module '"..m.."' does not exist",2)elseif type(modules[m])~="table"then error("Module '"..m.."' does not have a callable interface",2)elseif az=="unload"or type(modules[m][az])~="function"then error("Module '"..m.."' does not have a method '"..az.."'",2)end;return modules[m][az](process,aq,...)end;syslog.log("Loading kernel modules from /lib/modules")local bf,gB=pcall(filesystem.list,KERNEL,"/lib/modules")if bf then for z,i in ipairs(gB)do local E=filesystem.combine("/lib/modules",i)local bD=filesystem.stat(KERNEL,E)if bD.type~="directory"then local bf,o=pcall(syscalls.loadmodule,KERNEL,nil,E)if not bf then syslog.log({level="error"},"Could not load module from "..E..": "..o)end end end else syslog.log({level="notice"},"Could not open /lib/modules:",gB)end;xpcall(hardware.register,function(error)panic("An error occurred while registering devices: "..error)end,deviceTreeRoot,rootDriver)local ap={n=0}local gC=processes[syscalls.fork(KERNEL,nil,function()end,"init")]local gD=gC.id;local gE,gF;if args.init then gE,gF=pcall(syscalls.exec,gC,nil,args.initrd and"/init"or args.init)end;if not gE then syslog.log({level="error",process=0},"Could not load init:",gF)syslog.log("Could not find provided init, trying default locations")for z,i in ipairs{"/sbin/init","/etc/init","/bin/init","/bin/sh"}do syslog.log("Trying",i)gE,gF=pcall(syscalls.exec,gC,nil,i)if not gE then syslog.log({level="error",process=0},"Could not load init:",gF)end;if gE then break end end;if not gE then panic("No working init found")end end;syslog.log("Starting init from "..processes[gD].name)local at=false;local gG=coroutine.yield;function coroutine.yield(...)if coroutine.running()==mainThread then error("attempt to yield from kernel main thread",2)end;return gG(...)end;debug.protect(coroutine.yield)eventHooks.key=eventHooks.key or{}eventHooks.key[#eventHooks.key+1]=function(ar)if keysHeld.ctrl and keysHeld.shift and ar[2]==keys.f10 then term.clear()term.setCursorPos(1,1)term.write("Entering debug console.")local q=2;local aW=true;term.setCursorPos(1,q)while aW do local aj=""local af,ag=term.getSize()term.write("lua> ")term.setCursorBlink(true)while true do local ar={gG()}if ar[1]=="char"or ar[1]=="paste"then aj=aj..ar[2]term.write(ar[2])elseif ar[1]=="key"then if ar[2]==keys.backspace and#aj>0 then aj=aj:sub(1,-2)term.setCursorPos(term.getCursorPos()-1,q)term.write(" ")term.setCursorPos(term.getCursorPos()-1,q)elseif ar[2]==keys.enter then break end end end;q=q+1;if q>ag then q=q-1;term.scroll(1)end;term.setCursorPos(1,q)local g,o=load("return "..aj,"=lua","t",setmetatable({exit=function()aW=false end},{__index=_G}))if not g then g,o=load(aj,"=lua","t",setmetatable({exit=function()aW=false end},{__index=_G}))end;if g then local u=table.pack(pcall(g))if u[1]then for v=2,u.n do term.write(tostring(u[v]))q=q+1;if q>ag then q=q-1;term.scroll(1)end;term.setCursorPos(1,q)end else term.setTextColor(16384)term.write(u[2])term.setTextColor(1)q=q+1;if q>ag then q=q-1;term.scroll(1)end;term.setCursorPos(1,q)end else term.setTextColor(16384)term.write(o)term.setTextColor(1)q=q+1;if q>ag then q=q-1;term.scroll(1)end;term.setCursorPos(1,q)end end;term.setCursorBlink(false)term.clear()terminal.redraw(currentTTY,true)end end;local gH={char=true,key=true,key_up=true,mouse_click=true,mouse_up=true,mouse_drag=true,mouse_scroll=true,paste=true}local bf,o=xpcall(function()while processes[gD]do if not at then os.queueEvent("__event_queue_back")end;while true do local ar=table.pack(gG())local m=ar[1]if m=="__event_queue_back"then break end;local gI=false;if eventHooks[m]then for z,i in ipairs(eventHooks[m])do gI=i(ar)or gI end end;if eventParameterMap[m]then local av={}for v=2,#eventParameterMap[m]+1 do av[eventParameterMap[m][v-1]]=ar[v]end;if m=="key"or m=="key_up"then av.keycode=keymap[av.keycode]av.ctrlHeld=keysHeld.ctrl;av.altHeld=keysHeld.alt;av.shiftHeld=keysHeld.shift end;if gH[m]and currentTTY.frontmostProcess then currentTTY.frontmostProcess.eventQueue[#currentTTY.frontmostProcess.eventQueue+1]={m,av}gI=true elseif m=="timer"or m=="alarm"then local gJ;if m=="timer"then gJ=timerMap[ar[2]]else gJ,av.id=alarmMap[ar[2]],bit32.bor(av.id,0x80000000)end;if gJ then gJ.eventQueue[#gJ.eventQueue+1],gI={m,av},true end end end;if at and gI then break end end;at=true;for cM,process in pairs(processes)do if cM~=0 and not process.paused then local fh,ar=false,nil;local as=true;for fi,aq in pairs(process.threads)do if not fh and aq.status=="suspended"then ar=table.remove(process.eventQueue,1)fh=true end;if ar or aq.status~="suspended"then local gK;as,gK=executeThread(process,aq,ar or ap,as,at)at=gK and at else as=false end end;if as then process.isDead=true;if process.lastReturnValue then if cM==gD then init_retval=process.lastReturnValue.value or process.lastReturnValue.error elseif processes[process.parent]then process.lastReturnValue.id=cM;processes[process.parent].eventQueue[#processes[process.parent].eventQueue+1]={"process_complete",process.lastReturnValue}end end;reap_process(process)processes[cM]=nil;at=false end end end;terminal.redraw(currentTTY)end end,debug.traceback)if not bf then syslog.log({level="critical",traceback=true},o)end;if postkill then postkill()end;if init_retval~=nil then syslog.log({level=4},"init exited with result",init_retval)end;panic("init program exited")
