PHOENIX_VERSION="0.0.4"PHOENIX_BUILD="PRERELEASE NONFREE Sat Jul  1 20:43:40 2023"systemStartTime=os.epoch"utc"args={init="/sbin/init.lua",root="/root",rootfstype="craftos",preemptive=true,quantum=2000000,splitkernpath="/boot/kernel.lua.d",loglevel=1,console="tty1",traceback=true}syscalls={}processes={[0]={name="kernel",id=0,user="root",dir="/",root="/",env=_G,vars={},dependents={}}}KERNEL=processes[0]modules={}eventHooks={}shutdownHooks={}kSyscallYield={}process={}filesystem={}terminal={}user={}syslog={}hardware={}if discord then discord("Phoenix","Booting Phoenix "..PHOENIX_VERSION)end;do local a=fs.open("/rom/modules/main/cc/expect.lua","r")expect=(loadstring or load)(a.readAll(),"@/rom/modules/main/cc/expect.lua")()a.close()setmetatable(expect,{__call=function(self,...)return self.expect(...)end})if not expect.range then function expect.range(b,c,d)expect(1,b,"number")expect(2,c,"number","nil")expect(3,d,"number","nil")if d<c then error("bad argument #3 (min must be less than or equal to max)",2)end;if b~=b or b<(c or-math.huge)or b>(d or math.huge)then error(("number outside of range (expected %s to be within %s and %s)"):format(b,c or-math.huge,d or math.huge),3)end;return b end end end;do local a=fs.open("/rom/apis/textutils.lua","r")local e=setmetatable({dofile=function()return expect end},{__index=_G})local g;if loadstring and setfenv then g=loadstring(a.readAll(),"@/rom/apis/textutils.lua")setfenv(g,e)else g=load(a.readAll(),"@/rom/apis/textutils.lua","t",e)end;a.close()g()serialize,unserialize=e.serialize,e.unserialize end;do local a=fs.open("/rom/apis/keys.lua","r")local e=setmetatable({dofile=function()return expect end},{__index=_G})if _VERSION<"Lua 5.2"then e._ENV=e end;local g;if loadstring and setfenv then g=loadstring(a.readAll(),"@/rom/apis/keys.lua")setfenv(g,e)else g=load(a.readAll(),"@/rom/apis/keys.lua","t",e)end;a.close()g()keys={}for h,i in pairs(e)do keys[h]=i end end;if not pcall(load,"return","=test","t",{})then local j,k,expect,setfenv=load,loadstring,expect,setfenv;function load(l,m,n,e)expect(1,l,"string","function")expect(2,m,"string","nil")expect(3,n,"string","nil")expect(4,e,"table","nil")if type(l)=="string"then if l:sub(1,4)=="\27Lua"then if n==nil or n:find"b"then local g,o=k(l,m)if g and e then setfenv(g,e)end;return g,o else return nil,"attempt to load a binary chunk (mode is '"..(n or"bt").."')"end else if n==nil or n:find"t"then local g,o=k(l,m)if g and e then setfenv(g,e)end;return g,o else return nil,"attempt to load a text chunk (mode is '"..(n or"bt").."')"end end else local g,o=j(l,m)if g then setfenv(g,e)end;return g,o end end end;loadstring=nil;if bit then if not bit32 then local bit=bit;bit32={bnot=bit.bnot,lshift=bit.blshift,rshift=bit.blogic_rshift,arshift=bit.brshift}function bit32.band(p,q,...)expect(1,p,"number")expect(2,q,"number","nil")if not q then return p end;return bit32.band(bit.band(p,q),...)end;function bit32.bor(p,q,...)expect(1,p,"number")expect(2,q,"number","nil")if not q then return p end;return bit32.bor(bit.bor(p,q),...)end;function bit32.bxor(p,q,...)expect(1,p,"number")expect(2,q,"number","nil")if not q then return p end;return bit32.bxor(bit.bxor(p,q),...)end;function bit32.btest(...)return bit32.band(...)~=0 end;function bit32.extract(r,s,u)expect(1,r,"number")expect(2,s,"number")expect(3,u,"number","nil")(expect.range or function()end)(s,0,31)(expect.range or function()end)(s+u-1,0,31)u=u or 1;local v=0;for w=s+u-1,s,-1 do v=v*2+bit.band(r,2^w)/2^w end;return v end;function bit32.replace(r,i,s,u)expect(1,r,"number")expect(2,i,"number")expect(3,s,"number")expect(4,u,"number","nil")(expect.range or function()end)(s,0,31)(expect.range or function()end)(s+u-1,0,31)u=u or 1;local x=2^u-1;return bit.bor(bit.band(r,bit.bnot(bit.blshift(x,s))),bit.blshift(bit.band(i,x),s))end;function bit32.lrotate(p,y)return bit.bor(bit.blshift(p,y),bit.blogic_rshift(p,32-y))end;function bit32.rrotate(p,y)return bit.bor(bit.blogic_rshift(p,y),bit.blshift(p,32-y))end end;bit=nil end;if _VERSION=="Lua 5.1"then if not table.pack then table.pack=function(...)local t={...}t.n=select("#",...)return t end end;if not table.unpack then table.unpack,unpack=unpack,nil end;local z,i=xpcall(function(A)return A end,nil,true)if not i then local B=xpcall;xpcall=function(f,C,...)if select("#",...)>0 then local args=table.pack(...)return B(function()return f(table.unpack(args,1,args.n))end,C)else return B(f,C)end end end end;if tonumber(_HOST:match"ComputerCraft 1.(%d+)")<95 then local D=fs.combine;function fs.combine(E,...)if...~=nil then return D(E,fs.combine(...))else return E end end end;if not string.pack then local F={BIG_ENDIAN=1,LITTLE_ENDIAN=2}local G={b=1,B=1,h=1,H=1,l=1,L=1,j=1,J=1,T=1}local H={b=1,B=1,x=1,h=2,H=2,f=4,j=4,J=4,l=8,L=8,T=8,d=8,n=8}local function I(r)if r%1>=0.5 then return math.ceil(r)else return math.floor(r)end end;local function J(f)if f==0 then return 0 elseif f==-0 then return 0x80000000 elseif f==math.huge then return 0x7F800000 elseif f==-math.huge then return 0xFF800000 end;local A,K=math.frexp(f)if K>127 or K<-126 then error("number out of range",3)end;K,A=K+126,I((math.abs(A)-0.5)*0x1000000)if A>0x7FFFFF then K=K+1 end;return bit32.bor(f<0 and 0x80000000 or 0,bit32.lshift(bit32.band(K,0xFF),23),bit32.band(A,0x7FFFFF))end;local function L(f)if f==0 then return 0,0 elseif f==-0 then return 0x80000000,0 elseif f==math.huge then return 0x7FF00000,0 elseif f==-math.huge then return 0xFFF00000,0 end;local A,K=math.frexp(f)if K>1023 or K<-1022 then error("number out of range",3)end;K,A=K+1022,I((math.abs(A)-0.5)*0x20000000000000)if A>0xFFFFFFFFFFFFF then K=K+1 end;return bit32.bor(f<0 and 0x80000000 or 0,bit32.lshift(bit32.band(K,0x7FF),20),bit32.band(A/0x100000000,0xFFFFF)),bit32.band(A,0xFFFFFFFF)end;local function M(N)if N==0 then return 0 elseif N==0x80000000 then return-0 elseif N==0x7F800000 then return math.huge elseif N==0xFF800000 then return-math.huge end;local A,K=bit32.band(N,0x7FFFFF),bit32.band(bit32.rshift(N,23),0xFF)K,A=K-126,A/0x1000000+0.5;local r=math.ldexp(A,K)return bit32.btest(N,0x80000000)and-r or r end;local function O(P,Q)if P==0 and Q==0 then return 0 elseif P==0x80000000 and Q==0 then return-0 elseif P==0x7FF00000 and Q==0 then return math.huge elseif P==0xFFF00000 and Q==0 then return-math.huge end;local A,K=bit32.band(P,0xFFFFF)*0x100000000+bit32.band(Q,0xFFFFFFFF),bit32.band(bit32.rshift(P,20),0x7FF)K,A=K-1022,A/0x20000000000000+0.5;local r=math.ldexp(A,K)return bit32.btest(P,0x80000000)and-r or r end;local function R(b,S,T,U,V,W,X)local Y=0;if U%math.min(S,V)~=0 and V>1 then local w=0;while U%math.min(S,V)~=0 and w<V do T[U]=0;U=U+1;Y=Y+1;w=w+1 end end;if W==F.BIG_ENDIAN then local Z=0;if S>8 then for w=0,S-9 do T[U+w]=X and b>=2^(S*8-1)~=0 and 0xFF or 0;Z=Z+1;Y=Y+1 end end;for w=Z,S-1 do T[U+w]=bit32.band(bit32.rshift(b,(S-w-1)*8),0xFF)Y=Y+1 end else for w=0,math.min(S,8)-1 do T[U+w]=b/2^(w*8)%256;Y=Y+1 end;for w=8,S-1 do T[U+w]=X and b>=2^(S*8-1)~=0 and 0xFF or 0;Y=Y+1 end end;return Y end;local function _(a0,U,S,W,V,X)local a1,a2=0,0;if U%math.min(S,V)~=0 and V>1 then for w=0,V-1 do if U%math.min(S,V)==0 then break end;U=U+1;a2=a2+1 end end;for w=0,S-1 do a1=a1+a0:byte(U+w)*2^((W==F.BIG_ENDIAN and S-w-1 or w)*8)a2=a2+1 end;if X and a1>=2^(S*8-1)then a1=a1-2^(S*8)end;return a1,a2 end;local function a3(a4,V)local a5=H[a4]or 0;if V>1 and a5%V~=0 then a5=a5+V-a5%V end;return a5 end;function string.pack(...)local a6=expect(1,...,"string")local W=F.LITTLE_ENDIAN;local V=1;local a7=1;local a8=2;local T={}local w=1;while w<=#a6 do local a9=a6:sub(w,w)w=w+1;if a9=='='or a9=='<'then W=F.LITTLE_ENDIAN elseif a9=='>'then W=F.BIG_ENDIAN elseif a9=='!'then local S=-1;while w<=#a6 and a6:sub(w,w):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=math.max(S,0)*10+tonumber(a6:sub(w,w))w=w+1 end;if S>16 or S==0 then error(string.format("integral size (%d) out of limits [1,16]",S),2)elseif S==-1 then V=4 else V=S end elseif G[a9]then local b=expect(a8,select(a8,...),"number")a8=a8+1;if b>=math.pow(2,a3(a9,0)*8-(a9:match("%l")and 1 or 0))or b<(a9:match("%l")and-math.pow(2,a3(a9,0)*8-1)or 0)then error(string.format("bad argument #%d to 'pack' (integer overflow)",a8-1),2)end;a7=a7+R(b,a3(a9,0),T,a7,V,W,false)elseif a9:lower()=='i'then local X=a9=='i'local S=-1;while w<=#a6 and a6:sub(w,w):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=math.max(S,0)*10+tonumber(a6:sub(w,w))w=w+1 end;if S>16 or S==0 then error(string.format("integral size (%d) out of limits [1,16]",S),2)elseif V>1 and(S~=1 and S~=2 and S~=4 and S~=8 and S~=16)then error("bad argument #1 to 'pack' (format asks for alignment not power of 2)",2)elseif S==-1 then S=4 end;local b=expect(a8,select(a8,...),"number")a8=a8+1;if b>=math.pow(2,S*8-(a9:match("%l")and 1 or 0))or b<(a9:match("%l")and-math.pow(2,S*8-1)or 0)then error(string.format("bad argument #%d to 'pack' (integer overflow)",a8-1),2)end;a7=a7+R(b,S,T,a7,V,W,X)elseif a9=='f'then local f=expect(a8,select(a8,...),"number")a8=a8+1;local N=J(f)if a7%math.min(4,V)~=0 and V>1 then for aa=0,V-1 do if a7%math.min(4,V)==0 then break end;T[a7]=0;a7=a7+1 end end;for aa=0,3 do T[a7+(W==F.BIG_ENDIAN and 3-aa or aa)]=bit32.band(bit32.rshift(N,aa*8),0xFF)end;a7=a7+4 elseif a9=='d'or a9=='n'then local f=expect(a8,select(a8,...),"number")a8=a8+1;local P,Q=L(f)if a7%math.min(8,V)~=0 and V>1 then for aa=0,V-1 do if a7%math.min(8,V)==0 then break end;T[a7]=0;a7=a7+1 end end;for aa=0,3 do T[a7+(W==F.BIG_ENDIAN and 7-aa or aa)]=bit32.band(bit32.rshift(Q,aa*8),0xFF)end;for aa=4,7 do T[a7+(W==F.BIG_ENDIAN and 7-aa or aa)]=bit32.band(bit32.rshift(P,(aa-4)*8),0xFF)end;a7=a7+8 elseif a9=='c'then local S=0;if w>#a6 or not a6:sub(w,w):match("%d")then error("missing size for format option 'c'",2)end;while w<=#a6 and a6:sub(w,w):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(w,w))w=w+1 end;if a7+S<a7 or a7+S>0xFFFFFFFF then error("bad argument #1 to 'pack' (format result too large)",2)end;local a0=expect(a8,select(a8,...),"string")a8=a8+1;if#a0>S then error(string.format("bad argument #%d to 'pack' (string longer than given size)",a8-1),2)end;if S>0 then for aa=0,S-1 do T[a7+aa]=a0:byte(aa+1)or 0 end;a7=a7+S end elseif a9=='z'then local a0=expect(a8,select(a8,...),"string")a8=a8+1;for ab in a0:gmatch"."do if ab=='\0'then error(string.format("bad argument #%d to 'pack' (string contains zeros)",a8-1),2)end end;for aa=0,#a0-1 do T[a7+aa]=a0:byte(aa+1)end;T[a7+#a0]=0;a7=a7+#a0+1 elseif a9=='s'then local S=0;while w<=#a6 and a6:sub(w,w):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(w,w))w=w+1 end;if S>16 then error(string.format("integral size (%d) out of limits [1,16]",S),2)elseif S==0 then S=4 end;local a0=expect(a8,select(a8,...),"string")a8=a8+1;if#a0>=math.pow(2,S*8)then error(string.format("bad argument #%d to 'pack' (string length does not fit in given size)",a8-1),2)end;R(#a0,S,T,a7,1,W,false)for aa=S,#a0+S-1 do T[a7+aa]=a0:byte(aa-S+1)or 0 end;a7=a7+#a0+S elseif a9=='x'then T[a7]=0;a7=a7+1 elseif a9=='X'then if w>=#a6 then error("invalid next option for option 'X'",2)end;local S=0;local a9=a6:sub(w,w)w=w+1;if a9:lower()=='i'then while w<=#a6 and a6:sub(w,w):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(w,w))w=w+1 end;if S>16 or S==0 then error(string.format("integral size (%d) out of limits [1,16]",S),2)end else S=a3(a9,0)end;if S<1 then error("invalid next option for option 'X'",2)end;if a7%math.min(S,V)~=0 and V>1 then for aa=1,V do if a7%math.min(S,V)==0 then break end;T[a7]=0;a7=a7+1 end end elseif a9~=' 'then error(string.format("invalid format option '%s'",a9),2)end end;return string.char(table.unpack(T))end;function string.packsize(a6)local a7=0;local V=1;local w=1;while w<=#a6 do local a9=a6:sub(w,w)w=w+1;if a9=='!'then local S=0;while w<=#a6 and a6:sub(w,w):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(w,w))w=w+1 end;if S>16 then error(string.format("integral size (%d) out of limits [1,16]",S),2)elseif S==0 then V=4 else V=S end elseif G[a9]then local S=a3(a9,0)if a7%math.min(S,V)~=0 and V>1 then for aa=1,V do if a7%math.min(S,V)==0 then break end;a7=a7+1 end end;a7=a7+S elseif a9:lower()=='i'then local S=0;while w<=#a6 and a6:sub(w,w):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(w,w))w=w+1 end;if S>16 then error(string.format("integral size (%d) out of limits [1,16]",S))elseif V>1 and(S~=1 and S~=2 and S~=4 and S~=8 and S~=16)then error("bad argument #1 to 'pack' (format asks for alignment not power of 2)",2)elseif S==0 then S=4 end;if a7%math.min(S,V)~=0 and V>1 then for aa=1,V do if a7%math.min(S,V)==0 then break end;a7=a7+1 end end;a7=a7+S elseif a9=='f'then if a7%math.min(4,V)~=0 and V>1 then for aa=1,V do if a7%math.min(4,V)==0 then break end;a7=a7+1 end end;a7=a7+4 elseif a9=='d'or a9=='n'then if a7%math.min(8,V)~=0 and V>1 then for aa=1,V do if a7%math.min(8,V)==0 then break end;a7=a7+1 end end;a7=a7+8 elseif a9=='c'then local S=0;if w>#a6 or not a6:sub(w,w):match("%d")then error("missing size for format option 'c'",2)end;while w<=#a6 and a6:sub(w,w):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(w,w))w=w+1 end;if a7+S<a7 or a7+S>0x7FFFFFFF then error("bad argument #1 to 'packsize' (format result too large)",2)end;a7=a7+S elseif a9=='x'then a7=a7+1 elseif a9=='X'then if w>=#a6 then error("invalid next option for option 'X'",2)end;local S=0;local a9=a6:sub(w,w)w=w+1;if a9:lower()=='i'then while w<=#a6 and a6:sub(w,w):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(w,w))w=w+1 end;if S>16 or S==0 then error(string.format("integral size (%d) out of limits [1,16]",S),2)end else S=a3(a9,0)end;if S<1 then error("invalid next option for option 'X'",2)end;if a7%math.min(S,V)~=0 and V>1 then for aa=1,V do if a7%math.min(S,V)==0 then break end;a7=a7+1 end end elseif a9=='s'or a9=='z'then error("bad argument #1 to 'packsize' (variable-length format)",2)elseif a9~=' 'and a9~='<'and a9~='>'and a9~='='then error(string.format("invalid format option '%s'",a9),2)end end;return a7 end;function string.unpack(a6,a0,a7)expect(1,a6,"string")expect(2,a0,"string")expect(3,a7,"number","nil")if a7 then if a7<0 then a7=#a0+a7 elseif a7==0 then error("bad argument #3 to 'unpack' (initial position out of string)",2)end;if a7>#a0 or a7<0 then error("bad argument #3 to 'unpack' (initial position out of string)",2)end else a7=1 end;local W=F.LITTLE_ENDIAN;local V=1;local a5={}local w=1;while w<=#a6 do local a9=a6:sub(w,w)w=w+1;if a9=='<'or a9=='='then W=F.LITTLE_ENDIAN elseif a9=='>'then W=F.BIG_ENDIAN elseif a9=='!'then local S=0;while w<=#a6 and a6:sub(w,w):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(w,w))w=w+1 end;if S>16 then error(string.format("integral size (%d) out of limits [1,16]",S))elseif S==0 then V=4 else V=S end elseif G[a9]then if a7+a3(a9,0)>#a0+1 then error("data string too short",2)end;local v,ac=_(a0,a7,a3(a9,0),W,V,a9:match("%l")~=nil)a5[#a5+1]=v;a7=a7+ac elseif a9:lower()=='i'then local X=a9=='i'local S=0;while w<=#a6 and a6:sub(w,w):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(w,w))w=w+1 end;if S>16 then error(string.format("integral size (%d) out of limits [1,16]",S),2)elseif S>8 then error(string.format("%d-byte integer does not fit into Lua Integer",S),2)elseif S==0 then S=4 end;if a7+S>#a0+1 then error("data string too short",2)end;local v,ac=_(a0,a7,S,W,V,X)a5[#a5+1]=v;a7=a7+ac elseif a9=='f'then if a7%math.min(4,V)~=0 and V>1 then for aa=1,V do if a7%math.min(4,V)==0 then break end;a7=a7+1 end end;if a7+4>#a0+1 then error("data string too short",2)end;local v=_(a0,a7,4,W,V,false)a5[#a5+1]=M(v)a7=a7+4 elseif a9=='d'or a9=='n'then if a7%math.min(8,V)~=0 and V>1 then for aa=1,V do if a7%math.min(8,V)==0 then break end;a7=a7+1 end end;if a7+8>#a0+1 then error("data string too short",2)end;local P,Q=0,0;for aa=0,3 do P=bit32.bor(P,bit32.lshift(a0:byte(a7+aa),(W==F.BIG_ENDIAN and 3-aa or aa)*8))end;for aa=0,3 do Q=bit32.bor(Q,bit32.lshift(a0:byte(a7+aa+4),(W==F.BIG_ENDIAN and 3-aa or aa)*8))end;if W==F.LITTLE_ENDIAN then P,Q=Q,P end;a5[#a5+1]=O(P,Q)a7=a7+8 elseif a9=='c'then local S=0;if w>#a6 or not a6:sub(w,w):match("%d")then error("missing size for format option 'c'",2)end;while w<=#a6 and a6:sub(w,w):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)")end;S=S*10+tonumber(a6:sub(w,w))w=w+1 end;if a7+S>#a0+1 then error("data string too short",2)end;a5[#a5+1]=a0:sub(a7,a7+S-1)a7=a7+S elseif a9=='z'then local S=0;while a0:byte(a7+S)~=0 do S=S+1;if a7+S>#a0 then error("unfinished string for format 'z'",2)end end;a5[#a5+1]=a0:sub(a7,a7+S-1)a7=a7+S+1 elseif a9=='s'then local S=0;while w<=#a6 and a6:sub(w,w):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(w,w))w=w+1 end;if S>16 then error(string.format("integral size (%d) out of limits [1,16]",S),2)elseif S==0 then S=4 end;if a7+S>#a0+1 then error("data string too short",2)end;local b,ad=_(a0,a7,S,W,V,false)a7=a7+ad;if a7+b>#a0+1 then error("data string too short",2)end;a5[#a5+1]=a0:sub(a7,a7+b-1)a7=a7+b elseif a9=='x'then a7=a7+1 elseif a9=='X'then if w>=#a6 then error("invalid next option for option 'X'",2)end;local S=0;local a9=a6:sub(w,w)w=w+1;if a9:lower()=='i'then while w<=#a6 and a6:sub(w,w):match("%d")do if S>=0xFFFFFFFF/10 then error("bad argument #1 to 'pack' (invalid format)",2)end;S=S*10+tonumber(a6:sub(w,w))w=w+1 end;if S>16 or S==0 then error(string.format("integral size (%d) out of limits [1,16]",S),2)elseif S==-1 then S=4 end else S=a3(a9,0)end;if S<1 then error("invalid next option for option 'X'",2)end;if a7%math.min(S,V)~=0 and V>1 then for aa=1,V do if a7%math.min(S,V)==0 then break end;a7=a7+1 end end elseif a9~=' 'then error(string.format("invalid format option '%s'",a9),2)end end;a5[#a5+1]=a7;return table.unpack(a5)end end;if debug then local ae=setmetatable({},{__index=coroutine,__newindex=function()end,__metatable=false})debug.setmetatable(coroutine.running(),{__index=ae,__call=coroutine.resume})end;function panic(af)term.setBackgroundColor(32768)term.setTextColor(16384)term.setCursorBlink(false)local p,q=term.getCursorPos()p=1;local ag,ah=term.getSize()af="panic: "..(af or"unknown")for ai in af:gmatch"%S+"do if p+#ai>=ag then p,q=1,q+1;if q>ah then term.scroll(1)q=q-1 end end;term.setCursorPos(p,q)if p==1 then term.clearLine()end;term.write(ai.." ")p=p+#ai+1 end;p,q=1,q+1;if q>ah then term.scroll(1)q=q-1 end;if debug then local aj=debug.traceback(nil,2)for ak in aj:gmatch"[^\n]+"do term.setCursorPos(1,q)term.write(ak)q=q+1;if q>ah then term.scroll(1)q=q-1 end end end;term.setCursorPos(1,q)term.setTextColor(2)term.write("panic: We are hanging here...")while true do coroutine.yield()end end;function do_syscall(al,...)local v=table.pack(coroutine.yield("syscall",al,...))if v[1]then return table.unpack(v,2,v.n)else error(v[2],3)end end;function deepcopy(am)if type(am)=="table"then local a5=setmetatable({},deepcopy(getmetatable(am)))for h,i in pairs(am)do a5[deepcopy(h)]=deepcopy(i)end;return a5 else return am end end;function split(a0,an)local t={}for ao in a0:gmatch("[^"..(an or"%s").."]+")do t[#t+1]=ao end;return t end;local ap=pcall(os.epoch,"nano")and function()return os.epoch"nano"/1000000 end or(ccemux and function()return ccemux.nanoTime()/1000000 end or function()return os.epoch"utc"end)local aq={n=0}function executeThread(process,ar,as,at,au)local args;if ar.status=="starting"then args=ar.args elseif ar.status=="syscall"then args=ar.syscall_return elseif ar.status=="preempt"then args=aq elseif ar.status=="suspended"then args={as[1],deepcopy(as[2])}end;if ar.status~="dead"and(not ar.filter or ar.filter(process,ar,as))then local av=at;at=false;ar.filter=nil;local aw;if ar.yielding then aw={n=ar.syscall_return.n,true,"syscall",ar.yielding,table.unpack(ar.syscall_return,4,ar.syscall_return.n)}ar.yielding=nil else local ax=ap()aw=table.pack(coroutine.resume(ar.coro,table.unpack(args,1,args.n)))process.cputime=process.cputime+(ap()-ax)/1000 end;if aw[2]=="syscall"then ar.status="syscall"local ay=au;au=false;if aw[3]and syscalls[aw[3]]then local ax=ap()ar.syscall_return=table.pack(xpcall(syscalls[aw[3]],debug.traceback,process,ar,table.unpack(aw,4,aw.n)))process.systime=process.systime+(ap()-ax)/1000;if not ar.syscall_return[1]and type(ar.syscall_return[2])=="string"then syslog.log({level="debug",category="Syscall Failure",process=0,module=aw[3]},ar.syscall_return[2])ar.syscall_return[2]=ar.syscall_return[2]:gsub("kernel:%d+: ","")end;if ar.syscall_return[2]==kSyscallYield then ar.yielding=ar.syscall_return[3]au=ay end else ar.syscall_return={false,"No such syscall",n=2}end elseif aw[2]=="preempt"then ar.status="preempt"au=false elseif coroutine.status(ar.coro)=="dead"then ar.status="dead"ar.return_value=aw[2]if aw[1]then process.lastReturnValue={pid=process.id,thread=ar.id,value=aw[2],n=aw.n-1,table.unpack(aw,2,aw.n)}else process.lastReturnValue={pid=process.id,thread=ar.id,error=aw[2],traceback=debug.traceback(ar.coro)}end;if not aw[1]then ar.did_error=true;syslog.log({level=_G.args.traceback and"error"or"debug",process=process.id,thread=ar.id,category="Application Error",traceback=true},debug.traceback(ar.coro,aw[2]))if aw[2]and process.stderr and process.stderr.isTTY then terminal.write(process.stderr,aw[2].."\n")end end;process.threads[ar.id]=nil;at=av else ar.status="suspended"au=au and#process.eventQueue==0 end end;return at,au end;function userModeCallback(process,az,...)local ar={id=-1,name="<user mode callback>",coro=coroutine.create(az),status="starting",args=table.pack(...),filter=nil}pcall(setfenv,az,process.env)local at=false;while not at do at=executeThread(process,ar,aq,true,false)if ar.status=="suspended"then return false,"attempt to yield from a user mode callback"end end;return not ar.did_error,ar.return_value end;function make_ENV(e)if type(e)~="table"or _VERSION~="Lua 5.1"then return e end;repeat local aA=getmetatable(e)if aA and aA.__env then e=aA.__env end until not aA or not aA.__env;local t=setmetatable({},{__index=function(self,aB)if self==e then e=getmetatable(self).__env end;if aB=="_ENV"then return e else return e[aB]end end,__newindex=function(self,aB,aC)if self==e then e=getmetatable(self).__env end;if aB=="_ENV"then e=aC else e[aB]=aC end end,__pairs=function(self)if self==e then e=getmetatable(self).__env end;return next,e end,__len=function(self)if self==e then e=getmetatable(self).__env end;return#e end,__env=e})return t end;for z,i in ipairs({...})do local aD,aE=i:match("^([^=]+)=(.+)$")if aD and aE then if type(args[aD])=="boolean"then args[aD]=aE:lower()=="true"or aE=="1"elseif type(args[aD])=="number"then args[aD]=tonumber(aE)else args[aD]=aE end elseif aD=="silent"then args.loglevel=5 end end;local function aF(aG)local v;if _CC_VERSION then v=aG<=_CC_VERSION elseif not _HOST then v=aG<=os.version():gsub("CraftOS ","")elseif _HOST:match("ComputerCraft 1%.1%d+")~=aG:match("1%.1%d+")then aG=aG:gsub("(1%.)([02-9])","%10%2")local aH=_HOST:gsub("(ComputerCraft 1%.)([02-9])","%10%2")v=aG<=aH:match("ComputerCraft ([0-9%.]+)")else v=aG<=_HOST:match("ComputerCraft ([0-9%.]+)")end;return v end;if not aF"1.87.0"then panic("Phoenix requires ComputerCraft 1.87.0 or later. Please upgrade your version of ComputerCraft.")end;if jit and args.preemptive then panic("Phoenix does not support preemption when running under LuaJIT. Please set preemptive to false in the kernel arguments.")end;if not debug and args.preemptive then panic("Phoenix does not support preemption without the debug API. Please set preemptive to false in the kernel arguments.")end;if args.preemptive then PHOENIX_BUILD=PHOENIX_BUILD.." PREEMPT"end;if not getfenv then if not debug then panic("Phoenix requires the debug API when running under Lua 5.2 and later.")end;function getfenv(g)local w=1;while true do local m,aC=debug.getupvalue(g,w)if m=="_ENV"then return aC elseif not m then break end;w=w+1 end end;function setfenv(g,e)local w=1;while true do local m=debug.getupvalue(g,w)if m=="_ENV"then debug.upvaluejoin(g,w,function()return e end,1)break elseif not m then break end;w=w+1 end;return g end end;do local aI;local aJ,aK,aL,aM,aN,aO,aP,aQ,aR=getfenv,setfenv,debug.getfenv,debug.getlocal,debug.getupvalue,debug.setfenv,debug.setlocal,debug.setupvalue,debug.upvaluejoin;local error,aS,aT,select,setmetatable,type,tonumber=error,debug.getinfo,coroutine.running,select,setmetatable,type,tonumber;local aU;local function keys(t,i,...)if i then t[i]=true end;if select("#",...)>0 then return keys(t,...)else return t end end;local function aV(i,...)if select("#",...)>0 then return aU[i or""]or i,aV(...)else return aU[i or""]or i end end;function debug.getinfo(ar,az,aW)if type(ar)~="thread"then aW,az,ar=az,ar,aT()end;local a5;if tonumber(az)then a5=aS(ar,az+1,aW)else a5=aS(ar,az,aW)end;if a5 and a5.func then a5.func=aU[a5.func]or a5.func end;return a5 end;function debug.getlocal(ar,aX,aY)if aY==nil then aY,aX,ar=aX,ar,aT()end;local h,i;if type(aX)=="function"then local aZ=aS(2,"f")if aI[aX]and not(aZ and aI[aX][aZ.func])then return nil end;h,i=aV(aM(aX,aY))elseif tonumber(aX)then local a_=aS(ar,aX+1,"f")local aZ=aS(2,"f")if a_ and aI[a_.func]and not(aZ and aI[a_.func][aZ.func])then return nil end;h,i=aV(aM(ar,aX+1,aY))else h,i=aV(aM(ar,aX,aY))end;return h,i end;function debug.getupvalue(az,b0)if type(az)=="function"then local aZ=aS(2,"f")if aI[az]and not(aZ and aI[az][aZ.func])then return nil end end;local h,i=aV(aN(az,b0))return h,i end;function debug.setlocal(ar,aX,aY,aE)if aY==nil then aY,aX,ar=aX,ar,aT()end;if tonumber(aX)then local a_=aS(ar,aX+1,"f")local aZ=aS(2,"f")if a_ and aI[a_.func]and not(aZ and aI[a_.func][aZ.func])then error("attempt to set local of protected function",2)end;aP(ar,aX+1,aY,aE)else aP(ar,aX,aY,aE)end end;function debug.setupvalue(az,b0,aE)if type(az)=="function"then local aZ=aS(2,"f")if aI[az]and not(aZ and aI[az][aZ.func])then error("attempt to set upvalue of protected function",2)end end;aQ(az,b0,aE)end;function _G.getfenv(f)local i;if f==nil then i=aJ(2)elseif tonumber(f)and tonumber(f)>0 then local a_=aS(f+1,"f")local aZ=aS(2,"f")if a_ and aI[a_.func]and not(aZ and aI[a_.func][aZ.func])then return nil end;i=aJ(f+1)elseif type(f)=="function"then local aZ=aS(2,"f")if aI[f]and not(aZ and aI[f][aZ.func])then return nil end;i=aJ(f)else i=aJ(f)end;return i end;function _G.setfenv(f,am)if tonumber(f)then local a_=aS(f+1,"f")local aZ=aS(2,"f")if a_ and aI[a_.func]and not(aZ and aI[a_.func][aZ.func])then error("attempt to set environment of protected function",2)end;aK(f+1,am)elseif type(f)=="function"then local aZ=aS(2,"f")if aI[f]and not(aZ and aI[f][aZ.func])then error("attempt to set environment of protected function",2)end end;aK(f,am)end;if aL then function debug.getfenv(b1)if type(b1)=="function"then local aZ=aS(2,"f")if aI[b1]and not(aZ and aI[b1][aZ.func])then return nil end end;local i=aL(b1)return i end;function debug.setfenv(b1,am)if type(b1)=="function"then local aZ=aS(2,"f")if aI[b1]and not(aZ and aI[b1][aZ.func])then error("attempt to set environment of protected function",2)end end;aO(b1,am)end end;if aR then function debug.upvaluejoin(b2,b3,b4,b5)if type(b2)=="function"and type(b4)=="function"then local aZ=aS(2,"f")if aI[b2]and not(aZ and aI[b2][aZ.func])then error("attempt to get upvalue of protected function",2)end;if aI[b4]and not(aZ and aI[b4][aZ.func])then error("attempt to set upvalue of protected function",2)end end;aR(b2,b3,b4,b5)end end;function debug.protect(az)if type(az)~="function"then error("bad argument #1 (expected function, got "..type(az)..")",2)end;if aI[az]then error("attempt to protect a protected function",2)end;aI[az]=keys(setmetatable({},{__mode="k"}))end;aU={[aJ]=_G.getfenv,[aK]=_G.setfenv,[aL]=debug.getfenv,[aO]=debug.setfenv,[aM]=debug.getlocal,[aP]=debug.setlocal,[aN]=debug.getupvalue,[aQ]=debug.setupvalue,[aR]=debug.upvaluejoin,[aS]=debug.getinfo,[aV]=function()end}aI=keys(setmetatable({},{__mode="k"}),getfenv,setfenv,debug.getfenv,debug.setfenv,debug.getlocal,debug.setlocal,debug.getupvalue,debug.setupvalue,debug.upvaluejoin,debug.getinfo,aV,debug.protect)for h,i in pairs(aI)do aI[h]={}end end;mounts={}fifos={}filesystems={craftos={meta={meta={type="directory",owner="root",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}}},tmpfs={},drivefs={},tablefs={},bind={}}local function b6(process,b7)local E=fs.combine(process.root,b7:sub(1,1)=="/"and""or process.dir,b7)if"/"..E.."/"~=process.root and E:find(process.root:sub(2),1,true)~=1 then error(b7 ..": No such file or directory",4)end;return E end;local function b8(process,b7)local b9=split(b6(process,b7),"/\\")if#b9==0 then return mounts[""],b7,""end;local ba;for h in pairs(mounts)do local bb=true;for w,a9 in ipairs(split(h,"/\\"))do if b9[w]~=a9 then bb=false;break end end;if bb and(not ba or#h>#ba)then ba=h end end;if not ba then panic("Could not find mount for path "..b7 ..". Where is root?")end;local bc=split(ba,"/\\")local E=#b9>=#bc+1 and fs.combine(table.unpack(b9,#bc+1,#b9))or""return mounts[ba],E,ba end;function filesystem.readhandle(process,bd,be)local a7=1;local bf=false;local t={readLine=function(bg)if bf then error("attempt to use a closed file",2)end;if a7>#bd then return nil end;local bh;bh,a7=bd:match("([^\n]*"..(bg and"\n?)"or")\n?").."()",a7)return bh end,readAll=function()if bf then error("attempt to use a closed file",2)end;if a7>#bd then return nil end;local bh=bd:sub(a7)a7=#bh+1;return bh end,read=function(r)if bf then error("attempt to use a closed file",2)end;if r~=nil and type(r)~="number"then error("bad argument #1 (expected number, got "..type(r)..")",2)end;r=r or 1;if a7>#bd then return nil end;local bh=bd:sub(a7,a7+r-1)a7=a7+r;return bh end,close=function()if bf then error("attempt to use a closed file",2)end;bf=true end}if be then t.read=function(r)if bf then error("attempt to use a closed file",2)end;if r~=nil and type(r)~="number"then error("bad argument #1 (expected number, got "..type(r)..")",2)end;if a7>#bd then return nil end;if r then local bh=bd:sub(a7,a7+r-1)a7=a7+r;return bh else local bh=bd:byte(a7)a7=a7+1;return bh end end;t.seek=function(bi,U)if bi~=nil and type(bi)~="string"then error("bad argument #1 (expected string, got "..type(bi)..")",2)end;if U~=nil and type(U)~="number"then error("bad argument #2 (expected number, got "..type(U)..")",2)end;bi=bi or"cur"U=U or 0;if bf then error("attempt to use closed file",2)end;if bi=="set"then a7=U+1 elseif bi=="cur"then a7=a7+U elseif bi=="end"then a7=math.max(#bd-U,1)else error("Invalid whence",2)end;return a7-1 end else bd=bd:gsub("[\x80-\xFF]+",function(bj)local bk=""if not pcall(function()for z,bl in utf8.codes(bj)do bk=bk..(bl<256 and string.char(bl)or"?")end end)then return bj end;return bk end)end;for z,i in pairs(t)do setfenv(i,process.env)debug.protect(i)end;return setmetatable(t,{__name="file"})end;function filesystem.writehandle(process,bm,be)local function bn(t)for z,i in pairs(t)do setfenv(i,process.env)debug.protect(i)end;return setmetatable(t,{__name="file"})end;local bf=false;if be then local a7=1;local bo=""local bp=""return bn{write=function(bh)if bf then error("attempt to use a closed file",2)end;if type(bh)=="number"then bo,a7=bo:sub(1,a7-1)..string.char(bh)..bo:sub(a7+1),a7+1;if bp then bp=bp..string.char(bh)end elseif type(bh)=="string"then bo,a7=bo:sub(1,a7-1)..bh..bo:sub(a7+#bh),a7+#bh;if bp then bp=bp..bh end else error("bad argument #1 (expected string or number, got "..type(bh)..")",2)end end,writeLine=function(bh)if bf then error("attempt to use a closed file",2)end;if type(bh)=="number"then bo,a7=bo:sub(1,a7-1)..string.char(bh).."\n"..bo:sub(a7+2),a7+2;if bp then bp=bp..string.char(bh).."\n"end elseif type(bh)=="string"then bo,a7=bo:sub(1,a7-1)..bh.."\n"..bo:sub(a7+#bh+1),a7+#bh+1;if bp then bp=bp..bh.."\n"end else error("bad argument #1 (expected string or number, got "..type(bh)..")",2)end end,seek=function(bi,U)if bi~=nil and type(bi)~="string"then error("bad argument #1 (expected string, got "..type(bi)..")",2)end;if U~=nil and type(U)~="number"then error("bad argument #2 (expected number, got "..type(U)..")",2)end;bi=bi or"cur"U=U or 0;if bf then error("attempt to use closed file",2)end;local bq=a7;if bi=="set"then a7=U+1 elseif bi=="cur"then a7=a7+U elseif bi=="end"then a7=math.max(#bo-U,1)else error("Invalid whence",2)end;if bq~=a7 then bp=nil end;return a7-1 end,flush=function()if bf then error("attempt to use a closed file",2)end;if bp then bm(bp,false)else bm(bo,true)end;bp=""end,close=function()if bf then error("attempt to use a closed file",2)end;bf=true;if bp then bm(bp,false)else bm(bo,true)end;bp=""end}else local bo=""return bn{write=function(bh)if bf then error("attempt to use a closed file",2)end;bo=bo..tostring(bh)end,writeLine=function(bh)if bf then error("attempt to use a closed file",2)end;bo=bo..tostring(bh).."\n"end,flush=function()if bf then error("attempt to use a closed file",2)end;bm(bo,false)bo=""end,close=function()if bf then error("attempt to use a closed file",2)end;bm(bo,false)bo=""bf=true end}end end;function filesystem.fifohandle(process,br,n)local bf=false;local function bn(t)for z,i in pairs(t)do setfenv(i,process.env)debug.protect(i)end;return setmetatable(t,{__name="file"})end;if n=="r"then return bn{readLine=function(bg)if bf then error("attempt to use a closed file",2)end;if#br.data==0 then return nil end;local bh;bh,br.data=br.data:match("([^\n]*"..(bg and"\n?)"or")\n?").."(.*)")return bh end,readAll=function()if bf then error("attempt to use a closed file",2)end;if#br.data==0 then return nil end;local bh=br.data;br.data=""return bh end,read=function(r)if bf then error("attempt to use a closed file",2)end;if r~=nil and type(r)~="number"then error("bad argument #1 (expected number, got "..type(r)..")",2)end;r=r or 1;if#br.data==0 then return nil end;local bh=br.data:sub(1,r)br.data=br.data:sub(r+1)return bh end,close=function()if bf then error("attempt to use a closed file",2)end;bf=true end}elseif n=="w"or n=="a"then local bo=br.data;return bn{write=function(bh)if bf then error("attempt to use a closed file",2)end;bo=bo..tostring(bh)end,writeLine=function(bh)if bf then error("attempt to use a closed file",2)end;bo=bo..tostring(bh).."\n"end,flush=function()if bf then error("attempt to use a closed file",2)end;br.data=bo end,close=function()if bf then error("attempt to use a closed file",2)end;br.data=bo;bf=true end}elseif n=="rb"then return bn{readLine=function(bg)if bf then error("attempt to use a closed file",2)end;if#br.data==0 then return nil end;local bh;bh,br.data=br.data:match("([^\n]*"..(bg and"\n?)"or")\n?").."(.*)")return bh end,readAll=function()if bf then error("attempt to use a closed file",2)end;if#br.data==0 then return nil end;local bh=br.data;br.data=""return bh end,read=function(r)if bf then error("attempt to use a closed file",2)end;if r~=nil and type(r)~="number"then error("bad argument #1 (expected number, got "..type(r)..")",2)end;if#br.data==0 then return nil end;if r then local bh=br.data:sub(1,r)br.data=br.data:sub(r+1)return bh else local bh=br.data:byte()br.data=br.data:sub(2)return bh end end,seek=function(bi,U)if bi~=nil and type(bi)~="string"then error("bad argument #1 (expected string, got "..type(bi)..")",2)end;if U~=nil and type(U)~="number"then error("bad argument #2 (expected number, got "..type(U)..")",2)end;if bf then error("attempt to use closed file",2)end;return 0 end,close=function()if bf then error("attempt to use a closed file",2)end;bf=true end}elseif n=="wb"or n=="ab"then local bo=br.data;return bn{write=function(bh)if bf then error("attempt to use a closed file",2)end;if type(bh)=="number"then bo=bo..string.char(bh)elseif type(bh)=="string"then bo=bo..bh else error("bad argument #1 (expected string or number, got "..type(bh)..")",2)end end,writeLine=function(bh)if bf then error("attempt to use a closed file",2)end;if type(bh)=="number"then bo=bo..string.char(bh).."\n"elseif type(bh)=="string"then bo=bo..bh.."\n"else error("bad argument #1 (expected string or number, got "..type(bh)..")",2)end end,seek=function(bi,U)if bi~=nil and type(bi)~="string"then error("bad argument #1 (expected string, got "..type(bi)..")",2)end;if U~=nil and type(U)~="number"then error("bad argument #2 (expected number, got "..type(U)..")",2)end;if bf then error("attempt to use closed file",2)end;return#br.data+#bo end,flush=function()if bf then error("attempt to use a closed file",2)end;br.data=bo end,close=function()if bf then error("attempt to use a closed file",2)end;br.data=bo;bf=true end}else return nil,"Invalid mode"end end;filesystem.openfifo=filesystem.fifohandle;do local a=fs.open("/meta.ltn","r")if a then filesystems.craftos.meta=unserialize(a.readAll())or filesystems.craftos.meta;a.close()end end;if args.fsmeta then local a=fs.open(args.fsmeta,"r")if a then local bs=unserialize(a.readAll())a.close()if bs then local function bt(bu,bv)for h,i in pairs(bu)do if bv[h]and type(bv[h])=="table"and type(i)=="table"then bt(i,bv[h])else bv[h]=i end end end;bt(bs,filesystems.craftos.meta)end end end;function filesystems.craftos:getmeta(user,b7,bw)local bx={}local t=self.meta;local bc=split(b7,"/\\")for w,E in ipairs(bc)do if E==".."then t=table.remove(bx)if not t then return nil end elseif not E:match"^%.*$"then if not t then return nil elseif t.meta.type~="directory"then error("Not a directory",2)elseif t.meta.permissions[user]then if not t.meta.permissions[user].execute then error("Permission denied",2)end elseif not t.meta.worldPermissions.execute then error("Permission denied",2)end;bx[#bx+1]=t;t=t.contents[E]if t and t.meta.type=="link"and not(bw and w==#bc)then syslog.debug("linking "..b7 .." to "..filesystem.combine(t.meta.link,table.unpack(bc,w+1)))error{link=true,path=filesystem.combine(t.meta.link,table.unpack(bc,w+1)),orig=b7}end end end;return t and t.meta end;function filesystems.craftos:setmeta(user,b7,bs,bw)local bx={}local t=self.meta;local m;local bc=split(b7,"/\\")for w,E in ipairs(bc)do if E==".."then t=table.remove(bx)if not t then error("Not a directory",2)end elseif not E:match"^%.*$"then if t.meta.type~="directory"then error("Not a directory",2)elseif t.meta.permissions[user]then if not t.meta.permissions[user].execute then error("Permission denied",2)end elseif not t.meta.worldPermissions.execute then error("Permission denied",2)end;if not t.contents[E]then t.contents[E]={meta={type="directory",owner=t.meta.owner or"root",permissions={root={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false},contents={}}end;bx[#bx+1]=t;t=t.contents[E]m=E;if t and t.meta.type=="link"and not(bw and w==#bc)then syslog.debug("linking "..b7 .." to "..filesystem.combine(t.meta.link,table.unpack(bc,w+1)))error{link=true,path=filesystem.combine(t.meta.link,table.unpack(bc,w+1)),orig=b7}end end end;if bs~=nil then t.meta={type=bs.type,owner=bs.owner,permissions=deepcopy(bs.permissions),worldPermissions=deepcopy(bs.worldPermissions),setuser=bs.setuser,link=bs.link}if bs.type~="directory"then t.contents=nil end else bx[#bx].contents[m]=nil end;local a=assert(fs.open("/meta.ltn","w"))a.write(serialize(self.meta,{compact=true}))a.close()end;function filesystems.craftos:new(process,b7,by)expect.field(by,"ro","boolean","nil")if process.user~="root"then error("Could not mount "..b7 ..": Permission denied",3)elseif not fs.isDir(b7)then error("Could not mount "..b7 ..": No such directory",3)end;return setmetatable({path=b7,readOnly=by.ro},{__index=self})end;function filesystems.craftos:open(process,b7,n)local bb,bz=pcall(self.stat,self,process,b7)if not bb then if type(bz)=="table"then error(bz)end;return nil,bz elseif not bz then if n:sub(1,1)=="w"or n:sub(1,1)=="a"then if self.readOnly then return nil,"Read-only filesystem"end;local bA,bB=pcall(self.stat,self,process,fs.getDir(b7))if not bA or not bB then if type(bB)=="table"then error(bB)end;local bC,o=pcall(self.mkdir,self,process,fs.getDir(b7))if not bC then if type(o)=="table"then error(o)end;return nil,o:gsub("kernel:%d: ","")end;bB=self:stat(process,fs.getDir(b7))if not bB then return nil,"Could not stat "..fs.getDir(b7)end end;if process.user~="root"then local bD=bB.permissions[process.user]or bB.worldPermissions;if not bD.write then return nil,"Permission denied"end end;local bs={type="file",owner=process.user,permissions=deepcopy(bB.permissions),worldPermissions=deepcopy(bB.worldPermissions),setuser=false}if bB.owner then local t=bs.permissions[bB.owner]bs.permissions[bB.owner]=nil;bs.permissions[process.user]=t end;self:setmeta(process.user,fs.combine(self.path,b7),bs)local a,o=fs.open(fs.combine(self.path,b7),n)if not a then return a,o end;return setmetatable(a,{__name="file"})else return nil,"File not found"end elseif bz.type=="directory"then return nil,"Is a directory"end;local bD=bz.permissions[process.user]or bz.worldPermissions;if n:sub(1,1)=="r"and not bD.read or(n:sub(1,1)=="w"or n:sub(1,1)=="a")and not bD.write then return nil,"Permission denied"end;if bz.type=="fifo"then local bs=self:getmeta(process.user,fs.combine(self.path,b7))local bE=fifos[bs]if not bE then bE={data=""}fifos[bs]=bE end;return filesystem.fifohandle(process,bE,n)end;return setmetatable(fs.open(fs.combine(self.path,b7),n),{__name="file"})end;function filesystems.craftos:list(process,b7)local bz=self:stat(process,b7)if not bz or bz.type~="directory"then error(b7 ..": Not a directory",2)end;if process.user~="root"then local bD=bz.permissions[process.user]or bz.worldPermissions;if not bD.read then error(b7 ..": Permission denied",2)end end;return fs.list(fs.combine(self.path,b7))end;function filesystems.craftos:stat(process,b7,bw)local E=fs.combine(self.path,b7)if E:find(self.path:gsub("^/",""):gsub("/$",""),1,false)~=1 then return nil end;local bb,bF=pcall(fs.attributes,E)if not bb or not bF then return nil end;bF.type=bF.isDir and"directory"or"file"bF.special={}bF.isDir=nil;if not bF.modified then bF.modified=bF.modification end;bF.modification=nil;bF.capacity=fs.getCapacity(E)bF.freeSpace=fs.getFreeSpace(E)local bG=bF.isReadOnly;bF.isReadOnly=nil;local bs=self:getmeta(process.user,fs.combine(self.path,b7),bw)if bs then bF.owner=bs.owner;bF.permissions=deepcopy(bs.permissions)bF.worldPermissions=deepcopy(bs.worldPermissions)bF.type=bs.type or bF.type;bF.setuser=bs.setuser;bF.link=bs.link else bF.owner="root"bF.permissions={root={read=true,write=true,execute=true}}bF.worldPermissions={read=true,write=false,execute=true}bF.setuser=false end;if bG then bF.worldPermissions.write=false;for z,i in pairs(bF.permissions)do i.write=false end end;return bF end;function filesystems.craftos:remove(process,b7)if self.readOnly then error(b7 ..": Read-only filesystem",2)end;local bz=self:stat(process,b7,true)if not bz then return end;local function bH(E)local bj=self:stat(process,E,true)local bD=bj.permissions[process.user]or bj.worldPermissions;if process.user~="root"and not bD.write then error(E..": Permission denied",3)end;if bj.type=="directory"then if process.user~="root"and not bD.read then error(E..": Permission denied",3)end;for z,i in ipairs(fs.list(fs.combine(self.path,E)))do bH(fs.combine(E,i))end end end;bH(b7)fs.delete(fs.combine(self.path,b7))self:setmeta(process.user,fs.combine(self.path,b7),nil,true)end;function filesystems.craftos:rename(process,bI,bJ)if self.readOnly then error("Read-only filesystem",2)end;local bK=self:stat(process,bI,true)local bL=self:stat(process,bJ,true)if not bK then error(bI..": No such file or directory",2)elseif bL then error(bJ..": "..bL.type:gsub("%w",string.upper,1).." already exists",2)end;bL=self:stat(process,fs.getDir(bJ))if not bL then self:mkdir(process,fs.getDir(bJ))bL=self:stat(process,fs.getDir(bJ))end;if process.user~="root"then local bD=bL.permissions[process.user]or bL.worldPermissions;if not bD.write then error(bJ..": Permission denied",2)end end;fs.move(fs.combine(self.path,bI),fs.combine(self.path,bJ))self:setmeta(process.user,fs.combine(self.path,bJ),self:getmeta(process.user,fs.combine(self.path,bI),true),true)self:setmeta(process.user,fs.combine(self.path,bI),nil,true)end;function filesystems.craftos:mkdir(process,b7)if self.readOnly then error(b7 ..": Read-only filesystem",2)end;local bz=self:stat(process,b7)if bz then if bz.type=="directory"then return else error(b7 ..": File already exists",2)end end;local bc=split(b7,"/\\")local w=#bc-1;repeat bz=self:stat(process,table.concat(bc,"/",1,w))if bz then if bz.type=="directory"then break else error(b7 ..": File already exists",2)end end;w=w-1 until bz or w<=0;if b7:match"^/"then bz=assert(self:stat(process,"/"))else bz=assert(self:stat(process,process.dir))end;if process.user~="root"then local bD=bz.permissions[process.user]or bz.worldPermissions;if not bD.write then error(b7 ..": Permission denied",2)end end;local bs={type="directory",owner=process.user,permissions=deepcopy(bz.permissions),worldPermissions=deepcopy(bz.worldPermissions)}if bz.owner then local t=bs.permissions[bz.owner]bs.permissions[bz.owner]=nil;bs.permissions[process.user]=t end;w=w+1;while w<=#bc do self:setmeta(process.user,fs.combine(self.path,table.concat(bc,1,w)),deepcopy(bs))w=w+1 end;fs.makeDir(fs.combine(self.path,b7))end;function filesystems.craftos:link(process,b7,bM)local bz=self:stat(process,b7)if bz then error(b7 ..": File exists",2)end;self:open(process,b7,"w").close()local bs=self:getmeta(process.user,fs.combine(self.path,b7),true)bs.type,bs.link="link",bM;self:setmeta(process.user,fs.combine(self.path,b7),bs,true)end;function filesystems.craftos:mkfifo(process,b7)local bz=self:stat(process,b7)if bz then error(b7 ..": File exists",2)end;self:open(process,b7,"w").close()local bs=self:getmeta(process.user,fs.combine(self.path,b7),true)bs.type="fifo"self:setmeta(process.user,fs.combine(self.path,b7),bs,true)end;function filesystems.craftos:chmod(process,b7,user,n)if self.readOnly then error(b7 ..": Read-only filesystem",2)end;local bz=self:stat(process,b7,true)if not bz then error(b7 ..": No such file or directory",2)end;if not bz.owner or process.user~="root"and process.user~=bz.owner then error(b7 ..": Permission denied",2)end;local bD;if user==nil then bD=bz.worldPermissions else bD=bz.permissions[user]if not bD then bD=deepcopy(bz.worldPermissions)bz.permissions[user]=bD end end;if type(n)=="string"then if n:match"^[%+%-=][rwxs]+$"then local A=n:sub(1,1)local t={}for a9 in n:gmatch("[rwxs]")do if a9=="r"then t.read=true elseif a9=="w"then t.write=true elseif a9=="s"then t.setuser=true else t.execute=true end end;if A=="+"then if t.read then bD.read=true end;if t.write then bD.write=true end;if t.execute then bD.execute=true end;if t.setuser then bz.setuser=true end elseif A=="-"then if t.read then bD.read=false end;if t.write then bD.write=false end;if t.execute then bD.execute=false end;if t.setuser then bz.setuser=false end else bD.read=t.read or false;bD.write=t.write or false;bD.execute=t.execute or false;bz.setuser=t.setuser or false end else bD.read=n:sub(1,1)~="-"bD.write=n:sub(2,2)~="-"bD.execute=n:sub(3,3)~="-"bz.setuser=n:sub(3,3)=="s"end elseif type(n)=="number"then bz.setuser=bit32.btest(n,8)bD.read=bit32.btest(n,4)bD.write=bit32.btest(n,2)bD.execute=bit32.btest(n,1)else if n.read~=nil then bD.read=n.read end;if n.write~=nil then bD.write=n.write end;if n.execute~=nil then bD.execute=n.execute end;if n.setuser~=nil then bz.setuser=n.setuser end end;self:setmeta(process.user,fs.combine(self.path,b7),deepcopy(bz),true)end;function filesystems.craftos:chown(process,b7,bN)if self.readOnly then error(b7 ..": Read-only filesystem",2)end;local bz=self:stat(process,b7,true)if not bz then error(b7 ..": No such file or directory",2)end;if not bz.owner or process.user~="root"and process.user~=bz.owner then error(b7 ..": Permission denied",2)end;bz.owner=bN;bz.setuser=false;self:setmeta(process.user,fs.combine(self.path,b7),deepcopy(bz),true)end;function filesystems.craftos:info()return"craftos",self.path,{ro=self.readOnly}end;function filesystems.tmpfs:getpath(user,b7,bw)local t=self;local bc=split(b7,"/\\")for w,E in ipairs(bc)do if not t then return nil elseif t.type~="directory"then error("Not a directory",2)elseif t.permissions[user]then if not t.permissions[user].execute then error("Permission denied",2)end elseif not t.worldPermissions.execute then error("Permission denied",2)end;t=t.contents[E]if t and t.type=="link"and not(bw and w==#bc)then error{link=true,path=filesystem.combine(t.link,table.unpack(bc,w+1)),orig=b7}end end;return t end;function filesystems.tmpfs:setpath(user,b7,bd,bw)local t=self;local K=split(b7,"/\\")local bO=K[#K]K[#K]=nil;for w,E in ipairs(K)do if t.type~="directory"then error("Not a directory",2)elseif t.permissions[user]then if not t.permissions[user].execute then error("Permission denied",2)end elseif not t.worldPermissions.execute then error("Permission denied",2)end;if not t.contents[E]then t.contents[E]={type="directory",owner=t.owner,permissions=deepcopy(t.permissions),worldPermissions=deepcopy(t.worldPermissions),setuser=false,created=os.epoch"utc",modified=os.epoch"utc",contents={}}end;t=t.contents[E]if t and t.type=="link"then error{link=true,path=filesystem.combine(t.link,table.unpack(K,w+1)),orig=b7}end end;if t.type~="directory"then error("Not a directory",2)elseif user~="root"then if t.permissions[user]then if not t.permissions[user].execute then error("Permission denied",2)end elseif not t.worldPermissions.execute then error("Permission denied",2)end end;if not bw and t.contents[bO]and t.contents[bO].type=="link"then error{link=true,path=t.contents[bO].link,orig=b7}end;t.contents[bO]=bd end;function filesystems.tmpfs:new(process,bu,by)return setmetatable({type="directory",owner=process.user,permissions={[process.user]={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false,created=os.epoch"utc",modified=os.epoch"utc",contents={}},{__index=self})end;function filesystems.tmpfs:_open_internal(process,b7,n)local bP=os.epoch;local bd=self:getpath(process.user,b7)if not bd then return nil,"No such file"end;if n=="r"or n=="rb"then return filesystem.readhandle(process,bd.data,n=="rb")elseif n=="w"or n=="wb"then bd.data=""bd.modified=bP"utc"return filesystem.writehandle(process,function(bo,bQ)if bQ then bd.data=bo else bd.data=bd.data..bo end;bd.modified=bP"utc"if self.__flush then self:__flush()end end,n=="wb")elseif n=="a"or n=="ab"then local bR=bd.data;return filesystem.writehandle(process,function(bo,bQ)if bQ then bd.data=bR..bo else bd.data=bd.data..bo end;bd.modified=bP"utc"if self.__flush then self:__flush()end end,n=="ab")else return nil,"Invalid mode"end end;function filesystems.tmpfs:open(process,b7,n)if self.readOnly and(n:sub(1,1)=="w"or n:sub(1,1)=="a")then return nil,"Read-only filesystem"end;local bb,bz=pcall(self.stat,self,process,b7)if not bb then if type(bz)=="table"then error(bz)end;return nil,bz elseif not bz then if n:sub(1,1)=="w"or n:sub(1,1)=="a"then local bA,bB=pcall(self.stat,self,process,fs.getDir(b7))if not bA or not bB then if type(bB)=="table"then error(bB)end;local bC,o=pcall(self.mkdir,self,process,fs.getDir(b7))if not bC then if type(o)=="table"then error(o)end;return nil,o:gsub("kernel:%d: ","")end;bB=self:stat(process,fs.getDir(b7))end;if process.user~="root"then local bD=bB.permissions[process.user]or bB.worldPermissions;if not bD.write then return nil,"Permission denied"end end;local bs={type="file",owner=process.user,permissions=deepcopy(bB.permissions),worldPermissions=deepcopy(bB.worldPermissions),setuser=false,created=os.epoch"utc",modified=os.epoch"utc",data=""}local t=bs.permissions[bB.owner]bs.permissions[bB.owner]=nil;bs.permissions[process.user]=t;self:setpath(process.user,b7,bs)return self:_open_internal(process,b7,n)else return nil,"File not found"end elseif bz.type=="directory"then return nil,"Is a directory"end;if process.user~="root"then local bD=bz.permissions[process.user]or bz.worldPermissions;if n:sub(1,1)=="r"and not bD.read or(n:sub(1,1)=="w"or n:sub(1,1)=="a")and not bD.write then return nil,"Permission denied"end end;if bz.type=="fifo"then local bs=self:getpath(process.user,b7)local bE=fifos[bs]if not bE then bE={data=""}fifos[bs]=bE end;return filesystem.fifohandle(process,bE,n)end;return self:_open_internal(process,b7,n)end;function filesystems.tmpfs:list(process,b7)local bd=self:getpath(process.user,b7)if not bd or bd.type~="directory"then error(b7 ..": Not a directory",2)end;if process.user~="root"then local bD=bd.permissions[process.user]or bd.worldPermissions;if not bD.read then error(b7 ..": Permission denied",2)end end;local a5={}for h in pairs(bd.contents)do a5[#a5+1]=h end;table.sort(a5)return a5 end;function filesystems.tmpfs:stat(process,b7,bw)local bd=self:getpath(process.user,b7,bw)if not bd then return nil end;return{size=bd.type=="file"and#bd.data or(bd.type=="directory"and#bd.contents or 0),type=bd.type,created=bd.created,modified=bd.modified,owner=bd.owner,permissions=deepcopy(bd.permissions),worldPermissions=deepcopy(bd.worldPermissions),setuser=bd.setuser,capacity=math.huge,freeSpace=math.huge,link=rawget(bd,"link"),special={}}end;function filesystems.tmpfs:remove(process,b7)if self.readOnly then error("Read-only filesystem",2)end;local bS=self:getpath(process.user,fs.getDir(b7))local m=fs.getName(b7)if not bS or bS.type~="directory"or not bS.contents[m]then return end;if process.user~="root"and not(bS.permissions[process.user]or bS.worldPermissions).write then error(b7 ..": Permission denied",2)end;local bd=bS.contents[m]if process.user~="root"and not(bd.permissions[process.user]or bd.worldPermissions).write then error(b7 ..": Permission denied",2)end;local function bH(bj)local bD=bj.permissions[process.user]or bj.worldPermissions;if process.user~="root"and not bD.write then error(b7 ..": Permission denied",3)end;if bj.type=="directory"then if process.user~="root"and not bD.read then error(b7 ..": Permission denied",3)end;for z,i in pairs(bj.contents)do bH(i)end end end;bH(bd)bS.contents[m]=nil;bS.modified=os.epoch"utc"end;function filesystems.tmpfs:rename(process,bI,bJ)if self.readOnly then error("Read-only filesystem",2)end;local bT=self:getpath(process.user,fs.getDir(bI))local bU=fs.getName(bI)if not bT or bT.type~="directory"or not bT.contents[bU]then error(bI..": No such file or directory",2)end;if process.user~="root"and not(bT.permissions[process.user]or bT.worldPermissions).write then error(bI..": Permission denied",2)end;local bV=bT.contents[bU]if process.user~="root"and not(bV.permissions[process.user]or bV.worldPermissions).write then error(bI..": Permission denied",2)end;local bW=self:getpath(process.user,fs.getDir(bJ))local bX=fs.getName(bJ)if not bW or bW.type~="directory"then error(bJ..": No such file or directory",2)end;if process.user~="root"and not(bW.permissions[process.user]or bW.worldPermissions).write then error(bJ..": Permission denied",2)end;local bY=bW.contents[bX]if bY then error(bJ..": File already exists",2)end;bW.contents[bX],bT.contents[bU]=bV,nil;local bZ=os.epoch"utc"bT.modified,bW.modified=bZ,bZ end;function filesystems.tmpfs:mkdir(process,b7)if self.readOnly then error("Read-only filesystem",2)end;local t=self;for z,E in ipairs(split(b7,"/\\"))do local bD=t.permissions[process.user]or t.worldPermissions;if t.type~="directory"then error(b7 ..": File exists",2)elseif process.user~="root"and not bD.execute then error(b7 ..": Permission denied",2)end;if not t.contents[E]then if process.user~="root"and not bD.write then error(b7 ..": Permission denied",2)end;t.contents[E]={type="directory",owner=t.owner,permissions=deepcopy(t.permissions),worldPermissions=deepcopy(t.worldPermissions),created=os.epoch"utc",modified=os.epoch"utc",contents={}}t.modified=os.epoch"utc"end;t=t.contents[E]end end;function filesystems.tmpfs:link(process,b7,bM)if self.readOnly then error("Read-only filesystem",2)end;local bz=self:stat(process,b7)if bz then error(b7 ..": File exists",2)end;local bA,bB=pcall(self.stat,self,process,fs.getDir(b7))if not bA or not bB then if type(bB)=="table"then error(bB)end;local bC,o=pcall(self.mkdir,self,process,fs.getDir(b7))if not bC then if type(o)=="table"then error(o)end;return nil,type(o)=="string"and o:gsub("kernel:%d: ","")or o end;bB=self:stat(process,fs.getDir(b7))end;self:setpath(process.user,b7,{type="link",owner=process.user,permissions=deepcopy(bB.permissions),worldPermissions=deepcopy(bB.worldPermissions),setuser=false,created=os.epoch"utc",modified=os.epoch"utc",path=bM},true)end;function filesystems.tmpfs:mkfifo(process,b7)if self.readOnly then error("Read-only filesystem",2)end;local bz=self:stat(process,b7)if bz then error(b7 ..": File exists",2)end;local bA,bB=pcall(self.stat,self,process,fs.getDir(b7))if not bA or not bB then if type(bB)=="table"then error(bB)end;local bC,o=pcall(self.mkdir,self,process,fs.getDir(b7))if not bC then if type(o)=="table"then error(o)end;return nil,type(o)=="string"and o:gsub("kernel:%d: ","")or o end;bB=self:stat(process,fs.getDir(b7))end;self:setpath(process.user,b7,{type="fifo",owner=process.user,permissions=deepcopy(bB.permissions),worldPermissions=deepcopy(bB.worldPermissions),setuser=false,created=os.epoch"utc",modified=os.epoch"utc"},true)end;function filesystems.tmpfs:chmod(process,b7,user,n)if self.readOnly then error("Read-only filesystem",2)end;local bz=self:getpath(process.user,b7,true)if not bz then error(b7 ..": No such file or directory",2)end;if not bz.owner or process.user~="root"and process.user~=bz.owner then error(b7 ..": Permission denied",2)end;local bD;if user==nil then bD=bz.worldPermissions else bD=bz.permissions[user]if not bD then bD=deepcopy(bz.worldPermissions)bz.permissions[user]=bD end end;if type(n)=="string"then if n:match"^[%+%-=][rwxs]+$"then local A=n:sub(1,1)local t={}for a9 in n:gmatch("[rwxs]")do if a9=="r"then t.read=true elseif a9=="w"then t.write=true elseif a9=="s"then t.setuser=true else t.execute=true end end;if A=="+"then if t.read then bD.read=true end;if t.write then bD.write=true end;if t.execute then bD.execute=true end;if t.setuser then bz.setuser=true end elseif A=="-"then if t.read then bD.read=false end;if t.write then bD.write=false end;if t.execute then bD.execute=false end;if t.setuser then bz.setuser=false end else bD.read=t.read or false;bD.write=t.write or false;bD.execute=t.execute or false;bz.setuser=t.setuser or false end else bD.read=n:sub(1,1)~="-"bD.write=n:sub(2,2)~="-"bD.execute=n:sub(3,3)~="-"bz.setuser=n:sub(3,3)=="s"end elseif type(n)=="number"then bz.setuser=bit32.btest(n,8)bD.read=bit32.btest(n,4)bD.write=bit32.btest(n,2)bD.execute=bit32.btest(n,1)else if n.read~=nil then bD.read=n.read end;if n.write~=nil then bD.write=n.write end;if n.execute~=nil then bD.execute=n.execute end;if n.setuser~=nil then bz.setuser=n.setuser end end end;function filesystems.tmpfs:chown(process,b7,bN)if self.readOnly then error("Read-only filesystem",2)end;local bz=self:getpath(process.user,b7,true)if not bz then error(b7 ..": No such file or directory",2)end;if not bz.owner or process.user~="root"and process.user~=bz.owner then error(b7 ..": Permission denied",2)end;bz.owner=bN;bz.setuser=false end;function filesystems.tmpfs:info()return"tmpfs","memory",{ro=self.readOnly}end;setmetatable(filesystems.drivefs,{__index=filesystems.craftos})function filesystems.drivefs:new(process,bu,by)local b_=hardware.get(bu)if not b_ then error("Could not find drive at "..bu)end;local fs=filesystems.craftos:new(process,hardware.call(process,b_,"getMountPath"),by)fs.drive=b_.uuid;return setmetatable(fs,{__index=self})end;function filesystems.drivefs:info()return"drivefs",self.drive,{ro=self.readOnly}end;setmetatable(filesystems.tablefs,{__index=filesystems.tmpfs})function filesystems.tablefs:new(process,bu,by)local t;local a,o;if process==KERNEL and mounts[""]then a,o=filesystem.open(process,bu,"r")else a,o=fs.open(bu,"r")end;if a then local bd=a.readAll()or""a.close()local bb,v=pcall(unserialize,bd)if not bb then error("Could not mount "..bu..": "..v,3)elseif type(v)~="table"or v.type~="directory"or type(v.contents)~="table"then error("Could not mount "..bu..": Invalid table file",3)end;t=v else if not(by.rw and not by.ro)then error("Could not mount "..bu..": "..o,3)end;t={type="directory",owner=process.user,permissions={[process.user]={read=true,write=true,execute=true}},worldPermissions={read=true,write=false,execute=true},setuser=false,created=os.epoch"utc",modified=os.epoch"utc",contents={}}end;t.src=bu;t.readOnly=by.ro;if by.rw and not by.ro then function t:__flush()local f,bj=self.__flush,self.src;self.__flush,self.src=nil;local bb,v=pcall(serialize,self)self.__flush,self.src=f,bj;if not bb then error(v)end;local a,o=filesystem.open(process,bu,"w")if not a then syslog.log({level=4},"Could not save mount to "..bu..": "..o)return end;a.write(v)a.close()end end;return setmetatable(t,{__index=self})end;function filesystems.tablefs:info()return"tablefs",self.src,{rw=self.__flush~=nil,ro=self.readOnly}end;function filesystems.bind:new(process,b7,by)local bz,o=filesystem.stat(process,b7)if not bz then error("Could not bind "..b7 ..": "..o,3)elseif bz.type~="directory"then error("Could not bind "..b7 ..": Not a directory",3)end;return setmetatable({path=b7},{__index=self})end;function filesystems.bind:open(process,b7,n)return filesystem.open(process,fs.combine(self.path,b7),n)end;function filesystems.bind:list(process,b7)return filesystem.list(process,fs.combine(self.path,b7))end;function filesystems.bind:stat(process,b7,bw)return filesystem.stat(process,fs.combine(self.path,b7),bw)end;function filesystems.bind:remove(process,b7)return filesystem.remove(process,fs.combine(self.path,b7))end;function filesystems.bind:rename(process,bI,bJ)return filesystem.rename(process,fs.combine(self.path,bI),fs.combine(self.path,bJ))end;function filesystems.bind:mkdir(process,b7)return filesystem.mkdir(process,fs.combine(self.path,b7))end;function filesystems.bind:link(process,b7,bM)return filesystem.link(process,fs.combine(self.path,b7),bM)end;function filesystems.bind:mkfifo(process,b7)return filesystem.mkfifo(process,fs.combine(self.path,b7))end;function filesystems.bind:chmod(process,b7,user,n)return filesystem.chmod(process,fs.combine(self.path,b7),user,n)end;function filesystems.bind:chown(process,b7,bN)return filesystem.chown(process,fs.combine(self.path,b7),bN)end;function filesystems.bind:info()return"bind",self.path,{}end;function filesystem.open(process,b7,n)expect(0,process,"table")expect(1,b7,"string")expect(2,n,"string")if not n:match"^[rwa]b?$"then error("Invalid mode",0)end;repeat local bb,c0,E=pcall(b8,process,b7)if not bb then return nil,c0 end;local v=table.pack(pcall(c0.open,c0,process,E,n))if v[1]then return table.unpack(v,2,v.n)elseif type(v[2])~="table"or type(v[2].path)~="string"then error(v[2],2)end;b7=v[2].path until v[1]end;function filesystem.list(process,b7)expect(0,process,"table")expect(1,b7,"string")repeat local c0,E=b8(process,b7)local bb,v=pcall(c0.list,c0,process,E)if bb then return v elseif type(v)~="table"or type(v.path)~="string"then error(v,2)end;b7=v.path until bb end;function filesystem.stat(process,b7,bw)expect(0,process,"table")expect(1,b7,"string")repeat local bb,c0,E,c1=pcall(b8,process,b7)if not bb then return nil,c0 end;local c2,v,o=pcall(c0.stat,c0,process,E,bw)if c2 then if v then v.mountpoint="/"..c1 end;return v,o elseif type(v)~="table"or type(v.path)~="string"then error(v,2)end;b7=v.path until c2 end;function filesystem.remove(process,b7)expect(0,process,"table")expect(1,b7,"string")repeat local c0,E=b8(process,b7)local bb,v=pcall(c0.remove,c0,process,E)if bb then return elseif type(v)~="table"or type(v.path)~="string"then error(v,2)end;b7=v.path until bb end;function filesystem.rename(process,bI,bJ)expect(0,process,"table")expect(1,bI,"string")expect(2,bJ,"string")repeat local c3,c4=b8(process,bI)local c5,c6=b8(process,bJ)if c3~=c5 then error("Attempt to rename file across two filesystems",0)end;local bb,v=pcall(c3.rename,c3,process,c4,c6)if bb then return elseif type(v)~="table"or type(v.path)~="string"then error(v,2)end;if v.orig==bI then bI=v.path else bJ=v.path end until bb end;function filesystem.mkdir(process,b7)expect(0,process,"table")expect(1,b7,"string")repeat local c0,E=b8(process,b7)local bb,v=pcall(c0.mkdir,c0,process,E)if bb then return elseif type(v)~="table"or type(v.path)~="string"then error(v,2)end;b7=v.path until bb end;function filesystem.link(process,b7,bM)expect(0,process,"table")expect(1,b7,"string")expect(2,bM,"string")repeat local c0,E=b8(process,b7)if not c0.link then error("Filesystem does not support links",2)end;local bb,v=pcall(c0.link,c0,process,E,bM)if bb then return elseif type(v)~="table"or type(v.path)~="string"then error(v,2)end;b7=v.path until bb end;function filesystem.mkfifo(process,b7)expect(0,process,"table")expect(1,b7,"string")repeat local c0,E=b8(process,b7)if not c0.mkfifo then error("Filesystem does not support FIFOs",2)end;local bb,v=pcall(c0.mkfifo,c0,process,E)if bb then return elseif type(v)~="table"or type(v.path)~="string"then error(v,2)end;b7=v.path until bb end;function filesystem.chmod(process,b7,user,n)expect(0,process,"table")expect(1,b7,"string")expect(2,user,"string","nil")expect(3,n,"number","string","table")if type(n)=="string"and not n:match"^[%+%-=][rwxs]+$"and not n:match"^[r%-][w%-][xs%-]$"then error("bad argument #3 (invalid mode)",2)elseif type(n)=="table"then expect.field(n,"read","boolean","nil")expect.field(n,"write","boolean","nil")expect.field(n,"execute","boolean","nil")end;repeat local c0,E=b8(process,b7)local bb,v=pcall(c0.chmod,c0,process,E,user,n)if bb then return elseif type(v)~="table"or type(v.path)~="string"then error(v,2)end;b7=v.path until bb end;function filesystem.chown(process,b7,user)expect(0,process,"table")expect(1,b7,"string")expect(2,user,"string")repeat local c0,E=b8(process,b7)local bb,v=pcall(c0.chown,c0,process,E,user)if bb then return elseif type(v)~="table"or type(v.path)~="string"then error(v,2)end;b7=v.path until bb end;function filesystem.chroot(process,b7)expect(0,process,"table")expect(1,b7,"string")if process.user~="root"then error("Could not change root: Permission denied",2)end;local c7=filesystem.combine(process.root,b7).."/"if c7:find(process.root,1,true)~=1 then error("Could not change root: No such file or directory",2)end;local bj=filesystem.stat(process,"/"..b7)if not bj then error(b7 ..": No such directory",2)end;if bj.type~="directory"then error(b7 ..": Not a directory",2)end;process.root=c7 end;function filesystem.mount(process,type,bu,bv,by)expect(0,process,"table")expect(1,type,"string")expect(2,bu,"string")expect(3,bv,"string")expect(4,by,"table","nil")if not filesystems[type]then error("No such filesystem '"..type.."'",2)end;local E=b6(process,bv)if E==""then if process.user~="root"then error("Could not mount to "..bv..": Permission denied",2)elseif mounts[E]then error("Could not mount to "..bv..": Mount already exists")end else local bz=filesystem.stat(process,bv)if not bz then error("Could not mount to "..bv..": No such directory",2)elseif bz.type~="directory"then error("Could not mount to "..bv..": Not a directory",2)elseif process.user~="root"and not(bz.permissions[process.user]or bz.worldPermissions).write then error("Could not mount to "..bv..": Permission denied",2)elseif mounts[E]then error("Could not mount to "..bv..": Mount already exists")end end;local c0=filesystems[type]:new(process,bu,by or{})mounts[E]=c0 end;function filesystem.unmount(process,b7)expect(0,process,"table")expect(1,b7,"string")b7=b6(process,b7)if not mounts[b7]then error(b7 ..": No such mount",2)end;local bz=mounts[b7]:stat(process,"")if not bz then error("Internal error in unmount: could not get stat for root! Please report this to the maintainer of the target filesystem.",2)elseif process.user~="root"and not(bz.permissions[process.user]or bz.worldPermissions).write then error(b7 ..": Permission denied",2)end;mounts[b7]=nil end;function filesystem.mountlist(process)expect(0,process,"table")local a5={}for h,i in pairs(mounts)do if"/"..h.."/"==process.root or h:find(process.root:sub(2),1,true)==1 then local type,b7,by=i:info()a5[#a5+1]={path=h,type=type,source=b7,options=by}end end;return a5 end;function filesystem.combine(c8,...)local a0=fs.combine(c8,...)if c8:match"^/"then a0="/"..a0 end;return a0 end;function syscalls.open(process,ar,...)return filesystem.open(process,...)end;function syscalls.list(process,ar,...)return filesystem.list(process,...)end;function syscalls.stat(process,ar,...)return filesystem.stat(process,...)end;function syscalls.remove(process,ar,...)return filesystem.remove(process,...)end;function syscalls.rename(process,ar,...)return filesystem.rename(process,...)end;function syscalls.mkdir(process,ar,...)return filesystem.mkdir(process,...)end;function syscalls.link(process,ar,...)return filesystem.link(process,...)end;function syscalls.mkfifo(process,ar,...)return filesystem.mkfifo(process,...)end;function syscalls.chmod(process,ar,...)return filesystem.chmod(process,...)end;function syscalls.chown(process,ar,...)return filesystem.chown(process,...)end;function syscalls.chroot(process,ar,...)return filesystem.chroot(process,...)end;function syscalls.mount(process,ar,...)return filesystem.mount(process,...)end;function syscalls.unmount(process,ar,...)return filesystem.unmount(process,...)end;function syscalls.mountlist(process,ar,...)return filesystem.mountlist(process,...)end;function syscalls.combine(process,ar,...)return filesystem.combine(...)end;function syscalls.loadCraftOSAPI(process,ar,c9)expect(1,c9,"string")local e;e=setmetatable({dofile=function(b7)local a,o=fs.open(b7,"rb")if not a then error("Could not open module: "..o,0)end;local g,o=load(a.readAll(),"@"..b7,nil,e)a.close()if not g then error("Could not load module: "..o,0)end;return g()end,require=function(m)return e.dofile("rom/modules/main/"..m:gsub("%.","/")..".lua")end},{__index=process.env})if c9:sub(1,3)=="cc."then local b7=fs.combine("rom/modules/main",c9:gsub("%.","/")..".lua")if not b7:match"^/?rom/modules/main/"then error("Invalid module path",0)end;return e.dofile(b7)else if not c9:match"^[a-z]+$"then error("Invalid API name",0)end;local b7=fs.combine("rom/apis",c9 ..".lua")local a,o=fs.open(b7,"rb")if not a then error("Could not open module: "..o,0)end;local g,o=load(a.readAll(),"@"..b7,nil,e)a.close()if not g then error("Could not load module: "..o,0)end;g()local t={}for h,i in pairs(e)do if h~="dofile"then t[h]=i end end;return t end end;xpcall(function()if args.initrd then if args.initrd:match"^_G%.."then local ca=_G[args.initrd:match"^_G%.(.+)"]if type(ca)~="table"then error("Requested root filesystem in global '"..args.initrd.."' is not a table")end;ca.src=args.initrd;mounts[""]=setmetatable(ca,{__index=filesystems.tablefs})else mounts[""]=filesystems.tablefs:new(KERNEL,args.initrd,{})end else local by={}if args.rootflags then for A in args.rootflags:gmatch"[^,]+"do local h,i=A:match("^([^=]+)=(.*)$")if h and i then if i=="true"then by[h]=true elseif i=="false"then by[h]=false else by[h]=tonumber(i)or i end else by[A]=true end end end;mounts[""]=filesystems[args.rootfstype]:new(KERNEL,args.root,by)end end,panic)local do_syscall=do_syscall;local expect=expect;local function cb(cc,cd,ce,cf)local cg={bit32.extract(cd,0,16),bit32.extract(cd,16,16),bit32.extract(cc,0,16),bit32.extract(cc,16,16)}local ab={bit32.extract(cf,0,16),bit32.extract(cf,16,16),bit32.extract(ce,0,16),bit32.extract(ce,16,16)}local bp={{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0}}for ch=1,4 do for ci=1,4 do local r=cg[ci]*ab[ch]+bp[ch][ci]bp[ch][ci+1],bp[ch][ci]=bit32.rshift(r,16),bit32.band(r,0xFFFF)end end;local cj={0,0,0,0,0,0,0,0}for ck=1,8 do for cl=1,4 do cj[ck]=cj[ck]+(bp[cl][ck-cl+1]or 0)end;cj[ck+1],cj[ck]=bit32.rshift(cj[ck],16),bit32.band(cj[ck],0xFFFF)end;return cj[3]+cj[4]*0x10000,cj[1]+cj[2]*0x10000 end;local function cm(ab,cc,cd)return cc+math.floor((cd+ab)/0x100000000),bit32.band(cd+ab,0xFFFFFFFF)end;function makeRandom()local cn,co=0,0;local function next(cp)cn,co=cm(0xB,cb(cn,co,0x5,0xDEECE66D))cn=bit32.band(cn,0xFFFF)return math.floor(cn/2^(16-cp))+math.floor(co/2^(48-cp))end;local function cq(c,d)expect(1,c,"number","nil")expect(2,d,"number","nil")if c then expect.range(c,0,0x7FFFFFFF)if not d then c,d=0,c else expect.range(d,0,0x7FFFFFFF)end;local cr=d-c+1;local cs;if math.log(cr,2)%1==0 then cs=math.floor(cr*next(31)/0x80000000)else local cp;repeat cp=next(31)cs=cp%cr until cp-cs+cr-1>=0 end;return cs+c else return(next(26)*0x8000000+next(27))/0x20000000000000 end end;local function ct(cu)expect(1,cu,"number")cn,co=bit32.band(bit32.bxor(0x5,math.floor(cu/0x100000000)),0xFFFF),bit32.bxor(0xDEECE66D,math.floor(cu))end;ct(os.epoch"utc"*tonumber(tostring(next):match("%x+")or"1",16))return cq,ct end;do math.random,math.randomseed=makeRandom()end;function createLuaLib(process)local cv={}for z,i in ipairs{"assert","error","getmetatable","ipairs","next","pairs","pcall","rawequal","rawget","rawset","select","setmetatable","tonumber","tostring","type","_VERSION","xpcall","collectgarbage"}do cv[i]=_G[i]end;function cv.dofile(b7)if b7~=nil and type(b7)~="string"then error("bad argument #1 (expected string, got "..type(b7)..")",2)end;local g,o=loadfile(b7 or io.stdin:read("*a"),nil,_G)if not g then error(o,2)end;return g()end;local load,getfenv,setfenv,make_ENV=load,getfenv,setfenv,make_ENV;if _VERSION=="Lua 5.1"then function cv.load(l,m,n,e)return load(l,m,n,make_ENV(e or process.env))end;function cv.getfenv(f)local i;if f==nil then i=getfenv(2)elseif tonumber(f)and tonumber(f)>0 then i=getfenv(f+1)elseif type(f)=="function"then i=getfenv(f)else i=getfenv(f)end;local aA=getmetatable(f)if aA and aA.__env then return aA.__env else return i end end;function cv.setfenv(f,K)return setfenv(f,make_ENV(K))end else cv.load,cv.getfenv,cv.setfenv=function(l,m,n,e)return load(l,m,n,e or process.env)end,getfenv,setfenv end;function cv.loadfile(b7,n,e)if e==nil and type(n)=="table"then e,n=n,nil end;if type(b7)~="string"then error("bad argument #1 (expected string, got "..type(b7)..")",2)end;if n~=nil and type(n)~="string"then error("bad argument #2 (expected string, got "..type(n)..")",2)end;if e~=nil and type(e)~="table"then error("bad argument #3 (expected table, got "..type(e)..")",2)end;local a,o=do_syscall("open",b7,"rb")if not a then error(o,2)end;local bd=a.readAll()a.close()return load(bd,"@"..b7,n,e)end;function cv.print(...)local args=table.pack(...)args[args.n+1]="\n"return do_syscall("write",table.unpack(args,1,args.n+1))end;cv.coroutine=deepcopy(coroutine)cv.string=deepcopy(string)cv.table=deepcopy(table)cv.math=deepcopy(math)cv.bit32=deepcopy(bit32)cv.math.random,cv.math.randomseed=makeRandom()local cw=cv.coroutine.resume;cv.coroutine.resume=function(...)local a5=table.pack(cw(...))while a5.n==2 and a5[1]==true and a5[2]=="preempt"do a5=table.pack(cw(coroutine.yield("preempt")))end;return table.unpack(a5,1,a5.n)end;local cx=""local cy=setmetatable({close=function()end,lines=function(self,...)local args=table.pack(...)return function()return self:read(table.unpack(args,1,args.n))end end,read=function(self,a6,...)local bj,K;a6=a6 or"*l"if type(a6)=="number"then while#cx<a6 do cx=cx..do_syscall("read",a6)end elseif type(a6)=="string"then a6=a6:gsub("^%*","")if a6=="n"then while not cx:find("%d")do local bk=do_syscall("readline")if bk==nil then break end;cx=cx..bk.."\n"end elseif a6=="a"then while true do local bk=do_syscall("readline")if bk==nil then break end;cx=cx..bk.."\n"end elseif a6=="l"or a6=="L"then local bk=do_syscall("readline")if bk==nil then return nil end;cx=cx..bk.."\n"else error("bad argument (invalid format '"..a6 .."')",2)end else error("bad argument (expected string or number, got "..type(a6),2)end;if type(a6)=="number"then bj,K=cx:sub(1,a6),a6+1 elseif a6=="n"then bj,K=cx:match("(%d)()")elseif a6=="a"then bj,K=cx,#cx+1 elseif a6=="l"then bj,K=cx:match("(.*)\n()")else bj,K=cx:match("(.*\n)()")end;if not bj then return nil end;cx=cx:sub(K)if select("#",...)>0 then return bj,self:read(...)else return bj end end,seek=function()return nil,"Cannot seek default file"end,setvbuf=function()end},{__name="FILE*"})local cz=setmetatable({close=function()end,flush=function()end,seek=function()return nil,"Cannot seek default file"end,setvbuf=function()end,write=function(self,...)do_syscall("write",...)return self end},{__name="FILE*"})local cA=setmetatable({close=function()end,flush=function()end,seek=function()return nil,"Cannot seek default file"end,setvbuf=function()end,write=function(self,...)do_syscall("writeerr",...)return self end},{__name="FILE*"})local cB,cC=cy,cz;local cD={close=function(self)self._file.close()self._closed=true end,lines=function(self,...)local args=table.pack(...)return function()return self:read(table.unpack(args,1,args.n))end end,read=function(self,a6,...)local i;if a6==nil then a6="l"end;if type(a6)=="number"then i=self._file.read(a6)elseif type(a6)=="string"then a6=a6:gsub("^%*","")if a6=="a"then i=self._file.readAll()elseif a6=="l"then i=self._file.readLine(false)elseif a6=="L"then i=self._file.readLine(true)elseif a6=="n"then local bj,a9=""repeat a9=self._file.read(1)until a9:match("%d")while a9:match("%d")do bj,a9=bj..a9,self._file.read(1)end;i=tonumber(bj)else error("bad argument (invalid format '"..a6 .."')",2)end else error("bad argument (expected string or number, got "..type(a6)..")",2)end;if select("#",...)>0 then return i,self:read(...)else return i end end,seek=function(self,bi,U)if self._file.seek then return self._file.seek(bi,U)else return nil,"Cannot seek text file"end end,setvbuf=function()end}local cE={close=function(self)self._file.close()self._closed=true end,flush=function(self)self._file:flush()end,seek=function(self,bi,U)if self._file.seek then return self._file.seek(bi,U)else return nil,"Cannot seek text file"end end,setvbuf=function()end,write=function(self,...)self._file.write(...)return self end}cv.io={close=function(a)if a==nil then cC:close()elseif type(a)=="table"and getmetatable(a)and getmetatable(a).__name=="FILE*"then a:close()else error("bad argument #1 (expected FILE*, got "..type(a)..")",2)end end,flush=function()return cC:flush()end,input=function(a)if a==nil then return cB elseif type(a)=="string"then local ah,o=io.open(a,"r")if not ah then error(o,2)end;cB=ah elseif type(a)=="table"and getmetatable(a)and getmetatable(a).__name=="FILE*"then cB=a else error("bad argument #1 (expected string or FILE*, got "..type(a)..")",2)end end,lines=function(cF,...)if cF==nil then return cB:lines(...)end;if type(cF)~="string"then error("bad argument #1 (expected string, got "..type(cF)..")",2)end;local ah,o=io.open(cF,"r")if not ah then error(o,2)end;local g=ah:lines(...)return function(...)local a5=table.pack(g(...))if a5.n==0 or a5[1]==nil then ah:close()end;return table.unpack(a5,1,a5.n)end end,open=function(cF,n)if type(cF)~="string"then error("bad argument #1 (expected string, got "..type(cF)..")",2)end;if type(n)~="string"then error("bad argument #2 (expected string, got "..type(n)..")",2)end;local a,o=do_syscall("open",cF,n)if not a then return nil,o elseif n:find("r")then return setmetatable({_file=a},{__index=cD,__name="FILE*"})else return setmetatable({_file=a},{__index=cE,__name="FILE*"})end end,output=function(a)if a==nil then return cC elseif type(a)=="string"then local ah,o=io.open(a,"w")if not ah then error(o,2)end;cC=ah elseif type(a)=="table"and getmetatable(a)and getmetatable(a).__name=="FILE*"then cC=a else error("bad argument #1 (expected string or FILE*, got "..type(a)..")",2)end end,popen=function(b7,n)expect(1,b7,"string")n=expect(2,n,"string","nil")or"r"if n~="r"and n~="w"and n~="rw"then error("bad argument #2 (invalid mode)",2)end;if n=="rw"then local cG,cH="",""local cI;local cJ={read=function(r)if cG==""then return nil elseif r then local bj=cG:sub(1,r)cG=cG:sub(r+1)return bj else local bj,K=cG:match"([^\n]*)\n*()"cG=cG:sub(K)return bj end end}local cK={write=function(bj)cG=cG..bj end,flush=function()end,close=function()local a_=do_syscall("getpinfo",cI)if not a_ then return end;repeat local as,cL=coroutine.yield()until as=="process_complete"and cL.pid==cI end}local cM={read=function(r)if cH==""then return nil elseif r then local bj=cH:sub(1,r)cH=cH:sub(r+1)return bj else local bj,K=cH:match"([^\n]*)\n*()"cH=cH:sub(K)return bj end end,readLine=function()local bj,K=cH:match"([^\n]*)\n*()"cH=cH:sub(K)return bj end,readAll=function()local bj=cH;cH=""return bj end,close=function()local a_=do_syscall("getpinfo",cI)if not a_ then return end;repeat local as,cL=coroutine.yield()until as=="process_complete"and cL.pid==cI end}local cN={write=function(bj)cH=cH..bj end}cI=do_syscall("fork",function()do_syscall("stdin",cJ)do_syscall("stdout",cN)do_syscall("exec","/bin/sh","-c",b7)end)return setmetatable({_file=cM},{__index=cD,__name="FILE*"}),setmetatable({_file=cK},{__index=cE,__name="FILE*"})else local cO=""local bf=false;local cI;local cP={read=function(r)if cO==""then if bf then return nil else return"e"end elseif r then local bj=cO:sub(1,r)cO=cO:sub(r+1)return bj else local bj,K=cO:match"([^\n]*\n?)()"cO=cO:sub(K)return bj end end,readLine=function()local bj,K=cO:match"([^\n]*\n?)()"cO=cO:sub(K)return bj end,readAll=function()local bj=cO;cO=""return bj end,close=function()bf=true;local a_=do_syscall("getpinfo",cI)if not a_ then return end;repeat local as,cL=coroutine.yield()until as=="process_complete"and cL.pid==cI end}local cQ={write=function(bj)cO=cO..bj end,flush=function()end,close=function()bf=true;local a_=do_syscall("getpinfo",cI)if not a_ then return end;repeat local as,cL=coroutine.yield()until as=="process_complete"and cL.pid==cI end}cI=do_syscall("fork",function()do_syscall(n=="r"and"stdout"or"stdin",n=="r"and cQ or cP)do_syscall("exec","/bin/sh","-c",b7)end)return n=="r"and setmetatable({_file=cP},{__index=cD,__name="FILE*"})or setmetatable({_file=cQ},{__index=cE,__name="FILE*"})end end,read=function(...)return cB:read(...)end,tmpfile=function()return io.open(os.tmpname(),"a")end,type=function(br)if type(br)=="table"and getmetatable(br)and getmetatable(br).__name=="FILE*"then if br._closed then return"closed file"else return"file"end else return nil end end,write=function(...)return cC:write(...)end,stdin=cy,stdout=cz,stderr=cA}local cR=os;cv.os={clock=function()return do_syscall("clock")end,date=function(a6,bZ)if type(a6)=="string"and a6:sub(1,1)=="?"then local bh=cR.date("!"..a6:sub(2),bZ or cR.epoch"ingame"/1000)if type(bh)=="table"then bh.year=bh.year-1970 end;return bh else return cR.date(a6,bZ)end end,difftime=function(cg,ab)return cg-ab end,execute=function(b7)do_syscall("exec","/bin/sh","-c",b7)end,exit=function(bl)do_syscall("exit",bl)end,getenv=function(m)expect(1,m,"string")local e=do_syscall("getenv")if not e then return nil end;return e[m]end,remove=function(b7)expect(1,b7,"string")local bb,o=do_syscall("remove",b7)if not bb then bb=nil end;return bb,o end,rename=function(bI,bJ)expect(1,bI,"string")expect(2,bJ,"string")local bb,o=do_syscall("rename",bI,bJ)if not bb then bb=nil end;return bb,o end,setlocale=function(cS)if cS then error("setlocale is not supported",2)else return"C"end end,time=function(t)if t=="ingame"then return cR.epoch"ingame"/1000 elseif t=="nano"then return ccemux and ccemux.nanoTime()or cR.epoch"nano"end;expect(1,t,"table","nil")if t then return cR.time(t)else return cR.epoch"utc"/1000 end end,tmpname=function()local m="/tmp/lua_"for w=1,6 do local r=math.random(1,64)m=m..("qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890._"):sub(r,r)end;return m end}cv.debug=deepcopy(debug)createRequire(process,cv)for h,i in pairs(cv)do if type(i)=="function"then pcall(setfenv,i,cv)pcall(debug.protect,i)elseif type(i)=="table"and h~="debug"then for z,ag in pairs(i)do if type(ag)=="function"then pcall(setfenv,ag,cv)pcall(debug.protect,ag)end end end end;return cv end;function terminal.makeTTY(term,u,cT)local a5={isTTY=true,flags={cbreak=false,delay=true,echo=true,keypad=false,nlcr=true,raw=false},cursor={x=1,y=1},cursorBlink=true,colors={fg='0',bg='f',bold=false},size={width=u,height=cT},dirtyLines={},palette={},dirtyPalette={},buffer="",preBuffer="",isLocked=false,isGraphics=false,textBuffer={},graphicsBuffer={},frontmostProcess=nil,processList={},eof=false,term=term}for q=1,cT do a5[q]={(' '):rep(u),('0'):rep(u),('f'):rep(u)}a5.dirtyLines[q]=true end;for w=0,15 do a5.palette[w]={_G.term.nativePaletteColor(2^w)}a5.dirtyPalette[w]=true end;return a5 end;do local cU,cV=term.getSize()TTY={terminal.makeTTY(term,cU,cV),terminal.makeTTY(term,cU,cV),terminal.makeTTY(term,cU,cV),terminal.makeTTY(term,cU,cV),terminal.makeTTY(term,cU,cV),terminal.makeTTY(term,cU,cV),terminal.makeTTY(term,cU,cV),terminal.makeTTY(term,cU,cV)}end;currentTTY=TTY[1]terminal.userTTYs={}do local r=args.console:match"^tty(%d+)$"if r then KERNEL.stdout,KERNEL.stderr,KERNEL.stdin=TTY[tonumber(r)],TTY[tonumber(r)],TTY[tonumber(r)]end end;keysHeld={ctrl=false,alt=false,shift=false}eventHooks.term_resize=eventHooks.term_resize or{}eventHooks.char=eventHooks.char or{}eventHooks.key=eventHooks.key or{}eventHooks.key_up=eventHooks.key_up or{}eventHooks.term_resize[#eventHooks.term_resize+1]=function()local ag,ah=term.getSize()for w=1,8 do terminal.resize(TTY[w],ag,ah)end end;eventHooks.char[#eventHooks.char+1]=function(as)if not currentTTY.isLocked then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer..as[2]else currentTTY.preBuffer=currentTTY.preBuffer..as[2]end;if currentTTY.flags.echo then terminal.write(currentTTY,as[2])terminal.redraw(currentTTY)end end end;eventHooks.key[#eventHooks.key+1]=function(as)if not currentTTY.isLocked then if as[2]==keys.enter then if currentTTY.flags.cbreak then currentTTY.buffer=currentTTY.buffer.."\n"else currentTTY.buffer=currentTTY.buffer..currentTTY.preBuffer.."\n"currentTTY.preBuffer=""end;if currentTTY.flags.echo then terminal.write(currentTTY,"\n")terminal.redraw(currentTTY)end elseif as[2]==keys.backspace then if currentTTY.flags.cbreak then elseif#currentTTY.preBuffer>0 then currentTTY.preBuffer=currentTTY.preBuffer:sub(1,-2)if currentTTY.flags.echo then terminal.write(currentTTY,"\b \b")terminal.redraw(currentTTY)end end end end;if as[2]==keys.leftCtrl or as[2]==keys.rightCtrl then keysHeld.ctrl=true elseif as[2]==keys.leftAlt or as[2]==keys.rightAlt then keysHeld.alt=true elseif as[2]==keys.leftShift or as[2]==keys.rightShift then keysHeld.shift=true end;if not currentTTY.flags.raw and currentTTY.frontmostProcess and keysHeld.ctrl and not keysHeld.alt and not keysHeld.shift then if as[2]==keys.c then syscalls.kill(KERNEL,nil,currentTTY.frontmostProcess.id,2)terminal.write(currentTTY,"^C")elseif as[2]==keys.backslash then syscalls.kill(KERNEL,nil,currentTTY.frontmostProcess.id,3)terminal.write(currentTTY,"^\\")elseif as[2]==keys.z then syscalls.kill(KERNEL,nil,currentTTY.frontmostProcess.id,19)terminal.write(currentTTY,"^Z")elseif as[2]==keys.d then currentTTY.eof=true;terminal.write(currentTTY,"^D")end end;if keysHeld.ctrl and keysHeld.alt and not keysHeld.shift then local cW=true;if as[2]==keys.one then currentTTY=TTY[1]elseif as[2]==keys.two then currentTTY=TTY[2]elseif as[2]==keys.three then currentTTY=TTY[3]elseif as[2]==keys.four then currentTTY=TTY[4]elseif as[2]==keys.five then currentTTY=TTY[5]elseif as[2]==keys.six then currentTTY=TTY[6]elseif as[2]==keys.seven then currentTTY=TTY[7]elseif as[2]==keys.eight then currentTTY=TTY[8]elseif as[2]==keys.left then for w=1,8 do if currentTTY==TTY[w]then currentTTY=TTY[(w+7)%8]break end end elseif as[2]==keys.right then for w=1,8 do if currentTTY==TTY[w]then currentTTY=TTY[(w+1)%8]break end end else cW=false end;if cW then terminal.redraw(currentTTY,true)end end end;eventHooks.key_up[#eventHooks.key_up+1]=function(as)if as[2]==keys.leftCtrl or as[2]==keys.rightCtrl then keysHeld.ctrl=false elseif as[2]==keys.leftAlt or as[2]==keys.rightAlt then keysHeld.alt=false elseif as[2]==keys.leftShift or as[2]==keys.rightShift then keysHeld.shift=false end end;function terminal.redraw(cX,bQ)if cX.process then cX.process.eventQueue[#cX.process.eventQueue+1]={"tty_redraw",{id=cX.id}}return elseif currentTTY~=cX and not cX.isMonitor then return end;local term=cX.term;local cO=cX;if cX.isLocked then if cX.isGraphics then term.setGraphicsMode(2)if term.setFrozen then term.setFrozen(true)end;if bQ then term.clear()term.drawPixels(0,0,cX.graphicsBuffer)for w=0,255 do term.setPaletteColor(w,cX.graphicsBuffer.palette[w][1],cX.graphicsBuffer.palette[w][2],cX.graphicsBuffer.palette[w][3])end else if cX.graphicsBuffer.frozen then if term.setFrozen then term.setFrozen(false)end;return end;for z,i in ipairs(cX.graphicsBuffer.dirtyRects)do if i.color then term.setPixel(i.x,i.y,i.color,i.width,i.height)else term.drawPixels(i.x,i.y,i)end end;for w in pairs(cX.graphicsBuffer.dirtyPalette)do term.setPaletteColor(w,cX.graphicsBuffer.palette[w][1],cX.graphicsBuffer.palette[w][2],cX.graphicsBuffer.palette[w][3])end end;if term.setFrozen then term.setFrozen(false)end;cO.dirtyRects,cO.dirtyPalette={},{}return end;if term.setGraphicsMode then term.setGraphicsMode(false)end;cO=cX.textBuffer elseif cX.isGraphics then term.setGraphicsMode(false)cX.isGraphics=false end;term.setCursorBlink(false)if bQ then term.clear()for q=1,cX.size.height do term.setCursorPos(1,q)term.blit(cO[q][1],cO[q][2],cO[q][3])end;for w=0,15 do term.setPaletteColor(2^w,cO.palette[w][1],cO.palette[w][2],cO.palette[w][3])end else for q in pairs(cO.dirtyLines)do if not cO[q]then error(debug.traceback(q))end;term.setCursorPos(1,q)if#cO[q][1]~=#cO[q][2]or#cO[q][2]~=#cO[q][3]then syslog.log({level="critical"},"Bug in text writer! Inequal lengths: "..#cO[q][1]..", "..#cO[q][2]..", "..#cO[q][3])error("Invalid lengths")end;term.blit(cO[q][1],cO[q][2],cO[q][3])end;for w in pairs(cO.dirtyPalette)do term.setPaletteColor(2^w,cO.palette[w][1],cO.palette[w][2],cO.palette[w][3])end end;term.setCursorPos(cO.cursor.x,cO.cursor.y)term.setCursorBlink(cO.cursorBlink)cO.dirtyLines,cO.dirtyPalette={},{}end;function terminal.resize(cX,u,cT)if u>cX.size.width then for q=1,cX.size.height do cX[q][1]=cX[q][1]..(' '):rep(u-cX.size.width)cX[q][2]=cX[q][2]..cX.colors.fg:rep(u-cX.size.width)cX[q][3]=cX[q][3]..cX.colors.bg:rep(u-cX.size.width)cX.dirtyLines[q]=true end;if cX.isLocked then if cX.isGraphics then for q=1,cX.size.height*9 do cX.graphicsBuffer[q]=cX.graphicsBuffer[q]..('\15'):rep((u-cX.size.width)*6)end;cX.graphicsBuffer.dirtyRects[#cX.graphicsBuffer.dirtyRects+1]={x=cX.size.width*6+1,y=1,width=(u-cX.size.width)*6,height=cX.size.height*9}else for q=1,cX.size.height do cX.textBuffer[q][1]=cX.textBuffer[q][1]..(' '):rep(u-cX.size.width)cX.textBuffer[q][2]=cX.textBuffer[q][2]..cX.textBuffer.colors.fg:rep(u-cX.size.width)cX.textBuffer[q][3]=cX.textBuffer[q][3]..cX.textBuffer.colors.bg:rep(u-cX.size.width)cX.textBuffer.dirtyLines[q]=true end end end elseif u<cX.size.width then for q=1,cX.size.height do cX[q][1]=cX[q][1]:sub(1,u)cX[q][2]=cX[q][2]:sub(1,u)cX[q][3]=cX[q][3]:sub(1,u)cX.dirtyLines[q]=true end;if cX.isLocked then if cX.isGraphics then for q=1,cX.size.height*9 do cX.graphicsBuffer[q]=cX.graphicsBuffer[q]:sub(1,u*6)end else for q=1,cX.size.height do cX.textBuffer[q][1]=cX.textBuffer[q][1]:sub(1,u)cX.textBuffer[q][2]=cX.textBuffer[q][2]:sub(1,u)cX.textBuffer[q][3]=cX.textBuffer[q][3]:sub(1,u)end end end end;cX.size.width=u;if cT>cX.size.height then for q=cX.size.height+1,cT do cX[q]={(' '):rep(u),cX.colors.fg:rep(u),cX.colors.bg:rep(u)}cX.dirtyLines[q]=true end;if cX.isLocked then if cX.isGraphics then for q=cX.size.height*9+1,cT*9 do cX.graphicsBuffer[q]=('\15'):rep(u*6)end;cX.graphicsBuffer.dirtyRects[#cX.graphicsBuffer.dirtyRects+1]={x=1,y=cX.size.height*9+1,width=cX.size.width*6,height=(cT-cX.size.height)*9}else for q=cX.size.height+1,cT do cX.textBuffer[q]={(' '):rep(u),cX.textBuffer.colors.fg:rep(u),cX.textBuffer.colors.bg:rep(u)}cX.textBuffer.dirtyLines[q]=true end end end elseif cT<cX.size.height then for q=cT+1,cX.size.height do cX[q]=nil;cX.dirtyLines[q]=nil end;if cX.isLocked then if cX.isGraphics then for q=cT*9+1,cX.size.height*9 do cX.graphicsBuffer[q]=nil end else for q=cT+1,cX.size.height do cX.textBuffer[q]=nil;cX.textBuffer.dirtyLines[q]=nil end end end end;cX.size.height=cT end;local function cY(cX)cX.cursor.y=cX.cursor.y+1;if cX.cursor.y>cX.size.height then for w=1,cX.size.height-1 do cX[w]=cX[w+1]cX.dirtyLines[w]=true end;cX[cX.size.height]={(' '):rep(cX.size.width),cX.colors.fg:rep(cX.size.width),cX.colors.bg:rep(cX.size.width)}cX.dirtyLines[cX.size.height]=true;cX.cursor.y=cX.size.height end end;local cZ={['@']=function(cX,aw)end,A=function(cX,aw)local E=aw[1]or 1;if E==0 then E=1 end;cX.cursor.y=math.max(cX.cursor.y-E,1)end,B=function(cX,aw)local E=aw[1]or 1;if E==0 then E=1 end;cX.cursor.y=math.min(cX.cursor.y+E,cX.size.height)end,C=function(cX,aw)local E=aw[1]or 1;if E==0 then E=1 end;cX.cursor.x=math.min(cX.cursor.x+E,cX.size.width)end,D=function(cX,aw)local E=aw[1]or 1;if E==0 then E=1 end;cX.cursor.x=math.max(cX.cursor.x-E,1)end,E=function(cX,aw)local E=aw[1]or 1;if E==0 then E=1 end;cX.cursor.y=math.min(cX.cursor.y+E,cX.size.height)cX.cursor.x=1 end,F=function(cX,aw)local E=aw[1]or 1;if E==0 then E=1 end;cX.cursor.y=math.max(cX.cursor.y-E,1)cX.cursor.x=1 end,G=function(cX,aw)local E=aw[1]or 1;if E==0 then E=1 end;cX.cursor.x=math.min(E,cX.size.width)end,H=function(cX,aw)local bk,a9=aw[1]or 1,aw[2]or 1;if bk==0 then bk=1 end;if a9==0 then a9=1 end;cX.cursor.x,cX.cursor.y=math.min(a9,cX.size.width),math.min(bk,cX.size.height)end,I=function(cX,aw)end,J=function(cX,aw)local r=aw[1]or 0;if r==0 then cX[cX.cursor.y][1]=cX[cX.cursor.y][1]:sub(1,cX.cursor.x-1)..(" "):rep(cX.size.width-cX.cursor.x)cX[cX.cursor.y][2]=cX[cX.cursor.y][2]:sub(1,cX.cursor.x-1)..cX.colors.fg:rep(cX.size.width-cX.cursor.x)cX[cX.cursor.y][3]=cX[cX.cursor.y][3]:sub(1,cX.cursor.x-1)..cX.colors.bg:rep(cX.size.width-cX.cursor.x)cX.dirtyLines[cX.cursor.y]=true;for q=cX.cursor.y+1,cX.size.height do cX[q][1]=(" "):rep(cX.size.width)cX[q][2]=cX.colors.fg:rep(cX.size.width)cX[q][3]=cX.colors.bg:rep(cX.size.width)cX.dirtyLines[q]=true end elseif r==1 then cX[cX.cursor.y][1]=(" "):rep(cX.cursor.x)..cX[cX.cursor.y][1]:sub(cX.cursor.x)cX[cX.cursor.y][2]=cX.colors.fg:rep(cX.cursor.x)..cX[cX.cursor.y][2]:sub(cX.cursor.x)cX[cX.cursor.y][3]=cX.colors.bg:rep(cX.cursor.x)..cX[cX.cursor.y][3]:sub(cX.cursor.x)cX.dirtyLines[cX.cursor.y]=true;for q=cX.cursor.y-1,1,-1 do cX[q][1]=(" "):rep(cX.size.width)cX[q][2]=cX.colors.fg:rep(cX.size.width)cX[q][3]=cX.colors.bg:rep(cX.size.width)cX.dirtyLines[q]=true end elseif r==2 then for q=1,cX.size.height do cX[q][1]=(" "):rep(cX.size.width)cX[q][2]=cX.colors.fg:rep(cX.size.width)cX[q][3]=cX.colors.bg:rep(cX.size.width)cX.dirtyLines[q]=true end end end,K=function(cX,aw)local r=aw[1]or 0;if r==0 then cX[cX.cursor.y][1]=cX[cX.cursor.y][1]:sub(1,cX.cursor.x-1)..(" "):rep(cX.size.width-cX.cursor.x)cX[cX.cursor.y][2]=cX[cX.cursor.y][2]:sub(1,cX.cursor.x-1)..cX.colors.fg:rep(cX.size.width-cX.cursor.x)cX[cX.cursor.y][3]=cX[cX.cursor.y][3]:sub(1,cX.cursor.x-1)..cX.colors.bg:rep(cX.size.width-cX.cursor.x)cX.dirtyLines[cX.cursor.y]=true elseif r==1 then cX[cX.cursor.y][1]=(" "):rep(cX.cursor.x)..cX[cX.cursor.y][1]:sub(cX.cursor.x)cX[cX.cursor.y][2]=cX.colors.fg:rep(cX.cursor.x)..cX[cX.cursor.y][2]:sub(cX.cursor.x)cX[cX.cursor.y][3]=cX.colors.bg:rep(cX.cursor.x)..cX[cX.cursor.y][3]:sub(cX.cursor.x)cX.dirtyLines[cX.cursor.y]=true elseif r==2 then cX[cX.cursor.y][1]=(" "):rep(cX.size.width)cX[cX.cursor.y][2]=cX.colors.fg:rep(cX.size.width)cX[cX.cursor.y][3]=cX.colors.bg:rep(cX.size.width)cX.dirtyLines[cX.cursor.y]=true end end,L=function(cX,aw)end,M=function(cX,aw)end,N=function(cX,aw)end,O=function(cX,aw)end,P=function(cX,aw)end,Q=function(cX,aw)end,R=function(cX,aw)end,S=function(cX,aw)local r=aw[1]or 0;if r==0 then r=1 end;for z=1,r do table.insert(cX,1,{(' '):rep(cX.size.width),cX.colors.fg:rep(cX.size.width),cX.colors.bg:rep(cX.size.width)})cX[cX.size.height+1]=nil end end,T=function(cX,aw)local r=aw[1]or 0;if r==0 then r=1 end;for z=1,r do table.remove(cX,1)cX[cX.size.height]={(' '):rep(cX.size.width),cX.colors.fg:rep(cX.size.width),cX.colors.bg:rep(cX.size.width)}end end,U=function(cX,aw)end,V=function(cX,aw)end,W=function(cX,aw)end,X=function(cX,aw)end,Y=function(cX,aw)end,Z=function(cX,aw)end,['[']=function(cX,aw)end,['\\']=function(cX,aw)end,[']']=function(cX,aw)end,['^']=function(cX,aw)end,['_']=function(cX,aw)end,['`']=function(cX,aw)end,a=function(cX,aw)end,b=function(cX,aw)end,c=function(cX,aw)end,d=function(cX,aw)end,e=function(cX,aw)end,f=function(cX,aw)end,g=function(cX,aw)end,h=function(cX,aw)if aw[1]==25 then cX.cursorBlink=true end end,i=function(cX,aw)end,j=function(cX,aw)end,k=function(cX,aw)end,l=function(cX,aw)if aw[1]==25 then cX.cursorBlink=false end end,m=function(cX,aw)local r,A=aw[1]or 0,aw[2]if r==0 then cX.colors.fg,cX.colors.bg,cX.colors.bold='0','f',false elseif r==1 then cX.colors.bold=true elseif r==7 or r==27 then cX.colors.fg,cX.colors.bg=cX.colors.bg,cX.colors.fg elseif r==22 then cX.colors.bold=false elseif r>=30 and r<=37 then cX.colors.fg=("%x"):format(15-(r-30)-(cX.colors.bold and 8 or 0))elseif r==39 then cX.colors.fg='0'elseif r>=40 and r<=47 then cX.colors.bg=("%x"):format(15-(r-40)-(cX.colors.bold and 8 or 0))elseif r==49 then cX.colors.bg='f'elseif r>=90 and r<=97 then cX.colors.fg=("%x"):format(15-(r-90)-8)elseif r>=100 and r<=107 then cX.colors.bg=("%x"):format(15-(r-100)-8)end;if A~=nil then if A==0 then cX.colors.fg,cX.colors.bg='0','f'elseif A==1 then cX.colors.bold=true elseif A==7 or A==27 then cX.colors.fg,cX.colors.bg=cX.colors.bg,cX.colors.fg elseif A==22 then cX.colors.bold=false elseif A>=30 and A<=37 then cX.colors.fg=("%x"):format(15-(A-30)-(cX.colors.bold and 8 or 0))elseif A==39 then cX.colors.fg='0'elseif A>=40 and A<=47 then cX.colors.bg=("%x"):format(15-(A-40)-(cX.colors.bold and 8 or 0))elseif A==49 then cX.colors.bg='f'elseif A>=90 and A<=97 then cX.colors.fg=("%x"):format(15-(A-90)-8)elseif A>=100 and A<=107 then cX.colors.bg=("%x"):format(15-(A-100)-8)end end end,n=function(cX,aw)end,o=function(cX,aw)end}for w=0x70,0x7F do cZ[string.char(w)]=function(cX,aw)end end;function terminal.write(cX,c_)local ax,S=1,0;local function d0(p)if S==0 then ax,S=p,0;return end;while cX.cursor.x+S>cX.size.width do cX[cX.cursor.y][1]=cX[cX.cursor.y][1]:sub(1,cX.cursor.x-1)..c_:sub(ax,ax+cX.size.width-cX.cursor.x)cX[cX.cursor.y][2]=cX[cX.cursor.y][2]:sub(1,cX.cursor.x-1)..cX.colors.fg:rep(cX.size.width-cX.cursor.x+1)cX[cX.cursor.y][3]=cX[cX.cursor.y][3]:sub(1,cX.cursor.x-1)..cX.colors.bg:rep(cX.size.width-cX.cursor.x+1)cX.dirtyLines[cX.cursor.y]=true;ax=ax+cX.size.width-cX.cursor.x+1;S=S-(cX.size.width-cX.cursor.x+1)cX.cursor.x=1;cY(cX)end;cX[cX.cursor.y][1]=cX[cX.cursor.y][1]:sub(1,cX.cursor.x-1)..c_:sub(ax,ax+S-1)..cX[cX.cursor.y][1]:sub(cX.cursor.x+S)cX[cX.cursor.y][2]=cX[cX.cursor.y][2]:sub(1,cX.cursor.x-1)..cX.colors.fg:rep(S)..cX[cX.cursor.y][2]:sub(cX.cursor.x+S)cX[cX.cursor.y][3]=cX[cX.cursor.y][3]:sub(1,cX.cursor.x-1)..cX.colors.bg:rep(S)..cX[cX.cursor.y][3]:sub(cX.cursor.x+S)cX.dirtyLines[cX.cursor.y]=true;cX.cursor.x=cX.cursor.x+S;ax,S=p,0 end;local d1=0;local aw,d2;for p,a9,r in c_:gmatch"()(.)()"do if d1==0 then if a9=='\a'then d0(r)elseif a9=='\b'then d0(r)if cX.cursor.x==1 then if cX.cursor.y>1 then cX.cursor.x,cX.cursor.y=cX.size.width,cX.cursor.y-1 end else cX.cursor.x=cX.cursor.x-1 end elseif a9=='\t'then d0(r)cX.cursor.x=math.floor(cX.cursor.x/8)*8+8;if cX.cursor.x>cX.size.width then cX.cursor.x=1;cY(cX)end elseif a9=='\n'then d0(r)cY(cX)if cX.flags.nlcr then cX.cursor.x=1 end elseif a9=='\f'then d0(r)cY(cX)elseif a9=='\r'then d0(r)cX.cursor.x=1 elseif a9=='\27'then d1=1 else S=S+1 end elseif d1==1 then if false then elseif a9=='['then d1=2;aw,d2={},0 elseif a9==']'then if c_:byte(r)==0x50 then d1=4;aw={}else d1=3;aw,d2={},0 end else d0(r)d1=0 end elseif d1==2 then if a9>='@'and a9<='\127'then d0(r)aw[#aw+1]=d2;cZ[a9](cX,aw)d1=0 elseif a9>='0'and a9<='?'then if a9<='9'then d2=d2*10+tonumber(a9)elseif a9==';'then aw[#aw+1],d2=d2,0 end else d0(r)d1=0 end elseif d1==3 then if a9=='\\'and c_:byte(p-1)=='\27'then d0(r)d1=0 end elseif d1==4 then if#aw==0 then aw[1]=tonumber(a9,16)or 0 elseif#aw==1 and not d2 then d2=(tonumber(a9,16)or 0)*16 elseif#aw==1 then aw[2],d2=d2+(tonumber(a9,16)or 0),nil elseif#aw==2 and not d2 then d2=(tonumber(a9,16)or 0)*16 elseif#aw==2 then aw[3],d2=d2+(tonumber(a9,16)or 0),nil elseif#aw==3 and not d2 then d2=(tonumber(a9,16)or 0)*16 elseif#aw==3 then d0(r)aw[4],d2=d2+(tonumber(a9,16)or 0),nil;cX.palette[aw[1]]={aw[2]/255,aw[3]/255,aw[4]/255}cX.dirtyPalette[aw[1]]=true;d1=0 end end end;d0()end;function syscalls.write(process,ar,...)if not process.stdout then return end;local function d3(t)if process.stdout.isTTY then terminal.write(process.stdout,t)else process.stdout.write(t)end end;local args=table.pack(...)for w=1,args.n do if w>1 then d3("\t")end;d3(tostring(args[w]))end;if process.stdout.isTTY then terminal.redraw(process.stdout)end end;function syscalls.writeerr(process,ar,...)if not process.stderr then return end;local function d3(t)if process.stderr.isTTY then terminal.write(process.stderr,t)else process.stderr.write(t)end end;local args=table.pack(...)for w=1,args.n do if w>1 then d3("\t")end;d3(tostring(args[w]))end;if process.stderr.isTTY then terminal.redraw(process.stderr)end end;function syscalls.read(process,ar,r)expect(1,r,"number")if process.stdin then if process.stdin.eof then process.stdin.eof=false;return nil end;while#process.stdin.buffer<r do if process.stdin.eof then process.stdin.eof=false;return nil end;if process.stdin.isTTY and not process.stdin.flags.delay then return nil end;if process.stdin.read then local bj=process.stdin.read(r-#process.stdin.buffer)if not bj then return nil end;process.stdin.buffer=process.stdin.buffer..bj else return kSyscallYield,"read",r end end;local bj=process.stdin.buffer:sub(1,r-1)process.stdin.buffer=process.stdin.buffer:sub(r)return bj else return nil end end;function syscalls.readline(process,ar)if process.stdin then if process.stdin.eof then process.stdin.eof=false;return nil end;while not process.stdin.buffer:find("\n")do if process.stdin.eof then process.stdin.eof=false;return nil end;if process.stdin.isTTY and not process.stdin.flags.delay then return nil end;if process.stdin.read then local bj=process.stdin.read()if not bj then return nil end;process.stdin.buffer=process.stdin.buffer..bj else return kSyscallYield,"readline"end end;local r=process.stdin.buffer:find("\n")local bj=process.stdin.buffer:sub(1,r-1)process.stdin.buffer=process.stdin.buffer:sub(r+1)return bj else return nil end end;function syscalls.termctl(process,ar,d4)expect(1,d4,"table","nil")if not process.stdout or not process.stdout.isTTY then return nil end;if process~=process.stdout.frontmostProcess then syscalls.kill(KERNEL,nil,process.id,22)if process.paused then return kSyscallYield,"termctl",d4 end end;if d4 then expect.field(d4,"cbreak","boolean","nil")expect.field(d4,"delay","boolean","nil")expect.field(d4,"echo","boolean","nil")expect.field(d4,"keypad","boolean","nil")expect.field(d4,"nlcr","boolean","nil")expect.field(d4,"raw","boolean","nil")for h,i in pairs(d4)do if process.stdout.flags[h]~=nil then process.stdout.flags[h]=i end end end;local t=deepcopy(process.stdout.flags)t.hasgfx=term.getGraphicsMode~=nil;return t end;function terminal.openterm(cX,process)if cX.isLocked then return nil,"Terminal already in use"end;local S=cX.size;local cO={cursor={x=1,y=1},cursorBlink=false,colors={fg='0',bg='f'},palette={},dirtyLines={},dirtyPalette={}}cX.textBuffer=cO;cX.isLocked=true;cX.isGraphics=false;for q=1,S.height do cO[q]={(' '):rep(S.width),('0'):rep(S.width),('f'):rep(S.width)}cO.dirtyLines[q]=true end;for w=0,15 do cO.palette[w]={term.nativePaletteColor(2^w)}cO.dirtyPalette[w]=true end;cX.processList[#cX.processList+1]=cX.frontmostProcess;cX.frontmostProcess=process;local d5=setmetatable({},{__name="Terminal"})local d6=terminal.redraw;local expect=expect;function d5.close()if not d5 then error("terminal is already closed",2)end;d5=nil;cX.isLocked=false;cX.frontmostProcess=table.remove(cX.processList)d6(cX,true)end;function d5.write(c_)if not d5 then error("terminal is already closed",2)end;c_=tostring(c_)expect(1,c_,"string")if cO.cursor.y<1 or cO.cursor.y>S.height then return elseif cO.cursor.x>S.width or cO.cursor.x+#c_<1 then cO.cursor.x=cO.cursor.x+#c_;return elseif cO.cursor.x<1 then c_=c_:sub(-cO.cursor.x+2)cO.cursor.x=1 end;local d7=#c_;if cO.cursor.x+#c_>S.width then c_=c_:sub(1,S.width-cO.cursor.x+1)end;cO[cO.cursor.y][1]=cO[cO.cursor.y][1]:sub(1,cO.cursor.x-1)..c_..cO[cO.cursor.y][1]:sub(cO.cursor.x+#c_)cO[cO.cursor.y][2]=cO[cO.cursor.y][2]:sub(1,cO.cursor.x-1)..cO.colors.fg:rep(#c_)..cO[cO.cursor.y][2]:sub(cO.cursor.x+#c_)cO[cO.cursor.y][3]=cO[cO.cursor.y][3]:sub(1,cO.cursor.x-1)..cO.colors.bg:rep(#c_)..cO[cO.cursor.y][3]:sub(cO.cursor.x+#c_)cO.cursor.x=cO.cursor.x+d7;cO.dirtyLines[cO.cursor.y]=true end;function d5.blit(c_,d8,d9)if not d5 then error("terminal is already closed",2)end;c_=tostring(c_)expect(1,c_,"string")expect(2,d8,"string")expect(3,d9,"string")if#c_~=#d8 or#d8~=#d9 then error("Arguments must be the same length",2)end;if cO.cursor.y<1 or cO.cursor.y>S.height then return elseif cO.cursor.x>S.width or cO.cursor.x<1-#c_ then cO.cursor.x=cO.cursor.x+#c_;d6(cX)return elseif cO.cursor.x<1 then c_,d8,d9=c_:sub(-cO.cursor.x+2),d8:sub(-cO.cursor.x+2),d9:sub(-cO.cursor.x+2)cO.cursor.x=1 end;local d7=#c_;if cO.cursor.x+#c_>S.width then c_,d8,d9=c_:sub(1,S.width-cO.cursor.x+1),d8:sub(1,S.width-cO.cursor.x+1),d9:sub(1,S.width-cO.cursor.x+1)end;cO[cO.cursor.y][1]=cO[cO.cursor.y][1]:sub(1,cO.cursor.x-1)..c_..cO[cO.cursor.y][1]:sub(cO.cursor.x+#c_)cO[cO.cursor.y][2]=cO[cO.cursor.y][2]:sub(1,cO.cursor.x-1)..d8 ..cO[cO.cursor.y][2]:sub(cO.cursor.x+#d8)cO[cO.cursor.y][3]=cO[cO.cursor.y][3]:sub(1,cO.cursor.x-1)..d9 ..cO[cO.cursor.y][3]:sub(cO.cursor.x+#d9)cO.cursor.x=cO.cursor.x+d7;cO.dirtyLines[cO.cursor.y]=true end;function d5.clear()if not d5 then error("terminal is already closed",2)end;for q=1,S.height do cO[q]={(' '):rep(S.width),cO.colors.fg:rep(S.width),cO.colors.bg:rep(S.width)}cO.dirtyLines[q]=true end end;function d5.clearLine()if not d5 then error("terminal is already closed",2)end;if cO.cursor.y>=1 and cO.cursor.y<=S.height then cO[cO.cursor.y]={(' '):rep(S.width),cO.colors.fg:rep(S.width),cO.colors.bg:rep(S.width)}cO.dirtyLines[cO.cursor.y]=true end end;function d5.getCursorPos()if not d5 then error("terminal is already closed",2)end;return cO.cursor.x,cO.cursor.y end;function d5.setCursorPos(da,db)if not d5 then error("terminal is already closed",2)end;expect(1,da,"number")expect(2,db,"number")if da==cO.cursor.x and db==cO.cursor.y then return end;cO.cursor.x,cO.cursor.y=math.floor(da),math.floor(db)end;function d5.getCursorBlink()if not d5 then error("terminal is already closed",2)end;return cO.cursorBlink end;function d5.setCursorBlink(ab)if not d5 then error("terminal is already closed",2)end;expect(1,ab,"boolean")cO.cursorBlink=ab end;function d5.isColor()if not d5 then error("terminal is already closed",2)end;return true end;function d5.getSize()if not d5 then error("terminal is already closed",2)end;return S.width,S.height end;function d5.scroll(dc)if not d5 then error("terminal is already closed",2)end;expect(1,dc,"number")if math.abs(dc)>=S.width then for q=1,S.height do cO[q]={(' '):rep(S.width),cO.colors.fg:rep(S.width),cO.colors.bg:rep(S.width)}end elseif dc>0 then for w=dc+1,S.height do cO[w-dc]=cO[w]end;for w=S.height-dc+1,S.height do cO[w]={(' '):rep(S.width),cO.colors.fg:rep(S.width),cO.colors.bg:rep(S.width)}end elseif dc<0 then for w=1,S.height+dc do cO[w-dc]=cO[w]end;for w=1,-dc do cO[w]={(' '):rep(S.width),cO.colors.fg:rep(S.width),cO.colors.bg:rep(S.width)}end else return end;for w=1,S.height do cO.dirtyLines[w]=true end end;function d5.getTextColor()if not d5 then error("terminal is already closed",2)end;return tonumber(cO.colors.fg,16)end;function d5.setTextColor(dd)if not d5 then error("terminal is already closed",2)end;expect(1,dd,"number")expect.range(dd,0,15)cO.colors.fg=("%x"):format(dd)end;function d5.getBackgroundColor()if not d5 then error("terminal is already closed",2)end;return tonumber(cO.colors.bg,16)end;function d5.setBackgroundColor(dd)if not d5 then error("terminal is already closed",2)end;expect(1,dd,"number")expect.range(dd,0,15)cO.colors.bg=("%x"):format(dd)end;function d5.getPaletteColor(dd)if not d5 then error("terminal is already closed",2)end;expect(1,dd,"number")expect.range(dd,0,15)return table.unpack(cO.palette[math.floor(dd)])end;function d5.setPaletteColor(dd,bk,de,ab)if not d5 then error("terminal is already closed",2)end;expect(1,dd,"number")expect(2,bk,"number")if de==nil and ab==nil then bk,de,ab=bit32.band(bit32.rshift(bk,16),0xFF)/255,bit32.band(bit32.rshift(bk,8),0xFF)/255,bit32.band(bk,0xFF)/255 end;expect(3,de,"number")expect(4,ab,"number")expect.range(dd,0,15)if bk<0 or bk>1 then error("bad argument #2 (value out of range)",2)end;if de<0 or de>1 then error("bad argument #3 (value out of range)",2)end;if ab<0 or ab>1 then error("bad argument #4 (value out of range)",2)end;cO.palette[math.floor(dd)]={bk,de,ab}cO.dirtyPalette[math.floor(dd)]=true end;function d5.getLine(q)if not d5 then error("terminal is already closed",2)end;expect(1,q,"number")local N=cO[q]return N and table.unpack(N,1,3)end;for z,i in pairs(d5)do setfenv(i,process.env)debug.protect(i)end;d5.isColour=d5.isColor;d5.getTextColour=d5.getTextColor;d5.setTextColour=d5.setTextColor;d5.getBackgroundColour=d5.getBackgroundColor;d5.setBackgroundColour=d5.setBackgroundColor;d5.getPaletteColour=d5.getPaletteColor;d5.setPaletteColour=d5.setPaletteColor;process.dependents[#process.dependents+1]={gc=function()if d5 then return d5.close()end end}d6(cX,true)return d5 end;function syscalls.openterm(process,ar)if not process.stdout or not process.stdout.isTTY then return nil,"No valid TTY attached"end;if process~=process.stdout.frontmostProcess then syscalls.kill(KERNEL,nil,process.id,22)if process.paused then return kSyscallYield,"openterm"end end;return terminal.openterm(process.stdout,process)end;function terminal.opengfx(cX,process)if not term.drawPixels then return nil,"Graphics mode not supported"end;if cX.isLocked then return nil,"Terminal already in use"end;local S=cX.size;local cO={palette={},dirtyRects={},dirtyPalette={},frozen=false}cX.graphicsBuffer=cO;cX.isLocked=true;cX.isGraphics=true;for q=1,S.height*9 do cO[q]=('\15'):rep(S.width*6)end;for w=0,15 do cO.palette[w]={term.nativePaletteColor(2^w)}cO.dirtyPalette[w]=true end;for w=16,255 do cO.palette[w]={0,0,0}cO.dirtyPalette[w]=true end;cX.processList[#cX.processList+1]=cX.frontmostProcess;cX.frontmostProcess=process;local d5=setmetatable({},{__name="GFXTerminal"})local d6=terminal.redraw;local expect=expect;function d5.close()if not d5 then error("terminal is already closed",2)end;d5=nil;cX.isLocked=false;cX.frontmostProcess=table.remove(cX.processList)d6(cX,true)end;function d5.getSize()return S.width*6,S.height*9 end;function d5.clear()if not d5 then error("terminal is already closed",2)end;for q=1,S.height*9 do cO[q]=('\15'):rep(S.width*6)end;d6(cX,true)end;function d5.getPixel(p,q)if not d5 then error("terminal is already closed",2)end;expect(1,p,"number")expect(2,q,"number")expect.range(p,0,S.width*6-1)expect.range(q,0,S.height*9-1)p,q=math.floor(p),math.floor(q)return cO[q+1]:byte(p+1)end;function d5.setPixel(p,q,dd)if not d5 then error("terminal is already closed",2)end;expect(1,p,"number")expect(2,q,"number")expect(3,dd,"number")expect.range(p,0,S.width*6-1)expect.range(q,0,S.height*9-1)expect.range(dd,0,255)p,q=math.floor(p),math.floor(q)cO[q+1]=cO[q+1]:sub(1,p)..string.char(dd)..cO[q+1]:sub(p+2)cO.dirtyRects[#cO.dirtyRects+1]={x=p,y=q,color=dd}end;function d5.getPixels(p,q,u,cT,df)if not d5 then error("terminal is already closed",2)end;expect(1,p,"number")expect(2,q,"number")expect(3,u,"number")expect(4,cT,"number")expect(5,df,"boolean","nil")expect.range(u,0)expect.range(cT,0)p,q=math.floor(p),math.floor(q)local t={}for dg=1,cT do if df then t[dg]=cO[q+dg]:sub(p+1,p+u)else t[dg]={cO[q+dg]:sub(p+1,p+u):byte(1,-1)}end end;return t end;function d5.drawPixels(p,q,bd,u,cT)if not d5 then error("terminal is already closed",2)end;expect(1,p,"number")expect(2,q,"number")expect(3,bd,"table","number")local dh=type(bd)=="number"expect(4,u,"number",not dh and"nil"or nil)expect(5,cT,"number",not dh and"nil"or nil)expect.range(p,0,S.width*6-1)expect.range(q,0,S.height*9-1)if u then expect.range(u,0)end;if cT then expect.range(cT,0)end;if dh then expect.range(bd,0,255)end;if u==0 or cT==0 then return end;p,q=math.floor(p),math.floor(q)if u and p+u>=S.width*6 then u=S.width*6-p end;cT=cT or#bd;local di={x=p,y=q,width=u,height=cT}for dg=1,cT do if q+dg>S.height*9 then break end;if dh then local bj=string.char(bd):rep(u)cO[q+dg]=cO[q+dg]:sub(1,p)..bj..cO[q+dg]:sub(p+u+1)di[dg]=bj elseif bd[dg]~=nil then if type(bd[dg])~="table"and type(bd[dg])~="string"then error("bad argument #3 to 'drawPixels' (invalid row "..dg..")",2)end;local u=u or#bd[dg]if p+u>=S.width*6 then u=S.width*6-p end;local bj;if type(bd[dg])=="string"then bj=bd[dg]if#bj<u then bj=bj..('\15'):rep(u-#bj)elseif#bj>u then bj=bj:sub(1,u)end else bj=""for dj=1,u do bj=bj..string.char(bd[dg][dj]or cO[q+dg]:byte(p+dj))end end;cO[q+dg]=cO[q+dg]:sub(1,p)..bj..cO[q+dg]:sub(p+u+1)di[dg]=bj end end;cO.dirtyRects[#cO.dirtyRects+1]=di end;function d5.getFrozen()if not d5 then error("terminal is already closed",2)end;return cO.frozen end;function d5.setFrozen(f)if not d5 then error("terminal is already closed",2)end;expect(1,f,"boolean")cO.frozen=f end;function d5.getPaletteColor(dd)if not d5 then error("terminal is already closed",2)end;expect(1,dd,"number")expect.range(dd,0,255)return table.unpack(cO.palette[dd])end;function d5.setPaletteColor(dd,bk,de,ab)if not d5 then error("terminal is already closed",2)end;expect(1,dd,"number")expect(2,bk,"number")if de==nil and ab==nil then bk,de,ab=bit32.band(bit32.rshift(bk,16),0xFF)/255,bit32.band(bit32.rshift(bk,8),0xFF)/255,bit32.band(bk,0xFF)/255 end;expect(3,de,"number")expect(4,ab,"number")expect.range(bk,0,1)expect.range(de,0,1)expect.range(ab,0,1)expect.range(dd,0,255)cO.palette[dd]={bk,de,ab}cO.dirtyPalette[dd]=true end;for z,i in pairs(d5)do setfenv(i,process.env)debug.protect(i)end;d5.getPaletteColour=d5.getPaletteColor;d5.setPaletteColour=d5.setPaletteColor;process.dependents[#process.dependents+1]={gc=function()if d5 then return d5.close()end end}d6(cX,true)return d5 end;function syscalls.opengfx(process,ar)if not process.stdout or not process.stdout.isTTY then return nil,"No valid TTY attached"end;if process~=process.stdout.frontmostProcess then syscalls.kill(KERNEL,nil,process.id,22)if process.paused then return kSyscallYield,"openterm"end end;return terminal.opengfx(process.stdout,process)end;function syscalls.mktty(process,ar,u,cT)expect(1,u,"number")expect(2,cT,"number")expect.range(u,1)expect.range(cT,1)local cX=terminal.makeTTY(term,u,cT)cX.id=math.random(0,0x7FFFFFFF)cX.process=process;local a5=setmetatable({},{__index=cX,__metatable={}})terminal.userTTYs[a5]=cX;process.dependents[#process.dependents+1]={gc=function()terminal.userTTYs[a5]=nil end}return a5 end;function syscalls.stdin(process,ar,dk)expect(1,dk,"number","table","string","nil")if process.stdin and process.stdin.isTTY and process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)process.stdin.preBuffer=""end;if type(dk)=="number"then process.stdin=TTY[dk]elseif type(dk)=="string"then local dl=hardware.get(dk)if not dl then error("bad argument #1 (no such device)",2)end;if not dl.internalState.tty then error("bad argument #1 (no TTY available on device)",2)end;dk=dl.internalState.tty;if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)dk.processList[#dk.processList+1]=dk.frontmostProcess;dk.frontmostProcess=process end;process.stdin=dk elseif dk==nil then process.stdin=nil else if dk.isTTY then dk=terminal.userTTYs[dk]if not dk then error("bad argument #1 (invalid TTY)",2)end;if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)dk.processList[#dk.processList+1]=dk.frontmostProcess;dk.frontmostProcess=process;dk.preBuffer=""end else expect.field(dk,"read","function")local dm=dk.read;dk={buffer="",read=function(...)local bb,v=userModeCallback(process,dm,...)if bb then return v else error(v,2)end end}end;process.stdin=dk end end;function syscalls.stdout(process,ar,dk)expect(1,dk,"number","table","string","nil")if process.stdout and process.stdout.isTTY and process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.stdout.frontmostProcess.name)end end;if type(dk)=="number"then process.stdout=TTY[dk]elseif type(dk)=="string"then local dl=hardware.get(dk)if not dl then error("bad argument #1 (no such device)",2)end;if not dl.internalState.tty then error("bad argument #1 (no TTY available on device)",2)end;dk=dl.internalState.tty;if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)dk.processList[#dk.processList+1]=dk.frontmostProcess;dk.frontmostProcess=process;if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.name)end end;process.stdout=dk elseif dk==nil then process.stdout=nil else if dk.isTTY then dk=terminal.userTTYs[dk]if not dk then error("bad argument #1 (invalid TTY)",2)end;if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)dk.processList[#dk.processList+1]=dk.frontmostProcess;dk.frontmostProcess=process;if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.name)end end else expect.field(dk,"write","function")local d3=dk.write;dk={write=function(...)local bb,v=userModeCallback(process,d3,...)if bb then return v else error(v,2)end end}end;process.stdout=dk end end;function syscalls.stderr(process,ar,dk)expect(1,dk,"number","table","string","nil")if process.stderr and process.stderr.isTTY and process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)end;if type(dk)=="number"then process.stderr=TTY[dk]elseif type(dk)=="string"then local dl=hardware.get(dk)if not dl then error("bad argument #1 (no such device)",2)end;if not dl.internalState.tty then error("bad argument #1 (no TTY available on device)",2)end;dk=dl.internalState.tty;if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)dk.processList[#dk.processList+1]=dk.frontmostProcess;dk.frontmostProcess=process end;process.stderr=dk elseif dk==nil then process.stderr=nil else if dk.isTTY then dk=terminal.userTTYs[dk]if not dk then error("bad argument #1 (invalid TTY)",2)end;if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)dk.processList[#dk.processList+1]=dk.frontmostProcess;dk.frontmostProcess=process end else expect.field(dk,"write","function")local d3=dk.write;dk={write=function(...)local bb,v=userModeCallback(process,d3,...)if bb then return v else error(v,2)end end}end;process.stderr=dk end end;function syscalls.istty(process,ar)return process.stdin and process.stdin.isTTY,process.stdout and process.stdout.isTTY end;function syscalls.termsize(process,ar)if not process.stdout or not process.stdout.isTTY then return nil,nil end;return process.stdout.size.width,process.stdout.size.height end;syslogs={default={stream={},tty=KERNEL.stdout,tty_level=args.loglevel,colorize=true}}local dn={[0]="Debug","Info","Notice","Warning","Error","Critical","Panic"}local dp={}for w=0,#dn do dp[dn[w]:lower()]=w end;local dq={[0]='\27[90m','\27[97m','\27[36m','\27[93m','\27[31m','\27[95m','\27[96m'}local function dr(t,an,w,aa)if w>=aa then return tostring(t[w])else return tostring(t[w])..an..dr(t,an,w+1,aa)end end;function syscalls.syslog(process,ar,by,...)local args=table.pack(...)if type(by)=="table"then expect.field(by,"name","string","nil")expect.field(by,"category","string","nil")expect.field(by,"level","number","string","nil")expect.field(by,"time","number","nil")expect.field(by,"process","number","nil")expect.field(by,"thread","number","nil")expect.field(by,"module","string","nil")expect.field(by,"traceback","boolean","nil")if type(by.level)=="string"then by.level=dp[by.level:lower()]if not by.level then error("bad field 'level' (invalid name)",0)end elseif by.level and(by.level<0 or by.level>#dn)then error("bad field 'level' (level out of range)",0)end;by.name=by.name or"default"by.process=by.process or process.id;by.thread=by.thread or ar and ar.id;by.level=by.level or 1;by.time=by.time or os.epoch"utc"else local r=args.n;table.insert(args,1,by)args.n=r+1;by={process=process.id,thread=ar and ar.id,level=1,name="default",time=os.epoch"utc"}end;local ds=syslogs[by.name]if ds==nil then error("No such log named "..by.name,0)end;local af;for w=1,args.n do af=(w==1 and""or af.." ")..serialize(args[w])end;if ds.file then ds.file.writeLine(("[%s]%s %s[%d%s]%s [%s]: %s"):format(os.date("%b %d %X",by.time/1000),by.category and" <"..by.category..">"or"",processes[by.process]and processes[by.process].name or"(unknown)",by.process,by.thread and":"..by.thread or"",by.module and" ("..by.module..")"or"",dn[by.level],dr(args," ",1,args.n)))ds.file.flush()end;if ds.stream then by.message=af;for z,i in pairs(ds.stream)do local bb=true;if i.filter then local m,dt,aC=""local w=1;local du,dv=false,false;while w<#i.filter do if dt==nil then m,w=i.filter:match("(%a+)%s*()",w)if by[m]==nil then bb=false;break end;dt=""elseif aC==nil then local b1=i.filter:sub(w,w+1)if b1=="=="or b1=="!="or b1=="=%"or b1=="!%"or b1=="<="or b1==">="then dt=b1 elseif b1=="~="then dt="!="elseif b1=="~%"then dt="!%"elseif i.filter:sub(w,w)=='<'or i.filter:sub(w,w)=='>'then dt=i.filter:sub(w,w)else bb=false;break end;aC=""else local a9=i.filter:sub(w,w)if du then if a9==du and not dv then du,dv=false,false else aC=aC..a9;if not dv and a9=='\\'then dv=true else dv=false end end elseif a9=='"'or a9=="'"then du=a9 elseif a9=='|'or a9==';'then if dt=="=="and by[m]==aC or dt=="!="and by[m]~=aC or dt=="=%"and by[m]:match(aC)or dt=="!%"and not by[m]:match(aC)or dt=="<"and(tonumber(by[m])or 0)<(tonumber(aC)or 0)or dt=="<="and(tonumber(by[m])or 0)<=(tonumber(aC)or 0)or dt==">="and(tonumber(by[m])or 0)>=(tonumber(aC)or 0)or dt==">"and(tonumber(by[m])or 0)>(tonumber(aC)or 0)then if a9=='|'then w=i.filter:match("[^;]*;+()",w)if w==nil then break end;w=w-1 end;m,dt,aC=""du,dv=false,false else bb=a9=='|'aC=""if not bb then break end end elseif not(a9==' 'and aC=="")then aC=aC..a9 end;w=w+1 end end;if du then bb=false;break end end;if bb then process.queueEvent(i.pid,"syslog",i.id,by)end end end;if ds.tty and ds.tty_level<=by.level then if ds.tty.isTTY then local a0=dr(args," ",1,args.n)if ds.colorize and by.traceback then a0=a0:gsub("\t","  "):gsub("([^\n]+):(%d+):","\27[96m%1\27[37m:\27[95m%2\27[37m:"):gsub("'([^']+)'\n","\27[93m'%1'\27[37m\n")end;terminal.write(ds.tty,("%s[%s]%s %s[%d%s]%s [%s]: %s%s\n"):format(ds.colorize and dq[by.level]or"",os.date("%b %d %X",by.time/1000),by.category and" <"..by.category..">"or"",processes[by.process]and processes[by.process].name or"(unknown)",by.process,by.thread and":"..by.thread or"",by.module and" ("..by.module..")"or"",dn[by.level],a0,ds.colorize and"\27[0m"or""))terminal.redraw(ds.tty)else end end end;function syscalls.mklog(process,ar,m,dw,b7)expect(1,m,"string")expect(2,dw,"boolean","nil")expect(3,b7,"string","nil")if syslogs[m]then error("Log already exists",0)end;syslogs[m]={}if b7 then local o;syslogs[m].file,o=filesystem.open(process,b7,"a")if syslogs[m].file==nil then syslogs[m]=nil;return error("Could not open log file: "..o,0)end end;if dw then syslogs[m].stream={}end end;function syscalls.rmlog(process,ar,m)expect(1,m,"string")if m=="default"then error("Cannot delete default log",0)end;if not syslogs[m]then error("Log does not exist",0)end;if syslogs[m].stream then for z,i in pairs(syslogs[m].stream)do process.queueEvent(i.pid,"syslog_close",i.id)processes[i.pid].dependents[i.id]=nil end end;syslogs[m]=nil end;function syscalls.openlog(process,ar,m,dx)expect(1,m,"string")expect(2,dx,"string","nil")if not syslogs[m]then error("Log does not exist",0)end;if not syslogs[m].stream then error("Log does not have streaming enabled",0)end;local dy=#process.dependents+1;local cI=process.pid;process.dependents[dy]={type="log",name=m,filter=dx,gc=function()for w,i in pairs(syslogs[m].stream)do if i.id==dy and i.pid==cI then syslogs[m].stream[w]=nil end end end}syslogs[m].stream[#syslogs[m].stream+1]={pid=cI,id=dy,filter=dx}return dy end;function syscalls.closelog(process,ar,m)expect(1,m,"string","number")if type(m)=="string"then if not syslogs[m]then error("Log does not exist",0)end;if not syslogs[m].stream then error("Log does not have streaming enabled",0)end;for w,i in pairs(syslogs[m].stream)do if i.pid==process.pid then process.dependents[i.id]=nil;syslogs[m].stream[w]=nil end end else if not process.dependents[m]then error("Log connection does not exist",0)end;local ds=syslogs[process.dependents[m].name].stream;for w,i in pairs(ds)do if i.pid==process.pid and i.id==m then process.dependents[i.id]=nil;ds[w]=nil;break end end end end;function syscalls.logtty(process,ar,m,cX,aX)if process.user~="root"then error("Permission denied",0)end;expect(1,m,"string")expect(2,cX,"table","number","nil")expect(3,aX,"number","nil")if not syslogs[m]then error("Log does not exist",0)end;syslogs[m].tty=type(cX)=="table"and cX or TTY[cX]syslogs[m].tty_level=aX;return true end;function syslog.log(by,...)return pcall(syscalls.syslog,KERNEL,nil,by,...)end;function syslog.debug(...)return pcall(syscalls.syslog,KERNEL,nil,{level="debug",process=0},...)end;local dz=panic;function panic(af)xpcall(function()syslog.log({level="panic"},"Kernel panic:",af)if debug then local aj=debug.traceback(nil,2)syslog.log({level="panic",traceback=true},aj)end;syslog.log({level="panic"},"We are hanging here...")term.setCursorBlink(false)while true do coroutine.yield()end end,function(A)dz(af.."; and an error occurred while logging the error: "..A)end)end;xpcall(function()local o;syslogs.default.file,o=filesystem.open(KERNEL,"/var/log/default.log","a")shutdownHooks[#shutdownHooks+1]=function()if syslogs.default.file then syslogs.default.file.close()end end;syslog.log("Starting Phoenix version",PHOENIX_VERSION,PHOENIX_BUILD)syslog.log("Initialized system logger")syslog.log("System started at "..systemStartTime.." on computer "..os.computerID()..(os.computerLabel()and"('"..os.computerLabel().."')"or""))syslog.log("Computer host is ".._HOST)if syslogs.default.file==nil then syslog.log({level="notice"},"An error occurred while opening the log file at /var/log/default.log:",o,". System logs will not be saved to disk.")end end,panic)local function dA(bj)return string.match(bj,'^()%s*$')and''or string.match(bj,'^%s*(.*%S)')end;local expect,do_syscall=expect,do_syscall;local function dB(bd)local a7=1;local function dm(a9)if a7>#bd then return nil end;a9=a9 or 1;local bj=bd:sub(a7,a7+a9-1)a7=a7+a9;return bj end;if dm(8)~="!<arch>\n"then error("Not an ar archive",2)end;local a5={}local dC=nil;local dD={}while true do local bd={}local dE=dm()while dE=="\n"do dE=dm()end;if dE==nil then break end;local m=dm(15)if m==nil then break end;m=dE..m;if string.find(m,"/")and string.find(m,"/")>1 then m=string.sub(m,1,string.find(m,"/")-1)else m=dA(m)end;bd.timestamp=tonumber(dA(dm(12)))bd.owner=tonumber(dA(dm(6)))bd.group=tonumber(dA(dm(6)))bd.mode=tonumber(dA(dm(8)),8)local S=tonumber(dA(dm(10)))if dm(2)~="`\n"then error("Invalid header for file "..m,2)end;if string.match(m,"^#1/%d+$")then m=dm(tonumber(string.match(m,"#1/(%d+)")))elseif string.match(m,"^/%d+$")then if dC then local r=tonumber(string.match(m,"/(%d+)"))m=dC:match("[^/]*",r+1)else table.insert(dD,m)end end;bd.name=m;bd.data=dm(S)if m=="//"then dC=bd.data elseif m~="/"and m~="/SYM64/"then table.insert(a5,bd)end end;if dC then for h,i in pairs(dD)do local r=tonumber(string.match(i,"/(%d+)"))for N,ag in pairs(a5)do if ag.name==i then ag.name=dC:match("[^/]*",r+1)break end end end end;local dF={}for z,i in ipairs(a5)do dF[i.name]=i end;return dF end;function createRequire(process,cv)local dG,dH={},{}cv.package={}local dI=processes[process.parent]and processes[process.parent].env;if dI then cv.package.path=dI.package and dI.package.path;cv.package.libpath=dI.package and dI.package.libpath end;cv.package.path=cv.package.path or"/lib/?.lua;/lib/?/init.lua;/usr/lib/?.lua;/usr/lib/?/init.lua;./?.lua;./?/init.lua"if type(process.vars.PACKAGE_PATH)=="string"then cv.package.path=process.vars.PACKAGE_PATH..';'..cv.package.path end;cv.package.libpath=cv.package.libpath or"/lib/lib?.a;/usr/lib/lib?.a"if type(process.vars.PACKAGE_LIBPATH)=="string"then cv.package.libpath=process.vars.PACKAGE_LIBPATH..';'..cv.package.libpath end;cv.package.config="/\n;\n?\n!\n-"cv.package.loaded=dG;cv.package.preload=dH;cv.package.forceload=false;for h,i in pairs(cv)do if type(i)=="table"then dG[h]=i end end;local dJ=setmetatable({},{__newindex=function()end,__metatable=false})local dK={}local function dL(m,b7)local a,o=do_syscall("open",b7,"rb")if not a then error(b7 ..": "..o,3)end;local bd=a.readAll()a.close()local g,o=load(bd,"@"..b7,nil,_ENV)if not g then error(b7 ..": "..o,3)end;local dM=b7:match("^(.*)/[^/]*$")or"/"dK[#dK+1]=function(dN)local b7,o=package.searchpath(dN,dM.."/?.lua;"..dM.."/?/init.lua")if not b7 then return nil,o end;return dL,b7 end;local bb,v=pcall(g,m)dK[#dK]=nil;if bb then return v else error(b7 ..": "..v,3)end end;local function dO(m,b7)local dP;if b7:find"%z"then b7,dP=b7:match"^([^%z]*)%z(.*)$"elseif m:find"%-"then dP=m:match("^([^%-]*)%-(.*)$")else dP="init"end;local a,o=do_syscall("open",b7,"rb")if not a then error(b7 ..": "..o,3)end;local bd=a.readAll()a.close()local dM=dB(bd)local function dQ(m)local E=m..".lua"if not dM[E]then error(b7 ..":"..E..": File not found",0)end;local bd=dM[E].data;local g,o=load(bd,"@"..b7 ..":"..E,nil,_ENV)if not g then error(b7 ..":"..E..": "..o,3)end;local bb,v=pcall(g,m)if bb then return v else error(b7 ..":"..E..": "..v)end end;dK[#dK+1]=function(dN)return dQ,dN end;local v=dQ(dP)dK[#dK]=nil;return v end;dK[1]=function(m)local dM=do_syscall("getname"):match("^(.*)/[^/]*$")or"/"local b7,o=package.searchpath(m,dM.."/?.lua;"..dM.."/?/init.lua")if not b7 then return nil,o end;return dL,b7 end;function cv.package.searchpath(m,b7,an,dR)expect(1,m,"string")expect(2,b7,"string")expect(3,an,"string","nil")expect(4,dR,"string","nil")an=(an or"."):gsub("([%^%$%(%)%%%.%[%]%*%+%-%?])","%%%1")dR=(dR or"/"):gsub("([%^%$%(%)%%%.%[%]%*%+%-%?])","%%%1")local dS=""for E in b7:gmatch"[^;]+"do local dT=E:gsub("%?",m:gsub(an,dR),nil)local a,o=do_syscall("open",dT,"r")if a then a.close()return dT else dS=dS.."\t"..dT..": "..o.."\n"end end;return nil,dS end;cv.package.searchers={function(m)local E=dH[m]if E then return E else return nil,"\tpackage.preload['"..m.."']: No such field\n"end end,function(m)local b7,o=package.searchpath(m,package.path)if not b7 then return nil,o end;return dL,b7,b7 end,function(m)local b7,o=package.searchpath(m:match("^[^%-]*"),package.libpath)if not b7 then return nil,o end;local r=m:match("%-(.+)$")if r then return dO,b7,b7 ..":"..r else return dO,b7,b7 ..":init"end end,function(m)if not m:find"%."then return nil end;local b7,o=package.searchpath(m:match("^[^%.]*"),package.libpath)if not b7 then return nil,o end;local r=m:match("^[^%.]*%.(.*)$")return dO,b7 .."\0"..r,b7 ..":"..r end,function(m)if#dK>0 then return dK[#dK](m)end;return nil,"no local loaders found"end}setfenv(dL,cv)debug.protect(dL)setfenv(dO,cv)debug.protect(dO)setfenv(dK[1],cv)debug.protect(dK[1])for z,i in pairs(cv.package.searchers)do setfenv(i,cv)debug.protect(i)end;function cv.require(m)expect(1,m,"string")local o="module '"..m.."' not found:\n"local dU,dV,dW;for z,i in ipairs(package.searchers)do dU,dV,dW=i(m)if dU then break end;o=o..(dV or"")end;if not dU then error(o,2)end;if dW then if dG[dW]then if dG[dW]==dJ then error("loop detected loading '"..m.."'",3)elseif not package.forceload then return dG[dW]end end;dG[dW]=dJ else if dG[m]then if dG[m]==dJ then error("loop detected loading '"..m.."'",3)elseif not package.forceload then return dG[m]end end end;dG[m]=dJ;local bb,v=pcall(dU,m,dV)if bb then if v~=nil then dG[m]=v elseif dG[m]==dJ then dG[m]=true end;if dW then if v~=nil then dG[dW]=v elseif dG[dW]==dJ then dG[dW]=true end end;return dG[m]else dG[m]=nil;if dW then dG[dW]=nil end;error(o.."\t"..v.."\n",2)end end;return cv end;timerMap={}alarmMap={}local dX={}function syscalls.kill(process,ar,cI,dY)expect(1,cI,"number")expect(2,dY,"number")local dZ=processes[cI]if not dZ then error("No such process",2)end;if process.user~="root"and process.user~=dZ.user then error("Permission denied",2)end;if dY==9 then reap_process(dZ)if processes[dZ.parent]then syscalls.queueEvent(processes[dZ.parent],nil,"process_complete",{id=cI,result=9})end;processes[cI]=nil elseif dZ.signalHandlers[dY]then userModeCallback(dZ,dZ.signalHandlers[dY],dY)else syscalls.queueEvent(dZ,nil,"signal",{signal=dY})end end;function syscalls.signal(process,ar,dY,d_)expect(1,dY,"number")expect(2,d_,"function","nil")process.signalHandlers[dY]=d_ end;function syscalls.queueEvent(process,ar,m,aw)expect(1,m,"string")expect(2,aw,"table")process.eventQueue[#process.eventQueue+1]={m,aw}end;function syscalls.sendEvent(process,ar,cI,m,aw)expect(1,cI,"number")expect(2,m,"string")local dZ=processes[cI]if not dZ then return false end;dZ.eventQueue[#dZ.eventQueue+1]={"remote_event",{type=m,sender=process.id,data=aw}}return true end;function syscalls.register(process,ar,m)expect(1,m,"string")if dX[m]then return false end;dX[m]=process.id;process.dependents[#process.dependents+1]={gc=function()dX[m]=nil end}return true end;function syscalls.lookup(process,ar,m)expect(1,m,"string")return dX[m]end;function syscalls.timer(process,ar,e0)expect(1,e0,"number")local e1=os.startTimer(e0)timerMap[e1]=process;return bit32.band(e1,0x7FFFFFFF)end;function syscalls.alarm(process,ar,e0)expect(1,e0,"number")local e1=os.setAlarm(e0)alarmMap[e1]=process;return bit32.bor(e1,0x80000000)end;function syscalls.cancel(process,ar,e1)expect(1,e1,"number")if bit32.btest(e1,0x80000000)then e1=bit32.band(e1,0x7FFFFFFF)if alarmMap[e1]~=process then error("No such alarm")end;os.cancelAlarm(e1)alarmMap[e1]=nil else if timerMap[e1]~=process then error("No such timer")end;os.cancelTimer(e1)timerMap[e1]=nil end end;eventHooks.terminate=eventHooks.terminate or{}eventHooks.terminate[#eventHooks.terminate+1]=function()if currentTTY.frontmostProcess then syscalls.kill(KERNEL,nil,currentTTY.frontmostProcess.id,2)terminal.write(currentTTY,"^T")end end;eventParameterMap={alarm={"id"},char={"character"},key={"keycode","isRepeat"},key_up={"keycode"},mouse_click={"button","x","y"},mouse_drag={"button","x","y"},mouse_up={"button","x","y"},mouse_scroll={"direction","x","y"},paste={"text"},redstone={},term_resize={},timer={"id"},turtle_inventory={}}do local e2=0;for z,i in pairs(keys)do if type(i)=="number"then e2=math.max(e2,i)end end;local bl;local e3=string.dump(function()end)local e4=(function(p)if p<8 then return p end;local K=0;while p>=128 do p,K=bit32.rshift(p+0xf,4),K+4 end;while p>=16 do p,K=bit32.rshift(p+1,1),K+1 end;return bit32.bor((K+1)*8,p-8)end)(e2)if _VERSION=="Lua 5.1"then bl=e3:sub(1,12)..("I"..e3:byte(9).."IIBBBBIIIIIIII"):pack(0,0,0,0,0,0,1,2,e4*0x800000+10,0x0100001E,0,0,0,0,0)elseif _VERSION=="Lua 5.2"then bl=e3:sub(1,18)..("IIBBBIIIIIIIIII"):pack(0,0,0,0,1,2,e4*0x800000+11,0x0100001F,0,0,0,0,0,0,0)elseif _VERSION=="Lua 5.3"then bl=e3:sub(1,17+("jn"):packsize())..("BBIIBBBIIIIIIIII"):pack(0,0,0,0,0,0,1,2,e4*0x800000+11,0x01000026,0,0,0,0,0,0)elseif _VERSION=="Lua 5.4"then bl=e3:sub(1,15+("jn"):packsize())..("BBBBBBBBIIIBBBBBBB"):pack(0,0x80,0x80,0x80,0,0,1,0x83,0x00000013,e2*0x80+82,0x00008048,0x80,0x80,0x80,0x80,0x80,0x80,0x80)end;if bl then local g,o=load(bl,nil,"b")if g then keymap=g()else syslog.debug("Could not load key table code:",o)end end;if not keymap then keymap={}for w=1,e2 do keymap[w]=0 end;for w=1,e2 do if not keys.getName(w)then keymap[w]=nil end end end;for w=0x61,0x7A do keymap[keys[string.char(w)]]=w end;for w=0x81,0x99 do if keys["f"..bit32.band(w,31)]then keymap[keys["f"..bit32.band(w,31)]]=w end end;for w=0xA0,0xA9 do keymap[keys["numPad"..bit32.band(w,15)]]=w end;keymap[keys.backspace]=0x08;keymap[keys.tab]=0x09;keymap[keys.enter or keys["return"]]=0x0A;keymap[keys.space]=0x20;keymap[keys.apostrophe]=0x27;keymap[keys.comma]=0x2C;keymap[keys.minus]=0x2D;keymap[keys.period]=0x2E;keymap[keys.slash]=0x2F;keymap[keys.zero]=0x30;keymap[keys.one]=0x31;keymap[keys.two]=0x32;keymap[keys.three]=0x33;keymap[keys.four]=0x34;keymap[keys.five]=0x35;keymap[keys.six]=0x36;keymap[keys.seven]=0x37;keymap[keys.eight]=0x38;keymap[keys.nine]=0x39;keymap[keys.semicolon or keys.semiColon]=0x3B;keymap[keys.equals]=0x3D;keymap[keys.leftBracket]=0x5B;keymap[keys.backslash]=0x5C;keymap[keys.rightBracket]=0x5D;keymap[keys.grave]=0x60;keymap[keys.delete]=0x7F;keymap[keys.insert]=0x80;if keys.convert then keymap[keys.convert]=0x9A end;if keys.noconvert then keymap[keys.noconvert]=0x9B end;if keys.kana then keymap[keys.kana]=0x9C end;if keys.kanji then keymap[keys.kanji]=0x9D end;if keys.yen then keymap[keys.yen]=0x9E end;keymap[keys.numPadDecimal]=0x9F;keymap[keys.numPadAdd]=0xAA;keymap[keys.numPadSubtract]=0xAB;if keys.numPadMultiply then keymap[keys.numPadMultiply]=0xAC end;keymap[keys.numPadDivide]=0xAD;keymap[keys.numPadEqual or keys.numPadEquals]=0xAE;keymap[keys.numPadEnter]=0xAF;keymap[keys.leftCtrl]=0xB0;keymap[keys.rightCtrl]=0xB1;keymap[keys.leftAlt]=0xB2;keymap[keys.rightAlt]=0xB3;keymap[keys.leftShift]=0xB4;keymap[keys.rightShift]=0xB5;if keys.leftSuper then keymap[keys.leftSuper]=0xB6 end;if keys.rightSuper then keymap[keys.rightSuper]=0xB7 end;keymap[keys.capsLock]=0xB8;keymap[keys.numLock]=0xB9;keymap[keys.scrollLock or keys.scollLock]=0xBA;if keys.printScreen then keymap[keys.printScreen]=0xBB end;keymap[keys.pause]=0xBC;if keys.menu then keymap[keys.menu]=0xBD end;if keys.stop then keymap[keys.stop]=0xBE end;if keys.ax then keymap[keys.ax]=0xBF end;keymap[keys.up]=0xC0;keymap[keys.down]=0xC1;keymap[keys.left]=0xC2;keymap[keys.right]=0xC3;keymap[keys.pageUp]=0xC4;keymap[keys.pageDown]=0xC5;keymap[keys.home]=0xC6;keymap[keys["end"]]=0xC7;if keys.circumflex or keys.cimcumflex then keymap[keys.circumflex or keys.cimcumflex]=0xC8 end;if keys.at then keymap[keys.at]=0xC9 end;if keys.colon then keymap[keys.colon]=0xCA end;if keys.underscore then keymap[keys.underscore]=0xCB end end;local e5={id=1,name="init",user="root",dependents={{gc=function()end}},parent=0,dir="/",stdin=TTY[1],stdout={},stderr=TTY[1],cputime=0.2,systime=0.1,env={},syscallyield=nil,eventQueue={},signalHandlers={},paused=false,threads={[0]={id=0,name="",coro=coroutine.create(function()end),status="starting",args={"a",n=1},filter=function(process,ar,e6)end}}}local e7=1;local function e8(process)local e=createLuaLib(process)if _VERSION<"Lua 5.2"then e=make_ENV(e)end;e._G=e;return e end;local function e9()coroutine.yield("preempt","test",7)end;function reap_process(process)syslog.debug("Reaping process "..process.id.." ("..process.name..")")for z,i in ipairs(process.dependents)do i:gc()end;if process.stdin and process.stdin.isTTY then if process.stdin.frontmostProcess==process then process.stdin.frontmostProcess=table.remove(process.stdin.processList)process.stdin.preBuffer=""if discord and process.stdout==currentTTY and process.stdout.frontmostProcess then discord("Phoenix","Executing "..process.stdout.frontmostProcess.name)end else for w,i in ipairs(process.stdin.processList)do if i==process then table.remove(process.stdin.processList,w)break end end end end;if process.stdout and process.stdout.isTTY then if process.stdout.frontmostProcess==process then process.stdout.frontmostProcess=table.remove(process.stdout.processList)else for w,i in ipairs(process.stdout.processList)do if i==process then table.remove(process.stdout.processList,w)break end end end end;if process.stderr and process.stderr.isTTY then if process.stderr.frontmostProcess==process then process.stderr.frontmostProcess=table.remove(process.stderr.processList)else for w,i in ipairs(process.stderr.processList)do if i==process then table.remove(process.stderr.processList,w)break end end end end end;function syscalls.getpid(process,ar)return process.id end;function syscalls.getppid(process,ar)return process.parent end;function syscalls.clock(process,ar)return process.cputime end;function syscalls.getenv(process,ar)return process.vars end;function syscalls.getname(process,ar)return process.name end;function syscalls.getcwd(process,ar)return process.dir end;function syscalls.chdir(process,ar,dM)expect(1,dM,"string")local bz=filesystem.stat(process,dM)if not bz or bz.type~="directory"then return false,"No such file or directory"elseif not(bz.permissions[process.user]or bz.worldPermissions).execute then return false,"Permission denied"end;process.dir=dM:gsub("^([^/])","/"..process.dir.."/%1")return true end;function syscalls.getuser(process,ar)return process.user,process.realuser end;function syscalls.setuser(process,ar,user)expect(1,user,"string")if process.user~="root"then error("Permission denied")end;process.user=user;process.realuser=nil end;function syscalls.fork(process,ar,az,m,...)expect(1,az,"function")expect(2,m,"string","nil")local dy=e7;e7=e7+1;processes[dy]={id=dy,name=m or process.name,user=process.user,dependents={},parent=process.id,dir=process.dir,root=process.root,stdin=process.stdin,stdout=process.stdout,stderr=process.stderr,vars=deepcopy(process.vars),cputime=0,systime=0,syscallyield=nil,eventQueue={},signalHandlers={[1]=function()return coroutine.yield("syscall","exit",1)end,[2]=function()return coroutine.yield("syscall","exit",1)end,[3]=function()coroutine.yield("syscall","syslog",{level="error",category="Application Error",traceback=true},debug.traceback("Quit"))return coroutine.yield("syscall","exit",1)end,[6]=function(o)coroutine.yield("syscall","syslog",{level="error",category="Application Error",traceback=true},debug.traceback(o or"Aborted"))return coroutine.yield("syscall","exit",1)end,[13]=function()return coroutine.yield("syscall","exit",1)end,[15]=function()return coroutine.yield("syscall","exit",1)end,[19]=function()return coroutine.yield("syscall","suspend")end,[21]=function()return coroutine.yield("syscall","suspend")end,[22]=function()return coroutine.yield("syscall","suspend")end},paused=false,threads={[0]={id=0,name="<main thread>",coro=coroutine.create(az),status="starting",args=table.pack(...),filter=nil}}}processes[dy].env=e8(processes[dy])setfenv(az,processes[dy].env)if process.stdin and process.stdin.isTTY and not process.stdin.isLocked then process.stdin.processList[#process.stdin.processList+1]=process.stdin.frontmostProcess;process.stdin.frontmostProcess=processes[dy]process.stdin.preBuffer=""if discord and process.stdout==currentTTY then discord("Phoenix","Executing "..process.name)end end;if process.stdout and process.stdout.isTTY and not process.stdout.isLocked and process.stdout.frontmostProcess~=processes[dy]then process.stdout.processList[#process.stdout.processList+1]=process.stdout.frontmostProcess;process.stdout.frontmostProcess=processes[dy]end;if process.stderr and process.stderr.isTTY and not process.stderr.isLocked and process.stderr.frontmostProcess~=processes[dy]then process.stderr.processList[#process.stderr.processList+1]=process.stderr.frontmostProcess;process.stderr.frontmostProcess=processes[dy]end;if args.preemptive then debug.sethook(processes[dy].threads[0].coro,e9,"",args.quantum)end;return dy end;function syscalls.exec(process,ar,b7,...)expect(1,b7,"string")local a,o=filesystem.open(process,b7,"r")if not a then b7=b7 ..".lua"a,o=filesystem.open(process,b7,"r")if not a then error("Could not open file: "..o,0)end end;local ea=a.readAll()a.close()if ea:match("\x1bLua")then a,o=filesystem.open(process,b7,"rb")if not a then error("Could not open file: "..o,0)end;ea=a.readAll()a.close()end;local bz=filesystem.stat(process,b7)if not(bz.permissions[bz.owner]or bz.worldPermissions).execute then error("Could not execute file: Permission denied",0)end;if bz.setuser then process.realuser,process.user=process.user,bz.owner end;if ea:sub(1,2)=="#!"then local eb=ea:sub(3,ea:find("\n")-1)local args,w={},0;for bj in eb:gmatch"%S+"do args[w]=bj;w=w+1 end;args[w],w=b7,w+1;for z,i in ipairs{...}do args[w]=i;w=w+1 end;if args[0]==b7 then error("Recursive path detected while resolving shebang",0)end;syscalls.exec(process,ar,args[0],table.unpack(args,1,w))process.name="/"..fs.combine(b7:sub(1,1)=="/"and""or process.dir,b7)else local az,o=load(ea,"@"..b7,"bt",process.env)if not az then error("Could not execute file: "..o,0)end;process.name="/"..fs.combine(b7:sub(1,1)=="/"and""or process.dir,b7)process.threads={[0]={id=0,name="<main thread>",coro=coroutine.create(az),status="starting",args=table.pack(...),filter=nil}}if args.preemptive then debug.sethook(process.threads[0].coro,e9,"",args.quantum)end end;if discord and process.stdin and process.stdin.isTTY and process.stdin.frontmostProcess==process then discord("Phoenix","Executing "..process.name)end end;function syscalls.newthread(process,ar,az,...)expect(1,az,"function")local dy=#process.threads+1;process.threads[dy]={id=dy,name="<thread:"..dy..">",coro=coroutine.create(az),status="starting",args=table.pack(...),filter=nil}setfenv(az,process.env)if args.preemptive then debug.sethook(process.threads[dy].coro,e9,"",args.quantum)end;return dy end;function syscalls.exit(process,ar,bl)for z,ar in pairs(process.threads)do ar.status="dead"end end;function syscalls.getplist(process,ar)local ec={}for h in pairs(processes)do ec[#ec+1]=h end;table.sort(ec)return ec end;function syscalls.getpinfo(process,ar,cI)expect(1,cI,"number")local E=processes[cI]if not E then return nil,"No such process"end;local ed,ee,ef;for w,i in ipairs(TTY)do if E.stdin==i then ed=w end;if E.stdout==i then ee=w end;if E.stderr==i then ef=w end end;local eg={}if E.threads then for w,i in pairs(E.threads)do eg[w]={id=i.id,name=i.name,status=i.status}end end;return{id=E.id,name=E.name,user=E.user,realuser=E.realuser,parent=E.parent,dir=E.dir,stdin=ed,stdout=ee,stderr=ef,cputime=E.cputime or 0,systime=E.systime or 0,threads=eg}end;function syscalls.suspend(process,ar)process.paused=true end;local function eh(a0)a0=a0 .."\x80"..("\0"):rep(-(#a0+9)%64)..(">I8"):pack(#a0)local ei,ej,ek,el,em,ag=0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476,0xC3D2E1F0,{}for en=1,#a0,64 do local eo=en;for w=0,15 do ag[w]=a0:byte(eo)*0x1000000+a0:byte(eo+1)*0x10000+a0:byte(eo+2)*0x100+a0:byte(eo+3)eo=eo+4 end;for w=16,79 do ag[w]=bit32.lrotate(bit32.bxor(ag[w-3],ag[w-8],ag[w-14],ag[w-16]),1)end;local cg,ab,a9,bh,K=ei,ej,ek,el,em;for w=0,79 do local f,h;if w<=19 then f,h=bit32.bxor(bh,bit32.band(ab,bit32.bxor(a9,bh))),0x5A827999 elseif w<=39 then f,h=bit32.bxor(ab,a9,bh),0x6ED9EBA1 elseif w<=59 then f,h=bit32.bor(bit32.band(ab,bit32.bor(a9,bh)),bit32.band(a9,bh)),0x8F1BBCDC else f,h=bit32.bxor(ab,a9,bh),0xCA62C1D6 end;local ep=bit32.band(bit32.lrotate(cg,5)+f+K+h+ag[w],0xFFFFFFFF)K,bh,a9,ab,cg=bh,a9,bit32.lrotate(ab,30),cg,ep end;ei=bit32.band(ei+cg,0xFFFFFFFF)ej=bit32.band(ej+ab,0xFFFFFFFF)ek=bit32.band(ek+a9,0xFFFFFFFF)el=bit32.band(el+bh,0xFFFFFFFF)em=bit32.band(em+K,0xFFFFFFFF)end;return{ei,ej,ek,el,em}end;local function eq(er,m)local es=eh(er:gsub("%X",""):gsub("%x%x",function(bj)return string.char(tonumber(bj,16))end)..m)local cg,ab,a9,bh=es[1],bit32.bor(bit32.band(es[2],0xFFFF0FFF),0x5000),bit32.bor(bit32.band(es[3],0x3FFFFFFF),0x80000000),es[4]return("%08x-%04x-%04x-%04x-%04x%08x"):format(cg,bit32.rshift(ab,16),bit32.band(ab,0xFFFF),bit32.rshift(a9,16),bit32.band(a9,0xFFFF),bh)end;local et="a6f53b7d-50f3-4e51-adef-8728c83e3f3a"deviceTreeRoot={id=tostring(os.getComputerID()),uuid=eq(et,tostring(os.getComputerID())),parent=nil,displayName=os.getComputerLabel()or"",drivers={},metadata={},internalState={},children={},listeners=setmetatable({},{__mode="k"})}local eu={[deviceTreeRoot.uuid]=deviceTreeRoot}local ev={}function hardware.get(b7)expect(1,b7,"string")if b7:find("^%x+%-%x+%-%x+%-%x+%-%x+$")then return eu[b7]elseif b7:find("/")then local dl=deviceTreeRoot;for m in b7:gmatch"[^/]+"do dl=dl.children[m]if dl==nil then break end end;return dl else local ew={}local function ex(dl)if dl.id==b7 or dl.alias==b7 then ew[#ew+1]=dl end;for z,i in pairs(dl.children)do ex(i)end end;ex(deviceTreeRoot)return table.unpack(ew)end end;function hardware.find(type)expect(1,type,"string")local ey={}local function ez(dl)for z,i in ipairs(dl.drivers)do if i.type==type then ey[#ey+1]=dl;break end end;for z,i in pairs(dl.children)do ez(i)end end;ez(deviceTreeRoot)return table.unpack(ey)end;function hardware.path(dl)expect(1,dl,"table")expect.field(dl,"uuid","string")if not eu[dl.uuid]then error("bad argument #1 (invalid node)",2)end;local b7=dl.id;dl=dl.parent;while dl do b7=dl.id.."/"..b7;dl=dl.parent end;b7=b7:gsub("^[^/]+","")return b7==""and"/"or b7 end;function hardware.add(bS,m)expect(1,bS,"table")expect(2,m,"string")expect.field(bS,"uuid","string")if not eu[bS.uuid]then return nil,"Invalid parent node"end;if bS.children[m]then return nil,"Node already exists"end;local dl={id=m,uuid=eq(bS.uuid,m),parent=bS,displayName="",drivers={},metadata={},internalState={},children={},listeners=setmetatable({},{__mode="k"})}bS.children[m]=dl;eu[dl.uuid]=dl;syslog.log({module="Hardware"},"Added new device at "..hardware.path(dl))for z,i in ipairs(ev)do if(not i.parent or i.parent==bS)and(not i.pattern or m:match(i.pattern))then i.callback(dl)end end;return dl end;function hardware.remove(dl)expect(1,dl,"table")expect.field(dl,"uuid","string")if not eu[dl.uuid]then return false,"Invalid node"end;if dl==deviceTreeRoot or not dl.parent then return false,"Cannot remove root node"end;for w=#dl.drivers,1,-1 do hardware.deregister(dl,dl.drivers[w])end;for z,i in pairs(dl.children)do hardware.remove(i)end;syslog.log({module="Hardware"},"Device at "..hardware.path(dl).." has been removed")dl.parent.children[dl.id]=nil;eu[dl.uuid]=nil;dl.parent=nil;return true end;function hardware.register(dl,eA)expect(1,dl,"table")expect(2,eA,"table")expect.field(dl,"uuid","string")expect.field(eA,"name","string")expect.field(eA,"type","string")expect.field(eA,"properties","table")expect.field(eA,"methods","table")expect.field(eA,"init","function","nil")expect.field(eA,"deinit","function","nil")for h in pairs(eA.methods)do if type(h)~="string"then error("bad method name '"..tostring(h).."' (not a string)",2)end;expect.field(eA.methods,h,"function")end;for z,i in ipairs(eA.properties)do if type(i)~="string"then error("bad property name '"..tostring(i).."' (not a string)",2)end;if not eA.methods["get"..i:sub(1,1):upper()..i:sub(2)]then error("bad property '"..i.."' (no getter present)",2)end end;if not eu[dl.uuid]then error("bad argument #1 (invalid node)",2)end;for z,i in ipairs(dl.drivers)do if i==eA then return false end end;dl.drivers[#dl.drivers+1]=eA;syslog.log({module="Hardware"},"Registered device with type "..eA.type.." on device "..hardware.path(dl).." using driver "..eA.name)if eA.init then eA.init(dl)end;return true end;function hardware.register_callback(eA)return function(dl)return hardware.register(dl,eA)end end;function hardware.deregister(dl,eA)expect(1,dl,"table")expect(2,eA,"table")expect.field(dl,"uuid","string")if not eu[dl.uuid]then error("bad argument #1 (invalid node)",2)end;for w,i in ipairs(dl.drivers)do if i==eA then if eA.deinit then eA.deinit(dl)end;table.remove(dl.drivers,w)syslog.log({module="Hardware"},"Driver "..eA.name.." has been deregistered from device "..hardware.path(dl))return true end end;return false end;function hardware.listen(eB,bS,eC)expect(1,eB,"function")expect(2,bS,"table","nil")expect(3,eC,"string","nil")if bS then expect.field(bS,"uuid","string")end;if eC and not pcall(string.match,"",eC)then error("bad argument #3 (invalid pattern)",2)end;ev[#ev+1]={callback=eB,parent=bS,pattern=eC}end;function hardware.unlisten(eB)expect(1,eB,"function")local w=1;while w<#ev do if ev[w].callback==eB then table.remove(ev,w)else w=w+1 end end end;function hardware.broadcast(dl,e6,cL)expect(1,dl,"table")expect(2,e6,"string")expect(3,cL,"table")expect.field(dl,"uuid","string")if not eu[dl.uuid]then error("bad argument #1 (invalid node)",2)end;for i in pairs(dl.listeners)do i.eventQueue[#i.eventQueue+1]={e6,cL}end end;function hardware.call(process,dl,eD,...)for z,eA in ipairs(dl.drivers)do if eA.methods[eD]then return eA.methods[eD](dl,process,...)end end;error("No such method",2)end;function syscalls.devlookup(process,ar,m)expect(1,m,"string")local eE={hardware.get(m)}for h,i in ipairs(eE)do eE[h]=hardware.path(i)end;return table.unpack(eE)end;function syscalls.devfind(process,ar,type)expect(1,type,"string")local eE={hardware.find(type)}for h,i in ipairs(eE)do eE[h]=hardware.path(i)end;return table.unpack(eE)end;function syscalls.devinfo(process,ar,eF)expect(1,eF,"string")local dl=hardware.get(eF)if not dl then return nil end;local eG={}for z,i in ipairs(dl.drivers)do eG[i.type]=i.name end;return{id=dl.id,uuid=dl.uuid,alias=dl.alias,parent=dl.parent and hardware.path(dl.parent)or"/",displayName=dl.displayName,types=eG,metadata=deepcopy(dl.metadata)}end;function syscalls.devalias(process,ar,eF,eH)expect(1,eF,"string")expect(2,eH,"string","nil")local dl=hardware.get(eF)if not dl then error("No such device",2)end;dl.alias=eH end;function syscalls.devmethods(process,ar,eF)expect(1,eF,"string")local dl=hardware.get(eF)if not dl then error("No such device",2)end;local eI={}for z,i in ipairs(dl.drivers)do for h in pairs(i.methods)do eI[#eI+1]=h end end;return eI end;function syscalls.devproperties(process,ar,eF)expect(1,eF,"string")local dl=hardware.get(eF)if not dl then error("No such device",2)end;local eJ={}for z,i in ipairs(dl.drivers)do for z,h in pairs(i.properties)do eJ[#eJ+1]=h end end;return eJ end;function syscalls.devchildren(process,ar,eF)expect(1,eF,"string")local dl=hardware.get(eF)if not dl then error("No such device",2)end;local eK={}for h in pairs(dl.children)do eK[#eK+1]=h end;return eK end;function syscalls.devcall(process,ar,eF,eD,...)expect(1,eF,"string")expect(2,eD,"string")local dl=hardware.get(eF)if not dl then error("No such device",2)end;if dl.process and dl.process~=process.id then error("Device is locked",2)end;return hardware.call(process,dl,eD,...)end;function syscalls.devlisten(process,ar,eF,d1)expect(1,eF,"string")expect(2,d1,"boolean","nil")if d1==nil then d1=true end;local dl=hardware.get(eF)if not dl then error("No such device",2)end;if d1 then for z,i in ipairs(dl.listeners)do if i==process then return end end;dl.listeners[process]=true;process.dependents[#process.dependents+1]={type="hardware listen",node=dl,gc=function()dl.listeners[process]=nil end}else dl.listeners[process]=nil;for w,i in ipairs(process.dependents)do if i.type=="hardware listen"and i.node==dl then table.remove(process.dependents,w)break end end end end;function syscalls.devlock(process,ar,eF,eL)expect(1,eF,"string")expect(2,eL,"boolean","nil")if eL==nil then eL=true end;local dl=hardware.get(eF)if not dl then error("No such device",2)end;if dl.process==nil then dl.process=process.id;process.dependents[#process.dependents+1]={type="hardware lock",node=dl,gc=function()dl.process=nil end}return true elseif dl.process==process.id then return true elseif eL then ar.filter=function(process,ar)return dl.process==nil or dl.process==process.id end;return kSyscallYield,"devlock",eF,true else return false end end;function syscalls.devunlock(process,ar,eF)expect(1,eF,"string")local dl=hardware.get(eF)if not dl then error("No such device",2)end;if dl.process and dl.process~=process.id then error("Device is locked",2)end;dl.process=nil;for w,i in ipairs(process.dependents)do if i.type=="hardware lock"and i.node==dl then table.remove(process.dependents,w)break end end end;function syscalls.version(process,ar,eM)if eM then return PHOENIX_BUILD else return PHOENIX_VERSION end end;function syscalls.cchost(process,ar)return _HOST end;function syscalls.uptime(process,ar)return(os.epoch"utc"-systemStartTime)/1000 end;function syscalls.attach(process,ar,eN,_type,...)if process.user~="root"then error("Permission denied")end;expect(1,eN,"string","number")expect(2,_type,"string")local bb,o;if periphemu then bb=periphemu.create(eN,_type,...)elseif ccemux then if type(eN)=="number"then eN=_type.."_"..eN end;if _type=="drive"then _type="disk_drive"elseif _type=="modem"then _type="wireless_modem"end;if _type=="computer"then local dy=tonumber(eN:match("%d+"))if dy then bb,o=pcall(ccemux.openEmu,dy)else bb,o=false,"Invalid side"end else bb,o=pcall(ccemux.attach,eN,_type,...)end else bb,o=false,"Operation not supported"end;return bb,o end;function syscalls.detach(process,ar,eN)if process.user~="root"then error("Permission denied")end;expect(1,eN,"string","number")local bb,o;if periphemu then bb=periphemu.remove(eN)elseif ccemux then if type(eN)=="number"then eN=_type.."_"..eN end;bb,o=pcall(ccemux.detach,eN)else bb,o=false,"Operation not supported"end;return bb,o end;function syscalls.kernargs(process,ar)return deepcopy(args)end;local eO=0;function syscalls.lockmutex(process,ar,eP)expect(1,eP,"table")if eP.owner then if eP.owner~=ar.id then ar.filter=function(process,ar)return eP.owner==nil or eP.owner==ar.id end;return kSyscallYield,"lockmutex",eP elseif type(eP.recursive)=="number"then eP.recursive=eP.recursive+1 else error("cannot recursively lock mutex",0)end else eP.owner=ar.id;if eP.recursive then eP.recursive=1 end end end;function syscalls.__timeout_check(process,ar,a_)if a_.timeout then return false end;return syscalls[a_.call](process,ar,a_.object,0)end;function syscalls.timelockmutex(process,ar,eP,e0)expect(1,eP,"table")expect(2,e0,"number")if eP.owner then if eP.owner~=ar.id then local eQ=os.startTimer(e0)local a_={object=eP,timeout=false,call="timelockmutex"}ar.filter=function(process,ar,as)if as[1]=="timer"and as[2].id==eQ then a_.timeout=true;return true end;return eP.owner==nil or eP.owner==ar.id end;return kSyscallYield,"__timeout_check",a_ elseif type(eP.recursive)=="number"then eP.recursive=eP.recursive+1 else error("cannot recursively lock mutex",0)end else eP.owner=ar.id;if eP.recursive then eP.recursive=1 end end;return true end;function syscalls.unlockmutex(process,ar,eP)expect(1,eP,"table")if eP.owner==ar.id then if type(eP.recursive)=="number"then eP.recursive=eP.recursive-1;if eP.recursive<=0 then eP.owner=nil end else eP.owner=nil end elseif eP.owner==nil then error("mutex already unlocked",0)else error("mutex not locked by current thread")end end;function syscalls.trylockmutex(process,ar,eP)expect(1,eP,"table")if eP.owner then if eP.owner~=process.id then return false elseif type(eP.recursive)=="number"then eP.recursive=eP.recursive+1;return true else error("cannot recursively lock mutex",0)end else eP.owner=process.id;if eP.recursive then eP.recursive=1 end;return true end end;function syscalls.acquiresemaphore(process,ar,eR)expect(1,eR,"table")expect.field(eR,"count","number")if eR.count<=0 then ar.filter=function(process,ar)return type(eR.count)~="number"or eR.count>0 end;return kSyscallYield,"acquiresemaphore",eR end;eR.count=eR.count-1 end;function syscalls.timeacquiresemaphore(process,ar,eR,e0)expect(1,eR,"table")expect.field(eR,"count","number")expect(2,e0,"number")if eR.count<=0 then local eQ=os.startTimer(e0)local a_={object=eR,timeout=false,call="timeacquiresemaphore"}ar.filter=function(process,ar,as)if as[1]=="timer"and as[2].id==eQ then a_.timeout=true;return true end;return type(eR.count)~="number"or eR.count>0 end;return kSyscallYield,"__timeout_check",a_ end;eR.count=eR.count-1;return true end;function syscalls.releasesemaphore(process,ar,eR)expect(1,eR,"table")expect.field(eR,"count","number")eR.count=eR.count+1 end;local eS={name="root",type="computer",properties={"label","id"},methods={getLabel=function()end,setLabel=function(eT)end,getId=function()end,shutdown=function()end,reboot=function()end},init=function(dl)end,deinit=function(dl)end}local eU={top=true,bottom=true,left=true,right=true,front=true,back=true}local eV={}function getNodeById(m)if eU[m]then if deviceTreeRoot.children[m]then return deviceTreeRoot.children[m]end else for h in pairs(eU)do if peripheral.getType(h)=="modem"and not peripheral.call(h,"isWireless")and deviceTreeRoot.children[h]and deviceTreeRoot.children[h].children[m]then return deviceTreeRoot.children[h].children[m]end end end end;local function eW(self)self.internalState.peripheral=self.internalState.peripheral or{}if not self.internalState.peripheral.call then self.internalState.peripheral.call=peripheral.call end;if self.internalState.peripheral.call==peripheral.call or not self.parent then self.internalState.peripheral.getMethods=peripheral.getMethods else self.internalState.peripheral.getMethods=function(dy)return peripheral.call(self.parent.id,"getMethodsRemote",dy)end end end;local function eX(process,aA)aA.__metatable={}for z,i in pairs(aA)do setfenv(i,process.env)debug.protect(i)end;return setmetatable({},aA)end;local function eY(eA,type)return function(dl)local eG,g;if dl.parent==deviceTreeRoot then eG,g={peripheral.getType(dl.id)},peripheral.call else eG,g={peripheral.call(dl.parent.id,"getTypeRemote",dl.id)},function(...)return peripheral.call(dl.parent.id,"callRemote",...)end end;for z,i in ipairs(eG)do if i==type then dl.internalState.peripheral={call=g}return hardware.register(dl,eA)end end end end;local function eZ(type)return hardware.listen(eY(eV["peripheral_"..type],type),deviceTreeRoot)end;local function e_(eD)return function(self)return self.internalState.peripheral.call(self.id,eD)end end;local function f0(eD)return function(self,process)if process.user~="root"then error("Permission denied",0)end;return self.internalState.peripheral.call(self.id,eD)end end;local function f1(eD)return function(...)local eG={...}return function(self,process,aE)expect(1,aE,table.unpack(eG))return self.internalState.peripheral.call(self.id,eD,aE)end end end;local function f2(eD)return function(...)local eG={...}return function(self,process,aE)expect(1,aE,table.unpack(eG))if process.user~="root"then error("Permission denied",0)end;return self.internalState.peripheral.call(self.id,eD,aE)end end end;local function f3()syslog.log("Sending SIGTERM to all processes")local f4=false;for cI,process in pairs(processes)do if cI~=0 then syscalls.kill(KERNEL,nil,cI,15)local f5,as=false,nil;local at=true;for f6,ar in pairs(process.threads)do if not f5 and ar.status=="suspended"then as=table.remove(process.eventQueue,1)f5=true end;if as or ar.status~="suspended"then at=executeThread(process,ar,as or{n=0},at,true)else at=false end end;if at then process.isDead=true;if process.parent~=0 and processes[process.parent]then processes[process.parent].eventQueue[#processes[process.parent].eventQueue+1]={"process_complete",process.lastReturnValue}end;reap_process(process)processes[cI]=nil else f4=true end end end;terminal.redraw(currentTTY)if f4 then syslog.log("Sending SIGKILL to all processes")for cI in pairs(processes)do if cI~=0 then syscalls.kill(KERNEL,nil,cI,9)end end end end;eV.root={name="root",type="computer",properties={"isOn","label"},methods={}}function eV.root.methods:getIsOn(process)return true end;function eV.root.methods:getLabel(process)return os.getComputerLabel()end;function eV.root.methods:setLabel(process,eT)expect(1,eT,"string","nil")os.setComputerLabel(eT)end;function eV.root.methods:turnOn(process)end;function eV.root.methods:shutdown(process)if process.user~="root"then error("Permission denied",2)end;syslog.log("System is shutting down.")function postkill()hardware.deregister(deviceTreeRoot,eV.root)syslog.log("Halting system")for z,i in ipairs(shutdownHooks)do i()end;os.shutdown()while true do coroutine.yield()end end;f3()end;function eV.root.methods:reboot(process)if process.user~="root"then error("Permission denied",2)end;syslog.log("System is restarting.")function postkill()hardware.deregister(deviceTreeRoot,eV.root)syslog.log("Rebooting system")for z,i in ipairs(shutdownHooks)do i()end;os.reboot()while true do coroutine.yield()end end;f3()end;function eV.root:init()local f7=hardware.add(self,"redstone")for z,i in ipairs{"top","bottom","left","right","front","back"}do local bh=hardware.add(f7,i)bh.internalState.redstone={side=i}hardware.register(bh,eV.root_redstone)end;hardware.register(hardware.add(deviceTreeRoot,"lo"),eV.loopback_modem)registerLoopback()for i in pairs(eU)do if peripheral.isPresent(i)then hardware.add(self,i)end end;self.displayName=os.getComputerLabel()self.metadata.id=os.getComputerID()end;function eV.root:deinit()for i in pairs(eU)do if peripheral.isPresent(i)and self.children[i]then hardware.remove(self.children[i])end end;hardware.remove(hardware.get("/lo"))hardware.remove(hardware.get("/redstone"))end;eventHooks.peripheral=eventHooks.peripheral or{}eventHooks.peripheral[#eventHooks.peripheral+1]=function(as)if eU[as[2]]then local dl,o=hardware.add(deviceTreeRoot,as[2])if dl then hardware.broadcast(deviceTreeRoot,"device_added",{device=hardware.path(dl)})else syslog.log({level="error",module="Hardware"},"Could not create new device: "..o)end else for h in pairs(eU)do if peripheral.getType(h)=="modem"and not peripheral.call(h,"isWireless")and peripheral.call(h,"isPresentRemote",as[2])then if not deviceTreeRoot.children[h]then hardware.add(deviceTreeRoot,h)end;local dl,o=hardware.add(deviceTreeRoot.children[h],as[2])if dl then hardware.broadcast(deviceTreeRoot.children[h],"device_added",{device=hardware.path(dl)})else syslog.log({level="error",module="Hardware"},"Could not create new device: "..o)end;break end end end end;eventHooks.peripheral_detach=eventHooks.peripheral_detach or{}eventHooks.peripheral_detach[#eventHooks.peripheral_detach+1]=function(as)local dl=getNodeById(as[2])if not dl then syslog.log({level="notice",module="Hardware"},"Received "..as[1].." event for device ID "..as[2]..", but no device node was found; ignoring")return end;local b7,bS=hardware.path(dl),dl.parent;hardware.remove(dl)hardware.broadcast(bS,"device_removed",{device=b7})end;rootDriver=eV.root;eV.root_redstone={name="root_redstone",type="redstone",properties={"input","output","bundledInput","bundledOutput"},methods={}}local function f8(r)if r==0 then return nil else return r end end;function eV.root_redstone.methods:getInput()return f8(redstone.getAnalogInput(self.internalState.redstone.side))end;function eV.root_redstone.methods:getOutput()return f8(redstone.getAnalogOutput(self.internalState.redstone.side))end;function eV.root_redstone.methods:setOutput(process,r)r=expect(1,r,"number","nil")or 0;expect.range(r,0,15)redstone.setAnalogOutput(self.internalState.redstone.side,r)end;function eV.root_redstone.methods:getBundledInput()return redstone.getBundledInput(self.internalState.redstone.side)end;function eV.root_redstone.methods:getBundledOutput()return redstone.getBundledOutput(self.internalState.redstone.side)end;function eV.root_redstone.methods:setBundledOutput(process,r)expect(1,r,"number")expect.range(r,0,65535)redstone.setBundledOutput(self.internalState.redstone.side,r)end;function eV.root_redstone:init()if not self.internalState.redstone or not self.internalState.redstone.side then error("No assigned side on redstone device!",2)end;self.displayName="Redstone I/O on side "..self.internalState.redstone.side end;eV.peripheral_command={name="peripheral_command",type="command",properties={"command"},methods={}}eV.peripheral_command.methods.getCommand=f0"getCommand"eV.peripheral_command.methods.setCommand=f2"setCommand"("string")eV.peripheral_command.methods.run=f0"runCommand"function eV.peripheral_command:init()eW(self)self.displayName="Command block at "..self.id end;eZ"command"eV.peripheral_computer={name="peripheral_computer",type="computer",properties={"isOn","label"},methods={}}eV.peripheral_computer.methods.getIsOn=e_"isOn"eV.peripheral_computer.methods.getLabel=e_"getLabel"eV.peripheral_computer.methods.turnOn=f0"turnOn"eV.peripheral_computer.methods.shutdown=f0"shutdown"eV.peripheral_computer.methods.reboot=f0"reboot"function eV.peripheral_command:init()eW(self)local eT=self.internalState.peripheral.call(self.id,"getLabel")self.metadata.id=self.internalState.peripheral.call(self.id,"getID")self.displayName=(eT or"Computer "..self.metadata.id).." at "..self.id end;eZ"computer"hardware.listen(eY(eV["peripheral_computer"],"turtle"),deviceTreeRoot)eV.peripheral_drive={name="peripheral_drive",type="drive",properties={"state"},methods={}}function eV.peripheral_drive.methods:getState(process)if not self.internalState.peripheral.call(self.id,"isDiskPresent")then return nil end;return{audio=self.internalState.peripheral.call(self.id,"getAudioTitle")or nil,label=self.internalState.peripheral.call(self.id,"getDiskLabel"),id=self.internalState.peripheral.call(self.id,"getDiskID")}end;eV.peripheral_drive.methods.setLabel=f1"setDiskLabel"("string","nil")eV.peripheral_drive.methods.getMountPath=e_"getMountPath"function eV.peripheral_drive.methods:play(process)if not self.internalState.peripheral.call(self.id,"hasAudio")then error("Inserted disk is not an audio disc",2)end;return self.internalState.peripheral.call(self.id,"playAudio")end;eV.peripheral_drive.methods.stop=e_"stopAudio"eV.peripheral_drive.methods.eject=e_"ejectDisk"eV.peripheral_drive.methods.insert=f2"insertDisk"("string")function eV.peripheral_drive:init()eW(self)self.displayName=(self.internalState.peripheral.call(self.id,"getDiskLabel")or"No disk").." on drive "..self.id end;eZ"drive"eventHooks.disk=eventHooks.disk or{}eventHooks.disk[#eventHooks.disk+1]=function(as)local dl=getNodeById(as[2])if not dl then syslog.log({level="notice",module="Hardware"},"Received "..as[1].." event for device ID "..as[2]..", but no device node was found; ignoring")return end;hardware.broadcast(dl,"disk",{device=hardware.path(dl)})end;eventHooks.disk_eject=eventHooks.disk_eject or{}eventHooks.disk_eject[#eventHooks.disk_eject+1]=function(as)local dl=getNodeById(as[2])if not dl then syslog.log({level="notice",module="Hardware"},"Received "..as[1].." event for device ID "..as[2]..", but no device node was found; ignoring")return end;hardware.broadcast(dl,"disk_eject",{device=hardware.path(dl)})end;eV.peripheral_energy_storage={name="peripheral_energy_storage",type="energy_storage",properties={"energy"},methods={}}eV.peripheral_energy_storage.methods.getEnergy=e_"getEnergy"function eV.peripheral_energy_storage:init()eW(self)self.displayName="Energy storage block at "..self.id;self.metadata.capacity=self.internalState.peripheral.call(self.id,"getEnergyCapacity")end;eZ"energy_storage"eV.peripheral_fluid_storage={name="peripheral_fluid_storage",type="fluid_storage",properties={"tanks"},methods={}}eV.peripheral_fluid_storage.methods.getTanks=e_"tanks"function eV.peripheral_fluid_storage.methods:push(process,bJ,f9,m)expect(1,bJ,"string")expect(2,f9,"number","nil")expect(3,m,"string","nil")local dZ;local fa={hardware.get(bJ)}if#fa==1 then dZ=fa[1]else for z,i in ipairs(fa)do if i.parent==self.parent then dZ=i;break end end end;if not dZ then error("No such device",0)elseif dZ.parent~=self.parent then error("Devices must be on the same network",0)end;local bb=false;for z,i in ipairs(dZ.drivers)do if i==eV.peripheral_fluid_storage then bb=true;break end end;if not bb then error("Target device is not a fluid storage block",0)end;return self.internalState.peripheral.call(self.id,"pushFluid",dZ.id,f9,m)end;function eV.peripheral_fluid_storage.methods:pull(process,bI,f9,m)expect(1,bI,"string")expect(2,f9,"number","nil")expect(3,m,"string","nil")local dZ;local fa={hardware.get(bI)}if#fa==1 then dZ=fa[1]else for z,i in ipairs(fa)do if i.parent==self.parent then dZ=i;break end end end;if not dZ then error("No such device",0)elseif dZ.parent~=self.parent then error("Devices must be on the same network",0)end;local bb=false;for z,i in ipairs(dZ.drivers)do if i==eV.peripheral_fluid_storage then bb=true;break end end;if not bb then error("Target device is not a fluid storage block",0)end;return self.internalState.peripheral.call(self.id,"pullFluid",dZ.id,f9,m)end;function eV.peripheral_fluid_storage:init()eW(self)self.displayName="Fluid storage block at "..self.id end;eZ"fluid_storage"eV.peripheral_inventory={name="peripheral_inventory",type="inventory",properties={"items"},methods={}}eV.peripheral_inventory.methods.getItems=e_"list"eV.peripheral_inventory.methods.detail=f1"getItemDetail"("number")eV.peripheral_inventory.methods.limit=f1"getItemLimit"("number")function eV.peripheral_inventory.methods:push(process,bJ,fb,f9,fc)expect(1,bJ,"string")expect(2,fb,"number")expect(3,f9,"number","nil")expect(4,fc,"number","nil")local dZ;local fa={hardware.get(bJ)}if#fa==1 then dZ=fa[1]else for z,i in ipairs(fa)do if i.parent==self.parent then dZ=i;break end end end;if not dZ then error("No such device",0)elseif dZ.parent~=self.parent then error("Devices must be on the same network",0)end;local bb=false;for z,i in ipairs(dZ.drivers)do if i==eV.peripheral_inventory then bb=true;break end end;if not bb then error("Target device is not an inventory block",0)end;return self.internalState.peripheral.call(self.id,"pushItems",dZ.id,fb,f9,fc)end;function eV.peripheral_inventory.methods:pull(process,bI,fb,f9,fc)expect(1,bI,"string")expect(2,fb,"number")expect(3,f9,"number","nil")expect(4,fc,"number","nil")local dZ;local fa={hardware.get(bI)}if#fa==1 then dZ=fa[1]else for z,i in ipairs(fa)do if i.parent==self.parent then dZ=i;break end end end;if not dZ then error("No such device",0)elseif dZ.parent~=self.parent then error("Devices must be on the same network",0)end;local bb=false;for z,i in ipairs(dZ.drivers)do if i==eV.peripheral_inventory then bb=true;break end end;if not bb then error("Target device is not an inventory block",0)end;return self.internalState.peripheral.call(self.id,"pullItems",dZ.id,fb,f9,fc)end;function eV.peripheral_inventory:init()eW(self)self.displayName="Inventory at "..self.id;self.metadata.size=self.internalState.peripheral.call(self.id,"size")end;eZ"inventory"eV.peripheral_monitor={name="peripheral_monitor",type="monitor",properties={"scale","size"},methods={}}eV.peripheral_monitor.methods.getScale=e_"getTextScale"eV.peripheral_monitor.methods.setScale=f1"setTextScale"("number")function eV.peripheral_monitor.methods:getSize()local ag,ah=self.internalState.peripheral.call(self.id,"getSize")return{width=ag,height=ah}end;function eV.peripheral_monitor.methods:write(process,...)for w,i in ipairs{...}do if w>1 then terminal.write(self.internalState.tty,"\t")end;terminal.write(self.internalState.tty,i)end;terminal.redraw(self.internalState.tty)end;function eV.peripheral_monitor.methods:termctl(process,d4)expect(1,d4,"table","nil")if d4 then expect.field(d4,"cbreak","boolean","nil")expect.field(d4,"delay","boolean","nil")expect.field(d4,"echo","boolean","nil")expect.field(d4,"keypad","boolean","nil")expect.field(d4,"nlcr","boolean","nil")expect.field(d4,"raw","boolean","nil")for h,i in pairs(d4)do if self.internalState.tty.flags[h]~=nil then self.internalState.tty.flags[h]=i end end end;local t=deepcopy(self.internalState.tty.flags)t.hasgfx=term.getGraphicsMode~=nil;return t end;function eV.peripheral_monitor.methods:openterm(process)return terminal.openterm(self.internalState.tty,process)end;function eV.peripheral_monitor.methods:opengfx(process)return terminal.opengfx(self.internalState.tty,process)end;function eV.peripheral_monitor:init()eW(self)local ag,ah=self.internalState.peripheral.call(self.id,"getSize")local fd=self.internalState.peripheral.call(self.id,"getTextScale")self.displayName=ag*fd.."x"..ah*fd.." monitor at "..self.id;local term={}for z,i in ipairs(self.internalState.peripheral.getMethods(self.id))do term[i]=function(...)return self.internalState.peripheral.call(self.id,i,...)end end;self.internalState.tty=terminal.makeTTY(term,ag,ah)self.internalState.tty.isMonitor=true;terminal.redraw(self.internalState.tty,true)end;function eV.peripheral_monitor:deinit()local cX=self.internalState.tty;if cX.frontmostProcess then local i=cX.frontmostProcess;if i.stdin==cX then i.stdin=nil end;if i.stdout==cX then i.stdout=nil end;if i.stderr==cX then i.stderr=nil end end;for z,i in ipairs(cX.processList)do if i.stdin==cX then i.stdin=nil end;if i.stdout==cX then i.stdout=nil end;if i.stderr==cX then i.stderr=nil end end end;eZ"monitor"eventHooks.monitor_resize=eventHooks.monitor_resize or{}eventHooks.monitor_resize[#eventHooks.monitor_resize+1]=function(as)local dl=getNodeById(as[2])if not dl then syslog.log({level="notice",module="Hardware"},"Received "..as[1].." event for device ID "..as[2]..", but no device node was found; ignoring")return end;local ag,ah=eV.peripheral_monitor.methods.getSize(dl)terminal.resize(dl.internalState.tty,ag,ah)hardware.broadcast(dl,"monitor_resize",{device=hardware.path(dl),width=ag,height=ah})end;eV.peripheral_printer={name="peripheral_printer",type="printer",properties={"inkLevel","paperLevel"},methods={}}eV.peripheral_printer.methods.getInkLevel=e_"getInkLevel"eV.peripheral_printer.methods.getPaperLevel=e_"getPaperLevel"function eV.peripheral_printer.methods:page(process)if self.internalState.printer.open then self.internalState.peripheral.call(self.id,"endPage")self.internalState.printer.open=false end;if not self.internalState.peripheral.call(self.id,"newPage")then return nil end;self.internalState.printer.open=true;local fe,p,q;local function d3(...)if not self.internalState.printer.open then error("attempt to use closed page",2)end;return self.internalState.peripheral.call(self.id,"write",...)end;local function ff()if not self.internalState.printer.open then return true end;if not self.internalState.peripheral.call(self.id,"endPage")then return false end;self.internalState.printer.open=false end;setfenv(d3,process.env)setfenv(ff,process.env)debug.protect(d3)debug.protect(ff)return eX(process,{__index=function(z,aB)if not self.internalState.printer.open then error("attempt to use closed page",2)end;if aB=="size"then local u,cT=self.internalState.peripheral.call(self.id,"getPageSize")return eX(process,{__index=function(z,aB)if aB=="width"then return u elseif aB=="height"then return cT end end,__newindex=function()error("Cannot modify read-only table",2)end})elseif aB=="cursor"then p,q=self.internalState.peripheral.call(self.id,"getCursorPos")return eX(process,{__index=function(z,aB)if aB=="x"then return p elseif aB=="y"then return q end end,__newindex=function(z,aB,aC)if aB=="x"then p=aC;self.internalState.peripheral.call(self.id,"setCursorPos",p,q)elseif aB=="y"then q=aC;self.internalState.peripheral.call(self.id,"setCursorPos",p,q)else error("Cannot modify member '"..aB.."'",2)end end})elseif aB=="title"then return fe elseif aB=="isOpen"then return self.internalState.printer.open elseif aB=="write"then return d3 elseif aB=="close"then return ff end end,__newindex=function(z,aB,aC)if not self.internalState.printer.open then error("attempt to use closed page",2)end;if aB=="cursor"then if type(aC)~="table"then error("bad value for 'cursor' (expected table, got "..type(aC)..")",2)end;expect.field(aC,"x","number")expect.field(aC,"y","number")p,q=aC.x,aC.y;self.internalState.peripheral.call(self.id,"setCursorPos",p,q)elseif aB=="title"then if type(aC)~="string"and aC~=nil then error("bad value for 'title' (expected string, got "..type(aC)..")",2)end;fe=aC;self.internalState.peripheral.call(self.id,"setPageTitle",fe)else error("Cannot modify member '"..aB.."'",2)end end})end;function eV.peripheral_printer:init()eW(self)self.displayName="Speaker at "..self.id;self.internalState.printer={open=false}end;eZ"printer"eV.peripheral_speaker={name="peripheral_speaker",type="speaker",properties={},methods={}}function eV.peripheral_speaker.methods:playNote(process,fg,fh,fi)expect(1,fg,"string")expect(2,fh,"number","nil")expect(3,fi,"number","nil")if fh then expect.range(fh,0,3)end;if fi then expect.range(fi,0,24)end;return self.internalState.peripheral.call(self.id,"playNote",fg,fh,fi)end;function eV.peripheral_speaker.methods:playSound(process,m,fh,fj)expect(1,m,"string")expect(2,fh,"number","nil")expect(3,fj,"number","nil")if fh then expect.range(fh,0,3)end;if fj then expect.range(fj,0.5,2.0)end;return self.internalState.peripheral.call(self.id,"playNote",m,fh,fj)end;function eV.peripheral_speaker.methods:playAudio(fk,fh)expect(1,fk,"table")expect(2,fh,"number","nil")if fh then expect.range(fh,0,3)end;return self.internalState.peripheral.call(self.id,"playAudio",fk,fh)end;eV.peripheral_speaker.methods.stop=e_"stop"function eV.peripheral_command:init()eW(self)self.displayName="Speaker at "..self.id end;eZ"speaker"eventHooks.speaker_audio_empty=eventHooks.speaker_audio_empty or{}eventHooks.speaker_audio_empty[#eventHooks.speaker_audio_empty+1]=function(as)local dl=getNodeById(as[2])if not dl then syslog.log({level="notice",module="Hardware"},"Received "..as[1].." event for device ID "..as[2]..", but no device node was found; ignoring")return end;hardware.broadcast(dl,"speaker_audio_empty",{device=hardware.path(dl)})end;local fl={eV.peripheral_command,eV.peripheral_computer,eV.peripheral_drive,eV.peripheral_energy_storage,eV.peripheral_fluid_storage,eV.peripheral_inventory,eV.peripheral_monitor,eV.peripheral_printer,eV.peripheral_speaker}function registerDriver(eA)local fm=eA.init;eA.init=function(dl)eW(dl)if fm then return fm(dl)end end;eA.__callback=eY(eA,eA.type)hardware.listen(eA.__callback,deviceTreeRoot)fl[#fl+1]=eA;for z,dl in ipairs(hardware.find("modem"))do if not dl.metadata.wireless then hardware.listen(eA.__callback,dl)dl.internalState.modem.callbacks[#dl.internalState.modem.callbacks+1]=f end end end;function deregisterDriver(eA)if not eA.__callback then return end;hardware.unlisten(eA.__callback)for z,i in ipairs(hardware.find(eA.type))do hardware.deregister(i,eA)end;for w,i in ipairs(eU)do if i==eA then table.remove(eU,w)break end end;for z,dl in ipairs(hardware.find("modem"))do if not dl.metadata.wireless then hardware.unlisten(eA.__callback)for w,i in ipairs(dl.internalState.modem.callbacks)do if i==eA.__callback then table.remove(dl.internalState.modem.callbacks,w)break end end end end end;eV.peripheral_modem={name="peripheral_modem",type="modem",properties={"remainingChannels"},methods={}}function eV.peripheral_modem.methods:getRemainingChannels()local b=128;for z in pairs(self.internalState.modem)do b=b-1 end;return b end;function eV.peripheral_modem.methods:open(process,fn)if not self.internalState.modem[fn]then self.internalState.peripheral.call(self.id,"open",fn)self.internalState.modem[fn]={}end;self.internalState.modem[fn][process]=true end;function eV.peripheral_modem.methods:isOpen(process,fn)return self.internalState.modem[fn]and self.internalState.modem[fn][process]end;function eV.peripheral_modem.methods:close(process,fn)self.internalState.modem[fn][process]=nil;if not next(self.internalState.modem[fn])then self.internalState.peripheral.call(self.id,"close",fn)self.internalState.modem[fn]=nil end end;function eV.peripheral_modem.methods:closeAll(process)for fn=0,65535 do self.internalState.modem[fn][process]=nil;if not next(self.internalState.modem[fn])then self.internalState.peripheral.call(self.id,"close",fn)self.internalState.modem[fn]=nil end end end;function eV.peripheral_modem.methods:transmit(process,fn,fo,fp)expect(1,fn,"number")fo=expect(2,fo,"number","nil")or fn;return self.internalState.peripheral.call(self.id,"transmit",fn,fo,fp)end;function eV.peripheral_modem:init()eW(self)self.metadata.wireless=self.internalState.peripheral.call(self.id,"isWireless")self.displayName=(self.metadata.wireless and"Wireless"or"Wired").." modem at "..self.id;self.internalState.modem={}self.internalState.modem.channels={}self.internalState.peripheral.call(self.id,"closeAll")if not self.metadata.wireless then self.internalState.modem.callbacks={}for z,i in ipairs(fl)do local f=eY(i,i.type)hardware.listen(f,self)self.internalState.modem.callbacks[#self.internalState.modem.callbacks+1]=f end;local f=eY(eV["peripheral_computer"],"turtle")hardware.listen(f,self)self.internalState.modem.callbacks[#self.internalState.modem.callbacks+1]=f;for z,m in ipairs(self.internalState.peripheral.call(self.id,"getNamesRemote"))do hardware.add(self,m)end end end;function eV.peripheral_modem:deinit()if not self.metadata.wireless then for z,i in ipairs(self.internalState.modem.callbacks)do hardware.unlisten(i)end end end;eZ"modem"eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(as)local dl=getNodeById(as[2])or hardware.get(as[2])if not dl then syslog.log({level="notice",module="Hardware"},"Received "..as[1].." event for device ID "..as[2]..", but no device node was found; ignoring")return end;local a5=false;for i in pairs(dl.listeners)do if dl.internalState.modem[as[3]][i]then i.eventQueue[#i.eventQueue+1],a5={"modem_message",{device=hardware.path(dl),channel=as[3],replyChannel=as[4],message=as[5],distance=as[6]}},true end end;return a5 end;eV.loopback_modem={name="loopback_modem",type="modem",properties={"remainingChannels"},methods={}}function eV.loopback_modem.methods:getRemainingChannels()local b=128;for z in pairs(self.internalState.modem)do b=b-1 end;return b end;function eV.loopback_modem.methods:open(process,fn)if not self.internalState.modem[fn]then self.internalState.modem[fn]={}end;self.internalState.modem[fn][process]=true end;function eV.loopback_modem.methods:isOpen(process,fn)return self.internalState.modem[fn]and self.internalState.modem[fn][process]end;function eV.loopback_modem.methods:close(process,fn)self.internalState.modem[fn][process]=nil;if not next(self.internalState.modem[fn])then self.internalState.modem[fn]=nil end end;function eV.loopback_modem.methods:closeAll(process)for fn=0,65535 do self.internalState.modem[fn][process]=nil;if not next(self.internalState.modem[fn])then self.internalState.modem[fn]=nil end end end;function eV.loopback_modem.methods:transmit(process,fn,fo,fp)expect(1,fn,"number")fo=expect(2,fo,"number","nil")or fn;os.queueEvent("modem_message",self.uuid,fn,fo,fp,0)end;function eV.loopback_modem:init()self.metadata.wireless=true;self.displayName="Loopback modem"self.internalState.modem={}self.internalState.modem.channels={}end;local function fq(fr)local a_={scheme=""}for a9 in fr:gmatch"."do if a_.fragment then if a9:match"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/?]"then a_.fragment=a_.fragment..a9 else error("Invalid URI",3)end elseif a_.query then if a9=="#"then a_.fragment=""elseif a9:match"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/?]"then a_.query=a_.query..a9 else error("Invalid URI",3)end elseif a_.path then if a9=="/"and a_.path=="/"and not a_.host then a_.path,a_.host=nil,""elseif a9=="?"then a_.query=""elseif a9=="#"then a_.fragment=""elseif a9:match"[%w%-%._~%%@:/!%$&'%(%)%*%+,;=/]"then a_.path=a_.path..a9 else error("Invalid URI",3)end elseif a_.port then if tonumber(a9)then a_.port=a_.port..a9 elseif a9=="/"then a_.path="/"else error("Invalid URI",3)end elseif a_.host then if a9=="@"and not a_.user then a_.user,a_.host=a_.host,""elseif a9==":"then a_.port=""elseif a9=="/"then a_.path="/"elseif a9:match"[%w%-%._~%%/!%$&'%(%)%*%+,;=]"then a_.host=a_.host..a9 else error("Invalid URI",3)end else if a9==":"then a_.path=""elseif a9:match(a_.scheme==""and"[%a%+%-%.]"or"[%w%+%-%.]")then a_.scheme=a_.scheme..a9 else error("Invalid URI",3)end end end;if a_.port then a_.port=tonumber(a_.port)end;return a_ end;local function ft(fu)if fu:match"^%d+$"then return tonumber(fu)elseif fu:match"^%d+%.%d+$"then return tonumber(fu:match"^%d+")*0x1000000+tonumber(fu:match"^%d+%.(%d+)")elseif fu:match"^%d+%.%d+%.%d+$"then return tonumber(fu:match"^(%d+)")*0x1000000+tonumber(fu:match"^%d+%.(%d+)")*0x10000+tonumber(fu:match"^%d+%.%d+%.(%d+)")elseif fu:match"^%d+%.%d+%.%d+%.%d+$"then return tonumber(fu:match"^(%d+)")*0x1000000+tonumber(fu:match"^%d+%.(%d+)")*0x10000+tonumber(fu:match"^%d+%.%d+%.(%d+)")*0x100+tonumber(fu:match"^%d+%.%d+%.%d+%.(%d+)")else error("Invalid IP address",2)end end;local function fv(b)if not b then return nil end;return("%d.%d.%d.%d"):format(bit32.band(bit32.rshift(b,24),0xFF),bit32.band(bit32.rshift(b,16),0xFF),bit32.band(bit32.rshift(b,8),0xFF),bit32.band(b,0xFF))end;local function fw(fx)local bj=""for w=1,fx do bj=bj..string.char(math.random(0,255))end;return bj end;local function fy(b)return bit32.bnot(2^(32-b)-1)end;local function fz(x)local r=0;while bit32.btest(x,0x80000000)do x,r=bit32.lshift(x,1),r+1 end;return r end;local function fA(dl)if not dl then error("No such device")end;for z,i in pairs(dl.drivers)do if i.type=="modem"then return dl end end;error("Not a modem")end;local fB=0;local fC={}local fD={maxn=0,[0]={}}local fE={}local fF={send={},recv={}}local fG={}local fH=setmetatable({},{__mode="k"})local fI={arp={},socket={}}local fJ={}function fF.send.link(a_,fK,af)expect(2,fK,"number","nil")expect.field(a_,"device","table")local br={PhoenixNetworking=true,type="link",source=os.computerID(),destination=fK,payload=af}if fK==os.computerID()then os.queueEvent("modem_message",a_.device.id,a_.outPort or 0,a_.inPort or 0,br,0)else hardware.call(a_.process or KERNEL,a_.device,"transmit",a_.outPort or 0,a_.inPort or 0,br)end end;function fF.send.arp_request(a_,fu)expect.field(a_,"device","table")expect(2,fu,"string")hardware.call(a_.process or KERNEL,a_.device,"transmit",0,0,{PhoenixNetworking=true,type="arp",reply=false,source=os.computerID(),sourceIP=fC[a_.device.uuid]and fv(fC[a_.device.uuid].ip),destinationIP=fu})end;function fF.send.arp_reply(a_,fK,fL)expect.field(a_,"device","table")expect(2,fK,"number")expect(3,fL,"string","nil")hardware.call(a_.process or KERNEL,a_.device,"transmit",0,0,{PhoenixNetworking=true,type="arp",reply=true,source=os.computerID(),sourceIP=fv(fC[a_.device.uuid].ip),destination=fK,destinationIP=fL})end;function fF.send.internet(a_,fK,af)expect(2,fK,"number")local dS={PhoenixNetworking=true,type="internet",hopsLeft=15,payload=af,destination=fv(fK)}local dy=fw(32)dS.messageID=dy;local i;for w=fD.maxn,0,-1 do if fD[w]then for z,fM in ipairs(fD[w])do if bit32.band(fM.source,fM.sourceNetmask)==bit32.band(fK,fM.sourceNetmask)and(not i or fz(fM.sourceNetmask)>fz(i.sourceNetmask))then i=fM end end end end;if not i then return fF.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="No route to host",payload=dS})end;if i.action=="unicast"and fC[i.device.uuid]and fC[i.device.uuid].up then a_.device=i.device;dS.source=fv(fC[i.device.uuid].ip)if fE[i.device.uuid]and fE[i.device.uuid][i.destination]then return fF.send.link(a_,fE[i.device.uuid][i.destination],dS)end;local fN=false;local eQ;local function fO(z,fu,bv)if not fN and ft(fu)==i.destination then fN=true;fF.send.link(a_,bv,dS)end;if fN then for w,f in ipairs(fI.arp)do if f==fO then table.remove(fI.arp,w)break end end end end;local function fP(as)if as[2]==eQ then if not fN then fF.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="No route to host",payload=dS})end;fN=true;for w,i in ipairs(eventHooks.timer)do if i==fP then table.remove(eventHooks.timer,w)break end end;for w,f in ipairs(fI.arp)do if f==fO then table.remove(fI.arp,w)break end end end end;fI.arp[#fI.arp+1]=fO;fF.send.arp_request(a_,fv(i.destination))eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=fP;eQ=os.startTimer(2)return elseif i.action=="broadcast"and fC[i.device.uuid]and fC[i.device.uuid].up then a_.device=i.device;dS.source=fv(fC[i.device.uuid].ip)return fF.send.link(a_,nil,dS)elseif i.action=="local"and fC[i.device.uuid]and fC[i.device.uuid].up then a_.device=i.device;dS.source=fv(fC[i.device.uuid].ip)if fE[i.device.uuid]and fE[i.device.uuid][fK]then return fF.send.link(a_,fE[i.device.uuid][fK],dS)end;local fN=false;local eQ;local function fO(z,fu,bv)if not fN and ft(fu)==fK then fN=true;fF.send.link(a_,bv,dS)end;if fN then for w,f in ipairs(fI.arp)do if f==fO then table.remove(fI.arp,w)break end end end end;local function fP(as)if as[2]==eQ then if not fN then fF.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="No route to host",payload=dS})end;fN=true;for w,i in ipairs(eventHooks.timer)do if i==fP then table.remove(eventHooks.timer,w)break end end end end;fI.arp[#fI.arp+1]=fO;fF.send.arp_request(a_,fv(fK))eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=fP;eQ=os.startTimer(2)return elseif i.action=="unreachable"then return fF.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="Destination unreachable",payload=dS})elseif i.action=="prohibit"then return fF.recv.control({},{PhoenixNetworking=true,messageType="unreachable",error="Prohibited",payload=dS})elseif i.action=="blackhole"then return end end;function fF.send.control(a_,fK,type,o,fQ)expect(3,type,"string")expect(4,o,"string","nil")return fF.send.internet(a_,fK,{PhoenixNetworking=true,type="control",messageType=type,error=o,payload=fQ})end;fF.send.socket={}function fF.send.socket.connect(a_,fu,fR,fS)for w=1,16384 do local E=math.random(49152,65535)if not fG[E]then fS.localPort=E;break end end;if not fS.localPort then error("Too many open sockets")end;fS.id=fB;fB=fB+1;fS.ip=fu;fS.port=fR;fS.sendSeq=math.floor(math.random()*0x1000000000000)fS.sendSeqNext=fS.sendSeq+2;fS.sendSeqMax=fS.sendSeq+256;a_.outPort=fR;a_.inPort=fS.localPort;fF.send.internet(a_,fu,{PhoenixNetworking=true,type="socket",sequence=fS.sendSeqNext-1,windowSize=256,synchronize=true})local bb,o=pcall(hardware.call,a_.process or KERNEL,a_.device,"open",fS.localPort)if not bb then fF.send.internet(a_,fu,{PhoenixNetworking=true,type="socket",sequence=fS.sendSeqNext,windowSize=0,reset=true})error(o)end;fS.status="syn-sent"fS.nextUpdate=os.epoch"utc"+5000;fS.process=a_.process;fS.retryCount=0;fG[fS.localPort]=fS end;function fF.send.socket.data(a_,af,fS)a_.outPort=fS.port;a_.inPort=fS.localPort;af.PhoenixNetworking=true;af.type="socket"if not af.sequence then af.sequence=fS.sendSeqNext;fS.sendSeqNext=fS.sendSeqNext+1 end;af.acknowledgement=af.acknowledgement or fS.recvSeq-1;fS.nextAck=nil;if not af.final then af.windowSize=256 end;return fF.send.internet(a_,fS.ip,af)end;function fF.send.socket.ack(a_,b,fS)return fF.send.socket.data(a_,{acknowledgement=b},fS)end;function fF.send.socket.reset(a_,fu,fR,fT,fU,fV)a_.outPort=fR;a_.inPort=fV or fR;return fF.send.internet(a_,fu,{PhoenixNetworking=true,type="socket",sequence=fT,acknowledgement=fU,reset=true})end;local function fW(fS,n,...)n=n or"*l"if type(n)~="string"and type(n)~="number"then error("bad argument (expected string or number, got "..type(n)..")",2)end;if fS.buffer==""then return nil end;n=n:gsub("^%*","")if n=="a"then local a0=fS.buffer;fS.buffer=""return a0 elseif n=="l"then local a0,a7=fS.buffer:match"^([^\n]*)\n?()"if a0 then fS.buffer=fS.buffer:sub(a7)if select("#",...)>0 then return a0,fW(fS,...)else return a0 end else return nil end elseif n=="L"then local a0,a7=fS.buffer:match"^([^\n]*\n?)()"if a0 then fS.buffer=fS.buffer:sub(a7)if select("#",...)>0 then return a0,fW(fS,...)else return a0 end else return nil end elseif n=="n"then local a0,a7=fS.buffer:match"(%d+)()"if a0 then fS.buffer=fS.buffer:sub(a7)if select("#",...)>0 then return tonumber(a0),fW(fS,...)else return tonumber(a0)end else return nil end elseif type(n)=="number"then local a0=fS.buffer:sub(1,n)fS.buffer=fS.buffer:sub(n+1)if select("#",...)>0 then return a0,fW(fS,...)else return a0 end else error("bad argument (invalid mode '"..n.."')",2)end end;local function fX(fS,bd,...)bd=tostring(bd)fS.outQueue[fS.sendSeqNext]=bd;fF.send.socket.data({},{payload=bd},fS)if select("#",...)>0 then return fX(fS,...)end end;function syscalls.__socketcall(process,ar,fR,eD,...)local fS=fG[fR]if not fS or fS.process~=process then error("No such socket")end;if eD=="close"then fS.sendSeqMax=fS.sendSeqNext;fF.send.socket.data({},{final=true},fS)fS.status="fin-wait"elseif eD=="read"then return fW(fS,...)elseif eD=="write"then return fX(fS,...)else error("No such method")end end;local do_syscall=do_syscall;local function fY(fS)local br=setmetatable({id=fS.id},{__name="socket"})function br:status()if fS.status=="listening"or fS.status=="syn-sent"or fS.status=="syn-received"then return"connecting"elseif fS.status=="connected"then return"connected"elseif fS.status=="error"then return"error",fS.error else return"closed"end end;function br:read(n,...)if fS.status~="connected"then error("attempt to read from a "..fS.status.." handle",2)end;return do_syscall("__socketcall",fS.localPort,"read",n,...)end;function br:write(bd,...)if fS.status~="connected"then error("attempt to write to a "..fS.status.." handle",2)end;return do_syscall("__socketcall",fS.localPort,"write",bd,...)end;function br:close()if not(fS.status=="listening"or fS.status=="syn-sent"or fS.status=="syn-received"or fS.status=="connected")then error("attempt to close a "..fS.status.." handle",2)end;return do_syscall("__socketcall",fS.localPort,"close")end;return br end;function fF.recv.link(a_,af)expect.field(af,"source","number")expect.field(af,"destination","number")expect.field(af,"payload","table")syslog.debug("Received link message from",af.source,"to",af.destination)if af.destination~=os.computerID()then return end;a_.sourceID=af.source;assert(af.payload.PhoenixNetworking)expect.field(af.payload,"type","string")if not fF.recv[af.payload.type]then error("Unknown protocol '"..af.payload.type.."'")end;return fF.recv[af.payload.type](a_,af.payload)end;function fF.recv.arp(a_,af)expect.field(af,"source","number")expect.field(af,"reply","boolean")syslog.debug("Received arp message from",af.source)if not af.reply and af.destinationIP and af.sourceIP~=af.destinationIP then local fu=ft(expect.field(af,"destinationIP","string"))if fC[a_.device.uuid]and fC[a_.device.uuid].ip==fu then fF.send.arp_reply(a_,af.source,af.sourceIP)end end;if af.sourceIP then local fu=ft(expect.field(af,"sourceIP","string"))fE[a_.device.uuid]=fE[a_.device.uuid]or{}fE[a_.device.uuid][fu]=af.source;local fZ={}for w,i in ipairs(fI.arp)do fZ[w]=i end;for z,i in ipairs(fZ)do i(i,af.sourceIP,af.source)end end end;function fF.recv.internet(a_,af)a_.sourceIP=ft(expect.field(af,"source","string"))local bv=ft(expect.field(af,"destination","string"))syslog.debug("Received internet message from",af.source,"to",af.destination)expect.field(af,"payload","table")if fJ[expect.field(af,"messageID","number","string")]then return end;fJ[af.messageID]=os.epoch"utc"if not fC[a_.device.uuid]or fC[a_.device.uuid].ip~=bv then return end;a_.ipPacket=af;assert(af.payload.PhoenixNetworking)expect.field(af.payload,"type","string")if not fF.recv[af.payload.type]then error("Unknown protocol '"..af.payload.type.."'")end;return fF.recv[af.payload.type](a_,af.payload)end;function fF.recv.control(a_,af)expect.field(af,"messageType","string")syslog.debug("Received control message",af.messageType)local a5=false;if af.messageType=="ping"then fF.send.control({device=a_.device},a_.sourceIP,"pong",nil,a_.ipPacket)else for z,i in pairs(fH)do a5=i{type="control",messageType=af.messageType,error=af.error,payload=af.payload,sender=fv(a_.sourceIP)}or a5 end end;return a5 end;function fF.recv.socket(a_,af)expect.field(af,"sequence","number")expect.field(af,"acknowledgement","number","nil")expect.field(af,"windowSize","number","nil")expect.field(af,"payload","string","nil")if a_.channel==0 or a_.replyChannel==0 then syslog.debug("Received socket event on channel 0; discarding.")return end;local fS=fG[a_.channel]if not fS then if af.acknowledgement then fF.send.socket.reset(a_,a_.sourceIP,a_.replyChannel,af.acknowledgement,nil,a_.channel)else fF.send.socket.reset(a_,a_.sourceIP,a_.replyChannel,0,af.sequence+(af.windowSize or 0),a_.channel)end;return end;do local bj={}for h,i in pairs(fS)do if h~="process"then bj[h]=i end end;syslog.debug("Received socket message:",serialize(af),"\nSocket info:",serialize(bj))end;if fS.status=="listening"then if af.reset then return end;if af.acknowledgement then fF.send.socket.reset(a_,a_.sourceIP,a_.replyChannel,af.acknowledgement,nil,a_.channel)return end;if not af.synchronize then return end;fS.ip=a_.sourceIP;fS.port=a_.replyChannel;fS.recvSeq=af.sequence+1;fS.recvSeqMax=fS.recvSeq+(af.windowSize or 0)fS.sendSeq=math.floor(math.random()*0x1000000000000)fS.sendSeqNext=fS.sendSeq+2;fS.sendSeqMax=fS.sendSeq+(af.windowSize or 0)fS.status="syn-received"fS.nextUpdate=os.epoch"utc"+5000;fS.retryCount=0;fF.send.internet({inPort=a_.channel,outPort=a_.replyChannel},fS.ip,{PhoenixNetworking=true,type="socket",sequence=fS.sendSeqNext-1,acknowledgement=fS.recvSeq,windowSize=256,synchronize=true})elseif fS.status=="syn-sent"then if af.reset then fS.status="error"fS.error="Connection refused"fG[a_.channel]=nil;if fS.process then fS.process.eventQueue[#fS.process.eventQueue+1]={"handle_status_change",{id=fS.id,status="error"}}end;return true end;if not af.synchronize or not af.acknowledgement or af.acknowledgement<fS.sendSeq then fF.send.socket.reset(a_,a_.sourceIP,a_.replyChannel,af.acknowledgement,nil,a_.channel)fS.status="error"fS.error="Connection refused"fG[a_.channel]=nil;if fS.process then fS.process.eventQueue[#fS.process.eventQueue+1]={"handle_status_change",{id=fS.id,status="error"}}end;return true end;fS.status="connected"fS.sendSeq=af.acknowledgement;fS.sendSeqMax=fS.sendSeq+256;fS.recvSeq=af.sequence+1;fS.recvSeqMax=fS.recvSeq+(af.windowSize or 0)fS.outQueue={}fS.nextUpdate=os.epoch"utc"+2000;fF.send.socket.ack({},fS.recvSeq,fS)if fS.process then fS.process.eventQueue[#fS.process.eventQueue+1]={"handle_status_change",{id=fS.id,status="connected"}}end;return true else if af.sequence<fS.recvSeq or af.sequence>fS.recvSeqMax then syslog.debug("Sequence out of range")if af.reset then fS.status="error"fS.error="Connection reset by peer"fG[a_.channel]=nil;if fS.process then fS.process.eventQueue[#fS.process.eventQueue+1]={"handle_status_change",{id=fS.id,status="error"}}end;return true else fF.send.socket.ack({},fS.recvSeq,fS)return end end;if af.reset then syslog.debug("Received reset")if fS.status=="syn-received"then fS.status="listening"return elseif fS.status=="connected"or fS.status=="fin-wait"then fS.status="error"fS.error="Connection reset by peer"fG[a_.channel]=nil;if fS.process then fS.process.eventQueue[#fS.process.eventQueue+1]={"handle_status_change",{id=fS.id,status="error"}}end;return true else fS.status="closed"fG[a_.channel]=nil;if fS.process then fS.process.eventQueue[#fS.process.eventQueue+1]={"handle_status_change",{id=fS.id,status="closed"}}end;return true end end;if af.synchronize then fF.send.socket.reset(a_,a_.sourceIP,a_.replyChannel,af.acknowledgement,nil,a_.channel)fS.status="error"fS.error="Connection reset by host"fG[a_.channel]=nil;if fS.process then fS.process.eventQueue[#fS.process.eventQueue+1]={"handle_status_change",{id=fS.id,status="error"}}end;return true end;local a5;if not af.acknowledgement then syslog.debug("No acknowledgement")return end;if fS.status=="syn-received"then if af.acknowledgement>=fS.sendSeq and af.acknowledgement<=fS.sendSeqNext then fS.status="connected"fS.outQueue={}fS.nextUpdate=os.epoch"utc"+2000;if fS.process then fS.process.eventQueue[#fS.process.eventQueue+1]={"network_request",{uri=fS.uri,ip=a_.sourceIP,handle=fY(fS)}}end;a5=true else fF.send.socket.reset(a_,a_.sourceIP,a_.replyChannel,af.acknowledgement,nil,a_.channel)fS.status="error"fS.error="Connection reset by host"fG[a_.channel]=nil;if fS.process then fS.process.eventQueue[#fS.process.eventQueue+1]={"handle_status_change",{id=fS.id,status="error"}}end;return true end elseif fS.status=="close-wait"then if af.acknowledgement==fS.sendSeqMax then syslog.debug("Socket closed")fS.status="closed"fG[a_.channel]=nil;if fS.process then fS.process.eventQueue[#fS.process.eventQueue+1]={"handle_status_change",{id=fS.id,status="closed"}}end;return true end elseif fS.status=="time-wait"then if af.final then fF.send.socket.ack({},af.sequence,fS)fS.nextUpdate=os.epoch"utc"+10000;return end else if af.acknowledgement>fS.sendSeq and af.acknowledgement<=fS.sendSeqNext then for w=fS.sendSeq,af.acknowledgement do fS.outQueue[w]=nil end;fS.sendSeq=af.acknowledgement;if af.windowSize then fS.sendSeqMax=fS.sendSeq+af.windowSize end end;if fS.status=="fin-wait"then if af.acknowledgement==fS.sendSeqMax then if not af.final then fF.send.socket.reset(a_,a_.sourceIP,a_.replyChannel,af.acknowledgement,nil,a_.channel)fS.status="error"fS.error="Connection reset by host"fG[a_.channel]=nil;if fS.process then fS.process.eventQueue[#fS.process.eventQueue+1]={"handle_status_change",{id=fS.id,status="error"}}end;return true end;fS.status="time-wait"fS.nextUpdate=os.epoch"utc"+10000 end elseif fS.status=="closing"then if af.acknowledgement==fS.sendSeqMax then fS.status="time-wait"fS.nextUpdate=os.epoch"utc"+10000 end end end;if fS.status=="connected"and af.sequence==fS.recvSeq then if af.payload then fS.buffer=fS.buffer..af.payload;fS.nextAck=true;fS.nextUpdate=os.epoch"utc"+100;if fS.process then fS.process.eventQueue[#fS.process.eventQueue+1]={"handle_data_ready",{id=fS.id}}end;a5=true end;fS.recvSeq=fS.recvSeq+1 end;if af.final then syslog.debug("Got final message")fS.recvSeq=af.sequence+1;if fS.status=="syn-received"or fS.status=="connected"then fS.sendSeqMax=fS.sendSeqNext;fF.send.socket.data({},{final=true,acknowledgement=af.sequence},fS)fS.status="close-wait"if fS.process then fS.process.eventQueue[#fS.process.eventQueue+1]={"handle_status_change",{id=fS.id,status="closed"}}end;return true elseif fS.status=="fin-wait"then fF.send.socket.ack({},af.sequence,fS)if af.acknowledgement~=fS.sendSeqMax then fS.status="closing"else fS.status="time-wait"fS.nextUpdate=os.epoch"utc"+10000 end else fF.send.socket.ack({},af.sequence,fS)end;syslog.debug(fS.status)end;return a5 end end;local function f_()local bZ=os.epoch"utc"local e6=false;for fR,fS in pairs(fG)do if bZ>=fS.nextUpdate then if fS.status=="syn-sent"then fS.status="error"fS.error="Connection timed out (syn-sent)"fG[fR]=nil;if fS.process then fS.process.eventQueue[#fS.process.eventQueue+1]={"handle_status_change",{id=fS.id,status="error"}}e6=true end elseif fS.status=="syn-received"then fS.retryCount=fS.retryCount+1;if fS.retryCount>3 then fS.status="error"fS.error="Connection timed out (syn-received)"fG[fR]=nil;if fS.process then fS.process.eventQueue[#fS.process.eventQueue+1]={"handle_status_change",{id=fS.id,status="error"}}e6=true end else fS.nextUpdate=os.epoch"utc"+2000 end elseif fS.status=="connected"then for w=fS.sendSeq+1,fS.sendSeqNext-1 do if fS.outQueue[w]then fF.send.socket.data({},{sequence=w,payload=fS.outQueue[w]},fS)end end;if fS.nextAck then fF.send.socket.ack({},fS.recvSeq-1,fS)fS.nextAck=nil end;fS.nextUpdate=os.epoch"utc"+2000 elseif fS.status=="fin-wait"then elseif fS.status=="close-wait"then elseif fS.status=="time-wait"then syslog.debug("Time wait finished on port "..fR)fS.status="closed"fG[fR]=nil end end end;return e6 end;eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(as)if type(as[5])=="table"and as[5].PhoenixNetworking and type(as[5].type)=="string"and fF.recv[as[5].type]then local dl=getNodeById(as[2])or hardware.get(as[2])if not dl then syslog.log({level="notice",module="Network"},"Received network event for device ID "..as[2]..", but no device node was found; ignoring")return end;if not fC[dl.uuid]or not fC[dl.uuid].up then return end;syslog.debug(as[2],serialize(as[5]))local bb,o=pcall(fF.recv[as[5].type],{channel=as[3],replyChannel=as[4],device=dl},as[5])if not bb then syslog.log({level="debug",module="Network"},"Network event errored while processing:",o)else return o end end end;local g0=os.startTimer(1)eventHooks.timer=eventHooks.timer or{}eventHooks.timer[#eventHooks.timer+1]=function(as)if as[2]==g0 then g0=os.startTimer(1)return f_()end end;local function g1(process,by)local fr=fq(by.url)if not fr.port then error("No port specified")end;local fu=ft(fr.host)local fR=fr.port;local fS={process=process,buffer=""}fF.send.socket.connect({process=process},fu,fR,fS)return fY(fS)end;local g2={}local g3={}local g4={}local g5=os.computerID()%65500;local g6={}eventHooks.http_success=eventHooks.http_success or{}eventHooks.http_success[#eventHooks.http_success+1]=function(as)local a_=g2[as[2]]if a_ then a_.handle,a_.status=as[3],"open"a_.process.eventQueue[#a_.process.eventQueue+1]={"handle_status_change",{id=a_.id,status="open"}}g2[as[2]]=nil;return true else syslog.log({level="notice"},"Received HTTP response for "..as[2].." but nobody requested it; ignoring.")end end;eventHooks.http_failure=eventHooks.http_failure or{}eventHooks.http_failure[#eventHooks.http_failure+1]=function(as)local a_=g2[as[2]]if a_ then if as[4]then a_.handle,a_.status=as[3],"open"else a_.status,a_.error="error",as[3]end;a_.process.eventQueue[#a_.process.eventQueue+1]={"handle_status_change",{id=a_.id,status=a_.status}}g2[as[2]]=nil;return true else syslog.log({level="notice"},"Received HTTP response for "..as[2].." but nobody requested it; ignoring.")end end;eventHooks.websocket_success=eventHooks.websocket_success or{}eventHooks.websocket_success[#eventHooks.websocket_success+1]=function(as)local a_=g2[as[2]]if a_ then a_.handle,a_.status=as[3],"open"a_.process.eventQueue[#a_.process.eventQueue+1]={"handle_status_change",{id=a_.id,status="open"}}return true else syslog.log({level="notice"},"Received WebSocket response for "..as[2].." but nobody requested it; ignoring.")end end;eventHooks.websocket_failure=eventHooks.websocket_failure or{}eventHooks.websocket_failure[#eventHooks.websocket_failure+1]=function(as)local a_=g2[as[2]]if a_ then a_.status,a_.error="error",as[3]a_.process.eventQueue[#a_.process.eventQueue+1]={"handle_status_change",{id=a_.id,status=a_.status}}return true else syslog.log({level="notice"},"Received WebSocket response for "..as[2].." but nobody requested it; ignoring.")end end;eventHooks.websocket_message=eventHooks.websocket_message or{}eventHooks.websocket_message[#eventHooks.websocket_message+1]=function(as)local a_=g2[as[2]]if a_ then a_.buffer=a_.buffer..as[3]a_.process.eventQueue[#a_.process.eventQueue+1]={"handle_data_ready",{id=a_.id}}return true else syslog.log({level="notice"},"Received WebSocket message for "..as[2].." but nobody requested it; ignoring.")end end;eventHooks.websocket_closed=eventHooks.websocket_closed or{}eventHooks.websocket_closed[#eventHooks.websocket_closed+1]=function(as)local a_=g2[as[2]]if a_ then a_.status="closed"a_.process.eventQueue[#a_.process.eventQueue+1]={"handle_status_change",{id=a_.id,status=a_.status}}g2[as[2]]=nil;return true else syslog.log({level="notice"},"Received WebSocket message for "..as[2].." but it's not open; ignoring.")end end;eventHooks.modem_message=eventHooks.modem_message or{}eventHooks.modem_message[#eventHooks.modem_message+1]=function(as)local a5=false;if g3[as[2]]and(as[3]==g5 or as[3]==65535)and type(as[5])=="table"and type(as[5].nMessageID)=="number"and as[5].nMessageID==as[5].nMessageID and not g6[as[5].nMessageID]and(as[5].nRecipient and as[5].nRecipient==os.computerID()or as[3]==65535)then if g4[as[5].nSender]then for z,i in ipairs(g4[as[5].nSender])do if not i.protocol or i.protocol==as[5].sProtocol then i.buffer[#i.buffer+1]=deepcopy(as[5].message)g6[as[5].nMessageID]=os.clock()+9.5;i.process.eventQueue[#i.process.eventQueue+1]={"handle_data_ready",{id=i.id}}a5=true end end end;if g4[0xFFFFFFFF]then for z,i in ipairs(g4[0xFFFFFFFF])do if not i.protocol or i.protocol==as[5].sProtocol then i.buffer[#i.buffer+1]=deepcopy(as[5].message)g6[as[5].nMessageID]=os.clock()+9.5;i.process.eventQueue[#i.process.eventQueue+1]={"handle_data_ready",{id=i.id}}a5=true end end end;for h,i in pairs(g6)do if i<os.clock()then g6[h]=nil end end end;return a5 end;local g7=http.request;local function g8(process,by)expect.field(by,"encoding","string","nil")expect.field(by,"headers","table","nil")expect.field(by,"method","string","nil")expect.field(by,"redirect","boolean","nil")local a_={status="ready",process=process,id=fB}local br=setmetatable({id=fB},{__name="socket"})fB=fB+1;function br:status()return a_.status,a_.error end;function br:read(n,...)if a_.status~="open"then error("attempt to read from a "..a_.status.." handle",2)end;n=n or"*l"if type(n)~="string"and type(n)~="number"then error("bad argument (expected string or number, got "..type(n)..")",2)end;n=n:gsub("^%*","")if n=="a"then if select("#",...)>0 then return a_.handle.readAll(),self:read(...)else return a_.handle.readAll()end elseif n=="l"then if select("#",...)>0 then return a_.handle.readLine(false),self:read(...)else return a_.handle.readLine(false)end elseif n=="L"then if select("#",...)>0 then return a_.handle.readLine(true),self:read(...)else return a_.handle.readLine(true)end elseif n=="n"then local a0;repeat a0=a_.handle.read(1)if not a0 then return nil end until tonumber(a0)while true do local a9=a_.handle.read(1)if not a9 or not a9:match"%d"then break end;a0=a0 ..a9 end;if select("#",...)>0 then return tonumber(a0),self:read(...)else return tonumber(a0)end elseif type(n)=="number"then if select("#",...)>0 then return a_.handle.read(n),self:read(...)else return a_.handle.read(n)end else error("bad argument (invalid mode '"..n.."')",2)end end;function br:write(...)if a_.status~="ready"then error("attempt to write to a "..a_.status.." handle",2)end;local bd;if select("#",...)>0 then bd=""for z,i in ipairs{...}do bd=bd..tostring(i)end end;local g9=by.url.."#"..a_.id;local bb,o=g7{url=g9,body=bd,headers=by.headers,binary=by.encoding=="binary"or by.encoding==nil,method=by.method,redirect=by.redirect}if bb then g2[g9]=a_;a_.status="connecting"else a_.status,a_.error="error",o end end;function br:close()if a_.status~="open"then error("attempt to close a "..a_.status.." handle",2)end;a_.handle.close()a_.status="closed"end;function br:responseHeaders()if a_.status~="open"then error("attempt to read from a "..a_.status.." handle",2)end;return a_.handle.getResponseHeaders()end;function br:responseCode()if a_.status~="open"then error("attempt to read from a "..a_.status.." handle",2)end;return a_.handle.getResponseCode()end;return br end;local function ga(process,by)expect.field(by,"encoding","string","nil")expect.field(by,"headers","table","nil")local a_={process=process,id=fB,buffer=""}local br=setmetatable({id=fB},{__name="socket"})fB=fB+1;function br:status()return a_.status,a_.error end;function br:read(n,...)if a_.status~="open"then error("attempt to read from a "..a_.status.." handle",2)end;n=n or"*l"if type(n)~="string"and type(n)~="number"then error("bad argument (expected string or number, got "..type(n)..")",2)end;if a_.buffer==""then return nil end;n=n:gsub("^%*","")if n=="a"then local a0=a_.buffer;a_.buffer=""return a0 elseif n=="l"then local a0,a7=a_.buffer:match"^([^\n]*)\n?()"if a0 then a_.buffer=a_.buffer:sub(a7)if select("#",...)>0 then return a0,self:read(...)else return a0 end else return nil end elseif n=="L"then local a0,a7=a_.buffer:match"^([^\n]*\n?)()"if a0 then a_.buffer=a_.buffer:sub(a7)if select("#",...)>0 then return a0,self:read(...)else return a0 end else return nil end elseif n=="n"then local a0,a7=a_.buffer:match"(%d+)()"if a0 then a_.buffer=a_.buffer:sub(a7)if select("#",...)>0 then return tonumber(a0),self:read(...)else return tonumber(a0)end else return nil end elseif type(n)=="number"then local a0=a_.buffer:sub(1,n)a_.buffer=a_.buffer:sub(n+1)if select("#",...)>0 then return a0,self:read(...)else return a0 end else error("bad argument (invalid mode '"..n.."')",2)end end;function br:write(bd,...)if a_.status~="open"then error("attempt to write to a "..a_.status.." handle",2)end;a_.handle.send(tostring(bd),by.encoding=="binary")if select("#",...)>0 then return self:write(...)end end;function br:close()if a_.status~="open"then error("attempt to close a "..a_.status.." handle",2)end;a_.handle.close()a_.status="closed"end;local g9=by.url.."#"..a_.id;local bb,o=http.websocket(g9,by.headers)if bb then g2[g9]=a_;a_.status="connecting"else return nil,o end;return br end;local function gb(process,by)expect.field(by,"device","string","nil")local gc;if by.device then gc={hardware.get(by.device)}else gc={hardware.find("modem")}end;if#gc==0 then error("Could not find a modem",2)end;for z,i in ipairs(gc)do fA(i)if not g3[i]then hardware.call(process,i,"open",g5)hardware.call(process,i,"open",65535)g3[i]=1 else g3[i]=g3[i]+1 end end;local fr=fq(by.url)if not fr.host then error("Missing host",2)end;local dy=ft(fr.host)local a_={process=process,id=fB,buffer={},protocol=fr.scheme:match"rednet%+(.+)"}local br=setmetatable({id=fB},{__name="socket"})fB=fB+1;function br:status()return a_.closed and"closed"or"open"end;function br:read(n,...)if a_.closed then error("attempt to read from a "..a_.status.." handle",2)end;n=n or"*l"if type(n)~="string"and type(n)~="number"then error("bad argument (expected string or number, got "..type(n)..")",2)end;if#a_.buffer==0 then return nil end;n=n:gsub("^%*","")if n=="a"then return table.remove(a_.buffer,1)elseif n=="l"then a_.buffer[1]=tostring(a_.buffer[1])local a0,a7=a_.buffer[1]:match"^([^\n]*)\n?()"if a0 then a_.buffer[1]=a_.buffer[1]:sub(a7)if select("#",...)>0 then return a0,self:read(...)else return a0 end else table.remove(a_.buffer,1)return self:read(n,...)end elseif n=="L"then a_.buffer[1]=tostring(a_.buffer[1])local a0,a7=a_.buffer[1]:match"^([^\n]*\n?)()"if a0 then a_.buffer[1]=a_.buffer[1]:sub(a7)if select("#",...)>0 then return a0,self:read(...)else return a0 end else table.remove(a_.buffer,1)return self:read(n,...)end elseif n=="n"then a_.buffer[1]=tostring(a_.buffer[1])local a0,a7=a_.buffer[1]:match"(%d+)()"if a0 then a_.buffer[1]=a_.buffer[1]:sub(a7)if select("#",...)>0 then return tonumber(a0),self:read(...)else return tonumber(a0)end else table.remove(a_.buffer,1)return self:read(n,...)end elseif type(n)=="number"then local a0=""while#a0<n do a_.buffer[1]=tostring(a_.buffer[1])a0=a0 ..a_.buffer[1]:sub(1,n-#a0)a_.buffer[1]=a_.buffer[1]:sub(n-#a0+1)if a_.buffer[1]==""then table.remove(a_.buffer,1)end;if#a_.buffer==0 then break end end;if select("#",...)>0 then return a0,self:read(...)else return a0 end else error("bad argument (invalid mode '"..n.."')",2)end end;function br:write(bd,...)if a_.closed then error("attempt to write to a "..a_.status.." handle",2)end;local gd=math.random(1,0x7FFFFFFF)local dS={nMessageID=gd,nRecipient=dy,nSender=os.computerID(),message=bd,sProtocol=a_.protocol}if dy==os.computerID()then for z,i in ipairs(gc)do os.queueEvent("modem_message",i.id,g5,g5,dS,0)end else g6[gd]=os.clock()+9.5;for z,i in ipairs(gc)do hardware.call(process,i,"transmit",dy==0xFFFFFFFF and 65535 or dy%65500,g5,dS)hardware.call(process,i,"transmit",65533,g5,dS)end end;if select("#",...)>0 then return self:write(...)end end;function br:close()if a_.closed then error("attempt to close a "..a_.status.." handle",2)end;for z,i in ipairs(gc)do g3[i]=g3[i]-1;if g3[i]==0 then hardware.call(process,i,"close",g5)hardware.call(process,i,"close",65535)g3[i]=nil end end;a_.status="closed"end;return br end;uriSchemes={["https?"]=g8,["wss?"]=ga,["rednet"]=gb,["rednet%+%a+"]=gb,["psp"]=g1}function syscalls.connect(process,ar,by)if type(by)=="string"then by={url=by}end;expect(1,by,"table")expect.field(by,"url","string")local fr=fq(by.url)local br,o;for h,i in pairs(uriSchemes)do if fr.scheme:match(h)then br,o=i(process,by)break end end;if not br and not o then error("Invalid protocol "..fr.scheme)end;if br then for z,i in pairs(br)do if type(i)=="function"then setfenv(i,process.env)debug.protect(i)end end end;return br,o end;function syscalls.listen(process,ar,fr)expect(1,fr,"string")local ge=fq(fr)if http.addListener then if ge.scheme=="http"then http.addListener(ge.port or 80)return elseif ge.scheme=="ws"then http.websocket(ge.port or 80)return end end;if ge.scheme=="psp"then if not ge.port then error("Missing port")end;local fu=ft(ge.host)for h,i in pairs(fC)do if i.up and(fu==0 or i.ip==fu)then hardware.call(process,hardware.get(h),"open",ge.port)end end;local fS={localPort=ge.port,id=fB,status="listening",process=process,nextUpdate=math.huge,retryCount=0,uri=fr,buffer=""}fB=fB+1;fG[ge.port]=fS;return end;error("Invalid protocol "..ge.scheme)end;function syscalls.unlisten(process,ar,fr)end;function syscalls.ipconfig(process,ar,eF,a_)if process.user~="root"then error("Permission denied")end;expect(1,eF,"string")expect(2,a_,"table","nil")local dl=fA(hardware.get(eF))local t=fC[dl.uuid]if not t then if a_ then expect.field(a_,"ip","string","number")expect.field(a_,"netmask","string","number")t={up=true}fC[dl.uuid]=t;hardware.call(KERNEL,dl,"open",0)else return nil end end;if a_ then expect.field(a_,"ip","string","number","nil")expect.field(a_,"netmask","string","number","nil")expect.field(a_,"up","boolean","nil")local gf,gg;if t.ip then for z,i in ipairs(fD[0])do if i.source==bit32.band(t.ip,t.netmask)and i.netmask==t.netmask then gf=i elseif i.source==bit32.bor(bit32.band(t.ip,t.netmask),bit32.bnot(t.netmask))and i.netmask==0xFFFFFFFF then gg=i end end end;if a_.ip then if fE[dl.uuid]then fE[dl.uuid][t.ip]=nil end;if type(a_.ip)=="number"then t.ip=bit32.band(a_.ip,0xFFFFFFFF)else t.ip=ft(a_.ip)end;if gf then gf.source=bit32.band(t.ip,t.netmask)end;if gg then gg.source=bit32.bor(bit32.band(t.ip,t.netmask),bit32.bnot(t.netmask))end;fE[dl.uuid]=fE[dl.uuid]or{}fE[dl.uuid][t.ip]=os.computerID()end;if a_.netmask then if type(a_.netmask)=="number"then t.netmask=fy(a_.netmask)else t.netmask=ft(a_.netmask)end;if gf then gf.source=bit32.band(t.ip,t.netmask)end;if gg then gg.source=bit32.bor(bit32.band(t.ip,t.netmask),bit32.bnot(t.netmask))end end;if a_.up~=nil then t.up=a_.up;if t.up then hardware.call(KERNEL,dl,"open",0)else hardware.call(KERNEL,dl,"close",0)end end;if not gf then fD[0][#fD[0]+1]={source=bit32.band(t.ip,t.netmask),sourceNetmask=t.netmask,action="local",device=dl}end;if not gg then fD[0][#fD[0]+1]={source=bit32.bor(bit32.band(t.ip,t.netmask),bit32.bnot(t.netmask)),sourceNetmask=0xFFFFFFFF,action="broadcast",device=dl}end end;return{ip=fv(t.ip),netmask=fz(t.netmask),up=t.up}end;function syscalls.routelist(process,ar,b)b=expect(1,b,"number","nil")or 1;expect.range(b,0)if not fD[b]then return nil end;local a5={}for w,t in ipairs(fD[b])do a5[w]={source=fv(t.source),sourceNetmask=fz(t.sourceNetmask),action=t.action,device=t.device and hardware.path(t.device),destination=t.destination}end;return a5 end;local gh={unicast=true,broadcast=true,["local"]=true,unreachable=true,prohibit=true,blackhole=true}function syscalls.routeadd(process,ar,by)if process.user~="root"then error("Permission denied")end;expect(1,by,"table")expect.field(by,"source","string","number")expect.field(by,"sourceNetmask","string","number")expect.field(by,"action","string")expect.field(by,"device","string",by.action~="unicast"and by.action~="broadcast"and by.action~="local"and"nil"or nil)expect.field(by,"destination","string",by.action~="unicast"and"nil"or nil)expect.range(expect.field(by,"table","number","nil")or 1,1)by.table=by.table or 1;if not gh[by.action]then error("bad field 'action' (invalid option '"..by.action.."')")end;local t={}if type(by.source)=="number"then t.source=bit32.band(by.source,0xFFFFFFFF)else t.source=ft(by.source)end;if type(by.sourceNetmask)=="number"then t.sourceNetmask=fy(by.sourceNetmask)else t.sourceNetmask=ft(by.sourceNetmask)end;t.source=bit32.band(t.source,t.sourceNetmask)t.action=by.action;t.device=by.device and fA(hardware.get(by.device))t.destination=by.destination and ft(by.destination)fD[by.table]=fD[by.table]or{}for z,i in ipairs(fD[by.table])do if i.source==t.source and i.sourceNetmask==t.sourceNetmask then error("Route already exists")end end;fD[by.table][#fD[by.table]+1]=t end;function syscalls.routedel(process,ar,gi,x,b)if process.user~="root"then error("Permission denied")end;expect(1,gi,"string","number")expect(2,x,"string","number")b=expect(3,b,"number","nil")or 1;expect.range(b,1)if type(x)=="number"then x=fy(x)else x=ft(x)end;if type(gi)=="number"then gi=bit32.band(gi,x)else gi=bit32.band(ft(gi),x)end;if not fD[b]then error("Route table does not exist")end;for w,i in ipairs(fD[b])do if i.source==t.source and i.sourceNetmask==t.sourceNetmask then table.remove(fD[b],w)return end end end;function syscalls.arplist(process,ar,eF)expect(1,eF,"string")local dl=fA(hardware.get(eF))return deepcopy(fE[dl.uuid]or{})end;function syscalls.arpset(process,ar,eF,fu,dy)if process.user~="root"then error("Permission denied")end;expect(1,eF,"string")expect(2,fu,"string","number")expect(3,dy,"number")local dl=fA(hardware.get(eF))if type(fu)=="string"then fu=ft(fu)else fu=bit32.band(fu,0xFFFFFFFF)end;fE[dl.uuid]=fE[dl.uuid]or{}fE[dl.uuid][fu]=dy end;local gj={ping=true,pong=true,unreachable=true,timeout=true}function syscalls.netcontrol(process,ar,fu,gk,o)if process.user~="root"then error("Permission denied")end;expect(1,fu,"string","number")expect(2,gk,"string")expect(3,o,"string","nil")if not gj[gk]then error("bad argument #2 (invalid option '"..gk.."')")end;if type(fu)=="string"then fu=ft(fu)else fu=bit32.band(fu,0xFFFFFFFF)end;fF.send.control({process=process},fu,gk,o)end;function syscalls.netevent(process,ar,d1)if process.user~="root"then error("Permission denied")end;expect(1,d1,"boolean","nil")if d1==true then fH[process]=function(af)process.eventQueue[#process.eventQueue+1]={"network_event",deepcopy(af)}return true end elseif d1==false then fH[process]=nil end;return fH[process]~=nil end;function syscalls.checkuri(process,ar,fr)end;function registerLoopback()local dl=hardware.get("/lo")if dl then fC[dl.uuid]={ip=0x7F000001,netmask=0xFF000000,up=true}fD[0][#fD[0]+1]={source=0x7F000000,sourceNetmask=0xFF000000,action="local",device=dl}fD[0][#fD[0]+1]={source=0x7FFFFFFF,sourceNetmask=0xFFFFFFFF,action="broadcast",device=dl}fE[dl.uuid]=setmetatable({},{__index=function()return os.computerID()end})syslog.log("Configured IP for loopback device")end end;function syscalls.listmodules()local a5={}for h in pairs(modules)do a5[#a5+1]=h end;return a5 end;function syscalls.loadmodule(process,ar,b7)expect(1,b7,"string")if process.user~="root"then error("Could not load kernel module: Permission denied",2)end;local bz=filesystem.stat(process,b7)if bz.type=="directory"then error("Could not load kernel module: Is a directory",2)end;if bz.owner~="root"or bz.worldPermissions.write then error("Insecure permissions set on kernel module, refusing to load",2)end;local m=b7:match"([^%./]+)[^/]*$"syslog.log("Loading kernel module "..m.." from "..b7)local a,o=filesystem.open(process,b7,"rb")if a then local bd=a.readAll()or""a.close()local g,o=load(bd,"@"..b7)if g then local bb,v=pcall(g,b7)if bb then modules[m]=v or true else syslog.log({level="error"},"Kernel module "..m.." threw an error:",v)end else syslog.log({level="error"},"Could not load "..m..":",o)end else syslog.log({level="error"},"Could not open "..b7 ..":",o)end end;function syscalls.unloadmodule(process,ar,m)expect(1,m,"string")if process.user~="root"then error("Could not load kernel module: Permission denied",2)end;if type(modules[m])=="table"and modules[m].unload then modules[m].unload(process,ar)end;modules[m]=nil end;function syscalls.callmodule(process,ar,m,az,...)expect(1,m,"string")expect(2,az,"string")if not modules[m]then error("Module '"..m.."' does not exist",2)elseif type(modules[m])~="table"then error("Module '"..m.."' does not have a callable interface",2)elseif az=="unload"or type(modules[m][az])~="function"then error("Module '"..m.."' does not have a method '"..az.."'",2)end;return modules[m][az](process,ar,...)end;syslog.log("Loading kernel modules from /lib/modules")local bb,gl=pcall(filesystem.list,KERNEL,"/lib/modules")if bb then for z,i in ipairs(gl)do local E=filesystem.combine("/lib/modules",i)local bz=filesystem.stat(KERNEL,E)if bz.type~="directory"then local bb,o=pcall(syscalls.loadmodule,KERNEL,nil,E)if not bb then syslog.log({level="error"},"Could not load module from "..E..": "..o)end end end else syslog.log({level="notice"},"Could not open /lib/modules:",gl)end;xpcall(hardware.register,function(error)panic("An error occurred while registering devices: "..error)end,deviceTreeRoot,rootDriver)local aq={n=0}local gm=processes[syscalls.fork(KERNEL,nil,function()end,"init")]local gn=gm.id;local go,gp;if args.init then go,gp=pcall(syscalls.exec,gm,nil,args.initrd and"/init"or args.init)end;if not go then syslog.log({level="error",process=0},"Could not load init:",gp)syslog.log("Could not find provided init, trying default locations")for z,i in ipairs{"/sbin/init","/etc/init","/bin/init","/bin/sh"}do syslog.log("Trying",i)go,gp=pcall(syscalls.exec,gm,nil,i)if not go then syslog.log({level="error",process=0},"Could not load init:",gp)end;if go then break end end;if not go then panic("No working init found")end end;syslog.log("Starting init from "..processes[gn].name)local au=false;eventHooks.key=eventHooks.key or{}eventHooks.key[#eventHooks.key+1]=function(as)if keysHeld.ctrl and keysHeld.shift and as[2]==keys.f10 then term.clear()term.setCursorPos(1,1)term.write("Entering debug console.")local q=2;local aT=true;term.setCursorPos(1,q)while aT do local ak=""local ag,ah=term.getSize()term.write("lua> ")term.setCursorBlink(true)while true do local as={coroutine.yield()}if as[1]=="char"or as[1]=="paste"then ak=ak..as[2]term.write(as[2])elseif as[1]=="key"then if as[2]==keys.backspace and#ak>0 then ak=ak:sub(1,-2)term.setCursorPos(term.getCursorPos()-1,q)term.write(" ")term.setCursorPos(term.getCursorPos()-1,q)elseif as[2]==keys.enter then break end end end;q=q+1;if q>ah then q=q-1;term.scroll(1)end;term.setCursorPos(1,q)local g,o=load("return "..ak,"=lua","t",setmetatable({exit=function()aT=false end},{__index=_G}))if not g then g,o=load(ak,"=lua","t",setmetatable({exit=function()aT=false end},{__index=_G}))end;if g then local v=table.pack(pcall(g))if v[1]then for w=2,v.n do term.write(tostring(v[w]))q=q+1;if q>ah then q=q-1;term.scroll(1)end;term.setCursorPos(1,q)end else term.setTextColor(16384)term.write(v[2])term.setTextColor(1)q=q+1;if q>ah then q=q-1;term.scroll(1)end;term.setCursorPos(1,q)end else term.setTextColor(16384)term.write(o)term.setTextColor(1)q=q+1;if q>ah then q=q-1;term.scroll(1)end;term.setCursorPos(1,q)end end;term.setCursorBlink(false)term.clear()terminal.redraw(currentTTY,true)end end;local gq={char=true,key=true,key_up=true,mouse_click=true,mouse_up=true,mouse_drag=true,mouse_scroll=true,paste=true}local bb,o=xpcall(function()while processes[gn]do if not au then os.queueEvent("__event_queue_back")end;while true do local as=table.pack(coroutine.yield())local m=as[1]if m=="__event_queue_back"then break end;local gr=false;if eventHooks[m]then for z,i in ipairs(eventHooks[m])do gr=i(as)or gr end end;if eventParameterMap[m]then local aw={}for w=2,#eventParameterMap[m]+1 do aw[eventParameterMap[m][w-1]]=as[w]end;if m=="key"or m=="key_up"then aw.keycode=keymap[aw.keycode]aw.ctrlHeld=keysHeld.ctrl;aw.altHeld=keysHeld.alt;aw.shiftHeld=keysHeld.shift end;if gq[m]and currentTTY.frontmostProcess then currentTTY.frontmostProcess.eventQueue[#currentTTY.frontmostProcess.eventQueue+1]={m,aw}gr=true elseif m=="timer"or m=="alarm"then local gs;if m=="timer"then gs=timerMap[as[2]]else gs,aw.id=alarmMap[as[2]],bit32.bor(aw.id,0x80000000)end;if gs then gs.eventQueue[#gs.eventQueue+1],gr={m,aw},true end end end;if au and gr then break end end;au=true;for cI,process in pairs(processes)do if cI~=0 and not process.paused then local f5,as=false,nil;local at=true;for f6,ar in pairs(process.threads)do if not f5 and ar.status=="suspended"then as=table.remove(process.eventQueue,1)f5=true end;if as or ar.status~="suspended"then at,au=executeThread(process,ar,as or aq,at,au)else at=false end end;if at then process.isDead=true;if cI==gn then init_retval=process.lastReturnValue.value or process.lastReturnValue.error elseif processes[process.parent]then process.lastReturnValue.id=cI;processes[process.parent].eventQueue[#processes[process.parent].eventQueue+1]={"process_complete",process.lastReturnValue}end;reap_process(process)processes[cI]=nil;au=false end end end;terminal.redraw(currentTTY)end end,debug.traceback)if not bb then syslog.log({level="critical",traceback=true},o)end;if postkill then postkill()end;if init_retval~=nil then syslog.log({level=4},"init exited with result",init_retval)end;panic("init program exited")
